{"sha": "bc37d9a29a50bb8164651ec90d89d1742d153f09", "node_id": "C_kwDOAAsO6NoAKGJjMzdkOWEyOWE1MGJiODE2NDY1MWVjOTBkODlkMTc0MmQxNTNmMDk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-22T12:23:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-22T12:23:58Z"}, "message": "Merge #10832\n\n10832: internal: Split parts of `ide_db::call_info` off into `ide` r=Veykril a=Veykril\n\n`call_info` itself is just an ide feature and thus should not reside in `ide_db` itself.\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "84b23e085a838bcbf0ef54b2debe4e699b3699dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84b23e085a838bcbf0ef54b2debe4e699b3699dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc37d9a29a50bb8164651ec90d89d1742d153f09", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhm4veCRBK7hj4Ov3rIwAAiL4IAIWoFwGRF2P+d1NrCexFAM3h\nSCcmephl/PM3DcVYgLLW4qjiTCPcG24KI7nlSHhz7KHKX4N3KWAtMC+EfF1hHXU6\ny8wvWRFa+9xY8uDrtKzXS9K2MKtpHvw7fzEpq7yuQfiNl4wWOZT6XBryHuycMWZ9\nvPoaGrkFPbAIbxWAC8Ijm4QoTHlVg+FnJOY9da2qWENEGuRmg0Z9nD22Hsxm3wTm\nOyGjX14X2rm0buUltFmoQruo7obDF8+o5MioEUizW1FS9Qlkvam21eVcozBZzna9\n/uuS7AgU0tXYpZtf7Gdg1Pd32NMC1oc5L8jylT0khAuzXrpdladmXF8ISfmCKcg=\n=z045\n-----END PGP SIGNATURE-----\n", "payload": "tree 84b23e085a838bcbf0ef54b2debe4e699b3699dd\nparent c189555d988ea0a2732e582b1cd2145a06d14c78\nparent 77f08d0fc3387beb63543510f0fbe47a516857b2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1637583838 +0000\ncommitter GitHub <noreply@github.com> 1637583838 +0000\n\nMerge #10832\n\n10832: internal: Split parts of `ide_db::call_info` off into `ide` r=Veykril a=Veykril\n\n`call_info` itself is just an ide feature and thus should not reside in `ide_db` itself.\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc37d9a29a50bb8164651ec90d89d1742d153f09", "html_url": "https://github.com/rust-lang/rust/commit/bc37d9a29a50bb8164651ec90d89d1742d153f09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc37d9a29a50bb8164651ec90d89d1742d153f09/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c189555d988ea0a2732e582b1cd2145a06d14c78", "url": "https://api.github.com/repos/rust-lang/rust/commits/c189555d988ea0a2732e582b1cd2145a06d14c78", "html_url": "https://github.com/rust-lang/rust/commit/c189555d988ea0a2732e582b1cd2145a06d14c78"}, {"sha": "77f08d0fc3387beb63543510f0fbe47a516857b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/77f08d0fc3387beb63543510f0fbe47a516857b2", "html_url": "https://github.com/rust-lang/rust/commit/77f08d0fc3387beb63543510f0fbe47a516857b2"}], "stats": {"total": 1517, "additions": 765, "deletions": 752}, "files": [{"sha": "7568faa6bd535bde210552da7a717ee4c28166d0", "filename": "crates/ide/src/call_info.rs", "status": "added", "additions": 679, "deletions": 0, "changes": 679, "blob_url": "https://github.com/rust-lang/rust/blob/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_info.rs?ref=bc37d9a29a50bb8164651ec90d89d1742d153f09", "patch": "@@ -0,0 +1,679 @@\n+//! This module provides primitives for tracking the information about a call site.\n+\n+use either::Either;\n+use hir::{HasAttrs, HirDisplay, Semantics};\n+use ide_db::{active_parameter::callable_for_token, base_db::FilePosition};\n+use stdx::format_to;\n+use syntax::{algo, AstNode, Direction, TextRange, TextSize};\n+\n+use crate::RootDatabase;\n+\n+/// Contains information about a call site. Specifically the\n+/// `FunctionSignature`and current parameter.\n+#[derive(Debug)]\n+pub struct CallInfo {\n+    pub doc: Option<String>,\n+    pub signature: String,\n+    pub active_parameter: Option<usize>,\n+    parameters: Vec<TextRange>,\n+}\n+\n+impl CallInfo {\n+    pub fn parameter_labels(&self) -> impl Iterator<Item = &str> + '_ {\n+        self.parameters.iter().map(move |&it| &self.signature[it])\n+    }\n+\n+    pub fn parameter_ranges(&self) -> &[TextRange] {\n+        &self.parameters\n+    }\n+\n+    fn push_param(&mut self, param: &str) {\n+        if !self.signature.ends_with('(') {\n+            self.signature.push_str(\", \");\n+        }\n+        let start = TextSize::of(&self.signature);\n+        self.signature.push_str(param);\n+        let end = TextSize::of(&self.signature);\n+        self.parameters.push(TextRange::new(start, end))\n+    }\n+}\n+\n+/// Computes parameter information for the given call expression.\n+pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<CallInfo> {\n+    let sema = Semantics::new(db);\n+    let file = sema.parse(position.file_id);\n+    let file = file.syntax();\n+    let token = file\n+        .token_at_offset(position.offset)\n+        .left_biased()\n+        // if the cursor is sandwiched between two space tokens and the call is unclosed\n+        // this prevents us from leaving the CallExpression\n+        .and_then(|tok| algo::skip_trivia_token(tok, Direction::Prev))?;\n+    let token = sema.descend_into_macros_single(token);\n+\n+    let (callable, active_parameter) = callable_for_token(&sema, token)?;\n+\n+    let mut res =\n+        CallInfo { doc: None, signature: String::new(), parameters: vec![], active_parameter };\n+\n+    match callable.kind() {\n+        hir::CallableKind::Function(func) => {\n+            res.doc = func.docs(db).map(|it| it.into());\n+            format_to!(res.signature, \"fn {}\", func.name(db));\n+        }\n+        hir::CallableKind::TupleStruct(strukt) => {\n+            res.doc = strukt.docs(db).map(|it| it.into());\n+            format_to!(res.signature, \"struct {}\", strukt.name(db));\n+        }\n+        hir::CallableKind::TupleEnumVariant(variant) => {\n+            res.doc = variant.docs(db).map(|it| it.into());\n+            format_to!(\n+                res.signature,\n+                \"enum {}::{}\",\n+                variant.parent_enum(db).name(db),\n+                variant.name(db)\n+            );\n+        }\n+        hir::CallableKind::Closure => (),\n+    }\n+\n+    res.signature.push('(');\n+    {\n+        if let Some(self_param) = callable.receiver_param(db) {\n+            format_to!(res.signature, \"{}\", self_param)\n+        }\n+        let mut buf = String::new();\n+        for (pat, ty) in callable.params(db) {\n+            buf.clear();\n+            if let Some(pat) = pat {\n+                match pat {\n+                    Either::Left(_self) => format_to!(buf, \"self: \"),\n+                    Either::Right(pat) => format_to!(buf, \"{}: \", pat),\n+                }\n+            }\n+            format_to!(buf, \"{}\", ty.display(db));\n+            res.push_param(&buf);\n+        }\n+    }\n+    res.signature.push(')');\n+\n+    match callable.kind() {\n+        hir::CallableKind::Function(_) | hir::CallableKind::Closure => {\n+            let ret_type = callable.return_type();\n+            if !ret_type.is_unit() {\n+                format_to!(res.signature, \" -> {}\", ret_type.display(db));\n+            }\n+        }\n+        hir::CallableKind::TupleStruct(_) | hir::CallableKind::TupleEnumVariant(_) => {}\n+    }\n+    Some(res)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::{expect, Expect};\n+    use ide_db::base_db::{fixture::ChangeFixture, FilePosition};\n+\n+    use crate::RootDatabase;\n+\n+    /// Creates analysis from a multi-file fixture, returns positions marked with $0.\n+    pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n+        let change_fixture = ChangeFixture::parse(ra_fixture);\n+        let mut database = RootDatabase::default();\n+        database.apply_change(change_fixture.change);\n+        let (file_id, range_or_offset) =\n+            change_fixture.file_position.expect(\"expected a marker ($0)\");\n+        let offset = range_or_offset.expect_offset();\n+        (database, FilePosition { file_id, offset })\n+    }\n+\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let (db, position) = position(ra_fixture);\n+        let call_info = crate::call_info::call_info(&db, position);\n+        let actual = match call_info {\n+            Some(call_info) => {\n+                let docs = match &call_info.doc {\n+                    None => \"\".to_string(),\n+                    Some(docs) => format!(\"{}\\n------\\n\", docs.as_str()),\n+                };\n+                let params = call_info\n+                    .parameter_labels()\n+                    .enumerate()\n+                    .map(|(i, param)| {\n+                        if Some(i) == call_info.active_parameter {\n+                            format!(\"<{}>\", param)\n+                        } else {\n+                            param.to_string()\n+                        }\n+                    })\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n+                format!(\"{}{}\\n({})\\n\", docs, call_info.signature, params)\n+            }\n+            None => String::new(),\n+        };\n+        expect.assert_eq(&actual);\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_two_args() {\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo($03, ); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3$0, ); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3,$0 ); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (x: u32, <y: u32>)\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3, $0); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (x: u32, <y: u32>)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_two_args_empty() {\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo($0); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_two_args_first_generics() {\n+        check(\n+            r#\"\n+fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n+    where T: Copy + Display, U: Debug\n+{ x + y }\n+\n+fn bar() { foo($03, ); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: i32, y: {unknown}) -> u32\n+                (<x: i32>, y: {unknown})\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_no_params() {\n+        check(\n+            r#\"\n+fn foo<T>() -> T where T: Copy + Display {}\n+fn bar() { foo($0); }\n+\"#,\n+            expect![[r#\"\n+                fn foo() -> {unknown}\n+                ()\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_for_impl() {\n+        check(\n+            r#\"\n+struct F;\n+impl F { pub fn new() { } }\n+fn bar() {\n+    let _ : F = F::new($0);\n+}\n+\"#,\n+            expect![[r#\"\n+                fn new()\n+                ()\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_for_method_self() {\n+        check(\n+            r#\"\n+struct S;\n+impl S { pub fn do_it(&self) {} }\n+\n+fn bar() {\n+    let s: S = S;\n+    s.do_it($0);\n+}\n+\"#,\n+            expect![[r#\"\n+                fn do_it(&self)\n+                ()\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_for_method_with_arg() {\n+        check(\n+            r#\"\n+struct S;\n+impl S {\n+    fn foo(&self, x: i32) {}\n+}\n+\n+fn main() { S.foo($0); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(&self, x: i32)\n+                (<x: i32>)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_for_generic_method() {\n+        check(\n+            r#\"\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn foo(&self, x: T) {}\n+}\n+\n+fn main() { S(1u32).foo($0); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(&self, x: u32)\n+                (<x: u32>)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_for_method_with_arg_as_assoc_fn() {\n+        check(\n+            r#\"\n+struct S;\n+impl S {\n+    fn foo(&self, x: i32) {}\n+}\n+\n+fn main() { S::foo($0); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(self: &S, x: i32)\n+                (<self: &S>, x: i32)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_with_docs_simple() {\n+        check(\n+            r#\"\n+/// test\n+// non-doc-comment\n+fn foo(j: u32) -> u32 {\n+    j\n+}\n+\n+fn bar() {\n+    let _ = foo($0);\n+}\n+\"#,\n+            expect![[r#\"\n+            test\n+            ------\n+            fn foo(j: u32) -> u32\n+            (<j: u32>)\n+        \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_with_docs() {\n+        check(\n+            r#\"\n+/// Adds one to the number given.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let five = 5;\n+///\n+/// assert_eq!(6, my_crate::add_one(5));\n+/// ```\n+pub fn add_one(x: i32) -> i32 {\n+    x + 1\n+}\n+\n+pub fn do() {\n+    add_one($0\n+}\"#,\n+            expect![[r##\"\n+            Adds one to the number given.\n+\n+            # Examples\n+\n+            ```\n+            let five = 5;\n+\n+            assert_eq!(6, my_crate::add_one(5));\n+            ```\n+            ------\n+            fn add_one(x: i32) -> i32\n+            (<x: i32>)\n+        \"##]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_with_docs_impl() {\n+        check(\n+            r#\"\n+struct addr;\n+impl addr {\n+    /// Adds one to the number given.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let five = 5;\n+    ///\n+    /// assert_eq!(6, my_crate::add_one(5));\n+    /// ```\n+    pub fn add_one(x: i32) -> i32 {\n+        x + 1\n+    }\n+}\n+\n+pub fn do_it() {\n+    addr {};\n+    addr::add_one($0);\n+}\n+\"#,\n+            expect![[r##\"\n+            Adds one to the number given.\n+\n+            # Examples\n+\n+            ```\n+            let five = 5;\n+\n+            assert_eq!(6, my_crate::add_one(5));\n+            ```\n+            ------\n+            fn add_one(x: i32) -> i32\n+            (<x: i32>)\n+        \"##]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_with_docs_from_actix() {\n+        check(\n+            r#\"\n+struct WriteHandler<E>;\n+\n+impl<E> WriteHandler<E> {\n+    /// Method is called when writer emits error.\n+    ///\n+    /// If this method returns `ErrorAction::Continue` writer processing\n+    /// continues otherwise stream processing stops.\n+    fn error(&mut self, err: E, ctx: &mut Self::Context) -> Running {\n+        Running::Stop\n+    }\n+\n+    /// Method is called when writer finishes.\n+    ///\n+    /// By default this method stops actor's `Context`.\n+    fn finished(&mut self, ctx: &mut Self::Context) {\n+        ctx.stop()\n+    }\n+}\n+\n+pub fn foo(mut r: WriteHandler<()>) {\n+    r.finished($0);\n+}\n+\"#,\n+            expect![[r#\"\n+            Method is called when writer finishes.\n+\n+            By default this method stops actor's `Context`.\n+            ------\n+            fn finished(&mut self, ctx: &mut {unknown})\n+            (<ctx: &mut {unknown}>)\n+        \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn call_info_bad_offset() {\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo $0 (3, ); }\n+\"#,\n+            expect![[\"\"]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_nested_method_in_lambda() {\n+        check(\n+            r#\"\n+struct Foo;\n+impl Foo { fn bar(&self, _: u32) { } }\n+\n+fn bar(_: u32) { }\n+\n+fn main() {\n+    let foo = Foo;\n+    std::thread::spawn(move || foo.bar($0));\n+}\n+\"#,\n+            expect![[r#\"\n+                fn bar(&self, _: u32)\n+                (<_: u32>)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn works_for_tuple_structs() {\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32);\n+fn main() {\n+    let s = S(0, $0);\n+}\n+\"#,\n+            expect![[r#\"\n+            A cool tuple struct\n+            ------\n+            struct S(u32, i32)\n+            (u32, <i32>)\n+        \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn generic_struct() {\n+        check(\n+            r#\"\n+struct S<T>(T);\n+fn main() {\n+    let s = S($0);\n+}\n+\"#,\n+            expect![[r#\"\n+                struct S({unknown})\n+                (<{unknown}>)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn works_for_enum_variants() {\n+        check(\n+            r#\"\n+enum E {\n+    /// A Variant\n+    A(i32),\n+    /// Another\n+    B,\n+    /// And C\n+    C { a: i32, b: i32 }\n+}\n+\n+fn main() {\n+    let a = E::A($0);\n+}\n+\"#,\n+            expect![[r#\"\n+            A Variant\n+            ------\n+            enum E::A(i32)\n+            (<i32>)\n+        \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn cant_call_struct_record() {\n+        check(\n+            r#\"\n+struct S { x: u32, y: i32 }\n+fn main() {\n+    let s = S($0);\n+}\n+\"#,\n+            expect![[\"\"]],\n+        );\n+    }\n+\n+    #[test]\n+    fn cant_call_enum_record() {\n+        check(\n+            r#\"\n+enum E {\n+    /// A Variant\n+    A(i32),\n+    /// Another\n+    B,\n+    /// And C\n+    C { a: i32, b: i32 }\n+}\n+\n+fn main() {\n+    let a = E::C($0);\n+}\n+\"#,\n+            expect![[\"\"]],\n+        );\n+    }\n+\n+    #[test]\n+    fn fn_signature_for_call_in_macro() {\n+        check(\n+            r#\"\n+macro_rules! id { ($($tt:tt)*) => { $($tt)* } }\n+fn foo() { }\n+id! {\n+    fn bar() { foo($0); }\n+}\n+\"#,\n+            expect![[r#\"\n+                fn foo()\n+                ()\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn call_info_for_lambdas() {\n+        check(\n+            r#\"\n+struct S;\n+fn foo(s: S) -> i32 { 92 }\n+fn main() {\n+    (|s| foo(s))($0)\n+}\n+        \"#,\n+            expect![[r#\"\n+                (S) -> i32\n+                (<S>)\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn call_info_for_fn_ptr() {\n+        check(\n+            r#\"\n+fn main(f: fn(i32, f64) -> char) {\n+    f(0, $0)\n+}\n+        \"#,\n+            expect![[r#\"\n+                (i32, f64) -> char\n+                (i32, <f64>)\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn call_info_for_unclosed_call() {\n+        check(\n+            r#\"\n+fn foo(foo: u32, bar: u32) {}\n+fn main() {\n+    foo($0\n+}\"#,\n+            expect![[r#\"\n+            fn foo(foo: u32, bar: u32)\n+            (<foo: u32>, bar: u32)\n+        \"#]],\n+        );\n+        // check with surrounding space\n+        check(\n+            r#\"\n+fn foo(foo: u32, bar: u32) {}\n+fn main() {\n+    foo( $0\n+}\"#,\n+            expect![[r#\"\n+            fn foo(foo: u32, bar: u32)\n+            (<foo: u32>, bar: u32)\n+        \"#]],\n+        )\n+    }\n+}"}, {"sha": "034a51179331b83062864172b1e8124fccefdc44", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=bc37d9a29a50bb8164651ec90d89d1742d153f09", "patch": "@@ -24,6 +24,7 @@ mod navigation_target;\n \n mod annotations;\n mod call_hierarchy;\n+mod call_info;\n mod doc_links;\n mod highlight_related;\n mod expand_macro;\n@@ -73,6 +74,7 @@ use crate::navigation_target::{ToNav, TryToNav};\n pub use crate::{\n     annotations::{Annotation, AnnotationConfig, AnnotationKind},\n     call_hierarchy::CallItem,\n+    call_info::CallInfo,\n     expand_macro::ExpandedMacro,\n     file_structure::{StructureNode, StructureNodeKind},\n     folding_ranges::{Fold, FoldKind},\n@@ -106,7 +108,6 @@ pub use ide_db::{\n         Cancelled, Change, CrateGraph, CrateId, Edition, FileId, FilePosition, FileRange,\n         SourceRoot, SourceRootId,\n     },\n-    call_info::CallInfo,\n     label::Label,\n     line_index::{LineCol, LineColUtf16, LineIndex},\n     search::{ReferenceCategory, SearchScope},\n@@ -434,7 +435,7 @@ impl Analysis {\n \n     /// Computes parameter information for the given call expression.\n     pub fn call_info(&self, position: FilePosition) -> Cancellable<Option<CallInfo>> {\n-        self.with_db(|db| ide_db::call_info::call_info(db, position))\n+        self.with_db(|db| call_info::call_info(db, position))\n     }\n \n     /// Computes call hierarchy candidates for the given file position."}, {"sha": "29eef546cef700bd1033dd90732a6ef6673232b0", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=bc37d9a29a50bb8164651ec90d89d1742d153f09", "patch": "@@ -3,18 +3,18 @@\n \n use std::collections::HashMap;\n \n-use hir::Semantics;\n-use hir::{db::HirDatabase, Crate, Module};\n-use ide_db::base_db::{FileId, FileRange, SourceDatabaseExt};\n-use ide_db::defs::Definition;\n-use ide_db::RootDatabase;\n+use hir::{db::HirDatabase, Crate, Module, Semantics};\n+use ide_db::{\n+    base_db::{FileId, FileRange, SourceDatabaseExt},\n+    defs::Definition,\n+    RootDatabase,\n+};\n use rustc_hash::FxHashSet;\n-use syntax::{AstNode, SyntaxKind::*, T};\n-use syntax::{SyntaxToken, TextRange};\n+use syntax::{AstNode, SyntaxKind::*, SyntaxToken, TextRange, T};\n \n-use crate::hover::hover_for_definition;\n use crate::{\n-    Analysis, Fold, HoverConfig, HoverDocFormat, HoverResult, InlayHint, InlayHintsConfig, TryToNav,\n+    hover::hover_for_definition, Analysis, Fold, HoverConfig, HoverDocFormat, HoverResult,\n+    InlayHint, InlayHintsConfig, TryToNav,\n };\n \n /// A static representation of fully analyzed source code."}, {"sha": "543a7884825c4d2e536979cf82c96ea9f93b0f82", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=bc37d9a29a50bb8164651ec90d89d1742d153f09", "patch": "@@ -5,7 +5,8 @@ use std::mem;\n use either::Either;\n use hir::{InFile, Semantics};\n use ide_db::{\n-    call_info::ActiveParameter, defs::Definition, helpers::rust_doc::is_rust_fence, SymbolKind,\n+    active_parameter::ActiveParameter, defs::Definition, helpers::rust_doc::is_rust_fence,\n+    SymbolKind,\n };\n use syntax::{\n     ast::{self, AstNode, IsString},"}, {"sha": "d9ddd9f2aeb6da4edd9a78b282e6716a731a8591", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=bc37d9a29a50bb8164651ec90d89d1742d153f09", "patch": "@@ -3,8 +3,8 @@\n use base_db::SourceDatabaseExt;\n use hir::{Local, Name, ScopeDef, Semantics, SemanticsScope, Type, TypeInfo};\n use ide_db::{\n+    active_parameter::ActiveParameter,\n     base_db::{FilePosition, SourceDatabase},\n-    call_info::ActiveParameter,\n     RootDatabase,\n };\n use syntax::{"}, {"sha": "47bd7aa9798fc78043d598f269b20e94e4269a89", "filename": "crates/ide_db/src/active_parameter.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide_db%2Fsrc%2Factive_parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide_db%2Fsrc%2Factive_parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Factive_parameter.rs?ref=bc37d9a29a50bb8164651ec90d89d1742d153f09", "patch": "@@ -0,0 +1,70 @@\n+//! This module provides functionality for querying callable information about a token.\n+\n+use either::Either;\n+use hir::{Semantics, Type};\n+use syntax::{\n+    ast::{self, HasArgList, HasName},\n+    AstNode, SyntaxToken,\n+};\n+\n+use crate::RootDatabase;\n+\n+#[derive(Debug)]\n+pub struct ActiveParameter {\n+    pub ty: Type,\n+    pub pat: Either<ast::SelfParam, ast::Pat>,\n+}\n+\n+impl ActiveParameter {\n+    /// Returns information about the call argument this token is part of.\n+    pub fn at_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Self> {\n+        let (signature, active_parameter) = callable_for_token(sema, token)?;\n+\n+        let idx = active_parameter?;\n+        let mut params = signature.params(sema.db);\n+        if !(idx < params.len()) {\n+            cov_mark::hit!(too_many_arguments);\n+            return None;\n+        }\n+        let (pat, ty) = params.swap_remove(idx);\n+        pat.map(|pat| ActiveParameter { ty, pat })\n+    }\n+\n+    pub fn ident(&self) -> Option<ast::Name> {\n+        self.pat.as_ref().right().and_then(|param| match param {\n+            ast::Pat::IdentPat(ident) => ident.name(),\n+            _ => None,\n+        })\n+    }\n+}\n+\n+/// Returns a [`hir::Callable`] this token is a part of and its argument index of said callable.\n+pub fn callable_for_token(\n+    sema: &Semantics<RootDatabase>,\n+    token: SyntaxToken,\n+) -> Option<(hir::Callable, Option<usize>)> {\n+    // Find the calling expression and it's NameRef\n+    let parent = token.parent()?;\n+    let calling_node = parent.ancestors().filter_map(ast::CallableExpr::cast).find(|it| {\n+        it.arg_list()\n+            .map_or(false, |it| it.syntax().text_range().contains(token.text_range().start()))\n+    })?;\n+\n+    let callable = match &calling_node {\n+        ast::CallableExpr::Call(call) => {\n+            let expr = call.expr()?;\n+            sema.type_of_expr(&expr)?.adjusted().as_callable(sema.db)\n+        }\n+        ast::CallableExpr::MethodCall(call) => sema.resolve_method_call_as_callable(call),\n+    }?;\n+    let active_param = if let Some(arg_list) = calling_node.arg_list() {\n+        let param = arg_list\n+            .args()\n+            .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+            .count();\n+        Some(param)\n+    } else {\n+        None\n+    };\n+    Some((callable, active_param))\n+}"}, {"sha": "9e15702c5fb8a4ccd12b918fc9b31e36edba1912", "filename": "crates/ide_db/src/call_info.rs", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/c189555d988ea0a2732e582b1cd2145a06d14c78/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189555d988ea0a2732e582b1cd2145a06d14c78/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info.rs?ref=c189555d988ea0a2732e582b1cd2145a06d14c78", "patch": "@@ -1,174 +0,0 @@\n-//! This crate provides primitives for tracking the information about a call site.\n-use base_db::FilePosition;\n-use either::Either;\n-use hir::{HasAttrs, HirDisplay, Semantics, Type};\n-use stdx::format_to;\n-use syntax::{\n-    algo,\n-    ast::{self, HasArgList, HasName},\n-    AstNode, Direction, SyntaxToken, TextRange, TextSize,\n-};\n-\n-use crate::RootDatabase;\n-\n-/// Contains information about a call site. Specifically the\n-/// `FunctionSignature`and current parameter.\n-#[derive(Debug)]\n-pub struct CallInfo {\n-    pub doc: Option<String>,\n-    pub signature: String,\n-    pub active_parameter: Option<usize>,\n-    parameters: Vec<TextRange>,\n-}\n-\n-impl CallInfo {\n-    pub fn parameter_labels(&self) -> impl Iterator<Item = &str> + '_ {\n-        self.parameters.iter().map(move |&it| &self.signature[it])\n-    }\n-\n-    pub fn parameter_ranges(&self) -> &[TextRange] {\n-        &self.parameters\n-    }\n-\n-    fn push_param(&mut self, param: &str) {\n-        if !self.signature.ends_with('(') {\n-            self.signature.push_str(\", \");\n-        }\n-        let start = TextSize::of(&self.signature);\n-        self.signature.push_str(param);\n-        let end = TextSize::of(&self.signature);\n-        self.parameters.push(TextRange::new(start, end))\n-    }\n-}\n-\n-/// Computes parameter information for the given call expression.\n-pub fn call_info(db: &RootDatabase, position: FilePosition) -> Option<CallInfo> {\n-    let sema = Semantics::new(db);\n-    let file = sema.parse(position.file_id);\n-    let file = file.syntax();\n-    let token = file\n-        .token_at_offset(position.offset)\n-        .left_biased()\n-        // if the cursor is sandwiched between two space tokens and the call is unclosed\n-        // this prevents us from leaving the CallExpression\n-        .and_then(|tok| algo::skip_trivia_token(tok, Direction::Prev))?;\n-    let token = sema.descend_into_macros_single(token);\n-\n-    let (callable, active_parameter) = call_info_impl(&sema, token)?;\n-\n-    let mut res =\n-        CallInfo { doc: None, signature: String::new(), parameters: vec![], active_parameter };\n-\n-    match callable.kind() {\n-        hir::CallableKind::Function(func) => {\n-            res.doc = func.docs(db).map(|it| it.into());\n-            format_to!(res.signature, \"fn {}\", func.name(db));\n-        }\n-        hir::CallableKind::TupleStruct(strukt) => {\n-            res.doc = strukt.docs(db).map(|it| it.into());\n-            format_to!(res.signature, \"struct {}\", strukt.name(db));\n-        }\n-        hir::CallableKind::TupleEnumVariant(variant) => {\n-            res.doc = variant.docs(db).map(|it| it.into());\n-            format_to!(\n-                res.signature,\n-                \"enum {}::{}\",\n-                variant.parent_enum(db).name(db),\n-                variant.name(db)\n-            );\n-        }\n-        hir::CallableKind::Closure => (),\n-    }\n-\n-    res.signature.push('(');\n-    {\n-        if let Some(self_param) = callable.receiver_param(db) {\n-            format_to!(res.signature, \"{}\", self_param)\n-        }\n-        let mut buf = String::new();\n-        for (pat, ty) in callable.params(db) {\n-            buf.clear();\n-            if let Some(pat) = pat {\n-                match pat {\n-                    Either::Left(_self) => format_to!(buf, \"self: \"),\n-                    Either::Right(pat) => format_to!(buf, \"{}: \", pat),\n-                }\n-            }\n-            format_to!(buf, \"{}\", ty.display(db));\n-            res.push_param(&buf);\n-        }\n-    }\n-    res.signature.push(')');\n-\n-    match callable.kind() {\n-        hir::CallableKind::Function(_) | hir::CallableKind::Closure => {\n-            let ret_type = callable.return_type();\n-            if !ret_type.is_unit() {\n-                format_to!(res.signature, \" -> {}\", ret_type.display(db));\n-            }\n-        }\n-        hir::CallableKind::TupleStruct(_) | hir::CallableKind::TupleEnumVariant(_) => {}\n-    }\n-    Some(res)\n-}\n-\n-fn call_info_impl(\n-    sema: &Semantics<RootDatabase>,\n-    token: SyntaxToken,\n-) -> Option<(hir::Callable, Option<usize>)> {\n-    // Find the calling expression and it's NameRef\n-    let parent = token.parent()?;\n-    let calling_node = parent.ancestors().filter_map(ast::CallableExpr::cast).find(|it| {\n-        it.arg_list()\n-            .map_or(false, |it| it.syntax().text_range().contains(token.text_range().start()))\n-    })?;\n-\n-    let callable = match &calling_node {\n-        ast::CallableExpr::Call(call) => {\n-            let expr = call.expr()?;\n-            sema.type_of_expr(&expr)?.adjusted().as_callable(sema.db)\n-        }\n-        ast::CallableExpr::MethodCall(call) => sema.resolve_method_call_as_callable(call),\n-    }?;\n-    let active_param = if let Some(arg_list) = calling_node.arg_list() {\n-        let param = arg_list\n-            .args()\n-            .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n-            .count();\n-        Some(param)\n-    } else {\n-        None\n-    };\n-    Some((callable, active_param))\n-}\n-\n-#[derive(Debug)]\n-pub struct ActiveParameter {\n-    pub ty: Type,\n-    pub pat: Either<ast::SelfParam, ast::Pat>,\n-}\n-\n-impl ActiveParameter {\n-    pub fn at_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Self> {\n-        let (signature, active_parameter) = call_info_impl(sema, token)?;\n-\n-        let idx = active_parameter?;\n-        let mut params = signature.params(sema.db);\n-        if !(idx < params.len()) {\n-            cov_mark::hit!(too_many_arguments);\n-            return None;\n-        }\n-        let (pat, ty) = params.swap_remove(idx);\n-        pat.map(|pat| ActiveParameter { ty, pat })\n-    }\n-\n-    pub fn ident(&self) -> Option<ast::Name> {\n-        self.pat.as_ref().right().and_then(|param| match param {\n-            ast::Pat::IdentPat(ident) => ident.name(),\n-            _ => None,\n-        })\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "8cdfcd027a3066d8e7bed28b3201dfa719f3525a", "filename": "crates/ide_db/src/call_info/tests.rs", "status": "removed", "additions": 0, "deletions": 564, "changes": 564, "blob_url": "https://github.com/rust-lang/rust/blob/c189555d988ea0a2732e582b1cd2145a06d14c78/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189555d988ea0a2732e582b1cd2145a06d14c78/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs?ref=c189555d988ea0a2732e582b1cd2145a06d14c78", "patch": "@@ -1,564 +0,0 @@\n-use base_db::{fixture::ChangeFixture, FilePosition};\n-use expect_test::{expect, Expect};\n-\n-use crate::RootDatabase;\n-\n-/// Creates analysis from a multi-file fixture, returns positions marked with $0.\n-pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n-    let change_fixture = ChangeFixture::parse(ra_fixture);\n-    let mut database = RootDatabase::default();\n-    database.apply_change(change_fixture.change);\n-    let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let offset = range_or_offset.expect_offset();\n-    (database, FilePosition { file_id, offset })\n-}\n-\n-fn check(ra_fixture: &str, expect: Expect) {\n-    let (db, position) = position(ra_fixture);\n-    let call_info = crate::call_info::call_info(&db, position);\n-    let actual = match call_info {\n-        Some(call_info) => {\n-            let docs = match &call_info.doc {\n-                None => \"\".to_string(),\n-                Some(docs) => format!(\"{}\\n------\\n\", docs.as_str()),\n-            };\n-            let params = call_info\n-                .parameter_labels()\n-                .enumerate()\n-                .map(|(i, param)| {\n-                    if Some(i) == call_info.active_parameter {\n-                        format!(\"<{}>\", param)\n-                    } else {\n-                        param.to_string()\n-                    }\n-                })\n-                .collect::<Vec<_>>()\n-                .join(\", \");\n-            format!(\"{}{}\\n({})\\n\", docs, call_info.signature, params)\n-        }\n-        None => String::new(),\n-    };\n-    expect.assert_eq(&actual);\n-}\n-\n-#[test]\n-fn test_fn_signature_two_args() {\n-    check(\n-        r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo($03, ); }\n-\"#,\n-        expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (<x: u32>, y: u32)\n-            \"#]],\n-    );\n-    check(\n-        r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3$0, ); }\n-\"#,\n-        expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (<x: u32>, y: u32)\n-            \"#]],\n-    );\n-    check(\n-        r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3,$0 ); }\n-\"#,\n-        expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (x: u32, <y: u32>)\n-            \"#]],\n-    );\n-    check(\n-        r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3, $0); }\n-\"#,\n-        expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (x: u32, <y: u32>)\n-            \"#]],\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_two_args_empty() {\n-    check(\n-        r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo($0); }\n-\"#,\n-        expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (<x: u32>, y: u32)\n-            \"#]],\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_two_args_first_generics() {\n-    check(\n-        r#\"\n-fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n-    where T: Copy + Display, U: Debug\n-{ x + y }\n-\n-fn bar() { foo($03, ); }\n-\"#,\n-        expect![[r#\"\n-                fn foo(x: i32, y: {unknown}) -> u32\n-                (<x: i32>, y: {unknown})\n-            \"#]],\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_no_params() {\n-    check(\n-        r#\"\n-fn foo<T>() -> T where T: Copy + Display {}\n-fn bar() { foo($0); }\n-\"#,\n-        expect![[r#\"\n-                fn foo() -> {unknown}\n-                ()\n-            \"#]],\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_for_impl() {\n-    check(\n-        r#\"\n-struct F;\n-impl F { pub fn new() { } }\n-fn bar() {\n-    let _ : F = F::new($0);\n-}\n-\"#,\n-        expect![[r#\"\n-                fn new()\n-                ()\n-            \"#]],\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_for_method_self() {\n-    check(\n-        r#\"\n-struct S;\n-impl S { pub fn do_it(&self) {} }\n-\n-fn bar() {\n-    let s: S = S;\n-    s.do_it($0);\n-}\n-\"#,\n-        expect![[r#\"\n-                fn do_it(&self)\n-                ()\n-            \"#]],\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_for_method_with_arg() {\n-    check(\n-        r#\"\n-struct S;\n-impl S {\n-    fn foo(&self, x: i32) {}\n-}\n-\n-fn main() { S.foo($0); }\n-\"#,\n-        expect![[r#\"\n-                fn foo(&self, x: i32)\n-                (<x: i32>)\n-            \"#]],\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_for_generic_method() {\n-    check(\n-        r#\"\n-struct S<T>(T);\n-impl<T> S<T> {\n-    fn foo(&self, x: T) {}\n-}\n-\n-fn main() { S(1u32).foo($0); }\n-\"#,\n-        expect![[r#\"\n-                fn foo(&self, x: u32)\n-                (<x: u32>)\n-            \"#]],\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_for_method_with_arg_as_assoc_fn() {\n-    check(\n-        r#\"\n-struct S;\n-impl S {\n-    fn foo(&self, x: i32) {}\n-}\n-\n-fn main() { S::foo($0); }\n-\"#,\n-        expect![[r#\"\n-                fn foo(self: &S, x: i32)\n-                (<self: &S>, x: i32)\n-            \"#]],\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_with_docs_simple() {\n-    check(\n-        r#\"\n-/// test\n-// non-doc-comment\n-fn foo(j: u32) -> u32 {\n-    j\n-}\n-\n-fn bar() {\n-    let _ = foo($0);\n-}\n-\"#,\n-        expect![[r#\"\n-            test\n-            ------\n-            fn foo(j: u32) -> u32\n-            (<j: u32>)\n-        \"#]],\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_with_docs() {\n-    check(\n-        r#\"\n-/// Adds one to the number given.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let five = 5;\n-///\n-/// assert_eq!(6, my_crate::add_one(5));\n-/// ```\n-pub fn add_one(x: i32) -> i32 {\n-    x + 1\n-}\n-\n-pub fn do() {\n-    add_one($0\n-}\"#,\n-        expect![[r##\"\n-            Adds one to the number given.\n-\n-            # Examples\n-\n-            ```\n-            let five = 5;\n-\n-            assert_eq!(6, my_crate::add_one(5));\n-            ```\n-            ------\n-            fn add_one(x: i32) -> i32\n-            (<x: i32>)\n-        \"##]],\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_with_docs_impl() {\n-    check(\n-        r#\"\n-struct addr;\n-impl addr {\n-    /// Adds one to the number given.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let five = 5;\n-    ///\n-    /// assert_eq!(6, my_crate::add_one(5));\n-    /// ```\n-    pub fn add_one(x: i32) -> i32 {\n-        x + 1\n-    }\n-}\n-\n-pub fn do_it() {\n-    addr {};\n-    addr::add_one($0);\n-}\n-\"#,\n-        expect![[r##\"\n-            Adds one to the number given.\n-\n-            # Examples\n-\n-            ```\n-            let five = 5;\n-\n-            assert_eq!(6, my_crate::add_one(5));\n-            ```\n-            ------\n-            fn add_one(x: i32) -> i32\n-            (<x: i32>)\n-        \"##]],\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_with_docs_from_actix() {\n-    check(\n-        r#\"\n-struct WriteHandler<E>;\n-\n-impl<E> WriteHandler<E> {\n-    /// Method is called when writer emits error.\n-    ///\n-    /// If this method returns `ErrorAction::Continue` writer processing\n-    /// continues otherwise stream processing stops.\n-    fn error(&mut self, err: E, ctx: &mut Self::Context) -> Running {\n-        Running::Stop\n-    }\n-\n-    /// Method is called when writer finishes.\n-    ///\n-    /// By default this method stops actor's `Context`.\n-    fn finished(&mut self, ctx: &mut Self::Context) {\n-        ctx.stop()\n-    }\n-}\n-\n-pub fn foo(mut r: WriteHandler<()>) {\n-    r.finished($0);\n-}\n-\"#,\n-        expect![[r#\"\n-            Method is called when writer finishes.\n-\n-            By default this method stops actor's `Context`.\n-            ------\n-            fn finished(&mut self, ctx: &mut {unknown})\n-            (<ctx: &mut {unknown}>)\n-        \"#]],\n-    );\n-}\n-\n-#[test]\n-fn call_info_bad_offset() {\n-    check(\n-        r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo $0 (3, ); }\n-\"#,\n-        expect![[\"\"]],\n-    );\n-}\n-\n-#[test]\n-fn test_nested_method_in_lambda() {\n-    check(\n-        r#\"\n-struct Foo;\n-impl Foo { fn bar(&self, _: u32) { } }\n-\n-fn bar(_: u32) { }\n-\n-fn main() {\n-    let foo = Foo;\n-    std::thread::spawn(move || foo.bar($0));\n-}\n-\"#,\n-        expect![[r#\"\n-                fn bar(&self, _: u32)\n-                (<_: u32>)\n-            \"#]],\n-    );\n-}\n-\n-#[test]\n-fn works_for_tuple_structs() {\n-    check(\n-        r#\"\n-/// A cool tuple struct\n-struct S(u32, i32);\n-fn main() {\n-    let s = S(0, $0);\n-}\n-\"#,\n-        expect![[r#\"\n-            A cool tuple struct\n-            ------\n-            struct S(u32, i32)\n-            (u32, <i32>)\n-        \"#]],\n-    );\n-}\n-\n-#[test]\n-fn generic_struct() {\n-    check(\n-        r#\"\n-struct S<T>(T);\n-fn main() {\n-    let s = S($0);\n-}\n-\"#,\n-        expect![[r#\"\n-                struct S({unknown})\n-                (<{unknown}>)\n-            \"#]],\n-    );\n-}\n-\n-#[test]\n-fn works_for_enum_variants() {\n-    check(\n-        r#\"\n-enum E {\n-    /// A Variant\n-    A(i32),\n-    /// Another\n-    B,\n-    /// And C\n-    C { a: i32, b: i32 }\n-}\n-\n-fn main() {\n-    let a = E::A($0);\n-}\n-\"#,\n-        expect![[r#\"\n-            A Variant\n-            ------\n-            enum E::A(i32)\n-            (<i32>)\n-        \"#]],\n-    );\n-}\n-\n-#[test]\n-fn cant_call_struct_record() {\n-    check(\n-        r#\"\n-struct S { x: u32, y: i32 }\n-fn main() {\n-    let s = S($0);\n-}\n-\"#,\n-        expect![[\"\"]],\n-    );\n-}\n-\n-#[test]\n-fn cant_call_enum_record() {\n-    check(\n-        r#\"\n-enum E {\n-    /// A Variant\n-    A(i32),\n-    /// Another\n-    B,\n-    /// And C\n-    C { a: i32, b: i32 }\n-}\n-\n-fn main() {\n-    let a = E::C($0);\n-}\n-\"#,\n-        expect![[\"\"]],\n-    );\n-}\n-\n-#[test]\n-fn fn_signature_for_call_in_macro() {\n-    check(\n-        r#\"\n-macro_rules! id { ($($tt:tt)*) => { $($tt)* } }\n-fn foo() { }\n-id! {\n-    fn bar() { foo($0); }\n-}\n-\"#,\n-        expect![[r#\"\n-                fn foo()\n-                ()\n-            \"#]],\n-    );\n-}\n-\n-#[test]\n-fn call_info_for_lambdas() {\n-    check(\n-        r#\"\n-struct S;\n-fn foo(s: S) -> i32 { 92 }\n-fn main() {\n-    (|s| foo(s))($0)\n-}\n-        \"#,\n-        expect![[r#\"\n-                (S) -> i32\n-                (<S>)\n-            \"#]],\n-    )\n-}\n-\n-#[test]\n-fn call_info_for_fn_ptr() {\n-    check(\n-        r#\"\n-fn main(f: fn(i32, f64) -> char) {\n-    f(0, $0)\n-}\n-        \"#,\n-        expect![[r#\"\n-                (i32, f64) -> char\n-                (i32, <f64>)\n-            \"#]],\n-    )\n-}\n-\n-#[test]\n-fn call_info_for_unclosed_call() {\n-    check(\n-        r#\"\n-fn foo(foo: u32, bar: u32) {}\n-fn main() {\n-    foo($0\n-}\"#,\n-        expect![[r#\"\n-            fn foo(foo: u32, bar: u32)\n-            (<foo: u32>, bar: u32)\n-        \"#]],\n-    );\n-    // check with surrounding space\n-    check(\n-        r#\"\n-fn foo(foo: u32, bar: u32) {}\n-fn main() {\n-    foo( $0\n-}\"#,\n-        expect![[r#\"\n-            fn foo(foo: u32, bar: u32)\n-            (<foo: u32>, bar: u32)\n-        \"#]],\n-    )\n-}"}, {"sha": "1250008984e8c4347d54b3a9c01b949aba78714c", "filename": "crates/ide_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc37d9a29a50bb8164651ec90d89d1742d153f09/crates%2Fide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flib.rs?ref=bc37d9a29a50bb8164651ec90d89d1742d153f09", "patch": "@@ -13,12 +13,12 @@ pub mod items_locator;\n pub mod source_change;\n pub mod ty_filter;\n pub mod traits;\n-pub mod call_info;\n pub mod helpers;\n pub mod path_transform;\n \n pub mod search;\n pub mod rename;\n+pub mod active_parameter;\n \n use std::{fmt, mem::ManuallyDrop, sync::Arc};\n "}]}