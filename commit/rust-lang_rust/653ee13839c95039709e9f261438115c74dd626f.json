{"sha": "653ee13839c95039709e9f261438115c74dd626f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1M2VlMTM4MzljOTUwMzk3MDllOWYyNjE0MzgxMTVjNzRkZDYyNmY=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-10-23T03:21:46Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-10-28T01:25:19Z"}, "message": "Remove MD5 and Sha2. Move Sha1 and support code into librustpkg.", "tree": {"sha": "58b4980a88ebdc2d12ac30385a9cfca79659d964", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58b4980a88ebdc2d12ac30385a9cfca79659d964"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/653ee13839c95039709e9f261438115c74dd626f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/653ee13839c95039709e9f261438115c74dd626f", "html_url": "https://github.com/rust-lang/rust/commit/653ee13839c95039709e9f261438115c74dd626f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/653ee13839c95039709e9f261438115c74dd626f/comments", "author": null, "committer": null, "parents": [{"sha": "c5f10b47f33f8765aa538c6fca936745e8cf8519", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5f10b47f33f8765aa538c6fca936745e8cf8519", "html_url": "https://github.com/rust-lang/rust/commit/c5f10b47f33f8765aa538c6fca936745e8cf8519"}], "stats": {"total": 1388, "additions": 9, "deletions": 1379}, "files": [{"sha": "864fc64f82bec9af50535848e15389f0d777f387", "filename": "src/libextra/crypto/md5.rs", "status": "removed", "additions": 0, "deletions": 327, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/c5f10b47f33f8765aa538c6fca936745e8cf8519/src%2Flibextra%2Fcrypto%2Fmd5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f10b47f33f8765aa538c6fca936745e8cf8519/src%2Flibextra%2Fcrypto%2Fmd5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fmd5.rs?ref=c5f10b47f33f8765aa538c6fca936745e8cf8519", "patch": "@@ -1,327 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use std::iter::range_step;\n-\n-use cryptoutil::{write_u32_le, read_u32v_le, FixedBuffer, FixedBuffer64, StandardPadding};\n-use digest::Digest;\n-\n-\n-// A structure that represents that state of a digest computation for the MD5 digest function\n-struct Md5State {\n-    s0: u32,\n-    s1: u32,\n-    s2: u32,\n-    s3: u32\n-}\n-\n-impl Md5State {\n-    fn new() -> Md5State {\n-        return Md5State {\n-            s0: 0x67452301,\n-            s1: 0xefcdab89,\n-            s2: 0x98badcfe,\n-            s3: 0x10325476\n-        };\n-    }\n-\n-    fn reset(&mut self) {\n-        self.s0 = 0x67452301;\n-        self.s1 = 0xefcdab89;\n-        self.s2 = 0x98badcfe;\n-        self.s3 = 0x10325476;\n-    }\n-\n-    fn process_block(&mut self, input: &[u8]) {\n-        fn f(u: u32, v: u32, w: u32) -> u32 {\n-            return (u & v) | (!u & w);\n-        }\n-\n-        fn g(u: u32, v: u32, w: u32) -> u32 {\n-            return (u & w) | (v & !w);\n-        }\n-\n-        fn h(u: u32, v: u32, w: u32) -> u32 {\n-            return u ^ v ^ w;\n-        }\n-\n-        fn i(u: u32, v: u32, w: u32) -> u32 {\n-            return v ^ (u | !w);\n-        }\n-\n-        fn rotate_left(x: u32, n: u32) -> u32 {\n-            return (x << n) | (x >> (32 - n));\n-        }\n-\n-        fn op_f(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n-            return rotate_left(w + f(x, y, z) + m, s) + x;\n-        }\n-\n-        fn op_g(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n-            return rotate_left(w + g(x, y, z) + m, s) + x;\n-        }\n-\n-        fn op_h(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n-            return rotate_left(w + h(x, y, z) + m, s) + x;\n-        }\n-\n-        fn op_i(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n-            return rotate_left(w + i(x, y, z) + m, s) + x;\n-        }\n-\n-        let mut a = self.s0;\n-        let mut b = self.s1;\n-        let mut c = self.s2;\n-        let mut d = self.s3;\n-\n-        let mut data = [0u32, ..16];\n-\n-        read_u32v_le(data, input);\n-\n-        // round 1\n-        for i in range_step(0u, 16, 4) {\n-            a = op_f(a, b, c, d, data[i] + C1[i], 7);\n-            d = op_f(d, a, b, c, data[i + 1] + C1[i + 1], 12);\n-            c = op_f(c, d, a, b, data[i + 2] + C1[i + 2], 17);\n-            b = op_f(b, c, d, a, data[i + 3] + C1[i + 3], 22);\n-        }\n-\n-        // round 2\n-        let mut t = 1;\n-        for i in range_step(0u, 16, 4) {\n-            a = op_g(a, b, c, d, data[t & 0x0f] + C2[i], 5);\n-            d = op_g(d, a, b, c, data[(t + 5) & 0x0f] + C2[i + 1], 9);\n-            c = op_g(c, d, a, b, data[(t + 10) & 0x0f] + C2[i + 2], 14);\n-            b = op_g(b, c, d, a, data[(t + 15) & 0x0f] + C2[i + 3], 20);\n-            t += 20;\n-        }\n-\n-        // round 3\n-        t = 5;\n-        for i in range_step(0u, 16, 4) {\n-            a = op_h(a, b, c, d, data[t & 0x0f] + C3[i], 4);\n-            d = op_h(d, a, b, c, data[(t + 3) & 0x0f] + C3[i + 1], 11);\n-            c = op_h(c, d, a, b, data[(t + 6) & 0x0f] + C3[i + 2], 16);\n-            b = op_h(b, c, d, a, data[(t + 9) & 0x0f] + C3[i + 3], 23);\n-            t += 12;\n-        }\n-\n-        // round 4\n-        t = 0;\n-        for i in range_step(0u, 16, 4) {\n-            a = op_i(a, b, c, d, data[t & 0x0f] + C4[i], 6);\n-            d = op_i(d, a, b, c, data[(t + 7) & 0x0f] + C4[i + 1], 10);\n-            c = op_i(c, d, a, b, data[(t + 14) & 0x0f] + C4[i + 2], 15);\n-            b = op_i(b, c, d, a, data[(t + 21) & 0x0f] + C4[i + 3], 21);\n-            t += 28;\n-        }\n-\n-        self.s0 += a;\n-        self.s1 += b;\n-        self.s2 += c;\n-        self.s3 += d;\n-    }\n-}\n-\n-// Round 1 constants\n-static C1: [u32, ..16] = [\n-    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n-    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821\n-];\n-\n-// Round 2 constants\n-static C2: [u32, ..16] = [\n-    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n-    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a\n-];\n-\n-// Round 3 constants\n-static C3: [u32, ..16] = [\n-    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n-    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665\n-];\n-\n-// Round 4 constants\n-static C4: [u32, ..16] = [\n-    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n-    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391\n-];\n-\n-\n-/// The MD5 Digest algorithm\n-pub struct Md5 {\n-    priv length_bytes: u64,\n-    priv buffer: FixedBuffer64,\n-    priv state: Md5State,\n-    priv finished: bool,\n-}\n-\n-impl Md5 {\n-    /// Construct a new instance of the MD5 Digest.\n-    pub fn new() -> Md5 {\n-        return Md5 {\n-            length_bytes: 0,\n-            buffer: FixedBuffer64::new(),\n-            state: Md5State::new(),\n-            finished: false\n-        }\n-    }\n-}\n-\n-impl Digest for Md5 {\n-    fn input(&mut self, input: &[u8]) {\n-        assert!(!self.finished);\n-        // Unlike Sha1 and Sha2, the length value in MD5 is defined as the length of the message mod\n-        // 2^64 - ie: integer overflow is OK.\n-        self.length_bytes += input.len() as u64;\n-        self.buffer.input(input, |d: &[u8]| { self.state.process_block(d); });\n-    }\n-\n-    fn reset(&mut self) {\n-        self.length_bytes = 0;\n-        self.buffer.reset();\n-        self.state.reset();\n-        self.finished = false;\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        if !self.finished {\n-            self.buffer.standard_padding(8, |d: &[u8]| { self.state.process_block(d); });\n-            write_u32_le(self.buffer.next(4), (self.length_bytes << 3) as u32);\n-            write_u32_le(self.buffer.next(4), (self.length_bytes >> 29) as u32);\n-            self.state.process_block(self.buffer.full_buffer());\n-            self.finished = true;\n-        }\n-\n-        write_u32_le(out.mut_slice(0, 4), self.state.s0);\n-        write_u32_le(out.mut_slice(4, 8), self.state.s1);\n-        write_u32_le(out.mut_slice(8, 12), self.state.s2);\n-        write_u32_le(out.mut_slice(12, 16), self.state.s3);\n-    }\n-\n-    fn output_bits(&self) -> uint { 128 }\n-}\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use cryptoutil::test::test_digest_1million_random;\n-    use digest::Digest;\n-    use md5::Md5;\n-\n-\n-    struct Test {\n-        input: ~str,\n-        output_str: ~str,\n-    }\n-\n-    fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n-        // Test that it works when accepting the message all at once\n-        for t in tests.iter() {\n-            sh.input_str(t.input);\n-\n-            let out_str = sh.result_str();\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-\n-        // Test that it works when accepting the message in pieces\n-        for t in tests.iter() {\n-            let len = t.input.len();\n-            let mut left = len;\n-            while left > 0u {\n-                let take = (left + 1u) / 2u;\n-                sh.input_str(t.input.slice(len - left, take + len - left));\n-                left = left - take;\n-            }\n-\n-            let out_str = sh.result_str();\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-    }\n-\n-    #[test]\n-    fn test_md5() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"d41d8cd98f00b204e9800998ecf8427e\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"9e107d9d372bb6826bd81d3542a419d6\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"e4d909c290d0fb1ca068ffaddf22cbd0\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = Md5::new();\n-\n-        test_hash(&mut sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_1million_random_md5() {\n-        let mut sh = Md5::new();\n-        test_digest_1million_random(\n-            &mut sh,\n-            64,\n-            \"7707d6ae4e027c70eea2a935c2296f21\");\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod bench {\n-    use extra::test::BenchHarness;\n-\n-    use md5::Md5;\n-\n-\n-    #[bench]\n-    pub fn md5_10(bh: & mut BenchHarness) {\n-        let mut sh = Md5::new();\n-        let bytes = [1u8, ..10];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn md5_1k(bh: & mut BenchHarness) {\n-        let mut sh = Md5::new();\n-        let bytes = [1u8, ..1024];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn md5_64k(bh: & mut BenchHarness) {\n-        let mut sh = Md5::new();\n-        let bytes = [1u8, ..65536];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-}"}, {"sha": "fb9a6df50e48c21df37b6f4e3b46ba8c2184e52c", "filename": "src/libextra/crypto/sha2.rs", "status": "removed", "additions": 0, "deletions": 1033, "changes": 1033, "blob_url": "https://github.com/rust-lang/rust/blob/c5f10b47f33f8765aa538c6fca936745e8cf8519/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f10b47f33f8765aa538c6fca936745e8cf8519/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=c5f10b47f33f8765aa538c6fca936745e8cf8519", "patch": "@@ -1,1033 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use std::iter::range_step;\n-\n-use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, add_bytes_to_bits,\n-    add_bytes_to_bits_tuple, FixedBuffer, FixedBuffer128, FixedBuffer64, StandardPadding};\n-use digest::Digest;\n-\n-// A structure that represents that state of a digest computation for the SHA-2 512 family\n-// of digest functions\n-struct Engine512State {\n-    H0: u64,\n-    H1: u64,\n-    H2: u64,\n-    H3: u64,\n-    H4: u64,\n-    H5: u64,\n-    H6: u64,\n-    H7: u64,\n-}\n-\n-impl Engine512State {\n-    fn new(h: &[u64, ..8]) -> Engine512State {\n-        return Engine512State {\n-            H0: h[0],\n-            H1: h[1],\n-            H2: h[2],\n-            H3: h[3],\n-            H4: h[4],\n-            H5: h[5],\n-            H6: h[6],\n-            H7: h[7]\n-        };\n-    }\n-\n-    fn reset(&mut self, h: &[u64, ..8]) {\n-        self.H0 = h[0];\n-        self.H1 = h[1];\n-        self.H2 = h[2];\n-        self.H3 = h[3];\n-        self.H4 = h[4];\n-        self.H5 = h[5];\n-        self.H6 = h[6];\n-        self.H7 = h[7];\n-    }\n-\n-    fn process_block(&mut self, data: &[u8]) {\n-        fn ch(x: u64, y: u64, z: u64) -> u64 {\n-            ((x & y) ^ ((!x) & z))\n-        }\n-\n-        fn maj(x: u64, y: u64, z: u64) -> u64 {\n-            ((x & y) ^ (x & z) ^ (y & z))\n-        }\n-\n-        fn sum0(x: u64) -> u64 {\n-            ((x << 36) | (x >> 28)) ^ ((x << 30) | (x >> 34)) ^ ((x << 25) | (x >> 39))\n-        }\n-\n-        fn sum1(x: u64) -> u64 {\n-            ((x << 50) | (x >> 14)) ^ ((x << 46) | (x >> 18)) ^ ((x << 23) | (x >> 41))\n-        }\n-\n-        fn sigma0(x: u64) -> u64 {\n-            ((x << 63) | (x >> 1)) ^ ((x << 56) | (x >> 8)) ^ (x >> 7)\n-        }\n-\n-        fn sigma1(x: u64) -> u64 {\n-            ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6)\n-        }\n-\n-        let mut a = self.H0;\n-        let mut b = self.H1;\n-        let mut c = self.H2;\n-        let mut d = self.H3;\n-        let mut e = self.H4;\n-        let mut f = self.H5;\n-        let mut g = self.H6;\n-        let mut h = self.H7;\n-\n-        let mut W = [0u64, ..80];\n-\n-        // Sha-512 and Sha-256 use basically the same calculations which are implemented by\n-        // these macros. Inlining the calculations seems to result in better generated code.\n-        macro_rules! schedule_round( ($t:expr) => (\n-                W[$t] = sigma1(W[$t - 2]) + W[$t - 7] + sigma0(W[$t - 15]) + W[$t - 16];\n-                )\n-        )\n-\n-        macro_rules! sha2_round(\n-            ($A:ident, $B:ident, $C:ident, $D:ident,\n-             $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n-                {\n-                    $H += sum1($E) + ch($E, $F, $G) + $K[$t] + W[$t];\n-                    $D += $H;\n-                    $H += sum0($A) + maj($A, $B, $C);\n-                }\n-             )\n-        )\n-\n-\n-        read_u64v_be(W.mut_slice(0, 16), data);\n-\n-        // Putting the message schedule inside the same loop as the round calculations allows for\n-        // the compiler to generate better code.\n-        for t in range_step(0u, 64, 8) {\n-            schedule_round!(t + 16);\n-            schedule_round!(t + 17);\n-            schedule_round!(t + 18);\n-            schedule_round!(t + 19);\n-            schedule_round!(t + 20);\n-            schedule_round!(t + 21);\n-            schedule_round!(t + 22);\n-            schedule_round!(t + 23);\n-\n-            sha2_round!(a, b, c, d, e, f, g, h, K64, t);\n-            sha2_round!(h, a, b, c, d, e, f, g, K64, t + 1);\n-            sha2_round!(g, h, a, b, c, d, e, f, K64, t + 2);\n-            sha2_round!(f, g, h, a, b, c, d, e, K64, t + 3);\n-            sha2_round!(e, f, g, h, a, b, c, d, K64, t + 4);\n-            sha2_round!(d, e, f, g, h, a, b, c, K64, t + 5);\n-            sha2_round!(c, d, e, f, g, h, a, b, K64, t + 6);\n-            sha2_round!(b, c, d, e, f, g, h, a, K64, t + 7);\n-        }\n-\n-        for t in range_step(64u, 80, 8) {\n-            sha2_round!(a, b, c, d, e, f, g, h, K64, t);\n-            sha2_round!(h, a, b, c, d, e, f, g, K64, t + 1);\n-            sha2_round!(g, h, a, b, c, d, e, f, K64, t + 2);\n-            sha2_round!(f, g, h, a, b, c, d, e, K64, t + 3);\n-            sha2_round!(e, f, g, h, a, b, c, d, K64, t + 4);\n-            sha2_round!(d, e, f, g, h, a, b, c, K64, t + 5);\n-            sha2_round!(c, d, e, f, g, h, a, b, K64, t + 6);\n-            sha2_round!(b, c, d, e, f, g, h, a, K64, t + 7);\n-        }\n-\n-        self.H0 += a;\n-        self.H1 += b;\n-        self.H2 += c;\n-        self.H3 += d;\n-        self.H4 += e;\n-        self.H5 += f;\n-        self.H6 += g;\n-        self.H7 += h;\n-    }\n-}\n-\n-// Constants necessary for SHA-2 512 family of digests.\n-static K64: [u64, ..80] = [\n-    0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n-    0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n-    0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n-    0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n-    0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n-    0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n-    0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n-    0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n-    0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n-    0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n-    0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n-    0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n-    0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n-    0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n-    0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n-    0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n-    0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n-    0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n-    0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n-    0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n-];\n-\n-\n-// A structure that keeps track of the state of the Sha-512 operation and contains the logic\n-// necessary to perform the final calculations.\n-struct Engine512 {\n-    length_bits: (u64, u64),\n-    buffer: FixedBuffer128,\n-    state: Engine512State,\n-    finished: bool,\n-}\n-\n-impl Engine512 {\n-    fn new(h: &[u64, ..8]) -> Engine512 {\n-        return Engine512 {\n-            length_bits: (0, 0),\n-            buffer: FixedBuffer128::new(),\n-            state: Engine512State::new(h),\n-            finished: false\n-        }\n-    }\n-\n-    fn reset(&mut self, h: &[u64, ..8]) {\n-        self.length_bits = (0, 0);\n-        self.buffer.reset();\n-        self.state.reset(h);\n-        self.finished = false;\n-    }\n-\n-    fn input(&mut self, input: &[u8]) {\n-        assert!(!self.finished)\n-        // Assumes that input.len() can be converted to u64 without overflow\n-        self.length_bits = add_bytes_to_bits_tuple(self.length_bits, input.len() as u64);\n-        self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n-    }\n-\n-    fn finish(&mut self) {\n-        if self.finished {\n-            return;\n-        }\n-\n-        self.buffer.standard_padding(16, |input: &[u8]| { self.state.process_block(input) });\n-        match self.length_bits {\n-            (hi, low) => {\n-                write_u64_be(self.buffer.next(8), hi);\n-                write_u64_be(self.buffer.next(8), low);\n-            }\n-        }\n-        self.state.process_block(self.buffer.full_buffer());\n-\n-        self.finished = true;\n-    }\n-}\n-\n-\n-/// The SHA-512 hash algorithm\n-pub struct Sha512 {\n-    priv engine: Engine512\n-}\n-\n-impl Sha512 {\n-    /**\n-     * Construct an new instance of a SHA-512 digest.\n-     */\n-    pub fn new() -> Sha512 {\n-        return Sha512 {\n-            engine: Engine512::new(&H512)\n-        };\n-    }\n-}\n-\n-impl Digest for Sha512 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-\n-        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n-        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n-        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n-        write_u64_be(out.mut_slice(24, 32), self.engine.state.H3);\n-        write_u64_be(out.mut_slice(32, 40), self.engine.state.H4);\n-        write_u64_be(out.mut_slice(40, 48), self.engine.state.H5);\n-        write_u64_be(out.mut_slice(48, 56), self.engine.state.H6);\n-        write_u64_be(out.mut_slice(56, 64), self.engine.state.H7);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H512);\n-    }\n-\n-    fn output_bits(&self) -> uint { 512 }\n-}\n-\n-static H512: [u64, ..8] = [\n-    0x6a09e667f3bcc908,\n-    0xbb67ae8584caa73b,\n-    0x3c6ef372fe94f82b,\n-    0xa54ff53a5f1d36f1,\n-    0x510e527fade682d1,\n-    0x9b05688c2b3e6c1f,\n-    0x1f83d9abfb41bd6b,\n-    0x5be0cd19137e2179\n-];\n-\n-\n-/// The SHA-384 hash algorithm\n-pub struct Sha384 {\n-    priv engine: Engine512\n-}\n-\n-impl Sha384 {\n-    /**\n-     * Construct an new instance of a SHA-384 digest.\n-     */\n-    pub fn new() -> Sha384 {\n-        Sha384 {\n-            engine: Engine512::new(&H384)\n-        }\n-    }\n-}\n-\n-impl Digest for Sha384 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-\n-        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n-        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n-        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n-        write_u64_be(out.mut_slice(24, 32), self.engine.state.H3);\n-        write_u64_be(out.mut_slice(32, 40), self.engine.state.H4);\n-        write_u64_be(out.mut_slice(40, 48), self.engine.state.H5);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H384);\n-    }\n-\n-    fn output_bits(&self) -> uint { 384 }\n-}\n-\n-static H384: [u64, ..8] = [\n-    0xcbbb9d5dc1059ed8,\n-    0x629a292a367cd507,\n-    0x9159015a3070dd17,\n-    0x152fecd8f70e5939,\n-    0x67332667ffc00b31,\n-    0x8eb44a8768581511,\n-    0xdb0c2e0d64f98fa7,\n-    0x47b5481dbefa4fa4\n-];\n-\n-\n-/// The SHA-512 hash algorithm with digest truncated to 256 bits\n-pub struct Sha512Trunc256 {\n-    priv engine: Engine512\n-}\n-\n-impl Sha512Trunc256 {\n-    /**\n-     * Construct an new instance of a SHA-512/256 digest.\n-     */\n-    pub fn new() -> Sha512Trunc256 {\n-        Sha512Trunc256 {\n-            engine: Engine512::new(&H512_TRUNC_256)\n-        }\n-    }\n-}\n-\n-impl Digest for Sha512Trunc256 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-\n-        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n-        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n-        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n-        write_u64_be(out.mut_slice(24, 32), self.engine.state.H3);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H512_TRUNC_256);\n-    }\n-\n-    fn output_bits(&self) -> uint { 256 }\n-}\n-\n-static H512_TRUNC_256: [u64, ..8] = [\n-    0x22312194fc2bf72c,\n-    0x9f555fa3c84c64c2,\n-    0x2393b86b6f53b151,\n-    0x963877195940eabd,\n-    0x96283ee2a88effe3,\n-    0xbe5e1e2553863992,\n-    0x2b0199fc2c85b8aa,\n-    0x0eb72ddc81c52ca2\n-];\n-\n-\n-/// The SHA-512 hash algorithm with digest truncated to 224 bits\n-pub struct Sha512Trunc224 {\n-    priv engine: Engine512\n-}\n-\n-impl Sha512Trunc224 {\n-    /**\n-     * Construct an new instance of a SHA-512/224 digest.\n-     */\n-    pub fn new() -> Sha512Trunc224 {\n-        Sha512Trunc224 {\n-            engine: Engine512::new(&H512_TRUNC_224)\n-        }\n-    }\n-}\n-\n-impl Digest for Sha512Trunc224 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-\n-        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n-        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n-        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n-        write_u32_be(out.mut_slice(24, 28), (self.engine.state.H3 >> 32) as u32);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H512_TRUNC_224);\n-    }\n-\n-    fn output_bits(&self) -> uint { 224 }\n-}\n-\n-static H512_TRUNC_224: [u64, ..8] = [\n-    0x8c3d37c819544da2,\n-    0x73e1996689dcd4d6,\n-    0x1dfab7ae32ff9c82,\n-    0x679dd514582f9fcf,\n-    0x0f6d2b697bd44da8,\n-    0x77e36f7304c48942,\n-    0x3f9d85a86a1d36c8,\n-    0x1112e6ad91d692a1,\n-];\n-\n-\n-// A structure that represents that state of a digest computation for the SHA-2 512 family of digest\n-// functions\n-struct Engine256State {\n-    H0: u32,\n-    H1: u32,\n-    H2: u32,\n-    H3: u32,\n-    H4: u32,\n-    H5: u32,\n-    H6: u32,\n-    H7: u32,\n-}\n-\n-impl Engine256State {\n-    fn new(h: &[u32, ..8]) -> Engine256State {\n-        return Engine256State {\n-            H0: h[0],\n-            H1: h[1],\n-            H2: h[2],\n-            H3: h[3],\n-            H4: h[4],\n-            H5: h[5],\n-            H6: h[6],\n-            H7: h[7]\n-        };\n-    }\n-\n-    fn reset(&mut self, h: &[u32, ..8]) {\n-        self.H0 = h[0];\n-        self.H1 = h[1];\n-        self.H2 = h[2];\n-        self.H3 = h[3];\n-        self.H4 = h[4];\n-        self.H5 = h[5];\n-        self.H6 = h[6];\n-        self.H7 = h[7];\n-    }\n-\n-    fn process_block(&mut self, data: &[u8]) {\n-        fn ch(x: u32, y: u32, z: u32) -> u32 {\n-            ((x & y) ^ ((!x) & z))\n-        }\n-\n-        fn maj(x: u32, y: u32, z: u32) -> u32 {\n-            ((x & y) ^ (x & z) ^ (y & z))\n-        }\n-\n-        fn sum0(x: u32) -> u32 {\n-            ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))\n-        }\n-\n-        fn sum1(x: u32) -> u32 {\n-            ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))\n-        }\n-\n-        fn sigma0(x: u32) -> u32 {\n-            ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3)\n-        }\n-\n-        fn sigma1(x: u32) -> u32 {\n-            ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10)\n-        }\n-\n-        let mut a = self.H0;\n-        let mut b = self.H1;\n-        let mut c = self.H2;\n-        let mut d = self.H3;\n-        let mut e = self.H4;\n-        let mut f = self.H5;\n-        let mut g = self.H6;\n-        let mut h = self.H7;\n-\n-        let mut W = [0u32, ..64];\n-\n-        // Sha-512 and Sha-256 use basically the same calculations which are implemented\n-        // by these macros. Inlining the calculations seems to result in better generated code.\n-        macro_rules! schedule_round( ($t:expr) => (\n-                W[$t] = sigma1(W[$t - 2]) + W[$t - 7] + sigma0(W[$t - 15]) + W[$t - 16];\n-                )\n-        )\n-\n-        macro_rules! sha2_round(\n-            ($A:ident, $B:ident, $C:ident, $D:ident,\n-             $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n-                {\n-                    $H += sum1($E) + ch($E, $F, $G) + $K[$t] + W[$t];\n-                    $D += $H;\n-                    $H += sum0($A) + maj($A, $B, $C);\n-                }\n-             )\n-        )\n-\n-\n-        read_u32v_be(W.mut_slice(0, 16), data);\n-\n-        // Putting the message schedule inside the same loop as the round calculations allows for\n-        // the compiler to generate better code.\n-        for t in range_step(0u, 48, 8) {\n-            schedule_round!(t + 16);\n-            schedule_round!(t + 17);\n-            schedule_round!(t + 18);\n-            schedule_round!(t + 19);\n-            schedule_round!(t + 20);\n-            schedule_round!(t + 21);\n-            schedule_round!(t + 22);\n-            schedule_round!(t + 23);\n-\n-            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n-            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n-            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n-            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n-            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n-            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n-            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n-            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n-        }\n-\n-        for t in range_step(48u, 64, 8) {\n-            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n-            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n-            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n-            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n-            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n-            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n-            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n-            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n-        }\n-\n-        self.H0 += a;\n-        self.H1 += b;\n-        self.H2 += c;\n-        self.H3 += d;\n-        self.H4 += e;\n-        self.H5 += f;\n-        self.H6 += g;\n-        self.H7 += h;\n-    }\n-}\n-\n-static K32: [u32, ..64] = [\n-    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n-    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n-    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n-    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n-    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n-    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n-    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n-    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n-    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n-    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n-    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n-    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n-    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n-    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n-    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n-    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n-];\n-\n-\n-// A structure that keeps track of the state of the Sha-256 operation and contains the logic\n-// necessary to perform the final calculations.\n-struct Engine256 {\n-    length_bits: u64,\n-    buffer: FixedBuffer64,\n-    state: Engine256State,\n-    finished: bool,\n-}\n-\n-impl Engine256 {\n-    fn new(h: &[u32, ..8]) -> Engine256 {\n-        return Engine256 {\n-            length_bits: 0,\n-            buffer: FixedBuffer64::new(),\n-            state: Engine256State::new(h),\n-            finished: false\n-        }\n-    }\n-\n-    fn reset(&mut self, h: &[u32, ..8]) {\n-        self.length_bits = 0;\n-        self.buffer.reset();\n-        self.state.reset(h);\n-        self.finished = false;\n-    }\n-\n-    fn input(&mut self, input: &[u8]) {\n-        assert!(!self.finished)\n-        // Assumes that input.len() can be converted to u64 without overflow\n-        self.length_bits = add_bytes_to_bits(self.length_bits, input.len() as u64);\n-        self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n-    }\n-\n-    fn finish(&mut self) {\n-        if self.finished {\n-            return;\n-        }\n-\n-        self.buffer.standard_padding(8, |input: &[u8]| { self.state.process_block(input) });\n-        write_u32_be(self.buffer.next(4), (self.length_bits >> 32) as u32 );\n-        write_u32_be(self.buffer.next(4), self.length_bits as u32);\n-        self.state.process_block(self.buffer.full_buffer());\n-\n-        self.finished = true;\n-    }\n-}\n-\n-\n-/// The SHA-256 hash algorithm\n-pub struct Sha256 {\n-    priv engine: Engine256\n-}\n-\n-impl Sha256 {\n-    /**\n-     * Construct an new instance of a SHA-256 digest.\n-     */\n-    pub fn new() -> Sha256 {\n-        Sha256 {\n-            engine: Engine256::new(&H256)\n-        }\n-    }\n-}\n-\n-impl Digest for Sha256 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-\n-        write_u32_be(out.mut_slice(0, 4), self.engine.state.H0);\n-        write_u32_be(out.mut_slice(4, 8), self.engine.state.H1);\n-        write_u32_be(out.mut_slice(8, 12), self.engine.state.H2);\n-        write_u32_be(out.mut_slice(12, 16), self.engine.state.H3);\n-        write_u32_be(out.mut_slice(16, 20), self.engine.state.H4);\n-        write_u32_be(out.mut_slice(20, 24), self.engine.state.H5);\n-        write_u32_be(out.mut_slice(24, 28), self.engine.state.H6);\n-        write_u32_be(out.mut_slice(28, 32), self.engine.state.H7);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H256);\n-    }\n-\n-    fn output_bits(&self) -> uint { 256 }\n-}\n-\n-static H256: [u32, ..8] = [\n-    0x6a09e667,\n-    0xbb67ae85,\n-    0x3c6ef372,\n-    0xa54ff53a,\n-    0x510e527f,\n-    0x9b05688c,\n-    0x1f83d9ab,\n-    0x5be0cd19\n-];\n-\n-\n-/// The SHA-224 hash algorithm\n-pub struct Sha224 {\n-    priv engine: Engine256\n-}\n-\n-impl Sha224 {\n-    /**\n-     * Construct an new instance of a SHA-224 digest.\n-     */\n-    pub fn new() -> Sha224 {\n-        Sha224 {\n-            engine: Engine256::new(&H224)\n-        }\n-    }\n-}\n-\n-impl Digest for Sha224 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-        write_u32_be(out.mut_slice(0, 4), self.engine.state.H0);\n-        write_u32_be(out.mut_slice(4, 8), self.engine.state.H1);\n-        write_u32_be(out.mut_slice(8, 12), self.engine.state.H2);\n-        write_u32_be(out.mut_slice(12, 16), self.engine.state.H3);\n-        write_u32_be(out.mut_slice(16, 20), self.engine.state.H4);\n-        write_u32_be(out.mut_slice(20, 24), self.engine.state.H5);\n-        write_u32_be(out.mut_slice(24, 28), self.engine.state.H6);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H224);\n-    }\n-\n-    fn output_bits(&self) -> uint { 224 }\n-}\n-\n-static H224: [u32, ..8] = [\n-    0xc1059ed8,\n-    0x367cd507,\n-    0x3070dd17,\n-    0xf70e5939,\n-    0xffc00b31,\n-    0x68581511,\n-    0x64f98fa7,\n-    0xbefa4fa4\n-];\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use cryptoutil::test::test_digest_1million_random;\n-    use digest::Digest;\n-    use sha2::{Sha512, Sha384, Sha512Trunc256, Sha512Trunc224, Sha256, Sha224};\n-\n-    struct Test {\n-        input: ~str,\n-        output_str: ~str,\n-    }\n-\n-    fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n-        // Test that it works when accepting the message all at once\n-        for t in tests.iter() {\n-            sh.input_str(t.input);\n-\n-            let out_str = sh.result_str();\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-\n-        // Test that it works when accepting the message in pieces\n-        for t in tests.iter() {\n-            let len = t.input.len();\n-            let mut left = len;\n-            while left > 0u {\n-                let take = (left + 1u) / 2u;\n-                sh.input_str(t.input.slice(len - left, take + len - left));\n-                left = left - take;\n-            }\n-\n-            let out_str = sh.result_str();\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-    }\n-\n-    #[test]\n-    fn test_sha512() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\" +\n-                             \"47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"07e547d9586f6a73f73fbac0435ed76951218fb7d0c8d788a309d785436bbb64\" +\n-                             \"2e93a252a954f23912547d1e8a3b5ed6e1bfd7097821233fa0538f3db854fee6\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"91ea1245f20d46ae9a037a989f54f1f790f0a47607eeb8a14d12890cea77a1bb\" +\n-                             \"c6c7ed9cf205e67b7f2b8fd4c7dfd3a7a8617e45f3c463d481c7e586c39ac1ed\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = ~Sha512::new();\n-\n-        test_hash(sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_sha384() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"38b060a751ac96384cd9327eb1b1e36a21fdb71114be0743\" +\n-                             \"4c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"ca737f1014a48f4c0b6dd43cb177b0afd9e5169367544c49\" +\n-                             \"4011e3317dbf9a509cb1e5dc1e85a941bbee3d7f2afbc9b1\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"ed892481d8272ca6df370bf706e4d7bc1b5739fa2177aae6\" +\n-                             \"c50e946678718fc67a7af2819a021c2fc34e91bdb63409d7\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = ~Sha384::new();\n-\n-        test_hash(sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_sha512_256() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"c672b8d1ef56ed28ab87c3622c5114069bdd3ad7b8f9737498d0c01ecef0967a\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"dd9d67b371519c339ed8dbd25af90e976a1eeefd4ad3d889005e532fc5bef04d\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"1546741840f8a492b959d9b8b2344b9b0eb51b004bba35c0aebaac86d45264c3\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = ~Sha512Trunc256::new();\n-\n-        test_hash(sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_sha512_224() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"6ed0dd02806fa89e25de060c19d3ac86cabb87d6a0ddd05c333b84f4\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"944cd2847fb54558d4775db0485a50003111c8e5daa63fe722c6aa37\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"6d6a9279495ec4061769752e7ff9c68b6b0b3c5a281b7917ce0572de\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = ~Sha512Trunc224::new();\n-\n-        test_hash(sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_sha256() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = ~Sha256::new();\n-\n-        test_hash(sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_sha224() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"619cba8e8e05826e9b8c519c0a5c68f4fb653e8a3d8aa04bb2c8cd4c\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = ~Sha224::new();\n-\n-        test_hash(sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_1million_random_sha512() {\n-        let mut sh = Sha512::new();\n-        test_digest_1million_random(\n-            &mut sh,\n-            128,\n-            \"e718483d0ce769644e2e42c7bc15b4638e1f98b13b2044285632a803afa973eb\" +\n-            \"de0ff244877ea60a4cb0432ce577c31beb009c5c2c49aa2e4eadb217ad8cc09b\");\n-        }\n-\n-    #[test]\n-    fn test_1million_random_sha256() {\n-        let mut sh = Sha256::new();\n-        test_digest_1million_random(\n-            &mut sh,\n-            64,\n-            \"cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0\");\n-    }\n-}\n-\n-\n-\n-#[cfg(test)]\n-mod bench {\n-\n-    use sha2::{Sha256,Sha512};\n-    use test::BenchHarness;\n-\n-    #[bench]\n-    pub fn sha256_10(bh: & mut BenchHarness) {\n-        let mut sh = Sha256::new();\n-        let bytes = [1u8, ..10];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha256_1k(bh: & mut BenchHarness) {\n-        let mut sh = Sha256::new();\n-        let bytes = [1u8, ..1024];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha256_64k(bh: & mut BenchHarness) {\n-        let mut sh = Sha256::new();\n-        let bytes = [1u8, ..65536];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-\n-\n-    #[bench]\n-    pub fn sha512_10(bh: & mut BenchHarness) {\n-        let mut sh = Sha512::new();\n-        let bytes = [1u8, ..10];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha512_1k(bh: & mut BenchHarness) {\n-        let mut sh = Sha512::new();\n-        let bytes = [1u8, ..1024];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha512_64k(bh: & mut BenchHarness) {\n-        let mut sh = Sha512::new();\n-        let bytes = [1u8, ..65536];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-}"}, {"sha": "6abad2ed1818a6e371e0624e93e9775ce3157c62", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/653ee13839c95039709e9f261438115c74dd626f/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653ee13839c95039709e9f261438115c74dd626f/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=653ee13839c95039709e9f261438115c74dd626f", "patch": "@@ -68,18 +68,6 @@ pub mod sort;\n pub mod dlist;\n pub mod treemap;\n \n-// Crypto\n-#[path=\"crypto/cryptoutil.rs\"]\n-mod cryptoutil;\n-#[path=\"crypto/digest.rs\"]\n-pub mod digest;\n-#[path=\"crypto/md5.rs\"]\n-pub mod md5;\n-#[path=\"crypto/sha1.rs\"]\n-pub mod sha1;\n-#[path=\"crypto/sha2.rs\"]\n-pub mod sha2;\n-\n // And ... other stuff\n \n pub mod url;"}, {"sha": "dfed31bad9f5cafe130b9de584ccde15c76b7f95", "filename": "src/librustpkg/cryptoutil.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653ee13839c95039709e9f261438115c74dd626f/src%2Flibrustpkg%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653ee13839c95039709e9f261438115c74dd626f/src%2Flibrustpkg%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcryptoutil.rs?ref=653ee13839c95039709e9f261438115c74dd626f", "patch": "@@ -349,10 +349,10 @@ impl <T: FixedBuffer> StandardPadding for T {\n pub mod test {\n     use std::rand::{IsaacRng, Rng};\n     use std::vec;\n+    use extra::hex::FromHex;\n \n     use cryptoutil::{add_bytes_to_bits, add_bytes_to_bits_tuple};\n     use digest::Digest;\n-    use hex::FromHex;\n \n     /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n     /// correct.", "previous_filename": "src/libextra/crypto/cryptoutil.rs"}, {"sha": "f0dccf7c2e21238b5404db7b79e7164f9c87848a", "filename": "src/librustpkg/digest.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653ee13839c95039709e9f261438115c74dd626f/src%2Flibrustpkg%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653ee13839c95039709e9f261438115c74dd626f/src%2Flibrustpkg%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fdigest.rs?ref=653ee13839c95039709e9f261438115c74dd626f", "patch": "@@ -12,7 +12,7 @@\n \n use std::vec;\n \n-use hex::ToHex;\n+use extra::hex::ToHex;\n \n \n /**", "previous_filename": "src/libextra/crypto/digest.rs"}, {"sha": "89a7bfae86a9369e6fd9f285ca345085b526a851", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/653ee13839c95039709e9f261438115c74dd626f/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653ee13839c95039709e9f261438115c74dd626f/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=653ee13839c95039709e9f261438115c74dd626f", "patch": "@@ -18,7 +18,7 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[feature(globs, managed_boxes)];\n+#[feature(globs, managed_boxes, macro_rules)];\n \n extern mod extra;\n extern mod rustc;\n@@ -55,13 +55,16 @@ pub mod api;\n mod conditions;\n pub mod context;\n mod crate;\n+mod cryptoutil;\n+mod digest;\n pub mod exit_codes;\n mod installed_packages;\n mod messages;\n mod package_id;\n mod package_source;\n mod path_util;\n mod search;\n+mod sha1;\n mod source_control;\n mod target;\n #[cfg(test)]"}, {"sha": "38bfc51841fbdbfa13aea16aeabb58908abb07f9", "filename": "src/librustpkg/sha1.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653ee13839c95039709e9f261438115c74dd626f/src%2Flibrustpkg%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653ee13839c95039709e9f261438115c74dd626f/src%2Flibrustpkg%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsha1.rs?ref=653ee13839c95039709e9f261438115c74dd626f", "patch": "@@ -295,9 +295,9 @@ mod tests {\n \n #[cfg(test)]\n mod bench {\n+    use extra::test::BenchHarness;\n \n     use sha1::Sha1;\n-    use test::BenchHarness;\n \n     #[bench]\n     pub fn sha1_10(bh: & mut BenchHarness) {", "previous_filename": "src/libextra/crypto/sha1.rs"}, {"sha": "1cdaefd592b5c523788bcbb83983b95f85e0d8db", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/653ee13839c95039709e9f261438115c74dd626f/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653ee13839c95039709e9f261438115c74dd626f/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=653ee13839c95039709e9f261438115c74dd626f", "patch": "@@ -11,10 +11,9 @@\n use std::rt::io;\n use std::rt::io::extensions::ReaderUtil;\n use std::rt::io::file::FileInfo;\n-\n-use extra::sha1::Sha1;\n-use extra::digest::Digest;\n use extra::workcache;\n+use sha1::Sha1;\n+use digest::Digest;\n \n /// Hashes the file contents along with the last-modified time\n pub fn digest_file_with_date(path: &Path) -> ~str {"}]}