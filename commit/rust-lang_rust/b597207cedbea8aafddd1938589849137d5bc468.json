{"sha": "b597207cedbea8aafddd1938589849137d5bc468", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1OTcyMDdjZWRiZWE4YWFmZGRkMTkzODU4OTg0OTEzN2Q1YmM0Njg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-27T21:28:57Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-03T22:01:57Z"}, "message": "libsyntax: De-`@mut` `TtReader::cur_span`", "tree": {"sha": "80e052ed0204da349d22f4f58f09a95b5a45c702", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80e052ed0204da349d22f4f58f09a95b5a45c702"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b597207cedbea8aafddd1938589849137d5bc468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b597207cedbea8aafddd1938589849137d5bc468", "html_url": "https://github.com/rust-lang/rust/commit/b597207cedbea8aafddd1938589849137d5bc468", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b597207cedbea8aafddd1938589849137d5bc468/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c233c2edfdc4639963dc2310783cd84bc4aefa7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c233c2edfdc4639963dc2310783cd84bc4aefa7d", "html_url": "https://github.com/rust-lang/rust/commit/c233c2edfdc4639963dc2310783cd84bc4aefa7d"}], "stats": {"total": 25, "additions": 13, "deletions": 12}, "files": [{"sha": "fd7736cbd752c11a76fca521a533f56507846665", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b597207cedbea8aafddd1938589849137d5bc468/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b597207cedbea8aafddd1938589849137d5bc468/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=b597207cedbea8aafddd1938589849137d5bc468", "patch": "@@ -40,7 +40,7 @@ pub struct TtReader {\n     priv repeat_len: RefCell<~[uint]>,\n     /* cached: */\n     cur_tok: RefCell<Token>,\n-    cur_span: Span\n+    cur_span: RefCell<Span>,\n }\n \n /** This can do Macro-By-Example transcription. On the other hand, if\n@@ -67,7 +67,7 @@ pub fn new_tt_reader(sp_diag: @mut SpanHandler,\n         repeat_len: RefCell::new(~[]),\n         /* dummy values, never read: */\n         cur_tok: RefCell::new(EOF),\n-        cur_span: DUMMY_SP\n+        cur_span: RefCell::new(DUMMY_SP),\n     };\n     tt_next_token(r); /* get cur_tok and cur_span set up */\n     return r;\n@@ -93,7 +93,7 @@ pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n         repeat_idx: r.repeat_idx.clone(),\n         repeat_len: r.repeat_len.clone(),\n         cur_tok: r.cur_tok.clone(),\n-        cur_span: r.cur_span,\n+        cur_span: r.cur_span.clone(),\n         interpolations: r.interpolations.clone(),\n     }\n }\n@@ -123,8 +123,9 @@ fn lookup_cur_matched(r: &mut TtReader, name: Ident) -> @named_match {\n     match matched_opt {\n         Some(s) => lookup_cur_matched_by_matched(r, s),\n         None => {\n-            r.sp_diag.span_fatal(r.cur_span, format!(\"unknown macro variable `{}`\",\n-                                                  ident_to_str(&name)));\n+            r.sp_diag.span_fatal(r.cur_span.get(),\n+                                 format!(\"unknown macro variable `{}`\",\n+                                         ident_to_str(&name)));\n         }\n     }\n }\n@@ -176,7 +177,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n     // XXX(pcwalton): Bad copy?\n     let ret_val = TokenAndSpan {\n         tok: r.cur_tok.get(),\n-        sp: r.cur_span,\n+        sp: r.cur_span.get(),\n     };\n     loop {\n         {\n@@ -243,7 +244,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n           tt_tok(sp, tok) => {\n-            r.cur_span = sp;\n+            r.cur_span.set(sp);\n             r.cur_tok.set(tok);\n             r.stack.idx += 1u;\n             return ret_val;\n@@ -299,21 +300,21 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n               (a) idents can be in lots of places, so it'd be a pain\n               (b) we actually can, since it's a token. */\n               matched_nonterminal(nt_ident(~sn,b)) => {\n-                r.cur_span = sp;\n+                r.cur_span.set(sp);\n                 r.cur_tok.set(IDENT(sn,b));\n                 r.stack.idx += 1u;\n                 return ret_val;\n               }\n               matched_nonterminal(ref other_whole_nt) => {\n                 // XXX(pcwalton): Bad copy.\n-                r.cur_span = sp;\n+                r.cur_span.set(sp);\n                 r.cur_tok.set(INTERPOLATED((*other_whole_nt).clone()));\n                 r.stack.idx += 1u;\n                 return ret_val;\n               }\n               matched_seq(..) => {\n                 r.sp_diag.span_fatal(\n-                    r.cur_span, /* blame the macro writer */\n+                    r.cur_span.get(), /* blame the macro writer */\n                     format!(\"variable '{}' is still repeating at this depth\",\n                          ident_to_str(&ident)));\n               }"}, {"sha": "3fcc0414e6172e33fa71d9309ac9b75ee2a24a75", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b597207cedbea8aafddd1938589849137d5bc468/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b597207cedbea8aafddd1938589849137d5bc468/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=b597207cedbea8aafddd1938589849137d5bc468", "patch": "@@ -143,13 +143,13 @@ impl reader for TtReader {\n         return r;\n     }\n     fn fatal(@mut self, m: ~str) -> ! {\n-        self.sp_diag.span_fatal(self.cur_span, m);\n+        self.sp_diag.span_fatal(self.cur_span.get(), m);\n     }\n     fn span_diag(@mut self) -> @mut SpanHandler { self.sp_diag }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: self.cur_tok.get(),\n-            sp: self.cur_span,\n+            sp: self.cur_span.get(),\n         }\n     }\n     fn dup(@mut self) -> @mut reader { dup_tt_reader(self) as @mut reader }"}]}