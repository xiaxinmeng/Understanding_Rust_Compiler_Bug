{"sha": "30266a788f8399790024f0ffb7618cdd2c50935b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMjY2YTc4OGY4Mzk5NzkwMDI0ZjBmZmI3NjE4Y2RkMmM1MDkzNWI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-26T13:23:49Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-29T22:40:05Z"}, "message": "core: a pure Rust implementation of the ISAAC RNG.\n\nThis replaces the wrapper around the runtime RNG with a pure Rust\nimplementation of the same algorithm. This is faster (up to 5x), and\nis hopefully safer.\n\nThere is still much room for optimisation: testing by summing 100,000,000\nrandom `u32`s indicates this is about 40-50% slower than the pure C\nimplementation (running as standalone executable, not in the runtime).", "tree": {"sha": "3850b597187c39be2fc9f2b631d7501076e4d59e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3850b597187c39be2fc9f2b631d7501076e4d59e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30266a788f8399790024f0ffb7618cdd2c50935b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30266a788f8399790024f0ffb7618cdd2c50935b", "html_url": "https://github.com/rust-lang/rust/commit/30266a788f8399790024f0ffb7618cdd2c50935b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30266a788f8399790024f0ffb7618cdd2c50935b/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "html_url": "https://github.com/rust-lang/rust/commit/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a"}], "stats": {"total": 248, "additions": 202, "deletions": 46}, "files": [{"sha": "80a45fd6570809f6ea98cfb2b2e3ad30354b4f60", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 202, "deletions": 46, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/30266a788f8399790024f0ffb7618cdd2c50935b/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30266a788f8399790024f0ffb7618cdd2c50935b/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=30266a788f8399790024f0ffb7618cdd2c50935b", "patch": "@@ -207,20 +207,13 @@ impl<T: Rand> Rand for @T {\n     fn rand<R: Rng>(rng: &R) -> @T { @rng.gen() }\n }\n \n-#[allow(non_camel_case_types)] // runtime type\n-pub enum rust_rng {}\n-\n #[abi = \"cdecl\"]\n pub mod rustrt {\n     use libc::size_t;\n-    use super::rust_rng;\n \n     pub extern {\n         unsafe fn rand_seed_size() -> size_t;\n         unsafe fn rand_gen_seed(buf: *mut u8, sz: size_t);\n-        unsafe fn rand_new_seeded(buf: *u8, sz: size_t) -> *rust_rng;\n-        unsafe fn rand_next(rng: *rust_rng) -> u32;\n-        unsafe fn rand_free(rng: *rust_rng);\n     }\n }\n \n@@ -566,66 +559,179 @@ pub fn rng() -> IsaacRng {\n     IsaacRng::new()\n }\n \n-pub struct IsaacRng {\n-    priv rng: *rust_rng,\n-}\n+static RAND_SIZE_LEN: u32 = 8;\n+static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n \n-impl Drop for IsaacRng {\n-    fn finalize(&self) {\n-        unsafe {\n-            rustrt::rand_free(self.rng);\n-        }\n-    }\n+/// A random number generator that uses the [ISAAC\n+/// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n+pub struct IsaacRng {\n+    priv mut cnt: u32,\n+    priv mut rsl: [u32, .. RAND_SIZE],\n+    priv mut mem: [u32, .. RAND_SIZE],\n+    priv mut a: u32,\n+    priv mut b: u32,\n+    priv mut c: u32\n }\n \n pub impl IsaacRng {\n-    priv fn from_rust_rng(rng: *rust_rng) -> IsaacRng {\n-        IsaacRng {\n-            rng: rng\n-        }\n-    }\n-\n-    /// Create an ISAAC random number generator with a system specified seed\n+    /// Create an ISAAC random number generator with a random seed.\n     fn new() -> IsaacRng {\n         IsaacRng::new_seeded(seed())\n     }\n \n-    /**\n-     * Create a random number generator using the specified seed. A generator\n-     * constructed with a given seed will generate the same sequence of values as\n-     * all other generators constructed with the same seed. The seed may be any\n-     * length.\n-     */\n+    /// Create an ISAAC random number generator with a seed. This can be any\n+    /// length, although the maximum number of bytes used is 1024 and any more\n+    /// will be silently ignored. A generator constructed with a given seed\n+    /// will generate the same sequence of values as all other generators\n+    /// constructed with the same seed.\n     fn new_seeded(seed: &[u8]) -> IsaacRng {\n-        unsafe {\n-            do vec::as_imm_buf(seed) |p, sz| {\n-                IsaacRng::from_rust_rng(rustrt::rand_new_seeded(p, sz as size_t))\n+        let mut rng = IsaacRng {\n+            cnt: 0,\n+            rsl: [0, .. RAND_SIZE],\n+            mem: [0, .. RAND_SIZE],\n+            a: 0, b: 0, c: 0\n+        };\n+\n+        let array_size = sys::size_of_val(&rng.rsl);\n+        let copy_length = cmp::min(array_size, seed.len());\n+\n+        // manually create a &mut [u8] slice of randrsl to copy into.\n+        let dest = unsafe { cast::transmute((&mut rng.rsl, array_size)) };\n+        vec::bytes::copy_memory(dest, seed, copy_length);\n+        rng.init(true);\n+        rng\n+    }\n+\n+    /// Create an ISAAC random number generator using the default\n+    /// fixed seed.\n+    fn new_unseeded() -> IsaacRng {\n+        let mut rng = IsaacRng {\n+            cnt: 0,\n+            rsl: [0, .. RAND_SIZE],\n+            mem: [0, .. RAND_SIZE],\n+            a: 0, b: 0, c: 0\n+        };\n+        rng.init(false);\n+        rng\n+    }\n+\n+    /// Initialises `self`. If `use_rsl` is true, then use the current value\n+    /// of `rsl` as a seed, otherwise construct one algorithmically (not\n+    /// randomly).\n+    priv fn init(&self, use_rsl: bool) {\n+        macro_rules! init_mut_many (\n+            ($( $var:ident ),* = $val:expr ) => {\n+                let mut $( $var = $val ),*;\n+            }\n+        );\n+        init_mut_many!(a, b, c, d, e, f, g, h = 0x9e3779b9);\n+\n+\n+        macro_rules! mix(\n+            () => {{\n+                a^=b<<11; d+=a; b+=c;\n+                b^=c>>2;  e+=b; c+=d;\n+                c^=d<<8;  f+=c; d+=e;\n+                d^=e>>16; g+=d; e+=f;\n+                e^=f<<10; h+=e; f+=g;\n+                f^=g>>4;  a+=f; g+=h;\n+                g^=h<<8;  b+=g; h+=a;\n+                h^=a>>9;  c+=h; a+=b;\n+            }}\n+        );\n+\n+        for 4.times { mix!(); }\n+\n+        if use_rsl {\n+            macro_rules! memloop (\n+                ($arr:expr) => {{\n+                    for u32::range_step(0, RAND_SIZE, 8) |i| {\n+                        a+=$arr[i  ]; b+=$arr[i+1];\n+                        c+=$arr[i+2]; d+=$arr[i+3];\n+                        e+=$arr[i+4]; f+=$arr[i+5];\n+                        g+=$arr[i+6]; h+=$arr[i+7];\n+                        mix!();\n+                        self.mem[i  ]=a; self.mem[i+1]=b;\n+                        self.mem[i+2]=c; self.mem[i+3]=d;\n+                        self.mem[i+4]=e; self.mem[i+5]=f;\n+                        self.mem[i+6]=g; self.mem[i+7]=h;\n+                    }\n+                }}\n+            );\n+\n+            memloop!(self.rsl);\n+            memloop!(self.mem);\n+        } else {\n+            for u32::range_step(0, RAND_SIZE, 8) |i| {\n+                mix!();\n+                self.mem[i  ]=a; self.mem[i+1]=b;\n+                self.mem[i+2]=c; self.mem[i+3]=d;\n+                self.mem[i+4]=e; self.mem[i+5]=f;\n+                self.mem[i+6]=g; self.mem[i+7]=h;\n             }\n         }\n+\n+        self.isaac();\n     }\n-}\n \n-impl Rng for IsaacRng {\n-    pub fn next(&self) -> u32 {\n-        unsafe {\n-            return rustrt::rand_next(self.rng);\n+    /// Refills the output buffer (`self.rsl`)\n+    priv fn isaac(&self) {\n+        self.c += 1;\n+        // abbreviations\n+        let mut a = self.a, b = self.b + self.c;\n+        let mem = &mut self.mem;\n+        let rsl = &mut self.rsl;\n+\n+        static midpoint: uint =  RAND_SIZE as uint / 2;\n+\n+        macro_rules! ind (($x:expr) => { mem[($x >> 2) & (RAND_SIZE - 1)] });\n+        macro_rules! rngstep(\n+            ($j:expr, $shift:expr) => {{\n+                let base = base + $j;\n+                let mix = if $shift < 0 {\n+                    a >> -$shift as uint\n+                } else {\n+                    a << $shift as uint\n+                };\n+\n+                let x = mem[base  + mr_offset];\n+                a = (a ^ mix) + mem[base + m2_offset];\n+                let y = ind!(x) + a + b;\n+                mem[base + mr_offset] = y;\n+\n+                b = ind!(y >> RAND_SIZE_LEN) + x;\n+                rsl[base + mr_offset] = b;\n+            }}\n+        );\n+\n+        for [(0, midpoint), (midpoint, 0)].each |&(mr_offset, m2_offset)| {\n+            for uint::range_step(0, midpoint, 4) |base| {\n+                rngstep!(0, 13);\n+                rngstep!(1, -6);\n+                rngstep!(2, 2);\n+                rngstep!(3, -16);\n+            }\n         }\n+\n+        self.a = a;\n+        self.b = b;\n+        self.cnt = RAND_SIZE;\n     }\n }\n \n-/// Create a new random seed for IsaacRng::new_seeded\n-pub fn seed() -> ~[u8] {\n-    unsafe {\n-        let n = rustrt::rand_seed_size() as uint;\n-        let mut s = vec::from_elem(n, 0_u8);\n-        do vec::as_mut_buf(s) |p, sz| {\n-            rustrt::rand_gen_seed(p, sz as size_t)\n+impl Rng for IsaacRng {\n+    #[inline(always)]\n+    fn next(&self) -> u32 {\n+        if self.cnt == 0 {\n+            // make some more numbers\n+            self.isaac();\n         }\n-        s\n+        self.cnt -= 1;\n+        self.rsl[self.cnt]\n     }\n }\n \n-struct XorShiftRng {\n+pub struct XorShiftRng {\n     priv mut x: u32,\n     priv mut y: u32,\n     priv mut z: u32,\n@@ -660,7 +766,18 @@ pub impl XorShiftRng {\n     fn new_seeded(x: u32, y: u32, z: u32, w: u32) -> XorShiftRng {\n         XorShiftRng { x: x, y: y, z: z, w: w }\n     }\n+}\n \n+/// Create a new random seed.\n+pub fn seed() -> ~[u8] {\n+    unsafe {\n+        let n = rustrt::rand_seed_size() as uint;\n+        let mut s = vec::from_elem(n, 0_u8);\n+        do vec::as_mut_buf(s) |p, sz| {\n+            rustrt::rand_gen_seed(p, sz as size_t)\n+        }\n+        s\n+    }\n }\n \n // used to make space in TLS for a random number generator\n@@ -879,6 +996,45 @@ mod tests {\n                      (u8, i8, u16, i16, u32, i32, u64, i64),\n                      (f32, (f64, (float,)))) = random();\n     }\n+\n+    #[test]\n+    fn compare_isaac_implementation() {\n+        // This is to verify that the implementation of the ISAAC rng is\n+        // correct (i.e. matches the output of the upstream implementation,\n+        // which is in the runtime)\n+        use vec;\n+        use libc::size_t;\n+\n+        #[abi = \"cdecl\"]\n+        mod rustrt {\n+            use libc::size_t;\n+\n+            #[allow(non_camel_case_types)] // runtime type\n+            pub enum rust_rng {}\n+\n+            pub extern {\n+                unsafe fn rand_new_seeded(buf: *u8, sz: size_t) -> *rust_rng;\n+                unsafe fn rand_next(rng: *rust_rng) -> u32;\n+                unsafe fn rand_free(rng: *rust_rng);\n+            }\n+        }\n+\n+        // run against several seeds\n+        for 10.times {\n+            unsafe {\n+                let seed = super::seed();\n+                let rt_rng = do vec::as_imm_buf(seed) |p, sz| {\n+                    rustrt::rand_new_seeded(p, sz as size_t)\n+                };\n+                let rng = IsaacRng::new_seeded(seed);\n+\n+                for 10000.times {\n+                    assert_eq!(rng.next(), rustrt::rand_next(rt_rng));\n+                }\n+                rustrt::rand_free(rt_rng);\n+            }\n+        }\n+    }\n }\n \n "}]}