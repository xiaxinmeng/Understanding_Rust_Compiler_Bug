{"sha": "2575b1abc97e1352b307163ac7de2142aded22a5", "node_id": "C_kwDOAAsO6NoAKDI1NzViMWFiYzk3ZTEzNTJiMzA3MTYzYWM3ZGUyMTQyYWRlZDIyYTU", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-08-19T13:48:15Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2023-01-30T17:11:35Z"}, "message": "session: diagnostic migration lint on more fns\n\nApply the diagnostic migration lint to more functions on `Session`.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "7990ade06ccd75cdcbb3a8c9a07c6d255c60cf22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7990ade06ccd75cdcbb3a8c9a07c6d255c60cf22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2575b1abc97e1352b307163ac7de2142aded22a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2575b1abc97e1352b307163ac7de2142aded22a5", "html_url": "https://github.com/rust-lang/rust/commit/2575b1abc97e1352b307163ac7de2142aded22a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2575b1abc97e1352b307163ac7de2142aded22a5/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d45004806d04225bab2f86076bcc6d6a8862b2a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d45004806d04225bab2f86076bcc6d6a8862b2a9", "html_url": "https://github.com/rust-lang/rust/commit/d45004806d04225bab2f86076bcc6d6a8862b2a9"}], "stats": {"total": 670, "additions": 509, "deletions": 161}, "files": [{"sha": "c71413e8e7c04f96c548b12d354528127a315bf5", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -369,6 +369,8 @@ pub(super) fn dump_mir_results<'tcx>(\n     };\n }\n \n+#[allow(rustc::diagnostic_outside_of_impl)]\n+#[allow(rustc::untranslatable_diagnostic)]\n pub(super) fn dump_annotation<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     body: &Body<'tcx>,"}, {"sha": "5ab87feb98b1152ad306dfaac35ab4f66c5ee944", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -200,6 +200,7 @@ unsafe impl Sync for GccContext {}\n impl WriteBackendMethods for GccCodegenBackend {\n     type Module = GccContext;\n     type TargetMachine = ();\n+    type TargetMachineError = ();\n     type ModuleBuffer = ModuleBuffer;\n     type ThinData = ();\n     type ThinBuffer = ThinBuffer;"}, {"sha": "d2e01708a37bc3c53f3ef6773e31dd5aba24081c", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -1,5 +1,7 @@\n use crate::back::write::{self, save_temp_bitcode, DiagnosticHandlers};\n-use crate::errors::DynamicLinkingWithLTO;\n+use crate::errors::{\n+    DynamicLinkingWithLTO, LlvmError, LtoBitcodeFromRlib, LtoDisallowed, LtoDylib,\n+};\n use crate::llvm::{self, build_string};\n use crate::{LlvmCodegenBackend, ModuleLlvm};\n use object::read::archive::ArchiveFile;\n@@ -77,15 +79,12 @@ fn prepare_lto(\n         // Make sure we actually can run LTO\n         for crate_type in cgcx.crate_types.iter() {\n             if !crate_type_allows_lto(*crate_type) {\n-                let e = diag_handler.fatal(\n-                    \"lto can only be run for executables, cdylibs and \\\n-                                            static library outputs\",\n-                );\n-                return Err(e);\n+                diag_handler.emit_err(LtoDisallowed);\n+                return Err(FatalError);\n             } else if *crate_type == CrateType::Dylib {\n                 if !cgcx.opts.unstable_opts.dylib_lto {\n-                    return Err(diag_handler\n-                        .fatal(\"lto cannot be used for `dylib` crate type without `-Zdylib-lto`\"));\n+                    diag_handler.emit_err(LtoDylib);\n+                    return Err(FatalError);\n                 }\n             }\n         }\n@@ -127,7 +126,10 @@ fn prepare_lto(\n                         let module = SerializedModule::FromRlib(data.to_vec());\n                         upstream_modules.push((module, CString::new(name).unwrap()));\n                     }\n-                    Err(msg) => return Err(diag_handler.fatal(&msg)),\n+                    Err(e) => {\n+                        diag_handler.emit_err(e);\n+                        return Err(FatalError);\n+                    }\n                 }\n             }\n         }\n@@ -140,7 +142,7 @@ fn prepare_lto(\n     Ok((symbols_below_threshold, upstream_modules))\n }\n \n-fn get_bitcode_slice_from_object_data(obj: &[u8]) -> Result<&[u8], String> {\n+fn get_bitcode_slice_from_object_data(obj: &[u8]) -> Result<&[u8], LtoBitcodeFromRlib> {\n     let mut len = 0;\n     let data =\n         unsafe { llvm::LLVMRustGetBitcodeSliceFromObjectData(obj.as_ptr(), obj.len(), &mut len) };\n@@ -155,8 +157,9 @@ fn get_bitcode_slice_from_object_data(obj: &[u8]) -> Result<&[u8], String> {\n         Ok(bc)\n     } else {\n         assert!(len == 0);\n-        let msg = llvm::last_error().unwrap_or_else(|| \"unknown LLVM error\".to_string());\n-        Err(format!(\"failed to get bitcode from object file for LTO ({})\", msg))\n+        Err(LtoBitcodeFromRlib {\n+            llvm_err: llvm::last_error().unwrap_or_else(|| \"unknown LLVM error\".to_string()),\n+        })\n     }\n }\n \n@@ -328,10 +331,9 @@ fn fat_lto(\n                 });\n             info!(\"linking {:?}\", name);\n             let data = bc_decoded.data();\n-            linker.add(data).map_err(|()| {\n-                let msg = format!(\"failed to load bitcode of module {:?}\", name);\n-                write::llvm_err(diag_handler, &msg)\n-            })?;\n+            linker\n+                .add(data)\n+                .map_err(|()| write::llvm_err(diag_handler, LlvmError::LoadBitcode { name }))?;\n             serialized_bitcode.push(bc_decoded);\n         }\n         drop(linker);\n@@ -489,7 +491,7 @@ fn thin_lto(\n             symbols_below_threshold.as_ptr(),\n             symbols_below_threshold.len() as u32,\n         )\n-        .ok_or_else(|| write::llvm_err(diag_handler, \"failed to prepare thin LTO context\"))?;\n+        .ok_or_else(|| write::llvm_err(diag_handler, LlvmError::PrepareThinLtoContext))?;\n \n         let data = ThinData(data);\n \n@@ -562,8 +564,7 @@ fn thin_lto(\n         // session, overwriting the previous serialized data (if any).\n         if let Some(path) = key_map_path {\n             if let Err(err) = curr_key_map.save_to_file(&path) {\n-                let msg = format!(\"Error while writing ThinLTO key data: {}\", err);\n-                return Err(write::llvm_err(diag_handler, &msg));\n+                return Err(write::llvm_err(diag_handler, LlvmError::WriteThinLtoKey { err }));\n             }\n         }\n \n@@ -689,8 +690,7 @@ pub unsafe fn optimize_thin_module(\n \n     let module_name = &thin_module.shared.module_names[thin_module.idx];\n     let tm_factory_config = TargetMachineFactoryConfig::new(cgcx, module_name.to_str().unwrap());\n-    let tm =\n-        (cgcx.tm_factory)(tm_factory_config).map_err(|e| write::llvm_err(&diag_handler, &e))?;\n+    let tm = (cgcx.tm_factory)(tm_factory_config).map_err(|e| write::llvm_err(&diag_handler, e))?;\n \n     // Right now the implementation we've got only works over serialized\n     // modules, so we create a fresh new LLVM context and parse the module\n@@ -717,8 +717,7 @@ pub unsafe fn optimize_thin_module(\n         let mut cu2 = ptr::null_mut();\n         llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n         if !cu2.is_null() {\n-            let msg = \"multiple source DICompileUnits found\";\n-            return Err(write::llvm_err(&diag_handler, msg));\n+            return Err(write::llvm_err(&diag_handler, LlvmError::MultipleSourceDiCompileUnit));\n         }\n \n         // Up next comes the per-module local analyses that we do for Thin LTO.\n@@ -733,8 +732,7 @@ pub unsafe fn optimize_thin_module(\n             let _timer =\n                 cgcx.prof.generic_activity_with_arg(\"LLVM_thin_lto_rename\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod, target) {\n-                let msg = \"failed to prepare thin LTO module\";\n-                return Err(write::llvm_err(&diag_handler, msg));\n+                return Err(write::llvm_err(&diag_handler, LlvmError::PrepareThinLtoModule));\n             }\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-rename\");\n         }\n@@ -744,8 +742,7 @@ pub unsafe fn optimize_thin_module(\n                 .prof\n                 .generic_activity_with_arg(\"LLVM_thin_lto_resolve_weak\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTOResolveWeak(thin_module.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\";\n-                return Err(write::llvm_err(&diag_handler, msg));\n+                return Err(write::llvm_err(&diag_handler, LlvmError::PrepareThinLtoModule));\n             }\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-resolve\");\n         }\n@@ -755,8 +752,7 @@ pub unsafe fn optimize_thin_module(\n                 .prof\n                 .generic_activity_with_arg(\"LLVM_thin_lto_internalize\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTOInternalize(thin_module.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\";\n-                return Err(write::llvm_err(&diag_handler, msg));\n+                return Err(write::llvm_err(&diag_handler, LlvmError::PrepareThinLtoModule));\n             }\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-internalize\");\n         }\n@@ -765,8 +761,7 @@ pub unsafe fn optimize_thin_module(\n             let _timer =\n                 cgcx.prof.generic_activity_with_arg(\"LLVM_thin_lto_import\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod, target) {\n-                let msg = \"failed to prepare thin LTO module\";\n-                return Err(write::llvm_err(&diag_handler, msg));\n+                return Err(write::llvm_err(&diag_handler, LlvmError::PrepareThinLtoModule));\n             }\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-import\");\n         }\n@@ -886,11 +881,7 @@ pub fn parse_module<'a>(\n     diag_handler: &Handler,\n ) -> Result<&'a llvm::Module, FatalError> {\n     unsafe {\n-        llvm::LLVMRustParseBitcodeForLTO(cx, data.as_ptr(), data.len(), name.as_ptr()).ok_or_else(\n-            || {\n-                let msg = \"failed to parse bitcode for LTO module\";\n-                write::llvm_err(diag_handler, msg)\n-            },\n-        )\n+        llvm::LLVMRustParseBitcodeForLTO(cx, data.as_ptr(), data.len(), name.as_ptr())\n+            .ok_or_else(|| write::llvm_err(diag_handler, LlvmError::ParseBitcode))\n     }\n }"}, {"sha": "38f8733763dfa9200bef4e06a03b2d07de56395b", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -5,6 +5,9 @@ use crate::back::profiling::{\n use crate::base;\n use crate::common;\n use crate::consts;\n+use crate::errors::{\n+    CopyBitcode, FromLlvmDiag, FromLlvmOptimizationDiag, LlvmError, WithLlvmError, WriteBytecode,\n+};\n use crate::llvm::{self, DiagnosticInfo, PassManager};\n use crate::llvm_util;\n use crate::type_::Type;\n@@ -37,10 +40,10 @@ use std::slice;\n use std::str;\n use std::sync::Arc;\n \n-pub fn llvm_err(handler: &rustc_errors::Handler, msg: &str) -> FatalError {\n+pub fn llvm_err<'a>(handler: &rustc_errors::Handler, err: LlvmError<'a>) -> FatalError {\n     match llvm::last_error() {\n-        Some(err) => handler.fatal(&format!(\"{}: {}\", msg, err)),\n-        None => handler.fatal(msg),\n+        Some(llvm_err) => handler.emit_almost_fatal(WithLlvmError(err, llvm_err)),\n+        None => handler.emit_almost_fatal(err),\n     }\n }\n \n@@ -85,10 +88,9 @@ pub fn write_output_file<'ll>(\n             }\n         }\n \n-        result.into_result().map_err(|()| {\n-            let msg = format!(\"could not write output to {}\", output.display());\n-            llvm_err(handler, &msg)\n-        })\n+        result\n+            .into_result()\n+            .map_err(|()| llvm_err(handler, LlvmError::WriteOutput { path: output }))\n     }\n }\n \n@@ -98,7 +100,7 @@ pub fn create_informational_target_machine(sess: &Session) -> &'static mut llvm:\n     // system/tcx is set up.\n     let features = llvm_util::global_llvm_features(sess, false);\n     target_machine_factory(sess, config::OptLevel::No, &features)(config)\n-        .unwrap_or_else(|err| llvm_err(sess.diagnostic(), &err).raise())\n+        .unwrap_or_else(|err| llvm_err(sess.diagnostic(), err).raise())\n }\n \n pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut llvm::TargetMachine {\n@@ -117,7 +119,7 @@ pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut ll\n         tcx.backend_optimization_level(()),\n         tcx.global_backend_features(()),\n     )(config)\n-    .unwrap_or_else(|err| llvm_err(tcx.sess.diagnostic(), &err).raise())\n+    .unwrap_or_else(|err| llvm_err(tcx.sess.diagnostic(), err).raise())\n }\n \n pub fn to_llvm_opt_settings(\n@@ -240,9 +242,7 @@ pub fn target_machine_factory(\n             )\n         };\n \n-        tm.ok_or_else(|| {\n-            format!(\"Could not create LLVM TargetMachine for triple: {}\", triple.to_str().unwrap())\n-        })\n+        tm.ok_or_else(|| LlvmError::CreateTargetMachine { triple: triple.clone() })\n     })\n }\n \n@@ -355,25 +355,28 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n             };\n \n             if enabled {\n-                diag_handler.note_without_error(&format!(\n-                    \"{}:{}:{}: {}: {}\",\n-                    opt.filename, opt.line, opt.column, opt.pass_name, opt.message,\n-                ));\n+                diag_handler.emit_note(FromLlvmOptimizationDiag {\n+                    filename: &opt.filename,\n+                    line: opt.line,\n+                    column: opt.column,\n+                    pass_name: &opt.pass_name,\n+                    message: &opt.message,\n+                });\n             }\n         }\n         llvm::diagnostic::PGO(diagnostic_ref) | llvm::diagnostic::Linker(diagnostic_ref) => {\n-            let msg = llvm::build_string(|s| {\n+            let message = llvm::build_string(|s| {\n                 llvm::LLVMRustWriteDiagnosticInfoToString(diagnostic_ref, s)\n             })\n             .expect(\"non-UTF8 diagnostic\");\n-            diag_handler.warn(&msg);\n+            diag_handler.emit_warning(FromLlvmDiag { message });\n         }\n         llvm::diagnostic::Unsupported(diagnostic_ref) => {\n-            let msg = llvm::build_string(|s| {\n+            let message = llvm::build_string(|s| {\n                 llvm::LLVMRustWriteDiagnosticInfoToString(diagnostic_ref, s)\n             })\n             .expect(\"non-UTF8 diagnostic\");\n-            diag_handler.err(&msg);\n+            diag_handler.emit_err(FromLlvmDiag { message });\n         }\n         llvm::diagnostic::UnknownDiagnostic(..) => {}\n     }\n@@ -494,7 +497,7 @@ pub(crate) unsafe fn llvm_optimize(\n         llvm_plugins.as_ptr().cast(),\n         llvm_plugins.len(),\n     );\n-    result.into_result().map_err(|()| llvm_err(diag_handler, \"failed to run LLVM passes\"))\n+    result.into_result().map_err(|()| llvm_err(diag_handler, LlvmError::RunLlvmPasses))\n }\n \n // Unsafe due to LLVM calls.\n@@ -547,8 +550,7 @@ pub(crate) fn link(\n         let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_link_module\", &*module.name);\n         let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n         linker.add(buffer.data()).map_err(|()| {\n-            let msg = format!(\"failed to serialize module {:?}\", module.name);\n-            llvm_err(diag_handler, &msg)\n+            llvm_err(diag_handler, LlvmError::SerializeModule { name: &module.name })\n         })?;\n     }\n     drop(linker);\n@@ -626,9 +628,8 @@ pub(crate) unsafe fn codegen(\n                 let _timer = cgcx\n                     .prof\n                     .generic_activity_with_arg(\"LLVM_module_codegen_emit_bitcode\", &*module.name);\n-                if let Err(e) = fs::write(&bc_out, data) {\n-                    let msg = format!(\"failed to write bytecode to {}: {}\", bc_out.display(), e);\n-                    diag_handler.err(&msg);\n+                if let Err(err) = fs::write(&bc_out, data) {\n+                    diag_handler.emit_err(WriteBytecode { path: &bc_out, err });\n                 }\n             }\n \n@@ -678,10 +679,9 @@ pub(crate) unsafe fn codegen(\n                 record_artifact_size(&cgcx.prof, \"llvm_ir\", &out);\n             }\n \n-            result.into_result().map_err(|()| {\n-                let msg = format!(\"failed to write LLVM IR to {}\", out.display());\n-                llvm_err(diag_handler, &msg)\n-            })?;\n+            result\n+                .into_result()\n+                .map_err(|()| llvm_err(diag_handler, LlvmError::WriteIr { path: &out }))?;\n         }\n \n         if config.emit_asm {\n@@ -749,8 +749,8 @@ pub(crate) unsafe fn codegen(\n \n             EmitObj::Bitcode => {\n                 debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n-                if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n-                    diag_handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n+                if let Err(err) = link_or_copy(&bc_out, &obj_out) {\n+                    diag_handler.emit_err(CopyBitcode { err });\n                 }\n \n                 if !config.emit_bc {"}, {"sha": "81072edc475c4a2f2f27890c584cd5c1b35a9174", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "modified", "additions": 114, "deletions": 9, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -1,10 +1,11 @@\n use std::borrow::Cow;\n+use std::ffi::CString;\n+use std::path::Path;\n \n-use rustc_errors::fluent;\n-use rustc_errors::DiagnosticBuilder;\n-use rustc_errors::ErrorGuaranteed;\n-use rustc_errors::Handler;\n-use rustc_errors::IntoDiagnostic;\n+use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc_errors::{\n+    fluent, DiagnosticBuilder, EmissionGuarantee, ErrorGuaranteed, Handler, IntoDiagnostic,\n+};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::Span;\n \n@@ -81,10 +82,18 @@ pub(crate) struct DlltoolFailImportLibrary<'a> {\n #[note]\n pub(crate) struct DynamicLinkingWithLTO;\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_llvm_fail_parsing_target_machine_config_to_target_machine)]\n-pub(crate) struct FailParsingTargetMachineConfigToTargetMachine {\n-    pub error: String,\n+pub(crate) struct ParseTargetMachineConfig<'a>(pub LlvmError<'a>);\n+\n+impl<EM: EmissionGuarantee> IntoDiagnostic<'_, EM> for ParseTargetMachineConfig<'_> {\n+    fn into_diagnostic(self, sess: &'_ Handler) -> DiagnosticBuilder<'_, EM> {\n+        let diag: DiagnosticBuilder<'_, EM> = self.0.into_diagnostic(sess);\n+        let (message, _) = diag.styled_message().first().expect(\"`LlvmError` with no message\");\n+        let message = sess.eagerly_translate_to_string(message.clone(), diag.args());\n+\n+        let mut diag = sess.struct_diagnostic(fluent::codegen_llvm_parse_target_machine_config);\n+        diag.set_arg(\"error\", message);\n+        diag\n+    }\n }\n \n pub(crate) struct TargetFeatureDisableOrEnable<'a> {\n@@ -110,3 +119,99 @@ impl IntoDiagnostic<'_, ErrorGuaranteed> for TargetFeatureDisableOrEnable<'_> {\n         diag\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_lto_disallowed)]\n+pub(crate) struct LtoDisallowed;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_lto_dylib)]\n+pub(crate) struct LtoDylib;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_lto_bitcode_from_rlib)]\n+pub(crate) struct LtoBitcodeFromRlib {\n+    pub llvm_err: String,\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum LlvmError<'a> {\n+    #[diag(codegen_llvm_write_output)]\n+    WriteOutput { path: &'a Path },\n+    #[diag(codegen_llvm_target_machine)]\n+    CreateTargetMachine { triple: SmallCStr },\n+    #[diag(codegen_llvm_run_passes)]\n+    RunLlvmPasses,\n+    #[diag(codegen_llvm_serialize_module)]\n+    SerializeModule { name: &'a str },\n+    #[diag(codegen_llvm_write_ir)]\n+    WriteIr { path: &'a Path },\n+    #[diag(codegen_llvm_prepare_thin_lto_context)]\n+    PrepareThinLtoContext,\n+    #[diag(codegen_llvm_load_bitcode)]\n+    LoadBitcode { name: CString },\n+    #[diag(codegen_llvm_write_thinlto_key)]\n+    WriteThinLtoKey { err: std::io::Error },\n+    #[diag(codegen_llvm_multiple_source_dicompileunit)]\n+    MultipleSourceDiCompileUnit,\n+    #[diag(codegen_llvm_prepare_thin_lto_module)]\n+    PrepareThinLtoModule,\n+    #[diag(codegen_llvm_parse_bitcode)]\n+    ParseBitcode,\n+}\n+\n+pub(crate) struct WithLlvmError<'a>(pub LlvmError<'a>, pub String);\n+\n+impl<EM: EmissionGuarantee> IntoDiagnostic<'_, EM> for WithLlvmError<'_> {\n+    fn into_diagnostic(self, sess: &'_ Handler) -> DiagnosticBuilder<'_, EM> {\n+        use LlvmError::*;\n+        let msg_with_llvm_err = match &self.0 {\n+            WriteOutput { .. } => fluent::codegen_llvm_write_output_with_llvm_err,\n+            CreateTargetMachine { .. } => fluent::codegen_llvm_target_machine_with_llvm_err,\n+            RunLlvmPasses => fluent::codegen_llvm_run_passes_with_llvm_err,\n+            SerializeModule { .. } => fluent::codegen_llvm_serialize_module_with_llvm_err,\n+            WriteIr { .. } => fluent::codegen_llvm_write_ir_with_llvm_err,\n+            PrepareThinLtoContext => fluent::codegen_llvm_prepare_thin_lto_context_with_llvm_err,\n+            LoadBitcode { .. } => fluent::codegen_llvm_load_bitcode_with_llvm_err,\n+            WriteThinLtoKey { .. } => fluent::codegen_llvm_write_thinlto_key_with_llvm_err,\n+            MultipleSourceDiCompileUnit => {\n+                fluent::codegen_llvm_multiple_source_dicompileunit_with_llvm_err\n+            }\n+            PrepareThinLtoModule => fluent::codegen_llvm_prepare_thin_lto_module_with_llvm_err,\n+            ParseBitcode => fluent::codegen_llvm_parse_bitcode_with_llvm_err,\n+        };\n+        let mut diag = self.0.into_diagnostic(sess);\n+        diag.set_primary_message(msg_with_llvm_err);\n+        diag.set_arg(\"llvm_err\", self.1);\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_from_llvm_optimization_diag)]\n+pub(crate) struct FromLlvmOptimizationDiag<'a> {\n+    pub filename: &'a str,\n+    pub line: std::ffi::c_uint,\n+    pub column: std::ffi::c_uint,\n+    pub pass_name: &'a str,\n+    pub message: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_from_llvm_diag)]\n+pub(crate) struct FromLlvmDiag {\n+    pub message: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_write_bytecode)]\n+pub(crate) struct WriteBytecode<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_copy_bitcode)]\n+pub(crate) struct CopyBitcode {\n+    pub err: std::io::Error,\n+}"}, {"sha": "111d14b265cdee055a3c19c370de8b95a8cde699", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -5,11 +5,12 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(extern_types)]\n #![feature(hash_raw_entry)]\n+#![feature(iter_intersperse)]\n #![feature(let_chains)]\n-#![feature(extern_types)]\n+#![feature(never_type)]\n #![feature(once_cell)]\n-#![feature(iter_intersperse)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]\n@@ -22,7 +23,7 @@ extern crate tracing;\n \n use back::write::{create_informational_target_machine, create_target_machine};\n \n-use errors::FailParsingTargetMachineConfigToTargetMachine;\n+use errors::ParseTargetMachineConfig;\n pub use llvm_util::target_features;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n@@ -169,6 +170,7 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     type Module = ModuleLlvm;\n     type ModuleBuffer = back::lto::ModuleBuffer;\n     type TargetMachine = &'static mut llvm::TargetMachine;\n+    type TargetMachineError = crate::errors::LlvmError<'static>;\n     type ThinData = back::lto::ThinData;\n     type ThinBuffer = back::lto::ThinBuffer;\n     fn print_pass_timings(&self) {\n@@ -416,8 +418,7 @@ impl ModuleLlvm {\n             let tm = match (cgcx.tm_factory)(tm_factory_config) {\n                 Ok(m) => m,\n                 Err(e) => {\n-                    handler.emit_err(FailParsingTargetMachineConfigToTargetMachine { error: e });\n-                    return Err(FatalError);\n+                    return Err(handler.emit_almost_fatal(ParseTargetMachineConfig(e)));\n                 }\n             };\n "}, {"sha": "8508ab87532c27e1478abe7f82d4523f5d9554e4", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -305,8 +305,12 @@ impl TargetMachineFactoryConfig {\n }\n \n pub type TargetMachineFactoryFn<B> = Arc<\n-    dyn Fn(TargetMachineFactoryConfig) -> Result<<B as WriteBackendMethods>::TargetMachine, String>\n-        + Send\n+    dyn Fn(\n+            TargetMachineFactoryConfig,\n+        ) -> Result<\n+            <B as WriteBackendMethods>::TargetMachine,\n+            <B as WriteBackendMethods>::TargetMachineError,\n+        > + Send\n         + Sync,\n >;\n "}, {"sha": "9826256a4c5d5a8117b53e0e0ee839d20b65b5e5", "filename": "compiler/rustc_codegen_ssa/src/traits/write.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -8,6 +8,7 @@ use rustc_middle::dep_graph::WorkProduct;\n pub trait WriteBackendMethods: 'static + Sized + Clone {\n     type Module: Send + Sync;\n     type TargetMachine;\n+    type TargetMachineError;\n     type ModuleBuffer: ModuleBufferMethods;\n     type ThinData: Send + Sync;\n     type ThinBuffer: ThinBufferMethods;"}, {"sha": "02e0b042ad2631eadad94771b4a2dfab2c2defd4", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -43,7 +43,6 @@ use rustc_span::source_map::{FileLoader, FileName};\n use rustc_span::symbol::sym;\n use rustc_target::json::ToJson;\n \n-use std::borrow::Cow;\n use std::cmp::max;\n use std::env;\n use std::ffi::OsString;\n@@ -1205,29 +1204,20 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n         handler.emit_diagnostic(&mut d);\n     }\n \n-    let mut xs: Vec<Cow<'static, str>> = vec![\n-        \"the compiler unexpectedly panicked. this is a bug.\".into(),\n-        format!(\"we would appreciate a bug report: {bug_report_url}\").into(),\n-        format!(\n-            \"rustc {} running on {}\",\n-            util::version_str!().unwrap_or(\"unknown_version\"),\n-            config::host_triple()\n-        )\n-        .into(),\n-    ];\n+    handler.emit_note(session_diagnostics::Ice);\n+    handler.emit_note(session_diagnostics::IceBugReport { bug_report_url });\n+    handler.emit_note(session_diagnostics::IceVersion {\n+        version: util::version_str!().unwrap_or(\"unknown_version\"),\n+        triple: config::host_triple(),\n+    });\n \n     if let Some((flags, excluded_cargo_defaults)) = extra_compiler_flags() {\n-        xs.push(format!(\"compiler flags: {}\", flags.join(\" \")).into());\n-\n+        handler.emit_note(session_diagnostics::IceFlags { flags: flags.join(\" \") });\n         if excluded_cargo_defaults {\n-            xs.push(\"some of the compiler flags provided by cargo are hidden\".into());\n+            handler.emit_note(session_diagnostics::IceExcludeCargoDefaults);\n         }\n     }\n \n-    for note in &xs {\n-        handler.note_without_error(note.as_ref());\n-    }\n-\n     // If backtraces are enabled, also print the query stack\n     let backtrace = env::var_os(\"RUST_BACKTRACE\").map_or(false, |x| &x != \"0\");\n "}, {"sha": "a7aef9cbc2c8af5b00bae47a92920e10825248d7", "filename": "compiler/rustc_driver/src/session_diagnostics.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -38,3 +38,30 @@ pub(crate) struct UnprettyDumpFail {\n     pub path: String,\n     pub err: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(driver_ice)]\n+pub(crate) struct Ice;\n+\n+#[derive(Diagnostic)]\n+#[diag(driver_ice_bug_report)]\n+pub(crate) struct IceBugReport<'a> {\n+    pub bug_report_url: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(driver_ice_version)]\n+pub(crate) struct IceVersion<'a> {\n+    pub version: &'a str,\n+    pub triple: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(driver_ice_flags)]\n+pub(crate) struct IceFlags {\n+    pub flags: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(driver_ice_exclude_cargo_defaults)]\n+pub(crate) struct IceExcludeCargoDefaults;"}, {"sha": "e5df417370bb9030abf8ad18fe765b4bc0f265fc", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_llvm.ftl", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -39,5 +39,51 @@ codegen_llvm_dynamic_linking_with_lto =\n     cannot prefer dynamic linking when performing LTO\n     .note = only 'staticlib', 'bin', and 'cdylib' outputs are supported with LTO\n \n-codegen_llvm_fail_parsing_target_machine_config_to_target_machine =\n+codegen_llvm_parse_target_machine_config =\n     failed to parse target machine config to target machine: {$error}\n+\n+codegen_llvm_lto_disallowed = lto can only be run for executables, cdylibs and static library outputs\n+\n+codegen_llvm_lto_dylib = lto cannot be used for `dylib` crate type without `-Zdylib-lto`\n+\n+codegen_llvm_lto_bitcode_from_rlib = failed to get bitcode from object file for LTO ({$llvm_err})\n+\n+codegen_llvm_write_output = could not write output to {$path}\n+codegen_llvm_write_output_with_llvm_err = could not write output to {$path}: {$llvm_err}\n+\n+codegen_llvm_target_machine = could not create LLVM TargetMachine for triple: {$triple}\n+codegen_llvm_target_machine_with_llvm_err = could not create LLVM TargetMachine for triple: {$triple}: {$llvm_err}\n+\n+codegen_llvm_run_passes = failed to run LLVM passes\n+codegen_llvm_run_passes_with_llvm_err = failed to run LLVM passes: {$llvm_err}\n+\n+codegen_llvm_serialize_module = failed to serialize module {$name}\n+codegen_llvm_serialize_module_with_llvm_err = failed to serialize module {$name}: {$llvm_err}\n+\n+codegen_llvm_write_ir = failed to write LLVM IR to {$path}\n+codegen_llvm_write_ir_with_llvm_err = failed to write LLVM IR to {$path}: {$llvm_err}\n+\n+codegen_llvm_prepare_thin_lto_context = failed to prepare thin LTO context\n+codegen_llvm_prepare_thin_lto_context_with_llvm_err = failed to prepare thin LTO context: {$llvm_err}\n+\n+codegen_llvm_load_bitcode = failed to load bitcode of module \"{$name}\"\n+codegen_llvm_load_bitcode_with_llvm_err = failed to load bitcode of module \"{$name}\": {$llvm_err}\n+\n+codegen_llvm_write_thinlto_key = error while writing ThinLTO key data: {$err}\n+codegen_llvm_write_thinlto_key_with_llvm_err = error while writing ThinLTO key data: {$err}: {$llvm_err}\n+\n+codegen_llvm_multiple_source_dicompileunit = multiple source DICompileUnits found\n+codegen_llvm_multiple_source_dicompileunit_with_llvm_err = multiple source DICompileUnits found: {$llvm_err}\n+\n+codegen_llvm_prepare_thin_lto_module = failed to prepare thin LTO module\n+codegen_llvm_prepare_thin_lto_module_with_llvm_err = failed to prepare thin LTO module: {$llvm_err}\n+\n+codegen_llvm_parse_bitcode = failed to parse bitcode for LTO module\n+codegen_llvm_parse_bitcode_with_llvm_err = failed to parse bitcode for LTO module: {$llvm_err}\n+\n+codegen_llvm_from_llvm_optimization_diag = {$filename}:{$line}:{$column} {$pass_name}: {$message}\n+codegen_llvm_from_llvm_diag = {$message}\n+\n+codegen_llvm_write_bytecode = failed to write bytecode to {$path}: {$err}\n+\n+codegen_llvm_copy_bitcode = failed to copy bitcode to object file: {$err}"}, {"sha": "79ffc82c6c67d096d0f51b3b3030f6263d39ce85", "filename": "compiler/rustc_error_messages/locales/en-US/driver.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -11,3 +11,9 @@ driver_rlink_rustc_version_mismatch = .rlink file was produced by rustc version\n driver_rlink_no_a_file = rlink must be a file\n \n driver_unpretty_dump_fail = pretty-print failed to write `{$path}` due to error `{$err}`\n+\n+driver_ice = the compiler unexpectedly panicked. this is a bug.\n+driver_ice_bug_report = we would appreciate a bug report: {$bug_report_url}\n+driver_ice_version = rustc {$version} running on {$triple}\n+driver_ice_flags = compiler flags: {$flags}\n+driver_ice_exclude_cargo_defaults = some of the compiler flags provided by cargo are hidden"}, {"sha": "dbd80954382dbbaf52c9f287da7748d7b8c63fc8", "filename": "compiler/rustc_error_messages/locales/en-US/expand.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -127,3 +127,5 @@ expand_module_file_not_found =\n expand_module_multiple_candidates =\n     file for module `{$name}` found at both \"{$default_path}\" and \"{$secondary_path}\"\n     .help = delete or rename one of them to remove the ambiguity\n+\n+expand_trace_macro = trace_macro"}, {"sha": "a7bc0e7af1fe9e2a7ed8c3f349ad68171b1d3e35", "filename": "compiler/rustc_error_messages/locales/en-US/interface.ftl", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -44,3 +44,13 @@ interface_failed_writing_file =\n \n interface_proc_macro_crate_panic_abort =\n     building proc macro crate with `panic=abort` may crash the compiler should the proc-macro panic\n+\n+interface_unsupported_crate_type_for_target =\n+    dropping unsupported crate type `{$crate_type}` for target `{$target_triple}`\n+\n+interface_multiple_output_types_adaption =\n+    due to multiple output types requested, the explicitly specified output file name will be adapted for each output type\n+\n+interface_ignoring_extra_filename = ignoring -C extra-filename flag due to -o flag\n+\n+interface_ignoring_out_dir = ignoring --out-dir flag due to -o flag"}, {"sha": "6cea6a603f336564c77b24dc8930eeaa48fc9ca7", "filename": "compiler/rustc_error_messages/locales/en-US/monomorphize.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -24,3 +24,9 @@ monomorphize_large_assignments =\n \n monomorphize_couldnt_dump_mono_stats =\n     unexpected error occurred while dumping monomorphization stats: {$error}\n+\n+monomorphize_encountered_error_while_instantiating =\n+    the above error was encountered while instantiating `{$formatted_item}`\n+\n+monomorphize_unknown_cgu_collection_mode =\n+    unknown codegen-item collection mode '{$mode}', falling back to 'lazy' mode"}, {"sha": "6ebb188288f0016e604ebfcd3b1ce207fdc2e14c", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -731,3 +731,5 @@ passes_proc_macro_missing_args = mismatched {$kind} signature\n passes_proc_macro_invalid_abi = proc macro functions may not be `extern \"{$abi}\"`\n \n passes_proc_macro_unsafe = proc macro functions may not be `unsafe`\n+\n+passes_skipping_const_checks = skipping const checks"}, {"sha": "5984c201af0d01ba0a70e21985d0deff0a40c54e", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -89,3 +89,5 @@ session_int_literal_too_large = integer literal is too large\n \n session_invalid_int_literal_width = invalid width `{$width}` for integer literal\n     .help = valid widths are 8, 16, 32, 64 and 128\n+\n+session_optimization_fuel_exhausted = optimization-fuel-exhausted: {$msg}"}, {"sha": "df949e46fbde507e9bdeee514e4d979fca56c7de", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -1051,6 +1051,7 @@ impl Diagnostic {\n     ) -> (\n         &Level,\n         &[(DiagnosticMessage, Style)],\n+        Vec<(&Cow<'static, str>, &DiagnosticArgValue<'static>)>,\n         &Option<DiagnosticId>,\n         &MultiSpan,\n         &Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n@@ -1059,6 +1060,7 @@ impl Diagnostic {\n         (\n             &self.level,\n             &self.message,\n+            self.args().collect(),\n             &self.code,\n             &self.span,\n             &self.suggestions,"}, {"sha": "c9d662ad43fe50ed08359748f921deec6c1e11e0", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -408,6 +408,59 @@ impl EmissionGuarantee for ! {\n     }\n }\n \n+impl<'a> DiagnosticBuilder<'a, rustc_span::fatal_error::FatalError> {\n+    /// Convenience function for internal use, clients should use one of the\n+    /// `struct_*` methods on [`Handler`].\n+    #[track_caller]\n+    pub(crate) fn new_almost_fatal(\n+        handler: &'a Handler,\n+        message: impl Into<DiagnosticMessage>,\n+    ) -> Self {\n+        let diagnostic = Diagnostic::new_with_code(Level::Fatal, None, message);\n+        Self::new_diagnostic_almost_fatal(handler, diagnostic)\n+    }\n+\n+    /// Creates a new `DiagnosticBuilder` with an already constructed\n+    /// diagnostic.\n+    pub(crate) fn new_diagnostic_almost_fatal(\n+        handler: &'a Handler,\n+        diagnostic: Diagnostic,\n+    ) -> Self {\n+        debug!(\"Created new diagnostic\");\n+        Self {\n+            inner: DiagnosticBuilderInner {\n+                state: DiagnosticBuilderState::Emittable(handler),\n+                diagnostic: Box::new(diagnostic),\n+            },\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl EmissionGuarantee for rustc_span::fatal_error::FatalError {\n+    fn diagnostic_builder_emit_producing_guarantee(db: &mut DiagnosticBuilder<'_, Self>) -> Self {\n+        match db.inner.state {\n+            // First `.emit()` call, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                db.inner.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+\n+                handler.emit_diagnostic(&mut db.inner.diagnostic);\n+            }\n+            // `.emit()` was previously called, disallowed from repeating it.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {}\n+        }\n+        // Then fatally error..\n+        rustc_span::fatal_error::FatalError\n+    }\n+\n+    fn make_diagnostic_builder(\n+        handler: &Handler,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, Self> {\n+        DiagnosticBuilder::new_almost_fatal(handler, msg)\n+    }\n+}\n+\n /// In general, the `DiagnosticBuilder` uses deref to allow access to\n /// the fields and methods of the embedded `diagnostic` in a\n /// transparent way. *However,* many of the methods are intended to"}, {"sha": "7a94ce3777a29c8337b3439a50ce8e376ddc3cb6", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -159,12 +159,6 @@ impl IntoDiagnosticArg for ast::Path {\n     }\n }\n \n-impl IntoDiagnosticArg for &ast::Path {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(pprust::path_to_string(self)))\n-    }\n-}\n-\n impl IntoDiagnosticArg for ast::token::Token {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(pprust::token_to_string(&self))\n@@ -183,6 +177,18 @@ impl IntoDiagnosticArg for type_ir::FloatTy {\n     }\n }\n \n+impl IntoDiagnosticArg for std::ffi::CString {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string_lossy().into_owned()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for rustc_data_structures::small_c_str::SmallCStr {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string_lossy().into_owned()))\n+    }\n+}\n+\n impl IntoDiagnosticArg for Level {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(Cow::Borrowed(self.to_cmd_flag()))"}, {"sha": "ec04e865d53b105ae1ddf3101f10c511889e6369", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -617,22 +617,24 @@ impl Handler {\n         }\n     }\n \n-    /// Translate `message` eagerly with `args`.\n+    /// Translate `message` eagerly with `args` to `SubdiagnosticMessage::Eager`.\n     pub fn eagerly_translate<'a>(\n         &self,\n         message: DiagnosticMessage,\n         args: impl Iterator<Item = DiagnosticArg<'a, 'static>>,\n     ) -> SubdiagnosticMessage {\n+        SubdiagnosticMessage::Eager(self.eagerly_translate_to_string(message, args))\n+    }\n+\n+    /// Translate `message` eagerly with `args` to `String`.\n+    pub fn eagerly_translate_to_string<'a>(\n+        &self,\n+        message: DiagnosticMessage,\n+        args: impl Iterator<Item = DiagnosticArg<'a, 'static>>,\n+    ) -> String {\n         let inner = self.inner.borrow();\n         let args = crate::translation::to_fluent_args(args);\n-        SubdiagnosticMessage::Eager(\n-            inner\n-                .emitter\n-                .translate_message(&message, &args)\n-                .map_err(Report::new)\n-                .unwrap()\n-                .to_string(),\n-        )\n+        inner.emitter.translate_message(&message, &args).map_err(Report::new).unwrap().to_string()\n     }\n \n     // This is here to not allow mutation of flags;\n@@ -1010,6 +1012,7 @@ impl Handler {\n     }\n \n     #[track_caller]\n+    #[rustc_lint_diagnostics]\n     pub fn span_note_without_error(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -1019,6 +1022,7 @@ impl Handler {\n     }\n \n     #[track_caller]\n+    #[rustc_lint_diagnostics]\n     pub fn span_note_diag(\n         &self,\n         span: Span,\n@@ -1030,19 +1034,23 @@ impl Handler {\n     }\n \n     // NOTE: intentionally doesn't raise an error so rustc_codegen_ssa only reports fatal errors in the main thread\n+    #[rustc_lint_diagnostics]\n     pub fn fatal(&self, msg: impl Into<DiagnosticMessage>) -> FatalError {\n         self.inner.borrow_mut().fatal(msg)\n     }\n \n+    #[rustc_lint_diagnostics]\n     pub fn err(&self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.inner.borrow_mut().err(msg)\n     }\n \n+    #[rustc_lint_diagnostics]\n     pub fn warn(&self, msg: impl Into<DiagnosticMessage>) {\n         let mut db = DiagnosticBuilder::new(self, Warning(None), msg);\n         db.emit();\n     }\n \n+    #[rustc_lint_diagnostics]\n     pub fn note_without_error(&self, msg: impl Into<DiagnosticMessage>) {\n         DiagnosticBuilder::new(self, Note, msg).emit();\n     }\n@@ -1059,6 +1067,7 @@ impl Handler {\n     pub fn has_errors(&self) -> Option<ErrorGuaranteed> {\n         if self.inner.borrow().has_errors() { Some(ErrorGuaranteed(())) } else { None }\n     }\n+\n     pub fn has_errors_or_lint_errors(&self) -> Option<ErrorGuaranteed> {\n         if self.inner.borrow().has_errors_or_lint_errors() {\n             Some(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n@@ -1132,6 +1141,20 @@ impl Handler {\n         self.create_warning(warning).emit()\n     }\n \n+    pub fn create_almost_fatal<'a>(\n+        &'a self,\n+        fatal: impl IntoDiagnostic<'a, FatalError>,\n+    ) -> DiagnosticBuilder<'a, FatalError> {\n+        fatal.into_diagnostic(self)\n+    }\n+\n+    pub fn emit_almost_fatal<'a>(\n+        &'a self,\n+        fatal: impl IntoDiagnostic<'a, FatalError>,\n+    ) -> FatalError {\n+        self.create_almost_fatal(fatal).emit()\n+    }\n+\n     pub fn create_fatal<'a>(\n         &'a self,\n         fatal: impl IntoDiagnostic<'a, !>,"}, {"sha": "5a48473d5b07c90646808d0daa86112b2a124f21", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -4,7 +4,7 @@ use crate::errors::{\n     ArgumentNotAttributes, AttrNoArguments, AttributeMetaItem, AttributeSingleWord,\n     AttributesWrongForm, CannotBeNameOfMacro, ExpectedCommaInList, HelperAttributeNameInvalid,\n     MacroBodyStability, MacroConstStability, NotAMetaItem, OnlyOneArgument, OnlyOneWord,\n-    ResolveRelativePath, TakesNoArguments,\n+    ResolveRelativePath, TakesNoArguments, TraceMacro,\n };\n use crate::expand::{self, AstFragment, Invocation};\n use crate::module::DirOwnership;\n@@ -1142,8 +1142,8 @@ impl<'a> ExtCtxt<'a> {\n         self.sess.parse_sess.span_diagnostic.span_bug(sp, msg);\n     }\n     pub fn trace_macros_diag(&mut self) {\n-        for (sp, notes) in self.expansions.iter() {\n-            let mut db = self.sess.parse_sess.span_diagnostic.span_note_diag(*sp, \"trace_macro\");\n+        for (span, notes) in self.expansions.iter() {\n+            let mut db = self.sess.parse_sess.create_note(TraceMacro { span: *span });\n             for note in notes {\n                 db.note(note);\n             }"}, {"sha": "9b9697ab13d26a767e4cf5c922ed7caf3a0192f4", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -368,3 +368,10 @@ pub(crate) struct ModuleMultipleCandidates {\n     pub default_path: String,\n     pub secondary_path: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_trace_macro)]\n+pub struct TraceMacro {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "1199ff287c4302a09ee879e103084ad78e2fd200", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -49,9 +49,6 @@ rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n \n-[dev-dependencies]\n-rustc_target = { path = \"../rustc_target\" }\n-\n [features]\n llvm = ['rustc_codegen_llvm']\n rustc_use_parallel_compiler = ['rayon', 'rustc-rayon-core', 'rustc_query_impl/rustc_use_parallel_compiler', 'rustc_errors/rustc_use_parallel_compiler']"}, {"sha": "29543fe2f932c62564eba76826ccc779c68633eb", "filename": "compiler/rustc_interface/src/errors.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -1,5 +1,7 @@\n use rustc_macros::Diagnostic;\n+use rustc_session::config::CrateType;\n use rustc_span::{Span, Symbol};\n+use rustc_target::spec::TargetTriple;\n \n use std::io;\n use std::path::Path;\n@@ -91,3 +93,22 @@ pub struct FailedWritingFile<'a> {\n #[derive(Diagnostic)]\n #[diag(interface_proc_macro_crate_panic_abort)]\n pub struct ProcMacroCratePanicAbort;\n+\n+#[derive(Diagnostic)]\n+#[diag(interface_unsupported_crate_type_for_target)]\n+pub struct UnsupportedCrateTypeForTarget<'a> {\n+    pub crate_type: CrateType,\n+    pub target_triple: &'a TargetTriple,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(interface_multiple_output_types_adaption)]\n+pub struct MultipleOutputTypesAdaption;\n+\n+#[derive(Diagnostic)]\n+#[diag(interface_ignoring_extra_filename)]\n+pub struct IgnoringExtraFilename;\n+\n+#[derive(Diagnostic)]\n+#[diag(interface_ignoring_out_dir)]\n+pub struct IgnoringOutDir;"}, {"sha": "e4b4d5375e64a4d94c8e464108713e2590415e00", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use info;\n use libloading::Library;\n use rustc_ast as ast;\n@@ -472,16 +473,15 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<C\n     }\n \n     base.retain(|crate_type| {\n-        let res = !output::invalid_output_for_target(session, *crate_type);\n-\n-        if !res {\n-            session.warn(&format!(\n-                \"dropping unsupported crate type `{}` for target `{}`\",\n-                *crate_type, session.opts.target_triple\n-            ));\n+        if output::invalid_output_for_target(session, *crate_type) {\n+            session.emit_warning(errors::UnsupportedCrateTypeForTarget {\n+                crate_type: *crate_type,\n+                target_triple: &session.opts.target_triple,\n+            });\n+            false\n+        } else {\n+            true\n         }\n-\n-        res\n     });\n \n     base\n@@ -517,19 +517,16 @@ pub fn build_output_filenames(attrs: &[ast::Attribute], sess: &Session) -> Outpu\n             let unnamed_output_types =\n                 sess.opts.output_types.values().filter(|a| a.is_none()).count();\n             let ofile = if unnamed_output_types > 1 {\n-                sess.warn(\n-                    \"due to multiple output types requested, the explicitly specified \\\n-                     output file name will be adapted for each output type\",\n-                );\n+                sess.emit_warning(errors::MultipleOutputTypesAdaption);\n                 None\n             } else {\n                 if !sess.opts.cg.extra_filename.is_empty() {\n-                    sess.warn(\"ignoring -C extra-filename flag due to -o flag\");\n+                    sess.emit_warning(errors::IgnoringExtraFilename);\n                 }\n                 Some(out_file.clone())\n             };\n             if sess.io.output_dir != None {\n-                sess.warn(\"ignoring --out-dir flag due to -o flag\");\n+                sess.emit_warning(errors::IgnoringOutDir);\n             }\n \n             OutputFilenames::new("}, {"sha": "31a3ffbb1d8915e55283626392b5c17aa6377194", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -201,7 +201,9 @@ use rustc_target::abi::Size;\n use std::ops::Range;\n use std::path::PathBuf;\n \n-use crate::errors::{LargeAssignmentsLint, RecursionLimit, TypeLengthLimit};\n+use crate::errors::{\n+    EncounteredErrorWhileInstantiating, LargeAssignmentsLint, RecursionLimit, TypeLengthLimit,\n+};\n \n #[derive(PartialEq)]\n pub enum MonoItemCollectionMode {\n@@ -524,10 +526,10 @@ fn collect_items_rec<'tcx>(\n         && starting_point.node.is_user_defined()\n     {\n         let formatted_item = with_no_trimmed_paths!(starting_point.node.to_string());\n-        tcx.sess.span_note_without_error(\n-            starting_point.span,\n-            &format!(\"the above error was encountered while instantiating `{formatted_item}`\"),\n-        );\n+        tcx.sess.emit_note(EncounteredErrorWhileInstantiating {\n+            span: starting_point.span,\n+            formatted_item,\n+        });\n     }\n     inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors.items);\n "}, {"sha": "a53bd7e1fef5e9b76fbc7d664333c284f880b19b", "filename": "compiler/rustc_monomorphize/src/errors.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -83,3 +83,17 @@ pub struct SymbolAlreadyDefined {\n pub struct CouldntDumpMonoStats {\n     pub error: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(monomorphize_encountered_error_while_instantiating)]\n+pub struct EncounteredErrorWhileInstantiating {\n+    #[primary_span]\n+    pub span: Span,\n+    pub formatted_item: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(monomorphize_unknown_cgu_collection_mode)]\n+pub struct UnknownCguCollectionMode<'a> {\n+    pub mode: &'a str,\n+}"}, {"sha": "af3f60bb9326d6f0796e480a5b2c5f8f6d74efcc", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -114,7 +114,9 @@ use rustc_span::symbol::Symbol;\n \n use crate::collector::InliningMap;\n use crate::collector::{self, MonoItemCollectionMode};\n-use crate::errors::{CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownPartitionStrategy};\n+use crate::errors::{\n+    CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollectionMode, UnknownPartitionStrategy,\n+};\n \n pub struct PartitioningCx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -348,17 +350,13 @@ where\n fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[CodegenUnit<'_>]) {\n     let collection_mode = match tcx.sess.opts.unstable_opts.print_mono_items {\n         Some(ref s) => {\n-            let mode_string = s.to_lowercase();\n-            let mode_string = mode_string.trim();\n-            if mode_string == \"eager\" {\n+            let mode = s.to_lowercase();\n+            let mode = mode.trim();\n+            if mode == \"eager\" {\n                 MonoItemCollectionMode::Eager\n             } else {\n-                if mode_string != \"lazy\" {\n-                    let message = format!(\n-                        \"Unknown codegen-item collection mode '{mode_string}'. \\\n-                                           Falling back to 'lazy' mode.\"\n-                    );\n-                    tcx.sess.warn(&message);\n+                if mode != \"lazy\" {\n+                    tcx.sess.emit_warning(UnknownCguCollectionMode { mode });\n                 }\n \n                 MonoItemCollectionMode::Lazy"}, {"sha": "526b829bf676ae2e952cbcad78e3a21fe666817d", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_session::parse::feature_err;\n use rustc_span::{sym, Span, Symbol};\n \n-use crate::errors::ExprNotAllowedInContext;\n+use crate::errors::{ExprNotAllowedInContext, SkippingConstChecks};\n \n /// An expression that is not *always* legal in a const context.\n #[derive(Clone, Copy)]\n@@ -124,7 +124,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n             // corresponding feature gate. This encourages nightly users to use feature gates when\n             // possible.\n             None if tcx.sess.opts.unstable_opts.unleash_the_miri_inside_of_you => {\n-                tcx.sess.span_warn(span, \"skipping const checks\");\n+                tcx.sess.emit_warning(SkippingConstChecks { span });\n                 return;\n             }\n "}, {"sha": "97169a6367c3d97447f9b13e383b85b856c86ccb", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -1565,3 +1565,10 @@ pub(crate) struct ProcMacroUnsafe {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(passes_skipping_const_checks)]\n+pub struct SkippingConstChecks {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "8e8fba5e236f5970af069ac9193fbf0ce58db032", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -375,3 +375,9 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n         }\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(session_optimization_fuel_exhausted)]\n+pub struct OptimisationFuelExhausted {\n+    pub msg: String,\n+}"}, {"sha": "91d23f1041fe9e6581a796cbee7d723268feedb8", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2575b1abc97e1352b307163ac7de2142aded22a5/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=2575b1abc97e1352b307163ac7de2142aded22a5", "patch": "@@ -5,9 +5,10 @@ use crate::config::Input;\n use crate::config::{self, CrateType, InstrumentCoverage, OptLevel, OutputType, SwitchWithOptPath};\n use crate::errors::{\n     BranchProtectionRequiresAArch64, CannotEnableCrtStaticLinux, CannotMixAndMatchSanitizers,\n-    LinkerPluginToWindowsNotSupported, NotCircumventFeature, ProfileSampleUseFileDoesNotExist,\n-    ProfileUseFileDoesNotExist, SanitizerCfiEnabled, SanitizerNotSupported, SanitizersNotSupported,\n-    SkippingConstChecks, SplitDebugInfoUnstablePlatform, StackProtectorNotSupportedForTarget,\n+    LinkerPluginToWindowsNotSupported, NotCircumventFeature, OptimisationFuelExhausted,\n+    ProfileSampleUseFileDoesNotExist, ProfileUseFileDoesNotExist, SanitizerCfiEnabled,\n+    SanitizerNotSupported, SanitizersNotSupported, SkippingConstChecks,\n+    SplitDebugInfoUnstablePlatform, StackProtectorNotSupportedForTarget,\n     TargetRequiresUnwindTables, UnleashedFeatureHelp, UnstableVirtualFunctionElimination,\n     UnsupportedDwarfVersion,\n };\n@@ -483,6 +484,8 @@ impl Session {\n         self.diagnostic().span_err_with_code(sp, msg, code)\n     }\n     #[rustc_lint_diagnostics]\n+    #[allow(rustc::untranslatable_diagnostic)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn err(&self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.diagnostic().err(msg)\n     }\n@@ -583,12 +586,16 @@ impl Session {\n             ))\n         }\n     }\n+\n+    #[rustc_lint_diagnostics]\n     #[allow(rustc::untranslatable_diagnostic)]\n     #[allow(rustc::diagnostic_outside_of_impl)]\n     #[track_caller]\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().span_warn(sp, msg)\n     }\n+\n+    #[rustc_lint_diagnostics]\n     #[allow(rustc::untranslatable_diagnostic)]\n     #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn span_warn_with_code<S: Into<MultiSpan>>(\n@@ -599,6 +606,10 @@ impl Session {\n     ) {\n         self.diagnostic().span_warn_with_code(sp, msg, code)\n     }\n+\n+    #[rustc_lint_diagnostics]\n+    #[allow(rustc::untranslatable_diagnostic)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn warn(&self, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().warn(msg)\n     }\n@@ -641,18 +652,26 @@ impl Session {\n         self.diagnostic().delay_good_path_bug(msg)\n     }\n \n+    #[rustc_lint_diagnostics]\n+    #[allow(rustc::untranslatable_diagnostic)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn note_without_error(&self, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().note_without_error(msg)\n     }\n \n     #[track_caller]\n+    #[rustc_lint_diagnostics]\n+    #[allow(rustc::untranslatable_diagnostic)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn span_note_without_error<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n         msg: impl Into<DiagnosticMessage>,\n     ) {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n+\n+    #[rustc_lint_diagnostics]\n     #[allow(rustc::untranslatable_diagnostic)]\n     #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_note_without_error(\n@@ -882,7 +901,7 @@ impl Session {\n                         // We only call `msg` in case we can actually emit warnings.\n                         // Otherwise, this could cause a `delay_good_path_bug` to\n                         // trigger (issue #79546).\n-                        self.warn(&format!(\"optimization-fuel-exhausted: {}\", msg()));\n+                        self.emit_warning(OptimisationFuelExhausted { msg: msg() });\n                     }\n                     fuel.out_of_fuel = true;\n                 } else if fuel.remaining > 0 {"}]}