{"sha": "8af675a07576940ba24e3d91abd10b029b937946", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZjY3NWEwNzU3Njk0MGJhMjRlM2Q5MWFiZDEwYjAyOWI5Mzc5NDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-17T07:34:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-17T07:34:48Z"}, "message": "Auto merge of #58495 - kennytm:rollup, r=kennytm\n\nRollup of 19 pull requests\n\nSuccessful merges:\n\n - #57929 (Rustdoc remove old style files)\n - #57981 (Fix #57730)\n - #58074 (Stabilize slice_sort_by_cached_key)\n - #58196 (Add specific feature gate error for const-unstable features)\n - #58293 (Remove code for updating copyright years in generate-deriving-span-tests)\n - #58306 (Don't default on std crate when manipulating browser history)\n - #58359 (librustc_mir: use ? in impl_snapshot_for! macro)\n - #58395 (Instant::checked_duration_since)\n - #58429 (fix Box::into_unique effecitvely transmuting to a raw ptr)\n - #58433 (Update which libcore/liballoc tests Miri ignores, and document why)\n - #58438 (Use posix_spawn_file_actions_addchdir_np when possible)\n - #58440 (Whitelist the ARM v6 target-feature)\n - #58448 (rustdoc: mask `compiler_builtins` docs)\n - #58468 (split MaybeUninit into several features, expand docs a bit)\n - #58479 (compile-pass test for #53606)\n - #58489 (Fix runtime error in generate-keyword-tests)\n - #58496 (Fix documentation for std::path::PathBuf::pop)\n - #58509 (Notify myself when Clippy toolstate changes)\n - #58521 (Fix tracking issue for error iterators)", "tree": {"sha": "1636b5d5a844c946529f8688900f9f310c710096", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1636b5d5a844c946529f8688900f9f310c710096"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8af675a07576940ba24e3d91abd10b029b937946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8af675a07576940ba24e3d91abd10b029b937946", "html_url": "https://github.com/rust-lang/rust/commit/8af675a07576940ba24e3d91abd10b029b937946", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8af675a07576940ba24e3d91abd10b029b937946/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6982acd8673cbf511e64c6790964e94552400f40", "url": "https://api.github.com/repos/rust-lang/rust/commits/6982acd8673cbf511e64c6790964e94552400f40", "html_url": "https://github.com/rust-lang/rust/commit/6982acd8673cbf511e64c6790964e94552400f40"}, {"sha": "c65a82ab4ed6a4797c1d73b20a078f8d44b87e56", "url": "https://api.github.com/repos/rust-lang/rust/commits/c65a82ab4ed6a4797c1d73b20a078f8d44b87e56", "html_url": "https://github.com/rust-lang/rust/commit/c65a82ab4ed6a4797c1d73b20a078f8d44b87e56"}], "stats": {"total": 1119, "additions": 819, "deletions": 300}, "files": [{"sha": "aeb15821b0bb742c32e35d8cccb2e70fd048f675", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -16,6 +16,7 @@ fn main() {\n     let libdir = env::var_os(\"RUSTDOC_LIBDIR\").expect(\"RUSTDOC_LIBDIR was not set\");\n     let stage = env::var(\"RUSTC_STAGE\").expect(\"RUSTC_STAGE was not set\");\n     let sysroot = env::var_os(\"RUSTC_SYSROOT\").expect(\"RUSTC_SYSROOT was not set\");\n+    let mut has_unstable = false;\n \n     use std::str::FromStr;\n \n@@ -54,9 +55,22 @@ fn main() {\n     // it up so we can make rustdoc print this into the docs\n     if let Some(version) = env::var_os(\"RUSTDOC_CRATE_VERSION\") {\n         // This \"unstable-options\" can be removed when `--crate-version` is stabilized\n-        cmd.arg(\"-Z\")\n-           .arg(\"unstable-options\")\n-           .arg(\"--crate-version\").arg(version);\n+        if !has_unstable {\n+            cmd.arg(\"-Z\")\n+               .arg(\"unstable-options\");\n+        }\n+        cmd.arg(\"--crate-version\").arg(version);\n+        has_unstable = true;\n+    }\n+\n+    // Needed to be able to run all rustdoc tests.\n+    if let Some(_) = env::var_os(\"RUSTDOC_GENERATE_REDIRECT_PAGES\") {\n+        // This \"unstable-options\" can be removed when `--generate-redirect-pages` is stabilized\n+        if !has_unstable {\n+            cmd.arg(\"-Z\")\n+               .arg(\"unstable-options\");\n+        }\n+        cmd.arg(\"--generate-redirect-pages\");\n     }\n \n     if verbose > 1 {"}, {"sha": "660f9b9ef578adeecd41f28f0798aa03c1c771a2", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -517,6 +517,7 @@ impl Step for Std {\n             cargo.arg(\"--\")\n                  .arg(\"--markdown-css\").arg(\"rust.css\")\n                  .arg(\"--markdown-no-toc\")\n+                 .arg(\"--generate-redirect-pages\")\n                  .arg(\"--index-page\").arg(&builder.src.join(\"src/doc/index.md\"));\n \n             builder.run(&mut cargo);\n@@ -581,7 +582,9 @@ impl Step for Test {\n         let mut cargo = builder.cargo(compiler, Mode::Test, target, \"doc\");\n         compile::test_cargo(builder, &compiler, target, &mut cargo);\n \n-        cargo.arg(\"--no-deps\").arg(\"-p\").arg(\"test\");\n+        cargo.arg(\"--no-deps\")\n+             .arg(\"-p\").arg(\"test\")\n+             .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n \n         builder.run(&mut cargo);\n         builder.cp_r(&my_out, &out);\n@@ -650,9 +653,9 @@ impl Step for WhitelistedRustc {\n         // We don't want to build docs for internal compiler dependencies in this\n         // step (there is another step for that). Therefore, we whitelist the crates\n         // for which docs must be built.\n-        cargo.arg(\"--no-deps\");\n         for krate in &[\"proc_macro\"] {\n-            cargo.arg(\"-p\").arg(krate);\n+            cargo.arg(\"-p\").arg(krate)\n+                 .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n         }\n \n         builder.run(&mut cargo);"}, {"sha": "1c525101c76f66ac40d4e709eca2428c589449d3", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -8,14 +8,12 @@\n sample usage: src/etc/generate-deriving-span-tests.py\n \"\"\"\n \n-import os, datetime, stat, re\n+import os, stat\n \n TEST_DIR = os.path.abspath(\n     os.path.join(os.path.dirname(__file__), '../test/ui/derives/'))\n \n-YEAR = datetime.datetime.now().year\n-\n-TEMPLATE = \"\"\"\n+TEMPLATE = \"\"\"\\\n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n {error_deriving}\n@@ -63,19 +61,11 @@ def create_test_case(type, trait, super_traits, error_count):\n \n     errors = '\\n'.join('//~%s ERROR' % ('^' * n) for n in range(error_count))\n     code = string.format(traits = all_traits, errors = errors)\n-    return TEMPLATE.format(year = YEAR, error_deriving=error_deriving, code = code)\n+    return TEMPLATE.format(error_deriving=error_deriving, code = code)\n \n def write_file(name, string):\n     test_file = os.path.join(TEST_DIR, 'derives-span-%s.rs' % name)\n \n-    with open(test_file) as f:\n-        old_str = f.read()\n-        old_str_ignoring_date = re.sub(r'^// Copyright \\d+',\n-                                        '// Copyright {year}'.format(year = YEAR), old_str)\n-        if old_str_ignoring_date == string:\n-            # if all we're doing is updating the copyright year, ignore it\n-            return 0\n-\n     # set write permission if file exists, so it can be changed\n     if os.path.exists(test_file):\n         os.chmod(test_file, stat.S_IWUSR)\n@@ -86,8 +76,6 @@ def write_file(name, string):\n     # mark file read-only\n     os.chmod(test_file, stat.S_IRUSR|stat.S_IRGRP|stat.S_IROTH)\n \n-    return 1\n-\n \n ENUM = 1\n STRUCT = 2\n@@ -110,15 +98,11 @@ def write_file(name, string):\n                               ('Hash', [], 1)]:\n     traits[trait] = (ALL, supers, errs)\n \n-files = 0\n-\n for (trait, (types, super_traits, error_count)) in traits.items():\n     mk = lambda ty: create_test_case(ty, trait, super_traits, error_count)\n     if types & ENUM:\n-        files += write_file(trait + '-enum', mk(ENUM_TUPLE))\n-        files += write_file(trait + '-enum-struct-variant', mk(ENUM_STRUCT))\n+        write_file(trait + '-enum', mk(ENUM_TUPLE))\n+        write_file(trait + '-enum-struct-variant', mk(ENUM_STRUCT))\n     if types & STRUCT:\n-        files += write_file(trait + '-struct', mk(STRUCT_FIELDS))\n-        files += write_file(trait + '-tuple-struct', mk(STRUCT_TUPLE))\n-\n-print('Generated {files} deriving span test{}.'.format('s' if files != 1 else '', files = files))\n+        write_file(trait + '-struct', mk(STRUCT_FIELDS))\n+        write_file(trait + '-tuple-struct', mk(STRUCT_TUPLE))"}, {"sha": "bc046a8f42d0b6676ac64b8a29d3e71dc539132d", "filename": "src/etc/generate-keyword-tests.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fetc%2Fgenerate-keyword-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fetc%2Fgenerate-keyword-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-keyword-tests.py?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -15,7 +15,7 @@\n import stat\n \n \n-template = \"\"\"\n+template = \"\"\"\\\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py %s'\n \n fn main() {\n@@ -35,7 +35,7 @@\n         os.chmod(test_file, stat.S_IWUSR)\n \n     with open(test_file, 'wt') as f:\n-        f.write(template % (datetime.datetime.now().year, kw, kw, kw))\n+        f.write(template % (kw, kw, kw))\n \n     # mark file read-only\n     os.chmod(test_file, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)"}, {"sha": "a1884b7d548523a59423c7bbfffe285ffcf37529", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,5 +1,4 @@\n #![feature(repr_simd)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(test)]\n \n extern crate rand;"}, {"sha": "0cd2373c7f0215c19d9924522610eac7294f3d02", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -202,10 +202,15 @@ impl<T: ?Sized> Box<T> {\n     #[unstable(feature = \"ptr_internals\", issue = \"0\", reason = \"use into_raw_non_null instead\")]\n     #[inline]\n     #[doc(hidden)]\n-    pub fn into_unique(b: Box<T>) -> Unique<T> {\n-        let unique = b.0;\n+    pub fn into_unique(mut b: Box<T>) -> Unique<T> {\n+        // Box is kind-of a library type, but recognized as a \"unique pointer\" by\n+        // Stacked Borrows.  This function here corresponds to \"reborrowing to\n+        // a raw pointer\", but there is no actual reborrow here -- so\n+        // without some care, the pointer we are returning here still carries\n+        // the `Uniq` tag.  We round-trip through a mutable reference to avoid that.\n+        let unique = unsafe { b.0.as_mut() as *mut T };\n         mem::forget(b);\n-        unique\n+        unsafe { Unique::new_unchecked(unique) }\n     }\n \n     /// Consumes and leaks the `Box`, returning a mutable reference,"}, {"sha": "fc1c18789247104ad53c992d9fa3e216d6fe2ca1", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -453,7 +453,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData\n                 },\n-                idx: unsafe { usize::from(*self.as_header().parent_idx.get_ref()) },\n+                idx: unsafe { usize::from(*self.as_header().parent_idx.as_ptr()) },\n                 _marker: PhantomData\n             })\n         } else {\n@@ -1143,7 +1143,7 @@ impl<BorrowType, K, V>\n         NodeRef {\n             height: self.node.height - 1,\n             node: unsafe {\n-                self.node.as_internal().edges.get_unchecked(self.idx).get_ref().as_ptr()\n+                (&*self.node.as_internal().edges.get_unchecked(self.idx).as_ptr()).as_ptr()\n             },\n             root: self.node.root,\n             _marker: PhantomData"}, {"sha": "440ce8ac5e842d47ad5ee631f4ecdfa56bbb6c40", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -112,7 +112,7 @@\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit)]\n+#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n "}, {"sha": "f4b2d463778a99dede8d43748159c11d12df656a", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -257,6 +257,10 @@ impl<T> [T] {\n     /// This sort is stable (i.e., does not reorder equal elements) and `O(m n log(m n))`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n+    /// For expensive key functions (e.g. functions that are not simple property accesses or\n+    /// basic operations), [`sort_by_cached_key`](#method.sort_by_cached_key) is likely to be\n+    /// significantly faster, as it does not recompute element keys.\n+    ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n     /// See [`sort_unstable_by_key`](#method.sort_unstable_by_key).\n@@ -312,15 +316,14 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(slice_sort_by_cached_key)]\n     /// let mut v = [-5i32, 4, 32, -3, 2];\n     ///\n     /// v.sort_by_cached_key(|k| k.to_string());\n     /// assert!(v == [-3, -5, 2, 32, 4]);\n     /// ```\n     ///\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n-    #[unstable(feature = \"slice_sort_by_cached_key\", issue = \"34447\")]\n+    #[stable(feature = \"slice_sort_by_cached_key\", since = \"1.34.0\")]\n     #[inline]\n     pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n         where F: FnMut(&T) -> K, K: Ord"}, {"sha": "2759b1b1cac2769696f43075f2ab6e756318cab1", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,5 +1,3 @@\n-#![cfg(not(miri))]\n-\n use std::any::Any;\n use std::sync::{Arc, Weak};\n use std::cell::RefCell;"}, {"sha": "1d4a3edc1ac42c2d4e05f71df6bc43766ecd666f", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -282,7 +282,7 @@ fn assert_covariance() {\n //\n // Destructors must be called exactly once per element.\n #[test]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn panic_safe() {\n     static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n "}, {"sha": "f14750089c9560fdf2d6446f30ac355e67d12ef5", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -9,7 +9,10 @@ use super::DeterministicRng;\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n+    #[cfg(miri)]\n+    let size = 200;\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -69,7 +72,10 @@ fn test_basic_small() {\n \n #[test]\n fn test_iter() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n+    #[cfg(miri)]\n+    let size = 200;\n \n     // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n@@ -91,7 +97,10 @@ fn test_iter() {\n \n #[test]\n fn test_iter_rev() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n+    #[cfg(miri)]\n+    let size = 200;\n \n     // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n@@ -127,7 +136,10 @@ fn test_values_mut() {\n \n #[test]\n fn test_iter_mixed() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n+    #[cfg(miri)]\n+    let size = 200;\n \n     // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n@@ -214,42 +226,50 @@ fn test_range_equal_empty_cases() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_range_equal_excluded() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Excluded(2), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_1() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Included(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_2() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Included(3), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_3() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Excluded(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_4() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Excluded(3), Excluded(2)));\n }\n \n #[test]\n fn test_range_1000() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 1000;\n+    #[cfg(miri)]\n+    let size = 200;\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n@@ -286,7 +306,10 @@ fn test_range_borrowed_key() {\n \n #[test]\n fn test_range() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 200;\n+    #[cfg(miri)]\n+    let size = 30;\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     for i in 0..size {\n@@ -305,7 +328,10 @@ fn test_range() {\n \n #[test]\n fn test_range_mut() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 200;\n+    #[cfg(miri)]\n+    let size = 30;\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     for i in 0..size {\n@@ -479,7 +505,10 @@ fn test_bad_zst() {\n #[test]\n fn test_clone() {\n     let mut map = BTreeMap::new();\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 100;\n+    #[cfg(miri)]\n+    let size = 30;\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -631,6 +660,7 @@ create_append_test!(test_append_145, 145);\n create_append_test!(test_append_170, 170);\n create_append_test!(test_append_181, 181);\n create_append_test!(test_append_239, 239);\n+#[cfg(not(miri))] // Miri is too slow\n create_append_test!(test_append_1700, 1700);\n \n fn rand_data(len: usize) -> Vec<(u32, u32)> {"}, {"sha": "4c704d0f8c28fa7106bc3364133e9c44c57471b5", "filename": "src/liballoc/tests/btree/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,5 +1,3 @@\n-#![cfg(not(miri))]\n-\n mod map;\n mod set;\n "}, {"sha": "c225ebfa96b91d36f127a71656e61970d19d3088", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,5 +1,3 @@\n-#![cfg(not(miri))]\n-\n use std::alloc::{Global, Alloc, Layout, System};\n \n /// Issue #45955."}, {"sha": "2361a7db1f7a79e10066a096edf841b961f41278", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -4,7 +4,6 @@\n #![feature(exact_size_is_empty)]\n #![feature(pattern)]\n #![feature(repeat_generic_slice)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(vecdeque_rotate)]"}, {"sha": "18f82e804100823bec0e4e9c92dc55e7e444efd4", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,5 +1,3 @@\n-#![cfg(not(miri))]\n-\n use std::any::Any;\n use std::rc::{Rc, Weak};\n use std::cell::RefCell;"}, {"sha": "feba46b0fad78466af3496fb3ab98bfa9807d68f", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,5 +1,3 @@\n-#![cfg(not(miri))]\n-\n use std::cell::Cell;\n use std::cmp::Ordering::{self, Equal, Greater, Less};\n use std::mem;\n@@ -260,6 +258,7 @@ fn test_swap_remove() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_swap_remove_fail() {\n     let mut v = vec![1];\n     let _ = v.swap_remove(0);\n@@ -391,6 +390,7 @@ fn test_reverse() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri does not support entropy\n fn test_sort() {\n     let mut rng = thread_rng();\n \n@@ -467,6 +467,7 @@ fn test_sort() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri does not support entropy\n fn test_sort_stability() {\n     for len in (2..25).chain(500..510) {\n         for _ in 0..10 {\n@@ -631,6 +632,7 @@ fn test_insert() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_insert_oob() {\n     let mut a = vec![1, 2, 3];\n     a.insert(4, 5);\n@@ -655,6 +657,7 @@ fn test_remove() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_remove_fail() {\n     let mut a = vec![1];\n     let _ = a.remove(0);\n@@ -936,6 +939,7 @@ fn test_windowsator() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_windowsator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.windows(0);\n@@ -960,6 +964,7 @@ fn test_chunksator() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_chunksator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.chunks(0);\n@@ -984,6 +989,7 @@ fn test_chunks_exactator() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_chunks_exactator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.chunks_exact(0);\n@@ -1008,6 +1014,7 @@ fn test_rchunksator() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_rchunksator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.rchunks(0);\n@@ -1032,6 +1039,7 @@ fn test_rchunks_exactator() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_rchunks_exactator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.rchunks_exact(0);\n@@ -1084,6 +1092,7 @@ fn test_vec_default() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_overflow_does_not_cause_segfault() {\n     let mut v = vec![];\n     v.reserve_exact(!0);\n@@ -1093,6 +1102,7 @@ fn test_overflow_does_not_cause_segfault() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_overflow_does_not_cause_segfault_managed() {\n     let mut v = vec![Rc::new(1)];\n     v.reserve_exact(!0);\n@@ -1268,6 +1278,7 @@ fn test_mut_chunks_rev() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_chunks_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.chunks_mut(0);\n@@ -1300,6 +1311,7 @@ fn test_mut_chunks_exact_rev() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_chunks_exact_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.chunks_exact_mut(0);\n@@ -1332,6 +1344,7 @@ fn test_mut_rchunks_rev() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_rchunks_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.rchunks_mut(0);\n@@ -1364,6 +1377,7 @@ fn test_mut_rchunks_exact_rev() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_rchunks_exact_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.rchunks_exact_mut(0);\n@@ -1397,6 +1411,7 @@ fn test_box_slice_clone() {\n #[test]\n #[allow(unused_must_use)] // here, we care about the side effects of `.clone()`\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_box_slice_clone_panics() {\n     use std::sync::Arc;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n@@ -1461,6 +1476,7 @@ fn test_copy_from_slice() {\n \n #[test]\n #[should_panic(expected = \"destination and source slices have different lengths\")]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_from_slice_dst_longer() {\n     let src = [0, 1, 2, 3];\n     let mut dst = [0; 5];\n@@ -1469,6 +1485,7 @@ fn test_copy_from_slice_dst_longer() {\n \n #[test]\n #[should_panic(expected = \"destination and source slices have different lengths\")]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_from_slice_dst_shorter() {\n     let src = [0, 1, 2, 3];\n     let mut dst = [0; 3];\n@@ -1588,6 +1605,7 @@ thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n+#[cfg(not(miri))] // Miri does not support panics\n fn panic_safe() {\n     let prev = panic::take_hook();\n     panic::set_hook(Box::new(move |info| {"}, {"sha": "b33a56421888831bf0607d4832f77f92f84d5891", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -31,7 +31,6 @@ fn test_rfind() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn test_collect() {\n     let empty = \"\";\n     let s: String = empty.chars().collect();\n@@ -119,7 +118,6 @@ fn test_concat_for_different_types() {\n #[test]\n fn test_concat_for_different_lengths() {\n     let empty: &[&str] = &[];\n-    #[cfg(not(miri))]\n     test_concat!(\"\", empty);\n     test_concat!(\"a\", [\"a\"]);\n     test_concat!(\"ab\", [\"a\", \"b\"]);\n@@ -148,7 +146,6 @@ fn test_join_for_different_types() {\n #[test]\n fn test_join_for_different_lengths() {\n     let empty: &[&str] = &[];\n-    #[cfg(not(miri))]\n     test_join!(\"\", empty, \"-\");\n     test_join!(\"a\", [\"a\"], \"-\");\n     test_join!(\"a-b\", [\"a\", \"b\"], \"-\");\n@@ -162,15 +159,14 @@ fn test_join_for_different_lengths_with_long_separator() {\n     assert_eq!(\"\uff5e\uff5e\uff5e\uff5e\uff5e\".len(), 15);\n \n     let empty: &[&str] = &[];\n-    #[cfg(not(miri))]\n     test_join!(\"\", empty, \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n     test_join!(\"a\", [\"a\"], \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n     test_join!(\"a\uff5e\uff5e\uff5e\uff5e\uff5eb\", [\"a\", \"b\"], \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n     test_join!(\"\uff5e\uff5e\uff5e\uff5e\uff5ea\uff5e\uff5e\uff5e\uff5e\uff5ebc\", [\"\", \"a\", \"bc\"], \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n }\n \n #[test]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri is too slow\n fn test_unsafe_slice() {\n     assert_eq!(\"ab\", unsafe {\"abc\".get_unchecked(0..2)});\n     assert_eq!(\"bc\", unsafe {\"abc\".get_unchecked(1..3)});\n@@ -243,7 +239,6 @@ fn test_replacen() {\n #[test]\n fn test_replace() {\n     let a = \"a\";\n-    #[cfg(not(miri))]\n     assert_eq!(\"\".replace(a, \"b\"), \"\");\n     assert_eq!(\"a\".replace(a, \"b\"), \"b\");\n     assert_eq!(\"ab\".replace(a, \"b\"), \"bb\");\n@@ -303,7 +298,6 @@ fn test_replace_pattern() {\n // The current implementation of SliceIndex fails to handle methods\n // orthogonally from range types; therefore, it is worth testing\n // all of the indexing operations on each input.\n-#[cfg(not(miri))]\n mod slice_index {\n     // Test a slicing operation **that should succeed,**\n     // testing it on all of the indexing methods.\n@@ -357,6 +351,7 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"out of bounds\")]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_panic() {\n         assert_range_eq!(\"abc\", 0..5, \"abc\");\n     }\n@@ -366,6 +361,7 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"==\")]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_inequality() {\n         assert_range_eq!(\"abc\", 0..2, \"abc\");\n     }\n@@ -413,6 +409,7 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n+                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_fail() {\n                     let v: String = $data.into();\n                     let v: &str = &v;\n@@ -421,6 +418,7 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n+                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_mut_fail() {\n                     let mut v: String = $data.into();\n                     let v: &mut str = &mut v;\n@@ -490,6 +488,7 @@ mod slice_index {\n \n     #[test]\n     #[cfg(not(target_arch = \"asmjs\"))] // hits an OOM\n+    #[cfg(not(miri))] // Miri is too slow\n     fn simple_big() {\n         fn a_million_letter_x() -> String {\n             let mut i = 0;\n@@ -515,6 +514,7 @@ mod slice_index {\n \n     #[test]\n     #[should_panic]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn test_slice_fail() {\n         &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n     }\n@@ -666,12 +666,14 @@ mod slice_index {\n     // check the panic includes the prefix of the sliced string\n     #[test]\n     #[should_panic(expected=\"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn test_slice_fail_truncated_1() {\n         &LOREM_PARAGRAPH[..1024];\n     }\n     // check the truncation in the panic message\n     #[test]\n     #[should_panic(expected=\"luctus, im`[...]\")]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn test_slice_fail_truncated_2() {\n         &LOREM_PARAGRAPH[..1024];\n     }\n@@ -686,7 +688,7 @@ fn test_str_slice_rangetoinclusive_ok() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_str_slice_rangetoinclusive_notok() {\n     let s = \"abc\u03b1\u03b2\u03b3\";\n     &s[..=3];\n@@ -702,7 +704,7 @@ fn test_str_slicemut_rangetoinclusive_ok() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_str_slicemut_rangetoinclusive_notok() {\n     let mut s = \"abc\u03b1\u03b2\u03b3\".to_owned();\n     let s: &mut str = &mut s;\n@@ -892,7 +894,7 @@ fn test_as_bytes() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_as_bytes_fail() {\n     // Don't double free. (I'm not sure if this exercises the\n     // original problem code path anymore.)\n@@ -982,7 +984,7 @@ fn test_split_at_mut() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_split_at_boundscheck() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     s.split_at(1);\n@@ -1078,7 +1080,7 @@ fn test_rev_iterator() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri is too slow\n fn test_chars_decoding() {\n     let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(std::char::from_u32) {\n@@ -1090,7 +1092,7 @@ fn test_chars_decoding() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri is too slow\n fn test_chars_rev_decoding() {\n     let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(std::char::from_u32) {\n@@ -1320,7 +1322,6 @@ fn test_splitator() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn test_str_default() {\n     use std::default::Default;\n \n@@ -1380,7 +1381,7 @@ fn test_bool_from_str() {\n     assert_eq!(\"not even a boolean\".parse::<bool>().ok(), None);\n }\n \n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri is too slow\n fn check_contains_all_substrings(s: &str) {\n     assert!(s.contains(\"\"));\n     for i in 0..s.len() {\n@@ -1391,7 +1392,7 @@ fn check_contains_all_substrings(s: &str) {\n }\n \n #[test]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri is too slow\n fn strslice_issue_16589() {\n     assert!(\"bananas\".contains(\"nana\"));\n \n@@ -1401,15 +1402,14 @@ fn strslice_issue_16589() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn strslice_issue_16878() {\n     assert!(!\"1234567ah012345678901ah\".contains(\"hah\"));\n     assert!(!\"00abc01234567890123456789abc\".contains(\"bcabc\"));\n }\n \n \n #[test]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri is too slow\n fn test_strslice_contains() {\n     let x = \"There are moments, Jeeves, when one asks oneself, 'Do trousers matter?'\";\n     check_contains_all_substrings(x);\n@@ -1547,7 +1547,6 @@ fn trim_ws() {\n \n #[test]\n fn to_lowercase() {\n-    #[cfg(not(miri))]\n     assert_eq!(\"\".to_lowercase(), \"\");\n     assert_eq!(\"A\u00c9\u01c5a\u00e9 \".to_lowercase(), \"a\u00e9\u01c6a\u00e9 \");\n \n@@ -1581,7 +1580,6 @@ fn to_lowercase() {\n \n #[test]\n fn to_uppercase() {\n-    #[cfg(not(miri))]\n     assert_eq!(\"\".to_uppercase(), \"\");\n     assert_eq!(\"a\u00e9\u01c5\u00df\ufb01\u1f80\".to_uppercase(), \"A\u00c9\u01c4SSFI\u1f08\u0399\");\n }\n@@ -1613,7 +1611,6 @@ fn test_cow_from() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn test_repeat() {\n     assert_eq!(\"\".repeat(3), \"\");\n     assert_eq!(\"abc\".repeat(0), \"\");"}, {"sha": "7e93d84fe3b97b1578dad9e6ebd9eb2324ab83c4", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,5 +1,3 @@\n-#![cfg(not(miri))]\n-\n use std::borrow::Cow;\n use std::collections::CollectionAllocErr::*;\n use std::mem::size_of;\n@@ -233,6 +231,7 @@ fn test_split_off_empty() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_split_off_past_end() {\n     let orig = \"Hello, world!\";\n     let mut split = String::from(orig);\n@@ -241,6 +240,7 @@ fn test_split_off_past_end() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_split_off_mid_char() {\n     let mut orig = String::from(\"\u5c71\");\n     orig.split_off(1);\n@@ -289,6 +289,7 @@ fn test_str_truncate_invalid_len() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_str_truncate_split_codepoint() {\n     let mut s = String::from(\"\\u{FC}\"); // \u00fc\n     s.truncate(1);\n@@ -323,6 +324,7 @@ fn remove() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn remove_bad() {\n     \"\u0e28\".to_string().remove(1);\n }\n@@ -358,11 +360,13 @@ fn insert() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn insert_bad1() {\n     \"\".to_string().insert(1, 't');\n }\n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn insert_bad2() {\n     \"\u1ec7\".to_string().insert(1, 't');\n }\n@@ -443,6 +447,7 @@ fn test_replace_range() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_replace_range_char_boundary() {\n     let mut s = \"Hello, \u4e16\u754c!\".to_owned();\n     s.replace_range(..8, \"\");\n@@ -459,13 +464,15 @@ fn test_replace_range_inclusive_range() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_replace_range_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n     s.replace_range(5..6, \"789\");\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_replace_range_inclusive_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n     s.replace_range(5..=5, \"789\");\n@@ -525,6 +532,7 @@ fn test_reserve_exact() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve() {\n \n     // These are the interesting cases:\n@@ -602,6 +610,7 @@ fn test_try_reserve() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n \n     // This is exactly the same as test_try_reserve with the method changed."}, {"sha": "6e4ca1d90e642dd31bf20bfd5e3efc00c56e0256", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -368,6 +368,7 @@ fn test_vec_truncate_drop() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_vec_truncate_fail() {\n     struct BadElem(i32);\n     impl Drop for BadElem {\n@@ -391,48 +392,55 @@ fn test_index() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_index_out_of_bounds() {\n     let vec = vec![1, 2, 3];\n     let _ = vec[3];\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_1() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[!0..];\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_2() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[..6];\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_3() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[!0..4];\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_4() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[1..6];\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_5() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[3..2];\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_swap_remove_empty() {\n     let mut vec = Vec::<i32>::new();\n     vec.swap_remove(0);\n@@ -503,6 +511,7 @@ fn test_drain_items_zero_sized() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_drain_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     v.drain(5..6);\n@@ -576,6 +585,7 @@ fn test_drain_max_vec_size() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_drain_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     v.drain(5..=5);\n@@ -605,6 +615,7 @@ fn test_splice_inclusive_range() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_splice_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n@@ -613,6 +624,7 @@ fn test_splice_out_of_bounds() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_splice_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];"}, {"sha": "e0cb0e7a9e70c532ccd3f915b5afffa2d1d45514", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -108,7 +108,7 @@ fn test_index() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_index_out_of_bounds() {\n     let mut deq = VecDeque::new();\n     for i in 1..4 {\n@@ -907,24 +907,20 @@ fn test_append() {\n     // normal append\n     a.append(&mut b);\n     assert_eq!(a.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n-    #[cfg(not(miri))]\n     assert_eq!(b.iter().cloned().collect::<Vec<_>>(), []);\n \n     // append nothing to something\n     a.append(&mut b);\n     assert_eq!(a.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n-    #[cfg(not(miri))]\n     assert_eq!(b.iter().cloned().collect::<Vec<_>>(), []);\n \n     // append something to nothing\n     b.append(&mut a);\n     assert_eq!(b.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n-    #[cfg(not(miri))]\n     assert_eq!(a.iter().cloned().collect::<Vec<_>>(), []);\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn test_append_permutations() {\n     fn construct_vec_deque(\n         push_back: usize,\n@@ -948,7 +944,10 @@ fn test_append_permutations() {\n         out\n     }\n \n+    #[cfg(not(miri))] // Miri is too slow\n     const MAX: usize = 5;\n+    #[cfg(miri)]\n+    const MAX: usize = 3;\n \n     // Many different permutations of both the `VecDeque` getting appended to\n     // and the one getting appended are generated to check `append`.\n@@ -1125,7 +1124,7 @@ fn test_reserve_exact_2() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve() {\n \n     // These are the interesting cases:\n@@ -1227,7 +1226,7 @@ fn test_try_reserve() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n \n     // This is exactly the same as test_try_reserve with the method changed."}, {"sha": "d046236b5353a0ea5357c81f0ff261bd65bde4bf", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -122,7 +122,7 @@\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n-#![feature(maybe_uninit)]\n+#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n #![feature(unrestricted_attribute_tokens)]\n \n #[prelude_import]"}, {"sha": "fdbfa56000b8ebbc32c5fafea80c1e78cee8f152", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -563,11 +563,11 @@ macro_rules! unimplemented {\n \n /// A macro to create an array of [`MaybeUninit`]\n ///\n-/// This macro constructs and uninitialized array of the type `[MaybeUninit<K>; N]`.\n+/// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`.\n ///\n /// [`MaybeUninit`]: mem/union.MaybeUninit.html\n #[macro_export]\n-#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+#[unstable(feature = \"maybe_uninit_array\", issue = \"53491\")]\n macro_rules! uninitialized_array {\n     // This `into_initialized` is safe because an array of `MaybeUninit` does not\n     // require initialization."}, {"sha": "e0b0e72ff9b5f0e1aeea46d4aa48946617521baa", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1045,17 +1045,34 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// ever gets used to access memory:\n ///\n /// ```rust,no_run\n-/// use std::mem;\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::{self, MaybeUninit};\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n+/// // equivalent code with `MaybeUninit`\n+/// let x: &i32 = unsafe { MaybeUninit::zeroed().into_initialized() }; // undefined behavior!\n /// ```\n ///\n /// This is exploited by the compiler for various optimizations, such as eliding\n /// run-time checks and optimizing `enum` layout.\n ///\n-/// Not initializing memory at all (instead of zero--initializing it) causes the same\n+/// Not initializing memory at all (instead of zero-initializing it) causes the same\n /// issue: after all, the initial value of the variable might just happen to be\n-/// one that violates the invariant.\n+/// one that violates the invariant. Moreover, uninitialized memory is special\n+/// in that the compiler knows that it does not have a fixed value. This makes\n+/// it undefined behavior to have uninitialized data in a variable even if that\n+/// variable has otherwise no restrictions about which values are valid:\n+///\n+/// ```rust,no_run\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // equivalent code with `MaybeUninit`\n+/// let x: i32 = unsafe { MaybeUninit::uninitialized().into_initialized() }; // undefined behavior!\n+/// ```\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n ///\n /// `MaybeUninit` serves to enable unsafe code to deal with uninitialized data:\n /// it is a signal to the compiler indicating that the data here might *not*\n@@ -1065,7 +1082,8 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// #![feature(maybe_uninit)]\n /// use std::mem::MaybeUninit;\n ///\n-/// // Create an explicitly uninitialized reference.\n+/// // Create an explicitly uninitialized reference. The compiler knows that data inside\n+/// // a `MaybeUninit` may be invalid, and hence this is not UB:\n /// let mut x = MaybeUninit::<&i32>::uninitialized();\n /// // Set it to a valid value.\n /// x.set(&0);\n@@ -1075,6 +1093,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// ```\n ///\n /// The compiler then knows to not optimize this code.\n+// FIXME before stabilizing, explain how to initialize a struct field-by-field.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n // NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::{uninitialized,zeroed}`\n@@ -1134,14 +1153,31 @@ impl<T> MaybeUninit<T> {\n         }\n     }\n \n+    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn as_ptr(&self) -> *const T {\n+        unsafe { &*self.value as *const T }\n+    }\n+\n+    /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        unsafe { &mut *self.value as *mut T }\n+    }\n+\n     /// Extracts the value from the `MaybeUninit` container. This is a great way\n     /// to ensure that the data will get dropped, because the resulting `T` is\n     /// subject to the usual drop handling.\n     ///\n     /// # Unsafety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n-    /// state, otherwise this will immediately cause undefined behavior.\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn into_initialized(self) -> T {\n@@ -1162,8 +1198,9 @@ impl<T> MaybeUninit<T> {\n     /// # Unsafety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n-    /// state, otherwise this will immediately cause undefined behavior.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n         &*self.value\n@@ -1174,41 +1211,26 @@ impl<T> MaybeUninit<T> {\n     /// # Unsafety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n-    /// state, otherwise this will immediately cause undefined behavior.\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n     // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n         &mut *self.value\n     }\n \n-    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn as_ptr(&self) -> *const T {\n-        unsafe { &*self.value as *const T }\n-    }\n-\n-    /// Get sa mutable pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        unsafe { &mut *self.value as *mut T }\n-    }\n-\n     /// Gets a pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n         this as *const [MaybeUninit<T>] as *const T\n     }\n \n     /// Gets a mutable pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n         this as *mut [MaybeUninit<T>] as *mut T"}, {"sha": "a628fd0cfa4b2a1831e261776cc073b36a8692c5", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1563,6 +1563,10 @@ impl<T> [T] {\n     /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n     /// deterministic behavior.\n     ///\n+    /// Due to its key calling strategy, [`sort_unstable_by_key`](#method.sort_unstable_by_key)\n+    /// is likely to be slower than [`sort_by_cached_key`](#method.sort_by_cached_key) in\n+    /// cases where the key function is expensive.\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "b16416022c04e700197081fcdaa016d4fb565655", "filename": "src/libcore/tests/cell.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcell.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,5 +1,3 @@\n-#![cfg(not(miri))]\n-\n use core::cell::*;\n use core::default::Default;\n use std::mem::drop;\n@@ -111,6 +109,7 @@ fn double_borrow_single_release_no_borrow_mut() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn discard_doesnt_unborrow() {\n     let x = RefCell::new(0);\n     let _b = x.borrow();\n@@ -351,6 +350,7 @@ fn refcell_ref_coercion() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn refcell_swap_borrows() {\n     let x = RefCell::new(0);\n     let _b = x.borrow();\n@@ -360,6 +360,7 @@ fn refcell_swap_borrows() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn refcell_replace_borrows() {\n     let x = RefCell::new(0);\n     let _b = x.borrow();"}, {"sha": "df1deeaeb97b789c84387f2f69a9d26e06183d31", "filename": "src/libcore/tests/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,10 +1,9 @@\n-#![cfg(not(miri))]\n-\n mod builders;\n mod float;\n mod num;\n \n #[test]\n+#[cfg(not(miri))] // Miri cannot print pointers\n fn test_format_flags() {\n     // No residual flags left by pointer formatting\n     let p = \"\".as_ptr();\n@@ -14,6 +13,7 @@ fn test_format_flags() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri cannot print pointers\n fn test_pointer_formats_data_pointer() {\n     let b: &[u8] = b\"\";\n     let s: &str = \"\";"}, {"sha": "1000088e6b0633c5489e9eeee91c4e2af1c1a289", "filename": "src/libcore/tests/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,5 +1,3 @@\n-#![cfg(not(miri))]\n-\n mod sip;\n \n use std::hash::{Hash, Hasher};\n@@ -75,9 +73,11 @@ fn test_writer_hasher() {\n     let cs: &mut [u8] = &mut [1, 2, 3];\n     let ptr = cs.as_ptr();\n     let slice_ptr = cs as *const [u8];\n+    #[cfg(not(miri))] // Miri cannot hash pointers\n     assert_eq!(hash(&slice_ptr), hash(&ptr) + cs.len() as u64);\n \n     let slice_ptr = cs as *mut [u8];\n+    #[cfg(not(miri))] // Miri cannot hash pointers\n     assert_eq!(hash(&slice_ptr), hash(&ptr) + cs.len() as u64);\n }\n "}, {"sha": "9b76a4af98824a46052bd62c1cf9f552b4e98b90", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -190,7 +190,6 @@ fn test_iterator_step_by() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn test_iterator_step_by_nth() {\n     let mut it = (0..16).step_by(5);\n     assert_eq!(it.nth(0), Some(0));\n@@ -209,7 +208,6 @@ fn test_iterator_step_by_nth() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn test_iterator_step_by_nth_overflow() {\n     #[cfg(target_pointer_width = \"8\")]\n     type Bigger = u16;\n@@ -255,14 +253,13 @@ fn test_iterator_step_by_nth_overflow() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_iterator_step_by_zero() {\n     let mut it = (0..).step_by(0);\n     it.next();\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn test_iterator_step_by_size_hint() {\n     struct StubSizeHint(usize, Option<usize>);\n     impl Iterator for StubSizeHint {\n@@ -1417,7 +1414,7 @@ fn test_rposition() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_rposition_panic() {\n     let v: [(Box<_>, Box<_>); 4] =\n         [(box 0, box 0), (box 0, box 0),\n@@ -1657,7 +1654,6 @@ fn test_range_inclusive_nth() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn test_range_step() {\n     #![allow(deprecated)]\n \n@@ -1681,15 +1677,13 @@ fn test_range_step() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn test_step_by_skip() {\n     assert_eq!((0..640).step_by(128).skip(1).collect::<Vec<_>>(), [128, 256, 384, 512]);\n     assert_eq!((0..=50).step_by(10).nth(3), Some(30));\n     assert_eq!((200..=255u8).step_by(10).nth(3), Some(230));\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn test_range_inclusive_step() {\n     assert_eq!((0..=50).step_by(10).collect::<Vec<_>>(), [0, 10, 20, 30, 40, 50]);\n     assert_eq!((0..=5).step_by(1).collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5]);"}, {"sha": "956c22c998219ead7c9b65b0eb793c6f2d1b5137", "filename": "src/libcore/tests/num/bignum.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -3,6 +3,7 @@ use core::num::bignum::tests::Big8x3 as Big;\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_from_u64_overflow() {\n     Big::from_u64(0x1000000);\n }\n@@ -19,12 +20,14 @@ fn test_add() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_add_overflow_1() {\n     Big::from_small(1).add(&Big::from_u64(0xffffff));\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_add_overflow_2() {\n     Big::from_u64(0xffffff).add(&Big::from_small(1));\n }\n@@ -42,6 +45,7 @@ fn test_add_small() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_add_small_overflow() {\n     Big::from_u64(0xffffff).add_small(1);\n }\n@@ -57,12 +61,14 @@ fn test_sub() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_sub_underflow_1() {\n     Big::from_u64(0x10665).sub(&Big::from_u64(0x10666));\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_sub_underflow_2() {\n     Big::from_small(0).sub(&Big::from_u64(0x123456));\n }\n@@ -76,6 +82,7 @@ fn test_mul_small() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_small_overflow() {\n     Big::from_u64(0x800000).mul_small(2);\n }\n@@ -94,12 +101,14 @@ fn test_mul_pow2() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow2_overflow_1() {\n     Big::from_u64(0x1).mul_pow2(24);\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow2_overflow_2() {\n     Big::from_u64(0x123).mul_pow2(16);\n }\n@@ -118,12 +127,14 @@ fn test_mul_pow5() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow5_overflow_1() {\n     Big::from_small(1).mul_pow5(12);\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow5_overflow_2() {\n     Big::from_small(230).mul_pow5(8);\n }\n@@ -141,12 +152,14 @@ fn test_mul_digits() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_digits_overflow_1() {\n     Big::from_u64(0x800000).mul_digits(&[2]);\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_digits_overflow_2() {\n     Big::from_u64(0x1000).mul_digits(&[0, 0x10]);\n }\n@@ -206,6 +219,7 @@ fn test_get_bit() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_get_bit_out_of_range() {\n     Big::from_small(42).get_bit(24);\n }"}, {"sha": "faeaabbf95adacb75d7edd518f11ffdba021a087", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -52,6 +52,7 @@ fn large() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn subnormals() {\n     test_literal!(5e-324);\n     test_literal!(91e-324);\n@@ -63,6 +64,7 @@ fn subnormals() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn infinity() {\n     test_literal!(1e400);\n     test_literal!(1e309);"}, {"sha": "d362c7994d8066e0dd707a027c866ac1bed1f9ee", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))] // Miri does not implement ldexp, which most tests here need\n+\n use std::prelude::v1::*;\n use std::{str, i16, f32, f64, fmt};\n "}, {"sha": "a17c094679ea854623356691df94479bdb17670e", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,5 +1,3 @@\n-#![cfg(not(miri))]\n-\n use core::convert::{TryFrom, TryInto};\n use core::cmp::PartialEq;\n use core::fmt::Debug;"}, {"sha": "87ce2720c5918209a4a6f85b375f63d9fc6e5967", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -69,7 +69,7 @@ fn test_option_dance() {\n }\n \n #[test] #[should_panic]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_option_too_much_dance() {\n     struct A;\n     let mut y = Some(A);\n@@ -130,15 +130,15 @@ fn test_unwrap() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_unwrap_panic1() {\n     let x: Option<isize> = None;\n     x.unwrap();\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_unwrap_panic2() {\n     let x: Option<String> = None;\n     x.unwrap();"}, {"sha": "2c53e4832a8cc20086f33b023f3264e40d99c172", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,5 +1,3 @@\n-#![cfg(not(miri))]\n-\n use core::ptr::*;\n use core::cell::RefCell;\n \n@@ -42,6 +40,7 @@ fn test() {\n }\n \n #[test]\n+#[cfg(not(miri))] // This test performs invalid OOB pointer arithmetic\n fn test_is_null() {\n     let p: *const isize = null();\n     assert!(p.is_null());\n@@ -147,6 +146,7 @@ fn test_as_ref() {\n }\n \n #[test]\n+#[cfg(not(miri))] // This test is UB according to Stacked Borrows\n fn test_as_mut() {\n     unsafe {\n         let p: *mut isize = null_mut();\n@@ -208,6 +208,7 @@ fn test_ptr_addition() {\n }\n \n #[test]\n+#[cfg(not(miri))] // This test performs invalid OOB pointer arithmetic\n fn test_ptr_subtraction() {\n     unsafe {\n         let xs = vec![0,1,2,3,4,5,6,7,8,9];\n@@ -251,6 +252,7 @@ fn test_unsized_nonnull() {\n \n #[test]\n #[allow(warnings)]\n+#[cfg(not(miri))] // Miri cannot hash pointers\n // Have a symbol for the test below. It doesn\u2019t need to be an actual variadic function, match the\n // ABI, or even point to an actual executable code, because the function itself is never invoked.\n #[no_mangle]\n@@ -290,6 +292,7 @@ fn write_unaligned_drop() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri cannot compute actual alignment of an allocation\n fn align_offset_zst() {\n     // For pointers of stride = 0, the pointer is already aligned or it cannot be aligned at\n     // all, because no amount of elements will align the pointer.\n@@ -304,6 +307,7 @@ fn align_offset_zst() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri cannot compute actual alignment of an allocation\n fn align_offset_stride1() {\n     // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n     // number of bytes.\n@@ -320,6 +324,7 @@ fn align_offset_stride1() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn align_offset_weird_strides() {\n     #[repr(packed)]\n     struct A3(u16, u8);"}, {"sha": "bbc85685176671ad20051ddc28fa2a50014b4718", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -117,7 +117,7 @@ fn test_unwrap_or_else() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n pub fn test_unwrap_or_else_panic() {\n     fn handler(msg: &'static str) -> isize {\n         if msg == \"I got this.\" {\n@@ -139,7 +139,7 @@ pub fn test_expect_ok() {\n }\n #[test]\n #[should_panic(expected=\"Got expected error: \\\"All good\\\"\")]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n pub fn test_expect_err() {\n     let err: Result<isize, &'static str> = Err(\"All good\");\n     err.expect(\"Got expected error\");\n@@ -153,7 +153,7 @@ pub fn test_expect_err_err() {\n }\n #[test]\n #[should_panic(expected=\"Got expected ok: \\\"All good\\\"\")]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n pub fn test_expect_err_ok() {\n     let err: Result<&'static str, isize> = Ok(\"All good\");\n     err.expect_err(\"Got expected ok\");"}, {"sha": "31d16e0e320571c28897f4b30feb266e3bc86ba0", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -782,7 +782,7 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"out of range\")]\n-    #[cfg(not(miri))]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_panic() {\n         assert_range_eq!([0, 1, 2], 0..5, [0, 1, 2]);\n     }\n@@ -792,7 +792,7 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"==\")]\n-    #[cfg(not(miri))]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_inequality() {\n         assert_range_eq!([0, 1, 2], 0..2, [0, 1, 2]);\n     }\n@@ -842,7 +842,7 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n-                #[cfg(not(miri))]\n+                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_fail() {\n                     let v = $data;\n                     let v: &[_] = &v;\n@@ -851,7 +851,7 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n-                #[cfg(not(miri))]\n+                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_mut_fail() {\n                     let mut v = $data;\n                     let v: &mut [_] = &mut v;\n@@ -1015,7 +1015,7 @@ fn test_rotate_right() {\n \n #[test]\n #[cfg(not(target_arch = \"wasm32\"))]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support entropy\n fn sort_unstable() {\n     use core::cmp::Ordering::{Equal, Greater, Less};\n     use core::slice::heapsort;\n@@ -1171,7 +1171,7 @@ pub mod memchr {\n }\n \n #[test]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri cannot compute actual alignment of an allocation\n fn test_align_to_simple() {\n     let bytes = [1u8, 2, 3, 4, 5, 6, 7];\n     let (prefix, aligned, suffix) = unsafe { bytes.align_to::<u16>() };\n@@ -1187,7 +1187,6 @@ fn test_align_to_simple() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn test_align_to_zst() {\n     let bytes = [1, 2, 3, 4, 5, 6, 7];\n     let (prefix, aligned, suffix) = unsafe { bytes.align_to::<()>() };\n@@ -1196,7 +1195,7 @@ fn test_align_to_zst() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri cannot compute actual alignment of an allocation\n fn test_align_to_non_trivial() {\n     #[repr(align(8))] struct U64(u64, u64);\n     #[repr(align(8))] struct U64U64U32(u64, u64, u32);\n@@ -1208,7 +1207,6 @@ fn test_align_to_non_trivial() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n fn test_align_to_empty_mid() {\n     use core::mem;\n \n@@ -1306,7 +1304,7 @@ fn test_copy_within() {\n \n #[test]\n #[should_panic(expected = \"src is out of bounds\")]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_within_panics_src_too_long() {\n     let mut bytes = *b\"Hello, World!\";\n     // The length is only 13, so 14 is out of bounds.\n@@ -1315,15 +1313,15 @@ fn test_copy_within_panics_src_too_long() {\n \n #[test]\n #[should_panic(expected = \"dest is out of bounds\")]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_within_panics_dest_too_long() {\n     let mut bytes = *b\"Hello, World!\";\n     // The length is only 13, so a slice of length 4 starting at index 10 is out of bounds.\n     bytes.copy_within(0..4, 10);\n }\n #[test]\n #[should_panic(expected = \"src end is before src start\")]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_within_panics_src_inverted() {\n     let mut bytes = *b\"Hello, World!\";\n     // 2 is greater than 1, so this range is invalid."}, {"sha": "09aae4583482f83e41bd6574e453fedaf0500c60", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,5 +1,3 @@\n-#![cfg(not(miri))]\n-\n use core::time::Duration;\n \n #[test]\n@@ -109,12 +107,14 @@ fn checked_sub() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn sub_bad1() {\n     let _ = Duration::new(0, 0) - Duration::new(0, 1);\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn sub_bad2() {\n     let _ = Duration::new(0, 0) - Duration::new(1, 0);\n }"}, {"sha": "3d79b6777fa8b3c0bdd70cfe427419992e5070b0", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -47,7 +47,6 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_attrs)]\n #![feature(slice_patterns)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n #![feature(thread_local)]"}, {"sha": "e344f8732f820b2c1beb6c7fdce1efd2542b99da", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -17,7 +17,6 @@\n #![feature(nll)]\n #![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(optin_builtin_traits)]\n #![feature(concat_idents)]\n #![feature(link_args)]"}, {"sha": "ecca45a4d4281889d3f75d78351de265f49eda73", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -100,9 +100,11 @@ const ARM_WHITELIST: &[(&str, Option<&str>)] = &[\n     (\"dsp\", Some(\"arm_target_feature\")),\n     (\"neon\", Some(\"arm_target_feature\")),\n     (\"v5te\", Some(\"arm_target_feature\")),\n+    (\"v6\", Some(\"arm_target_feature\")),\n     (\"v6k\", Some(\"arm_target_feature\")),\n     (\"v6t2\", Some(\"arm_target_feature\")),\n     (\"v7\", Some(\"arm_target_feature\")),\n+    (\"v8\", Some(\"arm_target_feature\")),\n     (\"vfp2\", Some(\"arm_target_feature\")),\n     (\"vfp3\", Some(\"arm_target_feature\")),\n     (\"vfp4\", Some(\"arm_target_feature\")),"}, {"sha": "9e1744451465d310872a4b50030e31c6b3063c71", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -6,7 +6,6 @@\n #![feature(libc)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(in_band_lifetimes)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(nll)]\n #![allow(unused_attributes)]\n #![allow(dead_code)]"}, {"sha": "e022d3a3818a5caae987c3a606bc20c672cfd349", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -10,7 +10,6 @@\n #![cfg_attr(unix, feature(libc))]\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(set_stdio)]\n #![feature(no_debug)]\n #![feature(integer_atomics)]"}, {"sha": "b4f68399d9febc59aaca4163b6dd1b186e515234", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -6,7 +6,6 @@\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(crate_visibility_modifier)]\n #![feature(specialization)]\n #![feature(rustc_private)]"}, {"sha": "4df3004a9ada6296f79aadb40c3c5f53cd5ade55", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -2370,6 +2370,37 @@ let value = (&foo(), &foo());\n ```\n \"##,\n \n+E0723: r##\"\n+An feature unstable in `const` contexts was used.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0723\n+trait T {}\n+\n+impl T for () {}\n+\n+const fn foo() -> impl T { // error: `impl Trait` in const fn is unstable\n+    ()\n+}\n+```\n+\n+To enable this feature on a nightly version of rustc, add the `const_fn`\n+feature flag:\n+\n+```\n+#![feature(const_fn)]\n+\n+trait T {}\n+\n+impl T for () {}\n+\n+const fn foo() -> impl T {\n+    ()\n+}\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "0168e1301fa7af6db7fadec8de40621db0a7eb2c", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -101,9 +101,8 @@ macro_rules! __impl_snapshot_field {\n // This assumes the type has two type parameters, first for the tag (set to `()`),\n // then for the id\n macro_rules! impl_snapshot_for {\n-    // FIXME(mark-i-m): Some of these should be `?` rather than `*`.\n     (enum $enum_name:ident {\n-        $( $variant:ident $( ( $($field:ident $(-> $delegate:expr)*),* ) )* ),* $(,)*\n+        $( $variant:ident $( ( $($field:ident $(-> $delegate:expr)?),* ) )? ),* $(,)?\n     }) => {\n \n         impl<'a, Ctx> self::Snapshot<'a, Ctx> for $enum_name\n@@ -115,18 +114,17 @@ macro_rules! impl_snapshot_for {\n             fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n                 match *self {\n                     $(\n-                        $enum_name::$variant $( ( $(ref $field),* ) )* =>\n+                        $enum_name::$variant $( ( $(ref $field),* ) )? =>\n                             $enum_name::$variant $(\n-                                ( $( __impl_snapshot_field!($field, __ctx $(, $delegate)*) ),* ),\n-                            )*\n+                                ( $( __impl_snapshot_field!($field, __ctx $(, $delegate)?) ),* ),\n+                            )?\n                     )*\n                 }\n             }\n         }\n     };\n \n-    // FIXME(mark-i-m): same here.\n-    (struct $struct_name:ident { $($field:ident $(-> $delegate:expr)*),*  $(,)* }) => {\n+    (struct $struct_name:ident { $($field:ident $(-> $delegate:expr)?),*  $(,)? }) => {\n         impl<'a, Ctx> self::Snapshot<'a, Ctx> for $struct_name\n             where Ctx: self::SnapshotContext<'a>,\n         {\n@@ -139,7 +137,7 @@ macro_rules! impl_snapshot_for {\n                 } = *self;\n \n                 $struct_name {\n-                    $( $field: __impl_snapshot_field!($field, __ctx $(, $delegate)*) ),*\n+                    $( $field: __impl_snapshot_field!($field, __ctx $(, $delegate)?) ),*\n                 }\n             }\n         }"}, {"sha": "e0fee10cd008c90be3828ef42baa4c783984a9cb", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -7,7 +7,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(nll)]\n #![feature(in_band_lifetimes)]\n #![feature(slice_patterns)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]"}, {"sha": "285c674643f2e58cdcd2be4b45b1454a7b77f5bb", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1480,7 +1480,17 @@ impl MirPass for QualifyAndPromoteConstants {\n                         // enforce `min_const_fn` for stable const fns\n                         use super::qualify_min_const_fn::is_min_const_fn;\n                         if let Err((span, err)) = is_min_const_fn(tcx, def_id, mir) {\n-                            tcx.sess.span_err(span, &err);\n+                            let mut diag = struct_span_err!(\n+                                tcx.sess,\n+                                span,\n+                                E0723,\n+                                \"{} (see issue #57563)\",\n+                                err,\n+                            );\n+                            diag.help(\n+                                \"add #![feature(const_fn)] to the crate attributes to enable\",\n+                            );\n+                            diag.emit();\n                         } else {\n                             // this should not produce any errors, but better safe than sorry\n                             // FIXME(#53819)"}, {"sha": "606ae2741283240a973bfb136ac36fc36b8a3114", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -616,7 +616,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 if let Some(ref type_) = data.output {\n                     // `-> Foo` syntax is essentially an associated type binding,\n                     // so it is also allowed to contain nested `impl Trait`.\n-                    self.with_impl_trait(None, |this| visit::walk_ty(this, type_));\n+                    self.with_impl_trait(None, |this| this.visit_ty(type_));\n                 }\n             }\n         }"}, {"sha": "1a7744786d80eefcd6cccc9462200d2b500ed9b3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -4,7 +4,6 @@\n #![feature(label_break_value)]\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(slice_sort_by_cached_key)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "2dcb48692f6bdb5060f8512184d0f38b26af6aab", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -67,7 +67,6 @@ This API is completely unstable and subject to change.\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(never_type)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "ab471112832219e871f5b7c14a16551a57855ba5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -165,7 +165,12 @@ impl<'a, 'tcx, 'rcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx, 'rcx>\n         match module.inner {\n             ModuleItem(ref module) => {\n                 for it in &module.items {\n-                    if it.is_extern_crate() && it.attrs.has_doc_flag(\"masked\") {\n+                    // `compiler_builtins` should be masked too, but we can't apply\n+                    // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n+                    if it.is_extern_crate()\n+                        && (it.attrs.has_doc_flag(\"masked\")\n+                            || self.cx.tcx.is_compiler_builtins(it.def_id.krate))\n+                    {\n                         masked_crates.insert(it.def_id.krate);\n                     }\n                 }"}, {"sha": "91fbe877cb7d9f7fa661e60c0fa4b29d9e65646e", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -192,6 +192,8 @@ pub struct RenderOptions {\n     /// If false, the `select` element to have search filtering by crates on rendered docs\n     /// won't be generated.\n     pub generate_search_filter: bool,\n+    /// Option (disabled by default) to generate files used by RLS and some other tools.\n+    pub generate_redirect_pages: bool,\n }\n \n impl Options {\n@@ -436,6 +438,7 @@ impl Options {\n         let static_root_path = matches.opt_str(\"static-root-path\");\n         let generate_search_filter = !matches.opt_present(\"disable-per-crate-search\");\n         let persist_doctests = matches.opt_str(\"persist-doctests\").map(PathBuf::from);\n+        let generate_redirect_pages = matches.opt_present(\"generate-redirect-pages\");\n \n         let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n \n@@ -480,6 +483,7 @@ impl Options {\n                 markdown_css,\n                 markdown_playground_url,\n                 generate_search_filter,\n+                generate_redirect_pages,\n             }\n         })\n     }"}, {"sha": "692d87966887729890da288a4f8a6aa78fc02bf6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -148,6 +148,8 @@ struct SharedContext {\n     /// If false, the `select` element to have search filtering by crates on rendered docs\n     /// won't be generated.\n     pub generate_search_filter: bool,\n+    /// Option disabled by default to generate files used by RLS and some other tools.\n+    pub generate_redirect_pages: bool,\n }\n \n impl SharedContext {\n@@ -516,6 +518,7 @@ pub fn run(mut krate: clean::Crate,\n         resource_suffix,\n         static_root_path,\n         generate_search_filter,\n+        generate_redirect_pages,\n         ..\n     } = options;\n \n@@ -545,6 +548,7 @@ pub fn run(mut krate: clean::Crate,\n         resource_suffix,\n         static_root_path,\n         generate_search_filter,\n+        generate_redirect_pages,\n     };\n \n     // If user passed in `--playground-url` arg, we fill in crate name here\n@@ -2246,17 +2250,18 @@ impl Context {\n                 if !self.render_redirect_pages {\n                     all.append(full_path(self, &item), &item_type);\n                 }\n-                // Redirect from a sane URL using the namespace to Rustdoc's\n-                // URL for the page.\n-                let redir_name = format!(\"{}.{}.html\", name, item_type.name_space());\n-                let redir_dst = self.dst.join(redir_name);\n-                if let Ok(redirect_out) = OpenOptions::new().create_new(true)\n-                                                            .write(true)\n-                                                            .open(&redir_dst) {\n-                    let mut redirect_out = BufWriter::new(redirect_out);\n-                    try_err!(layout::redirect(&mut redirect_out, file_name), &redir_dst);\n+                if self.shared.generate_redirect_pages {\n+                    // Redirect from a sane URL using the namespace to Rustdoc's\n+                    // URL for the page.\n+                    let redir_name = format!(\"{}.{}.html\", name, item_type.name_space());\n+                    let redir_dst = self.dst.join(redir_name);\n+                    if let Ok(redirect_out) = OpenOptions::new().create_new(true)\n+                                                                .write(true)\n+                                                                .open(&redir_dst) {\n+                        let mut redirect_out = BufWriter::new(redirect_out);\n+                        try_err!(layout::redirect(&mut redirect_out, file_name), &redir_dst);\n+                    }\n                 }\n-\n                 // If the item is a macro, redirect from the old macro URL (with !)\n                 // to the new one (without).\n                 if item_type == ItemType::Macro {"}, {"sha": "ff28c4f40bcae15ffec1015cf7d2d5a7f95142d1", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1597,7 +1597,7 @@ if (!DOMTokenList.prototype.remove) {\n                 clearTimeout(searchTimeout);\n                 if (search_input.value.length === 0) {\n                     if (browserSupportsHistoryApi()) {\n-                        history.replaceState(\"\", \"std - Rust\", \"?search=\");\n+                        history.replaceState(\"\", window.currentCrate + \" - Rust\", \"?search=\");\n                     }\n                     if (hasClass(main, \"content\")) {\n                         removeClass(main, \"hidden\");"}, {"sha": "43b366535159ce468a075f512c9888107267a36d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -7,7 +7,6 @@\n #![feature(box_syntax)]\n #![feature(nll)]\n #![feature(set_stdio)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(test)]\n #![feature(vec_remove_item)]\n #![feature(ptr_offset_from)]\n@@ -346,6 +345,11 @@ fn opts() -> Vec<RustcOptGroup> {\n                        \"Directory to persist doctest executables into\",\n                        \"PATH\")\n         }),\n+        unstable(\"generate-redirect-pages\", |o| {\n+            o.optflag(\"\",\n+                      \"generate-redirect-pages\",\n+                      \"Generate extra pages to support legacy URLs and tool links\")\n+        }),\n     ]\n }\n "}, {"sha": "ef8c97bebdffdbfca227fdcea7c9d6c3959c564d", "filename": "src/libstd/error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -718,7 +718,7 @@ impl dyn Error {\n     /// ```\n     ///\n     /// [`source`]: trait.Error.html#method.source\n-    #[unstable(feature = \"error_iter\", issue = \"58289\")]\n+    #[unstable(feature = \"error_iter\", issue = \"58520\")]\n     #[inline]\n     pub fn iter_chain(&self) -> ErrorIter {\n         ErrorIter {\n@@ -793,7 +793,7 @@ impl dyn Error {\n     ///\n     /// [`source`]: trait.Error.html#method.source\n     #[inline]\n-    #[unstable(feature = \"error_iter\", issue = \"58289\")]\n+    #[unstable(feature = \"error_iter\", issue = \"58520\")]\n     pub fn iter_sources(&self) -> ErrorIter {\n         ErrorIter {\n             current: self.source(),\n@@ -804,13 +804,13 @@ impl dyn Error {\n /// An iterator over [`Error`]\n ///\n /// [`Error`]: trait.Error.html\n-#[unstable(feature = \"error_iter\", issue = \"58289\")]\n+#[unstable(feature = \"error_iter\", issue = \"58520\")]\n #[derive(Copy, Clone, Debug)]\n pub struct ErrorIter<'a> {\n     current: Option<&'a (dyn Error + 'static)>,\n }\n \n-#[unstable(feature = \"error_iter\", issue = \"58289\")]\n+#[unstable(feature = \"error_iter\", issue = \"58520\")]\n impl<'a> Iterator for ErrorIter<'a> {\n     type Item = &'a (dyn Error + 'static);\n "}, {"sha": "f849daf2079671a9f92d1718311d03238ebf926d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -295,6 +295,7 @@\n #![feature(non_exhaustive)]\n #![feature(alloc_layout_extra)]\n #![feature(maybe_uninit)]\n+#![feature(checked_duration_since)]\n #![cfg_attr(all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n             feature(global_asm, range_contains, slice_index_methods,\n                     decl_macro, coerce_unsized, sgx_platform, ptr_wrapping_offset_from))]"}, {"sha": "0a9796d1a9c209fd0d1ac075280016be922afe56", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1230,12 +1230,11 @@ impl PathBuf {\n \n     /// Truncates `self` to [`self.parent`].\n     ///\n-    /// Returns `false` and does nothing if [`self.file_name`] is [`None`].\n+    /// Returns `false` and does nothing if [`self.parent`] is [`None`].\n     /// Otherwise, returns `true`.\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     /// [`self.parent`]: struct.PathBuf.html#method.parent\n-    /// [`self.file_name`]: struct.PathBuf.html#method.file_name\n     ///\n     /// # Examples\n     ///"}, {"sha": "6fbbbb349b171a9a86e30ca8118abc18bc425391", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -281,8 +281,7 @@ impl Command {\n         use mem;\n         use sys;\n \n-        if self.get_cwd().is_some() ||\n-            self.get_gid().is_some() ||\n+        if self.get_gid().is_some() ||\n             self.get_uid().is_some() ||\n             self.env_saw_path() ||\n             self.get_closures().len() != 0 {\n@@ -301,6 +300,24 @@ impl Command {\n             }\n         }\n \n+        // Solaris and glibc 2.29+ can set a new working directory, and maybe\n+        // others will gain this non-POSIX function too. We'll check for this\n+        // weak symbol as soon as it's needed, so we can return early otherwise\n+        // to do a manual chdir before exec.\n+        weak! {\n+            fn posix_spawn_file_actions_addchdir_np(\n+                *mut libc::posix_spawn_file_actions_t,\n+                *const libc::c_char\n+            ) -> libc::c_int\n+        }\n+        let addchdir = match self.get_cwd() {\n+            Some(cwd) => match posix_spawn_file_actions_addchdir_np.get() {\n+                Some(f) => Some((f, cwd)),\n+                None => return Ok(None),\n+            },\n+            None => None,\n+        };\n+\n         let mut p = Process { pid: 0, status: None };\n \n         struct PosixSpawnFileActions(libc::posix_spawn_file_actions_t);\n@@ -345,6 +362,9 @@ impl Command {\n                                                            fd,\n                                                            libc::STDERR_FILENO))?;\n             }\n+            if let Some((f, cwd)) = addchdir {\n+                cvt(f(&mut file_actions.0, cwd.as_ptr()))?;\n+            }\n \n             let mut set: libc::sigset_t = mem::uninitialized();\n             cvt(libc::sigemptyset(&mut set))?;"}, {"sha": "e1c2b2b1d4f3079532be68437cac7fd1510e6ab9", "filename": "src/libstd/time.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -218,6 +218,52 @@ impl Instant {\n         self.0.sub_instant(&earlier.0)\n     }\n \n+    /// Returns the amount of time elapsed from another instant to this one,\n+    /// or None if that instant is earlier than this one.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(checked_duration_since)]\n+    /// use std::time::{Duration, Instant};\n+    /// use std::thread::sleep;\n+    ///\n+    /// let now = Instant::now();\n+    /// sleep(Duration::new(1, 0));\n+    /// let new_now = Instant::now();\n+    /// println!(\"{:?}\", new_now.checked_duration_since(now));\n+    /// println!(\"{:?}\", now.checked_duration_since(new_now)); // None\n+    /// ```\n+    #[unstable(feature = \"checked_duration_since\", issue = \"58402\")]\n+    pub fn checked_duration_since(&self, earlier: Instant) -> Option<Duration> {\n+        if self >= &earlier {\n+            Some(self.0.sub_instant(&earlier.0))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns the amount of time elapsed from another instant to this one,\n+    /// or zero duration if that instant is earlier than this one.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(checked_duration_since)]\n+    /// use std::time::{Duration, Instant};\n+    /// use std::thread::sleep;\n+    ///\n+    /// let now = Instant::now();\n+    /// sleep(Duration::new(1, 0));\n+    /// let new_now = Instant::now();\n+    /// println!(\"{:?}\", new_now.saturating_duration_since(now));\n+    /// println!(\"{:?}\", now.saturating_duration_since(new_now)); // 0ns\n+    /// ```\n+    #[unstable(feature = \"checked_duration_since\", issue = \"58402\")]\n+    pub fn saturating_duration_since(&self, earlier: Instant) -> Duration {\n+        self.checked_duration_since(earlier).unwrap_or(Duration::new(0, 0))\n+    }\n+\n     /// Returns the amount of time elapsed since this instant was created.\n     ///\n     /// # Panics\n@@ -626,6 +672,20 @@ mod tests {\n         (a - Duration::new(1, 0)).duration_since(a);\n     }\n \n+    #[test]\n+    fn checked_instant_duration_nopanic() {\n+        let a = Instant::now();\n+        let ret = (a - Duration::new(1, 0)).checked_duration_since(a);\n+        assert_eq!(ret, None);\n+    }\n+\n+    #[test]\n+    fn saturating_instant_duration_nopanic() {\n+        let a = Instant::now();\n+        let ret = (a - Duration::new(1, 0)).saturating_duration_since(a);\n+        assert_eq!(ret, Duration::new(0,0));\n+    }\n+\n     #[test]\n     fn system_time_math() {\n         let a = SystemTime::now();"}, {"sha": "a6145d5dcb38c6234146c2657111c267dff28918", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -14,7 +14,6 @@\n #![feature(nll)]\n #![feature(rustc_attrs)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(step_trait)]\n #![feature(try_trait)]\n #![feature(unicode_internals)]"}, {"sha": "c6bac51c5740dcd6da42b9af545f843a53724fcd", "filename": "src/test/rustdoc/issue-19190.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fissue-19190.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fissue-19190.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-19190.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags:-Z unstable-options --generate-redirect-pages\n+\n use std::ops::Deref;\n \n pub struct Foo;"}, {"sha": "b054145a4831a6d681516b560c1c19ec072162bb", "filename": "src/test/rustdoc/issue-21092.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fissue-21092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fissue-21092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-21092.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -3,7 +3,6 @@\n \n extern crate issue_21092;\n \n-// @has issue_21092/Bar.t.html\n // @has issue_21092/struct.Bar.html\n // @has - '//*[@id=\"associatedtype.Bar\"]' 'type Bar = i32'\n pub use issue_21092::{Foo, Bar};"}, {"sha": "33f7646ced68b4ef1f13442ff2b4cd3f23edc2cc", "filename": "src/test/rustdoc/issue-35169-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fissue-35169-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fissue-35169-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-35169-2.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -23,7 +23,6 @@ impl DerefMut for Bar {\n     fn deref_mut(&mut self) -> &mut Foo { loop {} }\n }\n \n-// @has issue_35169_2/Bar.t.html\n // @has issue_35169_2/struct.Bar.html\n // @has - '//*[@id=\"by_ref.v\"]' 'fn by_ref(&self)'\n // @has - '//*[@id=\"method.by_ref\"]' 'fn by_ref(&self)'"}, {"sha": "04fffc40572a6b5515cfad66c6f99b924c78261f", "filename": "src/test/rustdoc/issue-35169.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fissue-35169.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fissue-35169.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-35169.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -18,7 +18,6 @@ impl Deref for Bar {\n     fn deref(&self) -> &Foo { loop {} }\n }\n \n-// @has issue_35169/Bar.t.html\n // @has issue_35169/struct.Bar.html\n // @has - '//*[@id=\"by_ref.v\"]' 'fn by_ref(&self)'\n // @has - '//*[@id=\"method.by_ref\"]' 'fn by_ref(&self)'"}, {"sha": "fb4f02ad16052a8bc3f0c746733f9df62fdd14e7", "filename": "src/test/rustdoc/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacros.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -2,8 +2,6 @@\n // @has - //pre '() => { ... };'\n // @has - //pre '($a:tt) => { ... };'\n // @has - //pre '($e:expr) => { ... };'\n-// @has macros/macro.my_macro!.html\n-// @has - //a 'macro.my_macro.html'\n #[macro_export]\n macro_rules! my_macro {\n     () => [];"}, {"sha": "353ce10243e0055d8ee570b77bf4d9f8e786d076", "filename": "src/test/rustdoc/src-links.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fsrc-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fsrc-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsrc-links.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -14,13 +14,11 @@ pub mod bar {\n     // @has foo/bar/baz/index.html '//a/@href' '../../../src/foo/src-links.rs.html'\n     pub mod baz {\n         /// Dox\n-        // @has foo/bar/baz/baz.v.html\n         // @has foo/bar/baz/fn.baz.html '//a/@href' '../../../src/foo/src-links.rs.html'\n         pub fn baz() { }\n     }\n \n     /// Dox\n-    // @has foo/bar/Foobar.t.html\n     // @has foo/bar/trait.Foobar.html '//a/@href' '../../src/foo/src-links.rs.html'\n     pub trait Foobar { fn dummy(&self) { } }\n "}, {"sha": "235f0e852da2ca9dd4bb49bb34a8877de71c7406", "filename": "src/test/rustdoc/structfields.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fstructfields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fstructfields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstructfields.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags:-Z unstable-options --generate-redirect-pages\n+\n // @has structfields/Foo.t.html\n // @has - struct.Foo.html\n // @has structfields/struct.Foo.html"}, {"sha": "a076f8a3c5ec799a319797deec73ca4ec208fa98", "filename": "src/test/rustdoc/without-redirect.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fwithout-redirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Frustdoc%2Fwithout-redirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwithout-redirect.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -0,0 +1,13 @@\n+#![crate_name = \"foo\"]\n+\n+// @has foo/macro.bar.html\n+// @has foo/macro.bar!.html\n+// @!has foo/bar.m.html\n+#[macro_export]\n+macro_rules! bar {\n+    () => {}\n+}\n+\n+// @has foo/struct.Bar.html\n+// @!has foo/Bar.t.html\n+pub struct Bar;"}, {"sha": "62f678790d21fdb56cd50dabafda4eeac712fb86", "filename": "src/test/ui/consts/min_const_fn/bad_const_fn_body_ice.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,10 +1,12 @@\n-error: heap allocations are not allowed in const fn\n+error[E0723]: heap allocations are not allowed in const fn (see issue #57563)\n   --> $DIR/bad_const_fn_body_ice.rs:2:5\n    |\n LL |     vec![1, 2, 3] //~ ERROR heap allocations are not allowed in const fn\n    |     ^^^^^^^^^^^^^\n    |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "b5af3e7ee46655ca8d5c44f3aa342a1584102305", "filename": "src/test/ui/consts/min_const_fn/cast_errors.stderr", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcast_errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcast_errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcast_errors.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,32 +1,43 @@\n-error: unsizing casts are not allowed in const fn\n+error[E0723]: unsizing casts are not allowed in const fn (see issue #57563)\n   --> $DIR/cast_errors.rs:3:41\n    |\n LL | const fn unsize(x: &[u8; 3]) -> &[u8] { x }\n    |                                         ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: function pointers in const fn are unstable\n+error[E0723]: function pointers in const fn are unstable (see issue #57563)\n   --> $DIR/cast_errors.rs:5:23\n    |\n LL | const fn closure() -> fn() { || {} }\n    |                       ^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: function pointers in const fn are unstable\n+error[E0723]: function pointers in const fn are unstable (see issue #57563)\n   --> $DIR/cast_errors.rs:8:5\n    |\n LL |     (|| {}) as fn();\n    |     ^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: function pointers in const fn are unstable\n+error[E0723]: function pointers in const fn are unstable (see issue #57563)\n   --> $DIR/cast_errors.rs:11:28\n    |\n LL | const fn reify(f: fn()) -> unsafe fn() { f }\n    |                            ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: function pointers in const fn are unstable\n+error[E0723]: function pointers in const fn are unstable (see issue #57563)\n   --> $DIR/cast_errors.rs:13:21\n    |\n LL | const fn reify2() { main as unsafe fn(); }\n    |                     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "d84e2651d4fc42ac5f1390aca3139bb7e6942ca7", "filename": "src/test/ui/consts/min_const_fn/cmp_fn_pointers.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcmp_fn_pointers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcmp_fn_pointers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcmp_fn_pointers.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,8 +1,11 @@\n-error: function pointers in const fn are unstable\n+error[E0723]: function pointers in const fn are unstable (see issue #57563)\n   --> $DIR/cmp_fn_pointers.rs:1:14\n    |\n LL | const fn cmp(x: fn(), y: fn()) -> bool { //~ ERROR function pointers in const fn are unstable\n    |              ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "716e8380c45da23a2ebad6861a53c38cb742335c", "filename": "src/test/ui/consts/min_const_fn/loop_ice.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Floop_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Floop_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Floop_ice.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,8 +1,11 @@\n-error: loops are not allowed in const fn\n+error[E0723]: loops are not allowed in const fn (see issue #57563)\n   --> $DIR/loop_ice.rs:2:5\n    |\n LL |     loop {} //~ ERROR loops are not allowed in const fn\n    |     ^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "feb4960e0c7463f2d618483aaead279a98806c87", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.nll.stderr", "status": "modified", "additions": 100, "deletions": 34, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -4,197 +4,257 @@ error[E0493]: destructors cannot be evaluated at compile-time\n LL |     const fn into_inner(self) -> T { self.0 } //~ destructors cannot be evaluated\n    |                         ^^^^ constant functions cannot evaluate destructors\n \n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:39:36\n    |\n LL |     const fn get_mut(&mut self) -> &mut T { &mut self.0 }\n    |                                    ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:44:28\n    |\n LL |     const fn into_inner_lt(self) -> T { self.0 } //~ destructors cannot be evaluated\n    |                            ^^^^ constant functions cannot evaluate destructors\n \n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:46:42\n    |\n LL |     const fn get_mut_lt(&'a mut self) -> &mut T { &mut self.0 }\n    |                                          ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:51:27\n    |\n LL |     const fn into_inner_s(self) -> T { self.0 } //~ ERROR destructors\n    |                           ^^^^ constant functions cannot evaluate destructors\n \n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:53:38\n    |\n LL |     const fn get_mut_s(&mut self) -> &mut T { &mut self.0 }\n    |                                      ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:58:39\n    |\n LL |     const fn get_mut_sq(&mut self) -> &mut T { &mut self.0 }\n    |                                       ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:76:16\n    |\n LL | const fn foo11<T: std::fmt::Display>(t: T) -> T { t }\n    |                ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:78:18\n    |\n LL | const fn foo11_2<T: Send>(t: T) -> T { t }\n    |                  ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: only int, `bool` and `char` operations are stable in const fn\n+error[E0723]: only int, `bool` and `char` operations are stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:80:33\n    |\n LL | const fn foo19(f: f32) -> f32 { f * 2.0 }\n    |                                 ^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: only int, `bool` and `char` operations are stable in const fn\n+error[E0723]: only int, `bool` and `char` operations are stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:82:35\n    |\n LL | const fn foo19_2(f: f32) -> f32 { 2.0 - f }\n    |                                   ^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: only int and `bool` operations are stable in const fn\n+error[E0723]: only int and `bool` operations are stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:84:35\n    |\n LL | const fn foo19_3(f: f32) -> f32 { -f }\n    |                                   ^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: only int, `bool` and `char` operations are stable in const fn\n+error[E0723]: only int, `bool` and `char` operations are stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:86:43\n    |\n LL | const fn foo19_4(f: f32, g: f32) -> f32 { f / g }\n    |                                           ^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: cannot access `static` items in const fn\n+error[E0723]: cannot access `static` items in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:90:27\n    |\n LL | const fn foo25() -> u32 { BAR } //~ ERROR cannot access `static` items in const fn\n    |                           ^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: cannot access `static` items in const fn\n+error[E0723]: cannot access `static` items in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:91:36\n    |\n LL | const fn foo26() -> &'static u32 { &BAR } //~ ERROR cannot access `static` items\n    |                                    ^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: casting pointers to ints is unstable in const fn\n+error[E0723]: casting pointers to ints is unstable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:92:42\n    |\n LL | const fn foo30(x: *const u32) -> usize { x as usize }\n    |                                          ^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: casting pointers to ints is unstable in const fn\n+error[E0723]: casting pointers to ints is unstable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:94:63\n    |\n LL | const fn foo30_with_unsafe(x: *const u32) -> usize { unsafe { x as usize } }\n    |                                                               ^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: casting pointers to ints is unstable in const fn\n+error[E0723]: casting pointers to ints is unstable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:96:42\n    |\n LL | const fn foo30_2(x: *mut u32) -> usize { x as usize }\n    |                                          ^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: casting pointers to ints is unstable in const fn\n+error[E0723]: casting pointers to ints is unstable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:98:63\n    |\n LL | const fn foo30_2_with_unsafe(x: *mut u32) -> usize { unsafe { x as usize } }\n    |                                                               ^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:100:38\n    |\n LL | const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:102:29\n    |\n LL | const fn foo30_5(b: bool) { while b { } } //~ ERROR not stable in const fn\n    |                             ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:104:44\n    |\n LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n    |                                            ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:106:44\n    |\n LL | const fn foo37(a: bool, b: bool) -> bool { a || b }\n    |                                            ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:108:14\n    |\n LL | const fn inc(x: &mut i32) { *x += 1 }\n    |              ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:113:6\n    |\n LL | impl<T: std::fmt::Debug> Foo<T> {\n    |      ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:118:6\n    |\n LL | impl<T: std::fmt::Debug + Sized> Foo<T> {\n    |      ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:123:6\n    |\n LL | impl<T: Sync + Sized> Foo<T> {\n    |      ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: `impl Trait` in const fn is unstable\n+error[E0723]: `impl Trait` in const fn is unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:129:24\n    |\n LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:131:34\n    |\n LL | const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:133:22\n    |\n LL | const fn no_apit(_x: impl std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n    |                      ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: `impl Trait` in const fn is unstable\n+error[E0723]: `impl Trait` in const fn is unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:134:23\n    |\n LL | const fn no_rpit() -> impl std::fmt::Debug {} //~ ERROR `impl Trait` in const fn is unstable\n    |                       ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:135:23\n    |\n LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n    |                       ^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:136:32\n    |\n LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n warning[E0515]: cannot return reference to temporary value\n   --> $DIR/min_const_fn.rs:136:63\n@@ -208,25 +268,31 @@ LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:141:41\n    |\n LL | const fn really_no_traits_i_mean_it() { (&() as &std::fmt::Debug, ()).1 }\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: function pointers in const fn are unstable\n+error[E0723]: function pointers in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:144:21\n    |\n LL | const fn no_fn_ptrs(_x: fn()) {}\n    |                     ^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: function pointers in const fn are unstable\n+error[E0723]: function pointers in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:146:27\n    |\n LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n    |                           ^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to 36 previous errors\n \n-Some errors occurred: E0493, E0515.\n+Some errors occurred: E0493, E0515, E0723.\n For more information about an error, try `rustc --explain E0493`."}, {"sha": "e095ccaf20e29a106b46008ea1872e9ec06049be", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 101, "deletions": 34, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -4,216 +4,283 @@ error[E0493]: destructors cannot be evaluated at compile-time\n LL |     const fn into_inner(self) -> T { self.0 } //~ destructors cannot be evaluated\n    |                         ^^^^ constant functions cannot evaluate destructors\n \n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:39:36\n    |\n LL |     const fn get_mut(&mut self) -> &mut T { &mut self.0 }\n    |                                    ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:44:28\n    |\n LL |     const fn into_inner_lt(self) -> T { self.0 } //~ destructors cannot be evaluated\n    |                            ^^^^ constant functions cannot evaluate destructors\n \n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:46:42\n    |\n LL |     const fn get_mut_lt(&'a mut self) -> &mut T { &mut self.0 }\n    |                                          ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:51:27\n    |\n LL |     const fn into_inner_s(self) -> T { self.0 } //~ ERROR destructors\n    |                           ^^^^ constant functions cannot evaluate destructors\n \n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:53:38\n    |\n LL |     const fn get_mut_s(&mut self) -> &mut T { &mut self.0 }\n    |                                      ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:58:39\n    |\n LL |     const fn get_mut_sq(&mut self) -> &mut T { &mut self.0 }\n    |                                       ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:76:16\n    |\n LL | const fn foo11<T: std::fmt::Display>(t: T) -> T { t }\n    |                ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:78:18\n    |\n LL | const fn foo11_2<T: Send>(t: T) -> T { t }\n    |                  ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: only int, `bool` and `char` operations are stable in const fn\n+error[E0723]: only int, `bool` and `char` operations are stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:80:33\n    |\n LL | const fn foo19(f: f32) -> f32 { f * 2.0 }\n    |                                 ^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: only int, `bool` and `char` operations are stable in const fn\n+error[E0723]: only int, `bool` and `char` operations are stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:82:35\n    |\n LL | const fn foo19_2(f: f32) -> f32 { 2.0 - f }\n    |                                   ^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: only int and `bool` operations are stable in const fn\n+error[E0723]: only int and `bool` operations are stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:84:35\n    |\n LL | const fn foo19_3(f: f32) -> f32 { -f }\n    |                                   ^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: only int, `bool` and `char` operations are stable in const fn\n+error[E0723]: only int, `bool` and `char` operations are stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:86:43\n    |\n LL | const fn foo19_4(f: f32, g: f32) -> f32 { f / g }\n    |                                           ^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: cannot access `static` items in const fn\n+error[E0723]: cannot access `static` items in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:90:27\n    |\n LL | const fn foo25() -> u32 { BAR } //~ ERROR cannot access `static` items in const fn\n    |                           ^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: cannot access `static` items in const fn\n+error[E0723]: cannot access `static` items in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:91:36\n    |\n LL | const fn foo26() -> &'static u32 { &BAR } //~ ERROR cannot access `static` items\n    |                                    ^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: casting pointers to ints is unstable in const fn\n+error[E0723]: casting pointers to ints is unstable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:92:42\n    |\n LL | const fn foo30(x: *const u32) -> usize { x as usize }\n    |                                          ^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: casting pointers to ints is unstable in const fn\n+error[E0723]: casting pointers to ints is unstable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:94:63\n    |\n LL | const fn foo30_with_unsafe(x: *const u32) -> usize { unsafe { x as usize } }\n    |                                                               ^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: casting pointers to ints is unstable in const fn\n+error[E0723]: casting pointers to ints is unstable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:96:42\n    |\n LL | const fn foo30_2(x: *mut u32) -> usize { x as usize }\n    |                                          ^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: casting pointers to ints is unstable in const fn\n+error[E0723]: casting pointers to ints is unstable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:98:63\n    |\n LL | const fn foo30_2_with_unsafe(x: *mut u32) -> usize { unsafe { x as usize } }\n    |                                                               ^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:100:38\n    |\n LL | const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:102:29\n    |\n LL | const fn foo30_5(b: bool) { while b { } } //~ ERROR not stable in const fn\n    |                             ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:104:44\n    |\n LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n    |                                            ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn.rs:106:44\n    |\n LL | const fn foo37(a: bool, b: bool) -> bool { a || b }\n    |                                            ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:108:14\n    |\n LL | const fn inc(x: &mut i32) { *x += 1 }\n    |              ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:113:6\n    |\n LL | impl<T: std::fmt::Debug> Foo<T> {\n    |      ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:118:6\n    |\n LL | impl<T: std::fmt::Debug + Sized> Foo<T> {\n    |      ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:123:6\n    |\n LL | impl<T: Sync + Sized> Foo<T> {\n    |      ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: `impl Trait` in const fn is unstable\n+error[E0723]: `impl Trait` in const fn is unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:129:24\n    |\n LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:131:34\n    |\n LL | const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:133:22\n    |\n LL | const fn no_apit(_x: impl std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n    |                      ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: `impl Trait` in const fn is unstable\n+error[E0723]: `impl Trait` in const fn is unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:134:23\n    |\n LL | const fn no_rpit() -> impl std::fmt::Debug {} //~ ERROR `impl Trait` in const fn is unstable\n    |                       ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:135:23\n    |\n LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n    |                       ^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:136:32\n    |\n LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:141:41\n    |\n LL | const fn really_no_traits_i_mean_it() { (&() as &std::fmt::Debug, ()).1 }\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: function pointers in const fn are unstable\n+error[E0723]: function pointers in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:144:21\n    |\n LL | const fn no_fn_ptrs(_x: fn()) {}\n    |                     ^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: function pointers in const fn are unstable\n+error[E0723]: function pointers in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn.rs:146:27\n    |\n LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n    |                           ^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to 36 previous errors\n \n-For more information about this error, try `rustc --explain E0493`.\n+Some errors occurred: E0493, E0723.\n+For more information about an error, try `rustc --explain E0493`."}, {"sha": "2800d622f5353c0947ac80779ca5f5058fc3cc17", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_dyn.nll.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.nll.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,14 +1,18 @@\n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn_dyn.rs:9:5\n    |\n LL |     x.0.field;\n    |     ^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn_dyn.rs:12:66\n    |\n LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n    |                                                                  ^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n warning[E0716]: temporary value dropped while borrowed\n   --> $DIR/min_const_fn_dyn.rs:12:67\n@@ -24,4 +28,5 @@ LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0716`.\n+Some errors occurred: E0716, E0723.\n+For more information about an error, try `rustc --explain E0716`."}, {"sha": "8ff963722cf1519aac0a63523da678ab6f1b03c1", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_dyn.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,14 +1,19 @@\n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn_dyn.rs:9:5\n    |\n LL |     x.0.field;\n    |     ^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: trait bounds other than `Sized` on const fn parameters are unstable\n+error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable (see issue #57563)\n   --> $DIR/min_const_fn_dyn.rs:12:66\n    |\n LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n    |                                                                  ^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "8838ababe2c0e99adb0eb85a66da361ded04ca42", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_fn_ptr.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_fn_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_fn_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_fn_ptr.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,14 +1,19 @@\n-error: function pointers in const fn are unstable\n+error[E0723]: function pointers in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn_fn_ptr.rs:11:5\n    |\n LL |     x.0.field;\n    |     ^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: function pointers in const fn are unstable\n+error[E0723]: function pointers in const fn are unstable (see issue #57563)\n   --> $DIR/min_const_fn_fn_ptr.rs:14:59\n    |\n LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasPtr { field }) }\n    |                                                           ^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "1e6f698b3c8e3f11acdc379bb0d89c7c21a7db05", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_libstd_stability.stderr", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,26 +1,35 @@\n-error: can only call other `min_const_fn` within a `min_const_fn`\n+error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n   --> $DIR/min_const_fn_libstd_stability.rs:15:25\n    |\n LL | const fn bar() -> u32 { foo() } //~ ERROR can only call other `min_const_fn`\n    |                         ^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: can only call other `min_const_fn` within a `min_const_fn`\n+error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n   --> $DIR/min_const_fn_libstd_stability.rs:22:26\n    |\n LL | const fn bar2() -> u32 { foo2() } //~ ERROR can only call other `min_const_fn`\n    |                          ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: only int, `bool` and `char` operations are stable in const fn\n+error[E0723]: only int, `bool` and `char` operations are stable in const fn (see issue #57563)\n   --> $DIR/min_const_fn_libstd_stability.rs:26:26\n    |\n LL | const fn bar3() -> u32 { (5f32 + 6f32) as u32 } //~ ERROR only int, `bool` and `char` operations\n    |                          ^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: can only call other `min_const_fn` within a `min_const_fn`\n+error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n   --> $DIR/min_const_fn_libstd_stability.rs:34:32\n    |\n LL | const fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR can only call other `min_const_fn`\n    |                                ^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "07d10984392d809d067dc84f6fb40b5807850455", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability.stderr", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,26 +1,35 @@\n-error: can only call other `min_const_fn` within a `min_const_fn`\n+error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:15:41\n    |\n LL | const unsafe fn bar() -> u32 { unsafe { foo() } } //~ ERROR can only call other `min_const_fn`\n    |                                         ^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: can only call other `min_const_fn` within a `min_const_fn`\n+error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:22:42\n    |\n LL | const unsafe fn bar2() -> u32 { unsafe { foo2() } } //~ ERROR can only call other `min_const_fn`\n    |                                          ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: only int, `bool` and `char` operations are stable in const fn\n+error[E0723]: only int, `bool` and `char` operations are stable in const fn (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:26:33\n    |\n LL | const unsafe fn bar3() -> u32 { (5f32 + 6f32) as u32 } //~ ERROR only int, `bool` and `char` op\n    |                                 ^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: can only call other `min_const_fn` within a `min_const_fn`\n+error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:34:48\n    |\n LL | const unsafe fn bar2_gated() -> u32 { unsafe { foo2_gated() } } //~ ERROR can only call other\n    |                                                ^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "7cb8c6e62ec60ac3f2dd7c45b642d89bffc3fbaa", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability2.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,20 +1,27 @@\n-error: can only call other `min_const_fn` within a `min_const_fn`\n+error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:15:32\n    |\n LL | const unsafe fn bar() -> u32 { foo() } //~ ERROR can only call other `min_const_fn`\n    |                                ^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: can only call other `min_const_fn` within a `min_const_fn`\n+error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:22:33\n    |\n LL | const unsafe fn bar2() -> u32 { foo2() } //~ ERROR can only call other `min_const_fn`\n    |                                 ^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: can only call other `min_const_fn` within a `min_const_fn`\n+error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:30:39\n    |\n LL | const unsafe fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR can only call other `min_const_fn`\n    |                                       ^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "e5a3502a3dc52770eb0484a7ff93a24227e20c63", "filename": "src/test/ui/consts/min_const_fn/mutable_borrow.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmutable_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmutable_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmutable_borrow.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,14 +1,19 @@\n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/mutable_borrow.rs:3:9\n    |\n LL |     let b = &mut a; //~ ERROR mutable references in const fn\n    |         ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/mutable_borrow.rs:12:13\n    |\n LL |         let b = &mut a; //~ ERROR mutable references in const fn\n    |             ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "d199e34775e4be1d9a871e831297f5408b6d491a", "filename": "src/test/ui/consts/promote_evaluation_unused_result.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fpromote_evaluation_unused_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fpromote_evaluation_unused_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromote_evaluation_unused_result.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -0,0 +1,8 @@\n+//compile-pass\n+\n+#![feature(nll)]\n+\n+fn main() {\n+\n+    let _: &'static usize = &(loop {}, 1).1;\n+}"}, {"sha": "5272062ccfc14e959ac07beccbd05c9165a0494a", "filename": "src/test/ui/consts/single_variant_match_ice.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -10,12 +10,15 @@ error[E0019]: constant contains unimplemented expression type\n LL |     x => 42, //~ ERROR unimplemented expression type\n    |     ^\n \n-error: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn (see issue #57563)\n   --> $DIR/single_variant_match_ice.rs:18:13\n    |\n LL |             Prob => 0x1, //~ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n    |             ^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0019`.\n+Some errors occurred: E0019, E0723.\n+For more information about an error, try `rustc --explain E0019`."}, {"sha": "97160af43bee4eb1796c59fa0d0f7f6fb89d55c0", "filename": "src/test/ui/issues/issue-37550.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fissues%2Fissue-37550.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fissues%2Fissue-37550.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37550.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,8 +1,11 @@\n-error: function pointers in const fn are unstable\n+error[E0723]: function pointers in const fn are unstable (see issue #57563)\n   --> $DIR/issue-37550.rs:3:9\n    |\n LL |     let x = || t; //~ ERROR function pointers in const fn are unstable\n    |         ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "abd46b60ab194498d83f429979c427695166735c", "filename": "src/test/ui/issues/issue-57979.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fissues%2Fissue-57979.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fissues%2Fissue-57979.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57979.rs?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -0,0 +1,42 @@\n+// Regression test for #57979. This situation is meant to be an error.\n+// As noted in the issue thread, we decided to forbid nested impl\n+// trait of this kind:\n+//\n+// ```rust\n+// fn foo() -> impl Foo<impl Bar> { .. }\n+// ```\n+//\n+// Basically there are two hidden variables here, let's call them `X`\n+// and `Y`, and we must prove that:\n+//\n+// ```\n+// X: Foo<Y>\n+// Y: Bar\n+// ```\n+//\n+// However, the user is only giving us the return type `X`. It's true\n+// that in some cases, we can infer `Y` from `X`, because `X` only\n+// implements `Foo` for one type (and indeed the compiler does\n+// inference of this kind), but I do recall that we intended to forbid\n+// this -- in part because such inference is fragile, and there is not\n+// necessarily a way for the user to be more explicit should the\n+// inference fail (so you could get stuck with no way to port your\n+// code forward if, for example, more impls are added to an existing\n+// type).\n+//\n+// The same seems to apply in this situation. Here there are three impl traits, so we have\n+//\n+// ```\n+// X: IntoIterator<Item = Y>\n+// Y: Borrow<Data<Z>>\n+// Z: AsRef<[u8]>\n+// ```\n+\n+use std::borrow::Borrow;\n+\n+pub struct Data<TBody>(TBody);\n+\n+pub fn collect(_: impl IntoIterator<Item = impl Borrow<Data<impl AsRef<[u8]>>>>) {\n+    //~^ ERROR\n+    unimplemented!()\n+}"}, {"sha": "488f30ab7c5a7d6f6eda064f831e80b6ae4ab614", "filename": "src/test/ui/issues/issue-57979.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fissues%2Fissue-57979.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Fissues%2Fissue-57979.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57979.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -0,0 +1,17 @@\n+error[E0666]: nested `impl Trait` is not allowed\n+  --> $DIR/issue-57979.rs:39:61\n+   |\n+LL | pub fn collect(_: impl IntoIterator<Item = impl Borrow<Data<impl AsRef<[u8]>>>>) {\n+   |                                            -----------------^^^^^^^^^^^^^^^^--\n+   |                                            |                |\n+   |                                            |                nested `impl Trait` here\n+   |                                            outer `impl Trait`\n+\n+error[E0601]: `main` function not found in crate `issue_57979`\n+   |\n+   = note: consider adding a `main` function to `$DIR/issue-57979.rs`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0601, E0666.\n+For more information about an error, try `rustc --explain E0601`."}, {"sha": "fb3841948f11fd490f4c9a3c722171606202db22", "filename": "src/test/ui/unsafe/ranged_ints2_const.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.stderr?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -1,14 +1,18 @@\n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/ranged_ints2_const.rs:11:9\n    |\n LL |     let y = &mut x.0; //~ ERROR references in const fn are unstable\n    |         ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error: mutable references in const fn are unstable\n+error[E0723]: mutable references in const fn are unstable (see issue #57563)\n   --> $DIR/ranged_ints2_const.rs:18:9\n    |\n LL |     let y = unsafe { &mut x.0 }; //~ ERROR mutable references in const fn are unstable\n    |         ^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0133]: mutation of layout constrained field is unsafe and requires unsafe function or block\n   --> $DIR/ranged_ints2_const.rs:11:13\n@@ -20,4 +24,5 @@ LL |     let y = &mut x.0; //~ ERROR references in const fn are unstable\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0133`.\n+Some errors occurred: E0133, E0723.\n+For more information about an error, try `rustc --explain E0133`."}, {"sha": "ef17d6fbd5db321bfd97725de81b7e99b1ebb7d3", "filename": "src/tools/publish_toolstate.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftools%2Fpublish_toolstate.py", "raw_url": "https://github.com/rust-lang/rust/raw/8af675a07576940ba24e3d91abd10b029b937946/src%2Ftools%2Fpublish_toolstate.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fpublish_toolstate.py?ref=8af675a07576940ba24e3d91abd10b029b937946", "patch": "@@ -15,7 +15,7 @@\n # List of people to ping when the status of a tool changed.\n MAINTAINERS = {\n     'miri': '@oli-obk @RalfJung @eddyb',\n-    'clippy-driver': '@Manishearth @llogiq @mcarton @oli-obk',\n+    'clippy-driver': '@Manishearth @llogiq @mcarton @oli-obk @phansch',\n     'rls': '@nrc @Xanewok',\n     'rustfmt': '@nrc @topecongiro',\n     'book': '@carols10cents @steveklabnik',"}]}