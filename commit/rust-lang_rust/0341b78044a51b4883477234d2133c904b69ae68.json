{"sha": "0341b78044a51b4883477234d2133c904b69ae68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNDFiNzgwNDRhNTFiNDg4MzQ3NzIzNGQyMTMzYzkwNGI2OWFlNjg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-04T23:43:53Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-05T06:33:09Z"}, "message": "resolve: bool -> enum PatBoundCtx", "tree": {"sha": "9fbe5e9a3f23133418cd7ce26fbc823b9a806294", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fbe5e9a3f23133418cd7ce26fbc823b9a806294"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0341b78044a51b4883477234d2133c904b69ae68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0341b78044a51b4883477234d2133c904b69ae68", "html_url": "https://github.com/rust-lang/rust/commit/0341b78044a51b4883477234d2133c904b69ae68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0341b78044a51b4883477234d2133c904b69ae68/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7db1a4861e33f89181511a2e19aaa38e37e7f7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7db1a4861e33f89181511a2e19aaa38e37e7f7a", "html_url": "https://github.com/rust-lang/rust/commit/a7db1a4861e33f89181511a2e19aaa38e37e7f7a"}], "stats": {"total": 47, "additions": 29, "deletions": 18}, "files": [{"sha": "3ddaf2d94f9c82649e8b56b73c2de3b6b56f8f9c", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0341b78044a51b4883477234d2133c904b69ae68/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0341b78044a51b4883477234d2133c904b69ae68/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=0341b78044a51b4883477234d2133c904b69ae68", "patch": "@@ -75,6 +75,16 @@ impl PatternSource {\n     }\n }\n \n+/// Denotes whether the context for the set of already bound bindings is a `Product`\n+/// or `Or` context. This is used in e.g., `fresh_binding` and `resolve_pattern_inner`.\n+/// See those functions for more information.\n+enum PatBoundCtx {\n+    /// A product pattern context, e.g., `Variant(a, b)`.\n+    Product,\n+    /// An or-pattern context, e.g., `p_0 | ... | p_n`.\n+    Or,\n+}\n+\n /// The rib kind restricts certain accesses,\n /// e.g. to a `Res::Local` of an outer item.\n #[derive(Copy, Clone, Debug)]\n@@ -1109,7 +1119,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     fn resolve_params(&mut self, params: &[Param]) {\n-        let mut bindings = smallvec![(false, Default::default())];\n+        let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n         for Param { pat, ty, .. } in params {\n             self.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n             self.visit_ty(ty);\n@@ -1255,14 +1265,15 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     /// Arising from `source`, resolve a top level pattern.\n     fn resolve_pattern_top(&mut self, pat: &Pat, pat_src: PatternSource) {\n-        self.resolve_pattern(pat, pat_src, &mut smallvec![(false, Default::default())]);\n+        let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n+        self.resolve_pattern(pat, pat_src, &mut bindings);\n     }\n \n     fn resolve_pattern(\n         &mut self,\n         pat: &Pat,\n         pat_src: PatternSource,\n-        bindings: &mut SmallVec<[(bool, FxHashSet<Ident>); 1]>,\n+        bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n     ) {\n         self.resolve_pattern_inner(pat, pat_src, bindings);\n         // This has to happen *after* we determine which pat_idents are variants:\n@@ -1276,15 +1287,15 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     ///\n     /// A stack of sets of bindings accumulated.\n     ///\n-    /// In each set, `false` denotes that a found binding in it should be interpreted as\n-    /// re-binding an already bound binding. This results in an error. Meanwhile, `true`\n-    /// denotes that a found binding in the set should result in reusing this binding\n-    /// rather  than creating a fresh one. In other words, `false` and `true` correspond\n-    /// to product (e.g., `(a, b)`) and sum/or contexts (e.g., `p_0 | ... | p_i`) respectively.\n+    /// In each set, `PatBoundCtx::Product` denotes that a found binding in it should\n+    /// be interpreted as re-binding an already bound binding. This results in an error.\n+    /// Meanwhile, `PatBound::Or` denotes that a found binding in the set should result\n+    /// in reusing this binding rather than creating a fresh one.\n     ///\n-    /// When called at the top level, the stack should have a single element with `false`.\n-    /// Otherwise, pushing to the stack happens as or-patterns are encountered and the\n-    /// context needs to be switched to `true` and then `false` for each `p_i.\n+    /// When called at the top level, the stack must have a single element\n+    /// with `PatBound::Product`. Otherwise, pushing to the stack happens as\n+    /// or-patterns (`p_0 | ... | p_n`) are encountered and the context needs\n+    /// to be switched to `PatBoundCtx::Or` and then `PatBoundCtx::Product` for each `p_i`.\n     /// When each `p_i` has been dealt with, the top set is merged with its parent.\n     /// When a whole or-pattern has been dealt with, the thing happens.\n     ///\n@@ -1293,7 +1304,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         &mut self,\n         pat: &Pat,\n         pat_src: PatternSource,\n-        bindings: &mut SmallVec<[(bool, FxHashSet<Ident>); 1]>,\n+        bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n     ) {\n         // Visit all direct subpatterns of this pattern.\n         pat.walk(&mut |pat| {\n@@ -1317,15 +1328,15 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                     self.smart_resolve_path(pat.id, None, path, PathSource::Struct);\n                 }\n                 PatKind::Or(ref ps) => {\n-                    // Add a new set of bindings to the stack. `true` here records that when a\n+                    // Add a new set of bindings to the stack. `Or` here records that when a\n                     // binding already exists in this set, it should not result in an error because\n                     // `V1(a) | V2(a)` must be allowed and are checked for consistency later.\n-                    bindings.push((true, Default::default()));\n+                    bindings.push((PatBoundCtx::Or, Default::default()));\n                     for p in ps {\n                         // Now we need to switch back to a product context so that each\n                         // part of the or-pattern internally rejects already bound names.\n                         // For example, `V1(a) | V2(a, a)` and `V1(a, a) | V2(a)` are bad.\n-                        bindings.push((false, Default::default()));\n+                        bindings.push((PatBoundCtx::Product, Default::default()));\n                         self.resolve_pattern_inner(p, pat_src, bindings);\n                         // Move up the non-overlapping bindings to the or-pattern.\n                         // Existing bindings just get \"merged\".\n@@ -1352,7 +1363,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         ident: Ident,\n         pat_id: NodeId,\n         pat_src: PatternSource,\n-        bindings: &mut SmallVec<[(bool, FxHashSet<Ident>); 1]>,\n+        bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n     ) -> Res {\n         // Add the binding to the local ribs, if it doesn't already exist in the bindings map.\n         // (We must not add it if it's in the bindings map because that breaks the assumptions\n@@ -1366,10 +1377,10 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         for (is_sum, set) in bindings.iter_mut().rev() {\n             match (is_sum, set.get(&ident).cloned()) {\n                 // Already bound in a product pattern, e.g. `(a, a)` which is not allowed.\n-                (false, Some(..)) => already_bound_and = true,\n+                (PatBoundCtx::Product, Some(..)) => already_bound_and = true,\n                 // Already bound in an or-pattern, e.g. `V1(a) | V2(a)`.\n                 // This is *required* for consistency which is checked later.\n-                (true, Some(..)) => already_bound_or = true,\n+                (PatBoundCtx::Or, Some(..)) => already_bound_or = true,\n                 // Not already bound here.\n                 _ => {}\n             }"}]}