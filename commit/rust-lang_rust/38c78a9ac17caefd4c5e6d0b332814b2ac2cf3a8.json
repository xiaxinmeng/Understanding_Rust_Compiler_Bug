{"sha": "38c78a9ac17caefd4c5e6d0b332814b2ac2cf3a8", "node_id": "C_kwDOAAsO6NoAKDM4Yzc4YTlhYzE3Y2FlZmQ0YzVlNmQwYjMzMjgxNGIyYWMyY2YzYTg", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-08T08:48:53Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-11T20:47:31Z"}, "message": "reorder panicking.rs to put main entry points at the top", "tree": {"sha": "04f5f8db6af562e04089e528e77e34761b45636f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04f5f8db6af562e04089e528e77e34761b45636f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38c78a9ac17caefd4c5e6d0b332814b2ac2cf3a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38c78a9ac17caefd4c5e6d0b332814b2ac2cf3a8", "html_url": "https://github.com/rust-lang/rust/commit/38c78a9ac17caefd4c5e6d0b332814b2ac2cf3a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38c78a9ac17caefd4c5e6d0b332814b2ac2cf3a8/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b61e742a394a79cd7fc58bb6b8bf9e502fd2a4cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b61e742a394a79cd7fc58bb6b8bf9e502fd2a4cf", "html_url": "https://github.com/rust-lang/rust/commit/b61e742a394a79cd7fc58bb6b8bf9e502fd2a4cf"}], "stats": {"total": 128, "additions": 67, "deletions": 61}, "files": [{"sha": "a9de7c94e5a11ac25a7d6de036b1134bee3805f9", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 67, "deletions": 61, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/38c78a9ac17caefd4c5e6d0b332814b2ac2cf3a8/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c78a9ac17caefd4c5e6d0b332814b2ac2cf3a8/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=38c78a9ac17caefd4c5e6d0b332814b2ac2cf3a8", "patch": "@@ -29,6 +29,73 @@\n use crate::fmt;\n use crate::panic::{Location, PanicInfo};\n \n+// First we define the two main entry points that all panics go through.\n+// In the end both are just convenience wrappers around `panic_impl`.\n+\n+/// The entry point for panicking with a formatted message.\n+///\n+/// This is designed to reduce the amount of code required at the call\n+/// site as much as possible (so that `panic!()` has as low an impact\n+/// on (e.g.) the inlining of other functions as possible), by moving\n+/// the actual formatting into this shared place.\n+#[cold]\n+// If panic_immediate_abort, inline the abort call,\n+// otherwise avoid inlining because of it is cold path.\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n+#[track_caller]\n+#[lang = \"panic_fmt\"] // needed for const-evaluated panics\n+#[rustc_do_not_const_check] // hooked by const-eval\n+#[rustc_const_unstable(feature = \"core_panic\", issue = \"none\")]\n+pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        super::intrinsics::abort()\n+    }\n+\n+    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n+    // that gets resolved to the `#[panic_handler]` function.\n+    extern \"Rust\" {\n+        #[lang = \"panic_impl\"]\n+        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n+    }\n+\n+    let pi = PanicInfo::internal_constructor(Some(&fmt), Location::caller(), true);\n+\n+    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n+    unsafe { panic_impl(&pi) }\n+}\n+\n+/// Like panic_fmt, but without unwinding and track_caller to reduce the impact on codesize.\n+/// Also just works on `str`, as a `fmt::Arguments` needs more space to be passed.\n+#[cold]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n+#[cfg_attr(not(bootstrap), rustc_nounwind)]\n+#[cfg_attr(bootstrap, rustc_allocator_nounwind)]\n+pub fn panic_str_nounwind(msg: &'static str) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        super::intrinsics::abort()\n+    }\n+\n+    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n+    // that gets resolved to the `#[panic_handler]` function.\n+    extern \"Rust\" {\n+        #[lang = \"panic_impl\"]\n+        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n+    }\n+\n+    // PanicInfo with the `can_unwind` flag set to false forces an abort.\n+    let pieces = [msg];\n+    let fmt = fmt::Arguments::new_v1(&pieces, &[]);\n+    let pi = PanicInfo::internal_constructor(Some(&fmt), Location::caller(), false);\n+\n+    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n+    unsafe { panic_impl(&pi) }\n+}\n+\n+// Next we define a bunch of higher-level wrappers that all bottom out in the two core functions\n+// above.\n+\n /// The underlying implementation of libcore's `panic!` macro when no formatting is used.\n #[cold]\n // never inline unless panic_immediate_abort to avoid code\n@@ -97,67 +164,6 @@ fn panic_no_unwind() -> ! {\n     panic_str_nounwind(\"panic in a function that cannot unwind\")\n }\n \n-/// Like panic_fmt, but without unwinding and track_caller to reduce the impact on codesize.\n-/// Also just works on `str`, as a `fmt::Arguments` needs more space to be passed.\n-#[cold]\n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n-#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-#[cfg_attr(not(bootstrap), rustc_nounwind)]\n-#[cfg_attr(bootstrap, rustc_allocator_nounwind)]\n-pub fn panic_str_nounwind(msg: &'static str) -> ! {\n-    if cfg!(feature = \"panic_immediate_abort\") {\n-        super::intrinsics::abort()\n-    }\n-\n-    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n-    // that gets resolved to the `#[panic_handler]` function.\n-    extern \"Rust\" {\n-        #[lang = \"panic_impl\"]\n-        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n-    }\n-\n-    // PanicInfo with the `can_unwind` flag set to false forces an abort.\n-    let pieces = [msg];\n-    let fmt = fmt::Arguments::new_v1(&pieces, &[]);\n-    let pi = PanicInfo::internal_constructor(Some(&fmt), Location::caller(), false);\n-\n-    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n-    unsafe { panic_impl(&pi) }\n-}\n-\n-/// The entry point for panicking with a formatted message.\n-///\n-/// This is designed to reduce the amount of code required at the call\n-/// site as much as possible (so that `panic!()` has as low an impact\n-/// on (e.g.) the inlining of other functions as possible), by moving\n-/// the actual formatting into this shared place.\n-#[cold]\n-// If panic_immediate_abort, inline the abort call,\n-// otherwise avoid inlining because of it is cold path.\n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n-#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-#[track_caller]\n-#[lang = \"panic_fmt\"] // needed for const-evaluated panics\n-#[rustc_do_not_const_check] // hooked by const-eval\n-#[rustc_const_unstable(feature = \"core_panic\", issue = \"none\")]\n-pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n-    if cfg!(feature = \"panic_immediate_abort\") {\n-        super::intrinsics::abort()\n-    }\n-\n-    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n-    // that gets resolved to the `#[panic_handler]` function.\n-    extern \"Rust\" {\n-        #[lang = \"panic_impl\"]\n-        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n-    }\n-\n-    let pi = PanicInfo::internal_constructor(Some(&fmt), Location::caller(), true);\n-\n-    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n-    unsafe { panic_impl(&pi) }\n-}\n-\n /// This function is used instead of panic_fmt in const eval.\n #[lang = \"const_panic_fmt\"]\n #[rustc_const_unstable(feature = \"core_panic\", issue = \"none\")]"}]}