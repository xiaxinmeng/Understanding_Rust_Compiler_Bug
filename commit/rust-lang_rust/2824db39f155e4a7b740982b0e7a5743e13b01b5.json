{"sha": "2824db39f155e4a7b740982b0e7a5743e13b01b5", "node_id": "C_kwDOAAsO6NoAKDI4MjRkYjM5ZjE1NWU0YTdiNzQwOTgyYjBlN2E1NzQzZTEzYjAxYjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-06T07:38:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-06T07:38:58Z"}, "message": "Auto merge of #109915 - scottmcm:layout-indexvec, r=oli-obk\n\nUse `FieldIdx` in `FieldsShape`\n\nFinally got to the main motivating example from https://github.com/rust-lang/compiler-team/issues/606 :)", "tree": {"sha": "f91e260d50028c5dfecebd43fa1401e69d264381", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f91e260d50028c5dfecebd43fa1401e69d264381"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2824db39f155e4a7b740982b0e7a5743e13b01b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2824db39f155e4a7b740982b0e7a5743e13b01b5", "html_url": "https://github.com/rust-lang/rust/commit/2824db39f155e4a7b740982b0e7a5743e13b01b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2824db39f155e4a7b740982b0e7a5743e13b01b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f6edd3f15f75f0df70027edee2a520820d14217", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f6edd3f15f75f0df70027edee2a520820d14217", "html_url": "https://github.com/rust-lang/rust/commit/7f6edd3f15f75f0df70027edee2a520820d14217"}, {"sha": "21bb8ef24eaf9d1f46d35f188687dfc73d72c204", "url": "https://api.github.com/repos/rust-lang/rust/commits/21bb8ef24eaf9d1f46d35f188687dfc73d72c204", "html_url": "https://github.com/rust-lang/rust/commit/21bb8ef24eaf9d1f46d35f188687dfc73d72c204"}], "stats": {"total": 232, "additions": 132, "deletions": 100}, "files": [{"sha": "c863acde7b03dde231794f4f988539c50f3aed39", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=2824db39f155e4a7b740982b0e7a5743e13b01b5", "patch": "@@ -8,19 +8,6 @@ use rand_xoshiro::Xoshiro128StarStar;\n \n use tracing::debug;\n \n-// Invert a bijective mapping, i.e. `invert(map)[y] = x` if `map[x] = y`.\n-// This is used to go between `memory_index` (source field order to memory order)\n-// and `inverse_memory_index` (memory order to source field order).\n-// See also `FieldsShape::Arbitrary::memory_index` for more details.\n-// FIXME(eddyb) build a better abstraction for permutations, if possible.\n-fn invert_mapping(map: &[u32]) -> Vec<u32> {\n-    let mut inverse = vec![0; map.len()];\n-    for i in 0..map.len() {\n-        inverse[map[i] as usize] = i as u32;\n-    }\n-    inverse\n-}\n-\n pub trait LayoutCalculator {\n     type TargetDataLayoutRef: Borrow<TargetDataLayout>;\n \n@@ -45,8 +32,8 @@ pub trait LayoutCalculator {\n         LayoutS {\n             variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Arbitrary {\n-                offsets: vec![Size::ZERO, b_offset],\n-                memory_index: vec![0, 1],\n+                offsets: [Size::ZERO, b_offset].into(),\n+                memory_index: [0, 1].into(),\n             },\n             abi: Abi::ScalarPair(a, b),\n             largest_niche,\n@@ -58,18 +45,18 @@ pub trait LayoutCalculator {\n     fn univariant(\n         &self,\n         dl: &TargetDataLayout,\n-        fields: &[Layout<'_>],\n+        fields: &IndexSlice<FieldIdx, Layout<'_>>,\n         repr: &ReprOptions,\n         kind: StructKind,\n     ) -> Option<LayoutS> {\n         let pack = repr.pack;\n         let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n-        let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n+        let mut inverse_memory_index: IndexVec<u32, FieldIdx> = fields.indices().collect();\n         let optimize = !repr.inhibit_struct_field_reordering_opt();\n         if optimize {\n             let end =\n                 if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n-            let optimizing = &mut inverse_memory_index[..end];\n+            let optimizing = &mut inverse_memory_index.raw[..end];\n             let effective_field_align = |layout: Layout<'_>| {\n                 if let Some(pack) = pack {\n                     // return the packed alignment in bytes\n@@ -105,7 +92,7 @@ pub trait LayoutCalculator {\n                             // Place ZSTs first to avoid \"interesting offsets\",\n                             // especially with only one or two non-ZST fields.\n                             // Then place largest alignments first, largest niches within an alignment group last\n-                            let f = fields[x as usize];\n+                            let f = fields[x];\n                             let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n                             (!f.0.is_zst(), cmp::Reverse(effective_field_align(f)), niche_size)\n                         });\n@@ -117,7 +104,7 @@ pub trait LayoutCalculator {\n                         // And put the largest niche in an alignment group at the end\n                         // so it can be used as discriminant in jagged enums\n                         optimizing.sort_by_key(|&x| {\n-                            let f = fields[x as usize];\n+                            let f = fields[x];\n                             let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n                             (effective_field_align(f), niche_size)\n                         });\n@@ -135,7 +122,7 @@ pub trait LayoutCalculator {\n         // At the bottom of this function, we invert `inverse_memory_index` to\n         // produce `memory_index` (see `invert_mapping`).\n         let mut sized = true;\n-        let mut offsets = vec![Size::ZERO; fields.len()];\n+        let mut offsets = IndexVec::from_elem(Size::ZERO, &fields);\n         let mut offset = Size::ZERO;\n         let mut largest_niche = None;\n         let mut largest_niche_available = 0;\n@@ -146,7 +133,7 @@ pub trait LayoutCalculator {\n             offset = prefix_size.align_to(prefix_align);\n         }\n         for &i in &inverse_memory_index {\n-            let field = &fields[i as usize];\n+            let field = &fields[i];\n             if !sized {\n                 self.delay_bug(&format!(\n                     \"univariant: field #{} comes after unsized field\",\n@@ -168,7 +155,7 @@ pub trait LayoutCalculator {\n             align = align.max(field_align);\n \n             debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n-            offsets[i as usize] = offset;\n+            offsets[i] = offset;\n \n             if let Some(mut niche) = field.largest_niche() {\n                 let available = niche.available(dl);\n@@ -192,14 +179,18 @@ pub trait LayoutCalculator {\n         // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n         // Field 5 would be the first element, so memory_index is i:\n         // Note: if we didn't optimize, it's already right.\n-        let memory_index =\n-            if optimize { invert_mapping(&inverse_memory_index) } else { inverse_memory_index };\n+        let memory_index = if optimize {\n+            inverse_memory_index.invert_bijective_mapping()\n+        } else {\n+            debug_assert!(inverse_memory_index.iter().copied().eq(fields.indices()));\n+            inverse_memory_index.into_iter().map(FieldIdx::as_u32).collect()\n+        };\n         let size = min_size.align_to(align.abi);\n         let mut abi = Abi::Aggregate { sized };\n         // Unpack newtype ABIs and find scalar pairs.\n         if sized && size.bytes() > 0 {\n             // All other fields must be ZSTs.\n-            let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.0.is_zst());\n+            let mut non_zst_fields = fields.iter_enumerated().filter(|&(_, f)| !f.0.is_zst());\n \n             match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n                 // We have exactly one non-ZST field.\n@@ -238,13 +229,13 @@ pub trait LayoutCalculator {\n                             let pair = self.scalar_pair(a, b);\n                             let pair_offsets = match pair.fields {\n                                 FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n-                                    assert_eq!(memory_index, &[0, 1]);\n+                                    assert_eq!(memory_index.raw, [0, 1]);\n                                     offsets\n                                 }\n                                 _ => panic!(),\n                             };\n-                            if offsets[i] == pair_offsets[0]\n-                                && offsets[j] == pair_offsets[1]\n+                            if offsets[i] == pair_offsets[FieldIdx::from_usize(0)]\n+                                && offsets[j] == pair_offsets[FieldIdx::from_usize(1)]\n                                 && align == pair.align\n                                 && size == pair.size\n                             {\n@@ -289,7 +280,7 @@ pub trait LayoutCalculator {\n     fn layout_of_struct_or_enum(\n         &self,\n         repr: &ReprOptions,\n-        variants: &IndexSlice<VariantIdx, Vec<Layout<'_>>>,\n+        variants: &IndexSlice<VariantIdx, IndexVec<FieldIdx, Layout<'_>>>,\n         is_enum: bool,\n         is_unsafe_cell: bool,\n         scalar_valid_range: (Bound<u128>, Bound<u128>),\n@@ -312,7 +303,7 @@ pub trait LayoutCalculator {\n         // but *not* an encoding of the discriminant (e.g., a tag value).\n         // See issue #49298 for more details on the need to leave space\n         // for non-ZST uninhabited data (mostly partial initialization).\n-        let absent = |fields: &[Layout<'_>]| {\n+        let absent = |fields: &IndexSlice<FieldIdx, Layout<'_>>| {\n             let uninhabited = fields.iter().any(|f| f.abi().is_uninhabited());\n             let is_zst = fields.iter().all(|f| f.0.is_zst());\n             uninhabited && is_zst\n@@ -510,7 +501,7 @@ pub trait LayoutCalculator {\n                 // It'll fit, but we need to make some adjustments.\n                 match layout.fields {\n                     FieldsShape::Arbitrary { ref mut offsets, .. } => {\n-                        for (j, offset) in offsets.iter_mut().enumerate() {\n+                        for (j, offset) in offsets.iter_enumerated_mut() {\n                             if !variants[i][j].0.is_zst() {\n                                 *offset += this_offset;\n                             }\n@@ -577,8 +568,8 @@ pub trait LayoutCalculator {\n                     variants: IndexVec::new(),\n                 },\n                 fields: FieldsShape::Arbitrary {\n-                    offsets: vec![niche_offset],\n-                    memory_index: vec![0],\n+                    offsets: [niche_offset].into(),\n+                    memory_index: [0].into(),\n                 },\n                 abi,\n                 largest_niche,\n@@ -651,7 +642,8 @@ pub trait LayoutCalculator {\n                 st.variants = Variants::Single { index: i };\n                 // Find the first field we can't move later\n                 // to make room for a larger discriminant.\n-                for field in st.fields.index_by_increasing_offset().map(|j| &field_layouts[j]) {\n+                for field_idx in st.fields.index_by_increasing_offset() {\n+                    let field = &field_layouts[FieldIdx::from_usize(field_idx)];\n                     if !field.0.is_zst() || field.align().abi.bytes() != 1 {\n                         start_align = start_align.min(field.align().abi);\n                         break;\n@@ -802,13 +794,13 @@ pub trait LayoutCalculator {\n                 let pair = self.scalar_pair(tag, prim_scalar);\n                 let pair_offsets = match pair.fields {\n                     FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n-                        assert_eq!(memory_index, &[0, 1]);\n+                        assert_eq!(memory_index.raw, [0, 1]);\n                         offsets\n                     }\n                     _ => panic!(),\n                 };\n-                if pair_offsets[0] == Size::ZERO\n-                    && pair_offsets[1] == *offset\n+                if pair_offsets[FieldIdx::from_u32(0)] == Size::ZERO\n+                    && pair_offsets[FieldIdx::from_u32(1)] == *offset\n                     && align == pair.align\n                     && size == pair.size\n                 {\n@@ -844,7 +836,10 @@ pub trait LayoutCalculator {\n                 tag_field: 0,\n                 variants: IndexVec::new(),\n             },\n-            fields: FieldsShape::Arbitrary { offsets: vec![Size::ZERO], memory_index: vec![0] },\n+            fields: FieldsShape::Arbitrary {\n+                offsets: [Size::ZERO].into(),\n+                memory_index: [0].into(),\n+            },\n             largest_niche,\n             abi,\n             align,\n@@ -883,7 +878,7 @@ pub trait LayoutCalculator {\n     fn layout_of_union(\n         &self,\n         repr: &ReprOptions,\n-        variants: &IndexSlice<VariantIdx, Vec<Layout<'_>>>,\n+        variants: &IndexSlice<VariantIdx, IndexVec<FieldIdx, Layout<'_>>>,\n     ) -> Option<LayoutS> {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();"}, {"sha": "da91776ef6722d9a50be8925facc50390b747a65", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=2824db39f155e4a7b740982b0e7a5743e13b01b5", "patch": "@@ -1108,7 +1108,7 @@ pub enum FieldsShape {\n         /// ordered to match the source definition order.\n         /// This vector does not go in increasing order.\n         // FIXME(eddyb) use small vector optimization for the common case.\n-        offsets: Vec<Size>,\n+        offsets: IndexVec<FieldIdx, Size>,\n \n         /// Maps source order field indices to memory order indices,\n         /// depending on how the fields were reordered (if at all).\n@@ -1122,7 +1122,7 @@ pub enum FieldsShape {\n         ///\n         // FIXME(eddyb) build a better abstraction for permutations, if possible.\n         // FIXME(camlorn) also consider small vector optimization here.\n-        memory_index: Vec<u32>,\n+        memory_index: IndexVec<FieldIdx, u32>,\n     },\n }\n \n@@ -1157,7 +1157,7 @@ impl FieldsShape {\n                 assert!(i < count);\n                 stride * i\n             }\n-            FieldsShape::Arbitrary { ref offsets, .. } => offsets[i],\n+            FieldsShape::Arbitrary { ref offsets, .. } => offsets[FieldIdx::from_usize(i)],\n         }\n     }\n \n@@ -1168,28 +1168,27 @@ impl FieldsShape {\n                 unreachable!(\"FieldsShape::memory_index: `Primitive`s have no fields\")\n             }\n             FieldsShape::Union(_) | FieldsShape::Array { .. } => i,\n-            FieldsShape::Arbitrary { ref memory_index, .. } => memory_index[i].try_into().unwrap(),\n+            FieldsShape::Arbitrary { ref memory_index, .. } => {\n+                memory_index[FieldIdx::from_usize(i)].try_into().unwrap()\n+            }\n         }\n     }\n \n     /// Gets source indices of the fields by increasing offsets.\n     #[inline]\n     pub fn index_by_increasing_offset<'a>(&'a self) -> impl Iterator<Item = usize> + 'a {\n         let mut inverse_small = [0u8; 64];\n-        let mut inverse_big = vec![];\n+        let mut inverse_big = IndexVec::new();\n         let use_small = self.count() <= inverse_small.len();\n \n         // We have to write this logic twice in order to keep the array small.\n         if let FieldsShape::Arbitrary { ref memory_index, .. } = *self {\n             if use_small {\n-                for i in 0..self.count() {\n-                    inverse_small[memory_index[i] as usize] = i as u8;\n+                for (field_idx, &mem_idx) in memory_index.iter_enumerated() {\n+                    inverse_small[mem_idx as usize] = field_idx.as_u32() as u8;\n                 }\n             } else {\n-                inverse_big = vec![0; self.count()];\n-                for i in 0..self.count() {\n-                    inverse_big[memory_index[i] as usize] = i as u32;\n-                }\n+                inverse_big = memory_index.invert_bijective_mapping();\n             }\n         }\n \n@@ -1199,7 +1198,7 @@ impl FieldsShape {\n                 if use_small {\n                     inverse_small[i] as usize\n                 } else {\n-                    inverse_big[i] as usize\n+                    inverse_big[i as u32].as_usize()\n                 }\n             }\n         })"}, {"sha": "009602382dd07b42cbb98247d07da8ced5bb50ef", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=2824db39f155e4a7b740982b0e7a5743e13b01b5", "patch": "@@ -24,6 +24,7 @@ pub trait Idx: Copy + 'static + Eq + PartialEq + Debug + Hash {\n     }\n \n     #[inline]\n+    #[must_use = \"Use `increment_by` if you wanted to update the index in-place\"]\n     fn plus(self, amount: usize) -> Self {\n         Self::new(self.index() + amount)\n     }\n@@ -294,6 +295,11 @@ impl<I: Idx, T: Clone> ToOwned for IndexSlice<I, T> {\n }\n \n impl<I: Idx, T> IndexSlice<I, T> {\n+    #[inline]\n+    pub fn empty() -> &'static Self {\n+        Default::default()\n+    }\n+\n     #[inline]\n     pub fn from_raw(raw: &[T]) -> &Self {\n         let ptr: *const [T] = raw;\n@@ -409,6 +415,36 @@ impl<I: Idx, T> IndexSlice<I, T> {\n     }\n }\n \n+impl<I: Idx, J: Idx> IndexSlice<I, J> {\n+    /// Invert a bijective mapping, i.e. `invert(map)[y] = x` if `map[x] = y`,\n+    /// assuming the values in `self` are a permutation of `0..self.len()`.\n+    ///\n+    /// This is used to go between `memory_index` (source field order to memory order)\n+    /// and `inverse_memory_index` (memory order to source field order).\n+    /// See also `FieldsShape::Arbitrary::memory_index` for more details.\n+    // FIXME(eddyb) build a better abstraction for permutations, if possible.\n+    pub fn invert_bijective_mapping(&self) -> IndexVec<J, I> {\n+        debug_assert_eq!(\n+            self.iter().map(|x| x.index() as u128).sum::<u128>(),\n+            (0..self.len() as u128).sum::<u128>(),\n+            \"The values aren't 0..N in input {self:?}\",\n+        );\n+\n+        let mut inverse = IndexVec::from_elem_n(Idx::new(0), self.len());\n+        for (i1, &i2) in self.iter_enumerated() {\n+            inverse[i2] = i1;\n+        }\n+\n+        debug_assert_eq!(\n+            inverse.iter().map(|x| x.index() as u128).sum::<u128>(),\n+            (0..inverse.len() as u128).sum::<u128>(),\n+            \"The values aren't 0..N in result {self:?}\",\n+        );\n+\n+        inverse\n+    }\n+}\n+\n /// `IndexVec` is often used as a map, so it provides some map-like APIs.\n impl<I: Idx, T> IndexVec<I, Option<T>> {\n     #[inline]\n@@ -513,6 +549,13 @@ impl<I: Idx, T> FromIterator<T> for IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T, const N: usize> From<[T; N]> for IndexVec<I, T> {\n+    #[inline]\n+    fn from(array: [T; N]) -> Self {\n+        IndexVec::from_raw(array.into())\n+    }\n+}\n+\n impl<I: Idx, T> IntoIterator for IndexVec<I, T> {\n     type Item = T;\n     type IntoIter = vec::IntoIter<T>;"}, {"sha": "8af9acfadde900b529b54a2e54f05db001d6ce13", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=2824db39f155e4a7b740982b0e7a5743e13b01b5", "patch": "@@ -5,6 +5,7 @@ use crate::ty::{self, ReprOptions, Ty, TyCtxt, TypeVisitableExt};\n use rustc_errors::{DiagnosticBuilder, Handler, IntoDiagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_index::vec::IndexVec;\n use rustc_session::config::OptLevel;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -635,7 +636,7 @@ where\n                     variants: Variants::Single { index: variant_index },\n                     fields: match NonZeroUsize::new(fields) {\n                         Some(fields) => FieldsShape::Union(fields),\n-                        None => FieldsShape::Arbitrary { offsets: vec![], memory_index: vec![] },\n+                        None => FieldsShape::Arbitrary { offsets: IndexVec::new(), memory_index: IndexVec::new() },\n                     },\n                     abi: Abi::Uninhabited,\n                     largest_niche: None,"}, {"sha": "8f29066b6e2d0bdc58f40aa119f33d2637104bb5", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=2824db39f155e4a7b740982b0e7a5743e13b01b5", "patch": "@@ -287,7 +287,7 @@ impl<'tcx> TransformVisitor<'tcx> {\n         statements.push(Statement {\n             kind: StatementKind::Assign(Box::new((\n                 Place::return_place(),\n-                Rvalue::Aggregate(Box::new(kind), IndexVec::from_iter([val])),\n+                Rvalue::Aggregate(Box::new(kind), [val].into()),\n             ))),\n             source_info,\n         });"}, {"sha": "d4420ec88db95225548dc975018cfc6b945bb20b", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 39, "deletions": 46, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=2824db39f155e4a7b740982b0e7a5743e13b01b5", "patch": "@@ -1,7 +1,7 @@\n use hir::def_id::DefId;\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::mir::{GeneratorLayout, GeneratorSavedLocal};\n use rustc_middle::ty::layout::{\n     IntegerExt, LayoutCx, LayoutError, LayoutOf, TyAndLayout, MAX_SIMD_LANES,\n@@ -62,23 +62,10 @@ fn layout_of<'tcx>(\n     Ok(layout)\n }\n \n-// Invert a bijective mapping, i.e. `invert(map)[y] = x` if `map[x] = y`.\n-// This is used to go between `memory_index` (source field order to memory order)\n-// and `inverse_memory_index` (memory order to source field order).\n-// See also `FieldsShape::Arbitrary::memory_index` for more details.\n-// FIXME(eddyb) build a better abstraction for permutations, if possible.\n-fn invert_mapping(map: &[u32]) -> Vec<u32> {\n-    let mut inverse = vec![0; map.len()];\n-    for i in 0..map.len() {\n-        inverse[map[i] as usize] = i as u32;\n-    }\n-    inverse\n-}\n-\n fn univariant_uninterned<'tcx>(\n     cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n     ty: Ty<'tcx>,\n-    fields: &[Layout<'_>],\n+    fields: &IndexSlice<FieldIdx, Layout<'_>>,\n     repr: &ReprOptions,\n     kind: StructKind,\n ) -> Result<LayoutS, LayoutError<'tcx>> {\n@@ -106,7 +93,7 @@ fn layout_of_uncached<'tcx>(\n     };\n     let scalar = |value: Primitive| tcx.mk_layout(LayoutS::scalar(cx, scalar_unit(value)));\n \n-    let univariant = |fields: &[Layout<'_>], repr: &ReprOptions, kind| {\n+    let univariant = |fields: &IndexSlice<FieldIdx, Layout<'_>>, repr: &ReprOptions, kind| {\n         Ok(tcx.mk_layout(univariant_uninterned(cx, ty, fields, repr, kind)?))\n     };\n     debug_assert!(!ty.has_non_region_infer());\n@@ -256,12 +243,14 @@ fn layout_of_uncached<'tcx>(\n         }),\n \n         // Odd unit types.\n-        ty::FnDef(..) => univariant(&[], &ReprOptions::default(), StructKind::AlwaysSized)?,\n+        ty::FnDef(..) => {\n+            univariant(IndexSlice::empty(), &ReprOptions::default(), StructKind::AlwaysSized)?\n+        }\n         ty::Dynamic(_, _, ty::Dyn) | ty::Foreign(..) => {\n             let mut unit = univariant_uninterned(\n                 cx,\n                 ty,\n-                &[],\n+                IndexSlice::empty(),\n                 &ReprOptions::default(),\n                 StructKind::AlwaysSized,\n             )?;\n@@ -277,7 +266,7 @@ fn layout_of_uncached<'tcx>(\n         ty::Closure(_, ref substs) => {\n             let tys = substs.as_closure().upvar_tys();\n             univariant(\n-                &tys.map(|ty| Ok(cx.layout_of(ty)?.layout)).collect::<Result<Vec<_>, _>>()?,\n+                &tys.map(|ty| Ok(cx.layout_of(ty)?.layout)).try_collect::<IndexVec<_, _>>()?,\n                 &ReprOptions::default(),\n                 StructKind::AlwaysSized,\n             )?\n@@ -288,7 +277,7 @@ fn layout_of_uncached<'tcx>(\n                 if tys.len() == 0 { StructKind::AlwaysSized } else { StructKind::MaybeUnsized };\n \n             univariant(\n-                &tys.iter().map(|k| Ok(cx.layout_of(k)?.layout)).collect::<Result<Vec<_>, _>>()?,\n+                &tys.iter().map(|k| Ok(cx.layout_of(k)?.layout)).try_collect::<IndexVec<_, _>>()?,\n                 &ReprOptions::default(),\n                 kind,\n             )?\n@@ -393,7 +382,7 @@ fn layout_of_uncached<'tcx>(\n \n             // Compute the placement of the vector fields:\n             let fields = if is_array {\n-                FieldsShape::Arbitrary { offsets: vec![Size::ZERO], memory_index: vec![0] }\n+                FieldsShape::Arbitrary { offsets: [Size::ZERO].into(), memory_index: [0].into() }\n             } else {\n                 FieldsShape::Array { stride: e_ly.size, count: e_len }\n             };\n@@ -418,9 +407,9 @@ fn layout_of_uncached<'tcx>(\n                     v.fields\n                         .iter()\n                         .map(|field| Ok(cx.layout_of(field.ty(tcx, substs))?.layout))\n-                        .collect::<Result<Vec<_>, _>>()\n+                        .try_collect::<IndexVec<_, _>>()\n                 })\n-                .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+                .try_collect::<IndexVec<VariantIdx, _>>()?;\n \n             if def.is_union() {\n                 if def.repr().pack.is_some() && def.repr().align.is_some() {\n@@ -492,8 +481,7 @@ fn layout_of_uncached<'tcx>(\n enum SavedLocalEligibility {\n     Unassigned,\n     Assigned(VariantIdx),\n-    // FIXME: Use newtype_index so we aren't wasting bytes\n-    Ineligible(Option<u32>),\n+    Ineligible(Option<FieldIdx>),\n }\n \n // When laying out generators, we divide our saved local fields into two\n@@ -605,7 +593,7 @@ fn generator_saved_local_eligibility(\n     // Write down the order of our locals that will be promoted to the prefix.\n     {\n         for (idx, local) in ineligible_locals.iter().enumerate() {\n-            assignments[local] = Ineligible(Some(idx as u32));\n+            assignments[local] = Ineligible(Some(FieldIdx::from_usize(idx)));\n         }\n     }\n     debug!(\"generator saved local assignments: {:?}\", assignments);\n@@ -654,7 +642,7 @@ fn generator_layout<'tcx>(\n         .map(|ty| Ok(cx.layout_of(ty)?.layout))\n         .chain(iter::once(Ok(tag_layout)))\n         .chain(promoted_layouts)\n-        .collect::<Result<Vec<_>, _>>()?;\n+        .try_collect::<IndexVec<_, _>>()?;\n     let prefix = univariant_uninterned(\n         cx,\n         ty,\n@@ -672,26 +660,28 @@ fn generator_layout<'tcx>(\n     debug!(\"prefix = {:#?}\", prefix);\n     let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields {\n         FieldsShape::Arbitrary { mut offsets, memory_index } => {\n-            let mut inverse_memory_index = invert_mapping(&memory_index);\n+            let mut inverse_memory_index = memory_index.invert_bijective_mapping();\n \n             // \"a\" (`0..b_start`) and \"b\" (`b_start..`) correspond to\n             // \"outer\" and \"promoted\" fields respectively.\n-            let b_start = (tag_index + 1) as u32;\n-            let offsets_b = offsets.split_off(b_start as usize);\n+            let b_start = FieldIdx::from_usize(tag_index + 1);\n+            let offsets_b = IndexVec::from_raw(offsets.raw.split_off(b_start.as_usize()));\n             let offsets_a = offsets;\n \n             // Disentangle the \"a\" and \"b\" components of `inverse_memory_index`\n             // by preserving the order but keeping only one disjoint \"half\" each.\n             // FIXME(eddyb) build a better abstraction for permutations, if possible.\n-            let inverse_memory_index_b: Vec<_> =\n-                inverse_memory_index.iter().filter_map(|&i| i.checked_sub(b_start)).collect();\n-            inverse_memory_index.retain(|&i| i < b_start);\n+            let inverse_memory_index_b: IndexVec<u32, FieldIdx> = inverse_memory_index\n+                .iter()\n+                .filter_map(|&i| i.as_u32().checked_sub(b_start.as_u32()).map(FieldIdx::from_u32))\n+                .collect();\n+            inverse_memory_index.raw.retain(|&i| i < b_start);\n             let inverse_memory_index_a = inverse_memory_index;\n \n             // Since `inverse_memory_index_{a,b}` each only refer to their\n             // respective fields, they can be safely inverted\n-            let memory_index_a = invert_mapping(&inverse_memory_index_a);\n-            let memory_index_b = invert_mapping(&inverse_memory_index_b);\n+            let memory_index_a = inverse_memory_index_a.invert_bijective_mapping();\n+            let memory_index_b = inverse_memory_index_b.invert_bijective_mapping();\n \n             let outer_fields =\n                 FieldsShape::Arbitrary { offsets: offsets_a, memory_index: memory_index_a };\n@@ -722,7 +712,7 @@ fn generator_layout<'tcx>(\n                 ty,\n                 &variant_only_tys\n                     .map(|ty| Ok(cx.layout_of(ty)?.layout))\n-                    .collect::<Result<Vec<_>, _>>()?,\n+                    .try_collect::<IndexVec<_, _>>()?,\n                 &ReprOptions::default(),\n                 StructKind::Prefixed(prefix_size, prefix_align.abi),\n             )?;\n@@ -741,13 +731,16 @@ fn generator_layout<'tcx>(\n             // promoted fields were being used, but leave the elements not in the\n             // subset as `INVALID_FIELD_IDX`, which we can filter out later to\n             // obtain a valid (bijective) mapping.\n-            const INVALID_FIELD_IDX: u32 = !0;\n-            let mut combined_inverse_memory_index =\n-                vec![INVALID_FIELD_IDX; promoted_memory_index.len() + memory_index.len()];\n+            const INVALID_FIELD_IDX: FieldIdx = FieldIdx::MAX;\n+            debug_assert!(variant_fields.next_index() <= INVALID_FIELD_IDX);\n+\n+            let mut combined_inverse_memory_index = IndexVec::from_elem_n(\n+                INVALID_FIELD_IDX,\n+                promoted_memory_index.len() + memory_index.len(),\n+            );\n             let mut offsets_and_memory_index = iter::zip(offsets, memory_index);\n             let combined_offsets = variant_fields\n-                .iter()\n-                .enumerate()\n+                .iter_enumerated()\n                 .map(|(i, local)| {\n                     let (offset, memory_index) = match assignments[*local] {\n                         Unassigned => bug!(),\n@@ -756,19 +749,19 @@ fn generator_layout<'tcx>(\n                             (offset, promoted_memory_index.len() as u32 + memory_index)\n                         }\n                         Ineligible(field_idx) => {\n-                            let field_idx = field_idx.unwrap() as usize;\n+                            let field_idx = field_idx.unwrap();\n                             (promoted_offsets[field_idx], promoted_memory_index[field_idx])\n                         }\n                     };\n-                    combined_inverse_memory_index[memory_index as usize] = i as u32;\n+                    combined_inverse_memory_index[memory_index] = i;\n                     offset\n                 })\n                 .collect();\n \n             // Remove the unused slots and invert the mapping to obtain the\n             // combined `memory_index` (also see previous comment).\n-            combined_inverse_memory_index.retain(|&i| i != INVALID_FIELD_IDX);\n-            let combined_memory_index = invert_mapping(&combined_inverse_memory_index);\n+            combined_inverse_memory_index.raw.retain(|&i| i != INVALID_FIELD_IDX);\n+            let combined_memory_index = combined_inverse_memory_index.invert_bijective_mapping();\n \n             variant.fields = FieldsShape::Arbitrary {\n                 offsets: combined_offsets,\n@@ -779,7 +772,7 @@ fn generator_layout<'tcx>(\n             align = align.max(variant.align);\n             Ok(variant)\n         })\n-        .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+        .try_collect::<IndexVec<VariantIdx, _>>()?;\n \n     size = size.align_to(align.abi);\n "}, {"sha": "9195964a2f36616c98617170c3b554189b6a8da4", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2824db39f155e4a7b740982b0e7a5743e13b01b5/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=2824db39f155e4a7b740982b0e7a5743e13b01b5", "patch": "@@ -5,6 +5,7 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(iterator_try_collect)]\n #![feature(let_chains)]\n #![feature(never_type)]\n #![feature(box_patterns)]"}]}