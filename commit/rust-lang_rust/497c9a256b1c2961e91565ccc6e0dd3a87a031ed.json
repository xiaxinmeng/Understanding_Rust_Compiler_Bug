{"sha": "497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5N2M5YTI1NmIxYzI5NjFlOTE1NjVjY2M2ZTBkZDNhODdhMDMxZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-12T14:42:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-12T14:42:37Z"}, "message": "Auto merge of #80517 - wabain:issue-77880-infer-error-try-conversion-msg, r=davidtwco\n\nEnhance type inference errors involving the `?` operator\n\nThis patch adds a special-cased note on type inference errors when the error span points to a `?` return. It also makes the primary label for such errors \"cannot infer type of `?` error\" in cases where before we would have only said \"cannot infer type\".\n\nOne beneficiary of this change is async blocks, where we can't explicitly annotate the return type and so may not generate any other help (#77880); this lets us at least print the error type we're converting from and anything we know about the type we can't fully infer. More generally, it signposts that an implicit conversion is happening that may have impeded type inference the user was expecting. We already do something similar for [mismatched type errors](https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/src/test/ui/try-block/try-block-bad-type.stderr#L7).\n\nThe check for a relevant `?` operator is built into the existing HIR traversal which looks for places that could be annotated to resolve the error. That means we could identify `?` uses anywhere in the function that output the type we can't infer, but this patch just sticks to adding the note if the primary span given for the error has the operator; if there are other expressions where the type occurs and one of them is selected for the error instead, it's more likely that the `?` operator's implicit conversion isn't the sole cause of the inference failure and that adding an additional diagnostic would just be noise. I added a ui test for one such case.\n\nThe data about the `?` conversion is passed around in a `UseDiagnostic` enum that in theory could be used to add more of this kind of note in the future. It was also just easier to pass around than something with a more specific name. There are some follow-up refactoring commits for the code that generates the error label, which was already pretty involved and made a bit more complicated by this change.", "tree": {"sha": "c8c21ff5de2701b2668fd6e790836bdcad3cce5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8c21ff5de2701b2668fd6e790836bdcad3cce5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "html_url": "https://github.com/rust-lang/rust/commit/497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc9944fe84a683f0450c0921a935456e51b1c3ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc9944fe84a683f0450c0921a935456e51b1c3ae", "html_url": "https://github.com/rust-lang/rust/commit/fc9944fe84a683f0450c0921a935456e51b1c3ae"}, {"sha": "d46c3e3411b4971e31c9ead8126cc95114388b3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d46c3e3411b4971e31c9ead8126cc95114388b3b", "html_url": "https://github.com/rust-lang/rust/commit/d46c3e3411b4971e31c9ead8126cc95114388b3b"}], "stats": {"total": 460, "additions": 292, "deletions": 168}, "files": [{"sha": "7b0a91986b3a3382f462aa252beb35cefc7216e6", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "patch": "@@ -69,7 +69,7 @@ use rustc_middle::ty::{\n     subst::{Subst, SubstsRef},\n     Region, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_span::{BytePos, DesugaringKind, Pos, Span};\n+use rustc_span::{sym, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::ops::ControlFlow;\n use std::{cmp, fmt};\n@@ -2282,6 +2282,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.note_region_origin(&mut err, &sub_origin);\n         err.emit();\n     }\n+\n+    /// Determine whether an error associated with the given span and definition\n+    /// should be treated as being caused by the implicit `From` conversion\n+    /// within `?` desugaring.\n+    pub fn is_try_conversion(&self, span: Span, trait_def_id: DefId) -> bool {\n+        span.is_desugaring(DesugaringKind::QuestionMark)\n+            && self.tcx.is_diagnostic_item(sym::from_trait, trait_def_id)\n+    }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {"}, {"sha": "aaab89ace0ad9c84afa4633f6b95b171c8481638", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 212, "deletions": 153, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "patch": "@@ -3,13 +3,14 @@ use crate::infer::InferCtxt;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace};\n+use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Body, Expr, ExprKind, FnRetTy, HirId, Local, Pat};\n use rustc_middle::hir::map::Map;\n use rustc_middle::infer::unify_key::ConstVariableOriginKind;\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, DefIdTree, InferConst, Ty};\n+use rustc_middle::ty::{self, DefIdTree, InferConst, Ty, TyCtxt};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n@@ -25,6 +26,7 @@ struct FindHirNodeVisitor<'a, 'tcx> {\n     found_closure: Option<&'tcx Expr<'tcx>>,\n     found_method_call: Option<&'tcx Expr<'tcx>>,\n     found_exact_method_call: Option<&'tcx Expr<'tcx>>,\n+    found_use_diagnostic: Option<UseDiagnostic<'tcx>>,\n }\n \n impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n@@ -39,34 +41,43 @@ impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n             found_closure: None,\n             found_method_call: None,\n             found_exact_method_call: None,\n+            found_use_diagnostic: None,\n         }\n     }\n \n-    fn node_ty_contains_target(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n-        self.infcx\n-            .in_progress_typeck_results\n-            .and_then(|typeck_results| typeck_results.borrow().node_type_opt(hir_id))\n-            .map(|ty| self.infcx.resolve_vars_if_possible(ty))\n-            .filter(|ty| {\n-                ty.walk().any(|inner| {\n-                    inner == self.target\n-                        || match (inner.unpack(), self.target.unpack()) {\n-                            (GenericArgKind::Type(inner_ty), GenericArgKind::Type(target_ty)) => {\n-                                use ty::{Infer, TyVar};\n-                                match (inner_ty.kind(), target_ty.kind()) {\n-                                    (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => self\n-                                        .infcx\n-                                        .inner\n-                                        .borrow_mut()\n-                                        .type_variables()\n-                                        .sub_unified(a_vid, b_vid),\n-                                    _ => false,\n-                                }\n+    fn node_type_opt(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n+        self.infcx.in_progress_typeck_results?.borrow().node_type_opt(hir_id)\n+    }\n+\n+    fn node_ty_contains_target(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n+        self.node_type_opt(hir_id).map(|ty| self.infcx.resolve_vars_if_possible(ty)).filter(|ty| {\n+            ty.walk().any(|inner| {\n+                inner == self.target\n+                    || match (inner.unpack(), self.target.unpack()) {\n+                        (GenericArgKind::Type(inner_ty), GenericArgKind::Type(target_ty)) => {\n+                            use ty::{Infer, TyVar};\n+                            match (inner_ty.kind(), target_ty.kind()) {\n+                                (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => self\n+                                    .infcx\n+                                    .inner\n+                                    .borrow_mut()\n+                                    .type_variables()\n+                                    .sub_unified(a_vid, b_vid),\n+                                _ => false,\n                             }\n-                            _ => false,\n                         }\n-                })\n+                        _ => false,\n+                    }\n             })\n+        })\n+    }\n+\n+    /// Determine whether the expression, assumed to be the callee within a `Call`,\n+    /// corresponds to the `From::from` emitted in desugaring of the `?` operator.\n+    fn is_try_conversion(&self, callee: &Expr<'tcx>) -> bool {\n+        self.infcx\n+            .trait_def_from_hir_fn(callee.hir_id)\n+            .map_or(false, |def_id| self.infcx.is_try_conversion(callee.span, def_id))\n     }\n }\n \n@@ -119,28 +130,94 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n         // are handled specially, but instead they should be handled in `annotate_method_call`,\n         // which currently doesn't work because this evaluates to `false` for const arguments.\n         // See https://github.com/rust-lang/rust/pull/77758 for more details.\n-        if self.node_ty_contains_target(expr.hir_id).is_some() {\n+        if let Some(ty) = self.node_ty_contains_target(expr.hir_id) {\n             match expr.kind {\n                 ExprKind::Closure(..) => self.found_closure = Some(&expr),\n                 ExprKind::MethodCall(..) => self.found_method_call = Some(&expr),\n+\n+                // If the given expression falls within the target span and is a\n+                // `From::from(e)` call emitted during desugaring of the `?` operator,\n+                // extract the types inferred before and after the call\n+                ExprKind::Call(callee, [arg])\n+                    if self.target_span.contains(expr.span)\n+                        && self.found_use_diagnostic.is_none()\n+                        && self.is_try_conversion(callee) =>\n+                {\n+                    self.found_use_diagnostic = self.node_type_opt(arg.hir_id).map(|pre_ty| {\n+                        UseDiagnostic::TryConversion { pre_ty, post_ty: ty, span: callee.span }\n+                    });\n+                }\n                 _ => {}\n             }\n         }\n         intravisit::walk_expr(self, expr);\n     }\n }\n \n+/// An observation about the use site of a type to be emitted as an additional\n+/// note in an inference failure error.\n+enum UseDiagnostic<'tcx> {\n+    /// Records the types inferred before and after `From::from` is called on the\n+    /// error value within the desugaring of the `?` operator.\n+    TryConversion { pre_ty: Ty<'tcx>, post_ty: Ty<'tcx>, span: Span },\n+}\n+\n+impl UseDiagnostic<'_> {\n+    /// Return a descriptor of the value at the use site\n+    fn descr(&self) -> &'static str {\n+        match self {\n+            Self::TryConversion { .. } => \"error for `?` operator\",\n+        }\n+    }\n+\n+    /// Return a descriptor of the type at the use site\n+    fn type_descr(&self) -> &'static str {\n+        match self {\n+            Self::TryConversion { .. } => \"error type for `?` operator\",\n+        }\n+    }\n+\n+    fn applies_to(&self, span: Span) -> bool {\n+        match *self {\n+            // In some cases the span for an inference failure due to try\n+            // conversion contains the antecedent expression as well as the `?`\n+            Self::TryConversion { span: s, .. } => span.contains(s) && span.hi() == s.hi(),\n+        }\n+    }\n+\n+    fn attach_note(&self, err: &mut DiagnosticBuilder<'_>) {\n+        match *self {\n+            Self::TryConversion { pre_ty, post_ty, .. } => {\n+                let intro = \"`?` implicitly converts the error value\";\n+\n+                let msg = match (pre_ty.is_ty_infer(), post_ty.is_ty_infer()) {\n+                    (true, true) => format!(\"{} using the `From` trait\", intro),\n+                    (false, true) => {\n+                        format!(\"{} into a type implementing `From<{}>`\", intro, pre_ty)\n+                    }\n+                    (true, false) => {\n+                        format!(\"{} into `{}` using the `From` trait\", intro, post_ty)\n+                    }\n+                    (false, false) => {\n+                        format!(\n+                            \"{} into `{}` using its implementation of `From<{}>`\",\n+                            intro, post_ty, pre_ty\n+                        )\n+                    }\n+                };\n+\n+                err.note(&msg);\n+            }\n+        }\n+    }\n+}\n+\n /// Suggest giving an appropriate return type to a closure expression.\n fn closure_return_type_suggestion(\n-    span: Span,\n     err: &mut DiagnosticBuilder<'_>,\n     output: &FnRetTy<'_>,\n     body: &Body<'_>,\n-    descr: &str,\n-    name: &str,\n     ret: &str,\n-    parent_name: Option<String>,\n-    parent_descr: Option<&str>,\n ) {\n     let (arrow, post) = match output {\n         FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n@@ -158,10 +235,6 @@ fn closure_return_type_suggestion(\n         suggestion,\n         Applicability::HasPlaceholders,\n     );\n-    err.span_label(\n-        span,\n-        InferCtxt::cannot_infer_msg(\"type\", &name, &descr, parent_name, parent_descr),\n-    );\n }\n \n /// Given a closure signature, return a `String` containing a list of all its argument types.\n@@ -206,9 +279,67 @@ impl Into<rustc_errors::DiagnosticId> for TypeAnnotationNeeded {\n pub struct InferenceDiagnosticsData {\n     pub name: String,\n     pub span: Option<Span>,\n-    pub description: Cow<'static, str>,\n-    pub parent_name: Option<String>,\n-    pub parent_description: Option<&'static str>,\n+    pub kind: UnderspecifiedArgKind,\n+    pub parent: Option<InferenceDiagnosticsParentData>,\n+}\n+\n+/// Data on the parent definition where a generic argument was declared.\n+pub struct InferenceDiagnosticsParentData {\n+    pub prefix: &'static str,\n+    pub name: String,\n+}\n+\n+pub enum UnderspecifiedArgKind {\n+    Type { prefix: Cow<'static, str> },\n+    Const { is_parameter: bool },\n+}\n+\n+impl InferenceDiagnosticsData {\n+    /// Generate a label for a generic argument which can't be inferred. When not\n+    /// much is known about the argument, `use_diag` may be used to describe the\n+    /// labeled value.\n+    fn cannot_infer_msg(&self, use_diag: Option<&UseDiagnostic<'_>>) -> String {\n+        if self.name == \"_\" && matches!(self.kind, UnderspecifiedArgKind::Type { .. }) {\n+            if let Some(use_diag) = use_diag {\n+                return format!(\"cannot infer type of {}\", use_diag.descr());\n+            }\n+\n+            return \"cannot infer type\".to_string();\n+        }\n+\n+        let suffix = match (&self.parent, use_diag) {\n+            (Some(parent), _) => format!(\" declared on the {} `{}`\", parent.prefix, parent.name),\n+            (None, Some(use_diag)) => format!(\" in {}\", use_diag.type_descr()),\n+            (None, None) => String::new(),\n+        };\n+\n+        // For example: \"cannot infer type for type parameter `T`\"\n+        format!(\"cannot infer {} `{}`{}\", self.kind.prefix_string(), self.name, suffix)\n+    }\n+}\n+\n+impl InferenceDiagnosticsParentData {\n+    fn for_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<InferenceDiagnosticsParentData> {\n+        let parent_def_id = tcx.parent(def_id)?;\n+\n+        let parent_name =\n+            tcx.def_key(parent_def_id).disambiguated_data.data.get_opt_name()?.to_string();\n+\n+        Some(InferenceDiagnosticsParentData {\n+            prefix: tcx.def_kind(parent_def_id).descr(parent_def_id),\n+            name: parent_name,\n+        })\n+    }\n+}\n+\n+impl UnderspecifiedArgKind {\n+    fn prefix_string(&self) -> Cow<'static, str> {\n+        match self {\n+            Self::Type { prefix } => format!(\"type for {}\", prefix).into(),\n+            Self::Const { is_parameter: true } => \"the value of const parameter\".into(),\n+            Self::Const { is_parameter: false } => \"the value of the constant\".into(),\n+        }\n+    }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -228,32 +359,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) =\n                         var_origin.kind\n                     {\n-                        let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n-                        let (parent_name, parent_description) =\n-                            if let Some(parent_def_id) = parent_def_id {\n-                                let parent_name = self\n-                                    .tcx\n-                                    .def_key(parent_def_id)\n-                                    .disambiguated_data\n-                                    .data\n-                                    .get_opt_name()\n-                                    .map(|parent_symbol| parent_symbol.to_string());\n-\n-                                (\n-                                    parent_name,\n-                                    Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n-                                )\n-                            } else {\n-                                (None, None)\n-                            };\n-\n                         if name != kw::SelfUpper {\n                             return InferenceDiagnosticsData {\n                                 name: name.to_string(),\n                                 span: Some(var_origin.span),\n-                                description: \"type parameter\".into(),\n-                                parent_name,\n-                                parent_description,\n+                                kind: UnderspecifiedArgKind::Type {\n+                                    prefix: \"type parameter\".into(),\n+                                },\n+                                parent: def_id.and_then(|def_id| {\n+                                    InferenceDiagnosticsParentData::for_def_id(self.tcx, def_id)\n+                                }),\n                             };\n                         }\n                     }\n@@ -268,9 +383,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 InferenceDiagnosticsData {\n                     name: s,\n                     span: None,\n-                    description: ty.prefix_string(),\n-                    parent_name: None,\n-                    parent_description: None,\n+                    kind: UnderspecifiedArgKind::Type { prefix: ty.prefix_string() },\n+                    parent: None,\n                 }\n             }\n             GenericArgKind::Const(ct) => {\n@@ -280,31 +394,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     if let ConstVariableOriginKind::ConstParameterDefinition(name, def_id) =\n                         origin.kind\n                     {\n-                        let parent_def_id = self.tcx.parent(def_id);\n-                        let (parent_name, parent_description) =\n-                            if let Some(parent_def_id) = parent_def_id {\n-                                let parent_name = self\n-                                    .tcx\n-                                    .def_key(parent_def_id)\n-                                    .disambiguated_data\n-                                    .data\n-                                    .get_opt_name()\n-                                    .map(|parent_symbol| parent_symbol.to_string());\n-\n-                                (\n-                                    parent_name,\n-                                    Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n-                                )\n-                            } else {\n-                                (None, None)\n-                            };\n-\n                         return InferenceDiagnosticsData {\n                             name: name.to_string(),\n                             span: Some(origin.span),\n-                            description: \"const parameter\".into(),\n-                            parent_name,\n-                            parent_description,\n+                            kind: UnderspecifiedArgKind::Const { is_parameter: true },\n+                            parent: InferenceDiagnosticsParentData::for_def_id(self.tcx, def_id),\n                         };\n                     }\n \n@@ -319,9 +413,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     InferenceDiagnosticsData {\n                         name: s,\n                         span: Some(origin.span),\n-                        description: \"the constant\".into(),\n-                        parent_name: None,\n-                        parent_description: None,\n+                        kind: UnderspecifiedArgKind::Const { is_parameter: false },\n+                        parent: None,\n                     }\n                 } else {\n                     bug!(\"unexpect const: {:?}\", ct);\n@@ -420,7 +513,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         // When `arg_data.name` corresponds to a type argument, show the path of the full type we're\n         // trying to infer. In the following example, `ty_msg` contains\n-        // \" in `std::result::Result<i32, E>`\":\n+        // \" for `std::result::Result<i32, E>`\":\n         // ```\n         // error[E0282]: type annotations needed for `std::result::Result<i32, E>`\n         //  --> file.rs:L:CC\n@@ -438,6 +531,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             error_code,\n         );\n \n+        let use_diag = local_visitor.found_use_diagnostic.as_ref();\n+        if let Some(use_diag) = use_diag {\n+            if use_diag.applies_to(err_span) {\n+                use_diag.attach_note(&mut err);\n+            }\n+        }\n+\n         let suffix = match local_visitor.found_node_ty {\n             Some(ty) if ty.is_closure() => {\n                 let substs =\n@@ -453,18 +553,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 if let Some((decl, body_id)) = closure_decl_and_body_id {\n                     closure_return_type_suggestion(\n-                        span,\n                         &mut err,\n                         &decl.output,\n                         self.tcx.hir().body(body_id),\n-                        &arg_data.description,\n-                        &arg_data.name,\n                         &ret,\n-                        arg_data.parent_name,\n-                        arg_data.parent_description,\n                     );\n                     // We don't want to give the other suggestions when the problem is the\n                     // closure return type.\n+                    err.span_label(\n+                        span,\n+                        arg_data.cannot_infer_msg(use_diag.filter(|d| d.applies_to(span))),\n+                    );\n                     return err;\n                 }\n \n@@ -601,51 +700,53 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |\n         //   = note: type must be known at this point\n         let span = arg_data.span.unwrap_or(err_span);\n+\n+        // Avoid multiple labels pointing at `span`.\n         if !err\n             .span\n             .span_labels()\n             .iter()\n             .any(|span_label| span_label.label.is_some() && span_label.span == span)\n             && local_visitor.found_arg_pattern.is_none()\n         {\n-            let (kind_str, const_value) = match arg.unpack() {\n-                GenericArgKind::Type(_) => (\"type\", None),\n-                GenericArgKind::Const(_) => (\"the value\", Some(())),\n-                GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n-            };\n-\n             // FIXME(const_generics): we would like to handle const arguments\n             // as part of the normal diagnostics flow below, but there appear to\n             // be subtleties in doing so, so for now we special-case const args\n             // here.\n-            if let Some(suggestion) = const_value\n-                .and_then(|_| arg_data.parent_name.as_ref())\n-                .map(|parent| format!(\"{}::<{}>\", parent, arg_data.name))\n+            if let (UnderspecifiedArgKind::Const { .. }, Some(parent_data)) =\n+                (&arg_data.kind, &arg_data.parent)\n             {\n                 err.span_suggestion_verbose(\n                     span,\n                     \"consider specifying the const argument\",\n-                    suggestion,\n+                    format!(\"{}::<{}>\", parent_data.name, arg_data.name),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n \n-            // Avoid multiple labels pointing at `span`.\n             err.span_label(\n                 span,\n-                InferCtxt::cannot_infer_msg(\n-                    kind_str,\n-                    &arg_data.name,\n-                    &arg_data.description,\n-                    arg_data.parent_name,\n-                    arg_data.parent_description,\n-                ),\n+                arg_data.cannot_infer_msg(use_diag.filter(|d| d.applies_to(span))),\n             );\n         }\n \n         err\n     }\n \n+    fn trait_def_from_hir_fn(&self, hir_id: hir::HirId) -> Option<DefId> {\n+        // The DefId will be the method's trait item ID unless this is an inherent impl\n+        if let Some((DefKind::AssocFn, def_id)) =\n+            self.in_progress_typeck_results?.borrow().type_dependent_def(hir_id)\n+        {\n+            return self\n+                .tcx\n+                .parent(def_id)\n+                .filter(|&parent_def_id| self.tcx.is_trait(parent_def_id));\n+        }\n+\n+        None\n+    }\n+\n     /// If the `FnSig` for the method call can be found and type arguments are identified as\n     /// needed, suggest annotating the call, otherwise point out the resulting type of the call.\n     fn annotate_method_call(\n@@ -708,49 +809,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             \"type inside {} must be known in this context\",\n             kind,\n         );\n-        err.span_label(\n-            span,\n-            InferCtxt::cannot_infer_msg(\n-                \"type\",\n-                &data.name,\n-                &data.description,\n-                data.parent_name,\n-                data.parent_description,\n-            ),\n-        );\n+        err.span_label(span, data.cannot_infer_msg(None));\n         err\n     }\n-\n-    fn cannot_infer_msg(\n-        kind_str: &str,\n-        type_name: &str,\n-        descr: &str,\n-        parent_name: Option<String>,\n-        parent_descr: Option<&str>,\n-    ) -> String {\n-        if type_name == \"_\" {\n-            format!(\"cannot infer {}\", kind_str)\n-        } else {\n-            let parent_desc = if let Some(parent_name) = parent_name {\n-                let parent_type_descr = if let Some(parent_descr) = parent_descr {\n-                    format!(\" the {}\", parent_descr)\n-                } else {\n-                    \"\".into()\n-                };\n-\n-                format!(\" declared on{} `{}`\", parent_type_descr, parent_name)\n-            } else {\n-                \"\".to_string()\n-            };\n-\n-            // FIXME: We really shouldn't be dealing with strings here\n-            // but instead use a sensible enum for cases like this.\n-            let preposition = if \"the value\" == kind_str { \"of\" } else { \"for\" };\n-            // For example: \"cannot infer type for type parameter `T`\"\n-            format!(\n-                \"cannot infer {} {} {} `{}`{}\",\n-                kind_str, preposition, descr, type_name, parent_desc\n-            )\n-        }\n-    }\n }"}, {"sha": "0186d164a4c53f12af08a16d31d83ab1cc66f56b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "patch": "@@ -280,18 +280,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         let OnUnimplementedNote { message, label, note, enclosing_scope } =\n                             self.on_unimplemented_note(trait_ref, obligation);\n                         let have_alt_message = message.is_some() || label.is_some();\n-                        let is_try = self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .span_to_snippet(span)\n-                            .map(|s| &s == \"?\")\n-                            .unwrap_or(false);\n-                        let is_from = self.tcx.get_diagnostic_item(sym::from_trait)\n-                            == Some(trait_ref.def_id());\n+                        let is_try_conversion = self.is_try_conversion(span, trait_ref.def_id());\n                         let is_unsize =\n                             { Some(trait_ref.def_id()) == self.tcx.lang_items().unsize_trait() };\n-                        let (message, note) = if is_try && is_from {\n+                        let (message, note) = if is_try_conversion {\n                             (\n                                 Some(format!(\n                                     \"`?` couldn't convert the error to `{}`\",\n@@ -319,7 +311,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             ))\n                         );\n \n-                        if is_try && is_from {\n+                        if is_try_conversion {\n                             let none_error = self\n                                 .tcx\n                                 .get_diagnostic_item(sym::none_error)"}, {"sha": "2875cef680117215236af8f365ebb5e6f3d31937", "filename": "src/test/ui/inference/cannot-infer-async-enabled-impl-trait-bindings.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr?ref=497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "patch": "@@ -13,7 +13,9 @@ error[E0282]: type annotations needed for `impl Future`\n LL |     let fut = async {\n    |         --- consider giving `fut` the explicit type `impl Future`, with the type parameters specified\n LL |         make_unit()?;\n-   |                    ^ cannot infer type\n+   |                    ^ cannot infer type of error for `?` operator\n+   |\n+   = note: `?` implicitly converts the error value into a type implementing `From<std::io::Error>`\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "282bc13e9e7809afb33daec3acaf86a5caf3d2d7", "filename": "src/test/ui/inference/cannot-infer-async.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr?ref=497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "patch": "@@ -4,7 +4,9 @@ error[E0282]: type annotations needed\n LL |     let fut = async {\n    |         --- consider giving `fut` a type\n LL |         make_unit()?;\n-   |                    ^ cannot infer type\n+   |                    ^ cannot infer type of error for `?` operator\n+   |\n+   = note: `?` implicitly converts the error value into a type implementing `From<std::io::Error>`\n \n error: aborting due to previous error\n "}, {"sha": "a3b957179b1b1540235013a13e119027f3f6332c", "filename": "src/test/ui/inference/cannot-infer-closure-circular.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.rs?ref=497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "patch": "@@ -0,0 +1,14 @@\n+fn main() {\n+    // Below we call the closure with its own return as the argument, unifying\n+    // its inferred input and return types. We want to make sure that the generated\n+    // error handles this gracefully, and in particular doesn't generate an extra\n+    // note about the `?` operator in the closure body, which isn't relevant to\n+    // the inference.\n+    let x = |r| {\n+        //~^ ERROR type annotations needed\n+        let v = r?;\n+        Ok(v)\n+    };\n+\n+    let _ = x(x(Ok(())));\n+}"}, {"sha": "5efb400a4c7a51cb341df2846aca4a2a8dd33a82", "filename": "src/test/ui/inference/cannot-infer-closure-circular.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.stderr?ref=497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed for `std::result::Result<(), E>`\n+  --> $DIR/cannot-infer-closure-circular.rs:7:14\n+   |\n+LL |     let x = |r| {\n+   |              ^ consider giving this closure parameter the explicit type `std::result::Result<(), E>`, with the type parameters specified\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "475ed00d10752c5b6643498a94e5189d3221bb61", "filename": "src/test/ui/inference/cannot-infer-closure.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr?ref=497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "patch": "@@ -2,8 +2,9 @@ error[E0282]: type annotations needed for the closure `fn((), ()) -> std::result\n   --> $DIR/cannot-infer-closure.rs:3:15\n    |\n LL |         Err(a)?;\n-   |               ^ cannot infer type\n+   |               ^ cannot infer type of error for `?` operator\n    |\n+   = note: `?` implicitly converts the error value into a type implementing `From<()>`\n help: give this closure an explicit return type without `_` placeholders\n    |\n LL |     let x = |a: (), b: ()| -> std::result::Result<(), _> {"}, {"sha": "e1058e96cef4b1a8bf6de7ef471be2fbed8a58ab", "filename": "src/test/ui/inference/cannot-infer-partial-try-return.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs?ref=497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "patch": "@@ -0,0 +1,22 @@\n+struct QualifiedError<E>(E);\n+\n+impl<E, T> From<E> for QualifiedError<T>\n+where\n+    E: std::error::Error,\n+    T: From<E>,\n+{\n+    fn from(e: E) -> QualifiedError<T> {\n+        QualifiedError(e.into())\n+    }\n+}\n+\n+fn infallible() -> Result<(), std::convert::Infallible> {\n+    Ok(())\n+}\n+\n+fn main() {\n+    let x = || -> Result<_, QualifiedError<_>> {\n+        infallible()?; //~ERROR type annotations needed\n+        Ok(())\n+    };\n+}"}, {"sha": "a64503fa667c73f5ff7d88c021753bcb7d222269", "filename": "src/test/ui/inference/cannot-infer-partial-try-return.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/497c9a256b1c2961e91565ccc6e0dd3a87a031ed/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr?ref=497c9a256b1c2961e91565ccc6e0dd3a87a031ed", "patch": "@@ -0,0 +1,15 @@\n+error[E0282]: type annotations needed for the closure `fn() -> std::result::Result<(), QualifiedError<_>>`\n+  --> $DIR/cannot-infer-partial-try-return.rs:19:9\n+   |\n+LL |         infallible()?;\n+   |         ^^^^^^^^^^^^^ cannot infer type of error for `?` operator\n+   |\n+   = note: `?` implicitly converts the error value into `QualifiedError<_>` using its implementation of `From<Infallible>`\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let x = || -> std::result::Result<(), QualifiedError<_>> {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}]}