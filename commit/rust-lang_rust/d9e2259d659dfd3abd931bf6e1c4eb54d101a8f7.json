{"sha": "d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZTIyNTlkNjU5ZGZkM2FiZDkzMWJmNmUxYzRlYjU0ZDEwMWE4Zjc=", "commit": {"author": {"name": "Anthony Ramine", "email": "n.oxyde@gmail.com", "date": "2019-02-11T10:58:56Z"}, "committer": {"name": "Anthony Ramine", "email": "n.oxyde@gmail.com", "date": "2019-02-13T11:23:14Z"}, "message": "Relax some Hash bounds on HashMap<K, V, S> and HashSet<T, S>\n\nNotably, hash iterators don't require any trait bounds to be iterated.", "tree": {"sha": "37f99a561be8b18665de5d31c8cb228bb8e91017", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37f99a561be8b18665de5d31c8cb228bb8e91017"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7", "html_url": "https://github.com/rust-lang/rust/commit/d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7/comments", "author": {"login": "nox", "id": 123095, "node_id": "MDQ6VXNlcjEyMzA5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/123095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nox", "html_url": "https://github.com/nox", "followers_url": "https://api.github.com/users/nox/followers", "following_url": "https://api.github.com/users/nox/following{/other_user}", "gists_url": "https://api.github.com/users/nox/gists{/gist_id}", "starred_url": "https://api.github.com/users/nox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nox/subscriptions", "organizations_url": "https://api.github.com/users/nox/orgs", "repos_url": "https://api.github.com/users/nox/repos", "events_url": "https://api.github.com/users/nox/events{/privacy}", "received_events_url": "https://api.github.com/users/nox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nox", "id": 123095, "node_id": "MDQ6VXNlcjEyMzA5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/123095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nox", "html_url": "https://github.com/nox", "followers_url": "https://api.github.com/users/nox/followers", "following_url": "https://api.github.com/users/nox/following{/other_user}", "gists_url": "https://api.github.com/users/nox/gists{/gist_id}", "starred_url": "https://api.github.com/users/nox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nox/subscriptions", "organizations_url": "https://api.github.com/users/nox/orgs", "repos_url": "https://api.github.com/users/nox/repos", "events_url": "https://api.github.com/users/nox/events{/privacy}", "received_events_url": "https://api.github.com/users/nox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccd23b95e5077a89a2ce35d09cbd4141ccc94f58", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd23b95e5077a89a2ce35d09cbd4141ccc94f58", "html_url": "https://github.com/rust-lang/rust/commit/ccd23b95e5077a89a2ce35d09cbd4141ccc94f58"}], "stats": {"total": 718, "additions": 354, "deletions": 364}, "files": [{"sha": "defbc98648f3937741ced5a94ca0b7ad8a559a39", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 229, "deletions": 236, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7", "patch": "@@ -716,6 +716,232 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n     }\n }\n \n+impl<K, V, S> HashMap<K, V, S> {\n+    /// Returns the number of elements the map can hold without reallocating.\n+    ///\n+    /// This number is a lower bound; the `HashMap<K, V>` might be able to hold\n+    /// more, but is guaranteed to be able to hold at least this many.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// let map: HashMap<i32, i32> = HashMap::with_capacity(100);\n+    /// assert!(map.capacity() >= 100);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.resize_policy.capacity(self.raw_capacity())\n+    }\n+\n+    /// Returns the hash map's raw capacity.\n+    #[inline]\n+    fn raw_capacity(&self) -> usize {\n+        self.table.capacity()\n+    }\n+\n+    /// An iterator visiting all keys in arbitrary order.\n+    /// The iterator element type is `&'a K`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for key in map.keys() {\n+    ///     println!(\"{}\", key);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn keys(&self) -> Keys<K, V> {\n+        Keys { inner: self.iter() }\n+    }\n+\n+    /// An iterator visiting all values in arbitrary order.\n+    /// The iterator element type is `&'a V`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for val in map.values() {\n+    ///     println!(\"{}\", val);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn values(&self) -> Values<K, V> {\n+        Values { inner: self.iter() }\n+    }\n+\n+    /// An iterator visiting all values mutably in arbitrary order.\n+    /// The iterator element type is `&'a mut V`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for val in map.values_mut() {\n+    ///     *val = *val + 10;\n+    /// }\n+    ///\n+    /// for val in map.values() {\n+    ///     println!(\"{}\", val);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n+    pub fn values_mut(&mut self) -> ValuesMut<K, V> {\n+        ValuesMut { inner: self.iter_mut() }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order.\n+    /// The iterator element type is `(&'a K, &'a V)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for (key, val) in map.iter() {\n+    ///     println!(\"key: {} val: {}\", key, val);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn iter(&self) -> Iter<K, V> {\n+        Iter { inner: self.table.iter() }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order,\n+    /// with mutable references to the values.\n+    /// The iterator element type is `(&'a K, &'a mut V)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// // Update all values\n+    /// for (_, val) in map.iter_mut() {\n+    ///     *val *= 2;\n+    /// }\n+    ///\n+    /// for (key, val) in &map {\n+    ///     println!(\"key: {} val: {}\", key, val);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n+        IterMut { inner: self.table.iter_mut() }\n+    }\n+\n+    /// Returns the number of elements in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// assert_eq!(a.len(), 0);\n+    /// a.insert(1, \"a\");\n+    /// assert_eq!(a.len(), 1);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn len(&self) -> usize {\n+        self.table.size()\n+    }\n+\n+    /// Returns `true` if the map contains no elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// assert!(a.is_empty());\n+    /// a.insert(1, \"a\");\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+\n+    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n+    /// allocated memory for reuse.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    ///\n+    /// for (k, v) in a.drain().take(1) {\n+    ///     assert!(k == 1 || k == 2);\n+    ///     assert!(v == \"a\" || v == \"b\");\n+    /// }\n+    ///\n+    /// assert!(a.is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"drain\", since = \"1.6.0\")]\n+    pub fn drain(&mut self) -> Drain<K, V> {\n+        Drain { inner: self.table.drain() }\n+    }\n+\n+    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n+    /// for reuse.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.clear();\n+    /// assert!(a.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.drain();\n+    }\n+}\n+\n impl<K, V, S> HashMap<K, V, S>\n     where K: Eq + Hash,\n           S: BuildHasher\n@@ -802,30 +1028,6 @@ impl<K, V, S> HashMap<K, V, S>\n         &self.hash_builder\n     }\n \n-    /// Returns the number of elements the map can hold without reallocating.\n-    ///\n-    /// This number is a lower bound; the `HashMap<K, V>` might be able to hold\n-    /// more, but is guaranteed to be able to hold at least this many.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// let map: HashMap<i32, i32> = HashMap::with_capacity(100);\n-    /// assert!(map.capacity() >= 100);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.resize_policy.capacity(self.raw_capacity())\n-    }\n-\n-    /// Returns the hash map's raw capacity.\n-    #[inline]\n-    fn raw_capacity(&self) -> usize {\n-        self.table.capacity()\n-    }\n-\n     /// Reserves capacity for at least `additional` more elements to be inserted\n     /// in the `HashMap`. The collection may reserve more space to avoid\n     /// frequent reallocations.\n@@ -1048,127 +1250,6 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n     }\n \n-    /// An iterator visiting all keys in arbitrary order.\n-    /// The iterator element type is `&'a K`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for key in map.keys() {\n-    ///     println!(\"{}\", key);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn keys(&self) -> Keys<K, V> {\n-        Keys { inner: self.iter() }\n-    }\n-\n-    /// An iterator visiting all values in arbitrary order.\n-    /// The iterator element type is `&'a V`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for val in map.values() {\n-    ///     println!(\"{}\", val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn values(&self) -> Values<K, V> {\n-        Values { inner: self.iter() }\n-    }\n-\n-    /// An iterator visiting all values mutably in arbitrary order.\n-    /// The iterator element type is `&'a mut V`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for val in map.values_mut() {\n-    ///     *val = *val + 10;\n-    /// }\n-    ///\n-    /// for val in map.values() {\n-    ///     println!(\"{}\", val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n-    pub fn values_mut(&mut self) -> ValuesMut<K, V> {\n-        ValuesMut { inner: self.iter_mut() }\n-    }\n-\n-    /// An iterator visiting all key-value pairs in arbitrary order.\n-    /// The iterator element type is `(&'a K, &'a V)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for (key, val) in map.iter() {\n-    ///     println!(\"key: {} val: {}\", key, val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<K, V> {\n-        Iter { inner: self.table.iter() }\n-    }\n-\n-    /// An iterator visiting all key-value pairs in arbitrary order,\n-    /// with mutable references to the values.\n-    /// The iterator element type is `(&'a K, &'a mut V)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// // Update all values\n-    /// for (_, val) in map.iter_mut() {\n-    ///     *val *= 2;\n-    /// }\n-    ///\n-    /// for (key, val) in &map {\n-    ///     println!(\"key: {} val: {}\", key, val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n-        IterMut { inner: self.table.iter_mut() }\n-    }\n-\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n     ///\n     /// # Examples\n@@ -1197,85 +1278,6 @@ impl<K, V, S> HashMap<K, V, S>\n             .into_entry(key).expect(\"unreachable\")\n     }\n \n-    /// Returns the number of elements in the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// assert_eq!(a.len(), 0);\n-    /// a.insert(1, \"a\");\n-    /// assert_eq!(a.len(), 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize {\n-        self.table.size()\n-    }\n-\n-    /// Returns `true` if the map contains no elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// assert!(a.is_empty());\n-    /// a.insert(1, \"a\");\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n-        self.len() == 0\n-    }\n-\n-    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n-    /// allocated memory for reuse.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.insert(2, \"b\");\n-    ///\n-    /// for (k, v) in a.drain().take(1) {\n-    ///     assert!(k == 1 || k == 2);\n-    ///     assert!(v == \"a\" || v == \"b\");\n-    /// }\n-    ///\n-    /// assert!(a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"drain\", since = \"1.6.0\")]\n-    pub fn drain(&mut self) -> Drain<K, V> {\n-        Drain { inner: self.table.drain() }\n-    }\n-\n-    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n-    /// for reuse.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.clear();\n-    /// assert!(a.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn clear(&mut self) {\n-        self.drain();\n-    }\n-\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n@@ -2379,10 +2381,7 @@ enum VacantEntryState<K, V, M> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          S: BuildHasher\n-{\n+impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S> {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n \n@@ -2392,10 +2391,7 @@ impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          S: BuildHasher\n-{\n+impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S> {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n \n@@ -2405,10 +2401,7 @@ impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S> IntoIterator for HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          S: BuildHasher\n-{\n+impl<K, V, S> IntoIterator for HashMap<K, V, S> {\n     type Item = (K, V);\n     type IntoIter = IntoIter<K, V>;\n "}, {"sha": "5f9b3c1649f04601285c5729820a13939dbfd09c", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 114, "deletions": 118, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7", "patch": "@@ -149,6 +149,118 @@ impl<T: Hash + Eq> HashSet<T, RandomState> {\n     }\n }\n \n+impl<T, S> HashSet<T, S> {\n+    /// Returns the number of elements the set can hold without reallocating.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let set: HashSet<i32> = HashSet::with_capacity(100);\n+    /// assert!(set.capacity() >= 100);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.map.capacity()\n+    }\n+\n+    /// An iterator visiting all elements in arbitrary order.\n+    /// The iterator element type is `&'a T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set = HashSet::new();\n+    /// set.insert(\"a\");\n+    /// set.insert(\"b\");\n+    ///\n+    /// // Will print in an arbitrary order.\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter { iter: self.map.keys() }\n+    }\n+\n+    /// Returns the number of elements in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut v = HashSet::new();\n+    /// assert_eq!(v.len(), 0);\n+    /// v.insert(1);\n+    /// assert_eq!(v.len(), 1);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn len(&self) -> usize {\n+        self.map.len()\n+    }\n+\n+    /// Returns `true` if the set contains no elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut v = HashSet::new();\n+    /// assert!(v.is_empty());\n+    /// v.insert(1);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_empty(&self) -> bool {\n+        self.map.is_empty()\n+    }\n+\n+    /// Clears the set, returning all elements in an iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// assert!(!set.is_empty());\n+    ///\n+    /// // print 1, 2, 3 in an arbitrary order\n+    /// for i in set.drain() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    ///\n+    /// assert!(set.is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"drain\", since = \"1.6.0\")]\n+    pub fn drain(&mut self) -> Drain<T> {\n+        Drain { iter: self.map.drain() }\n+    }\n+\n+    /// Clears the set, removing all values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut v = HashSet::new();\n+    /// v.insert(1);\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn clear(&mut self) {\n+        self.map.clear()\n+    }\n+}\n+\n impl<T, S> HashSet<T, S>\n     where T: Eq + Hash,\n           S: BuildHasher\n@@ -225,21 +337,6 @@ impl<T, S> HashSet<T, S>\n         self.map.hasher()\n     }\n \n-    /// Returns the number of elements the set can hold without reallocating.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let set: HashSet<i32> = HashSet::with_capacity(100);\n-    /// assert!(set.capacity() >= 100);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.map.capacity()\n-    }\n-\n     /// Reserves capacity for at least `additional` more elements to be inserted\n     /// in the `HashSet`. The collection may reserve more space to avoid\n     /// frequent reallocations.\n@@ -310,27 +407,6 @@ impl<T, S> HashSet<T, S>\n         self.map.shrink_to(min_capacity)\n     }\n \n-    /// An iterator visiting all elements in arbitrary order.\n-    /// The iterator element type is `&'a T`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set = HashSet::new();\n-    /// set.insert(\"a\");\n-    /// set.insert(\"b\");\n-    ///\n-    /// // Will print in an arbitrary order.\n-    /// for x in set.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<T> {\n-        Iter { iter: self.map.keys() }\n-    }\n-\n     /// Visits the values representing the difference,\n     /// i.e., the values that are in `self` but not in `other`.\n     ///\n@@ -454,80 +530,6 @@ impl<T, S> HashSet<T, S>\n         }\n     }\n \n-    /// Returns the number of elements in the set.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut v = HashSet::new();\n-    /// assert_eq!(v.len(), 0);\n-    /// v.insert(1);\n-    /// assert_eq!(v.len(), 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize {\n-        self.map.len()\n-    }\n-\n-    /// Returns `true` if the set contains no elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut v = HashSet::new();\n-    /// assert!(v.is_empty());\n-    /// v.insert(1);\n-    /// assert!(!v.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n-        self.map.is_empty()\n-    }\n-\n-    /// Clears the set, returning all elements in an iterator.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n-    /// assert!(!set.is_empty());\n-    ///\n-    /// // print 1, 2, 3 in an arbitrary order\n-    /// for i in set.drain() {\n-    ///     println!(\"{}\", i);\n-    /// }\n-    ///\n-    /// assert!(set.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"drain\", since = \"1.6.0\")]\n-    pub fn drain(&mut self) -> Drain<T> {\n-        Drain { iter: self.map.drain() }\n-    }\n-\n-    /// Clears the set, removing all values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut v = HashSet::new();\n-    /// v.insert(1);\n-    /// v.clear();\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) {\n-        self.map.clear()\n-    }\n-\n     /// Returns `true` if the set contains a value.\n     ///\n     /// The value may be any borrowed form of the set's value type, but\n@@ -1066,10 +1068,7 @@ pub struct Union<'a, T: 'a, S: 'a> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S> IntoIterator for &'a HashSet<T, S>\n-    where T: Eq + Hash,\n-          S: BuildHasher\n-{\n+impl<'a, T, S> IntoIterator for &'a HashSet<T, S> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -1079,10 +1078,7 @@ impl<'a, T, S> IntoIterator for &'a HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S> IntoIterator for HashSet<T, S>\n-    where T: Eq + Hash,\n-          S: BuildHasher\n-{\n+impl<T, S> IntoIterator for HashSet<T, S> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n "}, {"sha": "ba2d503d7fcf1269659b6d8d47b6f7f8e2a7c0d9", "filename": "src/test/ui/issues/issue-35677.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7/src%2Ftest%2Fui%2Fissues%2Fissue-35677.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7/src%2Ftest%2Fui%2Fissues%2Fissue-35677.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35677.rs?ref=d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7", "patch": "@@ -1,6 +1,7 @@\n-use std::collections::HashMap;\n-fn intersect_map<K, V>(this: &mut HashMap<K, V>, other: HashMap<K, V>) -> bool {\n-    this.drain()\n+use std::collections::HashSet;\n+\n+fn is_subset<T>(this: &HashSet<T>, other: &HashSet<T>) -> bool {\n+    this.is_subset(other)\n     //~^ ERROR no method named\n }\n "}, {"sha": "99d99db93f3e3f3db027c0f4b4dfa8e86c33608b", "filename": "src/test/ui/issues/issue-35677.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7/src%2Ftest%2Fui%2Fissues%2Fissue-35677.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7/src%2Ftest%2Fui%2Fissues%2Fissue-35677.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35677.stderr?ref=d9e2259d659dfd3abd931bf6e1c4eb54d101a8f7", "patch": "@@ -1,12 +1,12 @@\n-error[E0599]: no method named `drain` found for type `&mut std::collections::HashMap<K, V>` in the current scope\n-  --> $DIR/issue-35677.rs:3:10\n+error[E0599]: no method named `is_subset` found for type `&std::collections::HashSet<T>` in the current scope\n+  --> $DIR/issue-35677.rs:4:10\n    |\n-LL |     this.drain()\n-   |          ^^^^^\n+LL |     this.is_subset(other)\n+   |          ^^^^^^^^^\n    |\n-   = note: the method `drain` exists but the following trait bounds were not satisfied:\n-           `K : std::cmp::Eq`\n-           `K : std::hash::Hash`\n+   = note: the method `is_subset` exists but the following trait bounds were not satisfied:\n+           `T : std::cmp::Eq`\n+           `T : std::hash::Hash`\n \n error: aborting due to previous error\n "}]}