{"sha": "a21f1b6c2a5734f39a1efe3fa84d6475843d14fe", "node_id": "C_kwDOAAsO6NoAKGEyMWYxYjZjMmE1NzM0ZjM5YTFlZmUzZmE4NGQ2NDc1ODQzZDE0ZmU", "commit": {"author": {"name": "Yacin Tmimi", "email": "yacintmimi@gmail.com", "date": "2021-11-27T22:14:15Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2021-11-27T23:36:18Z"}, "message": "Conditionally compile tests based on CFG_RELEASE_CHANNEL env var\n\nAdds the ``nightly_only_test`` and ``stable_only_test`` attribute macros\nthat prevent or allow certain tests to compile on nightly and stable\nrespectively. This is achieved through conditionally outputting the\ntests TokenStream.\n\nIf CFG_RELEASE_CHANNEL is not set, it's assumed that we're running in a\nnightly environment.\n\nTo mark a test as nightly only:\n\n    #[nightly_only_test]\n    #[test]\n    fn only_run_on_nightly() {\n        ...\n    }\n\nTo mark a test a stable only:\n\n    #[stable_only_test]\n    #[test]\n    fn only_run_on_stable() {\n        ...\n    }", "tree": {"sha": "8142f1b04d7ed510ae84ec838b0546cf2abca992", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8142f1b04d7ed510ae84ec838b0546cf2abca992"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a21f1b6c2a5734f39a1efe3fa84d6475843d14fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a21f1b6c2a5734f39a1efe3fa84d6475843d14fe", "html_url": "https://github.com/rust-lang/rust/commit/a21f1b6c2a5734f39a1efe3fa84d6475843d14fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a21f1b6c2a5734f39a1efe3fa84d6475843d14fe/comments", "author": {"login": "ytmimi", "id": 29028348, "node_id": "MDQ6VXNlcjI5MDI4MzQ4", "avatar_url": "https://avatars.githubusercontent.com/u/29028348?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ytmimi", "html_url": "https://github.com/ytmimi", "followers_url": "https://api.github.com/users/ytmimi/followers", "following_url": "https://api.github.com/users/ytmimi/following{/other_user}", "gists_url": "https://api.github.com/users/ytmimi/gists{/gist_id}", "starred_url": "https://api.github.com/users/ytmimi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ytmimi/subscriptions", "organizations_url": "https://api.github.com/users/ytmimi/orgs", "repos_url": "https://api.github.com/users/ytmimi/repos", "events_url": "https://api.github.com/users/ytmimi/events{/privacy}", "received_events_url": "https://api.github.com/users/ytmimi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67fd9ec3002d269c272f68fa0e34a1cb2ca5fd08", "url": "https://api.github.com/repos/rust-lang/rust/commits/67fd9ec3002d269c272f68fa0e34a1cb2ca5fd08", "html_url": "https://github.com/rust-lang/rust/commit/67fd9ec3002d269c272f68fa0e34a1cb2ca5fd08"}], "stats": {"total": 156, "additions": 88, "deletions": 68}, "files": [{"sha": "513018213192df3625b11f5b87fc88673c00e5cf", "filename": "config_proc_macro/src/lib.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a21f1b6c2a5734f39a1efe3fa84d6475843d14fe/config_proc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21f1b6c2a5734f39a1efe3fa84d6475843d14fe/config_proc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Fsrc%2Flib.rs?ref=a21f1b6c2a5734f39a1efe3fa84d6475843d14fe", "patch": "@@ -8,6 +8,8 @@ mod item_enum;\n mod item_struct;\n mod utils;\n \n+use std::str::FromStr;\n+\n use proc_macro::TokenStream;\n use syn::parse_macro_input;\n \n@@ -23,3 +25,43 @@ pub fn config_type(_args: TokenStream, input: TokenStream) -> TokenStream {\n \n     TokenStream::from(output)\n }\n+\n+/// Used to conditionally output the TokenStream for tests that need to be run on nightly only.\n+///\n+/// ```rust\n+/// #[nightly_only_test]\n+/// #[test]\n+/// fn test_needs_nightly_rustfmt() {\n+///   assert!(true);\n+/// }\n+/// ```\n+#[proc_macro_attribute]\n+pub fn nightly_only_test(_args: TokenStream, input: TokenStream) -> TokenStream {\n+    // if CFG_RELEASE_CHANNEL is not set we default to nightly, hence why the default is true\n+    if option_env!(\"CFG_RELEASE_CHANNEL\").map_or(true, |c| c == \"nightly\" || c == \"dev\") {\n+        input\n+    } else {\n+        // output an empty token stream if CFG_RELEASE_CHANNEL is not set to \"nightly\" or \"dev\"\n+        TokenStream::from_str(\"\").unwrap()\n+    }\n+}\n+\n+/// Used to conditionally output the TokenStream for tests that need to be run on stable only.\n+///\n+/// ```rust\n+/// #[stable_only_test]\n+/// #[test]\n+/// fn test_needs_stable_rustfmt() {\n+///   assert!(true);\n+/// }\n+/// ```\n+#[proc_macro_attribute]\n+pub fn stable_only_test(_args: TokenStream, input: TokenStream) -> TokenStream {\n+    // if CFG_RELEASE_CHANNEL is not set we default to nightly, hence why the default is false\n+    if option_env!(\"CFG_RELEASE_CHANNEL\").map_or(false, |c| c == \"stable\") {\n+        input\n+    } else {\n+        // output an empty token stream if CFG_RELEASE_CHANNEL is not set or is not 'stable'\n+        TokenStream::from_str(\"\").unwrap()\n+    }\n+}"}, {"sha": "5dbe532ac388fee287d48ee200e7d2bed65e8206", "filename": "src/config/mod.rs", "status": "modified", "additions": 36, "deletions": 50, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a21f1b6c2a5734f39a1efe3fa84d6475843d14fe/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21f1b6c2a5734f39a1efe3fa84d6475843d14fe/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=a21f1b6c2a5734f39a1efe3fa84d6475843d14fe", "patch": "@@ -405,6 +405,8 @@ mod test {\n     use super::*;\n     use std::str;\n \n+    use rustfmt_config_proc_macro::{nightly_only_test, stable_only_test};\n+\n     #[allow(dead_code)]\n     mod mock {\n         use super::super::*;\n@@ -525,21 +527,17 @@ mod test {\n         assert!(config.license_template.is_none());\n     }\n \n+    #[nightly_only_test]\n     #[test]\n     fn test_valid_license_template_path() {\n-        if !crate::is_nightly_channel!() {\n-            return;\n-        }\n         let toml = r#\"license_template_path = \"tests/license-template/lt.txt\"\"#;\n         let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n         assert!(config.license_template.is_some());\n     }\n \n+    #[nightly_only_test]\n     #[test]\n     fn test_override_existing_license_with_no_license() {\n-        if !crate::is_nightly_channel!() {\n-            return;\n-        }\n         let toml = r#\"license_template_path = \"tests/license-template/lt.txt\"\"#;\n         let mut config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n         assert!(config.license_template.is_some());\n@@ -634,48 +632,42 @@ make_backup = false\n         assert_eq!(&toml, &default_config);\n     }\n \n-    // FIXME(#2183): these tests cannot be run in parallel because they use env vars.\n-    // #[test]\n-    // fn test_as_not_nightly_channel() {\n-    //     let mut config = Config::default();\n-    //     assert_eq!(config.was_set().unstable_features(), false);\n-    //     config.set().unstable_features(true);\n-    //     assert_eq!(config.was_set().unstable_features(), false);\n-    // }\n-\n-    // #[test]\n-    // fn test_as_nightly_channel() {\n-    //     let v = ::std::env::var(\"CFG_RELEASE_CHANNEL\").unwrap_or(String::from(\"\"));\n-    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", \"nightly\");\n-    //     let mut config = Config::default();\n-    //     config.set().unstable_features(true);\n-    //     assert_eq!(config.was_set().unstable_features(), false);\n-    //     config.set().unstable_features(true);\n-    //     assert_eq!(config.unstable_features(), true);\n-    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", v);\n-    // }\n-\n-    // #[test]\n-    // fn test_unstable_from_toml() {\n-    //     let mut config = Config::from_toml(\"unstable_features = true\").unwrap();\n-    //     assert_eq!(config.was_set().unstable_features(), false);\n-    //     let v = ::std::env::var(\"CFG_RELEASE_CHANNEL\").unwrap_or(String::from(\"\"));\n-    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", \"nightly\");\n-    //     config = Config::from_toml(\"unstable_features = true\").unwrap();\n-    //     assert_eq!(config.was_set().unstable_features(), true);\n-    //     assert_eq!(config.unstable_features(), true);\n-    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", v);\n-    // }\n+    #[stable_only_test]\n+    #[test]\n+    fn test_as_not_nightly_channel() {\n+        let mut config = Config::default();\n+        assert_eq!(config.was_set().unstable_features(), false);\n+        config.set().unstable_features(true);\n+        assert_eq!(config.was_set().unstable_features(), false);\n+    }\n+\n+    #[nightly_only_test]\n+    #[test]\n+    fn test_as_nightly_channel() {\n+        let mut config = Config::default();\n+        config.set().unstable_features(true);\n+        // When we don't set the config from toml or command line options it\n+        // doesn't get marked as set by the user.\n+        assert_eq!(config.was_set().unstable_features(), false);\n+        config.set().unstable_features(true);\n+        assert_eq!(config.unstable_features(), true);\n+    }\n+\n+    #[nightly_only_test]\n+    #[test]\n+    fn test_unstable_from_toml() {\n+        let config = Config::from_toml(\"unstable_features = true\", Path::new(\"\")).unwrap();\n+        assert_eq!(config.was_set().unstable_features(), true);\n+        assert_eq!(config.unstable_features(), true);\n+    }\n \n     #[cfg(test)]\n     mod deprecated_option_merge_imports {\n         use super::*;\n \n+        #[nightly_only_test]\n         #[test]\n         fn test_old_option_set() {\n-            if !crate::is_nightly_channel!() {\n-                return;\n-            }\n             let toml = r#\"\n                 unstable_features = true\n                 merge_imports = true\n@@ -684,11 +676,9 @@ make_backup = false\n             assert_eq!(config.imports_granularity(), ImportGranularity::Crate);\n         }\n \n+        #[nightly_only_test]\n         #[test]\n         fn test_both_set() {\n-            if !crate::is_nightly_channel!() {\n-                return;\n-            }\n             let toml = r#\"\n                 unstable_features = true\n                 merge_imports = true\n@@ -698,11 +688,9 @@ make_backup = false\n             assert_eq!(config.imports_granularity(), ImportGranularity::Preserve);\n         }\n \n+        #[nightly_only_test]\n         #[test]\n         fn test_new_overridden() {\n-            if !crate::is_nightly_channel!() {\n-                return;\n-            }\n             let toml = r#\"\n                 unstable_features = true\n                 merge_imports = true\n@@ -712,11 +700,9 @@ make_backup = false\n             assert_eq!(config.imports_granularity(), ImportGranularity::Preserve);\n         }\n \n+        #[nightly_only_test]\n         #[test]\n         fn test_old_overridden() {\n-            if !crate::is_nightly_channel!() {\n-                return;\n-            }\n             let toml = r#\"\n                 unstable_features = true\n                 imports_granularity = \"Module\""}, {"sha": "dd7c7352686e620eda97ad4411bc43da48aeac84", "filename": "src/syntux/session.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a21f1b6c2a5734f39a1efe3fa84d6475843d14fe/src%2Fsyntux%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21f1b6c2a5734f39a1efe3fa84d6475843d14fe/src%2Fsyntux%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntux%2Fsession.rs?ref=a21f1b6c2a5734f39a1efe3fa84d6475843d14fe", "patch": "@@ -286,10 +286,11 @@ impl LineRangeUtils for ParseSess {\n mod tests {\n     use super::*;\n \n+    use rustfmt_config_proc_macro::nightly_only_test;\n+\n     mod emitter {\n         use super::*;\n         use crate::config::IgnoreList;\n-        use crate::is_nightly_channel;\n         use crate::utils::mk_sp;\n         use rustc_span::{FileName as SourceMapFileName, MultiSpan, RealFileName, DUMMY_SP};\n         use std::path::PathBuf;\n@@ -371,11 +372,9 @@ mod tests {\n             assert_eq!(can_reset_errors.load(Ordering::Acquire), false);\n         }\n \n+        #[nightly_only_test]\n         #[test]\n         fn handles_recoverable_parse_error_in_ignored_file() {\n-            if !is_nightly_channel!() {\n-                return;\n-            }\n             let num_emitted_errors = Lrc::new(AtomicU32::new(0));\n             let can_reset_errors = Lrc::new(AtomicBool::new(false));\n             let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n@@ -398,11 +397,9 @@ mod tests {\n             assert_eq!(can_reset_errors.load(Ordering::Acquire), true);\n         }\n \n+        #[nightly_only_test]\n         #[test]\n         fn handles_recoverable_parse_error_in_non_ignored_file() {\n-            if !is_nightly_channel!() {\n-                return;\n-            }\n             let num_emitted_errors = Lrc::new(AtomicU32::new(0));\n             let can_reset_errors = Lrc::new(AtomicBool::new(false));\n             let source_map = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n@@ -424,11 +421,9 @@ mod tests {\n             assert_eq!(can_reset_errors.load(Ordering::Acquire), false);\n         }\n \n+        #[nightly_only_test]\n         #[test]\n         fn handles_mix_of_recoverable_parse_error() {\n-            if !is_nightly_channel!() {\n-                return;\n-            }\n             let num_emitted_errors = Lrc::new(AtomicU32::new(0));\n             let can_reset_errors = Lrc::new(AtomicBool::new(false));\n             let source_map = Lrc::new(SourceMap::new(FilePathMapping::empty()));"}, {"sha": "cceb28dfea6d7e82e06d3051983cc0a377fca9a2", "filename": "src/test/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a21f1b6c2a5734f39a1efe3fa84d6475843d14fe/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21f1b6c2a5734f39a1efe3fa84d6475843d14fe/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=a21f1b6c2a5734f39a1efe3fa84d6475843d14fe", "patch": "@@ -15,6 +15,8 @@ use crate::rustfmt_diff::{make_diff, print_diff, DiffLine, Mismatch, ModifiedChu\n use crate::source_file;\n use crate::{is_nightly_channel, FormatReport, FormatReportFormatterBuilder, Input, Session};\n \n+use rustfmt_config_proc_macro::nightly_only_test;\n+\n mod configuration_snippet;\n mod mod_resolver;\n mod parser;\n@@ -307,14 +309,11 @@ fn assert_output(source: &Path, expected_filename: &Path) {\n \n // Idempotence tests. Files in tests/target are checked to be unaltered by\n // rustfmt.\n+#[nightly_only_test]\n #[test]\n fn idempotence_tests() {\n     init_log();\n     run_test_with(&TestSetting::default(), || {\n-        // these tests require nightly\n-        if !is_nightly_channel!() {\n-            return;\n-        }\n         // Get all files in the tests/target directory.\n         let files = get_test_files(Path::new(\"tests/target\"), true);\n         let (_reports, count, fails) = check_files(files, &None);\n@@ -332,13 +331,11 @@ fn idempotence_tests() {\n \n // Run rustfmt on itself. This operation must be idempotent. We also check that\n // no warnings are emitted.\n+// Issue-3443: these tests require nightly\n+#[nightly_only_test]\n #[test]\n fn self_tests() {\n     init_log();\n-    // Issue-3443: these tests require nightly\n-    if !is_nightly_channel!() {\n-        return;\n-    }\n     let mut files = get_test_files(Path::new(\"tests\"), false);\n     let bin_directories = vec![\"cargo-fmt\", \"git-rustfmt\", \"bin\", \"format-diff\"];\n     for dir in bin_directories {"}]}