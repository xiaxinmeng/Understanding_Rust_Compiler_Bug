{"sha": "0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MDQ0NjhmZDU0MGI0MzU2YmEyOGJmOWE2ZDI2YjU2YjczZDViM2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-25T19:42:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-25T19:42:41Z"}, "message": "auto merge of #6054 : catamorphism/rust/rustpkg, r=graydon\n\nr? @graydon\r\n\r\nSorry, this pull request is a few different things at once, but I tried to make them separate commits.\r\n\r\nFirst, as before, this should do file searching the way that's described in the doc now.\r\n\r\nSecond, there's also some preliminary work on the install command (really just tests for it).", "tree": {"sha": "e0c941c0ad45bd01d828b60ab1ba1d571517e68c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0c941c0ad45bd01d828b60ab1ba1d571517e68c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "html_url": "https://github.com/rust-lang/rust/commit/0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "html_url": "https://github.com/rust-lang/rust/commit/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3"}, {"sha": "4e2c8f422aec1aef910fdfdac57f5f66a7465355", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e2c8f422aec1aef910fdfdac57f5f66a7465355", "html_url": "https://github.com/rust-lang/rust/commit/4e2c8f422aec1aef910fdfdac57f5f66a7465355"}], "stats": {"total": 565, "additions": 387, "deletions": 178}, "files": [{"sha": "62633837207f93bae4ce8d7ea8d42673f7d21ae9", "filename": "src/libcore/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "patch": "@@ -43,8 +43,6 @@ use vec;\n pub use libc::fclose;\n pub use os::consts::*;\n \n-// FIXME: move these to str perhaps? #2620\n-\n pub fn close(fd: c_int) -> c_int {\n     unsafe {\n         libc::close(fd)\n@@ -79,6 +77,8 @@ pub fn getcwd() -> Path {\n     }\n }\n \n+// FIXME: move these to str perhaps? #2620\n+\n pub fn as_c_charp<T>(s: &str, f: &fn(*c_char) -> T) -> T {\n     str::as_c_str(s, |b| f(b as *c_char))\n }"}, {"sha": "acfbf395e4bcd95267cbab932609de5a2c3de017", "filename": "src/librustpkg/README.txt", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2FREADME.txt?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "patch": "@@ -1,4 +1,24 @@\n-Right now (2013-04-11), only one package works, the branch of rust-sdl at:\n-https://github.com/catamorphism/rust-sdl/tree/new-rustpkg\n+Right now, commands that work are \"build\" and \"clean\".\n \n-and only one command works, \"build\".\n+`rustpkg build` and `rustpkg clean` should work\n+\n+for example:\n+$ cd ~/rust/src/librustpkg/testsuite/pass\n+$ rustpkg build hello-world\n+... some output ...\n+$ rustpkg clean hello-world\n+\n+-------------\n+the following test packages in librustpkg/testsuite/pass:\n+      * hello-world\n+      * install-paths\n+      * simple-lib\n+      * deeply/nested/path\n+      * fancy-lib\n+\n+   It fails on the following test packages:\n+      * external-crate (no support for `extern mod` inference yet)\n+\n+and should fail with proper error messages\n+on all of the test packages in librustpkg/testsuite/fail\n+      * no-inferred-crates"}, {"sha": "35e70af7914c1b972230005c499251d0074f7a94", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "patch": "@@ -11,7 +11,12 @@\n // Useful conditions\n \n pub use core::path::Path;\n+pub use util::PkgId;\n \n condition! {\n     bad_path: (super::Path, ~str) -> super::Path;\n }\n+\n+condition! {\n+    nonexistent_package: (super::PkgId, ~str) -> super::Path;\n+}"}, {"sha": "db036f44a185b557e1cc21d37fbd5ba6c445f796", "filename": "src/librustpkg/context.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Context data structure used by rustpkg\n+\n+use core::hashmap::HashMap;\n+\n+pub struct Ctx {\n+    // I'm not sure what this is for\n+    json: bool,\n+    // Cache of hashes of things already installed\n+    // though I'm not sure why the value is a bool\n+    dep_cache: @mut HashMap<~str, bool>,\n+}"}, {"sha": "a8931e52747d943b209e9e3b12dc2b78ffb0468a", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 116, "deletions": 52, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "patch": "@@ -15,39 +15,43 @@ use core::{os, str};\n use core::option::*;\n use util::PkgId;\n \n-/// Returns the output directory to use.\n-/// Right now is always the default, should\n-/// support changing it.\n-pub fn dest_dir(pkgid: PkgId) -> Path {\n-    default_dest_dir(&pkgid.path)\n+#[deriving(Eq)]\n+pub enum OutputType { Main, Lib, Bench, Test }\n+\n+/// Returns the value of RUST_PATH, as a list\n+/// of Paths. In general this should be read from the\n+/// environment; for now, it's hard-wired to just be \".\"\n+pub fn rust_path() -> ~[Path] {\n+    ~[Path(\".\")]\n }\n \n-/// Returns the default output directory for compilation.\n-/// Creates that directory if it doesn't exist.\n-pub fn default_dest_dir(pkg_dir: &Path) -> Path {\n+/// Creates a directory that is readable, writeable,\n+/// and executable by the user. Returns true iff creation\n+/// succeeded.\n+pub fn make_dir_rwx(p: &Path) -> bool {\n     use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-    use conditions::bad_path::cond;\n \n-    // For now: assumes that pkg_dir exists and is relative\n-    // to the CWD. Change this later when we do path searching.\n-    let rslt = pkg_dir.push(\"build\");\n-    let is_dir = os::path_is_dir(&rslt);\n-    if os::path_exists(&rslt) {\n-        if is_dir {\n-            rslt\n-        }\n-        else {\n-            cond.raise((rslt, ~\"Path names a file that isn't a directory\"))\n-        }\n+    os::make_dir(p, (S_IRUSR | S_IWUSR | S_IXUSR) as i32)\n+}\n+\n+/// Creates a directory that is readable, writeable,\n+/// and executable by the user. Returns true iff creation\n+/// succeeded. Also creates all intermediate subdirectories\n+/// if they don't already exist.\n+pub fn mkdir_recursive(p: &Path) -> bool {\n+    if os::path_is_dir(p) {\n+        return true;\n+    }\n+    let parent = p.dir_path();\n+    debug!(\"mkdir_recursive: parent = %s\",\n+           parent.to_str());\n+    if parent.to_str() == ~\".\"\n+        || parent.to_str() == ~\"/\" { // !!!\n+        // No parent directories to create\n+        os::path_is_dir(&parent) && make_dir_rwx(p)\n     }\n     else {\n-        // Create it\n-        if os::make_dir(&rslt, (S_IRUSR | S_IWUSR | S_IXUSR) as i32) {\n-            rslt\n-        }\n-        else {\n-            cond.raise((rslt, ~\"Could not create directory\"))\n-        }\n+        mkdir_recursive(&parent) && make_dir_rwx(p)\n     }\n }\n \n@@ -69,34 +73,94 @@ pub fn normalize(p: ~Path) -> ~Path {\n     }\n }\n \n+// n.b. So far this only handles local workspaces\n+// n.b. The next three functions ignore the package version right\n+// now. Should fix that.\n+\n+/// True if there's a directory in <workspace> with\n+/// pkgid's short name\n+pub fn workspace_contains_package_id(pkgid: PkgId, workspace: &Path) -> bool {\n+    let pkgpath = workspace.push(\"src\").push(pkgid.path.to_str());\n+    os::path_is_dir(&pkgpath)\n+}\n+\n+/// Return the directory for <pkgid>'s source files in <workspace>.\n+/// Doesn't check that it exists.\n+pub fn pkgid_src_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+    let result = workspace.push(\"src\");\n+    result.push(pkgid.path.to_str())\n+}\n+\n+/// Returns the executable that would be installed for <pkgid>\n+/// in <workspace>\n+pub fn target_executable_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+    let result = workspace.push(\"bin\");\n+    // should use a target-specific subdirectory\n+    mk_output_path(Main, pkgid.path.to_str(), result)\n+}\n+\n+\n+/// Returns the executable that would be installed for <pkgid>\n+/// in <workspace>\n+pub fn target_library_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+    let result = workspace.push(\"lib\");\n+    mk_output_path(Lib, pkgid.path.to_str(), result)\n+}\n+\n+/// Returns the test executable that would be installed for <pkgid>\n+/// in <workspace>\n+pub fn target_test_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+    let result = workspace.push(\"build\");\n+    mk_output_path(Test, pkgid.path.to_str(), result)\n+}\n+\n+/// Returns the bench executable that would be installed for <pkgid>\n+/// in <workspace>\n+pub fn target_bench_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+    let result = workspace.push(\"build\");\n+    mk_output_path(Bench, pkgid.path.to_str(), result)\n+}\n+\n+/// Return the directory for <pkgid>'s build artifacts in <workspace>.\n+/// Creates it if it doesn't exist.\n+pub fn build_pkg_id_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+    use conditions::bad_path::cond;\n+\n+    let mut result = workspace.push(\"build\");\n+    // n.b. Should actually use a target-specific\n+    // subdirectory of build/\n+    result = result.push(normalize(~pkgid.path).to_str());\n+    if os::path_exists(&result) || mkdir_recursive(&result) {\n+        result\n+    }\n+    else {\n+        cond.raise((result, fmt!(\"Could not create directory for package %s\", pkgid.to_str())))\n+    }\n+}\n+\n+/// Return the output file for a given directory name,\n+/// given whether we're building a library and whether we're building tests\n+pub fn mk_output_path(what: OutputType, short_name: ~str, dir: Path) -> Path {\n+    match what {\n+        Lib => dir.push(os::dll_filename(short_name)),\n+        _ => dir.push(fmt!(\"%s%s%s\", short_name,\n+                           if what == Test { ~\"test\" } else { ~\"\" },\n+                           os::EXE_SUFFIX))\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n-    use core::{os, rand};\n-    use core::path::Path;\n-    use path_util::*;\n-    use core::rand::RngUtil;\n-\n-    // Helper function to create a directory name that doesn't exist\n-    pub fn mk_nonexistent(tmpdir: &Path, suffix: &str) -> Path {\n-        let r = rand::rng();\n-        for 1000.times {\n-            let p = tmpdir.push(r.gen_str(16) + suffix);\n-            if !os::path_exists(&p) {\n-                return p;\n-            }\n-        }\n-        fail!(~\"Couldn't compute a non-existent path name; this is worrisome\")\n-    }\n+    use core::os;\n \n     #[test]\n-    fn default_dir_ok() {\n-        let the_path = os::tmpdir();\n-        let substitute_path = Path(\"xyzzy\");\n-        assert!(default_dest_dir(&the_path) == the_path.push(~\"build\"));\n-        let nonexistent_path = mk_nonexistent(&the_path, \"quux\");\n-        let bogus = do ::conditions::bad_path::cond.trap(|_| {\n-            substitute_path\n-        }).in { default_dest_dir(&nonexistent_path) };\n-        assert!(bogus == substitute_path);\n+    fn recursive_mkdir_ok() {\n+        let root = os::tmpdir();\n+        let path = \"xy/z/zy\";\n+        let nested = root.push(path);\n+        assert!(super::mkdir_recursive(&nested));\n+        assert!(os::path_is_dir(&root.push(\"xy\")));\n+        assert!(os::path_is_dir(&root.push(\"xy/z\")));\n+        assert!(os::path_is_dir(&nested));\n     }\n }"}, {"sha": "e1edce6ce5b6a4297ed2ebe53f79d669f93f47d1", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 69, "deletions": 111, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "patch": "@@ -36,13 +36,19 @@ use rustc::metadata::filesearch;\n use std::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n-use path_util::{dest_dir, normalize};\n+use path_util::normalize;\n+use path_util::{build_pkg_id_in_workspace, pkgid_src_in_workspace};\n+use workspace::pkg_parent_workspaces;\n use rustc::driver::session::{lib_crate, bin_crate, crate_type};\n+use context::Ctx;\n \n mod conditions;\n+mod context;\n mod usage;\n mod path_util;\n+mod tests;\n mod util;\n+mod workspace;\n \n /// A PkgScript represents user-supplied custom logic for\n /// special build hooks. This only exists for packages with\n@@ -70,7 +76,7 @@ impl PkgScript {\n     /// Given the path name for a package script\n     /// and a package ID, parse the package script into\n     /// a PkgScript that we can then execute\n-    fn parse(script: Path, id: PkgId) -> PkgScript {\n+    fn parse(script: Path, workspace: &Path, id: PkgId) -> PkgScript {\n         // Get the executable name that was invoked\n         let binary = os::args()[0];\n         // Build the rustc session data structures to pass\n@@ -85,7 +91,7 @@ impl PkgScript {\n         let cfg = driver::build_configuration(sess, @binary, &input);\n         let (crate, _) = driver::compile_upto(sess, cfg, &input,\n                                               driver::cu_parse, None);\n-        let work_dir = dest_dir(id);\n+        let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n         debug!(\"Returning package script with id %?\", id);\n \n@@ -153,14 +159,6 @@ impl PkgScript {\n \n }\n \n-struct Ctx {\n-    // I'm not sure what this is for\n-    json: bool,\n-    // Cache of hashes of things already installed\n-    // though I'm not sure why the value is a bool\n-    dep_cache: @mut HashMap<~str, bool>,\n-}\n-\n impl Ctx {\n \n     fn run(&self, cmd: ~str, args: ~[~str]) {\n@@ -193,54 +191,50 @@ impl Ctx {\n                 // The package id is presumed to be the first command-line\n                 // argument\n                 let pkgid = PkgId::new(args[0]);\n-                // Should allow the build directory to be configured.\n-                // Right now it's always the \"build\" subdirectory in\n-                // the package directory\n-                let dst_dir = dest_dir(pkgid);\n-                debug!(\"Destination dir = %s\", dst_dir.to_str());\n-                // Right now, we assume the pkgid path is a valid dir\n-                // relative to the CWD. In the future, we should search\n-                // paths\n-                let cwd = os::getcwd().normalize();\n-                debug!(\"Current working directory = %s\", cwd.to_str());\n-\n-                // Create the package source\n-                let mut src = PkgSrc::new(&cwd, &dst_dir, &pkgid);\n-                debug!(\"Package src = %?\", src);\n-\n-                // Is there custom build logic? If so, use it\n-                let pkg_src_dir = cwd.push_rel(&pkgid.path);\n-                let mut custom = false;;\n-                debug!(\"Package source directory = %s\", pkg_src_dir.to_str());\n-                let cfgs = match src.package_script_option(&pkg_src_dir) {\n-                    Some(package_script_path) => {\n-                        let pscript = PkgScript::parse(package_script_path,\n-                                                       pkgid);\n-                        // Limited right now -- we're only running the post_build\n-                        // hook and probably fail otherwise\n-                        // also post_build should be called pre_build\n-                        let (cfgs, hook_result) = pscript.run_custom(~\"post_build\");\n-                        debug!(\"Command return code = %?\", hook_result);\n-                        if hook_result != 0 {\n-                            fail!(fmt!(\"Error running custom build command\"))\n+                for pkg_parent_workspaces(pkgid) |workspace| {\n+                    let src_dir   = pkgid_src_in_workspace(pkgid, workspace);\n+                    let build_dir = build_pkg_id_in_workspace(pkgid, workspace);\n+                    debug!(\"Destination dir = %s\", build_dir.to_str());\n+\n+                    // Create the package source\n+                    let mut src = PkgSrc::new(&workspace.push(\"src\"), &build_dir, &pkgid);\n+                    debug!(\"Package src = %?\", src);\n+\n+                    // Is there custom build logic? If so, use it\n+                    let pkg_src_dir = src_dir;\n+                    let mut custom = false;\n+                    debug!(\"Package source directory = %s\", pkg_src_dir.to_str());\n+                    let cfgs = match src.package_script_option(&pkg_src_dir) {\n+                        Some(package_script_path) => {\n+                            let pscript = PkgScript::parse(package_script_path,\n+                                                           workspace,\n+                                                           pkgid);\n+                            // Limited right now -- we're only running the post_build\n+                            // hook and probably fail otherwise\n+                            // also post_build should be called pre_build\n+                            let (cfgs, hook_result) = pscript.run_custom(~\"post_build\");\n+                            debug!(\"Command return code = %?\", hook_result);\n+                            if hook_result != 0 {\n+                                fail!(fmt!(\"Error running custom build command\"))\n+                            }\n+                            custom = true;\n+                            // otherwise, the package script succeeded\n+                            cfgs\n                         }\n-                        custom = true;\n-                        // otherwise, the package script succeeded\n-                        cfgs\n-                    }\n-                    None => {\n-                        debug!(\"No package script, continuing\");\n-                        ~[]\n+                        None => {\n+                            debug!(\"No package script, continuing\");\n+                            ~[]\n+                        }\n+                    };\n+\n+                    // If there was a package script, it should have finished\n+                    // the build already. Otherwise...\n+                    if !custom {\n+                        // Find crates inside the workspace\n+                        src.find_crates();\n+                        // Build it!\n+                        src.build(&build_dir, cfgs);\n                     }\n-                };\n-\n-                // If there was a package script, it should have finished\n-                // the build already. Otherwise...\n-                if !custom {\n-                    // Find crates inside the workspace\n-                    src.find_crates();\n-                    // Build it!\n-                    src.build(&dst_dir, cfgs);\n                 }\n             }\n             ~\"clean\" => {\n@@ -250,8 +244,8 @@ impl Ctx {\n                 // The package id is presumed to be the first command-line\n                 // argument\n                 let pkgid = PkgId::new(args[0]);\n-\n-                self.clean(pkgid);\n+                let cwd = os::getcwd();\n+                self.clean(&cwd, pkgid); // tjc: should use workspace, not cwd\n             }\n             ~\"do\" => {\n                 if args.len() < 2 {\n@@ -264,10 +258,16 @@ impl Ctx {\n                 self.info();\n             }\n             ~\"install\" => {\n-                self.install(if args.len() >= 1 { Some(args[0]) }\n-                             else { None },\n-                             if args.len() >= 2 { Some(args[1]) }\n-                             else { None }, false);\n+                if args.len() < 1 {\n+                    return usage::install();\n+                }\n+\n+                // The package id is presumed to be the first command-line\n+                // argument\n+                let pkgid = PkgId::new(args[0]);\n+                for pkg_parent_workspaces(pkgid) |workspace| {\n+                    self.install(workspace, pkgid);\n+                }\n             }\n             ~\"prefer\" => {\n                 if args.len() < 1 {\n@@ -303,58 +303,17 @@ impl Ctx {\n         }\n     }\n \n-    fn do_cmd(&self, cmd: ~str, pkgname: ~str)  {\n-        match cmd {\n-            ~\"build\" | ~\"test\" => {\n-                util::error(~\"that command cannot be manually called\");\n-                fail!(~\"do_cmd\");\n-            }\n-            _ => {}\n-        }\n-\n-        let cwd = &os::getcwd();\n-        let pkgid = PkgId::new(pkgname);\n-        // Always use the \"build\" subdirectory of the package dir,\n-        // but we should allow this to be configured\n-        let dst_dir = dest_dir(pkgid);\n-\n-        let mut src = PkgSrc::new(cwd, &dst_dir, &pkgid);\n-        match src.package_script_option(cwd) {\n-            Some(script_path) => {\n-                let script = PkgScript::parse(script_path, pkgid);\n-                let (_, status) = script.run_custom(cmd); // Ignore cfgs?\n-                if status == 42 {\n-                    util::error(~\"no fns are listening for that cmd\");\n-                    fail!(~\"do_cmd\");\n-                }\n-            }\n-            None => {\n-                util::error(fmt!(\"invoked `do`, but there is no package script in %s\",\n-                                 cwd.to_str()));\n-                fail!(~\"do_cmd\");\n-            }\n-        }\n-    }\n-\n-    fn build(&self, _dir: &Path, _verbose: bool, _opt: bool,\n-             _test: bool) -> Option<PkgScript> {\n- // either not needed anymore,\n- // or needed only when we don't have a package script. Not sure which one.\n-        fail!();\n-    }\n-\n-    fn compile(&self, _crate: &Path, _dir: &Path, _flags: ~[~str],\n-               _cfgs: ~[~str], _opt: bool, _test: bool)  {\n-        // What's the difference between build and compile?\n-        fail!(~\"compile not yet implemented\");\n+    fn do_cmd(&self, _cmd: ~str, _pkgname: ~str)  {\n+        // stub\n+        fail!(~\"`do` not yet implemented\");\n     }\n \n-    fn clean(&self, id: PkgId)  {\n+    fn clean(&self, workspace: &Path, id: PkgId)  {\n         // Could also support a custom build hook in the pkg\n         // script for cleaning files rustpkg doesn't know about.\n         // Do something reasonable for now\n \n-        let dir = dest_dir(id);\n+        let dir = build_pkg_id_in_workspace(id, workspace);\n         util::note(fmt!(\"Cleaning package %s (removing directory %s)\",\n                         id.to_str(), dir.to_str()));\n         if os::path_exists(&dir) {\n@@ -370,8 +329,7 @@ impl Ctx {\n         fail!(~\"info not yet implemented\");\n     }\n \n-    fn install(&self, _url: Option<~str>,\n-               _target: Option<~str>, _cache: bool)  {\n+    fn install(&self, _workspace: &Path, _id: PkgId)  {\n         // stub\n         fail!(~\"install not yet implemented\");\n     }"}, {"sha": "70c03c845ce600b23c27069c7cb77fe863f8f94a", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "patch": "@@ -9,3 +9,96 @@\n // except according to those terms.\n \n // rustpkg unit tests\n+\n+use context::Ctx;\n+use core::hashmap::HashMap;\n+use core::path::Path;\n+use core::os;\n+use core::io;\n+use core::option::*;\n+use std::tempfile::mkdtemp;\n+use util::{PkgId, default_version};\n+use path_util::{target_executable_in_workspace, target_library_in_workspace,\n+               target_test_in_workspace, target_bench_in_workspace,\n+               make_dir_rwx};\n+\n+fn fake_ctxt() -> Ctx {\n+    Ctx {\n+        json: false,\n+        dep_cache: @mut HashMap::new()\n+    }\n+}\n+\n+fn fake_pkg() -> PkgId {\n+    PkgId {\n+        path: Path(~\"bogus\"),\n+        version: default_version()\n+    }\n+}\n+\n+fn mk_temp_workspace() -> Path {\n+    mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\")\n+}\n+\n+fn is_rwx(p: &Path) -> bool {\n+    use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+\n+    match p.get_mode() {\n+        None => return false,\n+        Some(m) => {\n+            ((m & S_IRUSR as uint) == S_IRUSR as uint\n+            && (m & S_IWUSR as uint) == S_IWUSR as uint\n+            && (m & S_IXUSR as uint) == S_IXUSR as uint)\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_make_dir_rwx() {\n+    let temp = &os::tmpdir();\n+    let dir = temp.push(~\"quux\");\n+    let _ = os::remove_dir(&dir);\n+    assert!(make_dir_rwx(&dir));\n+    assert!(os::path_is_dir(&dir));\n+    assert!(is_rwx(&dir));\n+    assert!(os::remove_dir(&dir));\n+}\n+\n+#[test]\n+#[ignore(reason = \"install not yet implemented\")]\n+fn test_install_valid() {\n+    let ctxt = fake_ctxt();\n+    let temp_pkg_id = fake_pkg();\n+    let temp_workspace() = mk_temp_workspace();\n+    // should have test, bench, lib, and main\n+    ctxt.install(&temp_workspace, temp_pkg_id);\n+    // Check that all files exist\n+    let exec = target_executable_in_workspace(temp_pkg_id, &temp_workspace);\n+    assert!(os::path_exists(&exec));\n+    assert!(is_rwx(&exec));\n+    let lib = target_library_in_workspace(temp_pkg_id, &temp_workspace);\n+    assert!(os::path_exists(&lib));\n+    assert!(is_rwx(&lib));\n+    // And that the test and bench executables aren't installed\n+    assert!(!os::path_exists(&target_test_in_workspace(temp_pkg_id, &temp_workspace)));\n+    assert!(!os::path_exists(&target_bench_in_workspace(temp_pkg_id, &temp_workspace)));\n+}\n+\n+#[test]\n+#[ignore(reason = \"install not yet implemented\")]\n+fn test_install_invalid() {\n+    use conditions::nonexistent_package::cond;\n+\n+    let ctxt = fake_ctxt();\n+    let pkgid = fake_pkg();\n+    let temp_workspace = mk_temp_workspace();\n+    let expected_path = Path(~\"quux\");\n+    let substituted: Path = do cond.trap(|_| {\n+        expected_path\n+    }).in {\n+        ctxt.install(&temp_workspace, pkgid);\n+        // ok\n+        fail!(~\"test_install_invalid failed, should have raised a condition\");\n+    };\n+    assert!(substituted == expected_path);\n+}\n\\ No newline at end of file"}, {"sha": "ffbc6e2a7f9b2a68f07a2a3137e5dd25eb9a18dc", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/bar.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fbar.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "previous_filename": "src/librustpkg/testsuite/pass/src/fancy-lib/src/bar.rs"}, {"sha": "dc068eed143efd313d93299be2e0debbc10a0228", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/fancy-lib.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Ffancy-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Ffancy-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Ffancy-lib.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "patch": "@@ -21,4 +21,4 @@ extern mod std;\n \n pub mod foo;\n pub mod bar;\n-#[path = \"build/generated.rs\"] pub mod generated;\n+#[path = \"../../build/fancy_lib/generated.rs\"] pub mod generated;", "previous_filename": "src/librustpkg/testsuite/pass/src/fancy-lib/src/fancy-lib.rs"}, {"sha": "542a6af402d055053afffe3c366fb145e51c4b83", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/foo.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Ffoo.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "previous_filename": "src/librustpkg/testsuite/pass/src/fancy-lib/src/foo.rs"}, {"sha": "eeaa0f68ed531ed8c3c39baca929c7887203ccac", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "patch": "@@ -11,13 +11,18 @@\n use core::run;\n \n pub fn main() {\n-    let cwd = os::getcwd();\n-    debug!(\"cwd = %s\", cwd.to_str());\n-    let file = io::file_writer(&Path(~\"fancy-lib/build/generated.rs\"),\n+    use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+\n+    let out_path = Path(~\"build/fancy_lib\");\n+    if !os::path_exists(&out_path) {\n+        assert!(os::make_dir(&out_path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+    }\n+\n+    let file = io::file_writer(&out_path.push(\"generated.rs\"),\n                                [io::Create]).get();\n     file.write_str(\"pub fn wheeeee() { for [1, 2, 3].each() |_| { assert!(true); } }\");\n \n     // now compile the crate itself\n-    run::run_program(\"rustc\", ~[~\"fancy-lib/fancy-lib.rs\", ~\"--lib\",\n-                                ~\"-o\", ~\"fancy-lib/build/fancy_lib\"]);\n+    run::run_program(\"rustc\", ~[~\"src/fancy-lib/fancy-lib.rs\", ~\"--lib\",\n+                                ~\"-o\", out_path.push(~\"fancy_lib\").to_str()]);\n }\n\\ No newline at end of file"}, {"sha": "2ef387d962000c1f044061bb646ae299fa97b045", "filename": "src/librustpkg/testsuite/pass/src/hello-world/main.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "previous_filename": "src/librustpkg/testsuite/pass/src/hello-world/src/main.rs"}, {"sha": "e1641ccf0749309426e57a911ce21ceed13d75fd", "filename": "src/librustpkg/testsuite/pass/src/install-paths/bench.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fbench.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "previous_filename": "src/librustpkg/testsuite/pass/src/install-paths/src/bench.rs"}, {"sha": "baf90446f7aaca6c3364f96306e94574ee76f602", "filename": "src/librustpkg/testsuite/pass/src/install-paths/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Flib.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "previous_filename": "src/librustpkg/testsuite/pass/src/install-paths/src/lib.rs"}, {"sha": "37e606dcb1ab3ee283c3c6a280cf8837c2bdc038", "filename": "src/librustpkg/testsuite/pass/src/install-paths/main.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fmain.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "previous_filename": "src/librustpkg/testsuite/pass/src/install-paths/src/main.rs"}, {"sha": "acfae9e04fb59b54caf70ae08e407542606b83c5", "filename": "src/librustpkg/testsuite/pass/src/install-paths/test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Ftest.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "previous_filename": "src/librustpkg/testsuite/pass/src/install-paths/src/test.rs"}, {"sha": "28198e59f86d4a4c0be2a449ba0bf61739ac576c", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "patch": "@@ -78,7 +78,7 @@ impl ToStr for Version {\n }\n \n /// Placeholder\n-fn default_version() -> Version { ExactRevision(0.1) }\n+pub fn default_version() -> Version { ExactRevision(0.1) }\n \n // Path-fragment identifier of a package such as\n // 'github.com/graydon/test'; path must be a relative\n@@ -116,7 +116,14 @@ pub impl PkgId {\n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s-%s\", self.path.to_str(), self.version.to_str())\n+        fmt!(\"%s-%s\", self.path.to_str(),\n+             // Replace dots with -s in the version\n+             // this is because otherwise rustc will think\n+             // that foo-0.1 has .1 as its extension\n+             // (Temporary hack until I figure out how to\n+             // get rustc to not name the object file\n+             // foo-0.o if I pass in foo-0.1 to build_output_filenames)\n+             str::replace(self.version.to_str(), \".\", \"-\"))\n     }\n }\n \n@@ -438,7 +445,9 @@ pub fn compile_input(sysroot: Option<Path>,\n                      test: bool,\n                      crate_type: session::crate_type) -> bool {\n \n-    let short_name = pkg_id.to_str();\n+    // Want just the directory component here\n+    let pkg_filename = pkg_id.path.filename().expect(~\"Weird pkg id\");\n+    let short_name = fmt!(\"%s-%s\", pkg_filename, pkg_id.version.to_str());\n \n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input(copy *in_file);\n@@ -515,7 +524,7 @@ pub fn compile_crate_from_input(input: driver::input,\n                                 out_file: Path,\n                                 binary: ~str,\n                                 what: driver::compile_upto) -> @ast::crate {\n-    debug!(\"Calling build_output_filenames with %?\", build_dir_opt);\n+    debug!(\"Calling build_output_filenames with %? and %s\", build_dir_opt, out_file.to_str());\n     let outputs = driver::build_output_filenames(&input, &build_dir_opt, &Some(out_file), sess);\n     debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n     let cfg = driver::build_configuration(sess, @binary, &input);"}, {"sha": "15e2166b24abe1000d38dd4f49742fde97f87c99", "filename": "src/librustpkg/workspace.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0604468fd540b4356ba28bf9a6d26b56b73d5b3b/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustpkg utilities having to do with workspaces\n+\n+use path_util::{rust_path, workspace_contains_package_id};\n+use util::PkgId;\n+use core::path::Path;\n+\n+pub fn pkg_parent_workspaces(pkgid: PkgId, action: &fn(&Path) -> bool) {\n+    // Using the RUST_PATH, find workspaces that contain\n+    // this package ID\n+    let workspaces = rust_path().filtered(|ws|\n+        workspace_contains_package_id(pkgid, ws));\n+    if workspaces.is_empty() {\n+        // tjc: make this a condition\n+        fail!(fmt!(\"Package %s not found in any of \\\n+                    the following workspaces: %s\",\n+                   pkgid.path.to_str(),\n+                   rust_path().to_str()));\n+    }\n+    for workspaces.each |ws| {\n+        if action(ws) {\n+            break;\n+        }\n+    }\n+}\n\\ No newline at end of file"}]}