{"sha": "aea954b74de16888f09ff003ebfdf97f9f7ef001", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYTk1NGI3NGRlMTY4ODhmMDlmZjAwM2ViZmRmOTdmOWY3ZWYwMDE=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-04-29T02:58:24Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-05-20T15:12:49Z"}, "message": "Fixed detection of multiple non-auto traits.", "tree": {"sha": "f36db484b4059a1775f52fbd7509df20093c04fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f36db484b4059a1775f52fbd7509df20093c04fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aea954b74de16888f09ff003ebfdf97f9f7ef001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aea954b74de16888f09ff003ebfdf97f9f7ef001", "html_url": "https://github.com/rust-lang/rust/commit/aea954b74de16888f09ff003ebfdf97f9f7ef001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aea954b74de16888f09ff003ebfdf97f9f7ef001/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f6c2127d792b0f2f2eb82e160e02cae3b238f14", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f6c2127d792b0f2f2eb82e160e02cae3b238f14", "html_url": "https://github.com/rust-lang/rust/commit/5f6c2127d792b0f2f2eb82e160e02cae3b238f14"}], "stats": {"total": 360, "additions": 208, "deletions": 152}, "files": [{"sha": "d950746f6e6d9a161ba737fa26a1495f4fb7e692", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aea954b74de16888f09ff003ebfdf97f9f7ef001/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea954b74de16888f09ff003ebfdf97f9f7ef001/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=aea954b74de16888f09ff003ebfdf97f9f7ef001", "patch": "@@ -60,9 +60,12 @@ pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n-pub use self::util::{supertraits, supertrait_def_ids, transitive_bounds,\n-                     Supertraits, SupertraitDefIds};\n-pub use self::util::{expand_trait_refs, TraitRefExpander};\n+pub use self::util::{\n+    supertraits, supertrait_def_ids, transitive_bounds, Supertraits, SupertraitDefIds,\n+};\n+pub use self::util::{\n+    expand_trait_aliases, TraitAliasExpander, TraitAliasExpansionInfoDignosticBuilder,\n+};\n \n pub use self::chalk_fulfill::{\n     CanonicalGoal as ChalkCanonicalGoal,"}, {"sha": "d765827e3d569a524f1eb2652a5538ac072ad111", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 129, "deletions": 66, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/aea954b74de16888f09ff003ebfdf97f9f7ef001/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea954b74de16888f09ff003ebfdf97f9f7ef001/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=aea954b74de16888f09ff003ebfdf97f9f7ef001", "patch": "@@ -1,3 +1,5 @@\n+use errors::DiagnosticBuilder;\n+use smallvec::SmallVec;\n use syntax_pos::Span;\n \n use crate::hir;\n@@ -43,7 +45,7 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     }\n }\n \n-struct PredicateSet<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct PredicateSet<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     set: FxHashSet<ty::Predicate<'tcx>>,\n }\n@@ -53,6 +55,10 @@ impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n         PredicateSet { tcx: tcx, set: Default::default() }\n     }\n \n+    fn contains(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n+        self.set.contains(&anonymize_predicate(self.tcx, pred))\n+    }\n+\n     fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n         // We have to be careful here because we want\n         //\n@@ -66,6 +72,18 @@ impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n         // regions before we throw things into the underlying set.\n         self.set.insert(anonymize_predicate(self.tcx, pred))\n     }\n+\n+    fn remove(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n+        self.set.remove(&anonymize_predicate(self.tcx, pred))\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx, T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'a, 'gcx, 'tcx> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        for pred in iter.into_iter() {\n+            self.insert(pred.as_ref());\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -230,10 +248,16 @@ impl<'cx, 'gcx, 'tcx> Iterator for Elaborator<'cx, 'gcx, 'tcx> {\n     }\n \n     fn next(&mut self) -> Option<ty::Predicate<'tcx>> {\n-        self.stack.pop().map(|item| {\n-            self.push(&item);\n-            item\n-        })\n+        // Extract next item from top-most stack frame, if any.\n+        let next_predicate = match self.stack.pop() {\n+            Some(predicate) => predicate,\n+            None => {\n+                // No more stack frames. Done.\n+                return None;\n+            }\n+        };\n+        self.push(&next_predicate);\n+        return Some(next_predicate);\n     }\n }\n \n@@ -256,96 +280,140 @@ pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// `TraitRefExpander` iterator\n+// `TraitAliasExpander` iterator\n ///////////////////////////////////////////////////////////////////////////\n \n-/// \"Trait reference expansion\" is the process of expanding a sequence of trait\n+/// \"Trait alias expansion\" is the process of expanding a sequence of trait\n /// references into another sequence by transitively following all trait\n /// aliases. e.g. If you have bounds like `Foo + Send`, a trait alias\n /// `trait Foo = Bar + Sync;`, and another trait alias\n /// `trait Bar = Read + Write`, then the bounds would expand to\n /// `Read + Write + Sync + Send`.\n-pub struct TraitRefExpander<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    stack: Vec<TraitRefExpansionInfo<'tcx>>,\n+pub struct TraitAliasExpander<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    stack: Vec<TraitAliasExpansionInfo<'tcx>>,\n+    /// The set of predicates visited from the root directly to the current point in the\n+    /// expansion tree.\n     visited: PredicateSet<'a, 'gcx, 'tcx>,\n }\n \n #[derive(Debug, Clone)]\n-pub struct TraitRefExpansionInfo<'tcx> {\n-    pub top_level_trait_ref: ty::PolyTraitRef<'tcx>,\n-    pub top_level_span: Span,\n-    pub trait_ref: ty::PolyTraitRef<'tcx>,\n-    pub span: Span,\n+pub struct TraitAliasExpansionInfo<'tcx> {\n+    pub items: SmallVec<[(ty::PolyTraitRef<'tcx>, Span); 4]>,\n }\n \n-pub fn expand_trait_refs<'cx, 'gcx, 'tcx>(\n+impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n+    fn new(trait_ref: ty::PolyTraitRef<'tcx>, span: Span) -> TraitAliasExpansionInfo<'tcx> {\n+        TraitAliasExpansionInfo {\n+            items: smallvec![(trait_ref, span)]\n+        }\n+    }\n+\n+    fn push(&self, trait_ref: ty::PolyTraitRef<'tcx>, span: Span) -> TraitAliasExpansionInfo<'tcx> {\n+        let mut items = self.items.clone();\n+        items.push((trait_ref, span));\n+\n+        TraitAliasExpansionInfo {\n+            items\n+        }\n+    }\n+\n+    pub fn trait_ref(&self) -> &ty::PolyTraitRef<'tcx> {\n+        &self.top().0\n+    }\n+\n+    pub fn top(&self) -> &(ty::PolyTraitRef<'tcx>, Span) {\n+        self.items.last().unwrap()\n+    }\n+\n+    pub fn bottom(&self) -> &(ty::PolyTraitRef<'tcx>, Span) {\n+        self.items.first().unwrap()\n+    }\n+}\n+\n+pub trait TraitAliasExpansionInfoDignosticBuilder {\n+    fn label_with_exp_info<'tcx>(&mut self,\n+        info: &TraitAliasExpansionInfo<'tcx>,\n+        top_label: &str\n+    ) -> &mut Self;\n+}\n+\n+impl<'a> TraitAliasExpansionInfoDignosticBuilder for DiagnosticBuilder<'a> {\n+    fn label_with_exp_info<'tcx>(&mut self,\n+        info: &TraitAliasExpansionInfo<'tcx>,\n+        top_label: &str\n+    ) -> &mut Self {\n+        self.span_label(info.top().1, top_label);\n+        if info.items.len() > 1 {\n+            for (_, sp) in info.items[1..(info.items.len() - 1)].iter().rev() {\n+                self.span_label(*sp, \"referenced here\");\n+            }\n+        }\n+        self\n+    }\n+}\n+\n+pub fn expand_trait_aliases<'cx, 'gcx, 'tcx>(\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>\n-) -> TraitRefExpander<'cx, 'gcx, 'tcx> {\n-    let mut visited = PredicateSet::new(tcx);\n-    let mut items: Vec<_> =\n-        trait_refs\n-            .into_iter()\n-            .map(|(trait_ref, span)| TraitRefExpansionInfo {\n-                top_level_trait_ref: trait_ref.clone(),\n-                top_level_span: span,\n-                trait_ref,\n-                span,\n-            })\n-            .collect();\n-    items.retain(|item| visited.insert(&item.trait_ref.to_predicate()));\n-    TraitRefExpander { stack: items, visited }\n+) -> TraitAliasExpander<'cx, 'gcx, 'tcx> {\n+    let items: Vec<_> = trait_refs\n+        .into_iter()\n+        .map(|(trait_ref, span)| TraitAliasExpansionInfo::new(trait_ref, span))\n+        .collect();\n+    TraitAliasExpander { stack: items, visited: PredicateSet::new(tcx) }\n }\n \n-impl<'cx, 'gcx, 'tcx> TraitRefExpander<'cx, 'gcx, 'tcx> {\n-    /// If `item` refers to a trait alias, adds the components of the trait alias to the stack,\n-    /// and returns `false`.\n-    /// If `item` refers to an ordinary trait, simply returns `true`.\n-    fn push(&mut self, item: &TraitRefExpansionInfo<'tcx>) -> bool {\n+impl<'cx, 'gcx, 'tcx> TraitAliasExpander<'cx, 'gcx, 'tcx> {\n+    /// If `item` is a trait alias and its predicate has not yet been visited, then expands `item`\n+    /// to the definition and pushes the resulting expansion onto `self.stack`, and returns `false`.\n+    /// Otherwise, immediately returns `true` if `item` is a regular trait and `false` if it is a\n+    /// trait alias.\n+    /// The return value indicates whether `item` should not be yielded to the user.\n+    fn push(&mut self, item: &TraitAliasExpansionInfo<'tcx>) -> bool {\n         let tcx = self.visited.tcx;\n+        let trait_ref = item.trait_ref();\n+        let pred = trait_ref.to_predicate();\n+\n+        debug!(\"expand_trait_aliases: trait_ref={:?}\", trait_ref);\n+\n+        self.visited.remove(&pred);\n \n-        if !tcx.is_trait_alias(item.trait_ref.def_id()) {\n-            return true;\n+        let is_alias = tcx.is_trait_alias(trait_ref.def_id());\n+        if !is_alias || self.visited.contains(&pred) {\n+            return !is_alias;\n         }\n \n-        // Get components of the trait alias.\n-        let predicates = tcx.super_predicates_of(item.trait_ref.def_id());\n+        // Get components of trait alias.\n+        let predicates = tcx.super_predicates_of(trait_ref.def_id());\n \n-        let mut items: Vec<_> = predicates.predicates\n+        let items: Vec<_> = predicates.predicates\n             .iter()\n             .rev()\n             .filter_map(|(pred, span)| {\n-                pred.subst_supertrait(tcx, &item.trait_ref)\n+                pred.subst_supertrait(tcx, &trait_ref)\n                     .to_opt_poly_trait_ref()\n-                    .map(|trait_ref|\n-                        TraitRefExpansionInfo {\n-                            trait_ref,\n-                            span: *span,\n-                            ..*item\n-                        }\n-                    )\n+                    .map(|trait_ref| item.push(trait_ref, *span))\n             })\n             .collect();\n+        debug!(\"expand_trait_aliases: items={:?}\", items);\n \n-        debug!(\"trait_ref_expander: trait_ref={:?} items={:?}\",\n-               item.trait_ref, items);\n+        self.stack.extend(items);\n \n-        // Only keep those items that we haven't already seen.\n-        items.retain(|i| self.visited.insert(&i.trait_ref.to_predicate()));\n+        // Record predicate into set of already-visited.\n+        self.visited.insert(&pred);\n \n-        self.stack.extend(items);\n         false\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> Iterator for TraitRefExpander<'cx, 'gcx, 'tcx> {\n-    type Item = TraitRefExpansionInfo<'tcx>;\n+impl<'cx, 'gcx, 'tcx> Iterator for TraitAliasExpander<'cx, 'gcx, 'tcx> {\n+    type Item = TraitAliasExpansionInfo<'tcx>;\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.stack.len(), None)\n     }\n \n-    fn next(&mut self) -> Option<TraitRefExpansionInfo<'tcx>> {\n+    fn next(&mut self) -> Option<TraitAliasExpansionInfo<'tcx>> {\n         while let Some(item) = self.stack.pop() {\n             if self.push(&item) {\n                 return Some(item);\n@@ -386,8 +454,8 @@ impl<'cx, 'gcx, 'tcx> Iterator for SupertraitDefIds<'cx, 'gcx, 'tcx> {\n         self.stack.extend(\n             predicates.predicates\n                       .iter()\n-                      .filter_map(|(p, _)| p.to_opt_poly_trait_ref())\n-                      .map(|t| t.def_id())\n+                      .filter_map(|(pred, _)| pred.to_opt_poly_trait_ref())\n+                      .map(|trait_ref| trait_ref.def_id())\n                       .filter(|&super_def_id| visited.insert(super_def_id)));\n         Some(def_id)\n     }\n@@ -413,17 +481,12 @@ impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<\n     type Item = ty::PolyTraitRef<'tcx>;\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n-        loop {\n-            match self.base_iterator.next() {\n-                None => {\n-                    return None;\n-                }\n-                Some(ty::Predicate::Trait(data)) => {\n-                    return Some(data.to_poly_trait_ref());\n-                }\n-                Some(_) => {}\n+        while let Some(pred) = self.base_iterator.next() {\n+            if let ty::Predicate::Trait(data) = pred {\n+                return Some(data.to_poly_trait_ref());\n             }\n         }\n+        None\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {"}, {"sha": "d70c818549556bc8fdfe33e9b196266670ca3463", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aea954b74de16888f09ff003ebfdf97f9f7ef001/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea954b74de16888f09ff003ebfdf97f9f7ef001/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=aea954b74de16888f09ff003ebfdf97f9f7ef001", "patch": "@@ -504,7 +504,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         any_lifetime_bounds = true;\n                     }\n                 }\n-                self.no_questions_in_bounds(bounds, \"trait object types\", false);\n             }\n             TyKind::ImplTrait(_, ref bounds) => {\n                 if self.is_impl_trait_banned {"}, {"sha": "428fa66101acb786e5740b5e3510f61d2203edf2", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 73, "deletions": 82, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/aea954b74de16888f09ff003ebfdf97f9f7ef001/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea954b74de16888f09ff003ebfdf97f9f7ef001/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=aea954b74de16888f09ff003ebfdf97f9f7ef001", "patch": "@@ -11,7 +11,7 @@ use crate::lint;\n use crate::middle::resolve_lifetime as rl;\n use crate::namespace::Namespace;\n use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n-use rustc::traits;\n+use rustc::traits::{self, TraitAliasExpansionInfoDignosticBuilder};\n use rustc::ty::{self, DefIdTree, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc::ty::subst::{Kind, Subst, InternalSubsts, SubstsRef};\n@@ -965,84 +965,77 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         ty::ExistentialTraitRef::erase_self_ty(self.tcx(), trait_ref)\n     }\n \n-    fn expand_trait_refs(&self,\n-        trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>\n-    ) -> Vec<DefId> {\n+    fn conv_object_ty_poly_trait_ref(&self,\n+        span: Span,\n+        trait_bounds: &[hir::PolyTraitRef],\n+        lifetime: &hir::Lifetime)\n+        -> Ty<'tcx>\n+    {\n         let tcx = self.tcx();\n \n+        let mut projection_bounds = Vec::new();\n+        let mut potential_assoc_types = Vec::new();\n+        let dummy_self = self.tcx().types.trait_object_dummy_self;\n+        let bound_trait_refs: Vec<_> = trait_bounds\n+            .iter()\n+            .rev()\n+            .map(|trait_bound| {\n+                let (trait_ref, cur_potential_assoc_types) = self.instantiate_poly_trait_ref(\n+                    trait_bound,\n+                    dummy_self,\n+                    &mut projection_bounds\n+                );\n+                potential_assoc_types.extend(cur_potential_assoc_types.into_iter().flatten());\n+                (trait_ref, trait_bound.span)\n+            }).collect();\n+\n         // Expand trait aliases recursively and check that only one regular (non-auto) trait\n-        // is used.\n-        let expanded_traits = traits::expand_trait_refs(tcx, trait_refs);\n-        let (auto_traits, regular_traits): (Vec<_>, Vec<_>) =\n-            expanded_traits.partition(|i| tcx.trait_is_auto(i.trait_ref.def_id()));\n+        // is used and no 'maybe' bounds are used.\n+        let expanded_traits = traits::expand_trait_aliases(tcx, bound_trait_refs.clone());\n+        let (mut auto_traits, regular_traits): (Vec<_>, Vec<_>) =\n+            expanded_traits.partition(|i| tcx.trait_is_auto(i.trait_ref().def_id()));\n         if regular_traits.len() > 1 {\n             let extra_trait = &regular_traits[1];\n-            let mut err = struct_span_err!(tcx.sess, extra_trait.top_level_span, E0225,\n+            let mut err = struct_span_err!(tcx.sess, extra_trait.bottom().1, E0225,\n                 \"only auto traits can be used as additional traits in a trait object\");\n-            err.span_label(extra_trait.span, \"non-auto additional trait\");\n-            if extra_trait.span != extra_trait.top_level_span {\n-                err.span_label(extra_trait.top_level_span, \"expanded from this trait alias\");\n-            }\n+            err.label_with_exp_info(extra_trait, \"additional non-auto trait\");\n+            err.span_label(regular_traits[0].top().1, \"first non-auto trait\");\n             err.emit();\n         }\n \n-        auto_traits.into_iter().map(|i| i.trait_ref.def_id()).collect()\n-    }\n-\n-    fn conv_object_ty_poly_trait_ref(&self,\n-        span: Span,\n-        trait_bounds: &[hir::PolyTraitRef],\n-        lifetime: &hir::Lifetime)\n-        -> Ty<'tcx>\n-    {\n-        let tcx = self.tcx();\n-\n-        if trait_bounds.is_empty() {\n+        if regular_traits.is_empty() && auto_traits.is_empty() {\n             span_err!(tcx.sess, span, E0224,\n                 \"at least one non-builtin trait is required for an object type\");\n             return tcx.types.err;\n         }\n \n-        let mut projection_bounds = Vec::new();\n-        let dummy_self = self.tcx().types.trait_object_dummy_self;\n-        let (principal, potential_assoc_types) = self.instantiate_poly_trait_ref(\n-            &trait_bounds[0],\n-            dummy_self,\n-            &mut projection_bounds,\n-        );\n-        debug!(\"principal: {:?}\", principal);\n-\n-        let mut bound_trait_refs = Vec::with_capacity(trait_bounds.len());\n-        for trait_bound in trait_bounds[1..].iter().rev() {\n-            // Sanity check for non-principal trait bounds.\n-            let (tr, _) = self.instantiate_poly_trait_ref(\n-                trait_bound,\n-                dummy_self,\n-                &mut Vec::new()\n-            );\n-            bound_trait_refs.push((tr, trait_bound.span));\n-        }\n-        bound_trait_refs.push((principal, trait_bounds[0].span));\n-\n-        let mut auto_traits = self.expand_trait_refs(bound_trait_refs);\n-\n         // Check that there are no gross object safety violations;\n         // most importantly, that the supertraits don't contain `Self`,\n         // to avoid ICEs.\n-        let object_safety_violations =\n-            tcx.global_tcx().astconv_object_safety_violations(principal.def_id());\n-        if !object_safety_violations.is_empty() {\n-            tcx.report_object_safety_error(span, principal.def_id(), object_safety_violations)\n-                .map(|mut err| err.emit());\n-            return tcx.types.err;\n+        for item in &regular_traits {\n+            let object_safety_violations =\n+                tcx.global_tcx().astconv_object_safety_violations(item.trait_ref().def_id());\n+            if !object_safety_violations.is_empty() {\n+                tcx.report_object_safety_error(\n+                    span,\n+                    item.trait_ref().def_id(),\n+                    object_safety_violations\n+                )\n+                    .map(|mut err| err.emit());\n+                return tcx.types.err;\n+            }\n         }\n \n         // Use a `BTreeSet` to keep output in a more consistent order.\n         let mut associated_types = BTreeSet::default();\n \n-        for tr in traits::elaborate_trait_ref(tcx, principal) {\n-            debug!(\"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\", tr);\n-            match tr {\n+        let regular_traits_refs = bound_trait_refs\n+            .into_iter()\n+            .filter(|(trait_ref, _)| !tcx.trait_is_auto(trait_ref.def_id()))\n+            .map(|(trait_ref, _)| trait_ref);\n+        for trait_ref in traits::elaborate_trait_refs(tcx, regular_traits_refs) {\n+            debug!(\"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\", trait_ref);\n+            match trait_ref {\n                 ty::Predicate::Trait(pred) => {\n                     associated_types\n                         .extend(tcx.associated_items(pred.def_id())\n@@ -1102,20 +1095,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 if associated_types.len() == 1 { \"\" } else { \"s\" },\n                 names,\n             );\n-            let mut suggest = false;\n-            let mut potential_assoc_types_spans = vec![];\n-            if let Some(potential_assoc_types) = potential_assoc_types {\n+            let (suggest, potential_assoc_types_spans) =\n                 if potential_assoc_types.len() == associated_types.len() {\n-                    // Only suggest when the amount of missing associated types is equals to the\n+                    // Only suggest when the amount of missing associated types equals the number of\n                     // extra type arguments present, as that gives us a relatively high confidence\n                     // that the user forgot to give the associtated type's name. The canonical\n                     // example would be trying to use `Iterator<isize>` instead of\n-                    // `Iterator<Item=isize>`.\n-                    suggest = true;\n-                    potential_assoc_types_spans = potential_assoc_types;\n-                }\n-            }\n-            let mut suggestions = vec![];\n+                    // `Iterator<Item = isize>`.\n+                    (true, potential_assoc_types)\n+                } else {\n+                    (false, Vec::new())\n+                };\n+            let mut suggestions = Vec::new();\n             for (i, item_def_id) in associated_types.iter().enumerate() {\n                 let assoc_item = tcx.associated_item(*item_def_id);\n                 err.span_label(\n@@ -1151,9 +1142,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             err.emit();\n         }\n \n+        // De-duplicate auto traits so that, e.g., `dyn Trait + Send + Send` is the same as\n+        // `dyn Trait + Send`.\n+        auto_traits.sort_by_key(|i| i.trait_ref().def_id());\n+        auto_traits.dedup_by_key(|i| i.trait_ref().def_id());\n+        debug!(\"regular_traits: {:?}\", regular_traits);\n+        debug!(\"auto_traits: {:?}\", auto_traits);\n+\n         // Erase the `dummy_self` (`trait_object_dummy_self`) used above.\n-        let existential_principal = principal.map_bound(|trait_ref| {\n-            self.trait_ref_to_existential(trait_ref)\n+        let existential_trait_refs = regular_traits.iter().map(|i| {\n+            i.trait_ref().map_bound(|trait_ref| self.trait_ref_to_existential(trait_ref))\n         });\n         let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n             bound.map_bound(|b| {\n@@ -1166,21 +1164,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             })\n         });\n \n-        // De-duplicate auto traits so that, e.g., `dyn Trait + Send + Send` is the same as\n-        // `dyn Trait + Send`.\n-        auto_traits.sort();\n-        auto_traits.dedup();\n-        debug!(\"auto_traits: {:?}\", auto_traits);\n-\n         // Calling `skip_binder` is okay because the predicates are re-bound.\n-        let principal = if tcx.trait_is_auto(existential_principal.def_id()) {\n-            ty::ExistentialPredicate::AutoTrait(existential_principal.def_id())\n-        } else {\n-            ty::ExistentialPredicate::Trait(*existential_principal.skip_binder())\n-        };\n+        let regular_trait_predicates = existential_trait_refs.map(\n+            |trait_ref| ty::ExistentialPredicate::Trait(*trait_ref.skip_binder()));\n+        let auto_trait_predicates = auto_traits.into_iter().map(\n+            |trait_ref| ty::ExistentialPredicate::AutoTrait(trait_ref.trait_ref().def_id()));\n         let mut v =\n-            iter::once(principal)\n-            .chain(auto_traits.into_iter().map(ty::ExistentialPredicate::AutoTrait))\n+            regular_trait_predicates\n+            .chain(auto_trait_predicates)\n             .chain(existential_projections\n                 .map(|x| ty::ExistentialPredicate::Projection(*x.skip_binder())))\n             .collect::<SmallVec<[_; 8]>>();"}]}