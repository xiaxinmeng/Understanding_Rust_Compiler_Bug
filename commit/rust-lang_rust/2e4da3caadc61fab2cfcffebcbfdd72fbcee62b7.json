{"sha": "2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlNGRhM2NhYWRjNjFmYWIyY2ZjZmZlYmNiZmRkNzJmYmNlZTYyYjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-05T05:47:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-05T05:47:31Z"}, "message": "Auto merge of #65938 - eddyb:fn-abi-rename, r=oli-obk\n\nrustc_target: rename {Fn,Arg}Type to {Fn,Arg}Abi.\n\nI was trying to tweak the API of `FnType` (now `FnAbi`) and the name kept bothering me.\n\n`FnAbi` is to a function signature a bit like a layout is to a type, so the name still isn't perfect yet, but at least it doesn't have the misleading `Type` in it anymore.\n\nIf this can't land I think I can continue my original refactor without it, so I'm not strongly attached to it.\n\nr? @nagisa cc @oli-obk", "tree": {"sha": "c5a043dd98368807b1243e4ad73e34ac7789e61e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5a043dd98368807b1243e4ad73e34ac7789e61e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "html_url": "https://github.com/rust-lang/rust/commit/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2185f6752d3e9db6a0330f1a43c27a370783ac8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2185f6752d3e9db6a0330f1a43c27a370783ac8", "html_url": "https://github.com/rust-lang/rust/commit/d2185f6752d3e9db6a0330f1a43c27a370783ac8"}, {"sha": "8b06209c2883906427978305b854faa90e61a5c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b06209c2883906427978305b854faa90e61a5c0", "html_url": "https://github.com/rust-lang/rust/commit/8b06209c2883906427978305b854faa90e61a5c0"}], "stats": {"total": 622, "additions": 311, "deletions": 311}, "files": [{"sha": "95040135eb7d3984c890a8c9de49f0ab0338199a", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -23,7 +23,7 @@ use rustc_index::vec::{IndexVec, Idx};\n pub use rustc_target::abi::*;\n use rustc_target::spec::{HasTargetSpec, abi::Abi as SpecAbi};\n use rustc_target::abi::call::{\n-    ArgAttribute, ArgAttributes, ArgType, Conv, FnType, PassMode, Reg, RegKind\n+    ArgAttribute, ArgAttributes, ArgAbi, Conv, FnAbi, PassMode, Reg, RegKind\n };\n \n pub trait IntegerExt {\n@@ -2487,7 +2487,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for LayoutError<'tcx> {\n     }\n }\n \n-pub trait FnTypeExt<'tcx, C>\n+pub trait FnAbiExt<'tcx, C>\n where\n     C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n         + HasDataLayout\n@@ -2502,12 +2502,12 @@ where\n         cx: &C,\n         sig: ty::FnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n+        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgAbi<'tcx, Ty<'tcx>>,\n     ) -> Self;\n     fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n }\n \n-impl<'tcx, C> FnTypeExt<'tcx, C> for call::FnType<'tcx, Ty<'tcx>>\n+impl<'tcx, C> FnAbiExt<'tcx, C> for call::FnAbi<'tcx, Ty<'tcx>>\n where\n     C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n         + HasDataLayout\n@@ -2520,15 +2520,15 @@ where\n         let sig = cx\n             .tcx()\n             .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        call::FnType::new(cx, sig, &[])\n+        call::FnAbi::new(cx, sig, &[])\n     }\n \n     fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        call::FnType::new_internal(cx, sig, extra_args, |ty, _| ArgType::new(cx.layout_of(ty)))\n+        call::FnAbi::new_internal(cx, sig, extra_args, |ty, _| ArgAbi::new(cx.layout_of(ty)))\n     }\n \n     fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        FnTypeExt::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n+        FnAbiExt::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n             let mut layout = cx.layout_of(ty);\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n             // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n@@ -2578,17 +2578,17 @@ where\n                 layout = cx.layout_of(unit_pointer_ty);\n                 layout.ty = fat_pointer_ty;\n             }\n-            ArgType::new(layout)\n+            ArgAbi::new(layout)\n         })\n     }\n \n     fn new_internal(\n         cx: &C,\n         sig: ty::FnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n+        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgAbi<'tcx, Ty<'tcx>>,\n     ) -> Self {\n-        debug!(\"FnType::new_internal({:?}, {:?})\", sig, extra_args);\n+        debug!(\"FnAbi::new_internal({:?}, {:?})\", sig, extra_args);\n \n         use rustc_target::spec::abi::Abi::*;\n         let conv = match cx.tcx().sess.target.target.adjust_abi(sig.abi) {\n@@ -2741,7 +2741,7 @@ where\n             arg\n         };\n \n-        let mut fn_ty = FnType {\n+        let mut fn_abi = FnAbi {\n             ret: arg_of(sig.output(), None),\n             args: inputs\n                 .iter()\n@@ -2753,8 +2753,8 @@ where\n             c_variadic: sig.c_variadic,\n             conv,\n         };\n-        fn_ty.adjust_for_abi(cx, sig.abi);\n-        fn_ty\n+        fn_abi.adjust_for_abi(cx, sig.abi);\n+        fn_abi\n     }\n \n     fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi) {\n@@ -2767,7 +2767,7 @@ where\n             || abi == SpecAbi::RustIntrinsic\n             || abi == SpecAbi::PlatformIntrinsic\n         {\n-            let fixup = |arg: &mut ArgType<'tcx, Ty<'tcx>>| {\n+            let fixup = |arg: &mut ArgAbi<'tcx, Ty<'tcx>>| {\n                 if arg.is_ignore() {\n                     return;\n                 }"}, {"sha": "287d5705de8c7e3bd7089dbfee1ce799ffd329fe", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -7,7 +7,7 @@ use crate::type_of::{LayoutLlvmExt};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::mir::operand::OperandValue;\n-use rustc_target::abi::call::ArgType;\n+use rustc_target::abi::call::ArgAbi;\n \n use rustc_codegen_ssa::traits::*;\n \n@@ -163,7 +163,7 @@ impl LlvmType for CastTarget {\n     }\n }\n \n-pub trait ArgTypeExt<'ll, 'tcx> {\n+pub trait ArgAbiExt<'ll, 'tcx> {\n     fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn store(\n         &self,\n@@ -179,14 +179,14 @@ pub trait ArgTypeExt<'ll, 'tcx> {\n     );\n }\n \n-impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n+impl ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     /// Gets the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e., the result of `type_of::type_of`.\n     fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         self.layout.llvm_type(cx)\n     }\n \n-    /// Stores a direct/indirect value described by this ArgType into a\n+    /// Stores a direct/indirect value described by this ArgAbi into a\n     /// place for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n@@ -202,7 +202,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n         if self.is_sized_indirect() {\n             OperandValue::Ref(val, None, self.layout.align.abi).store(bx, dst)\n         } else if self.is_unsized_indirect() {\n-            bug!(\"unsized ArgType must be handled through store_fn_arg\");\n+            bug!(\"unsized ArgAbi must be handled through store_fn_arg\");\n         } else if let PassMode::Cast(cast) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n@@ -279,36 +279,36 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     }\n }\n \n-impl ArgTypeMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+impl ArgAbiMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn store_fn_arg(\n         &mut self,\n-        ty: &ArgType<'tcx, Ty<'tcx>>,\n+        arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n         idx: &mut usize, dst: PlaceRef<'tcx, Self::Value>\n     ) {\n-        ty.store_fn_arg(self, idx, dst)\n+        arg_abi.store_fn_arg(self, idx, dst)\n     }\n-    fn store_arg_ty(\n+    fn store_arg(\n         &mut self,\n-        ty: &ArgType<'tcx, Ty<'tcx>>,\n+        arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n         val: &'ll Value,\n         dst: PlaceRef<'tcx, &'ll Value>\n     ) {\n-        ty.store(self, val, dst)\n+        arg_abi.store(self, val, dst)\n     }\n-    fn memory_ty(&self, ty: &ArgType<'tcx, Ty<'tcx>>) -> &'ll Type {\n-        ty.memory_ty(self)\n+    fn arg_memory_ty(&self, arg_abi: &ArgAbi<'tcx, Ty<'tcx>>) -> &'ll Type {\n+        arg_abi.memory_ty(self)\n     }\n }\n \n-pub trait FnTypeLlvmExt<'tcx> {\n+pub trait FnAbiLlvmExt<'tcx> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn ptr_to_llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n     fn apply_attrs_llfn(&self, cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value);\n     fn apply_attrs_callsite(&self, bx: &mut Builder<'a, 'll, 'tcx>, callsite: &'ll Value);\n }\n \n-impl<'tcx> FnTypeLlvmExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n+impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         let args_capacity: usize = self.args.iter().map(|arg|\n             if arg.pad.is_some() { 1 } else { 0 } +\n@@ -478,10 +478,10 @@ impl<'tcx> FnTypeLlvmExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n impl AbiBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn apply_attrs_callsite(\n         &mut self,\n-        ty: &FnType<'tcx, Ty<'tcx>>,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         callsite: Self::Value\n     ) {\n-        ty.apply_attrs_callsite(self, callsite)\n+        fn_abi.apply_attrs_callsite(self, callsite)\n     }\n \n     fn get_param(&self, index: usize) -> Self::Value {"}, {"sha": "46cdd2aaa961424de265521d95a4ce14294a5530", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -13,13 +13,13 @@\n \n use crate::llvm;\n use crate::llvm::AttributePlace::Function;\n-use crate::abi::{FnType, FnTypeLlvmExt};\n+use crate::abi::{FnAbi, FnAbiLlvmExt};\n use crate::attributes;\n use crate::context::CodegenCx;\n use crate::type_::Type;\n use crate::value::Value;\n use rustc::ty::{self, PolyFnSig};\n-use rustc::ty::layout::{FnTypeExt, LayoutOf};\n+use rustc::ty::layout::{FnAbiExt, LayoutOf};\n use rustc::session::config::Sanitizer;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_codegen_ssa::traits::*;\n@@ -100,14 +100,14 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let sig = self.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n-        let fty = FnType::new(self, sig, &[]);\n-        let llfn = declare_raw_fn(self, name, fty.llvm_cconv(), fty.llvm_type(self));\n+        let fn_abi = FnAbi::new(self, sig, &[]);\n+        let llfn = declare_raw_fn(self, name, fn_abi.llvm_cconv(), fn_abi.llvm_type(self));\n \n         if self.layout_of(sig.output()).abi.is_uninhabited() {\n             llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n         }\n \n-        fty.apply_attrs_llfn(self, llfn);\n+        fn_abi.apply_attrs_llfn(self, llfn);\n \n         llfn\n     }"}, {"sha": "1bce34abe55993a474cfccf87f80b0b4710b363c", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,7 +1,7 @@\n use crate::attributes;\n use crate::llvm;\n use crate::llvm_util;\n-use crate::abi::{Abi, FnType, LlvmType, PassMode};\n+use crate::abi::{Abi, FnAbi, LlvmType, PassMode};\n use crate::context::CodegenCx;\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n@@ -84,7 +84,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn codegen_intrinsic_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        fn_ty: &FnType<'tcx, Ty<'tcx>>,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         args: &[OperandRef<'tcx, &'ll Value>],\n         llresult: &'ll Value,\n         span: Span,\n@@ -104,7 +104,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let name = &*tcx.item_name(def_id).as_str();\n \n         let llret_ty = self.layout_of(ret_ty).llvm_type(self);\n-        let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout);\n+        let result = PlaceRef::new_sized(llresult, fn_abi.ret.layout);\n \n         let simple = get_simple_intrinsic(self, name);\n         let llval = match name {\n@@ -147,7 +147,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.call(intrinsic, &[args[0].immediate(), args[1].immediate()], None)\n             }\n             \"va_arg\" => {\n-                match fn_ty.ret.layout.abi {\n+                match fn_abi.ret.layout.abi {\n                     layout::Abi::Scalar(ref scalar) => {\n                         match scalar.value {\n                             Primitive::Int(..) => {\n@@ -276,7 +276,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             \"volatile_load\" | \"unaligned_volatile_load\" => {\n                 let tp_ty = substs.type_at(0);\n                 let mut ptr = args[0].immediate();\n-                if let PassMode::Cast(ty) = fn_ty.ret.mode {\n+                if let PassMode::Cast(ty) = fn_abi.ret.mode {\n                     ptr = self.pointercast(ptr, self.type_ptr_to(ty.llvm_type(self)));\n                 }\n                 let load = self.volatile_load(ptr);\n@@ -715,8 +715,8 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             _ => bug!(\"unknown intrinsic '{}'\", name),\n         };\n \n-        if !fn_ty.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = fn_ty.ret.mode {\n+        if !fn_abi.ret.is_ignore() {\n+            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n                 let ptr_llty = self.type_ptr_to(ty.llvm_type(self));\n                 let ptr = self.pointercast(result.llval, ptr_llty);\n                 self.store(llval, ptr, result.align);"}, {"sha": "f936367572ea0e34ec51264665ab52df7704cf55", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -8,11 +8,11 @@ use rustc_codegen_ssa::traits::*;\n \n use crate::common;\n use crate::type_of::LayoutLlvmExt;\n-use crate::abi::{LlvmType, FnTypeLlvmExt};\n+use crate::abi::{LlvmType, FnAbiLlvmExt};\n use syntax::ast;\n use rustc::ty::Ty;\n use rustc::ty::layout::{self, Align, Size, TyLayout};\n-use rustc_target::abi::call::{CastTarget, FnType, Reg};\n+use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_codegen_ssa::common::TypeKind;\n \n@@ -243,7 +243,7 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n     fn type_ptr_to(&self, ty: &'ll Type) -> &'ll Type {\n         assert_ne!(self.type_kind(ty), TypeKind::Function,\n-                   \"don't call ptr_to on function types, use ptr_to_llvm_type on FnType instead\");\n+                   \"don't call ptr_to on function types, use ptr_to_llvm_type on FnAbi instead\");\n         ty.ptr_to()\n     }\n \n@@ -336,8 +336,8 @@ impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn cast_backend_type(&self, ty: &CastTarget) -> &'ll Type {\n         ty.llvm_type(self)\n     }\n-    fn fn_ptr_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Type {\n-        ty.ptr_to_llvm_type(self)\n+    fn fn_ptr_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Type {\n+        fn_abi.ptr_to_llvm_type(self)\n     }\n     fn reg_backend_type(&self, ty: &Reg) -> &'ll Type {\n         ty.llvm_type(self)"}, {"sha": "dc68872ede11c664a179ed2059ca65590035f14c", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,8 +1,8 @@\n-use crate::abi::{FnType};\n+use crate::abi::{FnAbi};\n use crate::common::*;\n use crate::type_::Type;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, LayoutOf, FnTypeExt, PointeeInfo, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, FnAbiExt, PointeeInfo, Size, TyLayout};\n use rustc_target::abi::{FloatTy, TyLayoutMethods};\n use rustc::ty::print::obsolete::DefPathBasedNames;\n use rustc_codegen_ssa::traits::*;\n@@ -239,7 +239,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                         ty::ParamEnv::reveal_all(),\n                         &sig,\n                     );\n-                    cx.fn_ptr_backend_type(&FnType::new(cx, sig, &[]))\n+                    cx.fn_ptr_backend_type(&FnAbi::new(cx, sig, &[]))\n                 }\n                 _ => self.scalar_llvm_type_at(cx, scalar, Size::ZERO)\n             };"}, {"sha": "692027390ec1b04eb157f1f04bd27dda6630eb88", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,4 +1,4 @@\n-use rustc_target::abi::call::FnType;\n+use rustc_target::abi::call::FnAbi;\n \n use crate::traits::*;\n \n@@ -20,14 +20,14 @@ impl<'a, 'tcx> VirtualIndex {\n         self,\n         bx: &mut Bx,\n         llvtable: Bx::Value,\n-        fn_ty: &FnType<'tcx, Ty<'tcx>>\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>\n     ) -> Bx::Value {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n \n         let llvtable = bx.pointercast(\n             llvtable,\n-            bx.type_ptr_to(bx.fn_ptr_backend_type(fn_ty))\n+            bx.type_ptr_to(bx.fn_ptr_backend_type(fn_abi))\n         );\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let gep = bx.inbounds_gep(llvtable, &[bx.const_usize(self.0)]);"}, {"sha": "07e904300a69655c70a31f5770c8f6b99484b7e2", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,10 +1,10 @@\n use rustc_index::vec::Idx;\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable, Instance};\n-use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, FnTypeExt};\n+use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, FnAbiExt};\n use rustc::mir::{self, PlaceBase, Static, StaticKind};\n use rustc::mir::interpret::PanicInfo;\n-use rustc_target::abi::call::{ArgType, FnType, PassMode};\n+use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::spec::abi::Abi;\n use crate::base;\n use crate::MemFlags;\n@@ -99,13 +99,13 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n         }\n     }\n \n-    /// Call `fn_ptr` of `fn_ty` with the arguments `llargs`, the optional\n+    /// Call `fn_ptr` of `fn_abi` with the arguments `llargs`, the optional\n     /// return destination `destination` and the cleanup function `cleanup`.\n     fn do_call<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n         &self,\n         fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n         bx: &mut Bx,\n-        fn_ty: FnType<'tcx, Ty<'tcx>>,\n+        fn_abi: FnAbi<'tcx, Ty<'tcx>>,\n         fn_ptr: Bx::Value,\n         llargs: &[Bx::Value],\n         destination: Option<(ReturnDest<'tcx, Bx::Value>, mir::BasicBlock)>,\n@@ -122,16 +122,16 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n                                       ret_bx,\n                                       self.llblock(fx, cleanup),\n                                       self.funclet(fx));\n-            bx.apply_attrs_callsite(&fn_ty, invokeret);\n+            bx.apply_attrs_callsite(&fn_abi, invokeret);\n \n             if let Some((ret_dest, target)) = destination {\n                 let mut ret_bx = fx.build_block(target);\n                 fx.set_debug_loc(&mut ret_bx, self.terminator.source_info);\n-                fx.store_return(&mut ret_bx, ret_dest, &fn_ty.ret, invokeret);\n+                fx.store_return(&mut ret_bx, ret_dest, &fn_abi.ret, invokeret);\n             }\n         } else {\n             let llret = bx.call(fn_ptr, &llargs, self.funclet(fx));\n-            bx.apply_attrs_callsite(&fn_ty, llret);\n+            bx.apply_attrs_callsite(&fn_abi, llret);\n             if fx.mir[*self.bb].is_cleanup {\n                 // Cleanup is always the cold path. Don't inline\n                 // drop glue. Also, when there is a deeply-nested\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n             }\n \n             if let Some((ret_dest, target)) = destination {\n-                fx.store_return(bx, ret_dest, &fn_ty.ret, llret);\n+                fx.store_return(bx, ret_dest, &fn_abi.ret, llret);\n                 self.funclet_br(fx, bx, target);\n             } else {\n                 bx.unreachable();\n@@ -248,24 +248,24 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     fn codegen_return_terminator(&mut self, mut bx: Bx) {\n         // Call `va_end` if this is the definition of a C-variadic function.\n-        if self.fn_ty.c_variadic {\n+        if self.fn_abi.c_variadic {\n             // The `VaList` \"spoofed\" argument is just after all the real arguments.\n-            let va_list_arg_idx = self.fn_ty.args.len();\n+            let va_list_arg_idx = self.fn_abi.args.len();\n             match self.locals[mir::Local::new(1 + va_list_arg_idx)] {\n                 LocalRef::Place(va_list) => {\n                     bx.va_end(va_list.llval);\n                 }\n                 _ => bug!(\"C-variadic function must have a `VaList` place\"),\n             }\n         }\n-        if self.fn_ty.ret.layout.abi.is_uninhabited() {\n+        if self.fn_abi.ret.layout.abi.is_uninhabited() {\n             // Functions with uninhabited return values are marked `noreturn`,\n             // so we should make sure that we never actually do.\n             bx.abort();\n             bx.unreachable();\n             return;\n         }\n-        let llval = match self.fn_ty.ret.mode {\n+        let llval = match self.fn_abi.ret.mode {\n             PassMode::Ignore | PassMode::Indirect(..) => {\n                 bx.ret_void();\n                 return;\n@@ -296,7 +296,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let llslot = match op.val {\n                     Immediate(_) | Pair(..) => {\n                         let scratch =\n-                            PlaceRef::alloca(&mut bx, self.fn_ty.ret.layout);\n+                            PlaceRef::alloca(&mut bx, self.fn_abi.ret.layout);\n                         op.val.store(&mut bx, scratch);\n                         scratch.llval\n                     }\n@@ -309,7 +309,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let addr = bx.pointercast(llslot, bx.type_ptr_to(\n                     bx.cast_backend_type(&cast_ty)\n                 ));\n-                bx.load(addr, self.fn_ty.ret.layout.align.abi)\n+                bx.load(addr, self.fn_abi.ret.layout.align.abi)\n             }\n         };\n         bx.ret(llval);\n@@ -344,25 +344,25 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             args1 = [place.llval];\n             &args1[..]\n         };\n-        let (drop_fn, fn_ty) = match ty.kind {\n+        let (drop_fn, fn_abi) = match ty.kind {\n             ty::Dynamic(..) => {\n                 let sig = drop_fn.fn_sig(self.cx.tcx());\n                 let sig = self.cx.tcx().normalize_erasing_late_bound_regions(\n                     ty::ParamEnv::reveal_all(),\n                     &sig,\n                 );\n-                let fn_ty = FnType::new_vtable(&bx, sig, &[]);\n+                let fn_abi = FnAbi::new_vtable(&bx, sig, &[]);\n                 let vtable = args[1];\n                 args = &args[..1];\n-                (meth::DESTRUCTOR.get_fn(&mut bx, vtable, &fn_ty), fn_ty)\n+                (meth::DESTRUCTOR.get_fn(&mut bx, vtable, &fn_abi), fn_abi)\n             }\n             _ => {\n                 (bx.get_fn_addr(drop_fn),\n-                 FnType::of_instance(&bx, drop_fn))\n+                 FnAbi::of_instance(&bx, drop_fn))\n             }\n         };\n         helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n-        helper.do_call(self, &mut bx, fn_ty, drop_fn, args,\n+        helper.do_call(self, &mut bx, fn_abi, drop_fn, args,\n                        Some((ReturnDest::Nothing, target)),\n                        unwind);\n     }\n@@ -439,11 +439,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Obtain the panic entry point.\n         let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n         let instance = ty::Instance::mono(bx.tcx(), def_id);\n-        let fn_ty = FnType::of_instance(&bx, instance);\n+        let fn_abi = FnAbi::of_instance(&bx, instance);\n         let llfn = bx.get_fn_addr(instance);\n \n         // Codegen the actual panic invoke/call.\n-        helper.do_call(self, &mut bx, fn_ty, llfn, &args, None, cleanup);\n+        helper.do_call(self, &mut bx, fn_abi, llfn, &args, None, cleanup);\n     }\n \n     fn codegen_call_terminator<'b>(\n@@ -514,9 +514,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             self.monomorphize(&op_ty)\n         }).collect::<Vec<_>>();\n \n-        let fn_ty = match def {\n+        let fn_abi = match def {\n             Some(ty::InstanceDef::Virtual(..)) => {\n-                FnType::new_vtable(&bx, sig, &extra_args)\n+                FnAbi::new_vtable(&bx, sig, &extra_args)\n             }\n             Some(ty::InstanceDef::DropGlue(_, None)) => {\n                 // Empty drop glue; a no-op.\n@@ -525,7 +525,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 helper.funclet_br(self, &mut bx, target);\n                 return;\n             }\n-            _ => FnType::new(&bx, sig, &extra_args)\n+            _ => FnAbi::new(&bx, sig, &extra_args)\n         };\n \n         // Emit a panic or a no-op for `panic_if_uninhabited`.\n@@ -541,7 +541,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let def_id =\n                     common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let fn_ty = FnType::of_instance(&bx, instance);\n+                let fn_abi = FnAbi::of_instance(&bx, instance);\n                 let llfn = bx.get_fn_addr(instance);\n \n                 if let Some((_, target)) = destination.as_ref() {\n@@ -551,7 +551,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 helper.do_call(\n                     self,\n                     &mut bx,\n-                    fn_ty,\n+                    fn_abi,\n                     llfn,\n                     &[msg.0, msg.1, location],\n                     destination.as_ref().map(|(_, bb)| (ReturnDest::Nothing, *bb)),\n@@ -567,13 +567,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n \n         // The arguments we'll be passing. Plus one to account for outptr, if used.\n-        let arg_count = fn_ty.args.len() + fn_ty.ret.is_indirect() as usize;\n+        let arg_count = fn_abi.args.len() + fn_abi.ret.is_indirect() as usize;\n         let mut llargs = Vec::with_capacity(arg_count);\n \n         // Prepare the return value destination\n         let ret_dest = if let Some((ref dest, _)) = *destination {\n             let is_intrinsic = intrinsic.is_some();\n-            self.make_return_dest(&mut bx, dest, &fn_ty.ret, &mut llargs,\n+            self.make_return_dest(&mut bx, dest, &fn_abi.ret, &mut llargs,\n                                   is_intrinsic)\n         } else {\n             ReturnDest::Nothing\n@@ -586,7 +586,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 if let ReturnDest::IndirectOperand(tmp, _) = ret_dest {\n                     location.val.store(&mut bx, tmp);\n                 }\n-                self.store_return(&mut bx, ret_dest, &fn_ty.ret, location.immediate());\n+                self.store_return(&mut bx, ret_dest, &fn_abi.ret, location.immediate());\n \n                 helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n                 helper.funclet_br(self, &mut bx, *target);\n@@ -596,9 +596,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n             let dest = match ret_dest {\n-                _ if fn_ty.ret.is_indirect() => llargs[0],\n+                _ if fn_abi.ret.is_indirect() => llargs[0],\n                 ReturnDest::Nothing =>\n-                    bx.const_undef(bx.type_ptr_to(bx.memory_ty(&fn_ty.ret))),\n+                    bx.const_undef(bx.type_ptr_to(bx.arg_memory_ty(&fn_abi.ret))),\n                 ReturnDest::IndirectOperand(dst, _) | ReturnDest::Store(dst) =>\n                     dst.llval,\n                 ReturnDest::DirectOperand(_) =>\n@@ -667,11 +667,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }).collect();\n \n \n-            bx.codegen_intrinsic_call(*instance.as_ref().unwrap(), &fn_ty, &args, dest,\n+            bx.codegen_intrinsic_call(*instance.as_ref().unwrap(), &fn_abi, &args, dest,\n                                       terminator.source_info.span);\n \n             if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                self.store_return(&mut bx, ret_dest, &fn_ty.ret, dst.llval);\n+                self.store_return(&mut bx, ret_dest, &fn_abi.ret, dst.llval);\n             }\n \n             if let Some((_, target)) = *destination {\n@@ -726,7 +726,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     match op.val {\n                         Pair(data_ptr, meta) => {\n                             llfn = Some(meth::VirtualIndex::from_index(idx)\n-                                .get_fn(&mut bx, meta, &fn_ty));\n+                                .get_fn(&mut bx, meta, &fn_abi));\n                             llargs.push(data_ptr);\n                             continue 'make_args\n                         }\n@@ -735,7 +735,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 } else if let Ref(data_ptr, Some(meta), _) = op.val {\n                     // by-value dynamic dispatch\n                     llfn = Some(meth::VirtualIndex::from_index(idx)\n-                        .get_fn(&mut bx, meta, &fn_ty));\n+                        .get_fn(&mut bx, meta, &fn_abi));\n                     llargs.push(data_ptr);\n                     continue;\n                 } else {\n@@ -755,11 +755,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 _ => {}\n             }\n \n-            self.codegen_argument(&mut bx, op, &mut llargs, &fn_ty.args[i]);\n+            self.codegen_argument(&mut bx, op, &mut llargs, &fn_abi.args[i]);\n         }\n         if let Some(tup) = untuple {\n             self.codegen_arguments_untupled(&mut bx, tup, &mut llargs,\n-                &fn_ty.args[first_args.len()..])\n+                &fn_abi.args[first_args.len()..])\n         }\n \n         let fn_ptr = match (llfn, instance) {\n@@ -771,7 +771,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if let Some((_, target)) = destination.as_ref() {\n             helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n         }\n-        helper.do_call(self, &mut bx, fn_ty, fn_ptr, &llargs,\n+        helper.do_call(self, &mut bx, fn_abi, fn_ptr, &llargs,\n                        destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                        cleanup);\n     }\n@@ -874,7 +874,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &mut Bx,\n         op: OperandRef<'tcx, Bx::Value>,\n         llargs: &mut Vec<Bx::Value>,\n-        arg: &ArgType<'tcx, Ty<'tcx>>\n+        arg: &ArgAbi<'tcx, Ty<'tcx>>\n     ) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n@@ -967,7 +967,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &mut Bx,\n         operand: &mir::Operand<'tcx>,\n         llargs: &mut Vec<Bx::Value>,\n-        args: &[ArgType<'tcx, Ty<'tcx>>]\n+        args: &[ArgAbi<'tcx, Ty<'tcx>>]\n     ) {\n         let tuple = self.codegen_operand(bx, operand);\n \n@@ -1095,7 +1095,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         &mut self,\n         bx: &mut Bx,\n         dest: &mir::Place<'tcx>,\n-        fn_ret: &ArgType<'tcx, Ty<'tcx>>,\n+        fn_ret: &ArgAbi<'tcx, Ty<'tcx>>,\n         llargs: &mut Vec<Bx::Value>, is_intrinsic: bool\n     ) -> ReturnDest<'tcx, Bx::Value> {\n         // If the return is ignored, we can just return a do-nothing `ReturnDest`.\n@@ -1204,30 +1204,30 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         &mut self,\n         bx: &mut Bx,\n         dest: ReturnDest<'tcx, Bx::Value>,\n-        ret_ty: &ArgType<'tcx, Ty<'tcx>>,\n+        ret_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n         llval: Bx::Value\n     ) {\n         use self::ReturnDest::*;\n \n         match dest {\n             Nothing => (),\n-            Store(dst) => bx.store_arg_ty(&ret_ty, llval, dst),\n+            Store(dst) => bx.store_arg(&ret_abi, llval, dst),\n             IndirectOperand(tmp, index) => {\n                 let op = bx.load_operand(tmp);\n                 tmp.storage_dead(bx);\n                 self.locals[index] = LocalRef::Operand(Some(op));\n             }\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n-                let op = if let PassMode::Cast(_) = ret_ty.mode {\n-                    let tmp = PlaceRef::alloca(bx, ret_ty.layout);\n+                let op = if let PassMode::Cast(_) = ret_abi.mode {\n+                    let tmp = PlaceRef::alloca(bx, ret_abi.layout);\n                     tmp.storage_live(bx);\n-                    bx.store_arg_ty(&ret_ty, llval, tmp);\n+                    bx.store_arg(&ret_abi, llval, tmp);\n                     let op = bx.load_operand(tmp);\n                     tmp.storage_dead(bx);\n                     op\n                 } else {\n-                    OperandRef::from_immediate_or_packed_pair(bx, llval, ret_ty.layout)\n+                    OperandRef::from_immediate_or_packed_pair(bx, llval, ret_abi.layout)\n                 };\n                 self.locals[index] = LocalRef::Operand(Some(op));\n             }"}, {"sha": "fec31f07a349b73c8a8f7bee06091de23b5a0922", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,7 +1,7 @@\n use rustc::ty::{self, Ty, TypeFoldable, Instance};\n-use rustc::ty::layout::{TyLayout, HasTyCtxt, FnTypeExt};\n+use rustc::ty::layout::{TyLayout, HasTyCtxt, FnAbiExt};\n use rustc::mir::{self, Body};\n-use rustc_target::abi::call::{FnType, PassMode};\n+use rustc_target::abi::call::{FnAbi, PassMode};\n use crate::base;\n use crate::traits::*;\n \n@@ -29,7 +29,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n \n     cx: &'a Bx::CodegenCx,\n \n-    fn_ty: FnType<'tcx, Ty<'tcx>>,\n+    fn_abi: FnAbi<'tcx, Ty<'tcx>>,\n \n     /// When unwinding is initiated, we have to store this personality\n     /// value somewhere so that we can load it and re-use it in the\n@@ -126,8 +126,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n ) {\n     assert!(!instance.substs.needs_infer());\n \n-    let fn_ty = FnType::new(cx, sig, &[]);\n-    debug!(\"fn_ty: {:?}\", fn_ty);\n+    let fn_abi = FnAbi::new(cx, sig, &[]);\n+    debug!(\"fn_abi: {:?}\", fn_abi);\n \n     let debug_context =\n         cx.create_function_debug_context(instance, sig, llfn, mir);\n@@ -159,7 +159,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         instance,\n         mir,\n         llfn,\n-        fn_ty,\n+        fn_abi,\n         cx,\n         personality_slot: None,\n         blocks: block_bxs,\n@@ -183,7 +183,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let layout = bx.layout_of(fx.monomorphize(&decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n-            if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n+            if local == mir::RETURN_PLACE && fx.fn_abi.ret.is_indirect() {\n                 debug!(\"alloc: {:?} (return place) -> place\", local);\n                 let llretptr = bx.get_param(0);\n                 return LocalRef::Place(PlaceRef::new_sized(llretptr, layout));\n@@ -323,7 +323,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n ) -> Vec<LocalRef<'tcx, Bx::Value>> {\n     let mir = fx.mir;\n     let mut idx = 0;\n-    let mut llarg_idx = fx.fn_ty.ret.is_indirect() as usize;\n+    let mut llarg_idx = fx.fn_abi.ret.is_indirect() as usize;\n \n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n@@ -342,7 +342,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n             let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n             for i in 0..tupled_arg_tys.len() {\n-                let arg = &fx.fn_ty.args[idx];\n+                let arg = &fx.fn_abi.args[idx];\n                 idx += 1;\n                 if arg.pad.is_some() {\n                     llarg_idx += 1;\n@@ -354,7 +354,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             return LocalRef::Place(place);\n         }\n \n-        if fx.fn_ty.c_variadic && arg_index == fx.fn_ty.args.len() {\n+        if fx.fn_abi.c_variadic && arg_index == fx.fn_abi.args.len() {\n             let arg_ty = fx.monomorphize(&arg_decl.ty);\n \n             let va_list = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n@@ -363,7 +363,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             return LocalRef::Place(va_list);\n         }\n \n-        let arg = &fx.fn_ty.args[idx];\n+        let arg = &fx.fn_abi.args[idx];\n         idx += 1;\n         if arg.pad.is_some() {\n             llarg_idx += 1;"}, {"sha": "fb44a69ce05525b30112e6d82334429142a523df", "filename": "src/librustc_codegen_ssa/traits/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,8 +1,8 @@\n use super::BackendTypes;\n use rustc::ty::{Ty};\n-use rustc_target::abi::call::FnType;\n+use rustc_target::abi::call::FnAbi;\n \n pub trait AbiBuilderMethods<'tcx>: BackendTypes {\n-    fn apply_attrs_callsite(&mut self, ty: &FnType<'tcx, Ty<'tcx>>, callsite: Self::Value);\n+    fn apply_attrs_callsite(&mut self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>, callsite: Self::Value);\n     fn get_param(&self, index: usize) -> Self::Value;\n }"}, {"sha": "ebbea6e7bf56dd2227aead1a156760517a79292b", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -2,7 +2,7 @@ use super::abi::AbiBuilderMethods;\n use super::asm::AsmBuilderMethods;\n use super::debuginfo::DebugInfoBuilderMethods;\n use super::intrinsic::IntrinsicCallMethods;\n-use super::type_::ArgTypeMethods;\n+use super::type_::ArgAbiMethods;\n use super::{HasCodegen, StaticBuilderMethods};\n use crate::common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate,\n     SynchronizationScope};\n@@ -25,7 +25,7 @@ pub enum OverflowOp {\n pub trait BuilderMethods<'a, 'tcx>:\n     HasCodegen<'tcx>\n     + DebugInfoBuilderMethods<'tcx>\n-    + ArgTypeMethods<'tcx>\n+    + ArgAbiMethods<'tcx>\n     + AbiBuilderMethods<'tcx>\n     + IntrinsicCallMethods<'tcx>\n     + AsmBuilderMethods<'tcx>"}, {"sha": "8006d778bd38e50dadb4f07e8eba16ae55613663", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,7 +1,7 @@\n use super::BackendTypes;\n use crate::mir::operand::OperandRef;\n use rustc::ty::{self, Ty};\n-use rustc_target::abi::call::FnType;\n+use rustc_target::abi::call::FnAbi;\n use syntax_pos::Span;\n \n pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n@@ -11,7 +11,7 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     fn codegen_intrinsic_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        fn_ty: &FnType<'tcx, Ty<'tcx>>,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         args: &[OperandRef<'tcx, Self::Value>],\n         llresult: Self::Value,\n         span: Span,"}, {"sha": "89982b9ea62bb4d2bb68c26e41a0b11ce0c628a7", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -38,7 +38,7 @@ pub use self::intrinsic::IntrinsicCallMethods;\n pub use self::misc::MiscMethods;\n pub use self::statics::{StaticMethods, StaticBuilderMethods};\n pub use self::type_::{\n-    ArgTypeMethods, BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMethods,\n+    ArgAbiMethods, BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMethods,\n };\n pub use self::write::{ModuleBufferMethods, ThinBufferMethods, WriteBackendMethods};\n use rustc::ty::layout::{HasParamEnv, HasTyCtxt};"}, {"sha": "f074d4479fab4dc25b4d65515daf4a1bb8710a37", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -5,7 +5,7 @@ use crate::common::TypeKind;\n use crate::mir::place::PlaceRef;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, TyLayout};\n-use rustc_target::abi::call::{ArgType, CastTarget, FnType, Reg};\n+use rustc_target::abi::call::{ArgAbi, CastTarget, FnAbi, Reg};\n use syntax_pos::DUMMY_SP;\n \n // This depends on `Backend` and not `BackendTypes`, because consumers will probably want to use\n@@ -96,7 +96,7 @@ impl<T> DerivedTypeMethods<'tcx> for T where Self: BaseTypeMethods<'tcx> + MiscM\n pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n     fn backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n     fn cast_backend_type(&self, ty: &CastTarget) -> Self::Type;\n-    fn fn_ptr_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> Self::Type;\n+    fn fn_ptr_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn reg_backend_type(&self, ty: &Reg) -> Self::Type;\n     fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n     fn is_backend_immediate(&self, layout: TyLayout<'tcx>) -> bool;\n@@ -110,20 +110,20 @@ pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n     ) -> Self::Type;\n }\n \n-pub trait ArgTypeMethods<'tcx>: HasCodegen<'tcx> {\n+pub trait ArgAbiMethods<'tcx>: HasCodegen<'tcx> {\n     fn store_fn_arg(\n         &mut self,\n-        ty: &ArgType<'tcx, Ty<'tcx>>,\n+        arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n         idx: &mut usize,\n         dst: PlaceRef<'tcx, Self::Value>,\n     );\n-    fn store_arg_ty(\n+    fn store_arg(\n         &mut self,\n-        ty: &ArgType<'tcx, Ty<'tcx>>,\n+        arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n         val: Self::Value,\n         dst: PlaceRef<'tcx, Self::Value>,\n     );\n-    fn memory_ty(&self, ty: &ArgType<'tcx, Ty<'tcx>>) -> Self::Type;\n+    fn arg_memory_ty(&self, arg_abi: &ArgAbi<'tcx, Ty<'tcx>>) -> Self::Type;\n }\n \n pub trait TypeMethods<'tcx>: DerivedTypeMethods<'tcx> + LayoutTypeMethods<'tcx> {}"}, {"sha": "45fe4751a3dae9dc4e07eae26513e3157e97e09f", "filename": "src/librustc_target/abi/call/aarch64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,7 +1,7 @@\n-use crate::abi::call::{FnType, ArgType, Reg, RegKind, Uniform};\n+use crate::abi::call::{FnAbi, ArgAbi, Reg, RegKind, Uniform};\n use crate::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n-fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n+fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n                                      -> Option<Uniform>\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n@@ -31,7 +31,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     })\n }\n \n-fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n+fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -65,7 +65,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -99,16 +99,16 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     arg.make_indirect();\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret);\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(cx, &mut fn_abi.ret);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg);\n+        classify_arg(cx, arg);\n     }\n }"}, {"sha": "38e674813b9f01d12db37261591fb98a428c614a", "filename": "src/librustc_target/abi/call/amdgpu.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Famdgpu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Famdgpu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Famdgpu.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,32 +1,32 @@\n-use crate::abi::call::{ArgType, FnType, };\n+use crate::abi::call::{ArgAbi, FnAbi, };\n use crate::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n-fn classify_ret_ty<'a, Ty, C>(_cx: &C, ret: &mut ArgType<'a, Ty>)\n+fn classify_ret<'a, Ty, C>(_cx: &C, ret: &mut ArgAbi<'a, Ty>)\n   where Ty: TyLayoutMethods<'a, C> + Copy,\n         C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n   ret.extend_integer_width_to(32);\n }\n \n-fn classify_arg_ty<'a, Ty, C>(_cx: &C, arg: &mut ArgType<'a, Ty>)\n+fn classify_arg<'a, Ty, C>(_cx: &C, arg: &mut ArgAbi<'a, Ty>)\n   where Ty: TyLayoutMethods<'a, C> + Copy,\n         C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n   arg.extend_integer_width_to(32);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n   where Ty: TyLayoutMethods<'a, C> + Copy,\n         C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-  if !fty.ret.is_ignore() {\n-    classify_ret_ty(cx, &mut fty.ret);\n+  if !fn_abi.ret.is_ignore() {\n+    classify_ret(cx, &mut fn_abi.ret);\n   }\n \n-  for arg in &mut fty.args {\n+  for arg in &mut fn_abi.args {\n     if arg.is_ignore() {\n       continue;\n     }\n-    classify_arg_ty(cx, arg);\n+    classify_arg(cx, arg);\n   }\n }"}, {"sha": "ff929f33d8bc94a0ecab52cdc8faf40b266498e0", "filename": "src/librustc_target/abi/call/arm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,8 +1,8 @@\n-use crate::abi::call::{Conv, FnType, ArgType, Reg, RegKind, Uniform};\n+use crate::abi::call::{Conv, FnAbi, ArgAbi, Reg, RegKind, Uniform};\n use crate::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n use crate::spec::HasTargetSpec;\n \n-fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n+fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n                                      -> Option<Uniform>\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n@@ -32,7 +32,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     })\n }\n \n-fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>, vfp: bool)\n+fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>, vfp: bool)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -67,7 +67,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>, vfp: bool)\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, vfp: bool)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, vfp: bool)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -91,22 +91,22 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, vfp: bool)\n     });\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec\n {\n     // If this is a target with a hard-float ABI, and the function is not explicitly\n     // `extern \"aapcs\"`, then we must use the VFP registers for homogeneous aggregates.\n     let vfp = cx.target_spec().llvm_target.ends_with(\"hf\")\n-        && fty.conv != Conv::ArmAapcs\n-        && !fty.c_variadic;\n+        && fn_abi.conv != Conv::ArmAapcs\n+        && !fn_abi.c_variadic;\n \n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret, vfp);\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(cx, &mut fn_abi.ret, vfp);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg, vfp);\n+        classify_arg(cx, arg, vfp);\n     }\n }"}, {"sha": "d3cae35f08924d6bc5a3a8c17daaaa1f478a7816", "filename": "src/librustc_target/abi/call/hexagon.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fhexagon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fhexagon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fhexagon.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,30 +1,30 @@\n-use crate::abi::call::{FnType, ArgType};\n+use crate::abi::call::{FnAbi, ArgAbi};\n \n-fn classify_ret_ty<Ty>(ret: &mut ArgType<'_, Ty>) {\n+fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {\n         ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg_ty<Ty>(arg: &mut ArgType<'_, Ty>) {\n+fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n     if arg.layout.is_aggregate() && arg.layout.size.bits() > 64 {\n         arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n }\n \n-pub fn compute_abi_info<Ty>(fty: &mut FnType<'_,Ty>) {\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(&mut fty.ret);\n+pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_,Ty>) {\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(arg);\n+        classify_arg(arg);\n     }\n }"}, {"sha": "b2c8d26ff1f86e44b2e755527808714125f42c3f", "filename": "src/librustc_target/abi/call/mips.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,7 +1,7 @@\n-use crate::abi::call::{ArgType, FnType, Reg, Uniform};\n+use crate::abi::call::{ArgAbi, FnAbi, Reg, Uniform};\n use crate::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n \n-fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'_, Ty>, offset: &mut Size)\n+fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     if !ret.layout.is_aggregate() {\n@@ -12,7 +12,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'_, Ty>, offset: &mut Si\n     }\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'_, Ty>, offset: &mut Size)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     let dl = cx.data_layout();\n@@ -34,16 +34,16 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'_, Ty>, offset: &mut Si\n     *offset = offset.align_to(align) + size.align_to(align);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'_, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'_, Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     let mut offset = Size::ZERO;\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(cx, &mut fn_abi.ret, &mut offset);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg, &mut offset);\n+        classify_arg(cx, arg, &mut offset);\n     }\n }"}, {"sha": "db34d3662129066705ee4e35378e853dbd71f701", "filename": "src/librustc_target/abi/call/mips64.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,7 +1,7 @@\n-use crate::abi::call::{ArgAttribute, ArgType, CastTarget, FnType, PassMode, Reg, RegKind, Uniform};\n+use crate::abi::call::{ArgAttribute, ArgAbi, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n use crate::abi::{self, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n \n-fn extend_integer_width_mips<Ty>(arg: &mut ArgType<'_, Ty>, bits: u64) {\n+fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n     // Always sign extend u32 values on 64-bit mips\n     if let abi::Abi::Scalar(ref scalar) = arg.layout.abi {\n         if let abi::Int(i, signed) = scalar.value {\n@@ -17,7 +17,7 @@ fn extend_integer_width_mips<Ty>(arg: &mut ArgType<'_, Ty>, bits: u64) {\n     arg.extend_integer_width_to(bits);\n }\n \n-fn float_reg<'a, Ty, C>(cx: &C, ret: &ArgType<'a, Ty>, i: usize) -> Option<Reg>\n+fn float_reg<'a, Ty, C>(cx: &C, ret: &ArgAbi<'a, Ty>, i: usize) -> Option<Reg>\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -31,7 +31,7 @@ fn float_reg<'a, Ty, C>(cx: &C, ret: &ArgType<'a, Ty>, i: usize) -> Option<Reg>\n     }\n }\n \n-fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n+fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -73,7 +73,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n     }\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -141,16 +141,16 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     });\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret);\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(cx, &mut fn_abi.ret);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg);\n+        classify_arg(cx, arg);\n     }\n }"}, {"sha": "396b962003803d2b623e0ee25431a7ded1f7a2fa", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -379,7 +379,7 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n /// Information about how to pass an argument to,\n /// or return a value from, a function, under some ABI.\n #[derive(Debug)]\n-pub struct ArgType<'a, Ty> {\n+pub struct ArgAbi<'a, Ty> {\n     pub layout: TyLayout<'a, Ty>,\n \n     /// Dummy argument, which is emitted before the real argument.\n@@ -388,9 +388,9 @@ pub struct ArgType<'a, Ty> {\n     pub mode: PassMode,\n }\n \n-impl<'a, Ty> ArgType<'a, Ty> {\n+impl<'a, Ty> ArgAbi<'a, Ty> {\n     pub fn new(layout: TyLayout<'a, Ty>) -> Self {\n-        ArgType {\n+        ArgAbi {\n             layout,\n             pad: None,\n             mode: PassMode::Direct(ArgAttributes::new()),\n@@ -516,19 +516,19 @@ pub enum Conv {\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n #[derive(Debug)]\n-pub struct FnType<'a, Ty> {\n+pub struct FnAbi<'a, Ty> {\n     /// The LLVM types of each argument.\n-    pub args: Vec<ArgType<'a, Ty>>,\n+    pub args: Vec<ArgAbi<'a, Ty>>,\n \n     /// LLVM return type.\n-    pub ret: ArgType<'a, Ty>,\n+    pub ret: ArgAbi<'a, Ty>,\n \n     pub c_variadic: bool,\n \n     pub conv: Conv,\n }\n \n-impl<'a, Ty> FnType<'a, Ty> {\n+impl<'a, Ty> FnAbi<'a, Ty> {\n     pub fn adjust_for_cabi<C>(&mut self, cx: &C, abi: spec::abi::Abi) -> Result<(), String>\n         where Ty: TyLayoutMethods<'a, C> + Copy,\n               C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec"}, {"sha": "3004bb9ff5d5b1e40fe0aa42c6ae6ea2dd70850e", "filename": "src/librustc_target/abi/call/msp430.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fmsp430.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fmsp430.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmsp430.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,39 +1,39 @@\n // Reference: MSP430 Embedded Application Binary Interface\n // http://www.ti.com/lit/an/slaa534/slaa534.pdf\n \n-use crate::abi::call::{ArgType, FnType};\n+use crate::abi::call::{ArgAbi, FnAbi};\n \n // 3.5 Structures or Unions Passed and Returned by Reference\n //\n // \"Structures (including classes) and unions larger than 32 bits are passed and\n // returned by reference. To pass a structure or union by reference, the caller\n // places its address in the appropriate location: either in a register or on\n // the stack, according to its position in the argument list. (..)\"\n-fn classify_ret_ty<Ty>(ret: &mut ArgType<'_, Ty>) {\n+fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 32 {\n         ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(16);\n     }\n }\n \n-fn classify_arg_ty<Ty>(arg: &mut ArgType<'_, Ty>) {\n+fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n     if arg.layout.is_aggregate() && arg.layout.size.bits() > 32 {\n         arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(16);\n     }\n }\n \n-pub fn compute_abi_info<Ty>(fty: &mut FnType<'_, Ty>) {\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(&mut fty.ret);\n+pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(arg);\n+        classify_arg(arg);\n     }\n }"}, {"sha": "693337f0e52fd4df4f634c372abc456a7dbd9a3b", "filename": "src/librustc_target/abi/call/nvptx.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fnvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fnvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fnvptx.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,33 +1,33 @@\n // Reference: PTX Writer's Guide to Interoperability\n // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n \n-use crate::abi::call::{ArgType, FnType};\n+use crate::abi::call::{ArgAbi, FnAbi};\n \n-fn classify_ret_ty<Ty>(ret: &mut ArgType<'_, Ty>) {\n+fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 32 {\n         ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg_ty<Ty>(arg: &mut ArgType<'_, Ty>) {\n+fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n     if arg.layout.is_aggregate() && arg.layout.size.bits() > 32 {\n         arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n }\n \n-pub fn compute_abi_info<Ty>(fty: &mut FnType<'_, Ty>) {\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(&mut fty.ret);\n+pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(arg);\n+        classify_arg(arg);\n     }\n }"}, {"sha": "b9c9296dbacc7db10fae36c0eae224deb42e3940", "filename": "src/librustc_target/abi/call/nvptx64.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fnvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fnvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fnvptx64.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,33 +1,33 @@\n // Reference: PTX Writer's Guide to Interoperability\n // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n \n-use crate::abi::call::{ArgType, FnType};\n+use crate::abi::call::{ArgAbi, FnAbi};\n \n-fn classify_ret_ty<Ty>(ret: &mut ArgType<'_, Ty>) {\n+fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {\n         ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(64);\n     }\n }\n \n-fn classify_arg_ty<Ty>(arg: &mut ArgType<'_, Ty>) {\n+fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n     if arg.layout.is_aggregate() && arg.layout.size.bits() > 64 {\n         arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(64);\n     }\n }\n \n-pub fn compute_abi_info<Ty>(fty: &mut FnType<'_, Ty>) {\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(&mut fty.ret);\n+pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(arg);\n+        classify_arg(arg);\n     }\n }"}, {"sha": "b2c8d26ff1f86e44b2e755527808714125f42c3f", "filename": "src/librustc_target/abi/call/powerpc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,7 +1,7 @@\n-use crate::abi::call::{ArgType, FnType, Reg, Uniform};\n+use crate::abi::call::{ArgAbi, FnAbi, Reg, Uniform};\n use crate::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n \n-fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'_, Ty>, offset: &mut Size)\n+fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     if !ret.layout.is_aggregate() {\n@@ -12,7 +12,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'_, Ty>, offset: &mut Si\n     }\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'_, Ty>, offset: &mut Size)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     let dl = cx.data_layout();\n@@ -34,16 +34,16 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'_, Ty>, offset: &mut Si\n     *offset = offset.align_to(align) + size.align_to(align);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'_, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'_, Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     let mut offset = Size::ZERO;\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(cx, &mut fn_abi.ret, &mut offset);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg, &mut offset);\n+        classify_arg(cx, arg, &mut offset);\n     }\n }"}, {"sha": "f967a83d5f9b603ba41d7dea50f0df8f0b365357", "filename": "src/librustc_target/abi/call/powerpc64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -2,7 +2,7 @@\n // Alignment of 128 bit types is not currently handled, this will\n // need to be fixed when PowerPC vector support is added.\n \n-use crate::abi::call::{FnType, ArgType, Reg, RegKind, Uniform};\n+use crate::abi::call::{FnAbi, ArgAbi, Reg, RegKind, Uniform};\n use crate::abi::{Endian, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n use crate::spec::HasTargetSpec;\n \n@@ -13,7 +13,7 @@ enum ABI {\n }\n use ABI::*;\n \n-fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n+fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, abi: ABI)\n                                        -> Option<Uniform>\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n@@ -43,7 +43,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, abi: A\n     })\n }\n \n-fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>, abi: ABI)\n+fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>, abi: ABI)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -88,7 +88,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>, abi: ABI)\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, abi: ABI)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -120,7 +120,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n     });\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec\n {\n@@ -133,12 +133,12 @@ pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n         }\n     };\n \n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret, abi);\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(cx, &mut fn_abi.ret, abi);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg, abi);\n+        classify_arg(cx, arg, abi);\n     }\n }"}, {"sha": "095e5aff74422235abb2460028e0a60002150569", "filename": "src/librustc_target/abi/call/riscv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,9 +1,9 @@\n // Reference: RISC-V ELF psABI specification\n // https://github.com/riscv/riscv-elf-psabi-doc\n \n-use crate::abi::call::{ArgType, FnType};\n+use crate::abi::call::{ArgAbi, FnAbi};\n \n-fn classify_ret_ty<Ty>(arg: &mut ArgType<'_, Ty>, xlen: u64) {\n+fn classify_ret<Ty>(arg: &mut ArgAbi<'_, Ty>, xlen: u64) {\n     // \"Scalars wider than 2\u2715XLEN are passed by reference and are replaced in\n     // the argument list with the address.\"\n     // \"Aggregates larger than 2\u2715XLEN bits are passed by reference and are\n@@ -19,7 +19,7 @@ fn classify_ret_ty<Ty>(arg: &mut ArgType<'_, Ty>, xlen: u64) {\n     arg.extend_integer_width_to(xlen); // this method only affects integer scalars\n }\n \n-fn classify_arg_ty<Ty>(arg: &mut ArgType<'_, Ty>, xlen: u64) {\n+fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>, xlen: u64) {\n     // \"Scalars wider than 2\u2715XLEN are passed by reference and are replaced in\n     // the argument list with the address.\"\n     // \"Aggregates larger than 2\u2715XLEN bits are passed by reference and are\n@@ -35,15 +35,15 @@ fn classify_arg_ty<Ty>(arg: &mut ArgType<'_, Ty>, xlen: u64) {\n     arg.extend_integer_width_to(xlen); // this method only affects integer scalars\n }\n \n-pub fn compute_abi_info<Ty>(fty: &mut FnType<'_, Ty>, xlen: u64) {\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(&mut fty.ret, xlen);\n+pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>, xlen: u64) {\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(&mut fn_abi.ret, xlen);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(arg, xlen);\n+        classify_arg(arg, xlen);\n     }\n }"}, {"sha": "c3967cb3ff56afe7622a8f3f9ec4dff507ece59e", "filename": "src/librustc_target/abi/call/s390x.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,10 +1,10 @@\n // FIXME: The assumes we're using the non-vector ABI, i.e., compiling\n // for a pre-z13 machine or using -mno-vx.\n \n-use crate::abi::call::{FnType, ArgType, Reg};\n+use crate::abi::call::{FnAbi, ArgAbi, Reg};\n use crate::abi::{self, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n-fn classify_ret_ty<'a, Ty, C>(ret: &mut ArgType<'_, Ty>)\n+fn classify_ret<'a, Ty, C>(ret: &mut ArgAbi<'_, Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     if !ret.layout.is_aggregate() && ret.layout.size.bits() <= 64 {\n@@ -31,7 +31,7 @@ fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyLayout<'a, Ty>) -> bool\n     }\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -57,16 +57,16 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     }\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(&mut fty.ret);\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg);\n+        classify_arg(cx, arg);\n     }\n }"}, {"sha": "b2c8d26ff1f86e44b2e755527808714125f42c3f", "filename": "src/librustc_target/abi/call/sparc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,7 +1,7 @@\n-use crate::abi::call::{ArgType, FnType, Reg, Uniform};\n+use crate::abi::call::{ArgAbi, FnAbi, Reg, Uniform};\n use crate::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n \n-fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'_, Ty>, offset: &mut Size)\n+fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     if !ret.layout.is_aggregate() {\n@@ -12,7 +12,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'_, Ty>, offset: &mut Si\n     }\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'_, Ty>, offset: &mut Size)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     let dl = cx.data_layout();\n@@ -34,16 +34,16 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'_, Ty>, offset: &mut Si\n     *offset = offset.align_to(align) + size.align_to(align);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'_, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'_, Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     let mut offset = Size::ZERO;\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(cx, &mut fn_abi.ret, &mut offset);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg, &mut offset);\n+        classify_arg(cx, arg, &mut offset);\n     }\n }"}, {"sha": "fe2c427f703100ba19445da7414015ab9fd31a1e", "filename": "src/librustc_target/abi/call/sparc64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,9 +1,9 @@\n // FIXME: This needs an audit for correctness and completeness.\n \n-use crate::abi::call::{FnType, ArgType, Reg, RegKind, Uniform};\n+use crate::abi::call::{FnAbi, ArgAbi, Reg, RegKind, Uniform};\n use crate::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n-fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n+fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n                                      -> Option<Uniform>\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n@@ -31,7 +31,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     })\n }\n \n-fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n+fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -59,7 +59,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -85,16 +85,16 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     });\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret);\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(cx, &mut fn_abi.ret);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg);\n+        classify_arg(cx, arg);\n     }\n }"}, {"sha": "31b78337311ff06c04195c3b69cf05e472926bd3", "filename": "src/librustc_target/abi/call/wasm32.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,7 +1,7 @@\n-use crate::abi::call::{FnType, ArgType, Uniform};\n+use crate::abi::call::{FnAbi, ArgAbi, Uniform};\n use crate::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n-fn unwrap_trivial_aggregate<'a, Ty, C>(cx: &C, val: &mut ArgType<'a, Ty>) -> bool\n+fn unwrap_trivial_aggregate<'a, Ty, C>(cx: &C, val: &mut ArgAbi<'a, Ty>) -> bool\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -21,7 +21,7 @@ fn unwrap_trivial_aggregate<'a, Ty, C>(cx: &C, val: &mut ArgType<'a, Ty>) -> boo\n }\n \n \n-fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n+fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -33,7 +33,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n     }\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -45,16 +45,16 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     }\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret);\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(cx, &mut fn_abi.ret);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg);\n+        classify_arg(cx, arg);\n     }\n }"}, {"sha": "d2766d478c90e6ad57a95af49c7c59001d7cd18f", "filename": "src/librustc_target/abi/call/wasm32_bindgen_compat.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32_bindgen_compat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32_bindgen_compat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32_bindgen_compat.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -5,23 +5,23 @@\n // can be fixed to work with the correct ABI. See #63649 for further\n // discussion.\n \n-use crate::abi::call::{FnType, ArgType};\n+use crate::abi::call::{FnAbi, ArgAbi};\n \n-fn classify_ret_ty<Ty>(ret: &mut ArgType<'_, Ty>) {\n+fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n     ret.extend_integer_width_to(32);\n }\n \n-fn classify_arg_ty<Ty>(arg: &mut ArgType<'_, Ty>) {\n+fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n     arg.extend_integer_width_to(32);\n }\n \n-pub fn compute_abi_info<Ty>(fty: &mut FnType<'_, Ty>) {\n-    if !fty.ret.is_ignore() {\n-        classify_ret_ty(&mut fty.ret);\n+pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(arg);\n+        classify_arg(arg);\n     }\n }"}, {"sha": "be7574e799a99796d184967329f75ed963f174cf", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,4 +1,4 @@\n-use crate::abi::call::{ArgAttribute, FnType, PassMode, Reg, RegKind};\n+use crate::abi::call::{ArgAttribute, FnAbi, PassMode, Reg, RegKind};\n use crate::abi::{self, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n use crate::spec::HasTargetSpec;\n \n@@ -25,12 +25,12 @@ fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyLayout<'a, Ty>) -> bool\n     }\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>, flavor: Flavor)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>, flavor: Flavor)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec\n {\n-    if !fty.ret.is_ignore() {\n-        if fty.ret.layout.is_aggregate() {\n+    if !fn_abi.ret.is_ignore() {\n+        if fn_abi.ret.layout.is_aggregate() {\n             // Returning a structure. Most often, this will use\n             // a hidden first argument. On some platforms, though,\n             // small structs are returned as integers.\n@@ -42,30 +42,30 @@ pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>, flavor: Fla\n             if t.options.abi_return_struct_as_int {\n                 // According to Clang, everyone but MSVC returns single-element\n                 // float aggregates directly in a floating-point register.\n-                if !t.options.is_like_msvc && is_single_fp_element(cx, fty.ret.layout) {\n-                    match fty.ret.layout.size.bytes() {\n-                        4 => fty.ret.cast_to(Reg::f32()),\n-                        8 => fty.ret.cast_to(Reg::f64()),\n-                        _ => fty.ret.make_indirect()\n+                if !t.options.is_like_msvc && is_single_fp_element(cx, fn_abi.ret.layout) {\n+                    match fn_abi.ret.layout.size.bytes() {\n+                        4 => fn_abi.ret.cast_to(Reg::f32()),\n+                        8 => fn_abi.ret.cast_to(Reg::f64()),\n+                        _ => fn_abi.ret.make_indirect()\n                     }\n                 } else {\n-                    match fty.ret.layout.size.bytes() {\n-                        1 => fty.ret.cast_to(Reg::i8()),\n-                        2 => fty.ret.cast_to(Reg::i16()),\n-                        4 => fty.ret.cast_to(Reg::i32()),\n-                        8 => fty.ret.cast_to(Reg::i64()),\n-                        _ => fty.ret.make_indirect()\n+                    match fn_abi.ret.layout.size.bytes() {\n+                        1 => fn_abi.ret.cast_to(Reg::i8()),\n+                        2 => fn_abi.ret.cast_to(Reg::i16()),\n+                        4 => fn_abi.ret.cast_to(Reg::i32()),\n+                        8 => fn_abi.ret.cast_to(Reg::i64()),\n+                        _ => fn_abi.ret.make_indirect()\n                     }\n                 }\n             } else {\n-                fty.ret.make_indirect();\n+                fn_abi.ret.make_indirect();\n             }\n         } else {\n-            fty.ret.extend_integer_width_to(32);\n+            fn_abi.ret.extend_integer_width_to(32);\n         }\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n         if arg.layout.is_aggregate() {\n             arg.make_indirect_byval();\n@@ -86,7 +86,7 @@ pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>, flavor: Fla\n \n         let mut free_regs = 2;\n \n-        for arg in &mut fty.args {\n+        for arg in &mut fn_abi.args {\n             let attrs = match arg.mode {\n                 PassMode::Ignore |\n                 PassMode::Indirect(_, None) => continue,"}, {"sha": "96fd077ec00b4d7c71301b45aa392d146700da24", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,7 +1,7 @@\n // The classification code for the x86_64 ABI is taken from the clay language\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n-use crate::abi::call::{ArgType, CastTarget, FnType, Reg, RegKind};\n+use crate::abi::call::{ArgAbi, CastTarget, FnAbi, Reg, RegKind};\n use crate::abi::{self, Abi, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n \n /// Classification of \"eightbyte\" components.\n@@ -21,7 +21,7 @@ struct Memory;\n const LARGEST_VECTOR_SIZE: usize = 512;\n const MAX_EIGHTBYTES: usize = LARGEST_VECTOR_SIZE / 64;\n \n-fn classify_arg<'a, Ty, C>(cx: &C, arg: &ArgType<'a, Ty>)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &ArgAbi<'a, Ty>)\n                           -> Result<[Option<Class>; MAX_EIGHTBYTES], Memory>\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n@@ -170,14 +170,14 @@ fn cast_target(cls: &[Option<Class>], size: Size) -> CastTarget {\n const MAX_INT_REGS: usize = 6; // RDI, RSI, RDX, RCX, R8, R9\n const MAX_SSE_REGS: usize = 8; // XMM0-7\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n     let mut int_regs = MAX_INT_REGS;\n     let mut sse_regs = MAX_SSE_REGS;\n \n-    let mut x86_64_ty = |arg: &mut ArgType<'a, Ty>, is_arg: bool| {\n+    let mut x86_64_arg_or_ret = |arg: &mut ArgAbi<'a, Ty>, is_arg: bool| {\n         let mut cls_or_mem = classify_arg(cx, arg);\n \n         if is_arg {\n@@ -234,12 +234,12 @@ pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n         }\n     };\n \n-    if !fty.ret.is_ignore() {\n-        x86_64_ty(&mut fty.ret, false);\n+    if !fn_abi.ret.is_ignore() {\n+        x86_64_arg_or_ret(&mut fn_abi.ret, false);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        x86_64_ty(arg, true);\n+        x86_64_arg_or_ret(arg, true);\n     }\n }"}, {"sha": "3c27d18a744cae191fc6cace9008f90b77b5798a", "filename": "src/librustc_target/abi/call/x86_win64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_win64.rs?ref=2e4da3caadc61fab2cfcffebcbfdd72fbcee62b7", "patch": "@@ -1,10 +1,10 @@\n-use crate::abi::call::{ArgType, FnType, Reg};\n+use crate::abi::call::{ArgAbi, FnAbi, Reg};\n use crate::abi::Abi;\n \n // Win64 ABI: http://msdn.microsoft.com/en-us/library/zthk2dkh.aspx\n \n-pub fn compute_abi_info<Ty>(fty: &mut FnType<'_, Ty>) {\n-    let fixup = |a: &mut ArgType<'_, Ty>| {\n+pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n+    let fixup = |a: &mut ArgAbi<'_, Ty>| {\n         match a.layout.abi {\n             Abi::Uninhabited => {}\n             Abi::ScalarPair(..) |\n@@ -31,10 +31,10 @@ pub fn compute_abi_info<Ty>(fty: &mut FnType<'_, Ty>) {\n         }\n     };\n \n-    if !fty.ret.is_ignore() {\n-        fixup(&mut fty.ret);\n+    if !fn_abi.ret.is_ignore() {\n+        fixup(&mut fn_abi.ret);\n     }\n-    for arg in &mut fty.args {\n+    for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n         fixup(arg);\n     }"}]}