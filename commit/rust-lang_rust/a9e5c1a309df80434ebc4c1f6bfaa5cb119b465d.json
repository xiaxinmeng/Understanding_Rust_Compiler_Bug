{"sha": "a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "node_id": "C_kwDOAAsO6NoAKGE5ZTVjMWEzMDlkZjgwNDM0ZWJjNGMxZjZiZmFhNWNiMTE5YjQ2NWQ", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-12-19T14:59:00Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-12-29T16:45:07Z"}, "message": "std: unify id-based thread parking implementations", "tree": {"sha": "e1022d1e13d77934c51552358e520a362c1380ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1022d1e13d77934c51552358e520a362c1380ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmOtxBMACgkQcE4BSbAZ\nSzymDA/8Dkno1QHBLBl+y1U4Zo39xgdNqvJ1Ri+sKXTS4crSd+RWu1JLA5nUNLMQ\nB+7lcIWl0+oe96ckGgmMSUaKDME79Z4jmS1dzaG8Mf4ZOEhp8Sls5KWDCshwRJ1y\nZsb6r1M9oZNyOYOmshxWsHaZtomfHE6y+TLwksZEwi0wL6TUuxT9gQpCUbURklij\nfOQPaCj0gD3a2iCHqib6dVZLNU2m8QUKRynFULNkHNpQH7srqUOnr6q8DYdG52DI\n2yz+RN95ppX8uvYqlBSeDh+HBtZCTTfe/tsFnVkcaGJt9aViIJ4OXGdRg5DsEYV2\nh93Ui12nKedyeAAENArdWjeQU8/d3T6aoOHbZmzASLZAKt77e6Qdq8oUycIESTaZ\noRftVagsacpVSztTr8S313iA+obEdEnJYDsu3Fd0Fiu1VJfdoRYYVu1u8Wgl+UM/\nDebwbTmoWphOzCg+vXi2FKxYUBFYAoWHHNP+aRQh9+CjbHaaGlTdyxW9pv2l7LOV\nf2o5vh0FQIX2unDCB5Z0hFmbDPHFr0pmY4uvpvsXRP04onXjFeuGcATRsXUhmyv+\nFlYZNilMXev42PmGL1GLRPLSCfLevSFqw1ldgL1t8geGlMNSrhZM+OceEfb8uyg/\nFl5/1rn3IH/CANagFGajG0ej29+Ez+Q8MojfkxolJDLe7kVeHoE=\n=P9zf\n-----END PGP SIGNATURE-----", "payload": "tree e1022d1e13d77934c51552358e520a362c1380ef\nparent 0c0b403f19fc6febcd1e36a83fc307ecc11de943\nauthor joboet <jonasboettiger@icloud.com> 1671461940 +0100\ncommitter joboet <jonasboettiger@icloud.com> 1672332307 +0100\n\nstd: unify id-based thread parking implementations\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "html_url": "https://github.com/rust-lang/rust/commit/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c0b403f19fc6febcd1e36a83fc307ecc11de943", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c0b403f19fc6febcd1e36a83fc307ecc11de943", "html_url": "https://github.com/rust-lang/rust/commit/0c0b403f19fc6febcd1e36a83fc307ecc11de943"}], "stats": {"total": 439, "additions": 208, "deletions": 231}, "files": [{"sha": "9865a945bad1d17389586da7633767f04eba3991", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "patch": "@@ -34,7 +34,7 @@ pub mod process;\n pub mod stdio;\n pub mod thread;\n pub mod thread_local_key;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod time;\n \n mod condvar;"}, {"sha": "8c3d8c37a192d4f21ebfbefba3d7dd0786d5ca36", "filename": "library/std/src/sys/sgx/thread.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "patch": "@@ -65,9 +65,10 @@ mod task_queue {\n /// execution. The signal is sent once all TLS destructors have finished at\n /// which point no new thread locals should be created.\n pub mod wait_notify {\n-    use super::super::thread_parker::Parker;\n+    use crate::mem::MaybeUninit;\n     use crate::pin::Pin;\n     use crate::sync::Arc;\n+    use crate::sys_common::thread_parking::Parker;\n \n     pub struct Notifier(Arc<Parker>);\n \n@@ -94,7 +95,18 @@ pub mod wait_notify {\n     }\n \n     pub fn new() -> (Notifier, Waiter) {\n-        let inner = Arc::new(Parker::new_internal());\n+        // Safety:\n+        // Some other platforms (looking at you, UNIX!) require that the thread\n+        // parker is constructed in-place. This is just a noisy way of writing:\n+        // ```rust\n+        // let parker = Parker::new();\n+        // ```\n+        let parker = unsafe {\n+            let mut place = MaybeUninit::uninit();\n+            Parker::new(place.as_mut_ptr());\n+            place.assume_init()\n+        };\n+        let inner = Arc::new(parker);\n         (Notifier(inner.clone()), Waiter(inner))\n     }\n }"}, {"sha": "1c55bcffb1e8c2dc3650e918177026d9b7cc2250", "filename": "library/std/src/sys/sgx/thread_parker.rs", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/0c0b403f19fc6febcd1e36a83fc307ecc11de943/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0b403f19fc6febcd1e36a83fc307ecc11de943/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs?ref=0c0b403f19fc6febcd1e36a83fc307ecc11de943", "patch": "@@ -1,107 +0,0 @@\n-//! Thread parking based on SGX events.\n-\n-use super::abi::{thread, usercalls};\n-use crate::io::ErrorKind;\n-use crate::pin::Pin;\n-use crate::ptr::{self, NonNull};\n-use crate::sync::atomic::AtomicPtr;\n-use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n-use crate::time::Duration;\n-use fortanix_sgx_abi::{EV_UNPARK, WAIT_INDEFINITE};\n-\n-// The TCS structure must be page-aligned (this is checked by EENTER), so these cannot\n-// be valid pointers\n-const EMPTY: *mut u8 = ptr::invalid_mut(1);\n-const NOTIFIED: *mut u8 = ptr::invalid_mut(2);\n-\n-pub struct Parker {\n-    /// The park state. One of EMPTY, NOTIFIED or a TCS address.\n-    /// A state change to NOTIFIED must be done with release ordering\n-    /// and be observed with acquire ordering so that operations after\n-    /// `thread::park` returns will not occur before the unpark message\n-    /// was sent.\n-    state: AtomicPtr<u8>,\n-}\n-\n-impl Parker {\n-    /// Construct the thread parker. The UNIX parker implementation\n-    /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n-        unsafe { parker.write(Parker::new_internal()) }\n-    }\n-\n-    pub(super) fn new_internal() -> Parker {\n-        Parker { state: AtomicPtr::new(EMPTY) }\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        if self.state.load(Acquire) != NOTIFIED {\n-            let mut prev = EMPTY;\n-            loop {\n-                // Guard against changing TCS addresses by always setting the state to\n-                // the current value.\n-                let tcs = thread::current().as_ptr();\n-                if self.state.compare_exchange(prev, tcs, Relaxed, Acquire).is_ok() {\n-                    let event = usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap();\n-                    assert!(event & EV_UNPARK == EV_UNPARK);\n-                    prev = tcs;\n-                } else {\n-                    // The state was definitely changed by another thread at this point.\n-                    // The only time this occurs is when the state is changed to NOTIFIED.\n-                    // We observed this change with acquire ordering, so we can simply\n-                    // change the state to EMPTY with a relaxed store.\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // At this point, the token was definately read with acquire ordering,\n-        // so this can be a relaxed store.\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        let timeout = u128::min(dur.as_nanos(), WAIT_INDEFINITE as u128 - 1) as u64;\n-        let tcs = thread::current().as_ptr();\n-\n-        if self.state.load(Acquire) != NOTIFIED {\n-            if self.state.compare_exchange(EMPTY, tcs, Relaxed, Acquire).is_ok() {\n-                match usercalls::wait(EV_UNPARK, timeout) {\n-                    Ok(event) => assert!(event & EV_UNPARK == EV_UNPARK),\n-                    Err(e) => {\n-                        assert!(matches!(e.kind(), ErrorKind::TimedOut | ErrorKind::WouldBlock))\n-                    }\n-                }\n-\n-                // Swap to provide acquire ordering even if the timeout occurred\n-                // before the token was set. This situation can result in spurious\n-                // wakeups on the next call to `park_timeout`, but it is better to let\n-                // those be handled by the user than do some perhaps unnecessary, but\n-                // always expensive guarding.\n-                self.state.swap(EMPTY, Acquire);\n-                return;\n-            }\n-        }\n-\n-        // The token was already read with `acquire` ordering, this can be a store.\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // This implementation doesn't require `Pin`, but other implementations do.\n-    pub fn unpark(self: Pin<&Self>) {\n-        let state = self.state.swap(NOTIFIED, Release);\n-\n-        if !matches!(state, EMPTY | NOTIFIED) {\n-            // There is a thread waiting, wake it up.\n-            let tcs = NonNull::new(state).unwrap();\n-            // This will fail if the thread has already terminated or its TCS is destroyed\n-            // by the time the signal is sent, but that is fine. If another thread receives\n-            // the same TCS, it will receive this notification as a spurious wakeup, but\n-            // all users of `wait` should and (internally) do guard against those where\n-            // necessary.\n-            let _ = usercalls::send(EV_UNPARK, Some(tcs));\n-        }\n-    }\n-}"}, {"sha": "a1795c358d6cb2768e05f8e2ac7c380b7f0dbed4", "filename": "library/std/src/sys/sgx/thread_parking.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parking.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "patch": "@@ -0,0 +1,23 @@\n+use super::abi::usercalls;\n+use crate::io::ErrorKind;\n+use crate::time::Duration;\n+use fortanix_sgx_abi::{EV_UNPARK, WAIT_INDEFINITE};\n+\n+pub type ThreadId = fortanix_sgx_abi::Tcs;\n+\n+pub use super::abi::thread::current;\n+\n+pub fn park() {\n+    usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap();\n+}\n+\n+pub fn park_timeout(dur: Duration) {\n+    let timeout = u128::min(dur.as_nanos(), WAIT_INDEFINITE as u128 - 1) as u64;\n+    if let Err(e) = usercalls::wait(EV_UNPARK, timeout) {\n+        assert!(matches!(e.kind(), ErrorKind::TimedOut | ErrorKind::WouldBlock))\n+    }\n+}\n+\n+pub fn unpark(tid: ThreadId) {\n+    let _ = usercalls::send(EV_UNPARK, Some(tid));\n+}"}, {"sha": "7b93137561259aa7b70a7044799512029aff2ad4", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "patch": "@@ -40,7 +40,7 @@ pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod time;\n \n #[cfg(target_os = \"espidf\")]"}, {"sha": "7657605b52f0d99d70db8599d5cb5d5b32d86be2", "filename": "library/std/src/sys/unix/thread_parker/netbsd.rs", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/0c0b403f19fc6febcd1e36a83fc307ecc11de943/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0b403f19fc6febcd1e36a83fc307ecc11de943/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs?ref=0c0b403f19fc6febcd1e36a83fc307ecc11de943", "patch": "@@ -1,113 +0,0 @@\n-use crate::ffi::{c_int, c_void};\n-use crate::pin::Pin;\n-use crate::ptr::{null, null_mut};\n-use crate::sync::atomic::{\n-    AtomicU64,\n-    Ordering::{Acquire, Relaxed, Release},\n-};\n-use crate::time::Duration;\n-use libc::{_lwp_self, clockid_t, lwpid_t, time_t, timespec, CLOCK_MONOTONIC};\n-\n-extern \"C\" {\n-    fn ___lwp_park60(\n-        clock_id: clockid_t,\n-        flags: c_int,\n-        ts: *mut timespec,\n-        unpark: lwpid_t,\n-        hint: *const c_void,\n-        unparkhint: *const c_void,\n-    ) -> c_int;\n-    fn _lwp_unpark(lwp: lwpid_t, hint: *const c_void) -> c_int;\n-}\n-\n-/// The thread is not parked and the token is not available.\n-///\n-/// Zero cannot be a valid LWP id, since it is used as empty value for the unpark\n-/// argument in _lwp_park.\n-const EMPTY: u64 = 0;\n-/// The token is available. Do not park anymore.\n-const NOTIFIED: u64 = u64::MAX;\n-\n-pub struct Parker {\n-    /// The parker state. Contains either one of the two state values above or the LWP\n-    /// id of the parked thread.\n-    state: AtomicU64,\n-}\n-\n-impl Parker {\n-    pub unsafe fn new(parker: *mut Parker) {\n-        parker.write(Parker { state: AtomicU64::new(EMPTY) })\n-    }\n-\n-    // Does not actually need `unsafe` or `Pin`, but the pthread implementation does.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        // If the token has already been made available, we can skip\n-        // a bit of work, so check for it here.\n-        if self.state.load(Acquire) != NOTIFIED {\n-            let parked = _lwp_self() as u64;\n-            let hint = self.state.as_mut_ptr().cast();\n-            if self.state.compare_exchange(EMPTY, parked, Relaxed, Acquire).is_ok() {\n-                // Loop to guard against spurious wakeups.\n-                loop {\n-                    ___lwp_park60(0, 0, null_mut(), 0, hint, null());\n-                    if self.state.load(Acquire) == NOTIFIED {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // At this point, the change to NOTIFIED has always been observed with acquire\n-        // ordering, so we can just use a relaxed store here (instead of a swap).\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // Does not actually need `unsafe` or `Pin`, but the pthread implementation does.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        if self.state.load(Acquire) != NOTIFIED {\n-            let parked = _lwp_self() as u64;\n-            let hint = self.state.as_mut_ptr().cast();\n-            let mut timeout = timespec {\n-                // Saturate so that the operation will definitely time out\n-                // (even if it is after the heat death of the universe).\n-                tv_sec: dur.as_secs().try_into().ok().unwrap_or(time_t::MAX),\n-                tv_nsec: dur.subsec_nanos().into(),\n-            };\n-\n-            if self.state.compare_exchange(EMPTY, parked, Relaxed, Acquire).is_ok() {\n-                // Timeout needs to be mutable since it is modified on NetBSD 9.0 and\n-                // above.\n-                ___lwp_park60(CLOCK_MONOTONIC, 0, &mut timeout, 0, hint, null());\n-                // Use a swap to get acquire ordering even if the token was set after\n-                // the timeout occurred.\n-                self.state.swap(EMPTY, Acquire);\n-                return;\n-            }\n-        }\n-\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // Does not actually need `Pin`, but the pthread implementation does.\n-    pub fn unpark(self: Pin<&Self>) {\n-        let state = self.state.swap(NOTIFIED, Release);\n-        if !matches!(state, EMPTY | NOTIFIED) {\n-            let lwp = state as lwpid_t;\n-            let hint = self.state.as_mut_ptr().cast();\n-\n-            // If the parking thread terminated and did not actually park, this will\n-            // probably return an error, which is OK. In the worst case, another\n-            // thread has received the same LWP id. It will then receive a spurious\n-            // wakeup, but those are allowable per the API contract. The same reasoning\n-            // applies if a timeout occurred before this call, but the state was not\n-            // yet reset.\n-\n-            // SAFETY:\n-            // The syscall has no invariants to hold. Only unsafe because it is an\n-            // extern function.\n-            unsafe {\n-                _lwp_unpark(lwp, hint);\n-            }\n-        }\n-    }\n-}"}, {"sha": "2f5356fe2276bbb31df2c0dea47d115364860fdc", "filename": "library/std/src/sys/unix/thread_parking/darwin.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fdarwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fdarwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fdarwin.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "previous_filename": "library/std/src/sys/unix/thread_parker/darwin.rs"}, {"sha": "185333c072f49246d1315347e1040da660f1ad59", "filename": "library/std/src/sys/unix/thread_parking/mod.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fmod.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "patch": "@@ -24,7 +24,7 @@ cfg_if::cfg_if! {\n         pub use darwin::Parker;\n     } else if #[cfg(target_os = \"netbsd\")] {\n         mod netbsd;\n-        pub use netbsd::Parker;\n+        pub use netbsd::{current, park, park_timeout, unpark, ThreadId};\n     } else {\n         mod pthread;\n         pub use pthread::Parker;", "previous_filename": "library/std/src/sys/unix/thread_parker/mod.rs"}, {"sha": "a441a05da0f67ff74c8e15f9cffbcaecc7f1c878", "filename": "library/std/src/sys/unix/thread_parking/netbsd.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fnetbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fnetbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fnetbsd.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "patch": "@@ -0,0 +1,54 @@\n+#![cfg(target_os = \"netbsd\")]\n+\n+use crate::ffi::{c_int, c_void};\n+use crate::ptr::{null, null_mut};\n+use crate::time::Duration;\n+use libc::{_lwp_self, clockid_t, lwpid_t, time_t, timespec, CLOCK_MONOTONIC};\n+\n+extern \"C\" {\n+    fn ___lwp_park60(\n+        clock_id: clockid_t,\n+        flags: c_int,\n+        ts: *mut timespec,\n+        unpark: lwpid_t,\n+        hint: *const c_void,\n+        unparkhint: *const c_void,\n+    ) -> c_int;\n+    fn _lwp_unpark(lwp: lwpid_t, hint: *const c_void) -> c_int;\n+}\n+\n+pub type ThreadId = lwpid_t;\n+\n+#[inline]\n+pub fn current() -> ThreadId {\n+    unsafe { _lwp_self() }\n+}\n+\n+#[inline]\n+pub fn park() {\n+    unsafe {\n+        ___lwp_park60(0, 0, null_mut(), 0, null(), null());\n+    }\n+}\n+\n+pub fn park_timeout(dur: Duration) {\n+    let mut timeout = timespec {\n+        // Saturate so that the operation will definitely time out\n+        // (even if it is after the heat death of the universe).\n+        tv_sec: dur.as_secs().try_into().ok().unwrap_or(time_t::MAX),\n+        tv_nsec: dur.subsec_nanos().into(),\n+    };\n+\n+    // Timeout needs to be mutable since it is modified on NetBSD 9.0 and\n+    // above.\n+    unsafe {\n+        ___lwp_park60(CLOCK_MONOTONIC, 0, &mut timeout, 0, null(), null());\n+    }\n+}\n+\n+#[inline]\n+pub fn unpark(tid: ThreadId) {\n+    unsafe {\n+        _lwp_unpark(tid, null());\n+    }\n+}"}, {"sha": "510168a010fcd3541fcd69e4fcf993648eb154f0", "filename": "library/std/src/sys/unix/thread_parking/pthread.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "previous_filename": "library/std/src/sys/unix/thread_parker/pthread.rs"}, {"sha": "77359abe429950869a9c82bbb5477e1a2f3cd6af", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "patch": "@@ -33,7 +33,7 @@ pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod time;\n cfg_if::cfg_if! {\n     if #[cfg(not(target_vendor = \"uwp\"))] {"}, {"sha": "2f7ae863b6a453b48e389671e24d932646b1668f", "filename": "library/std/src/sys/windows/thread_parking.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parking.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "previous_filename": "library/std/src/sys/windows/thread_parker.rs"}, {"sha": "6b24b0e9aa8be85129f6a62bfb074db63d39e7ec", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "patch": "@@ -30,7 +30,7 @@ pub mod process;\n pub mod thread;\n pub mod thread_info;\n pub mod thread_local_dtor;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod wstr;\n pub mod wtf8;\n "}, {"sha": "d9e2f39e3451848bea88a071b3a293d24b82e517", "filename": "library/std/src/sys_common/thread_parking/futex.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Ffutex.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "previous_filename": "library/std/src/sys_common/thread_parker/futex.rs"}, {"sha": "f3d8b34d3fd39279b20887f50081e2788b65f470", "filename": "library/std/src/sys_common/thread_parking/generic.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "previous_filename": "library/std/src/sys_common/thread_parker/generic.rs"}, {"sha": "9525340b75f4db3333106492cabcb65a50a991de", "filename": "library/std/src/sys_common/thread_parking/id.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "patch": "@@ -0,0 +1,104 @@\n+//! Thread parking using thread ids.\n+//!\n+//! Some platforms (notably NetBSD) have thread parking primitives whose semantics\n+//! match those offered by `thread::park`, with the difference that the thread to\n+//! be unparked is referenced by a platform-specific thread id. Since the thread\n+//! parker is constructed before that id is known, an atomic state variable is used\n+//! to manage the park state and propagate the thread id. This also avoids platform\n+//! calls in the case where `unpark` is called before `park`.\n+\n+use crate::cell::UnsafeCell;\n+use crate::pin::Pin;\n+use crate::sync::atomic::{\n+    fence, AtomicI8,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::thread_parking::{current, park, park_timeout, unpark, ThreadId};\n+use crate::time::Duration;\n+\n+pub struct Parker {\n+    state: AtomicI8,\n+    tid: UnsafeCell<Option<ThreadId>>,\n+}\n+\n+const PARKED: i8 = -1;\n+const EMPTY: i8 = 0;\n+const NOTIFIED: i8 = 1;\n+\n+impl Parker {\n+    /// Create a new thread parker. UNIX requires this to happen in-place.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        parker.write(Parker { state: AtomicI8::new(EMPTY), tid: UnsafeCell::new(None) })\n+    }\n+\n+    /// # Safety\n+    /// * must always be called from the same thread\n+    /// * must be called before the state is set to PARKED\n+    unsafe fn init_tid(&self) {\n+        // The field is only ever written to from this thread, so we don't need\n+        // synchronization to read it here.\n+        if self.tid.get().read().is_none() {\n+            // Because this point is only reached once, before the state is set\n+            // to PARKED for the first time, the non-atomic write here can not\n+            // conflict with reads by other threads.\n+            self.tid.get().write(Some(current()));\n+            // Ensure that the write can be observed by all threads reading the\n+            // state. Synchronizes with the acquire barrier in `unpark`.\n+            fence(Release);\n+        }\n+    }\n+\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        self.init_tid();\n+\n+        // Changes NOTIFIED to EMPTY and EMPTY to PARKED.\n+        let mut state = self.state.fetch_sub(1, Acquire).wrapping_sub(1);\n+        if state == PARKED {\n+            // Loop to guard against spurious wakeups.\n+            while state == PARKED {\n+                park();\n+                state = self.state.load(Acquire);\n+            }\n+\n+            // Since the state change has already been observed with acquire\n+            // ordering, the state can be reset with a relaxed store instead\n+            // of a swap.\n+            self.state.store(EMPTY, Relaxed);\n+        }\n+    }\n+\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        self.init_tid();\n+\n+        let state = self.state.fetch_sub(1, Acquire).wrapping_sub(1);\n+        if state == PARKED {\n+            park_timeout(dur);\n+            // Swap to ensure that we observe all state changes with acquire\n+            // ordering, even if the state has been changed after the timeout\n+            // occured.\n+            self.state.swap(EMPTY, Acquire);\n+        }\n+    }\n+\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+        if state == PARKED {\n+            // Synchronize with the release fence in `init_tid` to observe the\n+            // write to `tid`.\n+            fence(Acquire);\n+            // # Safety\n+            // The thread id is initialized before the state is set to `PARKED`\n+            // for the first time and is not written to from that point on\n+            // (negating the need for an atomic read).\n+            let tid = unsafe { self.tid.get().read().unwrap_unchecked() };\n+            // It is possible that the waiting thread woke up because of a timeout\n+            // and terminated before this call is made. This call then returns an\n+            // error or wakes up an unrelated thread. The platform API and\n+            // environment does allow this, however.\n+            unpark(tid);\n+        }\n+    }\n+}\n+\n+unsafe impl Send for Parker {}\n+unsafe impl Sync for Parker {}"}, {"sha": "0ead6633c3501bd5302a4f11c3865267cd6b5d8d", "filename": "library/std/src/sys_common/thread_parking/mod.rs", "status": "renamed", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "patch": "@@ -11,13 +11,17 @@ cfg_if::cfg_if! {\n     ))] {\n         mod futex;\n         pub use futex::Parker;\n+    } else if #[cfg(any(\n+        target_os = \"netbsd\",\n+        all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+    ))] {\n+        mod id;\n+        pub use id::Parker;\n     } else if #[cfg(target_os = \"solid_asp3\")] {\n         mod wait_flag;\n         pub use wait_flag::Parker;\n     } else if #[cfg(any(windows, target_family = \"unix\"))] {\n-        pub use crate::sys::thread_parker::Parker;\n-    } else if #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] {\n-        pub use crate::sys::thread_parker::Parker;\n+        pub use crate::sys::thread_parking::Parker;\n     } else {\n         mod generic;\n         pub use generic::Parker;", "previous_filename": "library/std/src/sys_common/thread_parker/mod.rs"}, {"sha": "6561c186655a5cbbb61e1f9194394c22b6981211", "filename": "library/std/src/sys_common/thread_parking/wait_flag.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "previous_filename": "library/std/src/sys_common/thread_parker/wait_flag.rs"}, {"sha": "4add4b85ee6bfe5e616a5fb63e92bf93268fd3a8", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=a9e5c1a309df80434ebc4c1f6bfaa5cb119b465d", "patch": "@@ -173,7 +173,7 @@ use crate::sync::Arc;\n use crate::sys::thread as imp;\n use crate::sys_common::thread;\n use crate::sys_common::thread_info;\n-use crate::sys_common::thread_parker::Parker;\n+use crate::sys_common::thread_parking::Parker;\n use crate::sys_common::{AsInner, IntoInner};\n use crate::time::Duration;\n "}]}