{"sha": "e6e678fac7dd093aa7de2201e4fca746ced9b6ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZTY3OGZhYzdkZDA5M2FhN2RlMjIwMWU0ZmNhNzQ2Y2VkOWI2Y2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T22:02:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T22:02:07Z"}, "message": "auto merge of #8623 : pnkfelix/rust/fsk-visitor-vpar-defaults-step4, r=nmatsakis\n\nFollow up to #8619 (step 3 of 5).\r\n\r\n(See #8527, which was step 1 of 5, for the full outline.)\r\n\r\nPart of #7081.", "tree": {"sha": "af2439bb15f3d68994eb2ee17369f74c479f7bb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af2439bb15f3d68994eb2ee17369f74c479f7bb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6e678fac7dd093aa7de2201e4fca746ced9b6ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e678fac7dd093aa7de2201e4fca746ced9b6ca", "html_url": "https://github.com/rust-lang/rust/commit/e6e678fac7dd093aa7de2201e4fca746ced9b6ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bdceb9c00da0c83e292ca831b25a09235721d2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bdceb9c00da0c83e292ca831b25a09235721d2c", "html_url": "https://github.com/rust-lang/rust/commit/4bdceb9c00da0c83e292ca831b25a09235721d2c"}, {"sha": "f93864c8f49d477885277091ce44fafa5ac2c6c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f93864c8f49d477885277091ce44fafa5ac2c6c3", "html_url": "https://github.com/rust-lang/rust/commit/f93864c8f49d477885277091ce44fafa5ac2c6c3"}], "stats": {"total": 531, "additions": 314, "deletions": 217}, "files": [{"sha": "0fa7750afa7aadc2367740dc6f6fa2190ef687ee", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 49, "deletions": 34, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=e6e678fac7dd093aa7de2201e4fca746ced9b6ca", "patch": "@@ -27,7 +27,8 @@ use syntax::ast::{m_mutbl, m_imm, m_const};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::span;\n-use syntax::oldvisit;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n use util::ppaux::Repr;\n \n #[deriving(Clone)]\n@@ -39,6 +40,27 @@ struct CheckLoanCtxt<'self> {\n     reported: @mut HashSet<ast::NodeId>,\n }\n \n+struct CheckLoanVisitor;\n+\n+impl<'self> Visitor<CheckLoanCtxt<'self>> for CheckLoanVisitor {\n+    fn visit_expr<'a>(&mut self, ex:@ast::expr, e:CheckLoanCtxt<'a>) {\n+        check_loans_in_expr(self, ex, e);\n+    }\n+    fn visit_local(&mut self, l:@ast::Local, e:CheckLoanCtxt) {\n+        check_loans_in_local(self, l, e);\n+    }\n+    fn visit_block(&mut self, b:&ast::Block, e:CheckLoanCtxt) {\n+        check_loans_in_block(self, b, e);\n+    }\n+    fn visit_pat(&mut self, p:@ast::pat, e:CheckLoanCtxt) {\n+        check_loans_in_pat(self, p, e);\n+    }\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                b:&ast::Block, s:span, n:ast::NodeId, e:CheckLoanCtxt) {\n+        check_loans_in_fn(self, fk, fd, b, s, n, e);\n+    }\n+}\n+\n pub fn check_loans(bccx: @BorrowckCtxt,\n                    dfcx_loans: &LoanDataFlow,\n                    move_data: move_data::FlowedMoveData,\n@@ -54,15 +76,8 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n         reported: @mut HashSet::new(),\n     };\n \n-    let vt = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_expr: check_loans_in_expr,\n-        visit_local: check_loans_in_local,\n-        visit_block: check_loans_in_block,\n-        visit_pat: check_loans_in_pat,\n-        visit_fn: check_loans_in_fn,\n-        .. *oldvisit::default_visitor()\n-    });\n-    (vt.visit_block)(body, (clcx, vt));\n+    let mut vt = CheckLoanVisitor;\n+    vt.visit_block(body, clcx);\n }\n \n enum MoveError {\n@@ -626,27 +641,27 @@ impl<'self> CheckLoanCtxt<'self> {\n     }\n }\n \n-fn check_loans_in_fn<'a>(fk: &oldvisit::fn_kind,\n+fn check_loans_in_fn<'a>(visitor: &mut CheckLoanVisitor,\n+                         fk: &visit::fn_kind,\n                          decl: &ast::fn_decl,\n                          body: &ast::Block,\n                          sp: span,\n                          id: ast::NodeId,\n-                         (this, visitor): (CheckLoanCtxt<'a>,\n-                                           oldvisit::vt<CheckLoanCtxt<'a>>)) {\n+                         this: CheckLoanCtxt<'a>) {\n     match *fk {\n-        oldvisit::fk_item_fn(*) |\n-        oldvisit::fk_method(*) => {\n+        visit::fk_item_fn(*) |\n+        visit::fk_method(*) => {\n             // Don't process nested items.\n             return;\n         }\n \n-        oldvisit::fk_anon(*) |\n-        oldvisit::fk_fn_block(*) => {\n+        visit::fk_anon(*) |\n+        visit::fk_fn_block(*) => {\n             check_captured_variables(this, id, sp);\n         }\n     }\n \n-    oldvisit::visit_fn(fk, decl, body, sp, id, (this, visitor));\n+    visit::walk_fn(visitor, fk, decl, body, sp, id, this);\n \n     fn check_captured_variables(this: CheckLoanCtxt,\n                                 closure_id: ast::NodeId,\n@@ -689,16 +704,16 @@ fn check_loans_in_fn<'a>(fk: &oldvisit::fn_kind,\n     }\n }\n \n-fn check_loans_in_local<'a>(local: @ast::Local,\n-                            (this, vt): (CheckLoanCtxt<'a>,\n-                                         oldvisit::vt<CheckLoanCtxt<'a>>)) {\n-    oldvisit::visit_local(local, (this, vt));\n+fn check_loans_in_local<'a>(vt: &mut CheckLoanVisitor,\n+                            local: @ast::Local,\n+                            this: CheckLoanCtxt<'a>) {\n+    visit::walk_local(vt, local, this);\n }\n \n-fn check_loans_in_expr<'a>(expr: @ast::expr,\n-                           (this, vt): (CheckLoanCtxt<'a>,\n-                                        oldvisit::vt<CheckLoanCtxt<'a>>)) {\n-    oldvisit::visit_expr(expr, (this, vt));\n+fn check_loans_in_expr<'a>(vt: &mut CheckLoanVisitor,\n+                           expr: @ast::expr,\n+                           this: CheckLoanCtxt<'a>) {\n+    visit::walk_expr(vt, expr, this);\n \n     debug!(\"check_loans_in_expr(expr=%s)\",\n            expr.repr(this.tcx()));\n@@ -749,19 +764,19 @@ fn check_loans_in_expr<'a>(expr: @ast::expr,\n     }\n }\n \n-fn check_loans_in_pat<'a>(pat: @ast::pat,\n-                          (this, vt): (CheckLoanCtxt<'a>,\n-                                       oldvisit::vt<CheckLoanCtxt<'a>>))\n+fn check_loans_in_pat<'a>(vt: &mut CheckLoanVisitor,\n+                          pat: @ast::pat,\n+                          this: CheckLoanCtxt<'a>)\n {\n     this.check_for_conflicting_loans(pat.id);\n     this.check_move_out_from_id(pat.id, pat.span);\n-    oldvisit::visit_pat(pat, (this, vt));\n+    visit::walk_pat(vt, pat, this);\n }\n \n-fn check_loans_in_block<'a>(blk: &ast::Block,\n-                            (this, vt): (CheckLoanCtxt<'a>,\n-                                         oldvisit::vt<CheckLoanCtxt<'a>>))\n+fn check_loans_in_block<'a>(vt: &mut CheckLoanVisitor,\n+                            blk: &ast::Block,\n+                            this: CheckLoanCtxt<'a>)\n {\n-    oldvisit::visit_block(blk, (this, vt));\n+    visit::walk_block(vt, blk, this);\n     this.check_for_conflicting_loans(blk.id);\n }"}, {"sha": "e6830a1f64e7c2ad40eb522802c0c29f3b50c2b5", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=e6e678fac7dd093aa7de2201e4fca746ced9b6ca", "patch": "@@ -15,9 +15,9 @@ use syntax::ast::{Crate, NodeId, item, item_fn};\n use syntax::ast_map;\n use syntax::attr;\n use syntax::codemap::span;\n-use syntax::oldvisit::{default_visitor, mk_vt, vt, Visitor, visit_crate};\n-use syntax::oldvisit::{visit_item};\n use syntax::parse::token::special_idents;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n use std::util;\n \n struct EntryContext {\n@@ -39,7 +39,13 @@ struct EntryContext {\n     non_main_fns: ~[(NodeId, span)],\n }\n \n-type EntryVisitor = vt<@mut EntryContext>;\n+struct EntryVisitor;\n+\n+impl Visitor<@mut EntryContext> for EntryVisitor {\n+    fn visit_item(&mut self, item:@item, ctxt:@mut EntryContext) {\n+        find_item(item, ctxt, self);\n+    }\n+}\n \n pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::map) {\n \n@@ -65,15 +71,14 @@ pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::map)\n         non_main_fns: ~[],\n     };\n \n-    visit_crate(crate, (ctxt, mk_vt(@Visitor {\n-        visit_item: |item, (ctxt, visitor)| find_item(item, ctxt, visitor),\n-        .. *default_visitor()\n-    })));\n+    let mut v = EntryVisitor;\n+\n+    visit::walk_crate(&mut v, crate, ctxt);\n \n     configure_main(ctxt);\n }\n \n-fn find_item(item: @item, ctxt: @mut EntryContext, visitor: EntryVisitor) {\n+fn find_item(item: @item, ctxt: @mut EntryContext, visitor: &mut EntryVisitor) {\n     match item.node {\n         item_fn(*) => {\n             if item.ident == special_idents::main {\n@@ -120,7 +125,7 @@ fn find_item(item: @item, ctxt: @mut EntryContext, visitor: EntryVisitor) {\n         _ => ()\n     }\n \n-    visit_item(item, (ctxt, visitor));\n+    visit::walk_item(visitor, item, ctxt);\n }\n \n fn configure_main(ctxt: @mut EntryContext) {"}, {"sha": "c6446955cc891bd69af8df802f4c5da14a334b90", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 61, "deletions": 37, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=e6e678fac7dd093aa7de2201e4fca746ced9b6ca", "patch": "@@ -17,7 +17,10 @@ use middle::ty;\n \n use std::hashmap::HashMap;\n use syntax::codemap::span;\n-use syntax::{ast, ast_util, oldvisit};\n+use syntax::{ast, ast_util};\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+use syntax::ast::{item};\n \n // A vector of defs representing the free variables referred to in a function.\n // (The def_upvar will already have been stripped).\n@@ -29,27 +32,27 @@ pub struct freevar_entry {\n pub type freevar_info = @~[@freevar_entry];\n pub type freevar_map = @mut HashMap<ast::NodeId, freevar_info>;\n \n-// Searches through part of the AST for all references to locals or\n-// upvars in this frame and returns the list of definition IDs thus found.\n-// Since we want to be able to collect upvars in some arbitrary piece\n-// of the AST, we take a walker function that we invoke with a visitor\n-// in order to start the search.\n-fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block)\n-    -> freevar_info {\n-    let seen = @mut HashMap::new();\n-    let refs = @mut ~[];\n+struct CollectFreevarsVisitor {\n+    seen: @mut HashMap<ast::NodeId, ()>,\n+    refs: @mut ~[@freevar_entry],\n+    def_map: resolve::DefMap,\n+}\n+\n+impl Visitor<int> for CollectFreevarsVisitor {\n \n-    fn ignore_item(_i: @ast::item, (_depth, _v): (int, oldvisit::vt<int>)) { }\n+    fn visit_item(&mut self, _:@item, _:int) {\n+        // ignore_item\n+    }\n+\n+    fn visit_expr(&mut self, expr:@ast::expr, depth:int) {\n \n-    let walk_expr: @fn(expr: @ast::expr, (int, oldvisit::vt<int>)) =\n-        |expr, (depth, v)| {\n             match expr.node {\n               ast::expr_fn_block(*) => {\n-                oldvisit::visit_expr(expr, (depth + 1, v))\n+                visit::walk_expr(self, expr, depth + 1)\n               }\n               ast::expr_path(*) | ast::expr_self => {\n                   let mut i = 0;\n-                  match def_map.find(&expr.id) {\n+                  match self.def_map.find(&expr.id) {\n                     None => fail!(\"path not found\"),\n                     Some(&df) => {\n                       let mut def = df;\n@@ -62,28 +65,58 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block)\n                       }\n                       if i == depth { // Made it to end of loop\n                         let dnum = ast_util::def_id_of_def(def).node;\n-                        if !seen.contains_key(&dnum) {\n-                            refs.push(@freevar_entry {\n+                        if !self.seen.contains_key(&dnum) {\n+                            self.refs.push(@freevar_entry {\n                                 def: def,\n                                 span: expr.span,\n                             });\n-                            seen.insert(dnum, ());\n+                            self.seen.insert(dnum, ());\n                         }\n                       }\n                     }\n                   }\n               }\n-              _ => oldvisit::visit_expr(expr, (depth, v))\n+              _ => visit::walk_expr(self, expr, depth)\n             }\n-        };\n+    }\n \n-    let v = oldvisit::mk_vt(@oldvisit::Visitor {visit_item: ignore_item,\n-                                          visit_expr: walk_expr,\n-                                          .. *oldvisit::default_visitor()});\n-    (v.visit_block)(blk, (1, v));\n+\n+}\n+\n+// Searches through part of the AST for all references to locals or\n+// upvars in this frame and returns the list of definition IDs thus found.\n+// Since we want to be able to collect upvars in some arbitrary piece\n+// of the AST, we take a walker function that we invoke with a visitor\n+// in order to start the search.\n+fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block)\n+    -> freevar_info {\n+    let seen = @mut HashMap::new();\n+    let refs = @mut ~[];\n+\n+    let mut v = CollectFreevarsVisitor {\n+        seen: seen,\n+        refs: refs,\n+        def_map: def_map,\n+    };\n+\n+    v.visit_block(blk, 1);\n     return @(*refs).clone();\n }\n \n+struct AnnotateFreevarsVisitor {\n+    def_map: resolve::DefMap,\n+    freevars: freevar_map,\n+}\n+\n+impl Visitor<()> for AnnotateFreevarsVisitor {\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                blk:&ast::Block, s:span, nid:ast::NodeId, _:()) {\n+        let vars = collect_freevars(self.def_map, blk);\n+        self.freevars.insert(nid, vars);\n+        visit::walk_fn(self, fk, fd, blk, s, nid, ());\n+    }\n+}\n+\n // Build a map from every function and for-each body to a set of the\n // freevars contained in it. The implementation is not particularly\n // efficient as it fully recomputes the free variables at every\n@@ -93,20 +126,11 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: &ast::Crate) ->\n    freevar_map {\n     let freevars = @mut HashMap::new();\n \n-    let walk_fn: @fn(&oldvisit::fn_kind,\n-                     &ast::fn_decl,\n-                     &ast::Block,\n-                     span,\n-                     ast::NodeId) = |_, _, blk, _, nid| {\n-        let vars = collect_freevars(def_map, blk);\n-        freevars.insert(nid, vars);\n+    let mut visitor = AnnotateFreevarsVisitor {\n+        def_map: def_map,\n+        freevars: freevars,\n     };\n-\n-    let visitor =\n-        oldvisit::mk_simple_visitor(@oldvisit::SimpleVisitor {\n-            visit_fn: walk_fn,\n-            .. *oldvisit::default_simple_visitor()});\n-    oldvisit::visit_crate(crate, ((), visitor));\n+    visit::walk_crate(&mut visitor, crate, ());\n \n     return freevars;\n }"}, {"sha": "6d7d8112991efd4270363ddae46fe3cef59693d4", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=e6e678fac7dd093aa7de2201e4fca746ced9b6ca", "patch": "@@ -21,7 +21,8 @@ use syntax::attr;\n use syntax::codemap::span;\n use syntax::opt_vec;\n use syntax::print::pprust::expr_to_str;\n-use syntax::{oldvisit, ast_util};\n+use syntax::{visit,ast_util};\n+use syntax::visit::Visitor;\n \n // Kind analysis pass.\n //\n@@ -58,6 +59,29 @@ pub struct Context {\n     current_item: NodeId\n }\n \n+struct KindAnalysisVisitor;\n+\n+impl Visitor<Context> for KindAnalysisVisitor {\n+\n+    fn visit_expr(&mut self, ex:@expr, e:Context) {\n+        check_expr(self, ex, e);\n+    }\n+\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, e:Context) {\n+        check_fn(self, fk, fd, b, s, n, e);\n+    }\n+\n+    fn visit_ty(&mut self, t:&Ty, e:Context) {\n+        check_ty(self, t, e);\n+    }\n+    fn visit_item(&mut self, i:@item, e:Context) {\n+        check_item(self, i, e);\n+    }\n+    fn visit_block(&mut self, b:&Block, e:Context) {\n+        check_block(self, b, e);\n+    }\n+}\n+\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    crate: &Crate) {\n@@ -66,15 +90,8 @@ pub fn check_crate(tcx: ty::ctxt,\n         method_map: method_map,\n         current_item: -1\n     };\n-    let visit = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_expr: check_expr,\n-        visit_fn: check_fn,\n-        visit_ty: check_ty,\n-        visit_item: check_item,\n-        visit_block: check_block,\n-        .. *oldvisit::default_visitor()\n-    });\n-    oldvisit::visit_crate(crate, (ctx, visit));\n+    let mut visit = KindAnalysisVisitor;\n+    visit::walk_crate(&mut visit, crate, ctx);\n     tcx.sess.abort_if_errors();\n }\n \n@@ -108,12 +125,13 @@ fn check_struct_safe_for_destructor(cx: Context,\n     }\n }\n \n-fn check_block(block: &Block,\n-               (cx, visitor): (Context, oldvisit::vt<Context>)) {\n-    oldvisit::visit_block(block, (cx, visitor));\n+fn check_block(visitor: &mut KindAnalysisVisitor,\n+               block: &Block,\n+               cx: Context) {\n+    visit::walk_block(visitor, block, cx);\n }\n \n-fn check_item(item: @item, (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn check_item(visitor: &mut KindAnalysisVisitor, item: @item, cx: Context) {\n     // If this is a destructor, check kinds.\n     if !attr::contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n@@ -153,7 +171,7 @@ fn check_item(item: @item, (cx, visitor): (Context, oldvisit::vt<Context>)) {\n     }\n \n     let cx = Context { current_item: item.id, ..cx };\n-    oldvisit::visit_item(item, (cx, visitor));\n+    visit::walk_item(visitor, item, cx);\n }\n \n // Yields the appropriate function to check the kind of closed over\n@@ -227,13 +245,13 @@ fn with_appropriate_checker(cx: Context, id: NodeId,\n // Check that the free variables used in a shared/sendable closure conform\n // to the copy/move kind bounds. Then recursively check the function body.\n fn check_fn(\n-    fk: &oldvisit::fn_kind,\n+    v: &mut KindAnalysisVisitor,\n+    fk: &visit::fn_kind,\n     decl: &fn_decl,\n     body: &Block,\n     sp: span,\n     fn_id: NodeId,\n-    (cx, v): (Context,\n-              oldvisit::vt<Context>)) {\n+    cx: Context) {\n \n     // Check kinds on free variables:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n@@ -243,10 +261,10 @@ fn check_fn(\n         }\n     }\n \n-    oldvisit::visit_fn(fk, decl, body, sp, fn_id, (cx, v));\n+    visit::walk_fn(v, fk, decl, body, sp, fn_id, cx);\n }\n \n-pub fn check_expr(e: @expr, (cx, v): (Context, oldvisit::vt<Context>)) {\n+pub fn check_expr(v: &mut KindAnalysisVisitor, e: @expr, cx: Context) {\n     debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters\n@@ -311,10 +329,10 @@ pub fn check_expr(e: @expr, (cx, v): (Context, oldvisit::vt<Context>)) {\n         }\n         _ => {}\n     }\n-    oldvisit::visit_expr(e, (cx, v));\n+    visit::walk_expr(v, e, cx);\n }\n \n-fn check_ty(aty: &Ty, (cx, v): (Context, oldvisit::vt<Context>)) {\n+fn check_ty(v: &mut KindAnalysisVisitor, aty: &Ty, cx: Context) {\n     match aty.node {\n       ty_path(_, _, id) => {\n           let r = cx.tcx.node_type_substs.find(&id);\n@@ -329,7 +347,7 @@ fn check_ty(aty: &Ty, (cx, v): (Context, oldvisit::vt<Context>)) {\n       }\n       _ => {}\n     }\n-    oldvisit::visit_ty(aty, (cx, v));\n+    visit::walk_ty(v, aty, cx);\n }\n \n // Calls \"any_missing\" if any bounds were missing."}, {"sha": "9b11301a9c494256c644730a9d4f049783d77b6e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e6e678fac7dd093aa7de2201e4fca746ced9b6ca", "patch": "@@ -26,8 +26,9 @@ use metadata::cstore::iter_crate_data;\n use syntax::ast::{Crate, def_id, MetaItem};\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n-use syntax::oldvisit::{default_simple_visitor, mk_simple_visitor};\n-use syntax::oldvisit::{SimpleVisitor, visit_crate};\n+use syntax::ast::{item};\n+use syntax::visit;\n+use syntax::visit::Visitor;\n \n use std::hashmap::HashMap;\n \n@@ -292,6 +293,27 @@ struct LanguageItemCollector<'self> {\n     item_refs: HashMap<@str, uint>,\n }\n \n+struct LanguageItemVisitor<'self> {\n+    this: *mut LanguageItemCollector<'self>,\n+}\n+\n+impl<'self> Visitor<()> for LanguageItemVisitor<'self> {\n+\n+    fn visit_item(&mut self, item:@item, _:()) {\n+\n+                for attribute in item.attrs.iter() {\n+                    unsafe {\n+                        (*self.this).match_and_collect_meta_item(\n+                            local_def(item.id),\n+                            attribute.node.value\n+                        );\n+                    }\n+                }\n+\n+        visit::walk_item(self, item, ());\n+    }\n+}\n+\n impl<'self> LanguageItemCollector<'self> {\n     pub fn new<'a>(crate: &'a Crate, session: Session)\n                    -> LanguageItemCollector<'a> {\n@@ -404,19 +426,8 @@ impl<'self> LanguageItemCollector<'self> {\n \n     pub fn collect_local_language_items(&mut self) {\n         let this: *mut LanguageItemCollector = &mut *self;\n-        visit_crate(self.crate, ((), mk_simple_visitor(@SimpleVisitor {\n-            visit_item: |item| {\n-                for attribute in item.attrs.iter() {\n-                    unsafe {\n-                        (*this).match_and_collect_meta_item(\n-                            local_def(item.id),\n-                            attribute.node.value\n-                        );\n-                    }\n-                }\n-            },\n-            .. *default_simple_visitor()\n-        })));\n+        let mut v = LanguageItemVisitor { this: this };\n+        visit::walk_crate(&mut v, self.crate, ());\n     }\n \n     pub fn collect_external_language_items(&mut self) {"}, {"sha": "b659f6081b12a05d0d13994884d0789b642b626a", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 73, "deletions": 63, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=e6e678fac7dd093aa7de2201e4fca746ced9b6ca", "patch": "@@ -45,10 +45,7 @@ use syntax::ast_map;\n use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::codemap::{span, dummy_sp};\n use syntax::opt_vec;\n-use syntax::oldvisit::{default_simple_visitor, default_visitor};\n-use syntax::oldvisit::{mk_simple_visitor, mk_vt, visit_crate, visit_item};\n-use syntax::oldvisit::{Visitor, SimpleVisitor};\n-use syntax::oldvisit::{visit_mod};\n+use syntax::visit;\n use syntax::parse;\n use util::ppaux::ty_to_str;\n \n@@ -168,31 +165,89 @@ pub struct CoherenceChecker {\n     base_type_def_ids: @mut HashMap<def_id,def_id>,\n }\n \n-impl CoherenceChecker {\n-    pub fn check_coherence(self, crate: &Crate) {\n-        // Check implementations and traits. This populates the tables\n-        // containing the inherent methods and extension methods. It also\n-        // builds up the trait inheritance table.\n-        visit_crate(crate, ((), mk_simple_visitor(@SimpleVisitor {\n-            visit_item: |item| {\n+struct CoherenceCheckVisitor { cc: CoherenceChecker }\n+\n+impl visit::Visitor<()> for CoherenceCheckVisitor {\n+    fn visit_item(&mut self, item:@item, _:()) {\n+\n //                debug!(\"(checking coherence) item '%s'\",\n-//                       self.crate_context.tcx.sess.str_of(item.ident));\n+//                       self.cc.crate_context.tcx.sess.str_of(item.ident));\n \n                 match item.node {\n                     item_impl(_, ref opt_trait, _, _) => {\n                         let opt_trait : ~[trait_ref] =\n                             opt_trait.iter()\n                                      .map(|x| (*x).clone())\n                                      .collect();\n-                        self.check_implementation(item, opt_trait);\n+                        self.cc.check_implementation(item, opt_trait);\n                     }\n                     _ => {\n                         // Nothing to do.\n                     }\n                 };\n-            },\n-            .. *default_simple_visitor()\n-        })));\n+\n+        visit::walk_item(self, item, ());\n+    }\n+}\n+\n+struct PrivilegedScopeVisitor { cc: CoherenceChecker }\n+\n+impl visit::Visitor<()> for PrivilegedScopeVisitor {\n+    fn visit_item(&mut self, item:@item, _:()) {\n+\n+                match item.node {\n+                    item_mod(ref module_) => {\n+                        // Then visit the module items.\n+                        visit::walk_mod(self, module_, ());\n+                    }\n+                    item_impl(_, None, ref ast_ty, _) => {\n+                        if !self.cc.ast_type_is_defined_in_local_crate(ast_ty) {\n+                            // This is an error.\n+                            let session = self.cc.crate_context.tcx.sess;\n+                            session.span_err(item.span,\n+                                             \"cannot associate methods with a type outside the \\\n+                                              crate the type is defined in; define and implement \\\n+                                              a trait or new type instead\");\n+                        }\n+                    }\n+                    item_impl(_, Some(ref trait_ref), _, _) => {\n+                        // `for_ty` is `Type` in `impl Trait for Type`\n+                        let for_ty =\n+                            ty::node_id_to_type(self.cc.crate_context.tcx,\n+                                                item.id);\n+                        if !type_is_defined_in_local_crate(for_ty) {\n+                            // This implementation is not in scope of its base\n+                            // type. This still might be OK if the trait is\n+                            // defined in the same crate.\n+\n+                            let trait_def_id =\n+                                self.cc.trait_ref_to_trait_def_id(trait_ref);\n+\n+                            if trait_def_id.crate != LOCAL_CRATE {\n+                                let session = self.cc.crate_context.tcx.sess;\n+                                session.span_err(item.span,\n+                                                 \"cannot provide an extension implementation \\\n+                                                  for a trait not defined in this crate\");\n+                            }\n+                        }\n+\n+                        visit::walk_item(self, item, ());\n+                    }\n+                    _ => {\n+                        visit::walk_item(self, item, ());\n+                    }\n+                }\n+    }\n+}\n+\n+impl CoherenceChecker {\n+    pub fn check_coherence(self, crate: &Crate) {\n+        // Check implementations and traits. This populates the tables\n+        // containing the inherent methods and extension methods. It also\n+        // builds up the trait inheritance table.\n+\n+        let mut visitor = CoherenceCheckVisitor { cc: self };\n+        visit::walk_crate(&mut visitor, crate, ());\n \n         // Check that there are no overlapping trait instances\n         self.check_implementation_coherence();\n@@ -486,53 +541,8 @@ impl CoherenceChecker {\n \n     // Privileged scope checking\n     pub fn check_privileged_scopes(self, crate: &Crate) {\n-        visit_crate(crate, ((), mk_vt(@Visitor {\n-            visit_item: |item, (_context, visitor)| {\n-                match item.node {\n-                    item_mod(ref module_) => {\n-                        // Then visit the module items.\n-                        visit_mod(module_, item.span, item.id, ((), visitor));\n-                    }\n-                    item_impl(_, None, ref ast_ty, _) => {\n-                        if !self.ast_type_is_defined_in_local_crate(ast_ty) {\n-                            // This is an error.\n-                            let session = self.crate_context.tcx.sess;\n-                            session.span_err(item.span,\n-                                             \"cannot associate methods with a type outside the \\\n-                                              crate the type is defined in; define and implement \\\n-                                              a trait or new type instead\");\n-                        }\n-                    }\n-                    item_impl(_, Some(ref trait_ref), _, _) => {\n-                        // `for_ty` is `Type` in `impl Trait for Type`\n-                        let for_ty =\n-                            ty::node_id_to_type(self.crate_context.tcx,\n-                                                item.id);\n-                        if !type_is_defined_in_local_crate(for_ty) {\n-                            // This implementation is not in scope of its base\n-                            // type. This still might be OK if the trait is\n-                            // defined in the same crate.\n-\n-                            let trait_def_id =\n-                                self.trait_ref_to_trait_def_id(trait_ref);\n-\n-                            if trait_def_id.crate != LOCAL_CRATE {\n-                                let session = self.crate_context.tcx.sess;\n-                                session.span_err(item.span,\n-                                                 \"cannot provide an extension implementation \\\n-                                                  for a trait not defined in this crate\");\n-                            }\n-                        }\n-\n-                        visit_item(item, ((), visitor));\n-                    }\n-                    _ => {\n-                        visit_item(item, ((), visitor));\n-                    }\n-                }\n-            },\n-            .. *default_visitor()\n-        })));\n+        let mut visitor = PrivilegedScopeVisitor{ cc: self };\n+        visit::walk_crate(&mut visitor, crate, ());\n     }\n \n     pub fn trait_ref_to_trait_def_id(&self, trait_ref: &trait_ref) -> def_id {"}, {"sha": "22d7a4a5f58443e96eb1097481d55deffa1141dd", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=e6e678fac7dd093aa7de2201e4fca746ced9b6ca", "patch": "@@ -11,7 +11,8 @@\n \n use syntax::ast;\n use syntax::codemap::{span};\n-use syntax::oldvisit;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n \n use std::hashmap::HashSet;\n use extra;\n@@ -59,42 +60,48 @@ pub fn field_exprs(fields: ~[ast::Field]) -> ~[@ast::expr] {\n     fields.map(|f| f.expr)\n }\n \n-// Takes a predicate p, returns true iff p is true for any subexpressions\n-// of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: &ast::Block, p: @fn(&ast::expr_) -> bool) -> bool {\n-    let rs = @mut false;\n-    let visit_expr: @fn(@ast::expr,\n-                        (@mut bool,\n-                         oldvisit::vt<@mut bool>)) = |e, (flag, v)| {\n-        *flag |= p(&e.node);\n+struct LoopQueryVisitor {\n+    p: @fn(&ast::expr_) -> bool\n+}\n+\n+impl Visitor<@mut bool> for LoopQueryVisitor {\n+    fn visit_expr(&mut self, e:@ast::expr, flag:@mut bool) {\n+        *flag |= (self.p)(&e.node);\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n           ast::expr_loop(*) | ast::expr_while(*) => {}\n-          _ => oldvisit::visit_expr(e, (flag, v))\n+          _ => visit::walk_expr(self, e, flag)\n         }\n-    };\n-    let v = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_expr: visit_expr,\n-        .. *oldvisit::default_visitor()});\n-    oldvisit::visit_block(b, (rs, v));\n+    }\n+}\n+\n+// Takes a predicate p, returns true iff p is true for any subexpressions\n+// of b -- skipping any inner loops (loop, while, loop_body)\n+pub fn loop_query(b: &ast::Block, p: @fn(&ast::expr_) -> bool) -> bool {\n+    let rs = @mut false;\n+    let mut v = LoopQueryVisitor { p: p };\n+    visit::walk_block(&mut v, b, rs);\n     return *rs;\n }\n \n+struct BlockQueryVisitor {\n+    p: @fn(@ast::expr) -> bool\n+}\n+\n+impl Visitor<@mut bool> for BlockQueryVisitor {\n+    fn visit_expr(&mut self, e:@ast::expr, flag:@mut bool) {\n+        *flag |= (self.p)(e);\n+        visit::walk_expr(self, e, flag)\n+    }\n+}\n+\n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n pub fn block_query(b: &ast::Block, p: @fn(@ast::expr) -> bool) -> bool {\n     let rs = @mut false;\n-    let visit_expr: @fn(@ast::expr,\n-                        (@mut bool,\n-                         oldvisit::vt<@mut bool>)) = |e, (flag, v)| {\n-        *flag |= p(e);\n-        oldvisit::visit_expr(e, (flag, v))\n-    };\n-    let v = oldvisit::mk_vt(@oldvisit::Visitor{\n-        visit_expr: visit_expr,\n-        .. *oldvisit::default_visitor()});\n-    oldvisit::visit_block(b, (rs, v));\n+    let mut v = BlockQueryVisitor { p: p };\n+    visit::walk_block(&mut v, b, rs);\n     return *rs;\n }\n "}, {"sha": "467a3fdc278372eeb07180a57081d3aebc31bd13", "filename": "src/librusti/utils.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrusti%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e678fac7dd093aa7de2201e4fca746ced9b6ca/src%2Flibrusti%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Futils.rs?ref=e6e678fac7dd093aa7de2201e4fca746ced9b6ca", "patch": "@@ -13,24 +13,31 @@ use syntax::ast;\n use syntax::print::pp;\n use syntax::print::pprust;\n use syntax::parse::token;\n+use syntax::visit;\n \n-pub fn each_binding(l: @ast::Local, f: @fn(&ast::Path, ast::NodeId)) {\n-    use syntax::oldvisit;\n+struct EachBindingVisitor {\n+    f: @fn(&ast::Path, ast::NodeId)\n+}\n \n-    let vt = oldvisit::mk_simple_visitor(\n-        @oldvisit::SimpleVisitor {\n-            visit_pat: |pat| {\n+impl visit::Visitor<()> for EachBindingVisitor {\n+    fn visit_pat(&mut self, pat:@ast::pat, _:()) {\n                 match pat.node {\n                     ast::pat_ident(_, ref path, _) => {\n-                        f(path, pat.id);\n+                        (self.f)(path, pat.id);\n                     }\n                     _ => {}\n                 }\n-            },\n-            .. *oldvisit::default_simple_visitor()\n-        }\n-    );\n-    (vt.visit_pat)(l.pat, ((), vt));\n+\n+                visit::walk_pat(self, pat, ());\n+    }\n+}\n+\n+pub fn each_binding(l: @ast::Local, f: @fn(&ast::Path, ast::NodeId)) {\n+    use syntax::visit::Visitor;\n+\n+    let mut vt = EachBindingVisitor{ f: f };\n+\n+    vt.visit_pat(l.pat, ());\n }\n \n /// A utility function that hands off a pretty printer to a callback."}]}