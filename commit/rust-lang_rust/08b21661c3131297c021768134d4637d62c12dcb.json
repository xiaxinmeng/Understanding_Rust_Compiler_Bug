{"sha": "08b21661c3131297c021768134d4637d62c12dcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YjIxNjYxYzMxMzEyOTdjMDIxNzY4MTM0ZDQ2MzdkNjJjMTJkY2I=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-06-29T18:44:40Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-06-29T20:18:08Z"}, "message": "Refine Atomic*::compare_and_swap documentation\n\nNamely:\n\n* Change parameter `old` to read `current` so it is clearer what the argument refers to (originally\n    suggested `expected`, but shot down by Steve);\n* Add some formatting and fix some mistakes like referring to the method as `swap` rather than\n  `compare_and_swap`.", "tree": {"sha": "36bafc896baaa1a880ae4303717aec0b09358bd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36bafc896baaa1a880ae4303717aec0b09358bd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08b21661c3131297c021768134d4637d62c12dcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08b21661c3131297c021768134d4637d62c12dcb", "html_url": "https://github.com/rust-lang/rust/commit/08b21661c3131297c021768134d4637d62c12dcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08b21661c3131297c021768134d4637d62c12dcb/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "216f6645ef0c93776e9f350f29c02780fb7bf673", "url": "https://api.github.com/repos/rust-lang/rust/commits/216f6645ef0c93776e9f350f29c02780fb7bf673", "html_url": "https://github.com/rust-lang/rust/commit/216f6645ef0c93776e9f350f29c02780fb7bf673"}], "stats": {"total": 46, "additions": 23, "deletions": 23}, "files": [{"sha": "5e6be49be97ef77ed0ec9c8228559b607a09c615", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/08b21661c3131297c021768134d4637d62c12dcb/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b21661c3131297c021768134d4637d62c12dcb/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=08b21661c3131297c021768134d4637d62c12dcb", "patch": "@@ -272,13 +272,13 @@ impl AtomicBool {\n         unsafe { atomic_swap(self.v.get(), val, order) > 0 }\n     }\n \n-    /// Stores a value into the bool if the current value is the same as the expected value.\n+    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `old`, then the value was\n-    /// updated.\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n     ///\n-    /// `swap` also takes an `Ordering` argument which describes the memory ordering of this\n-    /// operation.\n+    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n+    /// this operation.\n     ///\n     /// # Examples\n     ///\n@@ -295,11 +295,11 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n-        let old = if old { UINT_TRUE } else { 0 };\n+    pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n+        let current = if current { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) > 0 }\n+        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) > 0 }\n     }\n \n     /// Logical \"and\" with a boolean value.\n@@ -515,10 +515,10 @@ impl AtomicIsize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n-    /// Stores a value into the isize if the current value is the same as the expected value.\n+    /// Stores a value into the `isize` if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `old`, then the value was\n-    /// updated.\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n     ///\n     /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n     /// this operation.\n@@ -538,8 +538,8 @@ impl AtomicIsize {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, old: isize, new: isize, order: Ordering) -> isize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n+    pub fn compare_and_swap(&self, current: isize, new: isize, order: Ordering) -> isize {\n+        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) }\n     }\n \n     /// Add an isize to the current value, returning the previous value.\n@@ -709,10 +709,10 @@ impl AtomicUsize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n-    /// Stores a value into the usize if the current value is the same as the expected value.\n+    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `old`, then the value was\n-    /// updated.\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n     ///\n     /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n     /// this operation.\n@@ -732,8 +732,8 @@ impl AtomicUsize {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, old: usize, new: usize, order: Ordering) -> usize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n+    pub fn compare_and_swap(&self, current: usize, new: usize, order: Ordering) -> usize {\n+        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) }\n     }\n \n     /// Add to the current usize, returning the previous value.\n@@ -910,10 +910,10 @@ impl<T> AtomicPtr<T> {\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n \n-    /// Stores a value into the pointer if the current value is the same as the expected value.\n+    /// Stores a value into the pointer if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `old`, then the value was\n-    /// updated.\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n     ///\n     /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n     /// this operation.\n@@ -933,9 +933,9 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n+    pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_compare_and_swap(self.p.get() as *mut usize, old as usize,\n+            atomic_compare_and_swap(self.p.get() as *mut usize, current as usize,\n                                     new as usize, order) as *mut T\n         }\n     }"}]}