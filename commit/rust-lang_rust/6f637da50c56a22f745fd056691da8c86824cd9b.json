{"sha": "6f637da50c56a22f745fd056691da8c86824cd9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNjM3ZGE1MGM1NmEyMmY3NDVmZDA1NjY5MWRhOGM4NjgyNGNkOWI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-22T00:35:02Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-22T15:07:44Z"}, "message": "Remove Ty prefix from Ty{Adt|Array|Slice|RawPtr|Ref|FnDef|FnPtr|Dynamic|Closure|Generator|GeneratorWitness|Never|Tuple|Projection|Anon|Infer|Error}", "tree": {"sha": "2025348c4a042bad7eb0cb4cf3b48445ee025e36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2025348c4a042bad7eb0cb4cf3b48445ee025e36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f637da50c56a22f745fd056691da8c86824cd9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f637da50c56a22f745fd056691da8c86824cd9b", "html_url": "https://github.com/rust-lang/rust/commit/6f637da50c56a22f745fd056691da8c86824cd9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f637da50c56a22f745fd056691da8c86824cd9b/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d37cee3b0e859a1303ece1cade3176cc150d28b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d37cee3b0e859a1303ece1cade3176cc150d28b4", "html_url": "https://github.com/rust-lang/rust/commit/d37cee3b0e859a1303ece1cade3176cc150d28b4"}], "stats": {"total": 2860, "additions": 1430, "deletions": 1430}, "files": [{"sha": "0cc1df2b8c24e230fad413e67656ce9b60d9f92e", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -809,8 +809,8 @@ for ty::TyKind<'gcx>\n             TyBool  |\n             TyChar  |\n             TyStr   |\n-            TyError |\n-            TyNever => {\n+            Error |\n+            Never => {\n                 // Nothing more to hash.\n             }\n             TyInt(int_ty) => {\n@@ -822,55 +822,55 @@ for ty::TyKind<'gcx>\n             TyFloat(float_ty)  => {\n                 float_ty.hash_stable(hcx, hasher);\n             }\n-            TyAdt(adt_def, substs) => {\n+            Adt(adt_def, substs) => {\n                 adt_def.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }\n-            TyArray(inner_ty, len) => {\n+            Array(inner_ty, len) => {\n                 inner_ty.hash_stable(hcx, hasher);\n                 len.hash_stable(hcx, hasher);\n             }\n-            TySlice(inner_ty) => {\n+            Slice(inner_ty) => {\n                 inner_ty.hash_stable(hcx, hasher);\n             }\n-            TyRawPtr(pointee_ty) => {\n+            RawPtr(pointee_ty) => {\n                 pointee_ty.hash_stable(hcx, hasher);\n             }\n-            TyRef(region, pointee_ty, mutbl) => {\n+            Ref(region, pointee_ty, mutbl) => {\n                 region.hash_stable(hcx, hasher);\n                 pointee_ty.hash_stable(hcx, hasher);\n                 mutbl.hash_stable(hcx, hasher);\n             }\n-            TyFnDef(def_id, substs) => {\n+            FnDef(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }\n-            TyFnPtr(ref sig) => {\n+            FnPtr(ref sig) => {\n                 sig.hash_stable(hcx, hasher);\n             }\n-            TyDynamic(ref existential_predicates, region) => {\n+            Dynamic(ref existential_predicates, region) => {\n                 existential_predicates.hash_stable(hcx, hasher);\n                 region.hash_stable(hcx, hasher);\n             }\n-            TyClosure(def_id, closure_substs) => {\n+            Closure(def_id, closure_substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 closure_substs.hash_stable(hcx, hasher);\n             }\n-            TyGenerator(def_id, generator_substs, movability) => {\n+            Generator(def_id, generator_substs, movability) => {\n                 def_id.hash_stable(hcx, hasher);\n                 generator_substs.hash_stable(hcx, hasher);\n                 movability.hash_stable(hcx, hasher);\n             }\n-            TyGeneratorWitness(types) => {\n+            GeneratorWitness(types) => {\n                 types.hash_stable(hcx, hasher)\n             }\n-            TyTuple(inner_tys) => {\n+            Tuple(inner_tys) => {\n                 inner_tys.hash_stable(hcx, hasher);\n             }\n-            TyProjection(ref projection_ty) => {\n+            Projection(ref projection_ty) => {\n                 projection_ty.hash_stable(hcx, hasher);\n             }\n-            TyAnon(def_id, substs) => {\n+            Anon(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }\n@@ -880,7 +880,7 @@ for ty::TyKind<'gcx>\n             TyForeign(def_id) => {\n                 def_id.hash_stable(hcx, hasher);\n             }\n-            TyInfer(infer_ty) => {\n+            Infer(infer_ty) => {\n                 infer_ty.hash_stable(hcx, hasher);\n             }\n         }"}, {"sha": "96c64c05ccfbd9418868d5d1e8dbdf9d54a9976f", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -592,7 +592,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match ty.sty {\n-            ty::TyClosure(def_id, substs) => {\n+            ty::Closure(def_id, substs) => {\n                 // I am a horrible monster and I pray for death. When\n                 // we encounter a closure here, it is always a closure\n                 // from within the function that we are currently\n@@ -655,7 +655,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             tcx,\n             reg_op: |reg| reg,\n             fldop: |ty| {\n-                if let ty::TyAnon(def_id, substs) = ty.sty {\n+                if let ty::Anon(def_id, substs) = ty.sty {\n                     // Check that this is `impl Trait` type is\n                     // declared by `parent_def_id` -- i.e., one whose\n                     // value we are inferring.  At present, this is\n@@ -679,7 +679,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                     // ```\n                     //\n                     // Here, the return type of `foo` references a\n-                    // `TyAnon` indeed, but not one whose value is\n+                    // `Anon` indeed, but not one whose value is\n                     // presently being inferred. You can get into a\n                     // similar situation with closure return types\n                     // today:\n@@ -755,11 +755,11 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n \n         debug!(\n-            \"instantiate_anon_types: TyAnon(def_id={:?}, substs={:?})\",\n+            \"instantiate_anon_types: Anon(def_id={:?}, substs={:?})\",\n             def_id, substs\n         );\n \n-        // Use the same type variable if the exact same TyAnon appears more\n+        // Use the same type variable if the exact same Anon appears more\n         // than once in the return type (e.g. if it's passed to a type alias).\n         if let Some(anon_defn) = self.anon_types.get(&def_id) {\n             return anon_defn.concrete_ty;\n@@ -805,7 +805,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n \n         for predicate in bounds.predicates {\n             // Change the predicate to refer to the type variable,\n-            // which will be the concrete type, instead of the TyAnon.\n+            // which will be the concrete type, instead of the Anon.\n             // This also instantiates nested `impl Trait`.\n             let predicate = self.instantiate_anon_types_in_map(&predicate);\n "}, {"sha": "062c12579d9634cef10734798e3c62f69b5b9328", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -246,46 +246,46 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n-            ty::TyInfer(ty::TyVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::General, t),\n+            ty::Infer(ty::TyVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::General, t),\n \n-            ty::TyInfer(ty::IntVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Int, t),\n+            ty::Infer(ty::IntVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Int, t),\n \n-            ty::TyInfer(ty::FloatVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Float, t),\n+            ty::Infer(ty::FloatVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Float, t),\n \n-            ty::TyInfer(ty::FreshTy(_))\n-            | ty::TyInfer(ty::FreshIntTy(_))\n-            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+            ty::Infer(ty::FreshTy(_))\n+            | ty::Infer(ty::FreshIntTy(_))\n+            | ty::Infer(ty::FreshFloatTy(_)) => {\n                 bug!(\"encountered a fresh type during canonicalization\")\n             }\n \n-            ty::TyInfer(ty::CanonicalTy(_)) => {\n+            ty::Infer(ty::CanonicalTy(_)) => {\n                 bug!(\"encountered a canonical type during canonicalization\")\n             }\n \n-            ty::TyClosure(..)\n-            | ty::TyGenerator(..)\n-            | ty::TyGeneratorWitness(..)\n+            ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n             | ty::TyBool\n             | ty::TyChar\n             | ty::TyInt(..)\n             | ty::TyUint(..)\n             | ty::TyFloat(..)\n-            | ty::TyAdt(..)\n+            | ty::Adt(..)\n             | ty::TyStr\n-            | ty::TyError\n-            | ty::TyArray(..)\n-            | ty::TySlice(..)\n-            | ty::TyRawPtr(..)\n-            | ty::TyRef(..)\n-            | ty::TyFnDef(..)\n-            | ty::TyFnPtr(_)\n-            | ty::TyDynamic(..)\n-            | ty::TyNever\n-            | ty::TyTuple(..)\n-            | ty::TyProjection(..)\n+            | ty::Error\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Dynamic(..)\n+            | ty::Never\n+            | ty::Tuple(..)\n+            | ty::Projection(..)\n             | ty::TyForeign(..)\n             | ty::TyParam(..)\n-            | ty::TyAnon(..) => {\n+            | ty::Anon(..) => {\n                 if t.flags.intersects(self.needs_canonical_flags) {\n                     t.super_fold_with(self)\n                 } else {"}, {"sha": "341089d8a815fcae015207ade5208a22dee211cc", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -421,7 +421,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             match result_value.unpack() {\n                 UnpackedKind::Type(result_value) => {\n                     // e.g., here `result_value` might be `?0` in the example above...\n-                    if let ty::TyInfer(ty::InferTy::CanonicalTy(index)) = result_value.sty {\n+                    if let ty::Infer(ty::InferTy::CanonicalTy(index)) = result_value.sty {\n                         // in which case we would set `canonical_vars[0]` to `Some(?U)`.\n                         opt_values[index] = Some(*original_value);\n                     }"}, {"sha": "f3fe01d5fd121659b064b389ac35e240fb200034", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -85,7 +85,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'g\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n-            ty::TyInfer(ty::InferTy::CanonicalTy(c)) => {\n+            ty::Infer(ty::InferTy::CanonicalTy(c)) => {\n                 match self.var_values.var_values[c].unpack() {\n                     UnpackedKind::Type(ty) => ty,\n                     r => bug!(\"{:?} is a type but value is {:?}\", c, r),"}, {"sha": "6d4293216a440dee2eaa53e3e637af7cabb0a462", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -76,44 +76,44 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n \n         match (&a.sty, &b.sty) {\n             // Relate integral variables to other types\n-            (&ty::TyInfer(ty::IntVar(a_id)), &ty::TyInfer(ty::IntVar(b_id))) => {\n+            (&ty::Infer(ty::IntVar(a_id)), &ty::Infer(ty::IntVar(b_id))) => {\n                 self.int_unification_table\n                     .borrow_mut()\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| int_unification_error(a_is_expected, e))?;\n                 Ok(a)\n             }\n-            (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyInt(v)) => {\n+            (&ty::Infer(ty::IntVar(v_id)), &ty::TyInt(v)) => {\n                 self.unify_integral_variable(a_is_expected, v_id, IntType(v))\n             }\n-            (&ty::TyInt(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n+            (&ty::TyInt(v), &ty::Infer(ty::IntVar(v_id))) => {\n                 self.unify_integral_variable(!a_is_expected, v_id, IntType(v))\n             }\n-            (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyUint(v)) => {\n+            (&ty::Infer(ty::IntVar(v_id)), &ty::TyUint(v)) => {\n                 self.unify_integral_variable(a_is_expected, v_id, UintType(v))\n             }\n-            (&ty::TyUint(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n+            (&ty::TyUint(v), &ty::Infer(ty::IntVar(v_id))) => {\n                 self.unify_integral_variable(!a_is_expected, v_id, UintType(v))\n             }\n \n             // Relate floating-point variables to other types\n-            (&ty::TyInfer(ty::FloatVar(a_id)), &ty::TyInfer(ty::FloatVar(b_id))) => {\n+            (&ty::Infer(ty::FloatVar(a_id)), &ty::Infer(ty::FloatVar(b_id))) => {\n                 self.float_unification_table\n                     .borrow_mut()\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n                 Ok(a)\n             }\n-            (&ty::TyInfer(ty::FloatVar(v_id)), &ty::TyFloat(v)) => {\n+            (&ty::Infer(ty::FloatVar(v_id)), &ty::TyFloat(v)) => {\n                 self.unify_float_variable(a_is_expected, v_id, v)\n             }\n-            (&ty::TyFloat(v), &ty::TyInfer(ty::FloatVar(v_id))) => {\n+            (&ty::TyFloat(v), &ty::Infer(ty::FloatVar(v_id))) => {\n                 self.unify_float_variable(!a_is_expected, v_id, v)\n             }\n \n             // All other cases of inference are errors\n-            (&ty::TyInfer(_), _) |\n-            (_, &ty::TyInfer(_)) => {\n+            (&ty::Infer(_), _) |\n+            (_, &ty::Infer(_)) => {\n                 Err(TypeError::Sorts(ty::relate::expected_found(relation, &a, &b)))\n             }\n \n@@ -393,7 +393,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n         // subtyping. This is basically our \"occurs check\", preventing\n         // us from creating infinitely sized types.\n         match t.sty {\n-            ty::TyInfer(ty::TyVar(vid)) => {\n+            ty::Infer(ty::TyVar(vid)) => {\n                 let mut variables = self.infcx.type_variables.borrow_mut();\n                 let vid = variables.root_var(vid);\n                 let sub_vid = variables.sub_root_var(vid);\n@@ -433,8 +433,8 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                     }\n                 }\n             }\n-            ty::TyInfer(ty::IntVar(_)) |\n-            ty::TyInfer(ty::FloatVar(_)) => {\n+            ty::Infer(ty::IntVar(_)) |\n+            ty::Infer(ty::FloatVar(_)) => {\n                 // No matter what mode we are in,\n                 // integer/floating-point types must be equal to be\n                 // relatable."}, {"sha": "26eb2ffbf6aba763e12245a9d92c53d3fa52ba96", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -75,17 +75,17 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n         let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n-            (&ty::TyInfer(TyVar(a_id)), &ty::TyInfer(TyVar(b_id))) => {\n+            (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().equate(a_id, b_id);\n                 Ok(a)\n             }\n \n-            (&ty::TyInfer(TyVar(a_id)), _) => {\n+            (&ty::Infer(TyVar(a_id)), _) => {\n                 self.fields.instantiate(b, RelationDir::EqTo, a_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n-            (_, &ty::TyInfer(TyVar(b_id))) => {\n+            (_, &ty::Infer(TyVar(b_id))) => {\n                 self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }"}, {"sha": "4275e56db4e3cc4d9c99c868dd4762a850473835", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -484,7 +484,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // if they are both \"path types\", there's a chance of ambiguity\n                 // due to different versions of the same crate\n                 match (&exp_found.expected.sty, &exp_found.found.sty) {\n-                    (&ty::TyAdt(exp_adt, _), &ty::TyAdt(found_adt, _)) => {\n+                    (&ty::Adt(exp_adt, _), &ty::Adt(found_adt, _)) => {\n                         report_path_match(err, exp_adt.did, found_adt.did);\n                     }\n                     _ => (),\n@@ -636,7 +636,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n                 return Some(());\n             }\n-            if let &ty::TyAdt(def, _) = &ta.sty {\n+            if let &ty::Adt(def, _) = &ta.sty {\n                 let path_ = self.tcx.item_path_str(def.did.clone());\n                 if path_ == other_path {\n                     self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n@@ -704,14 +704,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         fn equals<'tcx>(a: &Ty<'tcx>, b: &Ty<'tcx>) -> bool {\n             match (&a.sty, &b.sty) {\n                 (a, b) if *a == *b => true,\n-                (&ty::TyInt(_), &ty::TyInfer(ty::InferTy::IntVar(_)))\n-                | (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInt(_))\n-                | (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInfer(ty::InferTy::IntVar(_)))\n-                | (&ty::TyFloat(_), &ty::TyInfer(ty::InferTy::FloatVar(_)))\n-                | (&ty::TyInfer(ty::InferTy::FloatVar(_)), &ty::TyFloat(_))\n+                (&ty::TyInt(_), &ty::Infer(ty::InferTy::IntVar(_)))\n+                | (&ty::Infer(ty::InferTy::IntVar(_)), &ty::TyInt(_))\n+                | (&ty::Infer(ty::InferTy::IntVar(_)), &ty::Infer(ty::InferTy::IntVar(_)))\n+                | (&ty::TyFloat(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n+                | (&ty::Infer(ty::InferTy::FloatVar(_)), &ty::TyFloat(_))\n                 | (\n-                    &ty::TyInfer(ty::InferTy::FloatVar(_)),\n-                    &ty::TyInfer(ty::InferTy::FloatVar(_)),\n+                    &ty::Infer(ty::InferTy::FloatVar(_)),\n+                    &ty::Infer(ty::InferTy::FloatVar(_)),\n                 ) => true,\n                 _ => false,\n             }\n@@ -738,7 +738,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         match (&t1.sty, &t2.sty) {\n-            (&ty::TyAdt(def1, sub1), &ty::TyAdt(def2, sub2)) => {\n+            (&ty::Adt(def1, sub1), &ty::Adt(def2, sub2)) => {\n                 let sub_no_defaults_1 = self.strip_generic_default_params(def1.did, sub1);\n                 let sub_no_defaults_2 = self.strip_generic_default_params(def2.did, sub2);\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n@@ -877,22 +877,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // When finding T != &T, highlight only the borrow\n-            (&ty::TyRef(r1, ref_ty1, mutbl1), _) if equals(&ref_ty1, &t2) => {\n+            (&ty::Ref(r1, ref_ty1, mutbl1), _) if equals(&ref_ty1, &t2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n                 values.1.push_normal(t2.to_string());\n                 values\n             }\n-            (_, &ty::TyRef(r2, ref_ty2, mutbl2)) if equals(&t1, &ref_ty2) => {\n+            (_, &ty::Ref(r2, ref_ty2, mutbl2)) if equals(&t1, &ref_ty2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 values.0.push_normal(t1.to_string());\n                 push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n                 values\n             }\n \n             // When encountering &T != &mut T, highlight only the borrow\n-            (&ty::TyRef(r1, ref_ty1, mutbl1),\n-             &ty::TyRef(r2, ref_ty2, mutbl2)) if equals(&ref_ty1, &ref_ty2) => {\n+            (&ty::Ref(r1, ref_ty1, mutbl1),\n+             &ty::Ref(r2, ref_ty2, mutbl2)) if equals(&ref_ty1, &ref_ty2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n                 push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n@@ -979,14 +979,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 (_, false, _) => {\n                     if let Some(exp_found) = exp_found {\n                         let (def_id, ret_ty) = match exp_found.found.sty {\n-                            TyKind::TyFnDef(def, _) => {\n+                            TyKind::FnDef(def, _) => {\n                                 (Some(def), Some(self.tcx.fn_sig(def).output()))\n                             }\n                             _ => (None, None),\n                         };\n \n                         let exp_is_struct = match exp_found.expected.sty {\n-                            TyKind::TyAdt(def, _) => def.is_struct(),\n+                            TyKind::Adt(def, _) => def.is_struct(),\n                             _ => false,\n                         };\n "}, {"sha": "505b1bc032d2021b9dbe6457c07b8015b460c049", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -12,7 +12,7 @@ use hir::{self, Local, Pat, Body, HirId};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use infer::InferCtxt;\n use infer::type_variable::TypeVariableOrigin;\n-use ty::{self, Ty, TyInfer, TyVar};\n+use ty::{self, Ty, Infer, TyVar};\n use syntax::source_map::CompilerDesugaringKind;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n@@ -35,7 +35,7 @@ impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n                 let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n                 ty.walk().any(|inner_ty| {\n                     inner_ty == *self.target_ty || match (&inner_ty.sty, &self.target_ty.sty) {\n-                        (&TyInfer(TyVar(a_vid)), &TyInfer(TyVar(b_vid))) => {\n+                        (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => {\n                             self.infcx\n                                 .type_variables\n                                 .borrow_mut()\n@@ -75,7 +75,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn extract_type_name(&self, ty: &'a Ty<'tcx>) -> String {\n-        if let ty::TyInfer(ty::TyVar(ty_vid)) = (*ty).sty {\n+        if let ty::Infer(ty::TyVar(ty_vid)) = (*ty).sty {\n             let ty_vars = self.type_variables.borrow();\n             if let TypeVariableOrigin::TypeParameterDefinition(_, name) =\n                 *ty_vars.var_origin(ty_vid) {"}, {"sha": "8cb0df18bc8fff5c96e786b0173323539ada4d52", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -162,7 +162,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ) -> Option<Span> {\n         let ret_ty = self.tcx.type_of(scope_def_id);\n         match ret_ty.sty {\n-            ty::TyFnDef(_, _) => {\n+            ty::FnDef(_, _) => {\n                 let sig = ret_ty.fn_sig(self.tcx);\n                 let late_bound_regions = self.tcx\n                     .collect_referenced_late_bound_regions(&sig.output());\n@@ -181,7 +181,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ) -> bool {\n         let ret_ty = self.tcx.type_of(scope_def_id);\n         match ret_ty.sty {\n-            ty::TyFnDef(_, _) => {\n+            ty::FnDef(_, _) => {\n                 let sig = ret_ty.fn_sig(self.tcx);\n                 let output = self.tcx.erase_late_bound_regions(&sig.output());\n                 return output.is_impl_trait();"}, {"sha": "06bc1bfbaf471a7a19765e60eec3fe75ab5b79b2", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -133,15 +133,15 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n         let tcx = self.infcx.tcx;\n \n         match t.sty {\n-            ty::TyInfer(ty::TyVar(v)) => {\n+            ty::Infer(ty::TyVar(v)) => {\n                 let opt_ty = self.infcx.type_variables.borrow_mut().probe(v).known();\n                 self.freshen(\n                     opt_ty,\n                     ty::TyVar(v),\n                     ty::FreshTy)\n             }\n \n-            ty::TyInfer(ty::IntVar(v)) => {\n+            ty::Infer(ty::IntVar(v)) => {\n                 self.freshen(\n                     self.infcx.int_unification_table.borrow_mut()\n                                                     .probe_value(v)\n@@ -150,7 +150,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                     ty::FreshIntTy)\n             }\n \n-            ty::TyInfer(ty::FloatVar(v)) => {\n+            ty::Infer(ty::FloatVar(v)) => {\n                 self.freshen(\n                     self.infcx.float_unification_table.borrow_mut()\n                                                       .probe_value(v)\n@@ -159,9 +159,9 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                     ty::FreshFloatTy)\n             }\n \n-            ty::TyInfer(ty::FreshTy(c)) |\n-            ty::TyInfer(ty::FreshIntTy(c)) |\n-            ty::TyInfer(ty::FreshFloatTy(c)) => {\n+            ty::Infer(ty::FreshTy(c)) |\n+            ty::Infer(ty::FreshIntTy(c)) |\n+            ty::Infer(ty::FreshFloatTy(c)) => {\n                 if c >= self.freshen_count {\n                     bug!(\"Encountered a freshend type with id {} \\\n                           but our counter is only at {}\",\n@@ -171,33 +171,33 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 t\n             }\n \n-            ty::TyInfer(ty::CanonicalTy(..)) =>\n+            ty::Infer(ty::CanonicalTy(..)) =>\n                 bug!(\"encountered canonical ty during freshening\"),\n \n-            ty::TyGenerator(..) |\n+            ty::Generator(..) |\n             ty::TyBool |\n             ty::TyChar |\n             ty::TyInt(..) |\n             ty::TyUint(..) |\n             ty::TyFloat(..) |\n-            ty::TyAdt(..) |\n+            ty::Adt(..) |\n             ty::TyStr |\n-            ty::TyError |\n-            ty::TyArray(..) |\n-            ty::TySlice(..) |\n-            ty::TyRawPtr(..) |\n-            ty::TyRef(..) |\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) |\n-            ty::TyDynamic(..) |\n-            ty::TyNever |\n-            ty::TyTuple(..) |\n-            ty::TyProjection(..) |\n+            ty::Error |\n+            ty::Array(..) |\n+            ty::Slice(..) |\n+            ty::RawPtr(..) |\n+            ty::Ref(..) |\n+            ty::FnDef(..) |\n+            ty::FnPtr(_) |\n+            ty::Dynamic(..) |\n+            ty::Never |\n+            ty::Tuple(..) |\n+            ty::Projection(..) |\n             ty::TyForeign(..) |\n             ty::TyParam(..) |\n-            ty::TyClosure(..) |\n-            ty::TyGeneratorWitness(..) |\n-            ty::TyAnon(..) => {\n+            ty::Closure(..) |\n+            ty::GeneratorWitness(..) |\n+            ty::Anon(..) => {\n                 t.super_fold_with(self)\n             }\n         }"}, {"sha": "39dc24b86e72a8851c08aa06894eefb91f4fb3df", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match ty.sty {\n-            ty::TyInfer(ty::InferTy::TyVar(vid)) => {\n+            ty::Infer(ty::InferTy::TyVar(vid)) => {\n                 match self.type_variables.get(&vid) {\n                     None => {\n                         // This variable was created before the"}, {"sha": "6848c625b5a1ff7fe6bac250f2b27aef24bcb905", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -88,12 +88,12 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n         // is (e.g.) `Box<i32>`. A more obvious solution might be to\n         // iterate on the subtype obligations that are returned, but I\n         // think this suffices. -nmatsakis\n-        (&ty::TyInfer(TyVar(..)), _) => {\n+        (&ty::Infer(TyVar(..)), _) => {\n             let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, b, a)?;\n             Ok(v)\n         }\n-        (_, &ty::TyInfer(TyVar(..))) => {\n+        (_, &ty::Infer(TyVar(..))) => {\n             let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)"}, {"sha": "a3c9d14eef2954f1530ed8f1cf997fe63f668417", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn type_var_diverges(&'a self, ty: Ty) -> bool {\n         match ty.sty {\n-            ty::TyInfer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n+            ty::Infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n             _ => false\n         }\n     }\n@@ -559,14 +559,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         use ty::error::UnconstrainedNumeric::Neither;\n         use ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n         match ty.sty {\n-            ty::TyInfer(ty::IntVar(vid)) => {\n+            ty::Infer(ty::IntVar(vid)) => {\n                 if self.int_unification_table.borrow_mut().probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n             },\n-            ty::TyInfer(ty::FloatVar(vid)) => {\n+            ty::Infer(ty::FloatVar(vid)) => {\n                 if self.float_unification_table.borrow_mut().probe_value(vid).is_some() {\n                     Neither\n                 } else {\n@@ -1118,7 +1118,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match typ.sty {\n-            ty::TyInfer(ty::TyVar(v)) => {\n+            ty::Infer(ty::TyVar(v)) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n                 // it can be resolved to an int/float variable, which\n                 // can then be recursively resolved, hence the\n@@ -1135,15 +1135,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                    .unwrap_or(typ)\n             }\n \n-            ty::TyInfer(ty::IntVar(v)) => {\n+            ty::Infer(ty::IntVar(v)) => {\n                 self.int_unification_table\n                     .borrow_mut()\n                     .probe_value(v)\n                     .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n \n-            ty::TyInfer(ty::FloatVar(v)) => {\n+            ty::Infer(ty::FloatVar(v)) => {\n                 self.float_unification_table\n                     .borrow_mut()\n                     .probe_value(v)\n@@ -1210,12 +1210,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // [Note-Type-error-reporting]\n-    // An invariant is that anytime the expected or actual type is TyError (the special\n+    // An invariant is that anytime the expected or actual type is Error (the special\n     // error type, meaning that an error occurred when typechecking this expression),\n     // this is a derived error. The error cascaded from another error (that was already\n     // reported), so it's not useful to display it to the user.\n     // The following methods implement this logic.\n-    // They check if either the actual or expected type is TyError, and don't print the error\n+    // They check if either the actual or expected type is Error, and don't print the error\n     // in this case. The typechecker should only ever report type errors involving mismatched\n     // types using one of these methods, and should not call span_err directly for such\n     // errors.\n@@ -1230,7 +1230,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n         debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n \n-        // Don't report an error if actual type is TyError.\n+        // Don't report an error if actual type is Error.\n         if actual_ty.references_error() {\n             return self.tcx.sess.diagnostic().struct_dummy();\n         }"}, {"sha": "c1006c17ba28756236ad36fbe677bd6d9a4cf60e", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -451,7 +451,7 @@ where\n     fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n         match ty.sty {\n             ty::TyParam(p) => self.param_bound(p),\n-            ty::TyProjection(data) => {\n+            ty::Projection(data) => {\n                 let declared_bounds = self.projection_declared_bounds(data);\n                 self.projection_bound(declared_bounds, data)\n             }"}, {"sha": "be13fb9a2a5ebf8818925001a71e5d0bea08e7e4", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'gcx, 'tcx>\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         let t = self.infcx.shallow_resolve(t);\n         if t.has_infer_types() {\n-            if let ty::TyInfer(_) = t.sty {\n+            if let ty::Infer(_) = t.sty {\n                 // Since we called `shallow_resolve` above, this must\n                 // be an (as yet...) unresolved inference variable.\n                 true\n@@ -158,19 +158,19 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             match t.sty {\n-                ty::TyInfer(ty::TyVar(vid)) => {\n+                ty::Infer(ty::TyVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedTy(vid));\n                     self.tcx().types.err\n                 }\n-                ty::TyInfer(ty::IntVar(vid)) => {\n+                ty::Infer(ty::IntVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedIntTy(vid));\n                     self.tcx().types.err\n                 }\n-                ty::TyInfer(ty::FloatVar(vid)) => {\n+                ty::Infer(ty::FloatVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedFloatTy(vid));\n                     self.tcx().types.err\n                 }\n-                ty::TyInfer(_) => {\n+                ty::Infer(_) => {\n                     bug!(\"Unexpected type in full type resolver: {:?}\", t);\n                 }\n                 _ => {"}, {"sha": "048810c042722f552de6844b3e5862f1d13b9a53", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -80,7 +80,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n         let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n-            (&ty::TyInfer(TyVar(a_vid)), &ty::TyInfer(TyVar(b_vid))) => {\n+            (&ty::Infer(TyVar(a_vid)), &ty::Infer(TyVar(b_vid))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n                 // this under a binder below without fear of accidental\n                 // capture.\n@@ -106,17 +106,17 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n \n                 Ok(a)\n             }\n-            (&ty::TyInfer(TyVar(a_id)), _) => {\n+            (&ty::Infer(TyVar(a_id)), _) => {\n                 self.fields\n                     .instantiate(b, RelationDir::SupertypeOf, a_id, !self.a_is_expected)?;\n                 Ok(a)\n             }\n-            (_, &ty::TyInfer(TyVar(b_id))) => {\n+            (_, &ty::Infer(TyVar(b_id))) => {\n                 self.fields.instantiate(a, RelationDir::SubtypeOf, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n-            (&ty::TyError, _) | (_, &ty::TyError) => {\n+            (&ty::Error, _) | (_, &ty::Error) => {\n                 infcx.set_tainted_by_errors();\n                 Ok(self.tcx().types.err)\n             }"}, {"sha": "b1e4fc7c7fc7b1127e9192bf3dcbbd72162ceb17", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -245,7 +245,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// instantiated. Otherwise, returns `t`.\n     pub fn replace_if_possible(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n-            ty::TyInfer(ty::TyVar(v)) => {\n+            ty::Infer(ty::TyVar(v)) => {\n                 match self.probe(v) {\n                     TypeVariableValue::Unknown { .. } => t,\n                     TypeVariableValue::Known { value } => value,"}, {"sha": "26f83bb9a3a45a95b4f42fd5266bc7d11889df7b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -105,19 +105,19 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, node_id: ast::NodeId) {\n         match self.tables.expr_ty_adjusted(lhs).sty {\n-            ty::TyAdt(def, _) => {\n+            ty::Adt(def, _) => {\n                 let index = self.tcx.field_index(node_id, self.tables);\n                 self.insert_def_id(def.non_enum_variant().fields[index].did);\n             }\n-            ty::TyTuple(..) => {}\n+            ty::Tuple(..) => {}\n             _ => span_bug!(lhs.span, \"named field access on non-ADT\"),\n         }\n     }\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n                                   pats: &[source_map::Spanned<hir::FieldPat>]) {\n         let variant = match self.tables.node_id_to_type(lhs.hir_id).sty {\n-            ty::TyAdt(adt, _) => adt.variant_of_def(def),\n+            ty::Adt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.handle_field_access(&lhs, expr.id);\n             }\n             hir::ExprKind::Struct(_, ref fields, _) => {\n-                if let ty::TyKind::TyAdt(ref adt, _) = self.tables.expr_ty(expr).sty {\n+                if let ty::TyKind::Adt(ref adt, _) = self.tables.expr_ty(expr).sty {\n                     self.mark_as_used_if_union(adt, fields);\n                 }\n             }"}, {"sha": "90692bcd30103303fa1df4cecade47c976500d7d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -457,7 +457,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.mc.expr_ty(expr));\n-                if let ty::TyRef(r, _, _) = expr_ty.sty {\n+                if let ty::Ref(r, _, _) = expr_ty.sty {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.borrow_expr(&base, r, bk, AddrOf);\n                 }\n@@ -551,10 +551,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n                callee, callee_ty);\n         match callee_ty.sty {\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+            ty::FnDef(..) | ty::FnPtr(_) => {\n                 self.consume_expr(callee);\n             }\n-            ty::TyError => { }\n+            ty::Error => { }\n             _ => {\n                 if let Some(def) = self.mc.tables.type_dependent_defs().get(call.hir_id) {\n                     let def_id = def.def_id();\n@@ -659,7 +659,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // Select just those fields of the `with`\n         // expression that will actually be used\n         match with_cmt.ty.sty {\n-            ty::TyAdt(adt, substs) if adt.is_struct() => {\n+            ty::Adt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n                     let is_mentioned = fields.iter().any(|f| {\n@@ -867,7 +867,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     // It is also a borrow or copy/move of the value being matched.\n                     match bm {\n                         ty::BindByReference(m) => {\n-                            if let ty::TyRef(r, _, _) = pat_ty.sty {\n+                            if let ty::Ref(r, _, _) = pat_ty.sty {\n                                 let bk = ty::BorrowKind::from_mutbl(m);\n                                 delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n                             }"}, {"sha": "8058f3dde668d8fd23f44eef940ecb1f15b929ed", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -41,7 +41,7 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 ty: Ty<'tcx>)\n                                 -> Ty<'tcx> {\n     let (def, substs) = match ty.sty {\n-        ty::TyAdt(def, substs) => (def, substs),\n+        ty::Adt(def, substs) => (def, substs),\n         _ => return ty\n     };\n \n@@ -83,7 +83,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n             // Special-case transmutting from `typeof(function)` and\n             // `Option<typeof(function)>` to present a clearer error.\n             let from = unpack_option_like(self.tcx.global_tcx(), from);\n-            if let (&ty::TyFnDef(..), SizeSkeleton::Known(size_to)) = (&from.sty, sk_to) {\n+            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (&from.sty, sk_to) {\n                 if size_to == Pointer.size(self.tcx) {\n                     struct_span_err!(self.tcx.sess, span, E0591,\n                                      \"can't transmute zero-sized type\")"}, {"sha": "e0ed0f1da509ee30bace777fd56ebeaae91eebab", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -214,8 +214,8 @@ impl<'tcx> cmt_<'tcx> {\n     fn resolve_field(&self, field_index: usize) -> Option<(&'tcx ty::AdtDef, &'tcx ty::FieldDef)>\n     {\n         let adt_def = match self.ty.sty {\n-            ty::TyAdt(def, _) => def,\n-            ty::TyTuple(..) => return None,\n+            ty::Adt(def, _) => def,\n+            ty::Tuple(..) => return None,\n             // closures get `Categorization::Upvar` rather than `Categorization::Interior`\n             _ =>  bug!(\"interior cmt {:?} is not an ADT\", self)\n         };\n@@ -783,8 +783,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // FnOnce         | copied               | upvar -> &'up bk\n \n         let kind = match self.node_ty(fn_hir_id)?.sty {\n-            ty::TyGenerator(..) => ty::ClosureKind::FnOnce,\n-            ty::TyClosure(closure_def_id, closure_substs) => {\n+            ty::Generator(..) => ty::ClosureKind::FnOnce,\n+            ty::Closure(closure_def_id, closure_substs) => {\n                 match self.infcx {\n                     // During upvar inference we may not know the\n                     // closure kind, just use the LATTICE_BOTTOM value.\n@@ -893,7 +893,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // that the above is actually immutable and\n         // has a ref type.  However, nothing should\n         // actually look at the type, so we can get\n-        // away with stuffing a `TyError` in there\n+        // away with stuffing a `Error` in there\n         // instead of bothering to construct a proper\n         // one.\n         let cmt_result = cmt_ {\n@@ -956,7 +956,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n         let promotable = match expr_ty.sty {\n-            ty::TyArray(_, len) if len.assert_usize(self.tcx) == Some(0) => true,\n+            ty::Array(_, len) if len.assert_usize(self.tcx) == Some(0) => true,\n             _ => promotable,\n         };\n \n@@ -1035,7 +1035,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let base_ty = self.expr_ty_adjusted(base)?;\n \n         let (region, mutbl) = match base_ty.sty {\n-            ty::TyRef(region, _, mutbl) => (region, mutbl),\n+            ty::Ref(region, _, mutbl) => (region, mutbl),\n             _ => {\n                 span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\")\n             }\n@@ -1068,9 +1068,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         };\n \n         let ptr = match base_cmt.ty.sty {\n-            ty::TyAdt(def, ..) if def.is_box() => Unique,\n-            ty::TyRawPtr(ref mt) => UnsafePtr(mt.mutbl),\n-            ty::TyRef(r, _, mutbl) => {\n+            ty::Adt(def, ..) if def.is_box() => Unique,\n+            ty::RawPtr(ref mt) => UnsafePtr(mt.mutbl),\n+            ty::Ref(r, _, mutbl) => {\n                 let bk = ty::BorrowKind::from_mutbl(mutbl);\n                 BorrowedPtr(bk, r)\n             }\n@@ -1290,7 +1290,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 }\n                 Def::StructCtor(_, CtorKind::Fn) => {\n                     match self.pat_ty_unadjusted(&pat)?.sty {\n-                        ty::TyAdt(adt_def, _) => {\n+                        ty::Adt(adt_def, _) => {\n                             (cmt, adt_def.non_enum_variant().fields.len())\n                         }\n                         ref ty => {\n@@ -1343,7 +1343,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           PatKind::Tuple(ref subpats, ddpos) => {\n             // (p1, ..., pN)\n             let expected_len = match self.pat_ty_unadjusted(&pat)?.sty {\n-                ty::TyTuple(ref tys) => tys.len(),\n+                ty::Tuple(ref tys) => tys.len(),\n                 ref ty => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {"}, {"sha": "9d556902e43db256e7baa812b49478cfdbfb0115", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -2248,14 +2248,14 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: &ty::Const) -> fmt::Result {\n         }\n     }\n     // print function definitons\n-    if let TyFnDef(did, _) = ty.sty {\n+    if let FnDef(did, _) = ty.sty {\n         return write!(f, \"{}\", item_path_str(did));\n     }\n     // print string literals\n     if let ConstValue::ScalarPair(ptr, len) = value {\n         if let Scalar::Ptr(ptr) = ptr {\n             if let ScalarMaybeUndef::Scalar(Scalar::Bits { bits: len, .. }) = len {\n-                if let TyRef(_, &ty::TyS { sty: TyStr, .. }, _) = ty.sty {\n+                if let Ref(_, &ty::TyS { sty: TyStr, .. }, _) = ty.sty {\n                     return ty::tls::with(|tcx| {\n                         let alloc = tcx.alloc_map.lock().get(ptr.alloc_id);\n                         if let Some(interpret::AllocType::Memory(alloc)) = alloc {"}, {"sha": "ec395478ec6b57ecde1d4870368bae142aeca2fa", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -68,12 +68,12 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                 let ty = self.to_ty(tcx);\n                 PlaceTy::Ty {\n                     ty: match ty.sty {\n-                        ty::TyArray(inner, size) => {\n+                        ty::Array(inner, size) => {\n                             let size = size.unwrap_usize(tcx);\n                             let len = size - (from as u64) - (to as u64);\n                             tcx.mk_array(inner, len)\n                         }\n-                        ty::TySlice(..) => ty,\n+                        ty::Slice(..) => ty,\n                         _ => {\n                             bug!(\"cannot subslice non-array type: `{:?}`\", self)\n                         }\n@@ -82,7 +82,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n             }\n             ProjectionElem::Downcast(adt_def1, index) =>\n                 match self.to_ty(tcx).sty {\n-                    ty::TyAdt(adt_def, substs) => {\n+                    ty::Adt(adt_def, substs) => {\n                         assert!(adt_def.is_enum());\n                         assert!(index < adt_def.variants.len());\n                         assert_eq!(adt_def, adt_def1);\n@@ -199,7 +199,7 @@ impl<'tcx> Rvalue<'tcx> {\n             }\n             Rvalue::Discriminant(ref place) => {\n                 let ty = place.ty(local_decls, tcx).to_ty(tcx);\n-                if let ty::TyAdt(adt_def, _) = ty.sty {\n+                if let ty::Adt(adt_def, _) = ty.sty {\n                     adt_def.repr.discr_type().to_ty(tcx)\n                 } else {\n                     // This can only be `0`, for now, so `u8` will suffice."}, {"sha": "87296f631bdab051c2f5c42043d6ea03346eb3a9", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -607,7 +607,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n         return match substs.type_at(0).sty {\n             ty::TyParam(_) => true,\n-            ty::TyProjection(p) => self.is_of_param(p.substs),\n+            ty::Projection(p) => self.is_of_param(p.substs),\n             _ => false,\n         };\n     }"}, {"sha": "2e82bad877cb77105d6ecb8cf600d2daddde168e", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -407,7 +407,7 @@ fn uncovered_tys<'tcx>(tcx: TyCtxt, ty: Ty<'tcx>, in_crate: InCrate)\n \n fn is_possibly_remote_type(ty: Ty, _in_crate: InCrate) -> bool {\n     match ty.sty {\n-        ty::TyProjection(..) | ty::TyParam(..) => true,\n+        ty::Projection(..) | ty::TyParam(..) => true,\n         _ => false,\n     }\n }\n@@ -419,9 +419,9 @@ fn ty_is_local(tcx: TyCtxt, ty: Ty, in_crate: InCrate) -> bool {\n \n fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     match ty.sty {\n-        ty::TyRef(..) => true,\n-        ty::TyAdt(def, _) => def.is_fundamental(),\n-        ty::TyDynamic(ref data, ..) => {\n+        ty::Ref(..) => true,\n+        ty::Adt(def, _) => def.is_fundamental(),\n+        ty::Dynamic(ref data, ..) => {\n             data.principal().map_or(false, |p| tcx.has_attr(p.def_id(), \"fundamental\"))\n         }\n         _ => false\n@@ -447,43 +447,43 @@ fn ty_is_local_constructor(ty: Ty, in_crate: InCrate) -> bool {\n         ty::TyUint(..) |\n         ty::TyFloat(..) |\n         ty::TyStr |\n-        ty::TyFnDef(..) |\n-        ty::TyFnPtr(_) |\n-        ty::TyArray(..) |\n-        ty::TySlice(..) |\n-        ty::TyRawPtr(..) |\n-        ty::TyRef(..) |\n-        ty::TyNever |\n-        ty::TyTuple(..) |\n+        ty::FnDef(..) |\n+        ty::FnPtr(_) |\n+        ty::Array(..) |\n+        ty::Slice(..) |\n+        ty::RawPtr(..) |\n+        ty::Ref(..) |\n+        ty::Never |\n+        ty::Tuple(..) |\n         ty::TyParam(..) |\n-        ty::TyProjection(..) => {\n+        ty::Projection(..) => {\n             false\n         }\n \n-        ty::TyInfer(..) => match in_crate {\n+        ty::Infer(..) => match in_crate {\n             InCrate::Local => false,\n             // The inference variable might be unified with a local\n             // type in that remote crate.\n             InCrate::Remote => true,\n         },\n \n-        ty::TyAdt(def, _) => def_id_is_local(def.did, in_crate),\n+        ty::Adt(def, _) => def_id_is_local(def.did, in_crate),\n         ty::TyForeign(did) => def_id_is_local(did, in_crate),\n \n-        ty::TyDynamic(ref tt, ..) => {\n+        ty::Dynamic(ref tt, ..) => {\n             tt.principal().map_or(false, |p| {\n                 def_id_is_local(p.def_id(), in_crate)\n             })\n         }\n \n-        ty::TyError => {\n+        ty::Error => {\n             true\n         }\n \n-        ty::TyClosure(..) |\n-        ty::TyGenerator(..) |\n-        ty::TyGeneratorWitness(..) |\n-        ty::TyAnon(..) => {\n+        ty::Closure(..) |\n+        ty::Generator(..) |\n+        ty::GeneratorWitness(..) |\n+        ty::Anon(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n         }\n     }"}, {"sha": "cfb4e049e92b0e741f78b819570792d850792080", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -247,33 +247,33 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyBool => Some(0),\n                 ty::TyChar => Some(1),\n                 ty::TyStr => Some(2),\n-                ty::TyInt(..) | ty::TyUint(..) | ty::TyInfer(ty::IntVar(..)) => Some(3),\n-                ty::TyFloat(..) | ty::TyInfer(ty::FloatVar(..)) => Some(4),\n-                ty::TyRef(..) | ty::TyRawPtr(..) => Some(5),\n-                ty::TyArray(..) | ty::TySlice(..) => Some(6),\n-                ty::TyFnDef(..) | ty::TyFnPtr(..) => Some(7),\n-                ty::TyDynamic(..) => Some(8),\n-                ty::TyClosure(..) => Some(9),\n-                ty::TyTuple(..) => Some(10),\n-                ty::TyProjection(..) => Some(11),\n+                ty::TyInt(..) | ty::TyUint(..) | ty::Infer(ty::IntVar(..)) => Some(3),\n+                ty::TyFloat(..) | ty::Infer(ty::FloatVar(..)) => Some(4),\n+                ty::Ref(..) | ty::RawPtr(..) => Some(5),\n+                ty::Array(..) | ty::Slice(..) => Some(6),\n+                ty::FnDef(..) | ty::FnPtr(..) => Some(7),\n+                ty::Dynamic(..) => Some(8),\n+                ty::Closure(..) => Some(9),\n+                ty::Tuple(..) => Some(10),\n+                ty::Projection(..) => Some(11),\n                 ty::TyParam(..) => Some(12),\n-                ty::TyAnon(..) => Some(13),\n-                ty::TyNever => Some(14),\n-                ty::TyAdt(adt, ..) => match adt.adt_kind() {\n+                ty::Anon(..) => Some(13),\n+                ty::Never => Some(14),\n+                ty::Adt(adt, ..) => match adt.adt_kind() {\n                     AdtKind::Struct => Some(15),\n                     AdtKind::Union => Some(16),\n                     AdtKind::Enum => Some(17),\n                 },\n-                ty::TyGenerator(..) => Some(18),\n+                ty::Generator(..) => Some(18),\n                 ty::TyForeign(..) => Some(19),\n-                ty::TyGeneratorWitness(..) => Some(20),\n-                ty::TyInfer(..) | ty::TyError => None\n+                ty::GeneratorWitness(..) => Some(20),\n+                ty::Infer(..) | ty::Error => None\n             }\n         }\n \n         match (type_category(a), type_category(b)) {\n             (Some(cat_a), Some(cat_b)) => match (&a.sty, &b.sty) {\n-                (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => def_a == def_b,\n+                (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n                 _ => cat_a == cat_b\n             },\n             // infer and error can be equated to all types\n@@ -784,25 +784,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let found_trait_ty = found_trait_ref.self_ty();\n \n                 let found_did = match found_trait_ty.sty {\n-                    ty::TyClosure(did, _) |\n+                    ty::Closure(did, _) |\n                     ty::TyForeign(did) |\n-                    ty::TyFnDef(did, _) => Some(did),\n-                    ty::TyAdt(def, _) => Some(def.did),\n+                    ty::FnDef(did, _) => Some(did),\n+                    ty::Adt(def, _) => Some(def.did),\n                     _ => None,\n                 };\n                 let found_span = found_did.and_then(|did| {\n                     self.tcx.hir.span_if_local(did)\n                 }).map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n \n                 let found = match found_trait_ref.skip_binder().substs.type_at(1).sty {\n-                    ty::TyTuple(ref tys) => tys.iter()\n+                    ty::Tuple(ref tys) => tys.iter()\n                         .map(|_| ArgKind::empty()).collect::<Vec<_>>(),\n                     _ => vec![ArgKind::empty()],\n                 };\n                 let expected = match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n-                    ty::TyTuple(ref tys) => tys.iter()\n+                    ty::Tuple(ref tys) => tys.iter()\n                         .map(|t| match t.sty {\n-                            ty::TyKind::TyTuple(ref tys) => ArgKind::Tuple(\n+                            ty::TyKind::Tuple(ref tys) => ArgKind::Tuple(\n                                 Some(span),\n                                 tys.iter()\n                                     .map(|ty| (\"_\".to_owned(), ty.sty.to_string()))\n@@ -899,7 +899,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let mut trait_type = trait_ref.self_ty();\n \n             for refs_remaining in 0..refs_number {\n-                if let ty::TyKind::TyRef(_, t_type, _) = trait_type.sty {\n+                if let ty::TyKind::Ref(_, t_type, _) = trait_type.sty {\n                     trait_type = t_type;\n \n                     let substs = self.tcx.mk_substs_trait(trait_type, &[]);\n@@ -1143,7 +1143,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         fn build_fn_sig_string<'a, 'gcx, 'tcx>(tcx: ty::TyCtxt<'a, 'gcx, 'tcx>,\n                                                trait_ref: &ty::TraitRef<'tcx>) -> String {\n             let inputs = trait_ref.substs.type_at(1);\n-            let sig = if let ty::TyTuple(inputs) = inputs.sty {\n+            let sig = if let ty::Tuple(inputs) = inputs.sty {\n                 tcx.mk_fn_sig(\n                     inputs.iter().map(|&x| x),\n                     tcx.mk_infer(ty::TyVar(ty::TyVid { index: 0 })),\n@@ -1594,7 +1594,7 @@ impl ArgKind {\n     /// argument. This has no name (`_`) and no source spans..\n     pub fn from_expected_ty(t: Ty<'_>) -> ArgKind {\n         match t.sty {\n-            ty::TyTuple(ref tys) => ArgKind::Tuple(\n+            ty::Tuple(ref tys) => ArgKind::Tuple(\n                 None,\n                 tys.iter()\n                    .map(|ty| (\"_\".to_owned(), ty.sty.to_string()))"}, {"sha": "5c977e1bf624be9a0c6a804d7aa4ae3aaec88eb8", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -540,7 +540,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n      .map(|t| selcx.infcx().resolve_type_vars_if_possible(&t))\n      .filter(|t| t.has_infer_types())\n      .flat_map(|t| t.walk())\n-     .filter(|t| match t.sty { ty::TyInfer(_) => true, _ => false })\n+     .filter(|t| match t.sty { ty::Infer(_) => true, _ => false })\n      .collect()\n }\n "}, {"sha": "dc1da5b0461b60fdfd57598d914d215772bedb1f", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -379,7 +379,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     false // no contained types to walk\n                 }\n \n-                ty::TyProjection(ref data) => {\n+                ty::Projection(ref data) => {\n                     // This is a projected type `<Foo as SomeTrait>::X`.\n \n                     // Compute supertraits of current trait lazily."}, {"sha": "939ba92c7badfdce7af71823f05079204bc405f2", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -366,7 +366,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n \n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n-            ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n+            ty::Anon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {\n                     Reveal::UserFacing => ty,\n@@ -393,7 +393,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                 }\n             }\n \n-            ty::TyProjection(ref data) if !data.has_escaping_regions() => { // (*)\n+            ty::Projection(ref data) if !data.has_escaping_regions() => { // (*)\n \n                 // (*) This is kind of hacky -- we need to be able to\n                 // handle normalization within binders because\n@@ -812,10 +812,10 @@ fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n /// return an associated obligation that, when fulfilled, will lead to\n /// an error.\n ///\n-/// Note that we used to return `TyError` here, but that was quite\n+/// Note that we used to return `Error` here, but that was quite\n /// dubious -- the premise was that an error would *eventually* be\n /// reported, when the obligation was processed. But in general once\n-/// you see a `TyError` you are supposed to be able to assume that an\n+/// you see a `Error` you are supposed to be able to assume that an\n /// error *has been* reported, so that you can take whatever heuristic\n /// paths you want to take. To make things worse, it was possible for\n /// cycles to arise, where you basically had a setup like `<MyType<$0>\n@@ -983,11 +983,11 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     let tcx = selcx.tcx();\n     // Check whether the self-type is itself a projection.\n     let (def_id, substs) = match obligation_trait_ref.self_ty().sty {\n-        ty::TyProjection(ref data) => {\n+        ty::Projection(ref data) => {\n             (data.trait_ref(tcx).def_id, data.substs)\n         }\n-        ty::TyAnon(def_id, substs) => (def_id, substs),\n-        ty::TyInfer(ty::TyVar(_)) => {\n+        ty::Anon(def_id, substs) => (def_id, substs),\n+        ty::Infer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n             candidate_set.mark_ambiguous();\n@@ -1265,7 +1265,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n     debug!(\"confirm_object_candidate(object_ty={:?})\",\n            object_ty);\n     let data = match object_ty.sty {\n-        ty::TyDynamic(ref data, ..) => data,\n+        ty::Dynamic(ref data, ..) => data,\n         _ => {\n             span_bug!(\n                 obligation.cause.span,\n@@ -1506,7 +1506,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n         // This means that the impl is missing a definition for the\n         // associated type. This error will be reported by the type\n         // checker method `check_impl_items_against_trait`, so here we\n-        // just return TyError.\n+        // just return Error.\n         debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n                assoc_ty.item.ident,\n                obligation.predicate);"}, {"sha": "1d51f165aefcb852673c2e5f337ac75fd065b984", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -214,34 +214,34 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) ->\n         // None of these types have a destructor and hence they do not\n         // require anything in particular to outlive the dtor's\n         // execution.\n-        ty::TyInfer(ty::FreshIntTy(_))\n-        | ty::TyInfer(ty::FreshFloatTy(_))\n+        ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n         | ty::TyBool\n         | ty::TyInt(_)\n         | ty::TyUint(_)\n         | ty::TyFloat(_)\n-        | ty::TyNever\n-        | ty::TyFnDef(..)\n-        | ty::TyFnPtr(_)\n+        | ty::Never\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n         | ty::TyChar\n-        | ty::TyGeneratorWitness(..)\n-        | ty::TyRawPtr(_)\n-        | ty::TyRef(..)\n+        | ty::GeneratorWitness(..)\n+        | ty::RawPtr(_)\n+        | ty::Ref(..)\n         | ty::TyStr\n         | ty::TyForeign(..)\n-        | ty::TyError => true,\n+        | ty::Error => true,\n \n         // [T; N] and [T] have same properties as T.\n-        ty::TyArray(ty, _) | ty::TySlice(ty) => trivial_dropck_outlives(tcx, ty),\n+        ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),\n \n         // (T1..Tn) and closures have same properties as T1..Tn --\n         // check if *any* of those are trivial.\n-        ty::TyTuple(ref tys) => tys.iter().cloned().all(|t| trivial_dropck_outlives(tcx, t)),\n-        ty::TyClosure(def_id, ref substs) => substs\n+        ty::Tuple(ref tys) => tys.iter().cloned().all(|t| trivial_dropck_outlives(tcx, t)),\n+        ty::Closure(def_id, ref substs) => substs\n             .upvar_tys(def_id, tcx)\n             .all(|t| trivial_dropck_outlives(tcx, t)),\n \n-        ty::TyAdt(def, _) => {\n+        ty::Adt(def, _) => {\n             if Some(def.did) == tcx.lang_items().manually_drop() {\n                 // `ManuallyDrop` never has a dtor.\n                 true\n@@ -255,11 +255,11 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) ->\n         }\n \n         // The following *might* require a destructor: it would deeper inspection to tell.\n-        ty::TyDynamic(..)\n-        | ty::TyProjection(..)\n+        ty::Dynamic(..)\n+        | ty::Projection(..)\n         | ty::TyParam(_)\n-        | ty::TyAnon(..)\n-        | ty::TyInfer(_)\n-        | ty::TyGenerator(..) => false,\n+        | ty::Anon(..)\n+        | ty::Infer(_)\n+        | ty::Generator(..) => false,\n     }\n }"}, {"sha": "7b81989c6415b99898748f2f5d971e19d8068845", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -99,7 +99,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n-            ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => {\n+            ty::Anon(def_id, substs) if !substs.has_escaping_regions() => {\n                 // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {\n@@ -159,7 +159,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                 }\n             }\n \n-            ty::TyProjection(ref data) if !data.has_escaping_regions() => {\n+            ty::Projection(ref data) if !data.has_escaping_regions() => {\n                 // (*)\n                 // (*) This is kind of hacky -- we need to be able to\n                 // handle normalization within binders because"}, {"sha": "55858cca1d157185de06c0e0bfa21906f93b086e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -1128,7 +1128,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                               -> SelectionResult<'tcx, SelectionCandidate<'tcx>>\n     {\n         if stack.obligation.predicate.references_error() {\n-            // If we encounter a `TyError`, we generally prefer the\n+            // If we encounter a `Error`, we generally prefer the\n             // most \"optimistic\" result in response -- that is, the\n             // one least likely to report downstream errors. But\n             // because this routine is shared by coherence and by\n@@ -1492,8 +1492,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // before we go into the whole skolemization thing, just\n         // quickly check if the self-type is a projection at all.\n         match obligation.predicate.skip_binder().trait_ref.self_ty().sty {\n-            ty::TyProjection(_) | ty::TyAnon(..) => {}\n-            ty::TyInfer(ty::TyVar(_)) => {\n+            ty::Projection(_) | ty::Anon(..) => {}\n+            ty::Infer(ty::TyVar(_)) => {\n                 span_bug!(obligation.cause.span,\n                     \"Self=_ should have been handled by assemble_candidates\");\n             }\n@@ -1526,9 +1526,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                skol_map);\n \n         let (def_id, substs) = match skol_trait_predicate.trait_ref.self_ty().sty {\n-            ty::TyProjection(ref data) =>\n+            ty::Projection(ref data) =>\n                 (data.trait_ref(self.tcx()).def_id, data.substs),\n-            ty::TyAnon(def_id, substs) => (def_id, substs),\n+            ty::Anon(def_id, substs) => (def_id, substs),\n             _ => {\n                 span_bug!(\n                     obligation.cause.span,\n@@ -1661,15 +1661,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // type/region parameters\n         let self_ty = *obligation.self_ty().skip_binder();\n         match self_ty.sty {\n-            ty::TyGenerator(..) => {\n+            ty::Generator(..) => {\n                 debug!(\"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n                        self_ty,\n                        obligation);\n \n                 candidates.vec.push(GeneratorCandidate);\n                 Ok(())\n             }\n-            ty::TyInfer(ty::TyVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_generator_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return Ok(());\n@@ -1698,7 +1698,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         match obligation.self_ty().skip_binder().sty {\n-            ty::TyClosure(closure_def_id, closure_substs) => {\n+            ty::Closure(closure_def_id, closure_substs) => {\n                 debug!(\"assemble_unboxed_candidates: kind={:?} obligation={:?}\",\n                        kind, obligation);\n                 match self.infcx.closure_kind(closure_def_id, closure_substs) {\n@@ -1715,7 +1715,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 };\n                 Ok(())\n             }\n-            ty::TyInfer(ty::TyVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return Ok(());\n@@ -1738,13 +1738,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // ok to skip binder because what we are inspecting doesn't involve bound regions\n         let self_ty = *obligation.self_ty().skip_binder();\n         match self_ty.sty {\n-            ty::TyInfer(ty::TyVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true; // could wind up being a fn() type\n             }\n \n             // provide an impl, but only for suitable `fn` pointers\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+            ty::FnDef(..) | ty::FnPtr(_) => {\n                 if let ty::FnSig {\n                     unsafety: hir::Unsafety::Normal,\n                     abi: Abi::Rust,\n@@ -1804,7 +1804,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         if self.tcx().trait_is_auto(def_id) {\n             match self_ty.sty {\n-                ty::TyDynamic(..) => {\n+                ty::Dynamic(..) => {\n                     // For object types, we don't know what the closed\n                     // over types are. This means we conservatively\n                     // say nothing; a candidate may be added by\n@@ -1817,7 +1817,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     // this trait and type.\n                 }\n                 ty::TyParam(..) |\n-                ty::TyProjection(..) => {\n+                ty::Projection(..) => {\n                     // In these cases, we don't know what the actual\n                     // type is.  Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n@@ -1832,7 +1832,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     // for an example of a test case that exercises\n                     // this path.\n                 }\n-                ty::TyInfer(ty::TyVar(_)) => {\n+                ty::Infer(ty::TyVar(_)) => {\n                     // the auto impl might apply, we don't know\n                     candidates.ambiguous = true;\n                 }\n@@ -1871,7 +1871,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // any LBR.\n             let self_ty = this.tcx().erase_late_bound_regions(&obligation.self_ty());\n             let poly_trait_ref = match self_ty.sty {\n-                ty::TyDynamic(ref data, ..) => {\n+                ty::Dynamic(ref data, ..) => {\n                     if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n                         debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n                                     pushing candidate\");\n@@ -1884,7 +1884,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         None => return,\n                     }\n                 }\n-                ty::TyInfer(ty::TyVar(_)) => {\n+                ty::Infer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n                     candidates.ambiguous = true; // could wind up being an object type\n                     return;\n@@ -1953,7 +1953,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let may_apply = match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::TyDynamic(ref data_a, ..), &ty::TyDynamic(ref data_b, ..)) => {\n+            (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 // Upcasts permit two things:\n                 //\n                 // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n@@ -1975,28 +1975,28 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // T -> Trait.\n-            (_, &ty::TyDynamic(..)) => true,\n+            (_, &ty::Dynamic(..)) => true,\n \n             // Ambiguous handling is below T -> Trait, because inference\n             // variables can still implement Unsize<Trait> and nested\n             // obligations will have the final say (likely deferred).\n-            (&ty::TyInfer(ty::TyVar(_)), _) |\n-            (_, &ty::TyInfer(ty::TyVar(_))) => {\n+            (&ty::Infer(ty::TyVar(_)), _) |\n+            (_, &ty::Infer(ty::TyVar(_))) => {\n                 debug!(\"assemble_candidates_for_unsizing: ambiguous\");\n                 candidates.ambiguous = true;\n                 false\n             }\n \n             // [T; n] -> [T].\n-            (&ty::TyArray(..), &ty::TySlice(_)) => true,\n+            (&ty::Array(..), &ty::Slice(_)) => true,\n \n             // Struct<T> -> Struct<U>.\n-            (&ty::TyAdt(def_id_a, _), &ty::TyAdt(def_id_b, _)) if def_id_a.is_struct() => {\n+            (&ty::Adt(def_id_a, _), &ty::Adt(def_id_b, _)) if def_id_a.is_struct() => {\n                 def_id_a == def_id_b\n             }\n \n             // (.., T) -> (.., U).\n-            (&ty::TyTuple(tys_a), &ty::TyTuple(tys_b)) => {\n+            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n                 tys_a.len() == tys_b.len()\n             }\n \n@@ -2179,37 +2179,37 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation.predicate.skip_binder().self_ty());\n \n         match self_ty.sty {\n-            ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n+            ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) |\n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyRawPtr(..) |\n-            ty::TyChar | ty::TyRef(..) | ty::TyGenerator(..) |\n-            ty::TyGeneratorWitness(..) | ty::TyArray(..) | ty::TyClosure(..) |\n-            ty::TyNever | ty::TyError => {\n+            ty::FnDef(..) | ty::FnPtr(_) | ty::RawPtr(..) |\n+            ty::TyChar | ty::Ref(..) | ty::Generator(..) |\n+            ty::GeneratorWitness(..) | ty::Array(..) | ty::Closure(..) |\n+            ty::Never | ty::Error => {\n                 // safe for everything\n                 Where(ty::Binder::dummy(Vec::new()))\n             }\n \n-            ty::TyStr | ty::TySlice(_) | ty::TyDynamic(..) | ty::TyForeign(..) => None,\n+            ty::TyStr | ty::Slice(_) | ty::Dynamic(..) | ty::TyForeign(..) => None,\n \n-            ty::TyTuple(tys) => {\n+            ty::Tuple(tys) => {\n                 Where(ty::Binder::bind(tys.last().into_iter().cloned().collect()))\n             }\n \n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n                 Where(ty::Binder::bind(\n                     sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect()\n                 ))\n             }\n \n-            ty::TyProjection(_) | ty::TyParam(_) | ty::TyAnon(..) => None,\n-            ty::TyInfer(ty::TyVar(_)) => Ambiguous,\n+            ty::Projection(_) | ty::TyParam(_) | ty::Anon(..) => None,\n+            ty::Infer(ty::TyVar(_)) => Ambiguous,\n \n-            ty::TyInfer(ty::CanonicalTy(_)) |\n-            ty::TyInfer(ty::FreshTy(_)) |\n-            ty::TyInfer(ty::FreshIntTy(_)) |\n-            ty::TyInfer(ty::FreshFloatTy(_)) => {\n+            ty::Infer(ty::CanonicalTy(_)) |\n+            ty::Infer(ty::FreshTy(_)) |\n+            ty::Infer(ty::FreshIntTy(_)) |\n+            ty::Infer(ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n                      self_ty);\n             }\n@@ -2226,35 +2226,35 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         use self::BuiltinImplConditions::{Ambiguous, None, Where};\n \n         match self_ty.sty {\n-            ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyError => {\n+            ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) |\n+            ty::FnDef(..) | ty::FnPtr(_) | ty::Error => {\n                 Where(ty::Binder::dummy(Vec::new()))\n             }\n \n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n-            ty::TyChar | ty::TyRawPtr(..) | ty::TyNever |\n-            ty::TyRef(_, _, hir::MutImmutable) => {\n+            ty::TyChar | ty::RawPtr(..) | ty::Never |\n+            ty::Ref(_, _, hir::MutImmutable) => {\n                 // Implementations provided in libcore\n                 None\n             }\n \n-            ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n-            ty::TyGenerator(..) | ty::TyGeneratorWitness(..) | ty::TyForeign(..) |\n-            ty::TyRef(_, _, hir::MutMutable) => {\n+            ty::Dynamic(..) | ty::TyStr | ty::Slice(..) |\n+            ty::Generator(..) | ty::GeneratorWitness(..) | ty::TyForeign(..) |\n+            ty::Ref(_, _, hir::MutMutable) => {\n                 None\n             }\n \n-            ty::TyArray(element_ty, _) => {\n+            ty::Array(element_ty, _) => {\n                 // (*) binder moved here\n                 Where(ty::Binder::bind(vec![element_ty]))\n             }\n \n-            ty::TyTuple(tys) => {\n+            ty::Tuple(tys) => {\n                 // (*) binder moved here\n                 Where(ty::Binder::bind(tys.to_vec()))\n             }\n \n-            ty::TyClosure(def_id, substs) => {\n+            ty::Closure(def_id, substs) => {\n                 let trait_id = obligation.predicate.def_id();\n                 let is_copy_trait = Some(trait_id) == self.tcx().lang_items().copy_trait();\n                 let is_clone_trait = Some(trait_id) == self.tcx().lang_items().clone_trait();\n@@ -2265,22 +2265,22 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            ty::TyAdt(..) | ty::TyProjection(..) | ty::TyParam(..) | ty::TyAnon(..) => {\n+            ty::Adt(..) | ty::Projection(..) | ty::TyParam(..) | ty::Anon(..) => {\n                 // Fallback to whatever user-defined impls exist in this case.\n                 None\n             }\n \n-            ty::TyInfer(ty::TyVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) => {\n                 // Unbound type variable. Might or might not have\n                 // applicable impls and so forth, depending on what\n                 // those type variables wind up being bound to.\n                 Ambiguous\n             }\n \n-            ty::TyInfer(ty::CanonicalTy(_)) |\n-            ty::TyInfer(ty::FreshTy(_)) |\n-            ty::TyInfer(ty::FreshIntTy(_)) |\n-            ty::TyInfer(ty::FreshFloatTy(_)) => {\n+            ty::Infer(ty::CanonicalTy(_)) |\n+            ty::Infer(ty::FreshTy(_)) |\n+            ty::Infer(ty::FreshIntTy(_)) |\n+            ty::Infer(ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n                      self_ty);\n             }\n@@ -2304,72 +2304,72 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyInt(_) |\n             ty::TyBool |\n             ty::TyFloat(_) |\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) |\n+            ty::FnDef(..) |\n+            ty::FnPtr(_) |\n             ty::TyStr |\n-            ty::TyError |\n-            ty::TyInfer(ty::IntVar(_)) |\n-            ty::TyInfer(ty::FloatVar(_)) |\n-            ty::TyNever |\n+            ty::Error |\n+            ty::Infer(ty::IntVar(_)) |\n+            ty::Infer(ty::FloatVar(_)) |\n+            ty::Never |\n             ty::TyChar => {\n                 Vec::new()\n             }\n \n-            ty::TyDynamic(..) |\n+            ty::Dynamic(..) |\n             ty::TyParam(..) |\n             ty::TyForeign(..) |\n-            ty::TyProjection(..) |\n-            ty::TyInfer(ty::CanonicalTy(_)) |\n-            ty::TyInfer(ty::TyVar(_)) |\n-            ty::TyInfer(ty::FreshTy(_)) |\n-            ty::TyInfer(ty::FreshIntTy(_)) |\n-            ty::TyInfer(ty::FreshFloatTy(_)) => {\n+            ty::Projection(..) |\n+            ty::Infer(ty::CanonicalTy(_)) |\n+            ty::Infer(ty::TyVar(_)) |\n+            ty::Infer(ty::FreshTy(_)) |\n+            ty::Infer(ty::FreshIntTy(_)) |\n+            ty::Infer(ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble constituent types of unexpected type: {:?}\",\n                      t);\n             }\n \n-            ty::TyRawPtr(ty::TypeAndMut { ty: element_ty, ..}) |\n-            ty::TyRef(_, element_ty, _) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: element_ty, ..}) |\n+            ty::Ref(_, element_ty, _) => {\n                 vec![element_ty]\n             },\n \n-            ty::TyArray(element_ty, _) | ty::TySlice(element_ty) => {\n+            ty::Array(element_ty, _) | ty::Slice(element_ty) => {\n                 vec![element_ty]\n             }\n \n-            ty::TyTuple(ref tys) => {\n+            ty::Tuple(ref tys) => {\n                 // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n                 tys.to_vec()\n             }\n \n-            ty::TyClosure(def_id, ref substs) => {\n+            ty::Closure(def_id, ref substs) => {\n                 substs.upvar_tys(def_id, self.tcx()).collect()\n             }\n \n-            ty::TyGenerator(def_id, ref substs, _) => {\n+            ty::Generator(def_id, ref substs, _) => {\n                 let witness = substs.witness(def_id, self.tcx());\n                 substs.upvar_tys(def_id, self.tcx()).chain(iter::once(witness)).collect()\n             }\n \n-            ty::TyGeneratorWitness(types) => {\n+            ty::GeneratorWitness(types) => {\n                 // This is sound because no regions in the witness can refer to\n                 // the binder outside the witness. So we'll effectivly reuse\n                 // the implicit binder around the witness.\n                 types.skip_binder().to_vec()\n             }\n \n             // for `PhantomData<T>`, we pass `T`\n-            ty::TyAdt(def, substs) if def.is_phantom_data() => {\n+            ty::Adt(def, substs) if def.is_phantom_data() => {\n                 substs.types().collect()\n             }\n \n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 def.all_fields()\n                     .map(|f| f.ty(self.tcx(), substs))\n                     .collect()\n             }\n \n-            ty::TyAnon(def_id, substs) => {\n+            ty::Anon(def_id, substs) => {\n                 // We can resolve the `impl Trait` to its concrete type,\n                 // which enforces a DAG between the functions requiring\n                 // the auto trait bounds in question.\n@@ -2728,7 +2728,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // case that results. -nmatsakis\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n-            ty::TyDynamic(ref data, ..) => {\n+            ty::Dynamic(ref data, ..) => {\n                 data.principal().unwrap().with_self_ty(self.tcx(), self_ty)\n             }\n             _ => {\n@@ -2823,7 +2823,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // type/region parameters\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         let (generator_def_id, substs) = match self_ty.sty {\n-            ty::TyGenerator(id, substs, _) => (id, substs),\n+            ty::Generator(id, substs, _) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation)\n         };\n \n@@ -2879,7 +2879,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // type/region parameters\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::TyClosure(id, substs) => (id, substs),\n+            ty::Closure(id, substs) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation)\n         };\n \n@@ -2976,7 +2976,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let mut nested = vec![];\n         match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::TyDynamic(ref data_a, r_a), &ty::TyDynamic(ref data_b, r_b)) => {\n+            (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n                 let existential_predicates = data_a.map_bound(|data_a| {\n                     let principal = data_a.principal();\n@@ -3005,7 +3005,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // T -> Trait.\n-            (_, &ty::TyDynamic(ref data, r)) => {\n+            (_, &ty::Dynamic(ref data, r)) => {\n                 let mut object_dids =\n                     data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n                 if let Some(did) = object_dids.find(|did| {\n@@ -3048,7 +3048,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // [T; n] -> [T].\n-            (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n+            (&ty::Array(a, _), &ty::Slice(b)) => {\n                 let InferOk { obligations, .. } =\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(b, a)\n@@ -3057,7 +3057,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // Struct<T> -> Struct<U>.\n-            (&ty::TyAdt(def, substs_a), &ty::TyAdt(_, substs_b)) => {\n+            (&ty::Adt(def, substs_a), &ty::Adt(_, substs_b)) => {\n                 let fields = def\n                     .all_fields()\n                     .map(|f| tcx.type_of(f.did))\n@@ -3082,7 +3082,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n \n                 // Replace type parameters used in unsizing with\n-                // TyError and ensure they do not affect any other fields.\n+                // Error and ensure they do not affect any other fields.\n                 // This could be checked after type collection for any struct\n                 // with a potentially unsized trailing field.\n                 let params = substs_a.iter().enumerate().map(|(i, &k)| {\n@@ -3130,7 +3130,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // (.., T) -> (.., U).\n-            (&ty::TyTuple(tys_a), &ty::TyTuple(tys_b)) => {\n+            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n                 assert_eq!(tys_a.len(), tys_b.len());\n \n                 // The last field of the tuple has to exist."}, {"sha": "c9b0e97c9b05c61847e79409a6232055c2ba1647", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -67,18 +67,18 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n         if a == b { return Ok(a); }\n \n         match (&a.sty, &b.sty) {\n-            (_, &ty::TyInfer(ty::FreshTy(_))) |\n-            (_, &ty::TyInfer(ty::FreshIntTy(_))) |\n-            (_, &ty::TyInfer(ty::FreshFloatTy(_))) => {\n+            (_, &ty::Infer(ty::FreshTy(_))) |\n+            (_, &ty::Infer(ty::FreshIntTy(_))) |\n+            (_, &ty::Infer(ty::FreshFloatTy(_))) => {\n                 Ok(a)\n             }\n \n-            (&ty::TyInfer(_), _) |\n-            (_, &ty::TyInfer(_)) => {\n+            (&ty::Infer(_), _) |\n+            (_, &ty::Infer(_)) => {\n                 Err(TypeError::Sorts(relate::expected_found(self, &a, &b)))\n             }\n \n-            (&ty::TyError, _) | (_, &ty::TyError) => {\n+            (&ty::Error, _) | (_, &ty::Error) => {\n                 Ok(self.tcx().types.err)\n             }\n "}, {"sha": "56ca13404aa9c73f2760d3aba0cf5cb744ecd2a8", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -63,15 +63,15 @@ impl<'tcx> CastTy<'tcx> {\n             ty::TyBool => Some(CastTy::Int(IntTy::Bool)),\n             ty::TyChar => Some(CastTy::Int(IntTy::Char)),\n             ty::TyInt(_) => Some(CastTy::Int(IntTy::I)),\n-            ty::TyInfer(ty::InferTy::IntVar(_)) => Some(CastTy::Int(IntTy::I)),\n-            ty::TyInfer(ty::InferTy::FloatVar(_)) => Some(CastTy::Float),\n+            ty::Infer(ty::InferTy::IntVar(_)) => Some(CastTy::Int(IntTy::I)),\n+            ty::Infer(ty::InferTy::FloatVar(_)) => Some(CastTy::Float),\n             ty::TyUint(u) => Some(CastTy::Int(IntTy::U(u))),\n             ty::TyFloat(_) => Some(CastTy::Float),\n-            ty::TyAdt(d,_) if d.is_enum() && d.is_payloadfree() =>\n+            ty::Adt(d,_) if d.is_enum() && d.is_payloadfree() =>\n                 Some(CastTy::Int(IntTy::CEnum)),\n-            ty::TyRawPtr(mt) => Some(CastTy::Ptr(mt)),\n-            ty::TyRef(_, ty, mutbl) => Some(CastTy::RPtr(ty::TypeAndMut { ty, mutbl })),\n-            ty::TyFnPtr(..) => Some(CastTy::FnPtr),\n+            ty::RawPtr(mt) => Some(CastTy::Ptr(mt)),\n+            ty::Ref(_, ty, mutbl) => Some(CastTy::RPtr(ty::TypeAndMut { ty, mutbl })),\n+            ty::FnPtr(..) => Some(CastTy::FnPtr),\n             _ => None,\n         }\n     }"}, {"sha": "b0c3f7f7edb18c4a3cc8b096d0d11b8036af4a8b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -819,8 +819,8 @@ impl<'tcx> CommonTypes<'tcx> {\n         CommonTypes {\n             bool: mk(TyBool),\n             char: mk(TyChar),\n-            never: mk(TyNever),\n-            err: mk(TyError),\n+            never: mk(Never),\n+            err: mk(Error),\n             isize: mk(TyInt(ast::IntTy::Isize)),\n             i8: mk(TyInt(ast::IntTy::I8)),\n             i16: mk(TyInt(ast::IntTy::I16)),\n@@ -2036,8 +2036,8 @@ macro_rules! sty_debug_print {\n                 for &Interned(t) in tcx.interners.type_.borrow().iter() {\n                     let variant = match t.sty {\n                         ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n-                            ty::TyFloat(..) | ty::TyStr | ty::TyNever => continue,\n-                        ty::TyError => /* unimportant */ continue,\n+                            ty::TyFloat(..) | ty::TyStr | ty::Never => continue,\n+                        ty::Error => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n                     let region = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n@@ -2076,9 +2076,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n-            TyAdt, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n-            TyGenerator, TyGeneratorWitness, TyDynamic, TyClosure, TyTuple,\n-            TyParam, TyInfer, TyProjection, TyAnon, TyForeign);\n+            Adt, Array, Slice, RawPtr, Ref, FnDef, FnPtr,\n+            Generator, GeneratorWitness, Dynamic, Closure, Tuple,\n+            TyParam, Infer, Projection, Anon, TyForeign);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n@@ -2323,7 +2323,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn coerce_closure_fn_ty(self, sig: PolyFnSig<'tcx>) -> Ty<'tcx> {\n         let converted_sig = sig.map_bound(|s| {\n             let params_iter = match s.inputs()[0].sty {\n-                ty::TyTuple(params) => {\n+                ty::Tuple(params) => {\n                     params.into_iter().cloned()\n                 }\n                 _ => bug!(),\n@@ -2383,7 +2383,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_adt(self, def: &'tcx AdtDef, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n-        self.mk_ty(TyAdt(def, substs))\n+        self.mk_ty(Adt(def, substs))\n     }\n \n     pub fn mk_foreign(self, def_id: DefId) -> Ty<'tcx> {\n@@ -2406,15 +2406,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n         });\n-        self.mk_ty(TyAdt(adt_def, substs))\n+        self.mk_ty(Adt(adt_def, substs))\n     }\n \n     pub fn mk_ptr(self, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyRawPtr(tm))\n+        self.mk_ty(RawPtr(tm))\n     }\n \n     pub fn mk_ref(self, r: Region<'tcx>, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyRef(r, tm.ty, tm.mutbl))\n+        self.mk_ty(Ref(r, tm.ty, tm.mutbl))\n     }\n \n     pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -2438,19 +2438,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n-        self.mk_ty(TyArray(ty, ty::Const::from_usize(self, n)))\n+        self.mk_ty(Array(ty, ty::Const::from_usize(self, n)))\n     }\n \n     pub fn mk_slice(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TySlice(ty))\n+        self.mk_ty(Slice(ty))\n     }\n \n     pub fn intern_tup(self, ts: &[Ty<'tcx>]) -> Ty<'tcx> {\n-        self.mk_ty(TyTuple(self.intern_type_list(ts)))\n+        self.mk_ty(Tuple(self.intern_type_list(ts)))\n     }\n \n     pub fn mk_tup<I: InternAs<[Ty<'tcx>], Ty<'tcx>>>(self, iter: I) -> I::Output {\n-        iter.intern_with(|ts| self.mk_ty(TyTuple(self.intern_type_list(ts))))\n+        iter.intern_with(|ts| self.mk_ty(Tuple(self.intern_type_list(ts))))\n     }\n \n     pub fn mk_nil(self) -> Ty<'tcx> {\n@@ -2471,46 +2471,46 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_fn_def(self, def_id: DefId,\n                      substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyFnDef(def_id, substs))\n+        self.mk_ty(FnDef(def_id, substs))\n     }\n \n     pub fn mk_fn_ptr(self, fty: PolyFnSig<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyFnPtr(fty))\n+        self.mk_ty(FnPtr(fty))\n     }\n \n     pub fn mk_dynamic(\n         self,\n         obj: ty::Binder<&'tcx List<ExistentialPredicate<'tcx>>>,\n         reg: ty::Region<'tcx>\n     ) -> Ty<'tcx> {\n-        self.mk_ty(TyDynamic(obj, reg))\n+        self.mk_ty(Dynamic(obj, reg))\n     }\n \n     pub fn mk_projection(self,\n                          item_def_id: DefId,\n                          substs: &'tcx Substs<'tcx>)\n         -> Ty<'tcx> {\n-            self.mk_ty(TyProjection(ProjectionTy {\n+            self.mk_ty(Projection(ProjectionTy {\n                 item_def_id,\n                 substs,\n             }))\n         }\n \n     pub fn mk_closure(self, closure_id: DefId, closure_substs: ClosureSubsts<'tcx>)\n                                           -> Ty<'tcx> {\n-        self.mk_ty(TyClosure(closure_id, closure_substs))\n+        self.mk_ty(Closure(closure_id, closure_substs))\n     }\n \n     pub fn mk_generator(self,\n                         id: DefId,\n                         generator_substs: GeneratorSubsts<'tcx>,\n                         movability: hir::GeneratorMovability)\n                         -> Ty<'tcx> {\n-        self.mk_ty(TyGenerator(id, generator_substs, movability))\n+        self.mk_ty(Generator(id, generator_substs, movability))\n     }\n \n     pub fn mk_generator_witness(self, types: ty::Binder<&'tcx List<Ty<'tcx>>>) -> Ty<'tcx> {\n-        self.mk_ty(TyGeneratorWitness(types))\n+        self.mk_ty(GeneratorWitness(types))\n     }\n \n     pub fn mk_var(self, v: TyVid) -> Ty<'tcx> {\n@@ -2526,7 +2526,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_infer(self, it: InferTy) -> Ty<'tcx> {\n-        self.mk_ty(TyInfer(it))\n+        self.mk_ty(Infer(it))\n     }\n \n     pub fn mk_ty_param(self,\n@@ -2549,7 +2549,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_anon(self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyAnon(def_id, substs))\n+        self.mk_ty(Anon(def_id, substs))\n     }\n \n     pub fn intern_existential_predicates(self, eps: &[ExistentialPredicate<'tcx>])"}, {"sha": "51d0a6819f6629e6c1527403fbdb9295258c4ebd", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -176,20 +176,20 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n     pub fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> String {\n         match self.sty {\n             ty::TyBool | ty::TyChar | ty::TyInt(_) |\n-            ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr | ty::TyNever => self.to_string(),\n-            ty::TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n+            ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr | ty::Never => self.to_string(),\n+            ty::Tuple(ref tys) if tys.is_empty() => self.to_string(),\n \n-            ty::TyAdt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n+            ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n             ty::TyForeign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)),\n-            ty::TyArray(_, n) => {\n+            ty::Array(_, n) => {\n                 match n.assert_usize(tcx) {\n                     Some(n) => format!(\"array of {} elements\", n),\n                     None => \"array\".to_string(),\n                 }\n             }\n-            ty::TySlice(_) => \"slice\".to_string(),\n-            ty::TyRawPtr(_) => \"*-ptr\".to_string(),\n-            ty::TyRef(region, ty, mutbl) => {\n+            ty::Slice(_) => \"slice\".to_string(),\n+            ty::RawPtr(_) => \"*-ptr\".to_string(),\n+            ty::Ref(region, ty, mutbl) => {\n                 let tymut = ty::TypeAndMut { ty, mutbl };\n                 let tymut_string = tymut.to_string();\n                 if tymut_string == \"_\" ||         //unknown type name,\n@@ -204,33 +204,33 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n                     format!(\"&{}\", tymut_string)\n                 }\n             }\n-            ty::TyFnDef(..) => \"fn item\".to_string(),\n-            ty::TyFnPtr(_) => \"fn pointer\".to_string(),\n-            ty::TyDynamic(ref inner, ..) => {\n+            ty::FnDef(..) => \"fn item\".to_string(),\n+            ty::FnPtr(_) => \"fn pointer\".to_string(),\n+            ty::Dynamic(ref inner, ..) => {\n                 inner.principal().map_or_else(|| \"trait\".to_string(),\n                     |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())))\n             }\n-            ty::TyClosure(..) => \"closure\".to_string(),\n-            ty::TyGenerator(..) => \"generator\".to_string(),\n-            ty::TyGeneratorWitness(..) => \"generator witness\".to_string(),\n-            ty::TyTuple(..) => \"tuple\".to_string(),\n-            ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),\n-            ty::TyInfer(ty::IntVar(_)) => \"integral variable\".to_string(),\n-            ty::TyInfer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),\n-            ty::TyInfer(ty::CanonicalTy(_)) |\n-            ty::TyInfer(ty::FreshTy(_)) => \"skolemized type\".to_string(),\n-            ty::TyInfer(ty::FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n-            ty::TyInfer(ty::FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n-            ty::TyProjection(_) => \"associated type\".to_string(),\n+            ty::Closure(..) => \"closure\".to_string(),\n+            ty::Generator(..) => \"generator\".to_string(),\n+            ty::GeneratorWitness(..) => \"generator witness\".to_string(),\n+            ty::Tuple(..) => \"tuple\".to_string(),\n+            ty::Infer(ty::TyVar(_)) => \"inferred type\".to_string(),\n+            ty::Infer(ty::IntVar(_)) => \"integral variable\".to_string(),\n+            ty::Infer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),\n+            ty::Infer(ty::CanonicalTy(_)) |\n+            ty::Infer(ty::FreshTy(_)) => \"skolemized type\".to_string(),\n+            ty::Infer(ty::FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n+            ty::Infer(ty::FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n+            ty::Projection(_) => \"associated type\".to_string(),\n             ty::TyParam(ref p) => {\n                 if p.is_self() {\n                     \"Self\".to_string()\n                 } else {\n                     \"type parameter\".to_string()\n                 }\n             }\n-            ty::TyAnon(..) => \"anonymized type\".to_string(),\n-            ty::TyError => \"type error\".to_string(),\n+            ty::Anon(..) => \"anonymized type\".to_string(),\n+            ty::Error => \"type error\".to_string(),\n         }\n     }\n }\n@@ -251,7 +251,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     db.help(\"consider boxing your closure and/or using it as a trait object\");\n                 }\n                 match (&values.found.sty, &values.expected.sty) { // Issue #53280\n-                    (ty::TyInfer(ty::IntVar(_)), ty::TyFloat(_)) => {\n+                    (ty::Infer(ty::IntVar(_)), ty::TyFloat(_)) => {\n                         if let Ok(snippet) = self.sess.source_map().span_to_snippet(sp) {\n                             if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n                                 db.span_suggestion_with_applicability("}, {"sha": "cdafdfeddea4768b1d4aadd01ec46525a34136b9", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -73,37 +73,37 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyInt(int_type) => Some(IntSimplifiedType(int_type)),\n         ty::TyUint(uint_type) => Some(UintSimplifiedType(uint_type)),\n         ty::TyFloat(float_type) => Some(FloatSimplifiedType(float_type)),\n-        ty::TyAdt(def, _) => Some(AdtSimplifiedType(def.did)),\n+        ty::Adt(def, _) => Some(AdtSimplifiedType(def.did)),\n         ty::TyStr => Some(StrSimplifiedType),\n-        ty::TyArray(..) | ty::TySlice(_) => Some(ArraySimplifiedType),\n-        ty::TyRawPtr(_) => Some(PtrSimplifiedType),\n-        ty::TyDynamic(ref trait_info, ..) => {\n+        ty::Array(..) | ty::Slice(_) => Some(ArraySimplifiedType),\n+        ty::RawPtr(_) => Some(PtrSimplifiedType),\n+        ty::Dynamic(ref trait_info, ..) => {\n             trait_info.principal().map(|p| TraitSimplifiedType(p.def_id()))\n         }\n-        ty::TyRef(_, ty, _) => {\n+        ty::Ref(_, ty, _) => {\n             // since we introduce auto-refs during method lookup, we\n             // just treat &T and T as equivalent from the point of\n             // view of possibly unifying\n             simplify_type(tcx, ty, can_simplify_params)\n         }\n-        ty::TyFnDef(def_id, _) |\n-        ty::TyClosure(def_id, _) => {\n+        ty::FnDef(def_id, _) |\n+        ty::Closure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }\n-        ty::TyGenerator(def_id, _, _) => {\n+        ty::Generator(def_id, _, _) => {\n             Some(GeneratorSimplifiedType(def_id))\n         }\n-        ty::TyGeneratorWitness(ref tys) => {\n+        ty::GeneratorWitness(ref tys) => {\n             Some(GeneratorWitnessSimplifiedType(tys.skip_binder().len()))\n         }\n-        ty::TyNever => Some(NeverSimplifiedType),\n-        ty::TyTuple(ref tys) => {\n+        ty::Never => Some(NeverSimplifiedType),\n+        ty::Tuple(ref tys) => {\n             Some(TupleSimplifiedType(tys.len()))\n         }\n-        ty::TyFnPtr(ref f) => {\n+        ty::FnPtr(ref f) => {\n             Some(FunctionSimplifiedType(f.skip_binder().inputs().len()))\n         }\n-        ty::TyProjection(_) | ty::TyParam(_) => {\n+        ty::Projection(_) | ty::TyParam(_) => {\n             if can_simplify_params {\n                 // In normalized types, projections don't unify with\n                 // anything. when lazy normalization happens, this\n@@ -115,13 +115,13 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 None\n             }\n         }\n-        ty::TyAnon(def_id, _) => {\n+        ty::Anon(def_id, _) => {\n             Some(AnonSimplifiedType(def_id))\n         }\n         ty::TyForeign(def_id) => {\n             Some(ForeignSimplifiedType(def_id))\n         }\n-        ty::TyInfer(_) | ty::TyError => None,\n+        ty::Infer(_) | ty::Error => None,\n     }\n }\n "}, {"sha": "067d7cc00c5f0695eba50efae5f97edb426042df", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -74,19 +74,19 @@ impl FlagComputation {\n             &ty::TyInt(_) |\n             &ty::TyFloat(_) |\n             &ty::TyUint(_) |\n-            &ty::TyNever |\n+            &ty::Never |\n             &ty::TyStr |\n             &ty::TyForeign(..) => {\n             }\n \n-            // You might think that we could just return TyError for\n-            // any type containing TyError as a component, and get\n+            // You might think that we could just return Error for\n+            // any type containing Error as a component, and get\n             // rid of the TypeFlags::HAS_TY_ERR flag -- likewise for ty_bot (with\n             // the exception of function types that return bot).\n             // But doing so caused sporadic memory corruption, and\n             // neither I (tjc) nor nmatsakis could figure out why,\n             // so we're doing it this way.\n-            &ty::TyError => {\n+            &ty::Error => {\n                 self.add_flags(TypeFlags::HAS_TY_ERR)\n             }\n \n@@ -99,25 +99,25 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty::TyGenerator(_, ref substs, _) => {\n+            &ty::Generator(_, ref substs, _) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n                 self.add_substs(&substs.substs);\n             }\n \n-            &ty::TyGeneratorWitness(ref ts) => {\n+            &ty::GeneratorWitness(ref ts) => {\n                 let mut computation = FlagComputation::new();\n                 computation.add_tys(&ts.skip_binder()[..]);\n                 self.add_bound_computation(&computation);\n             }\n \n-            &ty::TyClosure(_, ref substs) => {\n+            &ty::Closure(_, ref substs) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n                 self.add_substs(&substs.substs);\n             }\n \n-            &ty::TyInfer(infer) => {\n+            &ty::Infer(infer) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES); // it might, right?\n                 self.add_flags(TypeFlags::HAS_TY_INFER);\n                 match infer {\n@@ -136,11 +136,11 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty::TyAdt(_, substs) => {\n+            &ty::Adt(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n-            &ty::TyProjection(ref data) => {\n+            &ty::Projection(ref data) => {\n                 // currently we can't normalize projections that\n                 // include bound regions, so track those separately.\n                 if !data.has_escaping_regions() {\n@@ -150,12 +150,12 @@ impl FlagComputation {\n                 self.add_projection_ty(data);\n             }\n \n-            &ty::TyAnon(_, substs) => {\n+            &ty::Anon(_, substs) => {\n                 self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_substs(substs);\n             }\n \n-            &ty::TyDynamic(ref obj, r) => {\n+            &ty::Dynamic(ref obj, r) => {\n                 let mut computation = FlagComputation::new();\n                 for predicate in obj.skip_binder().iter() {\n                     match *predicate {\n@@ -172,33 +172,33 @@ impl FlagComputation {\n                 self.add_region(r);\n             }\n \n-            &ty::TyArray(tt, len) => {\n+            &ty::Array(tt, len) => {\n                 self.add_ty(tt);\n                 self.add_const(len);\n             }\n \n-            &ty::TySlice(tt) => {\n+            &ty::Slice(tt) => {\n                 self.add_ty(tt)\n             }\n \n-            &ty::TyRawPtr(ref m) => {\n+            &ty::RawPtr(ref m) => {\n                 self.add_ty(m.ty);\n             }\n \n-            &ty::TyRef(r, ty, _) => {\n+            &ty::Ref(r, ty, _) => {\n                 self.add_region(r);\n                 self.add_ty(ty);\n             }\n \n-            &ty::TyTuple(ref ts) => {\n+            &ty::Tuple(ref ts) => {\n                 self.add_tys(&ts[..]);\n             }\n \n-            &ty::TyFnDef(_, substs) => {\n+            &ty::FnDef(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n-            &ty::TyFnPtr(f) => {\n+            &ty::FnPtr(f) => {\n                 self.add_fn_sig(f);\n             }\n         }"}, {"sha": "26010c3d5f55c0b3b87652734c0a3596ba89aeb7", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -771,7 +771,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // in the normalized form\n         if self.just_constrained {\n             match t.sty {\n-                ty::TyProjection(..) | ty::TyAnon(..) => { return false; }\n+                ty::Projection(..) | ty::Anon(..) => { return false; }\n                 _ => { }\n             }\n         }"}, {"sha": "ef5b2236200322bf7c34ee921899058b2e67030f", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -226,7 +226,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match self.sty {\n-            TyAdt(def, substs) => {\n+            Adt(def, substs) => {\n                 {\n                     let substs_set = visited.entry(def.did).or_default();\n                     if !substs_set.insert(substs) {\n@@ -255,21 +255,21 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 ret\n             },\n \n-            TyNever => DefIdForest::full(tcx),\n-            TyTuple(ref tys) => {\n+            Never => DefIdForest::full(tcx),\n+            Tuple(ref tys) => {\n                 DefIdForest::union(tcx, tys.iter().map(|ty| {\n                     ty.uninhabited_from(visited, tcx)\n                 }))\n             },\n-            TyArray(ty, len) => {\n+            Array(ty, len) => {\n                 match len.assert_usize(tcx) {\n                     // If the array is definitely non-empty, it's uninhabited if\n                     // the type of its elements is uninhabited.\n                     Some(n) if n != 0 => ty.uninhabited_from(visited, tcx),\n                     _ => DefIdForest::empty()\n                 }\n             }\n-            TyRef(_, ty, _) => {\n+            Ref(_, ty, _) => {\n                 ty.uninhabited_from(visited, tcx)\n             }\n "}, {"sha": "68996f52b867a27adf6fd88dd9c2c264c8a35baa", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -194,7 +194,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n             );\n \n             let def = match item_type.sty {\n-                ty::TyFnDef(..) if {\n+                ty::FnDef(..) if {\n                     let f = item_type.fn_sig(tcx);\n                     f.abi() == Abi::RustIntrinsic ||\n                         f.abi() == Abi::PlatformIntrinsic"}, {"sha": "ce426c4749bd345836a25f00a16bcb95a04fa219", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -299,7 +299,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n         // anything other than a simple path.\n         match self_ty.sty {\n-            ty::TyAdt(adt_def, substs) => {\n+            ty::Adt(adt_def, substs) => {\n                 if substs.types().next().is_none() { // ignore regions\n                     self.push_item_path(buffer, adt_def.did);\n                 } else {\n@@ -357,39 +357,39 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n /// decisions and we may want to adjust it later.\n pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n     match ty.sty {\n-        ty::TyAdt(adt_def, _) => Some(adt_def.did),\n+        ty::Adt(adt_def, _) => Some(adt_def.did),\n \n-        ty::TyDynamic(data, ..) => data.principal().map(|p| p.def_id()),\n+        ty::Dynamic(data, ..) => data.principal().map(|p| p.def_id()),\n \n-        ty::TyArray(subty, _) |\n-        ty::TySlice(subty) => characteristic_def_id_of_type(subty),\n+        ty::Array(subty, _) |\n+        ty::Slice(subty) => characteristic_def_id_of_type(subty),\n \n-        ty::TyRawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n+        ty::RawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n \n-        ty::TyRef(_, ty, _) => characteristic_def_id_of_type(ty),\n+        ty::Ref(_, ty, _) => characteristic_def_id_of_type(ty),\n \n-        ty::TyTuple(ref tys) => tys.iter()\n+        ty::Tuple(ref tys) => tys.iter()\n                                    .filter_map(|ty| characteristic_def_id_of_type(ty))\n                                    .next(),\n \n-        ty::TyFnDef(def_id, _) |\n-        ty::TyClosure(def_id, _) |\n-        ty::TyGenerator(def_id, _, _) |\n+        ty::FnDef(def_id, _) |\n+        ty::Closure(def_id, _) |\n+        ty::Generator(def_id, _, _) |\n         ty::TyForeign(def_id) => Some(def_id),\n \n         ty::TyBool |\n         ty::TyChar |\n         ty::TyInt(_) |\n         ty::TyUint(_) |\n         ty::TyStr |\n-        ty::TyFnPtr(_) |\n-        ty::TyProjection(_) |\n+        ty::FnPtr(_) |\n+        ty::Projection(_) |\n         ty::TyParam(_) |\n-        ty::TyAnon(..) |\n-        ty::TyInfer(_) |\n-        ty::TyError |\n-        ty::TyGeneratorWitness(..) |\n-        ty::TyNever |\n+        ty::Anon(..) |\n+        ty::Infer(_) |\n+        ty::Error |\n+        ty::GeneratorWitness(..) |\n+        ty::Never |\n         ty::TyFloat(_) => None,\n     }\n }"}, {"sha": "77a737c986098ce912dc2a69e0718af55fb3805d", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -489,14 +489,14 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 scalar(Int(Integer::from_attr(dl, attr::UnsignedInt(ity)), false))\n             }\n             ty::TyFloat(fty) => scalar(Float(fty)),\n-            ty::TyFnPtr(_) => {\n+            ty::FnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n                 ptr.valid_range = 1..=*ptr.valid_range.end();\n                 tcx.intern_layout(LayoutDetails::scalar(self, ptr))\n             }\n \n             // The never type.\n-            ty::TyNever => {\n+            ty::Never => {\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Single { index: 0 },\n                     fields: FieldPlacement::Union(0),\n@@ -507,8 +507,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Potentially-fat pointers.\n-            ty::TyRef(_, pointee, _) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+            ty::Ref(_, pointee, _) |\n+            ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let mut data_ptr = scalar_unit(Pointer);\n                 if !ty.is_unsafe_ptr() {\n                     data_ptr.valid_range = 1..=*data_ptr.valid_range.end();\n@@ -524,10 +524,10 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     ty::TyForeign(..) => {\n                         return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n                     }\n-                    ty::TySlice(_) | ty::TyStr => {\n+                    ty::Slice(_) | ty::TyStr => {\n                         scalar_unit(Int(dl.ptr_sized_integer(), false))\n                     }\n-                    ty::TyDynamic(..) => {\n+                    ty::Dynamic(..) => {\n                         let mut vtable = scalar_unit(Pointer);\n                         vtable.valid_range = 1..=*vtable.valid_range.end();\n                         vtable\n@@ -540,7 +540,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Arrays and slices.\n-            ty::TyArray(element, mut count) => {\n+            ty::Array(element, mut count) => {\n                 if count.has_projections() {\n                     count = tcx.normalize_erasing_regions(param_env, count);\n                     if count.has_projections() {\n@@ -564,7 +564,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     size\n                 })\n             }\n-            ty::TySlice(element) => {\n+            ty::Slice(element) => {\n                 let element = self.layout_of(element)?;\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Single { index: 0 },\n@@ -591,10 +591,10 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Odd unit types.\n-            ty::TyFnDef(..) => {\n+            ty::FnDef(..) => {\n                 univariant(&[], &ReprOptions::default(), StructKind::AlwaysSized)?\n             }\n-            ty::TyDynamic(..) | ty::TyForeign(..) => {\n+            ty::Dynamic(..) | ty::TyForeign(..) => {\n                 let mut unit = univariant_uninterned(&[], &ReprOptions::default(),\n                   StructKind::AlwaysSized)?;\n                 match unit.abi {\n@@ -605,21 +605,21 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Tuples, generators and closures.\n-            ty::TyGenerator(def_id, ref substs, _) => {\n+            ty::Generator(def_id, ref substs, _) => {\n                 let tys = substs.field_tys(def_id, tcx);\n                 univariant(&tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n                     StructKind::AlwaysSized)?\n             }\n \n-            ty::TyClosure(def_id, ref substs) => {\n+            ty::Closure(def_id, ref substs) => {\n                 let tys = substs.upvar_tys(def_id, tcx);\n                 univariant(&tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n                     StructKind::AlwaysSized)?\n             }\n \n-            ty::TyTuple(tys) => {\n+            ty::Tuple(tys) => {\n                 let kind = if tys.len() == 0 {\n                     StructKind::AlwaysSized\n                 } else {\n@@ -631,7 +631,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // SIMD vector types.\n-            ty::TyAdt(def, ..) if def.repr.simd() => {\n+            ty::Adt(def, ..) if def.repr.simd() => {\n                 let element = self.layout_of(ty.simd_type(tcx))?;\n                 let count = ty.simd_size(tcx) as u64;\n                 assert!(count > 0);\n@@ -664,7 +664,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // ADTs.\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 // Cache the field layouts.\n                 let variants = def.variants.iter().map(|v| {\n                     v.fields.iter().map(|field| {\n@@ -1103,17 +1103,17 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Types with no meaningful known layout.\n-            ty::TyProjection(_) | ty::TyAnon(..) => {\n+            ty::Projection(_) | ty::Anon(..) => {\n                 let normalized = tcx.normalize_erasing_regions(param_env, ty);\n                 if ty == normalized {\n                     return Err(LayoutError::Unknown(ty));\n                 }\n                 tcx.layout_raw(param_env.and(normalized))?\n             }\n-            ty::TyGeneratorWitness(..) | ty::TyInfer(_) => {\n+            ty::GeneratorWitness(..) | ty::Infer(_) => {\n                 bug!(\"LayoutDetails::compute: unexpected type `{}`\", ty)\n             }\n-            ty::TyParam(_) | ty::TyError => {\n+            ty::TyParam(_) | ty::Error => {\n                 return Err(LayoutError::Unknown(ty));\n             }\n         })\n@@ -1153,12 +1153,12 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         };\n \n         let adt_def = match layout.ty.sty {\n-            ty::TyAdt(ref adt_def, _) => {\n+            ty::Adt(ref adt_def, _) => {\n                 debug!(\"print-type-size t: `{:?}` process adt\", layout.ty);\n                 adt_def\n             }\n \n-            ty::TyClosure(..) => {\n+            ty::Closure(..) => {\n                 debug!(\"print-type-size t: `{:?}` record closure\", layout.ty);\n                 record(DataTypeKind::Closure, false, None, vec![]);\n                 return;\n@@ -1294,12 +1294,12 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n         };\n \n         match ty.sty {\n-            ty::TyRef(_, pointee, _) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+            ty::Ref(_, pointee, _) |\n+            ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail(pointee);\n                 match tail.sty {\n-                    ty::TyParam(_) | ty::TyProjection(_) => {\n+                    ty::TyParam(_) | ty::Projection(_) => {\n                         debug_assert!(tail.has_param_types() || tail.has_self_ty());\n                         Ok(SizeSkeleton::Pointer {\n                             non_zero,\n@@ -1314,7 +1314,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n                 }\n             }\n \n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 // Only newtypes and enums w/ nullable pointer optimization.\n                 if def.is_union() || def.variants.is_empty() || def.variants.len() > 2 {\n                     return Err(err);\n@@ -1373,7 +1373,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n                 }\n             }\n \n-            ty::TyProjection(_) | ty::TyAnon(..) => {\n+            ty::Projection(_) | ty::Anon(..) => {\n                 let normalized = tcx.normalize_erasing_regions(param_env, ty);\n                 if ty == normalized {\n                     Err(err)\n@@ -1552,7 +1552,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 });\n \n                 let fields = match this.ty.sty {\n-                    ty::TyAdt(def, _) => def.variants[variant_index].fields.len(),\n+                    ty::Adt(def, _) => def.variants[variant_index].fields.len(),\n                     _ => bug!()\n                 };\n                 let tcx = cx.tcx();\n@@ -1587,18 +1587,18 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n             ty::TyInt(_) |\n             ty::TyUint(_) |\n             ty::TyFloat(_) |\n-            ty::TyFnPtr(_) |\n-            ty::TyNever |\n-            ty::TyFnDef(..) |\n-            ty::TyGeneratorWitness(..) |\n+            ty::FnPtr(_) |\n+            ty::Never |\n+            ty::FnDef(..) |\n+            ty::GeneratorWitness(..) |\n             ty::TyForeign(..) |\n-            ty::TyDynamic(..) => {\n+            ty::Dynamic(..) => {\n                 bug!(\"TyLayout::field_type({:?}): not applicable\", this)\n             }\n \n             // Potentially-fat pointers.\n-            ty::TyRef(_, pointee, _) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+            ty::Ref(_, pointee, _) |\n+            ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 assert!(i < this.fields.count());\n \n                 // Reuse the fat *T type as its own thin pointer data field.\n@@ -1619,9 +1619,9 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 }\n \n                 match tcx.struct_tail(pointee).sty {\n-                    ty::TySlice(_) |\n+                    ty::Slice(_) |\n                     ty::TyStr => tcx.types.usize,\n-                    ty::TyDynamic(data, _) => {\n+                    ty::Dynamic(data, _) => {\n                         let trait_def_id = data.principal().unwrap().def_id();\n                         let num_fns: u64 = crate::traits::supertrait_def_ids(tcx, trait_def_id)\n                             .map(|trait_def_id| {\n@@ -1646,28 +1646,28 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n             }\n \n             // Arrays and slices.\n-            ty::TyArray(element, _) |\n-            ty::TySlice(element) => element,\n+            ty::Array(element, _) |\n+            ty::Slice(element) => element,\n             ty::TyStr => tcx.types.u8,\n \n             // Tuples, generators and closures.\n-            ty::TyClosure(def_id, ref substs) => {\n+            ty::Closure(def_id, ref substs) => {\n                 substs.upvar_tys(def_id, tcx).nth(i).unwrap()\n             }\n \n-            ty::TyGenerator(def_id, ref substs, _) => {\n+            ty::Generator(def_id, ref substs, _) => {\n                 substs.field_tys(def_id, tcx).nth(i).unwrap()\n             }\n \n-            ty::TyTuple(tys) => tys[i],\n+            ty::Tuple(tys) => tys[i],\n \n             // SIMD vector types.\n-            ty::TyAdt(def, ..) if def.repr.simd() => {\n+            ty::Adt(def, ..) if def.repr.simd() => {\n                 this.ty.simd_type(tcx)\n             }\n \n             // ADTs.\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 match this.variants {\n                     Variants::Single { index } => {\n                         def.variants[index].fields[i].ty(tcx, substs)\n@@ -1686,8 +1686,8 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 }\n             }\n \n-            ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n-            ty::TyInfer(_) | ty::TyError => {\n+            ty::Projection(_) | ty::Anon(..) | ty::TyParam(_) |\n+            ty::Infer(_) | ty::Error => {\n                 bug!(\"TyLayout::field_type: unexpected type `{}`\", this.ty)\n             }\n         })\n@@ -1749,7 +1749,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         // Locals variables which live across yields are stored\n         // in the generator type as fields. These may be uninitialized\n         // so we don't look for niches there.\n-        if let ty::TyGenerator(..) = layout.ty.sty {\n+        if let ty::Generator(..) = layout.ty.sty {\n             return Ok(None);\n         }\n "}, {"sha": "17ce9ef87cbcf5cc8b74a3baa6cd5005f9911267", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -450,7 +450,7 @@ bitflags! {\n         const HAS_FREE_LOCAL_NAMES    = 1 << 10;\n \n         // Present if the type belongs in a local type context.\n-        // Only set for TyInfer other than Fresh.\n+        // Only set for Infer other than Fresh.\n         const KEEP_IN_LOCAL_TCX  = 1 << 11;\n \n         // Is there a projection that does not involve a bound region?\n@@ -547,24 +547,24 @@ impl<'tcx> TyS<'tcx> {\n                 TyKind::TyInt(_) |\n                 TyKind::TyUint(_) |\n                 TyKind::TyFloat(_) |\n-                TyKind::TyInfer(InferTy::IntVar(_)) |\n-                TyKind::TyInfer(InferTy::FloatVar(_)) |\n-                TyKind::TyInfer(InferTy::FreshIntTy(_)) |\n-                TyKind::TyInfer(InferTy::FreshFloatTy(_)) => true,\n-            TyKind::TyRef(_, x, _) => x.is_primitive_ty(),\n+                TyKind::Infer(InferTy::IntVar(_)) |\n+                TyKind::Infer(InferTy::FloatVar(_)) |\n+                TyKind::Infer(InferTy::FreshIntTy(_)) |\n+                TyKind::Infer(InferTy::FreshFloatTy(_)) => true,\n+            TyKind::Ref(_, x, _) => x.is_primitive_ty(),\n             _ => false,\n         }\n     }\n \n     pub fn is_suggestable(&self) -> bool {\n         match self.sty {\n-            TyKind::TyAnon(..) |\n-            TyKind::TyFnDef(..) |\n-            TyKind::TyFnPtr(..) |\n-            TyKind::TyDynamic(..) |\n-            TyKind::TyClosure(..) |\n-            TyKind::TyInfer(..) |\n-            TyKind::TyProjection(..) => false,\n+            TyKind::Anon(..) |\n+            TyKind::FnDef(..) |\n+            TyKind::FnPtr(..) |\n+            TyKind::Dynamic(..) |\n+            TyKind::Closure(..) |\n+            TyKind::Infer(..) |\n+            TyKind::Projection(..) => false,\n             _ => true,\n         }\n     }\n@@ -2231,29 +2231,29 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                                -> Vec<Ty<'tcx>> {\n         let result = match ty.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n-            TyArray(..) | TyClosure(..) | TyGenerator(..) | TyNever => {\n+            RawPtr(..) | Ref(..) | FnDef(..) | FnPtr(_) |\n+            Array(..) | Closure(..) | Generator(..) | Never => {\n                 vec![]\n             }\n \n             TyStr |\n-            TyDynamic(..) |\n-            TySlice(_) |\n+            Dynamic(..) |\n+            Slice(_) |\n             TyForeign(..) |\n-            TyError |\n-            TyGeneratorWitness(..) => {\n+            Error |\n+            GeneratorWitness(..) => {\n                 // these are never sized - return the target type\n                 vec![ty]\n             }\n \n-            TyTuple(ref tys) => {\n+            Tuple(ref tys) => {\n                 match tys.last() {\n                     None => vec![],\n                     Some(ty) => self.sized_constraint_for_ty(tcx, ty)\n                 }\n             }\n \n-            TyAdt(adt, substs) => {\n+            Adt(adt, substs) => {\n                 // recursive case\n                 let adt_tys = adt.sized_constraint(tcx);\n                 debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n@@ -2264,7 +2264,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     .collect()\n             }\n \n-            TyProjection(..) | TyAnon(..) => {\n+            Projection(..) | Anon(..) => {\n                 // must calculate explicitly.\n                 // FIXME: consider special-casing always-Sized projections\n                 vec![ty]\n@@ -2291,7 +2291,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 }\n             }\n \n-            TyInfer(..) => {\n+            Infer(..) => {\n                 bug!(\"unexpected type `{:?}` in sized_constraint_for_ty\",\n                      ty)\n             }\n@@ -2833,7 +2833,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n ///     - a type parameter or projection whose Sizedness can't be known\n ///     - a tuple of type parameters or projections, if there are multiple\n ///       such.\n-///     - a TyError, if a type contained itself. The representability\n+///     - a Error, if a type contained itself. The representability\n ///       check should catch this case.\n fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   def_id: DefId)"}, {"sha": "6803e15022de567bce85acf662ea7a56f1746505", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -72,14 +72,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // in the `subtys` iterator (e.g., when encountering a\n         // projection).\n         match ty.sty {\n-            ty::TyClosure(def_id, ref substs) => {\n+            ty::Closure(def_id, ref substs) => {\n \n                 for upvar_ty in substs.upvar_tys(def_id, *self) {\n                     self.compute_components(upvar_ty, out);\n                 }\n             }\n \n-            ty::TyGenerator(def_id, ref substs, _) => {\n+            ty::Generator(def_id, ref substs, _) => {\n                 // Same as the closure case\n                 for upvar_ty in substs.upvar_tys(def_id, *self) {\n                     self.compute_components(upvar_ty, out);\n@@ -90,7 +90,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // All regions are bound inside a witness\n-            ty::TyGeneratorWitness(..) => (),\n+            ty::GeneratorWitness(..) => (),\n \n             // OutlivesTypeParameterEnv -- the actual checking that `X:'a`\n             // is implied by the environment is done in regionck.\n@@ -106,7 +106,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // trait-ref. Therefore, if we see any higher-ranke regions,\n             // we simply fallback to the most restrictive rule, which\n             // requires that `Pi: 'a` for all `i`.\n-            ty::TyProjection(ref data) => {\n+            ty::Projection(ref data) => {\n                 if !data.has_escaping_regions() {\n                     // best case: no escaping regions, so push the\n                     // projection and skip the subtree (thus generating no\n@@ -127,7 +127,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // We assume that inference variables are fully resolved.\n             // So, if we encounter an inference variable, just record\n             // the unresolved variable as a component.\n-            ty::TyInfer(infer_ty) => {\n+            ty::Infer(infer_ty) => {\n                 out.push(Component::UnresolvedInferenceVariable(infer_ty));\n             }\n \n@@ -142,20 +142,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::TyInt(..) |         // OutlivesScalar\n             ty::TyUint(..) |        // OutlivesScalar\n             ty::TyFloat(..) |       // OutlivesScalar\n-            ty::TyNever |           // ...\n-            ty::TyAdt(..) |         // OutlivesNominalType\n-            ty::TyAnon(..) |        // OutlivesNominalType (ish)\n+            ty::Never |           // ...\n+            ty::Adt(..) |         // OutlivesNominalType\n+            ty::Anon(..) |        // OutlivesNominalType (ish)\n             ty::TyForeign(..) |     // OutlivesNominalType\n             ty::TyStr |             // OutlivesScalar (ish)\n-            ty::TyArray(..) |       // ...\n-            ty::TySlice(..) |       // ...\n-            ty::TyRawPtr(..) |      // ...\n-            ty::TyRef(..) |         // OutlivesReference\n-            ty::TyTuple(..) |       // ...\n-            ty::TyFnDef(..) |       // OutlivesFunction (*)\n-            ty::TyFnPtr(_) |        // OutlivesFunction (*)\n-            ty::TyDynamic(..) |       // OutlivesObject, OutlivesFragment (*)\n-            ty::TyError => {\n+            ty::Array(..) |       // ...\n+            ty::Slice(..) |       // ...\n+            ty::RawPtr(..) |      // ...\n+            ty::Ref(..) |         // OutlivesReference\n+            ty::Tuple(..) |       // ...\n+            ty::FnDef(..) |       // OutlivesFunction (*)\n+            ty::FnPtr(_) |        // OutlivesFunction (*)\n+            ty::Dynamic(..) |       // OutlivesObject, OutlivesFragment (*)\n+            ty::Error => {\n                 // (*) Bare functions and traits are both binders. In the\n                 // RFC, this means we would add the bound regions to the\n                 // \"bound regions list\".  In our representation, no such"}, {"sha": "baa7485d33a936544b97cd6f175274a7bcafd375", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -363,19 +363,19 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     let b_sty = &b.sty;\n     debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n     match (a_sty, b_sty) {\n-        (&ty::TyInfer(_), _) |\n-        (_, &ty::TyInfer(_)) =>\n+        (&ty::Infer(_), _) |\n+        (_, &ty::Infer(_)) =>\n         {\n             // The caller should handle these cases!\n             bug!(\"var types encountered in super_relate_tys\")\n         }\n \n-        (&ty::TyError, _) | (_, &ty::TyError) =>\n+        (&ty::Error, _) | (_, &ty::Error) =>\n         {\n             Ok(tcx.types.err)\n         }\n \n-        (&ty::TyNever, _) |\n+        (&ty::Never, _) |\n         (&ty::TyChar, _) |\n         (&ty::TyBool, _) |\n         (&ty::TyInt(_), _) |\n@@ -393,7 +393,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(a)\n         }\n \n-        (&ty::TyAdt(a_def, a_substs), &ty::TyAdt(b_def, b_substs))\n+        (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n             if a_def == b_def =>\n         {\n             let substs = relation.relate_item_substs(a_def.did, a_substs, b_substs)?;\n@@ -406,7 +406,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_foreign(a_id))\n         }\n \n-        (&ty::TyDynamic(ref a_obj, ref a_region), &ty::TyDynamic(ref b_obj, ref b_region)) => {\n+        (&ty::Dynamic(ref a_obj, ref a_region), &ty::Dynamic(ref b_obj, ref b_region)) => {\n             let region_bound = relation.with_cause(Cause::ExistentialRegionBound,\n                                                        |relation| {\n                                                            relation.relate_with_variance(\n@@ -417,18 +417,18 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_dynamic(relation.relate(a_obj, b_obj)?, region_bound))\n         }\n \n-        (&ty::TyGenerator(a_id, a_substs, movability),\n-         &ty::TyGenerator(b_id, b_substs, _))\n+        (&ty::Generator(a_id, a_substs, movability),\n+         &ty::Generator(b_id, b_substs, _))\n             if a_id == b_id =>\n         {\n-            // All TyGenerator types with the same id represent\n+            // All Generator types with the same id represent\n             // the (anonymous) type of the same generator expression. So\n             // all of their regions should be equated.\n             let substs = relation.relate(&a_substs, &b_substs)?;\n             Ok(tcx.mk_generator(a_id, substs, movability))\n         }\n \n-        (&ty::TyGeneratorWitness(a_types), &ty::TyGeneratorWitness(b_types)) =>\n+        (&ty::GeneratorWitness(a_types), &ty::GeneratorWitness(b_types)) =>\n         {\n             // Wrap our types with a temporary GeneratorWitness struct\n             // inside the binder so we can related them\n@@ -439,24 +439,24 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_generator_witness(types))\n         }\n \n-        (&ty::TyClosure(a_id, a_substs),\n-         &ty::TyClosure(b_id, b_substs))\n+        (&ty::Closure(a_id, a_substs),\n+         &ty::Closure(b_id, b_substs))\n             if a_id == b_id =>\n         {\n-            // All TyClosure types with the same id represent\n+            // All Closure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n             let substs = relation.relate(&a_substs, &b_substs)?;\n             Ok(tcx.mk_closure(a_id, substs))\n         }\n \n-        (&ty::TyRawPtr(ref a_mt), &ty::TyRawPtr(ref b_mt)) =>\n+        (&ty::RawPtr(ref a_mt), &ty::RawPtr(ref b_mt)) =>\n         {\n             let mt = relation.relate(a_mt, b_mt)?;\n             Ok(tcx.mk_ptr(mt))\n         }\n \n-        (&ty::TyRef(a_r, a_ty, a_mutbl), &ty::TyRef(b_r, b_ty, b_mutbl)) =>\n+        (&ty::Ref(a_r, a_ty, a_mutbl), &ty::Ref(b_r, b_ty, b_mutbl)) =>\n         {\n             let r = relation.relate_with_variance(ty::Contravariant, &a_r, &b_r)?;\n             let a_mt = ty::TypeAndMut { ty: a_ty, mutbl: a_mutbl };\n@@ -465,7 +465,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_ref(r, mt))\n         }\n \n-        (&ty::TyArray(a_t, sz_a), &ty::TyArray(b_t, sz_b)) =>\n+        (&ty::Array(a_t, sz_a), &ty::Array(b_t, sz_b)) =>\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n             assert_eq!(sz_a.ty, tcx.types.usize);\n@@ -514,26 +514,26 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             match (to_u64(sz_a), to_u64(sz_b)) {\n                 (Ok(sz_a_u64), Ok(sz_b_u64)) => {\n                     if sz_a_u64 == sz_b_u64 {\n-                        Ok(tcx.mk_ty(ty::TyArray(t, sz_a)))\n+                        Ok(tcx.mk_ty(ty::Array(t, sz_a)))\n                     } else {\n                         Err(TypeError::FixedArraySize(\n                             expected_found(relation, &sz_a_u64, &sz_b_u64)))\n                     }\n                 }\n-                // We reported an error or will ICE, so we can return TyError.\n+                // We reported an error or will ICE, so we can return Error.\n                 (Err(ErrorReported), _) | (_, Err(ErrorReported)) => {\n                     Ok(tcx.types.err)\n                 }\n             }\n         }\n \n-        (&ty::TySlice(a_t), &ty::TySlice(b_t)) =>\n+        (&ty::Slice(a_t), &ty::Slice(b_t)) =>\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n             Ok(tcx.mk_slice(t))\n         }\n \n-        (&ty::TyTuple(as_), &ty::TyTuple(bs)) =>\n+        (&ty::Tuple(as_), &ty::Tuple(bs)) =>\n         {\n             if as_.len() == bs.len() {\n                 Ok(tcx.mk_tup(as_.iter().zip(bs).map(|(a, b)| relation.relate(a, b)))?)\n@@ -545,26 +545,26 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             }\n         }\n \n-        (&ty::TyFnDef(a_def_id, a_substs), &ty::TyFnDef(b_def_id, b_substs))\n+        (&ty::FnDef(a_def_id, a_substs), &ty::FnDef(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n             let substs = relation.relate_item_substs(a_def_id, a_substs, b_substs)?;\n             Ok(tcx.mk_fn_def(a_def_id, substs))\n         }\n \n-        (&ty::TyFnPtr(a_fty), &ty::TyFnPtr(b_fty)) =>\n+        (&ty::FnPtr(a_fty), &ty::FnPtr(b_fty)) =>\n         {\n             let fty = relation.relate(&a_fty, &b_fty)?;\n             Ok(tcx.mk_fn_ptr(fty))\n         }\n \n-        (&ty::TyProjection(ref a_data), &ty::TyProjection(ref b_data)) =>\n+        (&ty::Projection(ref a_data), &ty::Projection(ref b_data)) =>\n         {\n             let projection_ty = relation.relate(a_data, b_data)?;\n             Ok(tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs))\n         }\n \n-        (&ty::TyAnon(a_def_id, a_substs), &ty::TyAnon(b_def_id, b_substs))\n+        (&ty::Anon(a_def_id, a_substs), &ty::Anon(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n             let substs = relate_substs(relation, None, a_substs, b_substs)?;"}, {"sha": "367e4c5cc7a5c734986df7b34162b641b7f7faec", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -836,33 +836,33 @@ impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let sty = match self.sty {\n-            ty::TyRawPtr(tm) => ty::TyRawPtr(tm.fold_with(folder)),\n-            ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz.fold_with(folder)),\n-            ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n-            ty::TyAdt(tid, substs) => ty::TyAdt(tid, substs.fold_with(folder)),\n-            ty::TyDynamic(ref trait_ty, ref region) =>\n-                ty::TyDynamic(trait_ty.fold_with(folder), region.fold_with(folder)),\n-            ty::TyTuple(ts) => ty::TyTuple(ts.fold_with(folder)),\n-            ty::TyFnDef(def_id, substs) => {\n-                ty::TyFnDef(def_id, substs.fold_with(folder))\n+            ty::RawPtr(tm) => ty::RawPtr(tm.fold_with(folder)),\n+            ty::Array(typ, sz) => ty::Array(typ.fold_with(folder), sz.fold_with(folder)),\n+            ty::Slice(typ) => ty::Slice(typ.fold_with(folder)),\n+            ty::Adt(tid, substs) => ty::Adt(tid, substs.fold_with(folder)),\n+            ty::Dynamic(ref trait_ty, ref region) =>\n+                ty::Dynamic(trait_ty.fold_with(folder), region.fold_with(folder)),\n+            ty::Tuple(ts) => ty::Tuple(ts.fold_with(folder)),\n+            ty::FnDef(def_id, substs) => {\n+                ty::FnDef(def_id, substs.fold_with(folder))\n             }\n-            ty::TyFnPtr(f) => ty::TyFnPtr(f.fold_with(folder)),\n-            ty::TyRef(ref r, ty, mutbl) => {\n-                ty::TyRef(r.fold_with(folder), ty.fold_with(folder), mutbl)\n+            ty::FnPtr(f) => ty::FnPtr(f.fold_with(folder)),\n+            ty::Ref(ref r, ty, mutbl) => {\n+                ty::Ref(r.fold_with(folder), ty.fold_with(folder), mutbl)\n             }\n-            ty::TyGenerator(did, substs, movability) => {\n-                ty::TyGenerator(\n+            ty::Generator(did, substs, movability) => {\n+                ty::Generator(\n                     did,\n                     substs.fold_with(folder),\n                     movability)\n             }\n-            ty::TyGeneratorWitness(types) => ty::TyGeneratorWitness(types.fold_with(folder)),\n-            ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n-            ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n-            ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n+            ty::GeneratorWitness(types) => ty::GeneratorWitness(types.fold_with(folder)),\n+            ty::Closure(did, substs) => ty::Closure(did, substs.fold_with(folder)),\n+            ty::Projection(ref data) => ty::Projection(data.fold_with(folder)),\n+            ty::Anon(did, substs) => ty::Anon(did, substs.fold_with(folder)),\n             ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n-            ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n-            ty::TyParam(..) | ty::TyNever | ty::TyForeign(..) => return self\n+            ty::TyUint(_) | ty::TyFloat(_) | ty::Error | ty::Infer(_) |\n+            ty::TyParam(..) | ty::Never | ty::TyForeign(..) => return self\n         };\n \n         if self.sty == sty {\n@@ -878,26 +878,26 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match self.sty {\n-            ty::TyRawPtr(ref tm) => tm.visit_with(visitor),\n-            ty::TyArray(typ, sz) => typ.visit_with(visitor) || sz.visit_with(visitor),\n-            ty::TySlice(typ) => typ.visit_with(visitor),\n-            ty::TyAdt(_, substs) => substs.visit_with(visitor),\n-            ty::TyDynamic(ref trait_ty, ref reg) =>\n+            ty::RawPtr(ref tm) => tm.visit_with(visitor),\n+            ty::Array(typ, sz) => typ.visit_with(visitor) || sz.visit_with(visitor),\n+            ty::Slice(typ) => typ.visit_with(visitor),\n+            ty::Adt(_, substs) => substs.visit_with(visitor),\n+            ty::Dynamic(ref trait_ty, ref reg) =>\n                 trait_ty.visit_with(visitor) || reg.visit_with(visitor),\n-            ty::TyTuple(ts) => ts.visit_with(visitor),\n-            ty::TyFnDef(_, substs) => substs.visit_with(visitor),\n-            ty::TyFnPtr(ref f) => f.visit_with(visitor),\n-            ty::TyRef(r, ty, _) => r.visit_with(visitor) || ty.visit_with(visitor),\n-            ty::TyGenerator(_did, ref substs, _) => {\n+            ty::Tuple(ts) => ts.visit_with(visitor),\n+            ty::FnDef(_, substs) => substs.visit_with(visitor),\n+            ty::FnPtr(ref f) => f.visit_with(visitor),\n+            ty::Ref(r, ty, _) => r.visit_with(visitor) || ty.visit_with(visitor),\n+            ty::Generator(_did, ref substs, _) => {\n                 substs.visit_with(visitor)\n             }\n-            ty::TyGeneratorWitness(ref types) => types.visit_with(visitor),\n-            ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),\n-            ty::TyProjection(ref data) => data.visit_with(visitor),\n-            ty::TyAnon(_, ref substs) => substs.visit_with(visitor),\n+            ty::GeneratorWitness(ref types) => types.visit_with(visitor),\n+            ty::Closure(_did, ref substs) => substs.visit_with(visitor),\n+            ty::Projection(ref data) => data.visit_with(visitor),\n+            ty::Anon(_, ref substs) => substs.visit_with(visitor),\n             ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n-            ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n-            ty::TyParam(..) | ty::TyNever | ty::TyForeign(..) => false,\n+            ty::TyUint(_) | ty::TyFloat(_) | ty::Error | ty::Infer(_) |\n+            ty::TyParam(..) | ty::Never | ty::TyForeign(..) => false,\n         }\n     }\n "}, {"sha": "8a9302aa2d60d37175d06d5d2459d40f38830bdb", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 92, "deletions": 92, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -103,77 +103,77 @@ pub enum TyKind<'tcx> {\n     ///\n     /// Substs here, possibly against intuition, *may* contain `TyParam`s.\n     /// That is, even after substitution it is possible that there are type\n-    /// variables. This happens when the `TyAdt` corresponds to an ADT\n+    /// variables. This happens when the `Adt` corresponds to an ADT\n     /// definition and not a concrete use of it.\n-    TyAdt(&'tcx AdtDef, &'tcx Substs<'tcx>),\n+    Adt(&'tcx AdtDef, &'tcx Substs<'tcx>),\n \n     TyForeign(DefId),\n \n     /// The pointee of a string slice. Written as `str`.\n     TyStr,\n \n     /// An array with the given length. Written as `[T; n]`.\n-    TyArray(Ty<'tcx>, &'tcx ty::Const<'tcx>),\n+    Array(Ty<'tcx>, &'tcx ty::Const<'tcx>),\n \n     /// The pointee of an array slice.  Written as `[T]`.\n-    TySlice(Ty<'tcx>),\n+    Slice(Ty<'tcx>),\n \n     /// A raw pointer. Written as `*mut T` or `*const T`\n-    TyRawPtr(TypeAndMut<'tcx>),\n+    RawPtr(TypeAndMut<'tcx>),\n \n     /// A reference; a pointer with an associated lifetime. Written as\n     /// `&'a mut T` or `&'a T`.\n-    TyRef(Region<'tcx>, Ty<'tcx>, hir::Mutability),\n+    Ref(Region<'tcx>, Ty<'tcx>, hir::Mutability),\n \n     /// The anonymous type of a function declaration/definition. Each\n     /// function has a unique type.\n-    TyFnDef(DefId, &'tcx Substs<'tcx>),\n+    FnDef(DefId, &'tcx Substs<'tcx>),\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n-    TyFnPtr(PolyFnSig<'tcx>),\n+    FnPtr(PolyFnSig<'tcx>),\n \n     /// A trait, defined with `trait`.\n-    TyDynamic(Binder<&'tcx List<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n+    Dynamic(Binder<&'tcx List<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n-    TyClosure(DefId, ClosureSubsts<'tcx>),\n+    Closure(DefId, ClosureSubsts<'tcx>),\n \n     /// The anonymous type of a generator. Used to represent the type of\n     /// `|a| yield a`.\n-    TyGenerator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n+    Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n \n     /// A type representin the types stored inside a generator.\n     /// This should only appear in GeneratorInteriors.\n-    TyGeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n+    GeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n \n     /// The never type `!`\n-    TyNever,\n+    Never,\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    TyTuple(&'tcx List<Ty<'tcx>>),\n+    Tuple(&'tcx List<Ty<'tcx>>),\n \n     /// The projection of an associated type.  For example,\n     /// `<T as Trait<..>>::N`.\n-    TyProjection(ProjectionTy<'tcx>),\n+    Projection(ProjectionTy<'tcx>),\n \n     /// Anonymized (`impl Trait`) type found in a return type.\n     /// The DefId comes either from\n     /// * the `impl Trait` ast::Ty node,\n     /// * or the `existential type` declaration\n     /// The substitutions are for the generics of the function in question.\n     /// After typeck, the concrete type can be found in the `types` map.\n-    TyAnon(DefId, &'tcx Substs<'tcx>),\n+    Anon(DefId, &'tcx Substs<'tcx>),\n \n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     TyParam(ParamTy),\n \n     /// A type variable used during type-checking.\n-    TyInfer(InferTy),\n+    Infer(InferTy),\n \n     /// A placeholder for a type which could not be computed; this is\n     /// propagated to avoid useless error messages.\n-    TyError,\n+    Error,\n }\n \n /// A closure can be modeled as a struct that looks like:\n@@ -348,7 +348,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// If you have an inference context, use `infcx.closure_sig()`.\n     pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n         match self.closure_sig_ty(def_id, tcx).sty {\n-            ty::TyFnPtr(sig) => sig,\n+            ty::FnPtr(sig) => sig,\n             ref t => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", t),\n         }\n     }\n@@ -1469,14 +1469,14 @@ impl RegionKind {\n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     pub fn is_nil(&self) -> bool {\n         match self.sty {\n-            TyTuple(ref tys) => tys.is_empty(),\n+            Tuple(ref tys) => tys.is_empty(),\n             _ => false,\n         }\n     }\n \n     pub fn is_never(&self) -> bool {\n         match self.sty {\n-            TyNever => true,\n+            Never => true,\n             _ => false,\n         }\n     }\n@@ -1490,20 +1490,20 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_ty_var(&self) -> bool {\n         match self.sty {\n-            TyInfer(TyVar(_)) => true,\n+            Infer(TyVar(_)) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_ty_infer(&self) -> bool {\n         match self.sty {\n-            TyInfer(_) => true,\n+            Infer(_) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_phantom_data(&self) -> bool {\n-        if let TyAdt(def, _) = self.sty {\n+        if let Adt(def, _) = self.sty {\n             def.is_phantom_data()\n         } else {\n             false\n@@ -1528,8 +1528,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_slice(&self) -> bool {\n         match self.sty {\n-            TyRawPtr(TypeAndMut { ty, .. }) | TyRef(_, ty, _) => match ty.sty {\n-                TySlice(_) | TyStr => true,\n+            RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => match ty.sty {\n+                Slice(_) | TyStr => true,\n                 _ => false,\n             },\n             _ => false\n@@ -1539,22 +1539,22 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_simd(&self) -> bool {\n         match self.sty {\n-            TyAdt(def, _) => def.repr.simd(),\n+            Adt(def, _) => def.repr.simd(),\n             _ => false,\n         }\n     }\n \n     pub fn sequence_element_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n-            TyArray(ty, _) | TySlice(ty) => ty,\n+            Array(ty, _) | Slice(ty) => ty,\n             TyStr => tcx.mk_mach_uint(ast::UintTy::U8),\n             _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n         }\n     }\n \n     pub fn simd_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n-            TyAdt(def, substs) => {\n+            Adt(def, substs) => {\n                 def.non_enum_variant().fields[0].ty(tcx, substs)\n             }\n             _ => bug!(\"simd_type called on invalid type\")\n@@ -1563,56 +1563,56 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn simd_size(&self, _cx: TyCtxt) -> usize {\n         match self.sty {\n-            TyAdt(def, _) => def.non_enum_variant().fields.len(),\n+            Adt(def, _) => def.non_enum_variant().fields.len(),\n             _ => bug!(\"simd_size called on invalid type\")\n         }\n     }\n \n     pub fn is_region_ptr(&self) -> bool {\n         match self.sty {\n-            TyRef(..) => true,\n+            Ref(..) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_mutable_pointer(&self) -> bool {\n         match self.sty {\n-            TyRawPtr(TypeAndMut { mutbl: hir::Mutability::MutMutable, .. }) |\n-            TyRef(_, _, hir::Mutability::MutMutable) => true,\n+            RawPtr(TypeAndMut { mutbl: hir::Mutability::MutMutable, .. }) |\n+            Ref(_, _, hir::Mutability::MutMutable) => true,\n             _ => false\n         }\n     }\n \n     pub fn is_unsafe_ptr(&self) -> bool {\n         match self.sty {\n-            TyRawPtr(_) => return true,\n+            RawPtr(_) => return true,\n             _ => return false,\n         }\n     }\n \n     pub fn is_box(&self) -> bool {\n         match self.sty {\n-            TyAdt(def, _) => def.is_box(),\n+            Adt(def, _) => def.is_box(),\n             _ => false,\n         }\n     }\n \n     /// panics if called on any type other than `Box<T>`\n     pub fn boxed_ty(&self) -> Ty<'tcx> {\n         match self.sty {\n-            TyAdt(def, substs) if def.is_box() => substs.type_at(0),\n+            Adt(def, substs) if def.is_box() => substs.type_at(0),\n             _ => bug!(\"`boxed_ty` is called on non-box type {:?}\", self),\n         }\n     }\n \n     /// A scalar type is one that denotes an atomic datum, with no sub-components.\n-    /// (A TyRawPtr is scalar because it represents a non-managed pointer, so its\n+    /// (A RawPtr is scalar because it represents a non-managed pointer, so its\n     /// contents are abstract to rustc.)\n     pub fn is_scalar(&self) -> bool {\n         match self.sty {\n             TyBool | TyChar | TyInt(_) | TyFloat(_) | TyUint(_) |\n-            TyInfer(IntVar(_)) | TyInfer(FloatVar(_)) |\n-            TyFnDef(..) | TyFnPtr(_) | TyRawPtr(_) => true,\n+            Infer(IntVar(_)) | Infer(FloatVar(_)) |\n+            FnDef(..) | FnPtr(_) | RawPtr(_) => true,\n             _ => false\n         }\n     }\n@@ -1621,21 +1621,21 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     pub fn is_floating_point(&self) -> bool {\n         match self.sty {\n             TyFloat(_) |\n-            TyInfer(FloatVar(_)) => true,\n+            Infer(FloatVar(_)) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_trait(&self) -> bool {\n         match self.sty {\n-            TyDynamic(..) => true,\n+            Dynamic(..) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_enum(&self) -> bool {\n         match self.sty {\n-            TyAdt(adt_def, _) => {\n+            Adt(adt_def, _) => {\n                 adt_def.is_enum()\n             }\n             _ => false,\n@@ -1644,37 +1644,37 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_closure(&self) -> bool {\n         match self.sty {\n-            TyClosure(..) => true,\n+            Closure(..) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_generator(&self) -> bool {\n         match self.sty {\n-            TyGenerator(..) => true,\n+            Generator(..) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_integral(&self) -> bool {\n         match self.sty {\n-            TyInfer(IntVar(_)) | TyInt(_) | TyUint(_) => true,\n+            Infer(IntVar(_)) | TyInt(_) | TyUint(_) => true,\n             _ => false\n         }\n     }\n \n     pub fn is_fresh_ty(&self) -> bool {\n         match self.sty {\n-            TyInfer(FreshTy(_)) => true,\n+            Infer(FreshTy(_)) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_fresh(&self) -> bool {\n         match self.sty {\n-            TyInfer(FreshTy(_)) => true,\n-            TyInfer(FreshIntTy(_)) => true,\n-            TyInfer(FreshFloatTy(_)) => true,\n+            Infer(FreshTy(_)) => true,\n+            Infer(FreshIntTy(_)) => true,\n+            Infer(FreshFloatTy(_)) => true,\n             _ => false,\n         }\n     }\n@@ -1688,7 +1688,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_fp(&self) -> bool {\n         match self.sty {\n-            TyInfer(FloatVar(_)) | TyFloat(_) => true,\n+            Infer(FloatVar(_)) | TyFloat(_) => true,\n             _ => false\n         }\n     }\n@@ -1714,7 +1714,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn has_concrete_skeleton(&self) -> bool {\n         match self.sty {\n-            TyParam(_) | TyInfer(_) | TyError => false,\n+            TyParam(_) | Infer(_) | Error => false,\n             _ => true,\n         }\n     }\n@@ -1725,53 +1725,53 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n     pub fn builtin_deref(&self, explicit: bool) -> Option<TypeAndMut<'tcx>> {\n         match self.sty {\n-            TyAdt(def, _) if def.is_box() => {\n+            Adt(def, _) if def.is_box() => {\n                 Some(TypeAndMut {\n                     ty: self.boxed_ty(),\n                     mutbl: hir::MutImmutable,\n                 })\n             },\n-            TyRef(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl }),\n-            TyRawPtr(mt) if explicit => Some(mt),\n+            Ref(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl }),\n+            RawPtr(mt) if explicit => Some(mt),\n             _ => None,\n         }\n     }\n \n     /// Returns the type of `ty[i]`.\n     pub fn builtin_index(&self) -> Option<Ty<'tcx>> {\n         match self.sty {\n-            TyArray(ty, _) | TySlice(ty) => Some(ty),\n+            Array(ty, _) | Slice(ty) => Some(ty),\n             _ => None,\n         }\n     }\n \n     pub fn fn_sig(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PolyFnSig<'tcx> {\n         match self.sty {\n-            TyFnDef(def_id, substs) => {\n+            FnDef(def_id, substs) => {\n                 tcx.fn_sig(def_id).subst(tcx, substs)\n             }\n-            TyFnPtr(f) => f,\n+            FnPtr(f) => f,\n             _ => bug!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }\n \n     pub fn is_fn(&self) -> bool {\n         match self.sty {\n-            TyFnDef(..) | TyFnPtr(_) => true,\n+            FnDef(..) | FnPtr(_) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_impl_trait(&self) -> bool {\n         match self.sty {\n-            TyAnon(..) => true,\n+            Anon(..) => true,\n             _ => false,\n         }\n     }\n \n     pub fn ty_adt_def(&self) -> Option<&'tcx AdtDef> {\n         match self.sty {\n-            TyAdt(adt, _) => Some(adt),\n+            Adt(adt, _) => Some(adt),\n             _ => None,\n         }\n     }\n@@ -1781,44 +1781,44 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// ignores late-bound regions binders.\n     pub fn regions(&self) -> Vec<ty::Region<'tcx>> {\n         match self.sty {\n-            TyRef(region, _, _) => {\n+            Ref(region, _, _) => {\n                 vec![region]\n             }\n-            TyDynamic(ref obj, region) => {\n+            Dynamic(ref obj, region) => {\n                 let mut v = vec![region];\n                 if let Some(p) = obj.principal() {\n                     v.extend(p.skip_binder().substs.regions());\n                 }\n                 v\n             }\n-            TyAdt(_, substs) | TyAnon(_, substs) => {\n+            Adt(_, substs) | Anon(_, substs) => {\n                 substs.regions().collect()\n             }\n-            TyClosure(_, ClosureSubsts { ref substs }) |\n-            TyGenerator(_, GeneratorSubsts { ref substs }, _) => {\n+            Closure(_, ClosureSubsts { ref substs }) |\n+            Generator(_, GeneratorSubsts { ref substs }, _) => {\n                 substs.regions().collect()\n             }\n-            TyProjection(ref data) => {\n+            Projection(ref data) => {\n                 data.substs.regions().collect()\n             }\n-            TyFnDef(..) |\n-            TyFnPtr(_) |\n-            TyGeneratorWitness(..) |\n+            FnDef(..) |\n+            FnPtr(_) |\n+            GeneratorWitness(..) |\n             TyBool |\n             TyChar |\n             TyInt(_) |\n             TyUint(_) |\n             TyFloat(_) |\n             TyStr |\n-            TyArray(..) |\n-            TySlice(_) |\n-            TyRawPtr(_) |\n-            TyNever |\n-            TyTuple(..) |\n+            Array(..) |\n+            Slice(_) |\n+            RawPtr(_) |\n+            Never |\n+            Tuple(..) |\n             TyForeign(..) |\n             TyParam(_) |\n-            TyInfer(_) |\n-            TyError => {\n+            Infer(_) |\n+            Error => {\n                 vec![]\n             }\n         }\n@@ -1845,9 +1845,9 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n             },\n \n-            TyInfer(_) => None,\n+            Infer(_) => None,\n \n-            TyError => Some(ty::ClosureKind::Fn),\n+            Error => Some(ty::ClosureKind::Fn),\n \n             _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n         }\n@@ -1859,31 +1859,31 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// `false` means nothing -- could be sized, might not be.\n     pub fn is_trivially_sized(&self, tcx: TyCtxt<'_, '_, 'tcx>) -> bool {\n         match self.sty {\n-            ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n+            ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) |\n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyRawPtr(..) |\n-            ty::TyChar | ty::TyRef(..) | ty::TyGenerator(..) |\n-            ty::TyGeneratorWitness(..) | ty::TyArray(..) | ty::TyClosure(..) |\n-            ty::TyNever | ty::TyError =>\n+            ty::FnDef(..) | ty::FnPtr(_) | ty::RawPtr(..) |\n+            ty::TyChar | ty::Ref(..) | ty::Generator(..) |\n+            ty::GeneratorWitness(..) | ty::Array(..) | ty::Closure(..) |\n+            ty::Never | ty::Error =>\n                 true,\n \n-            ty::TyStr | ty::TySlice(_) | ty::TyDynamic(..) | ty::TyForeign(..) =>\n+            ty::TyStr | ty::Slice(_) | ty::Dynamic(..) | ty::TyForeign(..) =>\n                 false,\n \n-            ty::TyTuple(tys) =>\n+            ty::Tuple(tys) =>\n                 tys.iter().all(|ty| ty.is_trivially_sized(tcx)),\n \n-            ty::TyAdt(def, _substs) =>\n+            ty::Adt(def, _substs) =>\n                 def.sized_constraint(tcx).is_empty(),\n \n-            ty::TyProjection(_) | ty::TyParam(_) | ty::TyAnon(..) => false,\n+            ty::Projection(_) | ty::TyParam(_) | ty::Anon(..) => false,\n \n-            ty::TyInfer(ty::TyVar(_)) => false,\n+            ty::Infer(ty::TyVar(_)) => false,\n \n-            ty::TyInfer(ty::CanonicalTy(_)) |\n-            ty::TyInfer(ty::FreshTy(_)) |\n-            ty::TyInfer(ty::FreshIntTy(_)) |\n-            ty::TyInfer(ty::FreshFloatTy(_)) =>\n+            ty::Infer(ty::CanonicalTy(_)) |\n+            ty::Infer(ty::FreshTy(_)) |\n+            ty::Infer(ty::FreshIntTy(_)) |\n+            ty::Infer(ty::FreshFloatTy(_)) =>\n                 bug!(\"is_trivially_sized applied to unexpected type: {:?}\", self),\n         }\n     }"}, {"sha": "d1f91b423acf02af797f665d5471c3052a098745", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -194,10 +194,10 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n                 // These types used to have a builtin impl.\n                 // Now libcore provides that impl.\n                 ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n-                ty::TyChar | ty::TyRawPtr(..) | ty::TyNever |\n-                ty::TyRef(_, _, hir::MutImmutable) => return Ok(()),\n+                ty::TyChar | ty::RawPtr(..) | ty::Never |\n+                ty::Ref(_, _, hir::MutImmutable) => return Ok(()),\n \n-                ty::TyAdt(adt, substs) => (adt, substs),\n+                ty::Adt(adt, substs) => (adt, substs),\n \n                 _ => return Err(CopyImplementationError::NotAnAdt),\n             };\n@@ -258,10 +258,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 for field in def.all_fields() {\n                     let field_ty = field.ty(self, substs);\n-                    if let TyError = field_ty.sty {\n+                    if let Error = field_ty.sty {\n                         return true;\n                     }\n                 }\n@@ -277,7 +277,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn struct_tail(self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n         loop {\n             match ty.sty {\n-                ty::TyAdt(def, substs) => {\n+                ty::Adt(def, substs) => {\n                     if !def.is_struct() {\n                         break;\n                     }\n@@ -287,7 +287,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::TyTuple(tys) => {\n+                ty::Tuple(tys) => {\n                     if let Some((&last_ty, _)) = tys.split_last() {\n                         ty = last_ty;\n                     } else {\n@@ -315,7 +315,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let (mut a, mut b) = (source, target);\n         loop {\n             match (&a.sty, &b.sty) {\n-                (&TyAdt(a_def, a_substs), &TyAdt(b_def, b_substs))\n+                (&Adt(a_def, a_substs), &Adt(b_def, b_substs))\n                         if a_def == b_def && a_def.is_struct() => {\n                     if let Some(f) = a_def.non_enum_variant().fields.last() {\n                         a = f.ty(self, a_substs);\n@@ -324,7 +324,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         break;\n                     }\n                 },\n-                (&TyTuple(a_tys), &TyTuple(b_tys))\n+                (&Tuple(a_tys), &Tuple(b_tys))\n                         if a_tys.len() == b_tys.len() => {\n                     if let Some(a_last) = a_tys.last() {\n                         a = a_last;\n@@ -487,12 +487,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // parameters marked as pure.\n \n         let impl_substs = match self.type_of(impl_def_id).sty {\n-            ty::TyAdt(def_, substs) if def_ == def => substs,\n+            ty::Adt(def_, substs) if def_ == def => substs,\n             _ => bug!()\n         };\n \n         let item_substs = match self.type_of(def.did).sty {\n-            ty::TyAdt(def_, substs) if def_ == def => substs,\n+            ty::Adt(def_, substs) if def_ == def => substs,\n             _ => bug!()\n         };\n \n@@ -697,18 +697,18 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             -> Representability\n         {\n             match ty.sty {\n-                TyTuple(ref ts) => {\n+                Tuple(ref ts) => {\n                     // Find non representable\n                     fold_repr(ts.iter().map(|ty| {\n                         is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty)\n                     }))\n                 }\n                 // Fixed-length vectors.\n                 // FIXME(#11924) Behavior undecided for zero-length vectors.\n-                TyArray(ty, _) => {\n+                Array(ty, _) => {\n                     is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty)\n                 }\n-                TyAdt(def, substs) => {\n+                Adt(def, substs) => {\n                     // Find non representable fields with their spans\n                     fold_repr(def.all_fields().map(|field| {\n                         let ty = field.ty(tcx, substs);\n@@ -723,7 +723,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         }\n                     }))\n                 }\n-                TyClosure(..) => {\n+                Closure(..) => {\n                     // this check is run on type definitions, so we don't expect\n                     // to see closure types\n                     bug!(\"requires check invoked on inapplicable type: {:?}\", ty)\n@@ -734,7 +734,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: &'tcx ty::AdtDef) -> bool {\n             match ty.sty {\n-                TyAdt(ty_def, _) => {\n+                Adt(ty_def, _) => {\n                      ty_def == def\n                 }\n                 _ => false\n@@ -743,7 +743,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         fn same_type<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n             match (&a.sty, &b.sty) {\n-                (&TyAdt(did_a, substs_a), &TyAdt(did_b, substs_b)) => {\n+                (&Adt(did_a, substs_a), &Adt(did_b, substs_b)) => {\n                     if did_a != did_b {\n                         return false;\n                     }\n@@ -785,7 +785,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             ty: Ty<'tcx>) -> Representability\n         {\n             match ty.sty {\n-                TyAdt(def, _) => {\n+                Adt(def, _) => {\n                     {\n                         // Iterate through stack of previously seen types.\n                         let mut iter = seen.iter();\n@@ -924,16 +924,16 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     match ty.sty {\n         // Fast-path for primitive types\n-        ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n-        ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar | ty::TyGeneratorWitness(..) |\n-        ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyStr => false,\n+        ty::Infer(ty::FreshIntTy(_)) | ty::Infer(ty::FreshFloatTy(_)) |\n+        ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::Never |\n+        ty::FnDef(..) | ty::FnPtr(_) | ty::TyChar | ty::GeneratorWitness(..) |\n+        ty::RawPtr(_) | ty::Ref(..) | ty::TyStr => false,\n \n         // Foreign types can never have destructors\n         ty::TyForeign(..) => false,\n \n         // `ManuallyDrop` doesn't have a destructor regardless of field types.\n-        ty::TyAdt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n+        ty::Adt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n \n         // Issue #22536: We first query type_moves_by_default.  It sees a\n         // normalized version of the type, and therefore will definitely\n@@ -951,30 +951,30 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // (see above), it is sound to treat it as having a destructor.\n \n         // User destructors are the only way to have concrete drop types.\n-        ty::TyAdt(def, _) if def.has_dtor(tcx) => true,\n+        ty::Adt(def, _) if def.has_dtor(tcx) => true,\n \n         // Can refer to a type which may drop.\n         // FIXME(eddyb) check this against a ParamEnv.\n-        ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyParam(_) |\n-        ty::TyAnon(..) | ty::TyInfer(_) | ty::TyError => true,\n+        ty::Dynamic(..) | ty::Projection(..) | ty::TyParam(_) |\n+        ty::Anon(..) | ty::Infer(_) | ty::Error => true,\n \n         // Structural recursion.\n-        ty::TyArray(ty, _) | ty::TySlice(ty) => needs_drop(ty),\n+        ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),\n \n-        ty::TyClosure(def_id, ref substs) => substs.upvar_tys(def_id, tcx).any(needs_drop),\n+        ty::Closure(def_id, ref substs) => substs.upvar_tys(def_id, tcx).any(needs_drop),\n \n         // Pessimistically assume that all generators will require destructors\n         // as we don't know if a destructor is a noop or not until after the MIR\n         // state transformation pass\n-        ty::TyGenerator(..) => true,\n+        ty::Generator(..) => true,\n \n-        ty::TyTuple(ref tys) => tys.iter().cloned().any(needs_drop),\n+        ty::Tuple(ref tys) => tys.iter().cloned().any(needs_drop),\n \n         // unions don't have destructors because of the child types,\n         // only if they manually implement `Drop` (handled above).\n-        ty::TyAdt(def, _) if def.is_union() => false,\n+        ty::Adt(def, _) if def.is_union() => false,\n \n-        ty::TyAdt(def, substs) =>\n+        ty::Adt(def, substs) =>\n             def.variants.iter().any(\n                 |variant| variant.fields.iter().any(\n                     |field| needs_drop(field.ty(tcx, substs)))),\n@@ -1025,13 +1025,13 @@ impl<'tcx> ExplicitSelf<'tcx> {\n \n         match self_arg_ty.sty {\n             _ if is_self_ty(self_arg_ty) => ByValue,\n-            ty::TyRef(region, ty, mutbl) if is_self_ty(ty) => {\n+            ty::Ref(region, ty, mutbl) if is_self_ty(ty) => {\n                 ByReference(region, mutbl)\n             }\n-            ty::TyRawPtr(ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => {\n+            ty::RawPtr(ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => {\n                 ByRawPointer(mutbl)\n             }\n-            ty::TyAdt(def, _) if def.is_box() && is_self_ty(self_arg_ty.boxed_ty()) => {\n+            ty::Adt(def, _) if def.is_box() && is_self_ty(self_arg_ty.boxed_ty()) => {\n                 ByBox\n             }\n             _ => Other"}, {"sha": "eafe4a81f759385371a0049e7b967e0bb9f3bcd6", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -82,26 +82,26 @@ pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> AccIntoIter<TypeWalkerArray<'tcx>> {\n fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n     match parent_ty.sty {\n         ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n-        ty::TyStr | ty::TyInfer(_) | ty::TyParam(_) | ty::TyNever | ty::TyError |\n+        ty::TyStr | ty::Infer(_) | ty::TyParam(_) | ty::Never | ty::Error |\n         ty::TyForeign(..) => {\n         }\n-        ty::TyArray(ty, len) => {\n+        ty::Array(ty, len) => {\n             push_const(stack, len);\n             stack.push(ty);\n         }\n-        ty::TySlice(ty) => {\n+        ty::Slice(ty) => {\n             stack.push(ty);\n         }\n-        ty::TyRawPtr(ref mt) => {\n+        ty::RawPtr(ref mt) => {\n             stack.push(mt.ty);\n         }\n-        ty::TyRef(_, ty, _) => {\n+        ty::Ref(_, ty, _) => {\n             stack.push(ty);\n         }\n-        ty::TyProjection(ref data) => {\n+        ty::Projection(ref data) => {\n             stack.extend(data.substs.types().rev());\n         }\n-        ty::TyDynamic(ref obj, ..) => {\n+        ty::Dynamic(ref obj, ..) => {\n             stack.extend(obj.iter().rev().flat_map(|predicate| {\n                 let (substs, opt_ty) = match *predicate.skip_binder() {\n                     ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n@@ -115,25 +115,25 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n                 substs.types().rev().chain(opt_ty)\n             }));\n         }\n-        ty::TyAdt(_, substs) | ty::TyAnon(_, substs) => {\n+        ty::Adt(_, substs) | ty::Anon(_, substs) => {\n             stack.extend(substs.types().rev());\n         }\n-        ty::TyClosure(_, ref substs) => {\n+        ty::Closure(_, ref substs) => {\n             stack.extend(substs.substs.types().rev());\n         }\n-        ty::TyGenerator(_, ref substs, _) => {\n+        ty::Generator(_, ref substs, _) => {\n             stack.extend(substs.substs.types().rev());\n         }\n-        ty::TyGeneratorWitness(ts) => {\n+        ty::GeneratorWitness(ts) => {\n             stack.extend(ts.skip_binder().iter().cloned().rev());\n         }\n-        ty::TyTuple(ts) => {\n+        ty::Tuple(ts) => {\n             stack.extend(ts.iter().cloned().rev());\n         }\n-        ty::TyFnDef(_, substs) => {\n+        ty::FnDef(_, substs) => {\n             stack.extend(substs.types().rev());\n         }\n-        ty::TyFnPtr(sig) => {\n+        ty::FnPtr(sig) => {\n             stack.push(sig.skip_binder().output());\n             stack.extend(sig.skip_binder().inputs().iter().cloned().rev());\n         }"}, {"sha": "0ebde35b134f1b3294507205649915464d4308ea", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -253,49 +253,49 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                 ty::TyInt(..) |\n                 ty::TyUint(..) |\n                 ty::TyFloat(..) |\n-                ty::TyError |\n+                ty::Error |\n                 ty::TyStr |\n-                ty::TyGeneratorWitness(..) |\n-                ty::TyNever |\n+                ty::GeneratorWitness(..) |\n+                ty::Never |\n                 ty::TyParam(_) |\n                 ty::TyForeign(..) => {\n                     // WfScalar, WfParameter, etc\n                 }\n \n-                ty::TySlice(subty) => {\n+                ty::Slice(subty) => {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n                 }\n \n-                ty::TyArray(subty, len) => {\n+                ty::Array(subty, len) => {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n                     assert_eq!(len.ty, self.infcx.tcx.types.usize);\n                     self.compute_const(len);\n                 }\n \n-                ty::TyTuple(ref tys) => {\n+                ty::Tuple(ref tys) => {\n                     if let Some((_last, rest)) = tys.split_last() {\n                         for elem in rest {\n                             self.require_sized(elem, traits::TupleElem);\n                         }\n                     }\n                 }\n \n-                ty::TyRawPtr(_) => {\n+                ty::RawPtr(_) => {\n                     // simple cases that are WF if their type args are WF\n                 }\n \n-                ty::TyProjection(data) => {\n+                ty::Projection(data) => {\n                     subtys.skip_current_subtree(); // subtree handled by compute_projection\n                     self.compute_projection(data);\n                 }\n \n-                ty::TyAdt(def, substs) => {\n+                ty::Adt(def, substs) => {\n                     // WfNominalType\n                     let obligations = self.nominal_obligations(def.did, substs);\n                     self.out.extend(obligations);\n                 }\n \n-                ty::TyRef(r, rty, _) => {\n+                ty::Ref(r, rty, _) => {\n                     // WfReference\n                     if !r.has_escaping_regions() && !rty.has_escaping_regions() {\n                         let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n@@ -309,7 +309,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::TyGenerator(..) => {\n+                ty::Generator(..) => {\n                     // Walk ALL the types in the generator: this will\n                     // include the upvar types as well as the yield\n                     // type. Note that this is mildly distinct from\n@@ -319,7 +319,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // generators don't take arguments.\n                 }\n \n-                ty::TyClosure(def_id, substs) => {\n+                ty::Closure(def_id, substs) => {\n                     // Only check the upvar types for WF, not the rest\n                     // of the types within. This is needed because we\n                     // capture the signature and it may not be WF\n@@ -355,12 +355,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                ty::FnDef(..) | ty::FnPtr(_) => {\n                     // let the loop iterate into the argument/return\n                     // types appearing in the fn signature\n                 }\n \n-                ty::TyAnon(did, substs) => {\n+                ty::Anon(did, substs) => {\n                     // all of the requirements on type parameters\n                     // should've been checked by the instantiation\n                     // of whatever returned this exact `impl Trait`.\n@@ -372,7 +372,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::TyDynamic(data, r) => {\n+                ty::Dynamic(data, r) => {\n                     // WfObject\n                     //\n                     // Here, we defer WF checking due to higher-ranked\n@@ -408,9 +408,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                 //    register a pending obligation and keep\n                 //    moving. (Goal is that an \"inductive hypothesis\"\n                 //    is satisfied to ensure termination.)\n-                ty::TyInfer(_) => {\n+                ty::Infer(_) => {\n                     let ty = self.infcx.shallow_resolve(ty);\n-                    if let ty::TyInfer(_) = ty.sty { // not yet resolved...\n+                    if let ty::Infer(_) = ty.sty { // not yet resolved...\n                         if ty == ty0 { // ...this is the type we started from! no progress.\n                             return false;\n                         }\n@@ -423,7 +423,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     } else {\n                         // Yes, resolved, proceed with the\n                         // result. Should never return false because\n-                        // `ty` is not a TyInfer.\n+                        // `ty` is not a Infer.\n                         assert!(self.compute(ty));\n                     }\n                 }"}, {"sha": "c096e1430a343c0f9d383fcac2d1cb92ffd21b56", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -14,11 +14,11 @@ use mir::interpret::ConstValue;\n use middle::region::{self, BlockRemainder};\n use ty::subst::{self, Subst};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n-use ty::{TyBool, TyChar, TyAdt};\n-use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n-use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n-use ty::{TyClosure, TyGenerator, TyGeneratorWitness, TyForeign, TyProjection, TyAnon};\n-use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n+use ty::{TyBool, TyChar, Adt};\n+use ty::{Error, TyStr, Array, Slice, TyFloat, FnDef, FnPtr};\n+use ty::{TyParam, RawPtr, Ref, Never, Tuple};\n+use ty::{Closure, Generator, GeneratorWitness, TyForeign, Projection, Anon};\n+use ty::{Dynamic, TyInt, TyUint, Infer};\n use ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind};\n use util::nodemap::FxHashSet;\n \n@@ -371,7 +371,7 @@ impl PrintContext {\n \n         if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n             let projection_ty = projections[0].ty;\n-            if let TyTuple(ref args) = substs.type_at(1).sty {\n+            if let Tuple(ref args) = substs.type_at(1).sty {\n                 return self.fn_sig(f, args, false, projection_ty);\n             }\n         }\n@@ -1037,14 +1037,14 @@ define_print! {\n                 TyInt(t) => write!(f, \"{}\", t.ty_to_string()),\n                 TyUint(t) => write!(f, \"{}\", t.ty_to_string()),\n                 TyFloat(t) => write!(f, \"{}\", t.ty_to_string()),\n-                TyRawPtr(ref tm) => {\n+                RawPtr(ref tm) => {\n                     write!(f, \"*{} \", match tm.mutbl {\n                         hir::MutMutable => \"mut\",\n                         hir::MutImmutable => \"const\",\n                     })?;\n                     tm.ty.print(f, cx)\n                 }\n-                TyRef(r, ty, mutbl) => {\n+                Ref(r, ty, mutbl) => {\n                     write!(f, \"&\")?;\n                     let s = r.print_to_string(cx);\n                     if s != \"'_\" {\n@@ -1055,8 +1055,8 @@ define_print! {\n                     }\n                     ty::TypeAndMut { ty, mutbl }.print(f, cx)\n                 }\n-                TyNever => write!(f, \"!\"),\n-                TyTuple(ref tys) => {\n+                Never => write!(f, \"!\"),\n+                Tuple(ref tys) => {\n                     write!(f, \"(\")?;\n                     let mut tys = tys.iter();\n                     if let Some(&ty) = tys.next() {\n@@ -1070,7 +1070,7 @@ define_print! {\n                     }\n                     write!(f, \")\")\n                 }\n-                TyFnDef(def_id, substs) => {\n+                FnDef(def_id, substs) => {\n                     ty::tls::with(|tcx| {\n                         let mut sig = tcx.fn_sig(def_id);\n                         if let Some(substs) = tcx.lift(&substs) {\n@@ -1081,14 +1081,14 @@ define_print! {\n                     cx.parameterized(f, substs, def_id, &[])?;\n                     write!(f, \"}}\")\n                 }\n-                TyFnPtr(ref bare_fn) => {\n+                FnPtr(ref bare_fn) => {\n                     bare_fn.print(f, cx)\n                 }\n-                TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n-                TyError => write!(f, \"[type error]\"),\n+                Infer(infer_ty) => write!(f, \"{}\", infer_ty),\n+                Error => write!(f, \"[type error]\"),\n                 TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-                TyAdt(def, substs) => cx.parameterized(f, substs, def.did, &[]),\n-                TyDynamic(data, r) => {\n+                Adt(def, substs) => cx.parameterized(f, substs, def.did, &[]),\n+                Dynamic(data, r) => {\n                     let r = r.print_to_string(cx);\n                     if !r.is_empty() {\n                         write!(f, \"(\")?;\n@@ -1102,10 +1102,10 @@ define_print! {\n                     }\n                 }\n                 TyForeign(def_id) => parameterized(f, subst::Substs::empty(), def_id, &[]),\n-                TyProjection(ref data) => data.print(f, cx),\n-                TyAnon(def_id, substs) => {\n+                Projection(ref data) => data.print(f, cx),\n+                Anon(def_id, substs) => {\n                     if cx.is_verbose {\n-                        return write!(f, \"TyAnon({:?}, {:?})\", def_id, substs);\n+                        return write!(f, \"Anon({:?}, {:?})\", def_id, substs);\n                     }\n \n                     ty::tls::with(|tcx| {\n@@ -1155,7 +1155,7 @@ define_print! {\n                     })\n                 }\n                 TyStr => write!(f, \"str\"),\n-                TyGenerator(did, substs, movability) => ty::tls::with(|tcx| {\n+                Generator(did, substs, movability) => ty::tls::with(|tcx| {\n                     let upvar_tys = substs.upvar_tys(did, tcx);\n                     let witness = substs.witness(did, tcx);\n                     if movability == hir::GeneratorMovability::Movable {\n@@ -1193,10 +1193,10 @@ define_print! {\n \n                     print!(f, cx, write(\" \"), print(witness), write(\"]\"))\n                 }),\n-                TyGeneratorWitness(types) => {\n+                GeneratorWitness(types) => {\n                     ty::tls::with(|tcx| cx.in_binder(f, tcx, &types, tcx.lift(&types)))\n                 }\n-                TyClosure(did, substs) => ty::tls::with(|tcx| {\n+                Closure(did, substs) => ty::tls::with(|tcx| {\n                     let upvar_tys = substs.upvar_tys(did, tcx);\n                     write!(f, \"[closure\")?;\n \n@@ -1233,7 +1233,7 @@ define_print! {\n \n                     write!(f, \"]\")\n                 }),\n-                TyArray(ty, sz) => {\n+                Array(ty, sz) => {\n                     print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n                     match sz.val {\n                         ConstValue::Unevaluated(_def_id, _substs) => {\n@@ -1245,7 +1245,7 @@ define_print! {\n                     }\n                     write!(f, \"]\")\n                 }\n-                TySlice(ty) => {\n+                Slice(ty) => {\n                     print!(f, cx, write(\"[\"), print(ty), write(\"]\"))\n                 }\n             }"}, {"sha": "847d37be89933c79607f15b837833af74ac358af", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -843,7 +843,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n             LpExtend(ref lp_base, _, LpInterior(_, InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n-                    ty::TyAdt(def, _) if def.has_dtor(self.tcx()) => {\n+                    ty::Adt(def, _) if def.has_dtor(self.tcx()) => {\n                         // In the case where the owner implements drop, then\n                         // the path must be initialized to prevent a case of\n                         // partial reinitialization"}, {"sha": "5c165fbad6943be5f3a815467348c2b7405e8480", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -191,14 +191,14 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         Categorization::Interior(ref b, mc::InteriorField(_)) |\n         Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern)) => {\n             match b.ty.sty {\n-                ty::TyAdt(def, _) => {\n+                ty::Adt(def, _) => {\n                     if def.has_dtor(bccx.tcx) {\n                         Some(cmt.clone())\n                     } else {\n                         check_and_get_illegal_move_origin(bccx, b)\n                     }\n                 }\n-                ty::TySlice(..) => Some(cmt.clone()),\n+                ty::Slice(..) => Some(cmt.clone()),\n                 _ => {\n                     check_and_get_illegal_move_origin(bccx, b)\n                 }"}, {"sha": "31778668e6da0c34e4f74d0b3a471e5e37bde8f5", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -154,7 +154,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &'a BorrowckCtxt<'a, 'tcx>,\n         Categorization::Downcast(ref b, _) |\n         Categorization::Interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n-                ty::TyAdt(def, _) if def.has_dtor(bccx.tcx) => {\n+                ty::Adt(def, _) if def.has_dtor(bccx.tcx) => {\n                     bccx.cannot_move_out_of_interior_of_drop(\n                         move_from.span, b.ty, Origin::Ast)\n                 }"}, {"sha": "d9784cc2177fde18003c252b9760e512d341b224", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 let result = self.restrict(&cmt_base);\n                 // Borrowing one union field automatically borrows all its fields.\n                 match base_ty.sty {\n-                    ty::TyAdt(adt_def, _) if adt_def.is_union() => match result {\n+                    ty::Adt(adt_def, _) if adt_def.is_union() => match result {\n                         RestrictionResult::Safe => RestrictionResult::Safe,\n                         RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n                             for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {"}, {"sha": "91507c77ab3965aaf8209bc693cbde4ce2e53b39", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -697,7 +697,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                              Some(nl.to_string()),\n                                                              Origin::Ast);\n                 let need_note = match lp.ty.sty {\n-                    ty::TyKind::TyClosure(id, _) => {\n+                    ty::TyKind::Closure(id, _) => {\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n                         let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n                         if let Some((span, name)) = self.tables.closure_kind_origins().get(hir_id) {"}, {"sha": "d9f223daf609179059a4ece46abc09e885162564", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         // all parent union fields, moves do not propagate upwards automatically.\n         let mut lp = orig_lp.clone();\n         while let LpExtend(ref base_lp, mutbl, lp_elem) = lp.clone().kind {\n-            if let (&ty::TyAdt(adt_def, _), LpInterior(opt_variant_id, interior))\n+            if let (&ty::Adt(adt_def, _), LpInterior(opt_variant_id, interior))\n                     = (&base_lp.ty.sty, lp_elem) {\n                 if adt_def.is_union() {\n                     for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n@@ -381,7 +381,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                           span: Span) {\n         // Assigning to one union field automatically assigns to all its fields.\n         if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n-            if let ty::TyAdt(adt_def, _) = base_lp.ty.sty {\n+            if let ty::Adt(adt_def, _) = base_lp.ty.sty {\n                 if adt_def.is_union() {\n                     for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n                         let field ="}, {"sha": "684f2b358858f935387d082d6b0b26607a796cb1", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -364,7 +364,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             assert!(!sig.variadic && extra_args.is_empty());\n \n             match sig.inputs().last().unwrap().sty {\n-                ty::TyTuple(ref tupled_arguments) => {\n+                ty::Tuple(ref tupled_arguments) => {\n                     inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n                     tupled_arguments\n                 }"}, {"sha": "33dc94b27bde7f97fec995924953788f0a5c07a0", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -197,16 +197,16 @@ pub fn unsized_info(\n ) -> &'ll Value {\n     let (source, target) = cx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n-        (&ty::TyArray(_, len), &ty::TySlice(_)) => {\n+        (&ty::Array(_, len), &ty::Slice(_)) => {\n             C_usize(cx, len.unwrap_usize(cx.tcx))\n         }\n-        (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n+        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n             // change to the vtable.\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n-        (_, &ty::TyDynamic(ref data, ..)) => {\n+        (_, &ty::Dynamic(ref data, ..)) => {\n             let vtable_ptr = cx.layout_of(cx.tcx.mk_mut_ptr(target))\n                 .field(cx, abi::FAT_PTR_EXTRA);\n             consts::ptrcast(meth::get_vtable(cx, source, data.principal()),\n@@ -227,23 +227,23 @@ pub fn unsize_thin_ptr(\n ) -> (&'ll Value, &'ll Value) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::TyRef(_, a, _),\n-         &ty::TyRef(_, b, _)) |\n-        (&ty::TyRef(_, a, _),\n-         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n-         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+        (&ty::Ref(_, a, _),\n+         &ty::Ref(_, b, _)) |\n+        (&ty::Ref(_, a, _),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(bx.cx.type_is_sized(a));\n             let ptr_ty = bx.cx.layout_of(b).llvm_type(bx.cx).ptr_to();\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx, a, b, None))\n         }\n-        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n             assert!(bx.cx.type_is_sized(a));\n             let ptr_ty = bx.cx.layout_of(b).llvm_type(bx.cx).ptr_to();\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx, a, b, None))\n         }\n-        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n             let src_layout = bx.cx.layout_of(src_ty);\n@@ -299,16 +299,16 @@ pub fn coerce_unsized_into(\n         OperandValue::Pair(base, info).store(bx, dst);\n     };\n     match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::TyRef(..), &ty::TyRef(..)) |\n-        (&ty::TyRef(..), &ty::TyRawPtr(..)) |\n-        (&ty::TyRawPtr(..), &ty::TyRawPtr(..)) => {\n+        (&ty::Ref(..), &ty::Ref(..)) |\n+        (&ty::Ref(..), &ty::RawPtr(..)) |\n+        (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n             coerce_ptr()\n         }\n-        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             coerce_ptr()\n         }\n \n-        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n             for i in 0..def_a.variants[0].fields.len() {"}, {"sha": "53bb02ddd99d947887ad4a555fb4330114df511e", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -413,10 +413,10 @@ pub fn ty_fn_sig<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                            -> ty::PolyFnSig<'tcx>\n {\n     match ty.sty {\n-        ty::TyFnDef(..) |\n-        // Shims currently have type TyFnPtr. Not sure this should remain.\n-        ty::TyFnPtr(_) => ty.fn_sig(cx.tcx),\n-        ty::TyClosure(def_id, substs) => {\n+        ty::FnDef(..) |\n+        // Shims currently have type FnPtr. Not sure this should remain.\n+        ty::FnPtr(_) => ty.fn_sig(cx.tcx),\n+        ty::Closure(def_id, substs) => {\n             let tcx = cx.tcx;\n             let sig = substs.closure_sig(def_id, tcx);\n \n@@ -429,7 +429,7 @@ pub fn ty_fn_sig<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 sig.abi\n             ))\n         }\n-        ty::TyGenerator(def_id, substs, _) => {\n+        ty::Generator(def_id, substs, _) => {\n             let tcx = cx.tcx;\n             let sig = substs.poly_sig(def_id, cx.tcx);\n "}, {"sha": "6f09ebb382697e6fa0a66014bf7c03d40a712149", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -250,7 +250,7 @@ fn check_and_apply_linkage(\n         // static and call it a day. Some linkages (like weak) will make it such\n         // that the static actually has a null value.\n         let llty2 = match ty.sty {\n-            ty::TyRawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n+            ty::RawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n             _ => {\n                 if span.is_some() {\n                     cx.sess().span_fatal(span.unwrap(), \"must have type `*const T` or `*mut T`\")"}, {"sha": "500e659a76d95f7edc09a73e60b8fef1a529e37f", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -435,7 +435,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         let tail = self.tcx.struct_tail(ty);\n         match tail.sty {\n             ty::TyForeign(..) => false,\n-            ty::TyStr | ty::TySlice(..) | ty::TyDynamic(..) => true,\n+            ty::TyStr | ty::Slice(..) | ty::Dynamic(..) => true,\n             _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n         }\n     }"}, {"sha": "45bb951d9c18406298671bfde246ef8ab8185d44", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -309,7 +309,7 @@ fn fixed_vec_metadata(\n     let (size, align) = cx.size_and_align_of(array_or_slice_type);\n \n     let upper_bound = match array_or_slice_type.sty {\n-        ty::TyArray(_, len) => {\n+        ty::Array(_, len) => {\n             len.unwrap_usize(cx.tcx) as c_longlong\n         }\n         _ => -1\n@@ -396,7 +396,7 @@ fn subroutine_type_metadata(\n     let signature_metadata: Vec<_> = iter::once(\n         // return type\n         match signature.output().sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => None,\n+            ty::Tuple(ref tys) if tys.is_empty() => None,\n             _ => Some(type_metadata(cx, signature.output(), span))\n         }\n     ).chain(\n@@ -435,7 +435,7 @@ fn trait_pointer_metadata(\n     // But it does not describe the trait's methods.\n \n     let containing_scope = match trait_type.sty {\n-        ty::TyDynamic(ref data, ..) => if let Some(principal) = data.principal() {\n+        ty::Dynamic(ref data, ..) => if let Some(principal) = data.principal() {\n             let def_id = principal.def_id();\n             Some(get_namespace_for_item(cx, def_id))\n         } else {\n@@ -534,13 +534,13 @@ pub fn type_metadata(\n \n     let ptr_metadata = |ty: Ty<'tcx>| {\n         match ty.sty {\n-            ty::TySlice(typ) => {\n+            ty::Slice(typ) => {\n                 Ok(vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span))\n             }\n             ty::TyStr => {\n                 Ok(vec_slice_metadata(cx, t, cx.tcx.types.u8, unique_type_id, usage_site_span))\n             }\n-            ty::TyDynamic(..) => {\n+            ty::Dynamic(..) => {\n                 Ok(MetadataCreationResult::new(\n                     trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n                     false))\n@@ -562,25 +562,25 @@ pub fn type_metadata(\n     };\n \n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match t.sty {\n-        ty::TyNever    |\n+        ty::Never    |\n         ty::TyBool     |\n         ty::TyChar     |\n         ty::TyInt(_)   |\n         ty::TyUint(_)  |\n         ty::TyFloat(_) => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::TyTuple(ref elements) if elements.is_empty() => {\n+        ty::Tuple(ref elements) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::TyArray(typ, _) |\n-        ty::TySlice(typ) => {\n+        ty::Array(typ, _) |\n+        ty::Slice(typ) => {\n             fixed_vec_metadata(cx, unique_type_id, t, typ, usage_site_span)\n         }\n         ty::TyStr => {\n             fixed_vec_metadata(cx, unique_type_id, t, cx.tcx.types.i8, usage_site_span)\n         }\n-        ty::TyDynamic(..) => {\n+        ty::Dynamic(..) => {\n             MetadataCreationResult::new(\n                         trait_pointer_metadata(cx, t, None, unique_type_id),\n             false)\n@@ -590,20 +590,20 @@ pub fn type_metadata(\n                         foreign_type_metadata(cx, t, unique_type_id),\n             false)\n         }\n-        ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n-        ty::TyRef(_, ty, _) => {\n+        ty::RawPtr(ty::TypeAndMut{ty, ..}) |\n+        ty::Ref(_, ty, _) => {\n             match ptr_metadata(ty) {\n                 Ok(res) => res,\n                 Err(metadata) => return metadata,\n             }\n         }\n-        ty::TyAdt(def, _) if def.is_box() => {\n+        ty::Adt(def, _) if def.is_box() => {\n             match ptr_metadata(t.boxed_ty()) {\n                 Ok(res) => res,\n                 Err(metadata) => return metadata,\n             }\n         }\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n             let fn_metadata = subroutine_type_metadata(cx,\n                                                        unique_type_id,\n                                                        t.fn_sig(cx.tcx),\n@@ -619,15 +619,15 @@ pub fn type_metadata(\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n \n         }\n-        ty::TyClosure(def_id, substs) => {\n+        ty::Closure(def_id, substs) => {\n             let upvar_tys : Vec<_> = substs.upvar_tys(def_id, cx.tcx).collect();\n             prepare_tuple_metadata(cx,\n                                    t,\n                                    &upvar_tys,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n-        ty::TyGenerator(def_id, substs,  _) => {\n+        ty::Generator(def_id, substs,  _) => {\n             let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx).map(|t| {\n                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t)\n             }).collect();\n@@ -637,7 +637,7 @@ pub fn type_metadata(\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n-        ty::TyAdt(def, ..) => match def.adt_kind() {\n+        ty::Adt(def, ..) => match def.adt_kind() {\n             AdtKind::Struct => {\n                 prepare_struct_metadata(cx,\n                                         t,\n@@ -658,7 +658,7 @@ pub fn type_metadata(\n                                     usage_site_span).finalize(cx)\n             }\n         },\n-        ty::TyTuple(ref elements) => {\n+        ty::Tuple(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n                                    &elements[..],\n@@ -765,8 +765,8 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     debug!(\"basic_type_metadata: {:?}\", t);\n \n     let (name, encoding) = match t.sty {\n-        ty::TyNever => (\"!\", DW_ATE_unsigned),\n-        ty::TyTuple(ref elements) if elements.is_empty() =>\n+        ty::Never => (\"!\", DW_ATE_unsigned),\n+        ty::Tuple(ref elements) if elements.is_empty() =>\n             (\"()\", DW_ATE_unsigned),\n         ty::TyBool => (\"bool\", DW_ATE_boolean),\n         ty::TyChar => (\"char\", DW_ATE_unsigned_char),\n@@ -1009,7 +1009,7 @@ fn prepare_struct_metadata(\n     let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n \n     let (struct_def_id, variant) = match struct_type.sty {\n-        ty::TyAdt(def, _) => (def.did, def.non_enum_variant()),\n+        ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n         _ => bug!(\"prepare_struct_metadata on a non-ADT\")\n     };\n \n@@ -1126,7 +1126,7 @@ fn prepare_union_metadata(\n     let union_name = compute_debuginfo_type_name(cx, union_type, false);\n \n     let (union_def_id, variant) = match union_type.sty {\n-        ty::TyAdt(def, _) => (def.did, def.non_enum_variant()),\n+        ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n         _ => bug!(\"prepare_union_metadata on a non-ADT\")\n     };\n "}, {"sha": "99919a940b40511dcd605cea460440d5a1a9e05a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -323,7 +323,7 @@ pub fn create_function_debug_context(\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n         signature.push(match sig.output().sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => None,\n+            ty::Tuple(ref tys) if tys.is_empty() => None,\n             _ => Some(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n         });\n \n@@ -347,7 +347,7 @@ pub fn create_function_debug_context(\n             // already inaccurate due to ABI adjustments (see #42800).\n             signature.extend(inputs.iter().map(|&t| {\n                 let t = match t.sty {\n-                    ty::TyArray(ct, _)\n+                    ty::Array(ct, _)\n                         if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() => {\n                         cx.tcx.mk_imm_ptr(ct)\n                     }\n@@ -362,7 +362,7 @@ pub fn create_function_debug_context(\n         }\n \n         if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n-            if let ty::TyTuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n+            if let ty::Tuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n                 signature.extend(\n                     args.iter().map(|argument_type| {\n                         Some(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP))\n@@ -460,7 +460,7 @@ pub fn create_function_debug_context(\n                 // Only \"class\" methods are generally understood by LLVM,\n                 // so avoid methods on other types (e.g. `<*mut T>::null`).\n                 match impl_self_ty.sty {\n-                    ty::TyAdt(def, ..) if !def.is_box() => {\n+                    ty::Adt(def, ..) if !def.is_box() => {\n                         Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))\n                     }\n                     _ => None"}, {"sha": "e0ad72681ae11d5517332a2c7e7f0a1e0987ffd2", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -44,16 +44,16 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::TyBool => output.push_str(\"bool\"),\n         ty::TyChar => output.push_str(\"char\"),\n         ty::TyStr => output.push_str(\"str\"),\n-        ty::TyNever => output.push_str(\"!\"),\n+        ty::Never => output.push_str(\"!\"),\n         ty::TyInt(int_ty) => output.push_str(int_ty.ty_to_string()),\n         ty::TyUint(uint_ty) => output.push_str(uint_ty.ty_to_string()),\n         ty::TyFloat(float_ty) => output.push_str(float_ty.ty_to_string()),\n         ty::TyForeign(def_id) => push_item_name(cx, def_id, qualified, output),\n-        ty::TyAdt(def, substs) => {\n+        ty::Adt(def, substs) => {\n             push_item_name(cx, def.did, qualified, output);\n             push_type_params(cx, substs, output);\n         },\n-        ty::TyTuple(component_types) => {\n+        ty::Tuple(component_types) => {\n             output.push('(');\n             for &component_type in component_types {\n                 push_debuginfo_type_name(cx, component_type, true, output);\n@@ -65,7 +65,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             }\n             output.push(')');\n         },\n-        ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n+        ty::RawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n             if !cpp_like_names {\n                 output.push('*');\n             }\n@@ -80,7 +80,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push('*');\n             }\n         },\n-        ty::TyRef(_, inner_type, mutbl) => {\n+        ty::Ref(_, inner_type, mutbl) => {\n             if !cpp_like_names {\n                 output.push('&');\n             }\n@@ -94,13 +94,13 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push('*');\n             }\n         },\n-        ty::TyArray(inner_type, len) => {\n+        ty::Array(inner_type, len) => {\n             output.push('[');\n             push_debuginfo_type_name(cx, inner_type, true, output);\n             output.push_str(&format!(\"; {}\", len.unwrap_usize(cx.tcx)));\n             output.push(']');\n         },\n-        ty::TySlice(inner_type) => {\n+        ty::Slice(inner_type) => {\n             if cpp_like_names {\n                 output.push_str(\"slice<\");\n             } else {\n@@ -115,7 +115,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push(']');\n             }\n         },\n-        ty::TyDynamic(ref trait_data, ..) => {\n+        ty::Dynamic(ref trait_data, ..) => {\n             if let Some(principal) = trait_data.principal() {\n                 let principal = cx.tcx.normalize_erasing_late_bound_regions(\n                     ty::ParamEnv::reveal_all(),\n@@ -125,7 +125,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 push_type_params(cx, principal.substs, output);\n             }\n         },\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n             let sig = t.fn_sig(cx.tcx);\n             if sig.unsafety() == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n@@ -165,17 +165,17 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 push_debuginfo_type_name(cx, sig.output(), true, output);\n             }\n         },\n-        ty::TyClosure(..) => {\n+        ty::Closure(..) => {\n             output.push_str(\"closure\");\n         }\n-        ty::TyGenerator(..) => {\n+        ty::Generator(..) => {\n             output.push_str(\"generator\");\n         }\n-        ty::TyError |\n-        ty::TyInfer(_) |\n-        ty::TyProjection(..) |\n-        ty::TyAnon(..) |\n-        ty::TyGeneratorWitness(..) |\n+        ty::Error |\n+        ty::Infer(_) |\n+        ty::Projection(..) |\n+        ty::Anon(..) |\n+        ty::GeneratorWitness(..) |\n         ty::TyParam(_) => {\n             bug!(\"debuginfo: Trying to create type name for \\\n                 unexpected type: {:?}\", t);"}, {"sha": "791d003165f07145d6fbb78fc9febc7e1501348e", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -35,12 +35,12 @@ pub fn size_and_align_of_dst(bx: &Builder<'_, 'll, 'tcx>, t: Ty<'tcx>, info: Opt\n         return (size, align);\n     }\n     match t.sty {\n-        ty::TyDynamic(..) => {\n+        ty::Dynamic(..) => {\n             // load size/align from vtable\n             let vtable = info.unwrap();\n             (meth::SIZE.get_usize(bx, vtable), meth::ALIGN.get_usize(bx, vtable))\n         }\n-        ty::TySlice(_) | ty::TyStr => {\n+        ty::Slice(_) | ty::TyStr => {\n             let unit = t.sequence_element_type(bx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n@@ -81,7 +81,7 @@ pub fn size_and_align_of_dst(bx: &Builder<'_, 'll, 'tcx>, t: Ty<'tcx>, info: Opt\n             let size = bx.add(sized_size, unsized_size);\n \n             // Packed types ignore the alignment of their fields.\n-            if let ty::TyAdt(def, _) = t.sty {\n+            if let ty::Adt(def, _) = t.sty {\n                 if def.repr.packed() {\n                     unsized_align = sized_align;\n                 }"}, {"sha": "06abe31327a20849b0274e66350b5f4a9b9bdf27", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -98,7 +98,7 @@ pub fn codegen_intrinsic_call(\n     let tcx = cx.tcx;\n \n     let (def_id, substs) = match callee_ty.sty {\n-        ty::TyFnDef(def_id, substs) => (def_id, substs),\n+        ty::FnDef(def_id, substs) => (def_id, substs),\n         _ => bug!(\"expected fn item type, found {}\", callee_ty)\n     };\n \n@@ -1343,23 +1343,23 @@ fn generic_simd_intrinsic(\n         // This counts how many pointers\n         fn ptr_count(t: ty::Ty) -> usize {\n             match t.sty {\n-                ty::TyRawPtr(p) => 1 + ptr_count(p.ty),\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n                 _ => 0,\n             }\n         }\n \n         // Non-ptr type\n         fn non_ptr(t: ty::Ty) -> ty::Ty {\n             match t.sty {\n-                ty::TyRawPtr(p) => non_ptr(p.ty),\n+                ty::RawPtr(p) => non_ptr(p.ty),\n                 _ => t,\n             }\n         }\n \n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n         let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).sty {\n-            ty::TyRawPtr(p) if p.ty == in_elem => (ptr_count(arg_tys[1].simd_type(tcx)),\n+            ty::RawPtr(p) if p.ty == in_elem => (ptr_count(arg_tys[1].simd_type(tcx)),\n                                                    non_ptr(arg_tys[1].simd_type(tcx))),\n             _ => {\n                 require!(false, \"expected element type `{}` of second argument `{}` \\\n@@ -1439,23 +1439,23 @@ fn generic_simd_intrinsic(\n         // This counts how many pointers\n         fn ptr_count(t: ty::Ty) -> usize {\n             match t.sty {\n-                ty::TyRawPtr(p) => 1 + ptr_count(p.ty),\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n                 _ => 0,\n             }\n         }\n \n         // Non-ptr type\n         fn non_ptr(t: ty::Ty) -> ty::Ty {\n             match t.sty {\n-                ty::TyRawPtr(p) => non_ptr(p.ty),\n+                ty::RawPtr(p) => non_ptr(p.ty),\n                 _ => t,\n             }\n         }\n \n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n         let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).sty {\n-            ty::TyRawPtr(p) if p.ty == in_elem && p.mutbl == hir::MutMutable\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::MutMutable\n                 => (ptr_count(arg_tys[1].simd_type(tcx)),\n                     non_ptr(arg_tys[1].simd_type(tcx))),\n             _ => {"}, {"sha": "0206744eb2b6b2daabc4f60f67cdb95a99d4f51f", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -131,7 +131,7 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n                 func: mir::Operand::Constant(ref c),\n                 ref args, ..\n             } => match c.ty.sty {\n-                ty::TyFnDef(did, _) => Some((did, args)),\n+                ty::FnDef(did, _) => Some((did, args)),\n                 _ => None,\n             },\n             _ => None,"}, {"sha": "a534b4e478fb793e4f96496e4621287c25eb0a24", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -296,7 +296,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     &args1[..]\n                 };\n                 let (drop_fn, fn_ty) = match ty.sty {\n-                    ty::TyDynamic(..) => {\n+                    ty::Dynamic(..) => {\n                         let fn_ty = drop_fn.ty(bx.cx.tcx);\n                         let sig = common::ty_fn_sig(bx.cx, fn_ty);\n                         let sig = bx.tcx().normalize_erasing_late_bound_regions(\n@@ -417,14 +417,14 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 let callee = self.codegen_operand(&bx, func);\n \n                 let (instance, mut llfn) = match callee.layout.ty.sty {\n-                    ty::TyFnDef(def_id, substs) => {\n+                    ty::FnDef(def_id, substs) => {\n                         (Some(ty::Instance::resolve(bx.cx.tcx,\n                                                     ty::ParamEnv::reveal_all(),\n                                                     def_id,\n                                                     substs).unwrap()),\n                          None)\n                     }\n-                    ty::TyFnPtr(_) => {\n+                    ty::FnPtr(_) => {\n                         (None, Some(callee.immediate()))\n                     }\n                     _ => bug!(\"{} is not callable\", callee.layout.ty)"}, {"sha": "2657543b2d167c477af34597873c56b41a8926e2", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -182,7 +182,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             .and_then(|c| {\n                 let field_ty = c.ty.builtin_index().unwrap();\n                 let fields = match c.ty.sty {\n-                    ty::TyArray(_, n) => n.unwrap_usize(bx.tcx()),\n+                    ty::Array(_, n) => n.unwrap_usize(bx.tcx()),\n                     ref other => bug!(\"invalid simd shuffle type: {}\", other),\n                 };\n                 let values: Result<Vec<_>, Lrc<_>> = (0..fields).map(|field| {"}, {"sha": "9e65144bd60a1fd87fd6ff425fd76a676fe34a42", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -467,7 +467,7 @@ fn arg_local_refs(\n \n             let arg_ty = fx.monomorphize(&arg_decl.ty);\n             let tupled_arg_tys = match arg_ty.sty {\n-                ty::TyTuple(ref tys) => tys,\n+                ty::Tuple(ref tys) => tys,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n@@ -592,14 +592,14 @@ fn arg_local_refs(\n \n             // Or is it the closure environment?\n             let (closure_layout, env_ref) = match arg.layout.ty.sty {\n-                ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-                ty::TyRef(_, ty, _)  => (bx.cx.layout_of(ty), true),\n+                ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n+                ty::Ref(_, ty, _)  => (bx.cx.layout_of(ty), true),\n                 _ => (arg.layout, false)\n             };\n \n             let (def_id, upvar_substs) = match closure_layout.ty.sty {\n-                ty::TyClosure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n-                ty::TyGenerator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n+                ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n+                ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n                 _ => bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_layout.ty)\n             };\n             let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n@@ -639,7 +639,7 @@ fn arg_local_refs(\n                 // a pointer in an alloca for debuginfo atm.\n                 let mut ops = if env_ref || env_alloca { &ops[..] } else { &ops[1..] };\n \n-                let ty = if let (true, &ty::TyRef(_, ty, _)) = (decl.by_ref, &ty.sty) {\n+                let ty = if let (true, &ty::Ref(_, ty, _)) = (decl.by_ref, &ty.sty) {\n                     ty\n                 } else {\n                     ops = &ops[..ops.len() - 1];"}, {"sha": "ace907055a3ab34c0b1199b65fc0cc96b062d5ca", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -211,8 +211,8 @@ impl PlaceRef<'ll, 'tcx> {\n                 return simple();\n             }\n             _ if !field.is_unsized() => return simple(),\n-            ty::TySlice(..) | ty::TyStr | ty::TyForeign(..) => return simple(),\n-            ty::TyAdt(def, _) => {\n+            ty::Slice(..) | ty::TyStr | ty::TyForeign(..) => return simple(),\n+            ty::Adt(def, _) => {\n                 if def.repr.packed() {\n                     // FIXME(eddyb) generalize the adjustment when we\n                     // start supporting packing to larger alignments."}, {"sha": "69263cbf416bd5419e42a85dc8bf12d0d633b8ae", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -214,7 +214,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.layout.ty.sty {\n-                            ty::TyFnDef(def_id, substs) => {\n+                            ty::FnDef(def_id, substs) => {\n                                 if bx.cx.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n                                     bug!(\"reifying a fn ptr that requires \\\n                                           const arguments\");\n@@ -229,7 +229,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     }\n                     mir::CastKind::ClosureFnPointer => {\n                         match operand.layout.ty.sty {\n-                            ty::TyClosure(def_id, substs) => {\n+                            ty::Closure(def_id, substs) => {\n                                 let instance = monomorphize::resolve_closure(\n                                     bx.cx.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n                                 OperandValue::Immediate(callee::get_fn(bx.cx, instance))\n@@ -545,7 +545,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         // because codegen_place() panics if Local is operand.\n         if let mir::Place::Local(index) = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n-                if let ty::TyArray(_, n) = op.layout.ty.sty {\n+                if let ty::Array(_, n) = op.layout.ty.sty {\n                     let n = n.unwrap_usize(bx.cx.tcx);\n                     return common::C_usize(bx.cx, n);\n                 }"}, {"sha": "a970d41c15b400fc5e5173bcaf89c7e788a6f9f7", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -56,19 +56,19 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     }\n \n     let name = match layout.ty.sty {\n-        ty::TyClosure(..) |\n-        ty::TyGenerator(..) |\n-        ty::TyAdt(..) |\n+        ty::Closure(..) |\n+        ty::Generator(..) |\n+        ty::Adt(..) |\n         // FIXME(eddyb) producing readable type names for trait objects can result\n         // in problematically distinct types due to HRTB and subtyping (see #47638).\n-        // ty::TyDynamic(..) |\n+        // ty::Dynamic(..) |\n         ty::TyForeign(..) |\n         ty::TyStr => {\n             let mut name = String::with_capacity(32);\n             let printer = DefPathBasedNames::new(cx.tcx, true, true);\n             printer.push_type_name(layout.ty, &mut name);\n             match (&layout.ty.sty, &layout.variants) {\n-                (&ty::TyAdt(def, _), &layout::Variants::Single { index }) => {\n+                (&ty::Adt(def, _), &layout::Variants::Single { index }) => {\n                     if def.is_enum() && !def.variants.is_empty() {\n                         write!(&mut name, \"::{}\", def.variants[index].name).unwrap();\n                     }\n@@ -252,14 +252,14 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 return llty;\n             }\n             let llty = match self.ty.sty {\n-                ty::TyRef(_, ty, _) |\n-                ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                ty::Ref(_, ty, _) |\n+                ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n                     cx.layout_of(ty).llvm_type(cx).ptr_to()\n                 }\n-                ty::TyAdt(def, _) if def.is_box() => {\n+                ty::Adt(def, _) if def.is_box() => {\n                     cx.layout_of(self.ty.boxed_ty()).llvm_type(cx).ptr_to()\n                 }\n-                ty::TyFnPtr(sig) => {\n+                ty::FnPtr(sig) => {\n                     let sig = cx.tcx.normalize_erasing_late_bound_regions(\n                         ty::ParamEnv::reveal_all(),\n                         &sig,\n@@ -344,11 +344,11 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n         match self.ty.sty {\n-            ty::TyRef(..) |\n-            ty::TyRawPtr(_) => {\n+            ty::Ref(..) |\n+            ty::RawPtr(_) => {\n                 return self.field(cx, index).llvm_type(cx);\n             }\n-            ty::TyAdt(def, _) if def.is_box() => {\n+            ty::Adt(def, _) if def.is_box() => {\n                 let ptr_ty = cx.tcx.mk_mut_ptr(self.ty.boxed_ty());\n                 return cx.layout_of(ptr_ty).scalar_pair_element_llvm_type(cx, index, immediate);\n             }\n@@ -410,7 +410,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         let mut result = None;\n         match self.ty.sty {\n-            ty::TyRawPtr(mt) if offset.bytes() == 0 => {\n+            ty::RawPtr(mt) if offset.bytes() == 0 => {\n                 let (size, align) = cx.size_and_align_of(mt.ty);\n                 result = Some(PointeeInfo {\n                     size,\n@@ -419,7 +419,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 });\n             }\n \n-            ty::TyRef(_, ty, mt) if offset.bytes() == 0 => {\n+            ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n                 let (size, align) = cx.size_and_align_of(ty);\n \n                 let kind = match mt {\n@@ -497,7 +497,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n                 // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n                 if let Some(ref mut pointee) = result {\n-                    if let ty::TyAdt(def, _) = self.ty.sty {\n+                    if let ty::Adt(def, _) = self.ty.sty {\n                         if def.is_box() && offset.bytes() == 0 {\n                             pointee.safe = Some(PointerKind::UniqueOwned);\n                         }"}, {"sha": "33ce06217a46e80e7d012bac4d7728876b1b9892", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -171,7 +171,7 @@ fn get_symbol_hash<'a, 'tcx>(\n         // If this is a function, we hash the signature as well.\n         // This is not *strictly* needed, but it may help in some\n         // situations, see the `run-make/a-b-a-linker-guard` test.\n-        if let ty::TyFnDef(..) = item_type.sty {\n+        if let ty::FnDef(..) = item_type.sty {\n             item_type.fn_sig(tcx).hash_stable(&mut hcx, &mut hasher);\n         }\n "}, {"sha": "c26d8555214c1cfbb894fc04d2a57f20bd0e4322", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -1320,7 +1320,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr) {\n-            Some((&ty::TyRef(_, _, from_mt), &ty::TyRef(_, _, to_mt))) => {\n+            Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n                 if to_mt == hir::Mutability::MutMutable &&\n                    from_mt == hir::Mutability::MutImmutable {\n                     cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);"}, {"sha": "767d7430ee8d3c8d83c1ddf18926c483f8481919", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -460,10 +460,10 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         if def.variants[data_idx].fields.len() == 1 {\n             match def.variants[data_idx].fields[0].ty(tcx, substs).sty {\n-                ty::TyFnPtr(_) => {\n+                ty::FnPtr(_) => {\n                     return true;\n                 }\n-                ty::TyRef(..) => {\n+                ty::Ref(..) => {\n                     return true;\n                 }\n                 _ => {}\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         match ty.sty {\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 if def.is_phantom_data() {\n                     return FfiPhantom(ty);\n                 }\n@@ -646,15 +646,15 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             },\n \n             // Primitive types with a stable representation.\n-            ty::TyBool | ty::TyInt(..) | ty::TyUint(..) | ty::TyFloat(..) | ty::TyNever => FfiSafe,\n+            ty::TyBool | ty::TyInt(..) | ty::TyUint(..) | ty::TyFloat(..) | ty::Never => FfiSafe,\n \n-            ty::TySlice(_) => FfiUnsafe {\n+            ty::Slice(_) => FfiUnsafe {\n                 ty: ty,\n                 reason: \"slices have no C equivalent\",\n                 help: Some(\"consider using a raw pointer instead\"),\n             },\n \n-            ty::TyDynamic(..) => FfiUnsafe {\n+            ty::Dynamic(..) => FfiUnsafe {\n                 ty: ty,\n                 reason: \"trait objects have no C equivalent\",\n                 help: None,\n@@ -666,18 +666,18 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 help: Some(\"consider using `*const u8` and a length instead\"),\n             },\n \n-            ty::TyTuple(..) => FfiUnsafe {\n+            ty::Tuple(..) => FfiUnsafe {\n                 ty: ty,\n                 reason: \"tuples have unspecified layout\",\n                 help: Some(\"consider using a struct instead\"),\n             },\n \n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-            ty::TyRef(_, ty, _) => self.check_type_for_ffi(cache, ty),\n+            ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n+            ty::Ref(_, ty, _) => self.check_type_for_ffi(cache, ty),\n \n-            ty::TyArray(ty, _) => self.check_type_for_ffi(cache, ty),\n+            ty::Array(ty, _) => self.check_type_for_ffi(cache, ty),\n \n-            ty::TyFnPtr(sig) => {\n+            ty::FnPtr(sig) => {\n                 match sig.abi() {\n                     Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic | Abi::RustCall => {\n                         return FfiUnsafe {\n@@ -715,14 +715,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::TyForeign(..) => FfiSafe,\n \n             ty::TyParam(..) |\n-            ty::TyInfer(..) |\n-            ty::TyError |\n-            ty::TyClosure(..) |\n-            ty::TyGenerator(..) |\n-            ty::TyGeneratorWitness(..) |\n-            ty::TyProjection(..) |\n-            ty::TyAnon(..) |\n-            ty::TyFnDef(..) => bug!(\"Unexpected type in foreign function\"),\n+            ty::Infer(..) |\n+            ty::Error |\n+            ty::Closure(..) |\n+            ty::Generator(..) |\n+            ty::GeneratorWitness(..) |\n+            ty::Projection(..) |\n+            ty::Anon(..) |\n+            ty::FnDef(..) => bug!(\"Unexpected type in foreign function\"),\n         }\n     }\n \n@@ -746,7 +746,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 if let Some(s) = help {\n                     diag.help(s);\n                 }\n-                if let ty::TyAdt(def, _) = unsafe_ty.sty {\n+                if let ty::Adt(def, _) = unsafe_ty.sty {\n                     if let Some(sp) = self.cx.tcx.hir.span_if_local(def.did) {\n                         diag.span_note(sp, \"type defined here\");\n                     }"}, {"sha": "7a9d18676cf6c9d2e405a819d4de8aeaea599fd6", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -60,9 +60,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let t = cx.tables.expr_ty(&expr);\n         let ty_warned = match t.sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => return,\n-            ty::TyNever => return,\n-            ty::TyAdt(def, _) => {\n+            ty::Tuple(ref tys) if tys.is_empty() => return,\n+            ty::Never => return,\n+            ty::Adt(def, _) => {\n                 if def.variants.is_empty() {\n                     return;\n                 } else {"}, {"sha": "44d8d4a727769906b75d0430071a31d96fbcecf4", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -1342,15 +1342,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n         let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n         let kind = match tables.node_id_to_type(hir_id).sty {\n-            ty::TyGenerator(def_id, ..) => {\n+            ty::Generator(def_id, ..) => {\n                 let layout = self.tcx.generator_layout(def_id);\n                 let data = GeneratorData {\n                     layout: layout.clone(),\n                 };\n                 EntryKind::Generator(self.lazy(&data))\n             }\n \n-            ty::TyClosure(def_id, substs) => {\n+            ty::Closure(def_id, substs) => {\n                 let sig = substs.closure_sig(def_id, self.tcx);\n                 let data = ClosureData { sig: self.lazy(&sig) };\n                 EntryKind::Closure(self.lazy(&data))\n@@ -1865,7 +1865,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n pub fn get_repr_options<'a, 'tcx, 'gcx>(tcx: &TyCtxt<'a, 'tcx, 'gcx>, did: DefId) -> ReprOptions {\n     let ty = tcx.type_of(did);\n     match ty.sty {\n-        ty::TyAdt(ref def, _) => return def.repr,\n+        ty::Adt(ref def, _) => return def.repr,\n         _ => bug!(\"{} is not an ADT\", ty),\n     }\n }"}, {"sha": "288c540a55e2d59652d914cf8da408ee1e5da5c7", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -134,7 +134,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             if let Some(ty) = self.retrieve_type_for_place(place) {\n                 let needs_note = match ty.sty {\n-                    ty::TyKind::TyClosure(id, _) => {\n+                    ty::TyKind::Closure(id, _) => {\n                         let tables = self.tcx.typeck_tables_of(id);\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n                         let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n@@ -834,19 +834,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             self.describe_field_from_ty(&ty.boxed_ty(), field)\n         } else {\n             match ty.sty {\n-                ty::TyAdt(def, _) => if def.is_enum() {\n+                ty::Adt(def, _) => if def.is_enum() {\n                     field.index().to_string()\n                 } else {\n                     def.non_enum_variant().fields[field.index()]\n                         .ident\n                         .to_string()\n                 },\n-                ty::TyTuple(_) => field.index().to_string(),\n-                ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                ty::Tuple(_) => field.index().to_string(),\n+                ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n                     self.describe_field_from_ty(&ty, field)\n                 }\n-                ty::TyArray(ty, _) | ty::TySlice(ty) => self.describe_field_from_ty(&ty, field),\n-                ty::TyClosure(def_id, _) | ty::TyGenerator(def_id, _, _) => {\n+                ty::Array(ty, _) | ty::Slice(ty) => self.describe_field_from_ty(&ty, field),\n+                ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                     // Convert the def-id into a node-id. node-ids are only valid for\n                     // the local code in the current crate, so this returns an `Option` in case\n                     // the closure comes from another crate. But in that case we wouldn't"}, {"sha": "f4071e02f558087e9c2a506918a529cb8118c291", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -935,22 +935,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // individual fields instead. This way if `foo` has a\n             // destructor but `bar` does not, we will only check for\n             // borrows of `x.foo` and not `x.bar`. See #47703.\n-            ty::TyAdt(def, substs) if def.is_struct() && !def.has_dtor(self.tcx) => {\n+            ty::Adt(def, substs) if def.is_struct() && !def.has_dtor(self.tcx) => {\n                 def.all_fields()\n                     .map(|field| field.ty(gcx, substs))\n                     .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             // Same as above, but for tuples.\n-            ty::TyTuple(tys) => {\n+            ty::Tuple(tys) => {\n                 tys.iter()\n                     .cloned()\n                     .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             // Closures also have disjoint fields, but they are only\n             // directly accessed in the body of the closure.\n-            ty::TyClosure(def, substs)\n+            ty::Closure(def, substs)\n                 if *drop_place == Place::Local(Local::new(1))\n                     && !self.mir.upvar_decls.is_empty() =>\n             {\n@@ -961,7 +961,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n             // Generators also have disjoint fields, but they are only\n             // directly accessed in the body of the generator.\n-            ty::TyGenerator(def, substs, _)\n+            ty::Generator(def, substs, _)\n                 if *drop_place == Place::Local(Local::new(1))\n                     && !self.mir.upvar_decls.is_empty() =>\n             {\n@@ -978,7 +978,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // the base case below, we would have a Deep Write due to\n             // the box being `needs_drop`, and that Deep Write would\n             // touch `&mut` data in the box.\n-            ty::TyAdt(def, _) if def.is_box() => {\n+            ty::Adt(def, _) if def.is_box() => {\n                 // When/if we add a `&own T` type, this action would\n                 // be like running the destructor of the `&own T`.\n                 // (And the owner of backing storage referenced by the\n@@ -1818,7 +1818,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // be already initialized\n                             let tcx = self.tcx;\n                             match base.ty(self.mir, tcx).to_ty(tcx).sty {\n-                                ty::TyAdt(def, _) if def.has_dtor(tcx) => {\n+                                ty::Adt(def, _) if def.has_dtor(tcx) => {\n \n                                     // FIXME: analogous code in\n                                     // check_loans.rs first maps\n@@ -2062,7 +2062,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n-                            ty::TyRef(_, _, mutbl) => {\n+                            ty::Ref(_, _, mutbl) => {\n                                 match mutbl {\n                                     // Shared borrowed data is never mutable\n                                     hir::MutImmutable => Err(place),\n@@ -2086,7 +2086,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     }\n                                 }\n                             }\n-                            ty::TyRawPtr(tnm) => {\n+                            ty::RawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n                                     hir::MutImmutable => return Err(place),"}, {"sha": "497e8e07853fbdb7e3992244b44d4f4b2e949115", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -261,10 +261,10 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             .any(|p| p.is_upvar_field_projection(self.mir, &self.tcx)\n                                  .is_some());\n                         match ty.sty {\n-                            ty::TyArray(..) | ty::TySlice(..) => self\n+                            ty::Array(..) | ty::Slice(..) => self\n                                 .tcx\n                                 .cannot_move_out_of_interior_noncopy(span, ty, None, origin),\n-                            ty::TyClosure(def_id, closure_substs)\n+                            ty::Closure(def_id, closure_substs)\n                                 if !self.mir.upvar_decls.is_empty() && is_upvar_field_projection\n                             => {\n                                 let closure_kind_ty ="}, {"sha": "f233a17597a5468f5a88d72c4266889640a2e2fe", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -312,26 +312,26 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n             // individual fields instead. This way if `foo` has a\n             // destructor but `bar` does not, we will only check for\n             // borrows of `x.foo` and not `x.bar`. See #47703.\n-            ty::TyAdt(def, substs) if def.is_struct() && !def.has_dtor(self.infcx.tcx) => {\n+            ty::Adt(def, substs) if def.is_struct() && !def.has_dtor(self.infcx.tcx) => {\n                 def.all_fields()\n                     .map(|field| field.ty(gcx, substs))\n                     .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             // Same as above, but for tuples.\n-            ty::TyTuple(tys) => {\n+            ty::Tuple(tys) => {\n                 tys.iter().cloned().enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             // Closures and generators also have disjoint fields, but they are only\n             // directly accessed in the body of the closure/generator.\n-            ty::TyGenerator(def, substs, ..)\n+            ty::Generator(def, substs, ..)\n                 if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n             => {\n                 substs.upvar_tys(def, self.infcx.tcx).enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n-            ty::TyClosure(def, substs)\n+            ty::Closure(def, substs)\n                 if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n                 => {\n                     substs.upvar_tys(def, self.infcx.tcx).enumerate()"}, {"sha": "6177194ab914d5817d69e9ef1fa0f159b2bb0d6d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -376,7 +376,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 //     &\n                 //     - let's call the lifetime of this reference `'1`\n                 (\n-                    ty::TyRef(region, referent_ty, _),\n+                    ty::Ref(region, referent_ty, _),\n                     hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n                 ) => {\n                     if region.to_region_vid() == needle_fr {\n@@ -403,7 +403,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                 // Match up something like `Foo<'1>`\n                 (\n-                    ty::TyAdt(_adt_def, substs),\n+                    ty::Adt(_adt_def, substs),\n                     hir::TyKind::Path(hir::QPath::Resolved(None, path)),\n                 ) => {\n                     if let Some(last_segment) = path.segments.last() {\n@@ -423,16 +423,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // The following cases don't have lifetimes, so we\n                 // just worry about trying to match up the rustc type\n                 // with the HIR types:\n-                (ty::TyTuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n+                (ty::Tuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n                     search_stack.extend(elem_tys.iter().cloned().zip(elem_hir_tys));\n                 }\n \n-                (ty::TySlice(elem_ty), hir::TyKind::Slice(elem_hir_ty))\n-                | (ty::TyArray(elem_ty, _), hir::TyKind::Array(elem_hir_ty, _)) => {\n+                (ty::Slice(elem_ty), hir::TyKind::Slice(elem_hir_ty))\n+                | (ty::Array(elem_ty, _), hir::TyKind::Array(elem_hir_ty, _)) => {\n                     search_stack.push((elem_ty, elem_hir_ty));\n                 }\n \n-                (ty::TyRawPtr(mut_ty), hir::TyKind::Ptr(mut_hir_ty)) => {\n+                (ty::RawPtr(mut_ty), hir::TyKind::Ptr(mut_hir_ty)) => {\n                     search_stack.push((mut_ty.ty, &mut_hir_ty.ty));\n                 }\n "}, {"sha": "2fb5861dff44453d4018d75dea29eddd4e0f9d00", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -320,7 +320,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         // constraints on `'a` and `'b`. These constraints\n         // would be lost if we just look at the normalized\n         // value.\n-        if let ty::TyFnDef(def_id, substs) = constant.literal.ty.sty {\n+        if let ty::FnDef(def_id, substs) = constant.literal.ty.sty {\n             let tcx = self.tcx();\n             let type_checker = &mut self.cx;\n \n@@ -483,7 +483,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             }\n             ProjectionElem::Subslice { from, to } => PlaceTy::Ty {\n                 ty: match base_ty.sty {\n-                    ty::TyArray(inner, size) => {\n+                    ty::Array(inner, size) => {\n                         let size = size.unwrap_usize(tcx);\n                         let min_size = (from as u64) + (to as u64);\n                         if let Some(rest_size) = size.checked_sub(min_size) {\n@@ -497,12 +497,12 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                             )\n                         }\n                     }\n-                    ty::TySlice(..) => base_ty,\n+                    ty::Slice(..) => base_ty,\n                     _ => span_mirbug_and_err!(self, place, \"slice of non-array {:?}\", base_ty),\n                 },\n             },\n             ProjectionElem::Downcast(adt_def1, index) => match base_ty.sty {\n-                ty::TyAdt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n+                ty::Adt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n                     if index >= adt_def.variants.len() {\n                         PlaceTy::Ty {\n                             ty: span_mirbug_and_err!(\n@@ -578,16 +578,16 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 variant_index,\n             } => (&adt_def.variants[variant_index], substs),\n             PlaceTy::Ty { ty } => match ty.sty {\n-                ty::TyAdt(adt_def, substs) if !adt_def.is_enum() => (&adt_def.variants[0], substs),\n-                ty::TyClosure(def_id, substs) => {\n+                ty::Adt(adt_def, substs) if !adt_def.is_enum() => (&adt_def.variants[0], substs),\n+                ty::Closure(def_id, substs) => {\n                     return match substs.upvar_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n                             field_count: substs.upvar_tys(def_id, tcx).count(),\n                         }),\n                     }\n                 }\n-                ty::TyGenerator(def_id, substs, _) => {\n+                ty::Generator(def_id, substs, _) => {\n                     // Try pre-transform fields first (upvars and current state)\n                     if let Some(ty) = substs.pre_transforms_tys(def_id, tcx).nth(field.index()) {\n                         return Ok(ty);\n@@ -602,7 +602,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         }),\n                     };\n                 }\n-                ty::TyTuple(tys) => {\n+                ty::Tuple(tys) => {\n                     return match tys.get(field.index()) {\n                         Some(&ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n@@ -917,7 +917,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             } => {\n                 let place_type = place.ty(mir, tcx).to_ty(tcx);\n                 let adt = match place_type.sty {\n-                    TyKind::TyAdt(adt, _) if adt.is_enum() => adt,\n+                    TyKind::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n                         span_bug!(\n                             stmt.source_info.span,\n@@ -1032,7 +1032,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let func_ty = func.ty(mir, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let sig = match func_ty.sty {\n-                    ty::TyFnDef(..) | ty::TyFnPtr(_) => func_ty.fn_sig(tcx),\n+                    ty::FnDef(..) | ty::FnPtr(_) => func_ty.fn_sig(tcx),\n                     _ => {\n                         span_mirbug!(self, term, \"call to non-function {:?}\", func_ty);\n                         return;\n@@ -1472,7 +1472,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 CastKind::ClosureFnPointer => {\n                     let sig = match op.ty(mir, tcx).sty {\n-                        ty::TyClosure(def_id, substs) => {\n+                        ty::Closure(def_id, substs) => {\n                             substs.closure_sig_ty(def_id, tcx).fn_sig(tcx)\n                         }\n                         _ => bug!(),\n@@ -1650,7 +1650,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n-                        ty::TyRef(ref_region, _, mutbl) => {\n+                        ty::Ref(ref_region, _, mutbl) => {\n                             constraints.outlives_constraints.push(OutlivesConstraint {\n                                 sup: ref_region.to_region_vid(),\n                                 sub: borrow_region.to_region_vid(),\n@@ -1697,11 +1697,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                                 }\n                             }\n                         }\n-                        ty::TyRawPtr(..) => {\n+                        ty::RawPtr(..) => {\n                             // deref of raw pointer, guaranteed to be valid\n                             break;\n                         }\n-                        ty::TyAdt(def, _) if def.is_box() => {\n+                        ty::Adt(def, _) if def.is_box() => {\n                             // deref of `Box`, need the base to be valid - propagate\n                         }\n                         _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place),"}, {"sha": "deb972ee04611058d6bb339bcde1b6f248ec2988", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -325,7 +325,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         // Watch out for the case that we are matching a `?T` against the\n         // right-hand side.\n-        if let ty::TyInfer(ty::CanonicalTy(var)) = a.sty {\n+        if let ty::Infer(ty::CanonicalTy(var)) = a.sty {\n             self.equate_var(var, b.into())?;\n             Ok(a)\n         } else {"}, {"sha": "8112b71b127527f1a9d38a1bb67875a840bdcd2e", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -64,7 +64,7 @@ pub struct UniversalRegions<'tcx> {\n \n     /// The \"defining\" type for this function, with all universal\n     /// regions instantiated.  For a closure or generator, this is the\n-    /// closure type, but for a top-level function it's the `TyFnDef`.\n+    /// closure type, but for a top-level function it's the `FnDef`.\n     pub defining_ty: DefiningTy<'tcx>,\n \n     /// The return type of this function, with all regions replaced by\n@@ -437,11 +437,11 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n                     .replace_free_regions_with_nll_infer_vars(FR, &defining_ty);\n \n                 match defining_ty.sty {\n-                    ty::TyClosure(def_id, substs) => DefiningTy::Closure(def_id, substs),\n-                    ty::TyGenerator(def_id, substs, movability) => {\n+                    ty::Closure(def_id, substs) => DefiningTy::Closure(def_id, substs),\n+                    ty::Generator(def_id, substs, movability) => {\n                         DefiningTy::Generator(def_id, substs, movability)\n                     }\n-                    ty::TyFnDef(def_id, substs) => DefiningTy::FnDef(def_id, substs),\n+                    ty::FnDef(def_id, substs) => DefiningTy::FnDef(def_id, substs),\n                     _ => span_bug!(\n                         tcx.def_span(self.mir_def_id),\n                         \"expected defining type for `{:?}`: `{:?}`\",\n@@ -524,7 +524,7 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n                         let (&output, tuplized_inputs) = inputs_and_output.split_last().unwrap();\n                         assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n                         let inputs = match tuplized_inputs[0].sty {\n-                            ty::TyTuple(inputs) => inputs,\n+                            ty::Tuple(inputs) => inputs,\n                             _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n                         };\n "}, {"sha": "2b4a1553e1a893d3054e048105b3b1937493fe03", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                         // original path into a new variable and\n                         // borrowed *that* one, leaving the original\n                         // path unborrowed.\n-                        ty::TyRawPtr(..) | ty::TyRef(_, _, hir::MutImmutable) => true,\n+                        ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => true,\n                         _ => proj.base.ignore_borrow(tcx, mir),\n                     }\n                 }"}, {"sha": "f791735690922aaf81404a684cad5c3b88e9b7a4", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -170,7 +170,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                         debug!(\"places_conflict: shallow access behind ptr\");\n                         return false;\n                     }\n-                    (ProjectionElem::Deref, ty::TyRef(_, _, hir::MutImmutable), _) => {\n+                    (ProjectionElem::Deref, ty::Ref(_, _, hir::MutImmutable), _) => {\n                         // the borrow goes through a dereference of a shared reference.\n                         //\n                         // I'm not sure why we are tracking these borrows - shared\n@@ -329,7 +329,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n         }\n         (Place::Promoted(p1), Place::Promoted(p2)) => {\n             if p1.0 == p2.0 {\n-                if let ty::TyArray(_, size) = p1.1.sty {\n+                if let ty::Array(_, size) = p1.1.sty {\n                     if size.unwrap_usize(tcx) == 0 {\n                         // Ignore conflicts with promoted [T; 0].\n                         debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n@@ -366,7 +366,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                     } else {\n                         let ty = pi1.base.ty(mir, tcx).to_ty(tcx);\n                         match ty.sty {\n-                            ty::TyAdt(def, _) if def.is_union() => {\n+                            ty::Adt(def, _) if def.is_union() => {\n                                 // Different fields of a union, we are basically stuck.\n                                 debug!(\"place_element_conflict: STUCK-UNION\");\n                                 Overlap::Arbitrary"}, {"sha": "8dcc1143306212079b1b8178a4254c4da22bc9ba", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -155,8 +155,8 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n \n             let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n             match ty.sty {\n-                ty::TyRawPtr(_) |\n-                ty::TyRef(\n+                ty::RawPtr(_) |\n+                ty::Ref(\n                     _, /*rgn*/\n                     _, /*ty*/\n                     hir::MutImmutable\n@@ -166,7 +166,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n                     return Some(cursor);\n                 }\n \n-                ty::TyRef(\n+                ty::Ref(\n                     _, /*rgn*/\n                     _, /*ty*/\n                     hir::MutMutable,\n@@ -175,7 +175,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n                     return Some(cursor);\n                 }\n \n-                ty::TyAdt(..) if ty.is_box() => {\n+                ty::Adt(..) if ty.is_box() => {\n                     self.next = Some(&proj.base);\n                     return Some(cursor);\n                 }"}, {"sha": "2b05e2c023a5c7295cf359984a1a498896705bbf", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // FIXME(canndrew): This is_never should probably be an is_uninhabited\n                 let diverges = expr.ty.is_never();\n                 let intrinsic = match ty.sty {\n-                    ty::TyFnDef(def_id, _)  => {\n+                    ty::FnDef(def_id, _)  => {\n                         let f = ty.fn_sig(this.hir.tcx());\n                         if f.abi() == Abi::RustIntrinsic ||\n                            f.abi() == Abi::PlatformIntrinsic {"}, {"sha": "e41698f1f0d806f6252f7fd7b3da17d8ae459237", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -272,8 +272,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // array, so we can call `<[u8]>::eq` rather than having to find an\n                     // `<[u8; N]>::eq`.\n                     let unsize = |ty: Ty<'tcx>| match ty.sty {\n-                        ty::TyRef(region, rty, _) => match rty.sty {\n-                            ty::TyArray(inner_ty, n) => Some((region, inner_ty, n)),\n+                        ty::Ref(region, rty, _) => match rty.sty {\n+                            ty::Array(inner_ty, n) => Some((region, inner_ty, n)),\n                             _ => None,\n                         },\n                         _ => None,"}, {"sha": "179bc2426ab4a2e2a4911b82bfbfec47e1eff571", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -67,13 +67,13 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             let ty = tcx.type_of(tcx.hir.local_def_id(id));\n             let mut abi = fn_sig.abi;\n             let implicit_argument = match ty.sty {\n-                ty::TyClosure(..) => {\n+                ty::Closure(..) => {\n                     // HACK(eddyb) Avoid having RustCall on closures,\n                     // as it adds unnecessary (and wrong) auto-tupling.\n                     abi = Abi::Rust;\n                     Some(ArgInfo(liberated_closure_env_ty(tcx, id, body_id), None, None, None))\n                 }\n-                ty::TyGenerator(..) => {\n+                ty::Generator(..) => {\n                     let gen_ty = tcx.body_tables(body_id).node_id_to_type(fn_hir_id);\n                     Some(ArgInfo(gen_ty, None, None, None))\n                 }\n@@ -115,7 +115,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n \n             let (yield_ty, return_ty) = if body.is_generator {\n                 let gen_sig = match ty.sty {\n-                    ty::TyGenerator(gen_def_id, gen_substs, ..) =>\n+                    ty::Generator(gen_def_id, gen_substs, ..) =>\n                         gen_substs.sig(gen_def_id, tcx),\n                     _ =>\n                         span_bug!(tcx.hir.span(id), \"generator w/o generator type: {:?}\", ty),\n@@ -241,7 +241,7 @@ fn liberated_closure_env_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_hir_id);\n \n     let (closure_def_id, closure_substs) = match closure_ty.sty {\n-        ty::TyClosure(closure_def_id, closure_substs) => (closure_def_id, closure_substs),\n+        ty::Closure(closure_def_id, closure_substs) => (closure_def_id, closure_substs),\n         _ => bug!(\"closure expr does not have closure type: {:?}\", closure_ty)\n     };\n "}, {"sha": "7af1daae4cad50602142cbab1a96dc5a80725102", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -61,17 +61,17 @@ fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx,\n                                                             place: &mir::Place<'tcx>) -> bool {\n     let ty = place.ty(mir, tcx).to_ty(tcx);\n     match ty.sty {\n-        ty::TyArray(..) => {\n+        ty::Array(..) => {\n             debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false\",\n                    place, ty);\n             false\n         }\n-        ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n+        ty::Slice(..) | ty::Ref(..) | ty::RawPtr(..) => {\n             debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} refd => true\",\n                    place, ty);\n             true\n         }\n-        ty::TyAdt(def, _) if (def.has_dtor(tcx) && !def.is_box()) || def.is_union() => {\n+        ty::Adt(def, _) if (def.has_dtor(tcx) && !def.is_box()) || def.is_union() => {\n             debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} Drop => true\",\n                    place, ty);\n             true"}, {"sha": "2148363c79712ee7ab17c0ae86c5cfaaef903491", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -134,19 +134,19 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         let tcx = self.builder.tcx;\n         let place_ty = proj.base.ty(mir, tcx).to_ty(tcx);\n         match place_ty.sty {\n-            ty::TyRef(..) | ty::TyRawPtr(..) =>\n+            ty::Ref(..) | ty::RawPtr(..) =>\n                 return Err(MoveError::cannot_move_out_of(\n                     self.loc,\n                     BorrowedContent { target_place: place.clone() })),\n-            ty::TyAdt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n+            ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n                 return Err(MoveError::cannot_move_out_of(self.loc,\n                                                          InteriorOfTypeWithDestructor {\n                     container_ty: place_ty\n                 })),\n             // move out of union - always move the entire union\n-            ty::TyAdt(adt, _) if adt.is_union() =>\n+            ty::Adt(adt, _) if adt.is_union() =>\n                 return Err(MoveError::UnionMove { path: base }),\n-            ty::TySlice(_) =>\n+            ty::Slice(_) =>\n                 return Err(MoveError::cannot_move_out_of(\n                     self.loc,\n                     InteriorOfSliceOrArray {\n@@ -155,7 +155,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                             _ => false\n                         },\n                     })),\n-            ty::TyArray(..) => match proj.elem {\n+            ty::Array(..) => match proj.elem {\n                 ProjectionElem::Index(..) =>\n                     return Err(MoveError::cannot_move_out_of(\n                         self.loc,"}, {"sha": "04a3b5c115f22ae44b96f84abaaef4273cc0ee01", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -284,7 +284,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprKind::AddrOf(mutbl, ref expr) => {\n             let region = match expr_ty.sty {\n-                ty::TyRef(r, _, _) => r,\n+                ty::Ref(r, _, _) => r,\n                 _ => span_bug!(expr.span, \"type of & not region\"),\n             };\n             ExprKind::Borrow {\n@@ -418,7 +418,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprKind::Struct(ref qpath, ref fields, ref base) => {\n             match expr_ty.sty {\n-                ty::TyAdt(adt, substs) => {\n+                ty::Adt(adt, substs) => {\n                     match adt.adt_kind() {\n                         AdtKind::Struct | AdtKind::Union => {\n                             ExprKind::Adt {\n@@ -472,8 +472,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprKind::Closure(..) => {\n             let closure_ty = cx.tables().expr_ty(expr);\n             let (def_id, substs, movability) = match closure_ty.sty {\n-                ty::TyClosure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n-                ty::TyGenerator(def_id, substs, movability) => {\n+                ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n+                ty::Generator(def_id, substs, movability) => {\n                     (def_id, UpvarSubsts::Generator(substs), Some(movability))\n                 }\n                 _ => {\n@@ -775,7 +775,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match cx.tables().node_id_to_type(expr.hir_id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n-                ty::TyAdt(adt_def, substs) => {\n+                ty::Adt(adt_def, substs) => {\n                     ExprKind::Adt {\n                         adt_def,\n                         variant_index: adt_def.variant_index_with_id(def_id),\n@@ -827,7 +827,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             });\n             let region = cx.tcx.mk_region(region);\n \n-            let self_expr = if let ty::TyClosure(_, closure_substs) = closure_ty.sty {\n+            let self_expr = if let ty::Closure(_, closure_substs) = closure_ty.sty {\n                 match cx.infcx.closure_kind(closure_def_id, closure_substs).unwrap() {\n                     ty::ClosureKind::Fn => {\n                         let ref_closure_ty = cx.tcx.mk_ref(region,\n@@ -977,7 +977,7 @@ fn overloaded_place<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // same region and mutability as the receiver. This holds for\n     // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n     let (region, mutbl) = match recv_ty.sty {\n-        ty::TyRef(region, _, mutbl) => (region, mutbl),\n+        ty::Ref(region, _, mutbl) => (region, mutbl),\n         _ => span_bug!(expr.span, \"overloaded_place: receiver is not a reference\"),\n     };\n     let ref_ty = cx.tcx.mk_ref(region, ty::TypeAndMut {"}, {"sha": "750ef71c974c55b569894bf20ecfba2f2ae778d0", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -206,7 +206,7 @@ struct LiteralExpander;\n impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n         match (&pat.ty.sty, &*pat.kind) {\n-            (&ty::TyRef(_, rty, _), &PatternKind::Constant { ref value }) => {\n+            (&ty::Ref(_, rty, _), &PatternKind::Constant { ref value }) => {\n                 Pattern {\n                     ty: pat.ty,\n                     span: pat.span,\n@@ -381,14 +381,14 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n     fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyAdt(adt_def, ..) => adt_def.is_enum() && adt_def.is_non_exhaustive(),\n+            ty::Adt(adt_def, ..) => adt_def.is_enum() && adt_def.is_non_exhaustive(),\n             _ => false,\n         }\n     }\n \n     fn is_local(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyAdt(adt_def, ..) => adt_def.did.is_local(),\n+            ty::Adt(adt_def, ..) => adt_def.did.is_local(),\n             _ => false,\n         }\n     }\n@@ -548,16 +548,16 @@ impl<'tcx> Witness<'tcx> {\n             let mut pats = self.0.drain((len - arity) as usize..).rev();\n \n             match ty.sty {\n-                ty::TyAdt(..) |\n-                ty::TyTuple(..) => {\n+                ty::Adt(..) |\n+                ty::Tuple(..) => {\n                     let pats = pats.enumerate().map(|(i, p)| {\n                         FieldPattern {\n                             field: Field::new(i),\n                             pattern: p\n                         }\n                     }).collect();\n \n-                    if let ty::TyAdt(adt, substs) = ty.sty {\n+                    if let ty::Adt(adt, substs) = ty.sty {\n                         if adt.is_enum() {\n                             PatternKind::Variant {\n                                 adt_def: adt,\n@@ -573,11 +573,11 @@ impl<'tcx> Witness<'tcx> {\n                     }\n                 }\n \n-                ty::TyRef(..) => {\n+                ty::Ref(..) => {\n                     PatternKind::Deref { subpattern: pats.nth(0).unwrap() }\n                 }\n \n-                ty::TySlice(_) | ty::TyArray(..) => {\n+                ty::Slice(_) | ty::Array(..) => {\n                     PatternKind::Slice {\n                         prefix: pats.collect(),\n                         slice: None,\n@@ -624,7 +624,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 ConstantValue(ty::Const::from_bool(cx.tcx, b))\n             }).collect()\n         }\n-        ty::TyArray(ref sub_ty, len) if len.assert_usize(cx.tcx).is_some() => {\n+        ty::Array(ref sub_ty, len) if len.assert_usize(cx.tcx).is_some() => {\n             let len = len.unwrap_usize(cx.tcx);\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n@@ -633,15 +633,15 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n-        ty::TyArray(ref sub_ty, _) |\n-        ty::TySlice(ref sub_ty) => {\n+        ty::Array(ref sub_ty, _) |\n+        ty::Slice(ref sub_ty) => {\n             if cx.is_uninhabited(sub_ty) {\n                 vec![Slice(0)]\n             } else {\n                 (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n             }\n         }\n-        ty::TyAdt(def, substs) if def.is_enum() => {\n+        ty::Adt(def, substs) if def.is_enum() => {\n             def.variants.iter()\n                 .filter(|v| !cx.is_variant_uninhabited(v, substs))\n                 .map(|v| Variant(v.did))\n@@ -1243,7 +1243,7 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt,\n         PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n         PatternKind::Range { lo, hi, end } => Some(vec![ConstantRange(lo, hi, end)]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n-            ty::TyArray(_, length) => Some(vec![\n+            ty::Array(_, length) => Some(vec![\n                 Slice(length.unwrap_usize(cx.tcx))\n             ]),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n@@ -1267,14 +1267,14 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt,\n fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n     debug!(\"constructor_arity({:#?}, {:?})\", ctor, ty);\n     match ty.sty {\n-        ty::TyTuple(ref fs) => fs.len() as u64,\n-        ty::TySlice(..) | ty::TyArray(..) => match *ctor {\n+        ty::Tuple(ref fs) => fs.len() as u64,\n+        ty::Slice(..) | ty::Array(..) => match *ctor {\n             Slice(length) => length,\n             ConstantValue(_) => 0,\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n-        ty::TyRef(..) => 1,\n-        ty::TyAdt(adt, _) => {\n+        ty::Ref(..) => 1,\n+        ty::Adt(adt, _) => {\n             adt.variants[ctor.variant_index_for_adt(adt)].fields.len() as u64\n         }\n         _ => 0\n@@ -1291,14 +1291,14 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n {\n     debug!(\"constructor_sub_pattern_tys({:#?}, {:?})\", ctor, ty);\n     match ty.sty {\n-        ty::TyTuple(ref fs) => fs.into_iter().map(|t| *t).collect(),\n-        ty::TySlice(ty) | ty::TyArray(ty, _) => match *ctor {\n+        ty::Tuple(ref fs) => fs.into_iter().map(|t| *t).collect(),\n+        ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n             Slice(length) => (0..length).map(|_| ty).collect(),\n             ConstantValue(_) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n-        ty::TyRef(_, rty, _) => vec![rty],\n-        ty::TyAdt(adt, substs) => {\n+        ty::Ref(_, rty, _) => vec![rty],\n+        ty::Adt(adt, substs) => {\n             if adt.is_box() {\n                 // Use T as the sub pattern type of Box<T>.\n                 vec![substs.type_at(0)]"}, {"sha": "604cc61a17ecb17073f104a7eb8167793291ddc4", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -258,8 +258,8 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     fn conservative_is_uninhabited(&self, scrutinee_ty: Ty<'tcx>) -> bool {\n         // \"rustc-1.0-style\" uncontentious uninhabitableness check\n         match scrutinee_ty.sty {\n-            ty::TyNever => true,\n-            ty::TyAdt(def, _) => def.variants.is_empty(),\n+            ty::Never => true,\n+            ty::Adt(def, _) => def.variants.is_empty(),\n             _ => false\n         }\n     }\n@@ -315,7 +315,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n                     return true;\n                 }\n                 let pat_ty = cx.tables.pat_ty(p);\n-                if let ty::TyAdt(edef, _) = pat_ty.sty {\n+                if let ty::Adt(edef, _) = pat_ty.sty {\n                     if edef.is_enum() && edef.variants.iter().any(|variant| {\n                         variant.name == ident.name && variant.ctor_kind == CtorKind::Const\n                     }) {"}, {"sha": "ac506989ecfb0091f50f0c9af4712ca7b69c0c8f", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -148,7 +148,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                     PatternKind::Variant { adt_def, variant_index, .. } => {\n                         Some(&adt_def.variants[variant_index])\n                     }\n-                    _ => if let ty::TyAdt(adt, _) = self.ty.sty {\n+                    _ => if let ty::Adt(adt, _) = self.ty.sty {\n                         if !adt.is_enum() {\n                             Some(&adt.variants[0])\n                         } else {\n@@ -165,7 +165,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 if let Some(variant) = variant {\n                     write!(f, \"{}\", variant.name)?;\n \n-                    // Only for TyAdt we can have `S {...}`,\n+                    // Only for Adt we can have `S {...}`,\n                     // which we handle separately here.\n                     if variant.ctor_kind == CtorKind::Fictive {\n                         write!(f, \" {{ \")?;\n@@ -216,8 +216,8 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             }\n             PatternKind::Deref { ref subpattern } => {\n                 match self.ty.sty {\n-                    ty::TyAdt(def, _) if def.is_box() => write!(f, \"box \")?,\n-                    ty::TyRef(_, _, mutbl) => {\n+                    ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n+                    ty::Ref(_, _, mutbl) => {\n                         write!(f, \"&\")?;\n                         if mutbl == hir::MutMutable {\n                             write!(f, \"mut \")?;\n@@ -413,7 +413,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n                 match ty.sty {\n-                    ty::TyRef(_, ty, _) =>\n+                    ty::Ref(_, ty, _) =>\n                         PatternKind::Deref {\n                             subpattern: Pattern {\n                                 ty,\n@@ -422,10 +422,10 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                     pat.span, ty, prefix, slice, suffix))\n                             },\n                         },\n-                    ty::TySlice(..) |\n-                    ty::TyArray(..) =>\n+                    ty::Slice(..) |\n+                    ty::Array(..) =>\n                         self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n-                    ty::TyError => { // Avoid ICE\n+                    ty::Error => { // Avoid ICE\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                     }\n                     ref sty =>\n@@ -438,7 +438,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n                 match ty.sty {\n-                    ty::TyTuple(ref tys) => {\n+                    ty::Tuple(ref tys) => {\n                         let subpatterns =\n                             subpatterns.iter()\n                                        .enumerate_and_adjust(tys.len(), ddpos)\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n                         PatternKind::Leaf { subpatterns: subpatterns }\n                     }\n-                    ty::TyError => { // Avoid ICE (#50577)\n+                    ty::Error => { // Avoid ICE (#50577)\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                     }\n                     ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n@@ -460,8 +460,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             PatKind::Binding(_, id, ident, ref sub) => {\n                 let var_ty = self.tables.node_id_to_type(pat.hir_id);\n                 let region = match var_ty.sty {\n-                    ty::TyRef(r, _, _) => Some(r),\n-                    ty::TyError => { // Avoid ICE\n+                    ty::Ref(r, _, _) => Some(r),\n+                    ty::Error => { // Avoid ICE\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                     }\n                     _ => None,\n@@ -484,7 +484,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 // A ref x pattern is the same node used for x, and as such it has\n                 // x's type, which is &T, where we want T (the type being matched).\n                 if let ty::BindByReference(_) = bm {\n-                    if let ty::TyRef(_, rty, _) = ty.sty {\n+                    if let ty::Ref(_, rty, _) = ty.sty {\n                         ty = rty;\n                     } else {\n                         bug!(\"`ref {}` has wrong type {}\", ident, ty);\n@@ -504,8 +504,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n                 let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 let adt_def = match ty.sty {\n-                    ty::TyAdt(adt_def, _) => adt_def,\n-                    ty::TyError => { // Avoid ICE (#50585)\n+                    ty::Adt(adt_def, _) => adt_def,\n+                    ty::Error => { // Avoid ICE (#50585)\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                     }\n                     _ => span_bug!(pat.span,\n@@ -608,12 +608,12 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             self.flatten_nested_slice_patterns(prefix, slice, suffix);\n \n         match ty.sty {\n-            ty::TySlice(..) => {\n+            ty::Slice(..) => {\n                 // matching a slice or fixed-length array\n                 PatternKind::Slice { prefix: prefix, slice: slice, suffix: suffix }\n             }\n \n-            ty::TyArray(_, len) => {\n+            ty::Array(_, len) => {\n                 // fixed-length array\n                 let len = len.unwrap_usize(self.tcx);\n                 assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n@@ -640,9 +640,9 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.is_enum() {\n                     let substs = match ty.sty {\n-                        ty::TyAdt(_, substs) |\n-                        ty::TyFnDef(_, substs) => substs,\n-                        ty::TyError => {  // Avoid ICE (#50585)\n+                        ty::Adt(_, substs) |\n+                        ty::FnDef(_, substs) => substs,\n+                        ty::Error => {  // Avoid ICE (#50585)\n                             return PatternKind::Wild;\n                         }\n                         _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n@@ -823,20 +823,20 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     value: cv,\n                 }\n             },\n-            ty::TyAdt(adt_def, _) if adt_def.is_union() => {\n+            ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n                 PatternKind::Wild\n             }\n-            ty::TyAdt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n+            ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n                 let msg = format!(\"to use a constant of type `{}` in a pattern, \\\n                                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n                                     self.tcx.item_path_str(adt_def.did),\n                                     self.tcx.item_path_str(adt_def.did));\n                 self.tcx.sess.span_err(span, &msg);\n                 PatternKind::Wild\n             },\n-            ty::TyAdt(adt_def, substs) if adt_def.is_enum() => {\n+            ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                 let variant_index = const_variant_index(\n                     self.tcx, self.param_env, instance, cv\n                 ).expect(\"const_variant_index failed\");\n@@ -851,18 +851,18 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     subpatterns,\n                 }\n             },\n-            ty::TyAdt(adt_def, _) => {\n+            ty::Adt(adt_def, _) => {\n                 let struct_var = adt_def.non_enum_variant();\n                 PatternKind::Leaf {\n                     subpatterns: adt_subpatterns(struct_var.fields.len(), None),\n                 }\n             }\n-            ty::TyTuple(fields) => {\n+            ty::Tuple(fields) => {\n                 PatternKind::Leaf {\n                     subpatterns: adt_subpatterns(fields.len(), None),\n                 }\n             }\n-            ty::TyArray(_, n) => {\n+            ty::Array(_, n) => {\n                 PatternKind::Array {\n                     prefix: (0..n.unwrap_usize(self.tcx))\n                         .map(|i| adt_subpattern(i as usize, None))\n@@ -1094,7 +1094,7 @@ pub fn compare_const_vals<'a, 'tcx>(\n         }\n     }\n \n-    if let ty::TyRef(_, rty, _) = ty.value.sty {\n+    if let ty::Ref(_, rty, _) = ty.value.sty {\n         if let ty::TyStr = rty.sty {\n             match (a.val, b.val) {\n                 (\n@@ -1174,7 +1174,7 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                 ty::TyInt(other) => Int::Signed(other),\n                 ty::TyUint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n                 ty::TyUint(other) => Int::Unsigned(other),\n-                ty::TyError => { // Avoid ICE (#51963)\n+                ty::Error => { // Avoid ICE (#51963)\n                     return Err(LitToConstError::Propagated);\n                 }\n                 _ => bug!(\"literal integer type with bad type ({:?})\", ty.sty),"}, {"sha": "1f6a1e76f001dcef93fadeaca5aa085eb31f9059", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ReifyFnPointer => {\n                 // The src operand does not matter, just its type\n                 match src_layout.ty.sty {\n-                    ty::TyFnDef(def_id, substs) => {\n+                    ty::FnDef(def_id, substs) => {\n                         if self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n                             bug!(\"reifying a fn ptr that requires \\\n                                     const arguments\");\n@@ -101,7 +101,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             UnsafeFnPointer => {\n                 let src = self.read_value(src)?;\n                 match dest.layout.ty.sty {\n-                    ty::TyFnPtr(_) => {\n+                    ty::FnPtr(_) => {\n                         // No change to value\n                         self.write_value(*src, dest)?;\n                     }\n@@ -112,7 +112,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ClosureFnPointer => {\n                 // The src operand does not matter, just its type\n                 match src_layout.ty.sty {\n-                    ty::TyClosure(def_id, substs) => {\n+                    ty::Closure(def_id, substs) => {\n                         let substs = self.tcx.subst_and_normalize_erasing_regions(\n                             self.substs(),\n                             ty::ParamEnv::reveal_all(),\n@@ -217,7 +217,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             },\n \n             // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n-            TyRawPtr(_) => {\n+            RawPtr(_) => {\n                 Ok(Scalar::Bits {\n                     bits: self.memory.truncate_to_ptr(v).0 as u128,\n                     size: self.memory.pointer_size().bytes() as u8,\n@@ -293,7 +293,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         use rustc::ty::TyKind::*;\n         match ty.sty {\n             // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here.\n-            TyRawPtr(_) |\n+            RawPtr(_) |\n             TyInt(IntTy::Isize) |\n             TyUint(UintTy::Usize) => Ok(ptr.into()),\n             TyInt(_) | TyUint(_) => err!(ReadPointerAsBytes),"}, {"sha": "9a6f1199421d6445dc25af9b8909f8b13810dedc", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -457,7 +457,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             let layout = mplace.layout;\n             assert!(layout.is_unsized());\n             match layout.ty.sty {\n-                ty::TyAdt(..) | ty::TyTuple(..) => {\n+                ty::Adt(..) | ty::Tuple(..) => {\n                     // First get the size of all statically known fields.\n                     // Don't use type_of::sizing_type_of because that expects t to be sized,\n                     // and it also rounds up to alignment, which we want to avoid,\n@@ -506,7 +506,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                     Ok((size.abi_align(align), align))\n                 }\n-                ty::TyDynamic(..) => {\n+                ty::Dynamic(..) => {\n                     let vtable = match mplace.extra {\n                         PlaceExtra::Vtable(vtable) => vtable,\n                         _ => bug!(\"Expected vtable\"),\n@@ -515,7 +515,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     self.read_size_and_align_from_vtable(vtable)\n                 }\n \n-                ty::TySlice(_) | ty::TyStr => {\n+                ty::Slice(_) | ty::Str => {\n                     let len = match mplace.extra {\n                         PlaceExtra::Length(len) => len,\n                         _ => bug!(\"Expected length\"),"}, {"sha": "0bddd7147b9986609c5173516944018c116034e6", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -20,7 +20,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let place = self.force_allocation(place)?;\n \n         let (instance, place) = match place.layout.ty.sty {\n-            ty::TyDynamic(..) => {\n+            ty::Dynamic(..) => {\n                 // Dropping a trait object.\n                 let vtable = match place.extra {\n                     PlaceExtra::Vtable(vtable) => vtable,"}, {"sha": "913b88fc8eb48acccc34a88d3b3043a5be7dd9aa", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -72,12 +72,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n                 let func = self.eval_operand(func, None)?;\n                 let (fn_def, sig) = match func.layout.ty.sty {\n-                    ty::TyFnPtr(sig) => {\n+                    ty::FnPtr(sig) => {\n                         let fn_ptr = self.read_scalar(func)?.to_ptr()?;\n                         let instance = self.memory.get_fn(fn_ptr)?;\n                         let instance_ty = instance.ty(*self.tcx);\n                         match instance_ty.sty {\n-                            ty::TyFnDef(..) => {\n+                            ty::FnDef(..) => {\n                                 let real_sig = instance_ty.fn_sig(*self.tcx);\n                                 let sig = self.tcx.normalize_erasing_late_bound_regions(\n                                     ty::ParamEnv::reveal_all(),\n@@ -95,7 +95,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         }\n                         (instance, sig)\n                     }\n-                    ty::TyFnDef(def_id, substs) => (\n+                    ty::FnDef(def_id, substs) => (\n                         self.resolve(def_id, substs)?,\n                         func.layout.ty.fn_sig(*self.tcx),\n                     ),\n@@ -198,8 +198,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // Permit changing the pointer type of raw pointers and references as well as\n                 // mutability of raw pointers.\n                 // TODO: Should not be allowed when fat pointers are involved.\n-                (&ty::TyRawPtr(_), &ty::TyRawPtr(_)) => true,\n-                (&ty::TyRef(_, _, _), &ty::TyRef(_, _, _)) => {\n+                (&ty::RawPtr(_), &ty::RawPtr(_)) => true,\n+                (&ty::Ref(_, _, _), &ty::Ref(_, _, _)) => {\n                     ty.is_mutable_pointer() == real_ty.is_mutable_pointer()\n                 }\n                 // rule out everything else\n@@ -233,7 +233,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     // Second argument must be a tuple matching the argument list of sig\n                     let snd_ty = real_sig.inputs_and_output[1];\n                     match snd_ty.sty {\n-                        ty::TyTuple(tys) if sig.inputs().len() == tys.len() =>\n+                        ty::Tuple(tys) if sig.inputs().len() == tys.len() =>\n                             if sig.inputs().iter().zip(tys).all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n                                 return Ok(true)\n                             },\n@@ -339,7 +339,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n                         // unpack and write all other args\n                         let layout = args[1].layout;\n-                        if let ty::TyTuple(_) = layout.ty.sty {\n+                        if let ty::Tuple(_) = layout.ty.sty {\n                             if layout.is_zst() {\n                                 // Nothing to do, no need to unpack zsts\n                                 return Ok(());"}, {"sha": "8cf2868d12a3ff24864fed17fcb6bf47c6d84e78", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -571,7 +571,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     &source_ty,\n                 );\n                 match source_ty.sty {\n-                    ty::TyClosure(def_id, substs) => {\n+                    ty::Closure(def_id, substs) => {\n                         let instance = monomorphize::resolve_closure(\n                             self.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n                         if should_monomorphize_locally(self.tcx, &instance) {\n@@ -680,7 +680,7 @@ fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           is_direct_call: bool,\n                           output: &mut Vec<MonoItem<'tcx>>)\n {\n-    if let ty::TyFnDef(def_id, substs) = ty.sty {\n+    if let ty::FnDef(def_id, substs) = ty.sty {\n         let instance = ty::Instance::resolve(tcx,\n                                              ty::ParamEnv::reveal_all(),\n                                              def_id,\n@@ -839,7 +839,7 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let tail = tcx.struct_tail(ty);\n             match tail.sty {\n                 ty::TyForeign(..) => false,\n-                ty::TyStr | ty::TySlice(..) | ty::TyDynamic(..) => true,\n+                ty::TyStr | ty::Slice(..) | ty::Dynamic(..) => true,\n                 _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n             }\n         };\n@@ -851,20 +851,20 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     match (&source_ty.sty, &target_ty.sty) {\n-        (&ty::TyRef(_, a, _),\n-         &ty::TyRef(_, b, _)) |\n-        (&ty::TyRef(_, a, _),\n-         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n-         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+        (&ty::Ref(_, a, _),\n+         &ty::Ref(_, b, _)) |\n+        (&ty::Ref(_, a, _),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             ptr_vtable(a, b)\n         }\n-        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             ptr_vtable(source_ty.boxed_ty(), target_ty.boxed_ty())\n         }\n \n-        (&ty::TyAdt(source_adt_def, source_substs),\n-         &ty::TyAdt(target_adt_def, target_substs)) => {\n+        (&ty::Adt(source_adt_def, source_substs),\n+         &ty::Adt(target_adt_def, target_substs)) => {\n             assert_eq!(source_adt_def, target_adt_def);\n \n             let kind =\n@@ -906,7 +906,7 @@ fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_regions() &&\n             !impl_ty.needs_subst() && !impl_ty.has_escaping_regions());\n \n-    if let ty::TyDynamic(ref trait_ty, ..) = trait_ty.sty {\n+    if let ty::Dynamic(ref trait_ty, ..) = trait_ty.sty {\n         if let Some(principal) = trait_ty.principal() {\n             let poly_trait_ref = principal.with_self_ty(tcx, impl_ty);\n             assert!(!poly_trait_ref.has_escaping_regions());"}, {"sha": "da19f03304bca7595a30481a685cd65145067b8f", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::TyBool              => output.push_str(\"bool\"),\n             ty::TyChar              => output.push_str(\"char\"),\n             ty::TyStr               => output.push_str(\"str\"),\n-            ty::TyNever             => output.push_str(\"!\"),\n+            ty::Never             => output.push_str(\"!\"),\n             ty::TyInt(ast::IntTy::Isize)    => output.push_str(\"isize\"),\n             ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n             ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n@@ -275,11 +275,11 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::TyUint(ast::UintTy::U128)  => output.push_str(\"u128\"),\n             ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n             ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n-            ty::TyAdt(adt_def, substs) => {\n+            ty::Adt(adt_def, substs) => {\n                 self.push_def_path(adt_def.did, output);\n                 self.push_type_params(substs, iter::empty(), output);\n             },\n-            ty::TyTuple(component_types) => {\n+            ty::Tuple(component_types) => {\n                 output.push('(');\n                 for &component_type in component_types {\n                     self.push_type_name(component_type, output);\n@@ -291,7 +291,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 }\n                 output.push(')');\n             },\n-            ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n                 output.push('*');\n                 match mutbl {\n                     hir::MutImmutable => output.push_str(\"const \"),\n@@ -300,26 +300,26 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n                 self.push_type_name(inner_type, output);\n             },\n-            ty::TyRef(_, inner_type, mutbl) => {\n+            ty::Ref(_, inner_type, mutbl) => {\n                 output.push('&');\n                 if mutbl == hir::MutMutable {\n                     output.push_str(\"mut \");\n                 }\n \n                 self.push_type_name(inner_type, output);\n             },\n-            ty::TyArray(inner_type, len) => {\n+            ty::Array(inner_type, len) => {\n                 output.push('[');\n                 self.push_type_name(inner_type, output);\n                 write!(output, \"; {}\", len.unwrap_usize(self.tcx)).unwrap();\n                 output.push(']');\n             },\n-            ty::TySlice(inner_type) => {\n+            ty::Slice(inner_type) => {\n                 output.push('[');\n                 self.push_type_name(inner_type, output);\n                 output.push(']');\n             },\n-            ty::TyDynamic(ref trait_data, ..) => {\n+            ty::Dynamic(ref trait_data, ..) => {\n                 if let Some(principal) = trait_data.principal() {\n                     self.push_def_path(principal.def_id(), output);\n                     self.push_type_params(principal.skip_binder().substs,\n@@ -328,8 +328,8 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 }\n             },\n             ty::TyForeign(did) => self.push_def_path(did, output),\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) => {\n+            ty::FnDef(..) |\n+            ty::FnPtr(_) => {\n                 let sig = t.fn_sig(self.tcx);\n                 if sig.unsafety() == hir::Unsafety::Unsafe {\n                     output.push_str(\"unsafe \");\n@@ -373,19 +373,19 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                     self.push_type_name(sig.output(), output);\n                 }\n             },\n-            ty::TyGenerator(def_id, GeneratorSubsts { ref substs }, _) |\n-            ty::TyClosure(def_id, ClosureSubsts { ref substs }) => {\n+            ty::Generator(def_id, GeneratorSubsts { ref substs }, _) |\n+            ty::Closure(def_id, ClosureSubsts { ref substs }) => {\n                 self.push_def_path(def_id, output);\n                 let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));\n                 let substs = substs.truncate_to(self.tcx, generics);\n                 self.push_type_params(substs, iter::empty(), output);\n             }\n-            ty::TyError |\n-            ty::TyInfer(_) |\n-            ty::TyProjection(..) |\n+            ty::Error |\n+            ty::Infer(_) |\n+            ty::Projection(..) |\n             ty::TyParam(_) |\n-            ty::TyGeneratorWitness(_) |\n-            ty::TyAnon(..) => {\n+            ty::GeneratorWitness(_) |\n+            ty::Anon(..) => {\n                 bug!(\"DefPathBasedNames: Trying to create type name for \\\n                                          unexpected type: {:?}\", t);\n             }"}, {"sha": "765a47e729e6834aa5e245a9b5bb5fc4adb6728f", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -165,7 +165,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n     // Check if this is a generator, if so, return the drop glue for it\n-    if let Some(&ty::TyS { sty: ty::TyGenerator(gen_def_id, substs, _), .. }) = ty {\n+    if let Some(&ty::TyS { sty: ty::Generator(gen_def_id, substs, _), .. }) = ty {\n         let mir = &**tcx.optimized_mir(gen_def_id).generator_drop.as_ref().unwrap();\n         return mir.subst(tcx, substs.substs);\n     }\n@@ -301,17 +301,17 @@ fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n-        ty::TyArray(ty, len) => {\n+        ty::Array(ty, len) => {\n             let len = len.unwrap_usize(tcx);\n             builder.array_shim(dest, src, ty, len)\n         }\n-        ty::TyClosure(def_id, substs) => {\n+        ty::Closure(def_id, substs) => {\n             builder.tuple_like_shim(\n                 dest, src,\n                 substs.upvar_tys(def_id, tcx)\n             )\n         }\n-        ty::TyTuple(tys) => builder.tuple_like_shim(dest, src, tys.iter().cloned()),\n+        ty::Tuple(tys) => builder.tuple_like_shim(dest, src, tys.iter().cloned()),\n         _ => {\n             bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty)\n         }\n@@ -821,7 +821,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n     let sig = gcx.normalize_erasing_regions(param_env, sig);\n \n     let (adt_def, substs) = match sig.output().sty {\n-        ty::TyAdt(adt_def, substs) => (adt_def, substs),\n+        ty::Adt(adt_def, substs) => (adt_def, substs),\n         _ => bug!(\"unexpected type for ADT ctor {:?}\", sig.output())\n     };\n "}, {"sha": "9061b34ae4445a49e47b935e45e0c1ca0a78de90", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -45,7 +45,7 @@ fn place_context<'a, 'tcx, D>(\n                     // A Deref projection may restrict the context, this depends on the type\n                     // being deref'd.\n                     let context = match ty.sty {\n-                        ty::TyRef(re, _, mutbl) => {\n+                        ty::Ref(re, _, mutbl) => {\n                             let re = match re {\n                                 &RegionKind::ReScope(ce) => Some(ce),\n                                 &RegionKind::ReErased =>\n@@ -54,12 +54,12 @@ fn place_context<'a, 'tcx, D>(\n                             };\n                             (re, mutbl)\n                         }\n-                        ty::TyRawPtr(_) =>\n+                        ty::RawPtr(_) =>\n                             // There is no guarantee behind even a mutable raw pointer,\n                             // no write locks are acquired there, so we also don't want to\n                             // release any.\n                             (None, hir::MutImmutable),\n-                        ty::TyAdt(adt, _) if adt.is_box() => (None, hir::MutMutable),\n+                        ty::Adt(adt, _) if adt.is_box() => (None, hir::MutMutable),\n                         _ => bug!(\"Deref on a non-pointer type {:?}\", ty),\n                     };\n                     // \"Intersect\" this restriction with proj.base."}, {"sha": "5d284981c70afda49338ac299f872c3e2feeb832", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -179,13 +179,13 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n                 let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n                 match base_ty.sty {\n-                    ty::TyRawPtr(..) => {\n+                    ty::RawPtr(..) => {\n                         self.require_unsafe(\"dereference of raw pointer\",\n                             \"raw pointers may be NULL, dangling or unaligned; they can violate \\\n                              aliasing rules and cause data races: all of these are undefined \\\n                              behavior\")\n                     }\n-                    ty::TyAdt(adt, _) => {\n+                    ty::Adt(adt, _) => {\n                         if adt.is_union() {\n                             if context == PlaceContext::Store ||\n                                 context == PlaceContext::AsmOutput ||"}, {"sha": "4a9b6b7f6e833930e877db7f2add4148f1e9b48a", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -493,7 +493,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // MIR types\n     let allowed_upvars = tcx.erase_regions(&upvars);\n     let allowed = match interior.sty {\n-        ty::TyGeneratorWitness(s) => tcx.erase_late_bound_regions(&s),\n+        ty::GeneratorWitness(s) => tcx.erase_late_bound_regions(&s),\n         _ => bug!(),\n     };\n \n@@ -863,7 +863,7 @@ impl MirPass for StateTransform {\n \n         // Get the interior types and substs which typeck computed\n         let (upvars, interior, movable) = match gen_ty.sty {\n-            ty::TyGenerator(_, substs, movability) => {\n+            ty::Generator(_, substs, movability) => {\n                 (substs.upvar_tys(def_id, tcx).collect(),\n                  substs.witness(def_id, tcx),\n                  movability == hir::GeneratorMovability::Movable)"}, {"sha": "31e437ce2281acb9b1dc6556f8b336cca8374091", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 let terminator = bb_data.terminator();\n                 if let TerminatorKind::Call {\n                     func: Operand::Constant(ref f), .. } = terminator.kind {\n-                        if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n+                        if let ty::FnDef(callee_def_id, substs) = f.ty.sty {\n                             if let Some(instance) = Instance::resolve(self.tcx,\n                                                                       param_env,\n                                                                       callee_def_id,\n@@ -158,7 +158,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     let terminator = bb_data.terminator();\n                     if let TerminatorKind::Call {\n                         func: Operand::Constant(ref f), .. } = terminator.kind {\n-                        if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n+                        if let ty::FnDef(callee_def_id, substs) = f.ty.sty {\n                             // Don't inline the same function multiple times.\n                             if callsite.callee != callee_def_id {\n                                 callsites.push_back(CallSite {\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 }\n \n                 TerminatorKind::Call {func: Operand::Constant(ref f), .. } => {\n-                    if let ty::TyFnDef(def_id, _) = f.ty.sty {\n+                    if let ty::FnDef(def_id, _) = f.ty.sty {\n                         // Don't give intrinsics the extra penalty for calls\n                         let f = tcx.fn_sig(def_id);\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n@@ -538,7 +538,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             assert!(args.next().is_none());\n \n             let tuple = Place::Local(tuple);\n-            let tuple_tys = if let ty::TyTuple(s) = tuple.ty(caller_mir, tcx).to_ty(tcx).sty {\n+            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_mir, tcx).to_ty(tcx).sty {\n                 s\n             } else {\n                 bug!(\"Closure arguments are not passed as a tuple\");"}, {"sha": "4cf4a8f23a443f63ddd85d37b229683cb0ba82dc", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -100,7 +100,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n \n         if let Rvalue::Len(ref place) = *rvalue {\n             let place_ty = place.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n-            if let TyKind::TyArray(_, len) = place_ty.sty {\n+            if let TyKind::Array(_, len) = place_ty.sty {\n                 let span = self.mir.source_info(location).span;\n                 let ty = self.tcx.types.usize;\n                 let constant = Constant { span, ty, literal: len };"}, {"sha": "a56399eecd38ef057c2273bf2a5b357a52077c3c", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -495,7 +495,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                 this.add(Qualif::NOT_CONST);\n                             } else {\n                                 let base_ty = proj.base.ty(this.mir, this.tcx).to_ty(this.tcx);\n-                                if let ty::TyRawPtr(_) = base_ty.sty {\n+                                if let ty::RawPtr(_) = base_ty.sty {\n                                     if !this.tcx.sess.features_untracked().const_raw_ptr_deref {\n                                         emit_feature_err(\n                                             &this.tcx.sess.parse_sess, \"const_raw_ptr_deref\",\n@@ -591,7 +591,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             if let Place::Projection(ref proj) = *place {\n                 if let ProjectionElem::Deref = proj.elem {\n                     let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                    if let ty::TyRef(..) = base_ty.sty {\n+                    if let ty::Ref(..) = base_ty.sty {\n                         is_reborrow = true;\n                     }\n                 }\n@@ -638,10 +638,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     if self.mode == Mode::StaticMut {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n                         match ty.sty {\n-                            ty::TyArray(..) | ty::TySlice(_) => forbidden_mut = false,\n+                            ty::Array(..) | ty::Slice(_) => forbidden_mut = false,\n                             _ => {}\n                         }\n-                    } else if let ty::TyArray(_, len) = ty.sty {\n+                    } else if let ty::Array(_, len) = ty.sty {\n                         // FIXME(eddyb) the `self.mode == Mode::Fn` condition\n                         // seems unnecessary, given that this is merely a ZST.\n                         if len.unwrap_usize(self.tcx) == 0 && self.mode == Mode::Fn {\n@@ -745,7 +745,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::TyRawPtr(_) = lhs.ty(self.mir, self.tcx).sty {\n+                if let ty::RawPtr(_) = lhs.ty(self.mir, self.tcx).sty {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -809,7 +809,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             let fn_ty = func.ty(self.mir, self.tcx);\n             let mut callee_def_id = None;\n             let (mut is_shuffle, mut is_const_fn) = (false, None);\n-            if let ty::TyFnDef(def_id, _) = fn_ty.sty {\n+            if let ty::FnDef(def_id, _) = fn_ty.sty {\n                 callee_def_id = Some(def_id);\n                 match self.tcx.fn_sig(def_id).abi() {\n                     Abi::RustIntrinsic |"}, {"sha": "2147cc2a41a078f70065f9ea023c2aa649ceec96", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -229,7 +229,7 @@ fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n         if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n             if let mir::Operand::Constant(ref func) = *oper {\n-                if let ty::TyFnDef(def_id, _) = func.ty.sty {\n+                if let ty::FnDef(def_id, _) = func.ty.sty {\n                     let abi = tcx.fn_sig(def_id).abi();\n                     let name = tcx.item_name(def_id);\n                     if abi == Abi::RustIntrinsic &&  name == \"rustc_peek\" {"}, {"sha": "78464b2a104ec301501e6d14d7f482ec8c47b619", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     // no need to transformation\n                 } else {\n                     let place_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                    if let ty::TyArray(item_ty, const_size) = place_ty.sty {\n+                    if let ty::Array(item_ty, const_size) = place_ty.sty {\n                         if let Some(size) = const_size.assert_usize(self.tcx) {\n                             assert!(size <= u32::max_value() as u64,\n                                     \"uniform array move out doesn't supported\n@@ -202,7 +202,7 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n                         let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n                         let opt_size = opt_src_place.and_then(|src_place| {\n                             let src_ty = src_place.ty(mir, tcx).to_ty(tcx);\n-                            if let ty::TyArray(_, ref size_o) = src_ty.sty {\n+                            if let ty::Array(_, ref size_o) = src_ty.sty {\n                                 size_o.assert_usize(tcx)\n                             } else {\n                                 None"}, {"sha": "8717bd08ae4a5ba90c39340e3ecdf61649e4e687", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -59,7 +59,7 @@ fn is_within_packed<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ProjectionElem::Field(..) => {\n                 let ty = base.ty(local_decls, tcx).to_ty(tcx);\n                 match ty.sty {\n-                    ty::TyAdt(def, _) if def.repr.packed() => {\n+                    ty::Adt(def, _) if def.repr.packed() => {\n                         return true\n                     }\n                     _ => {}"}, {"sha": "1c5e1e406911a9063a21a26c0b538dfe034b2e51", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -425,8 +425,8 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         o: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let type_name = match (&ty.sty, is_index) {\n-            (&ty::TyArray(_, _), Some(true)) | (&ty::TyArray(_, _), None) => \"array\",\n-            (&ty::TySlice(_), _) => \"slice\",\n+            (&ty::Array(_, _), Some(true)) | (&ty::Array(_, _), None) => \"array\",\n+            (&ty::Slice(_), _) => \"slice\",\n             _ => span_bug!(move_from_span, \"this path should not cause illegal move\"),\n         };\n         let mut err = struct_span_err!("}, {"sha": "33e0554715f804fb5f83c33cc3a0e9b408fa5b07", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -780,7 +780,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     fn open_drop<'a>(&mut self) -> BasicBlock {\n         let ty = self.place_ty(self.place);\n         match ty.sty {\n-            ty::TyClosure(def_id, substs) => {\n+            ty::Closure(def_id, substs) => {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n                 self.open_drop_for_tuple(&tys)\n             }\n@@ -790,30 +790,30 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             // This should only happen for the self argument on the resume function.\n             // It effetively only contains upvars until the generator transformation runs.\n             // See librustc_mir/transform/generator.rs for more details.\n-            ty::TyGenerator(def_id, substs, _) => {\n+            ty::Generator(def_id, substs, _) => {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n                 self.open_drop_for_tuple(&tys)\n             }\n-            ty::TyTuple(tys) => {\n+            ty::Tuple(tys) => {\n                 self.open_drop_for_tuple(tys)\n             }\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 if def.is_box() {\n                     self.open_drop_for_box(def, substs)\n                 } else {\n                     self.open_drop_for_adt(def, substs)\n                 }\n             }\n-            ty::TyDynamic(..) => {\n+            ty::Dynamic(..) => {\n                 let unwind = self.unwind; // FIXME(#43234)\n                 let succ = self.succ;\n                 self.complete_drop(Some(DropFlagMode::Deep), succ, unwind)\n             }\n-            ty::TyArray(ety, size) => {\n+            ty::Array(ety, size) => {\n                 let size = size.assert_usize(self.tcx());\n                 self.open_drop_for_array(ety, size)\n             },\n-            ty::TySlice(ety) => self.open_drop_for_array(ety, None),\n+            ty::Slice(ety) => self.open_drop_for_array(ety, None),\n \n             _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n         }"}, {"sha": "fca1c7f27ab37a590274385579ca5b7cf94a2efe", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -328,7 +328,7 @@ fn check_expr_kind<'a, 'tcx>(\n     e: &'tcx hir::Expr, node_ty: Ty<'tcx>) -> Promotability {\n \n     let ty_result = match node_ty.sty {\n-        ty::TyAdt(def, _) if def.has_dtor(v.tcx) => {\n+        ty::Adt(def, _) if def.has_dtor(v.tcx) => {\n             NotPromotable\n         }\n         _ => Promotable\n@@ -356,7 +356,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 return NotPromotable;\n             }\n             match v.tables.node_id_to_type(lhs.hir_id).sty {\n-                ty::TyRawPtr(_) => {\n+                ty::RawPtr(_) => {\n                     assert!(op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne ||\n                         op.node == hir::BinOpKind::Le || op.node == hir::BinOpKind::Lt ||\n                         op.node == hir::BinOpKind::Ge || op.node == hir::BinOpKind::Gt);\n@@ -494,7 +494,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 Some(ref expr) => { struct_result = struct_result & v.check_expr(&expr); },\n                 None => {},\n             }\n-            if let ty::TyAdt(adt, ..) = v.tables.expr_ty(e).sty {\n+            if let ty::Adt(adt, ..) = v.tables.expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items().unsafe_cell_type() {\n                     return NotPromotable;"}, {"sha": "3c2869af54f401bf5a4818c9b5428f11731842da", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -89,11 +89,11 @@ struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn item_ty_level(&self, item_def_id: DefId) -> Option<AccessLevel> {\n         let ty_def_id = match self.tcx.type_of(item_def_id).sty {\n-            ty::TyAdt(adt, _) => adt.did,\n+            ty::Adt(adt, _) => adt.did,\n             ty::TyForeign(did) => did,\n-            ty::TyDynamic(ref obj, ..) if obj.principal().is_some() =>\n+            ty::Dynamic(ref obj, ..) if obj.principal().is_some() =>\n                 obj.principal().unwrap().def_id(),\n-            ty::TyProjection(ref proj) => proj.trait_ref(self.tcx).def_id,\n+            ty::Projection(ref proj) => proj.trait_ref(self.tcx).def_id,\n             _ => return Some(AccessLevel::Public)\n         };\n         if let Some(node_id) = self.tcx.hir.as_local_node_id(ty_def_id) {\n@@ -443,7 +443,7 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     fn ty(&mut self) -> &mut Self {\n         let ty = self.ev.tcx.type_of(self.item_def_id);\n         ty.visit_with(self);\n-        if let ty::TyFnDef(def_id, _) = ty.sty {\n+        if let ty::FnDef(def_id, _) = ty.sty {\n             if def_id == self.item_def_id {\n                 self.ev.tcx.fn_sig(def_id).visit_with(self);\n             }\n@@ -470,14 +470,14 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty_def_id = match ty.sty {\n-            ty::TyAdt(adt, _) => Some(adt.did),\n+            ty::Adt(adt, _) => Some(adt.did),\n             ty::TyForeign(did) => Some(did),\n-            ty::TyDynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n-            ty::TyProjection(ref proj) => Some(proj.item_def_id),\n-            ty::TyFnDef(def_id, ..) |\n-            ty::TyClosure(def_id, ..) |\n-            ty::TyGenerator(def_id, ..) |\n-            ty::TyAnon(def_id, _) => Some(def_id),\n+            ty::Dynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n+            ty::Projection(ref proj) => Some(proj.item_def_id),\n+            ty::FnDef(def_id, ..) |\n+            ty::Closure(def_id, ..) |\n+            ty::Generator(def_id, ..) |\n+            ty::Anon(def_id, _) => Some(def_id),\n             _ => None\n         };\n \n@@ -896,15 +896,15 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyAdt(&ty::AdtDef { did: def_id, .. }, ..) |\n-            ty::TyFnDef(def_id, ..) |\n+            ty::Adt(&ty::AdtDef { did: def_id, .. }, ..) |\n+            ty::FnDef(def_id, ..) |\n             ty::TyForeign(def_id) => {\n                 if !self.item_is_accessible(def_id) {\n                     let msg = format!(\"type `{}` is private\", ty);\n                     self.tcx.sess.span_err(self.span, &msg);\n                     return true;\n                 }\n-                if let ty::TyFnDef(..) = ty.sty {\n+                if let ty::FnDef(..) = ty.sty {\n                     if self.tcx.fn_sig(def_id).visit_with(self) {\n                         return true;\n                     }\n@@ -919,7 +919,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            ty::TyDynamic(ref predicates, ..) => {\n+            ty::Dynamic(ref predicates, ..) => {\n                 let is_private = predicates.skip_binder().iter().any(|predicate| {\n                     let def_id = match *predicate {\n                         ty::ExistentialPredicate::Trait(trait_ref) => trait_ref.def_id,\n@@ -935,13 +935,13 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                     return true;\n                 }\n             }\n-            ty::TyProjection(ref proj) => {\n+            ty::Projection(ref proj) => {\n                 let tcx = self.tcx;\n                 if self.check_trait_ref(proj.trait_ref(tcx)) {\n                     return true;\n                 }\n             }\n-            ty::TyAnon(def_id, ..) => {\n+            ty::Anon(def_id, ..) => {\n                 for predicate in &self.tcx.predicates_of(def_id).predicates {\n                     let trait_ref = match *predicate {\n                         ty::Predicate::Trait(ref poly_trait_predicate) => {\n@@ -964,9 +964,9 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                             return true;\n                         }\n                         for subst in trait_ref.substs.iter() {\n-                            // Skip repeated `TyAnon`s to avoid infinite recursion.\n+                            // Skip repeated `Anon`s to avoid infinite recursion.\n                             if let UnpackedKind::Type(ty) = subst.unpack() {\n-                                if let ty::TyAnon(def_id, ..) = ty.sty {\n+                                if let ty::Anon(def_id, ..) = ty.sty {\n                                     if !self.visited_anon_tys.insert(def_id) {\n                                         continue;\n                                     }\n@@ -1388,7 +1388,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn ty(&mut self) -> &mut Self {\n         let ty = self.tcx.type_of(self.item_def_id);\n         ty.visit_with(self);\n-        if let ty::TyFnDef(def_id, _) = ty.sty {\n+        if let ty::FnDef(def_id, _) = ty.sty {\n             if def_id == self.item_def_id {\n                 self.tcx.fn_sig(def_id).visit_with(self);\n             }\n@@ -1434,10 +1434,10 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty_def_id = match ty.sty {\n-            ty::TyAdt(adt, _) => Some(adt.did),\n+            ty::Adt(adt, _) => Some(adt.did),\n             ty::TyForeign(did) => Some(did),\n-            ty::TyDynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n-            ty::TyProjection(ref proj) => {\n+            ty::Dynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n+            ty::Projection(ref proj) => {\n                 if self.required_visibility == ty::Visibility::Invisible {\n                     // Conservatively approximate the whole type alias as public without\n                     // recursing into its components when determining impl publicity."}, {"sha": "298f95496666a7a1e48db447be3d912721ebb487", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -534,7 +534,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         let hir_node = self.tcx.hir.expect_expr(expr.id);\n         let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n-        if ty.is_none() || ty.unwrap().sty == ty::TyError {\n+        if ty.is_none() || ty.unwrap().sty == ty::Error {\n             return None;\n         }\n         match expr.node {\n@@ -551,7 +551,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 };\n                 match self.tables.expr_ty_adjusted(&hir_node).sty {\n-                    ty::TyAdt(def, _) if !def.is_enum() => {\n+                    ty::Adt(def, _) if !def.is_enum() => {\n                         let variant = &def.non_enum_variant();\n                         let index = self.tcx.find_field_index(ident, variant).unwrap();\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n@@ -563,7 +563,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             ref_id: id_from_def_id(variant.fields[index].did),\n                         }));\n                     }\n-                    ty::TyTuple(..) => None,\n+                    ty::Tuple(..) => None,\n                     _ => {\n                         debug!(\"Expected struct or union type, found {:?}\", ty);\n                         None\n@@ -572,7 +572,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ExprKind::Struct(ref path, ..) => {\n                 match self.tables.expr_ty_adjusted(&hir_node).sty {\n-                    ty::TyAdt(def, _) if !def.is_enum() => {\n+                    ty::Adt(def, _) if !def.is_enum() => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);\n                         let span = self.span_from_span(sub_span.unwrap());\n@@ -674,7 +674,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     hir::QPath::Resolved(_, ref path) => path.def,\n                     hir::QPath::TypeRelative(..) => {\n                         let ty = hir_ty_to_ty(self.tcx, ty);\n-                        if let ty::TyProjection(proj) = ty.sty {\n+                        if let ty::Projection(proj) = ty.sty {\n                             return HirDef::AssociatedTy(proj.item_def_id);\n                         }\n                         HirDef::Err"}, {"sha": "4227144e204fbbf9bf7eef356830de21dd9e8c06", "filename": "src/librustc_traits/chalk_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -237,7 +237,7 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n //                    _ => false,\n //                },\n //                Kind::Type(ty) => match ty.sty {\n-//                    ty::TyInfer(ty::InferTy::CanonicalTy(cvar1)) => cvar == cvar1,\n+//                    ty::Infer(ty::InferTy::CanonicalTy(cvar1)) => cvar == cvar1,\n //                    _ => false,\n //                },\n //            })"}, {"sha": "005d56a15086349b71c14a32eac3dc9055b139d2", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -123,7 +123,7 @@ fn dropck_outlives<'tcx>(\n \n                             // A projection that we couldn't resolve - it\n                             // might have a destructor.\n-                            ty::TyProjection(..) | ty::TyAnon(..) => {\n+                            ty::Projection(..) | ty::Anon(..) => {\n                                 result.kinds.push(ty.into());\n                             }\n \n@@ -179,33 +179,33 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n         | ty::TyUint(_)\n         | ty::TyFloat(_)\n         | ty::TyStr\n-        | ty::TyNever\n+        | ty::Never\n         | ty::TyForeign(..)\n-        | ty::TyRawPtr(..)\n-        | ty::TyRef(..)\n-        | ty::TyFnDef(..)\n-        | ty::TyFnPtr(_)\n-        | ty::TyGeneratorWitness(..) => {\n+        | ty::RawPtr(..)\n+        | ty::Ref(..)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::GeneratorWitness(..) => {\n             // these types never have a destructor\n             Ok(DtorckConstraint::empty())\n         }\n \n-        ty::TyArray(ety, _) | ty::TySlice(ety) => {\n+        ty::Array(ety, _) | ty::Slice(ety) => {\n             // single-element containers, behave like their element\n             dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ety)\n         }\n \n-        ty::TyTuple(tys) => tys\n+        ty::Tuple(tys) => tys\n             .iter()\n             .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n             .collect(),\n \n-        ty::TyClosure(def_id, substs) => substs\n+        ty::Closure(def_id, substs) => substs\n             .upvar_tys(def_id, tcx)\n             .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n             .collect(),\n \n-        ty::TyGenerator(def_id, substs, _movability) => {\n+        ty::Generator(def_id, substs, _movability) => {\n             // rust-lang/rust#49918: types can be constructed, stored\n             // in the interior, and sit idle when generator yields\n             // (and is subsequently dropped).\n@@ -216,7 +216,7 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n             // its interior).\n             //\n             // However, the interior's representation uses things like\n-            // TyGeneratorWitness that explicitly assume they are not\n+            // GeneratorWitness that explicitly assume they are not\n             // traversed in such a manner. So instead, we will\n             // simplify things for now by treating all generators as\n             // if they were like trait objects, where its upvars must\n@@ -242,7 +242,7 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n             Ok(constraint)\n         }\n \n-        ty::TyAdt(def, substs) => {\n+        ty::Adt(def, substs) => {\n             let DtorckConstraint {\n                 dtorck_types,\n                 outlives,\n@@ -259,20 +259,20 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n \n         // Objects must be alive in order for their destructor\n         // to be called.\n-        ty::TyDynamic(..) => Ok(DtorckConstraint {\n+        ty::Dynamic(..) => Ok(DtorckConstraint {\n             outlives: vec![ty.into()],\n             dtorck_types: vec![],\n             overflows: vec![],\n         }),\n \n         // Types that can't be resolved. Pass them forward.\n-        ty::TyProjection(..) | ty::TyAnon(..) | ty::TyParam(..) => Ok(DtorckConstraint {\n+        ty::Projection(..) | ty::Anon(..) | ty::TyParam(..) => Ok(DtorckConstraint {\n             outlives: vec![],\n             dtorck_types: vec![ty],\n             overflows: vec![],\n         }),\n \n-        ty::TyInfer(..) | ty::TyError => {\n+        ty::Infer(..) | ty::Error => {\n             // By the time this code runs, all type variables ought to\n             // be fully resolved.\n             Err(NoSolution)"}, {"sha": "42218fc5150403b446f1c7876642d98ed5aec549", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -108,7 +108,7 @@ struct GenericArgMismatchErrorCode {\n /// Dummy type used for the `Self` of a `TraitRef` created for converting\n /// a trait object, and which gets removed in `ExistentialTraitRef`.\n /// This type must not appear anywhere in other converted types.\n-const TRAIT_OBJECT_DUMMY_SELF: ty::TyKind<'static> = ty::TyInfer(ty::FreshTy(0));\n+const TRAIT_OBJECT_DUMMY_SELF: ty::TyKind<'static> = ty::Infer(ty::FreshTy(0));\n \n impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     pub fn ast_region_to_region(&self,\n@@ -1474,7 +1474,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyKind::Rptr(ref region, ref mt) => {\n                 let r = self.ast_region_to_region(region, None);\n-                debug!(\"TyRef r={:?}\", r);\n+                debug!(\"Ref r={:?}\", r);\n                 let t = self.ast_ty_to_ty(&mt.ty);\n                 tcx.mk_ref(r, ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n             }\n@@ -1513,7 +1513,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 let length_def_id = tcx.hir.local_def_id(length.id);\n                 let substs = Substs::identity_for_item(tcx, length_def_id);\n                 let length = ty::Const::unevaluated(tcx, length_def_id, substs, tcx.types.usize);\n-                let array_ty = tcx.mk_ty(ty::TyArray(self.ast_ty_to_ty(&ty), length));\n+                let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(&ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }\n             hir::TyKind::Typeof(ref _e) => {\n@@ -1525,7 +1525,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 tcx.types.err\n             }\n             hir::TyKind::Infer => {\n-                // TyInfer also appears as the type of arguments or return\n+                // Infer also appears as the type of arguments or return\n                 // values in a ExprKind::Closure, or as\n                 // the type of local variables. Both of these cases are\n                 // handled specially and will not descend into this routine."}, {"sha": "eda3e6715e9c2411c25f50b85f7a2317d45caf0f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             PatKind::Lit(ref lt) => {\n                 let ty = self.check_expr(lt);\n                 match ty.sty {\n-                    ty::TyKind::TyRef(..) => false,\n+                    ty::TyKind::Ref(..) => false,\n                     _ => true,\n                 }\n             }\n@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Peel off as many `&` or `&mut` from the discriminant as possible. For example,\n             // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches\n-            // the `Some(5)` which is not of type TyRef.\n+            // the `Some(5)` which is not of type Ref.\n             //\n             // For each ampersand peeled off, update the binding mode and push the original\n             // type into the adjustments vector.\n@@ -84,8 +84,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             expected = loop {\n                 debug!(\"inspecting {:?} with type {:?}\", exp_ty, exp_ty.sty);\n                 match exp_ty.sty {\n-                    ty::TyKind::TyRef(_, inner_ty, inner_mutability) => {\n-                        debug!(\"current discriminant is TyRef, inserting implicit deref\");\n+                    ty::TyKind::Ref(_, inner_ty, inner_mutability) => {\n+                        debug!(\"current discriminant is Ref, inserting implicit deref\");\n                         // Preserve the reference type. We'll need it later during HAIR lowering.\n                         pat_adjustments.push(exp_ty);\n \n@@ -150,8 +150,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let hir::ExprKind::Lit(ref lt) = lt.node {\n                     if let ast::LitKind::ByteStr(_) = lt.node {\n                         let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                        if let ty::TyRef(_, r_ty, _) = expected_ty.sty {\n-                            if let ty::TySlice(_) = r_ty.sty {\n+                        if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n+                            if let ty::Slice(_) = r_ty.sty {\n                                 pat_ty = tcx.mk_imm_ref(tcx.types.re_static,\n                                                          tcx.mk_slice(tcx.types.u8))\n                             }\n@@ -285,7 +285,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let mut expected_len = elements.len();\n                 if ddpos.is_some() {\n                     // Require known type only when `..` is present\n-                    if let ty::TyTuple(ref tys) =\n+                    if let ty::Tuple(ref tys) =\n                             self.structurally_resolved_type(pat.span, expected).sty {\n                         expected_len = tys.len();\n                     }\n@@ -297,7 +297,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     //       from all tuple elements isn't trivial.\n                     TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n-                let pat_ty = tcx.mk_ty(ty::TyTuple(element_tys));\n+                let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n                 self.demand_eqtype(pat.span, expected, pat_ty);\n                 for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n                     self.check_pat_walk(elem, &element_tys[i], def_bm, true);\n@@ -333,7 +333,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // hack detailed in (*) below.\n                     debug!(\"check_pat_walk: expected={:?}\", expected);\n                     let (rptr_ty, inner_ty) = match expected.sty {\n-                        ty::TyRef(_, r_ty, r_mutbl) if r_mutbl == mutbl => {\n+                        ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => {\n                             (expected, r_ty)\n                         }\n                         _ => {\n@@ -375,7 +375,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             PatKind::Slice(ref before, ref slice, ref after) => {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 let (inner_ty, slice_ty) = match expected_ty.sty {\n-                    ty::TyArray(inner_ty, size) => {\n+                    ty::Array(inner_ty, size) => {\n                         let size = size.unwrap_usize(tcx);\n                         let min_len = before.len() as u64 + after.len() as u64;\n                         if slice.is_none() {\n@@ -400,16 +400,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             (inner_ty, tcx.types.err)\n                         }\n                     }\n-                    ty::TySlice(inner_ty) => (inner_ty, expected_ty),\n+                    ty::Slice(inner_ty) => (inner_ty, expected_ty),\n                     _ => {\n                         if !expected_ty.references_error() {\n                             let mut err = struct_span_err!(\n                                 tcx.sess, pat.span, E0529,\n                                 \"expected an array or slice, found `{}`\",\n                                 expected_ty);\n-                            if let ty::TyRef(_, ty, _) = expected_ty.sty {\n+                            if let ty::Ref(_, ty, _) = expected_ty.sty {\n                                 match ty.sty {\n-                                    ty::TyArray(..) | ty::TySlice(..) => {\n+                                    ty::Array(..) | ty::Slice(..) => {\n                                         err.help(\"the semantics of slice patterns changed \\\n                                                   recently; see issue #23121\");\n                                     }\n@@ -493,7 +493,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n-                if let ty::TyDynamic(..) = mt.ty.sty {\n+                if let ty::Dynamic(..) = mt.ty.sty {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                     let type_str = self.ty_to_string(expected);\n@@ -818,7 +818,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         if subpats.len() == variant.fields.len() ||\n                 subpats.len() < variant.fields.len() && ddpos.is_some() {\n             let substs = match pat_ty.sty {\n-                ty::TyAdt(_, substs) => substs,\n+                ty::Adt(_, substs) => substs,\n                 ref ty => bug!(\"unexpected pattern type {:?}\", ty),\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n@@ -854,7 +854,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let tcx = self.tcx;\n \n         let (substs, adt) = match adt_ty.sty {\n-            ty::TyAdt(adt, substs) => (substs, adt),\n+            ty::Adt(adt, substs) => (substs, adt),\n             _ => span_bug!(span, \"struct pattern is not an ADT\")\n         };\n         let kind_name = adt.variant_descr();"}, {"sha": "743a2390ec43d5a9fcac17d62f0e0f4f689c0646", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -177,7 +177,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                 self.fcx.try_overloaded_deref(self.span, source, needs)\n                     .and_then(|InferOk { value: method, obligations: o }| {\n                         obligations.extend(o);\n-                        if let ty::TyRef(region, _, mutbl) = method.sig.output().sty {\n+                        if let ty::Ref(region, _, mutbl) = method.sig.output().sty {\n                             Some(OverloadedDeref {\n                                 region,\n                                 mutbl,"}, {"sha": "462bde2ab4f13612d1c25fcd03738bd559859d01", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -95,13 +95,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.sty {\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+            ty::FnDef(..) | ty::FnPtr(_) => {\n                 let adjustments = autoderef.adjust_steps(Needs::None);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n \n-            ty::TyClosure(def_id, substs) => {\n+            ty::Closure(def_id, substs) => {\n                 assert_eq!(def_id.krate, LOCAL_CRATE);\n \n                 // Check whether this is a call to a closure where we\n@@ -135,7 +135,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // over the top. The simplest fix by far is to just ignore\n             // this case and deref again, so we wind up with\n             // `FnMut::call_mut(&mut *x, ())`.\n-            ty::TyRef(..) if autoderef.step_count() == 0 => {\n+            ty::Ref(..) if autoderef.step_count() == 0 => {\n                 return None;\n             }\n \n@@ -175,7 +175,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let method = self.register_infer_ok_obligations(ok);\n                     let mut autoref = None;\n                     if borrow {\n-                        if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                        if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n                             let mutbl = match mutbl {\n                                 hir::MutImmutable => AutoBorrowMutability::Immutable,\n                                 hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -206,13 +206,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             expected: Expectation<'tcx>)\n                             -> Ty<'tcx> {\n         let (fn_sig, def_span) = match callee_ty.sty {\n-            ty::TyFnDef(def_id, _) => {\n+            ty::FnDef(def_id, _) => {\n                 (callee_ty.fn_sig(self.tcx), self.tcx.hir.span_if_local(def_id))\n             }\n-            ty::TyFnPtr(sig) => (sig, None),\n+            ty::FnPtr(sig) => (sig, None),\n             ref t => {\n                 let mut unit_variant = None;\n-                if let &ty::TyAdt(adt_def, ..) = t {\n+                if let &ty::Adt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n                         if let hir::ExprKind::Call(ref expr, _) = call_expr.node {\n                             unit_variant = Some(self.tcx.hir.node_to_pretty_string(expr.id))"}, {"sha": "cf0026a7a9c91528009451edb4246c5e689e7463", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -103,10 +103,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         Ok(match t.sty {\n-            ty::TySlice(_) | ty::TyStr => Some(PointerKind::Length),\n-            ty::TyDynamic(ref tty, ..) =>\n+            ty::Slice(_) | ty::TyStr => Some(PointerKind::Length),\n+            ty::Dynamic(ref tty, ..) =>\n                 Some(PointerKind::Vtable(tty.principal().map(|p| p.def_id()))),\n-            ty::TyAdt(def, substs) if def.is_struct() => {\n+            ty::Adt(def, substs) if def.is_struct() => {\n                 match def.non_enum_variant().fields.last() {\n                     None => Some(PointerKind::Thin),\n                     Some(f) => {\n@@ -115,25 +115,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            ty::TyTuple(fields) => match fields.last() {\n+            ty::Tuple(fields) => match fields.last() {\n                 None => Some(PointerKind::Thin),\n                 Some(f) => self.pointer_kind(f, span)?\n             },\n \n             // Pointers to foreign types are thin, despite being unsized\n             ty::TyForeign(..) => Some(PointerKind::Thin),\n             // We should really try to normalize here.\n-            ty::TyProjection(ref pi) => Some(PointerKind::OfProjection(pi)),\n-            ty::TyAnon(def_id, substs) => Some(PointerKind::OfAnon(def_id, substs)),\n+            ty::Projection(ref pi) => Some(PointerKind::OfProjection(pi)),\n+            ty::Anon(def_id, substs) => Some(PointerKind::OfAnon(def_id, substs)),\n             ty::TyParam(ref p) => Some(PointerKind::OfParam(p)),\n             // Insufficient type information.\n-            ty::TyInfer(_) => None,\n+            ty::Infer(_) => None,\n \n             ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n-            ty::TyFloat(_) | ty::TyArray(..) | ty::TyGeneratorWitness(..) |\n-            ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyFnDef(..) |\n-            ty::TyFnPtr(..) | ty::TyClosure(..) | ty::TyGenerator(..) |\n-            ty::TyAdt(..) | ty::TyNever | ty::TyError => {\n+            ty::TyFloat(_) | ty::Array(..) | ty::GeneratorWitness(..) |\n+            ty::RawPtr(_) | ty::Ref(..) | ty::FnDef(..) |\n+            ty::FnPtr(..) | ty::Closure(..) | ty::Generator(..) |\n+            ty::Adt(..) | ty::Never | ty::Error => {\n                 self.tcx.sess.delay_span_bug(\n                     span, &format!(\"`{:?}` should be sized but is not?\", t));\n                 return Err(ErrorReported);\n@@ -199,7 +199,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         // cases now. We do a more thorough check at the end, once\n         // inference is more completely known.\n         match cast_ty.sty {\n-            ty::TyDynamic(..) | ty::TySlice(..) => {\n+            ty::Dynamic(..) | ty::Slice(..) => {\n                 check.report_cast_to_unsized_type(fcx);\n                 Err(ErrorReported)\n             }\n@@ -319,7 +319,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                          fcx.resolve_type_vars_if_possible(&self.expr_ty),\n                                          tstr);\n         match self.expr_ty.sty {\n-            ty::TyRef(_, _, mt) => {\n+            ty::Ref(_, _, mt) => {\n                 let mtstr = match mt {\n                     hir::MutMutable => \"mut \",\n                     hir::MutImmutable => \"\",\n@@ -343,7 +343,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                tstr);\n                 }\n             }\n-            ty::TyAdt(def, ..) if def.is_box() => {\n+            ty::Adt(def, ..) if def.is_box() => {\n                 match fcx.tcx.sess.source_map().span_to_snippet(self.cast_span) {\n                     Ok(s) => {\n                         err.span_suggestion(self.cast_span,\n@@ -429,7 +429,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n             // Function item types may need to be reified before casts.\n             (None, Some(t_cast)) => {\n-                if let ty::TyFnDef(..) = self.expr_ty.sty {\n+                if let ty::FnDef(..) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n                     let f = self.expr_ty.fn_sig(fcx.tcx);\n                     let res = fcx.try_coerce(self.expr,\n@@ -482,7 +482,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                     ty::TyKind::TyFloat(_) => {\n                         Err(CastError::NeedDeref)\n                     }\n-                    ty::TyKind::TyInfer(t) => {\n+                    ty::TyKind::Infer(t) => {\n                         match t {\n                             ty::InferTy::IntVar(_) |\n                             ty::InferTy::FloatVar(_) => Err(CastError::NeedDeref),\n@@ -583,7 +583,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         // array-ptr-cast.\n \n         if m_expr.mutbl == hir::MutImmutable && m_cast.mutbl == hir::MutImmutable {\n-            if let ty::TyArray(ety, _) = m_expr.ty.sty {\n+            if let ty::Array(ety, _) = m_expr.ty.sty {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of\n                 // vector elements instead of the original values."}, {"sha": "a283e032e0e023a11654a66d81575c0300a236bf", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -190,7 +190,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         match expected_ty.sty {\n-            ty::TyDynamic(ref object_type, ..) => {\n+            ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type\n                     .projection_bounds()\n                     .filter_map(|pb| {\n@@ -203,8 +203,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .and_then(|p| self.tcx.lang_items().fn_trait_kind(p.def_id()));\n                 (sig, kind)\n             }\n-            ty::TyInfer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n-            ty::TyFnPtr(sig) => {\n+            ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n+            ty::FnPtr(sig) => {\n                 let expected_sig = ExpectedSig {\n                     cause_span: None,\n                     sig: sig.skip_binder().clone(),\n@@ -269,9 +269,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                     // NB: This predicate is created by breaking down a\n                     // `ClosureType: FnFoo()` predicate, where\n-                    // `ClosureType` represents some `TyClosure`. It can't\n+                    // `ClosureType` represents some `Closure`. It can't\n                     // possibly be referring to the current closure,\n-                    // because we haven't produced the `TyClosure` for\n+                    // because we haven't produced the `Closure` for\n                     // this closure yet; this is exactly why the other\n                     // code is looking for a self type of a unresolved\n                     // inference variable.\n@@ -317,7 +317,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         let input_tys = match arg_param_ty.sty {\n-            ty::TyTuple(tys) => tys.into_iter(),\n+            ty::Tuple(tys) => tys.into_iter(),\n             _ => {\n                 return None;\n             }\n@@ -353,7 +353,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             trait_ref, self_ty\n         );\n         match self_ty.sty {\n-            ty::TyInfer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n+            ty::Infer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n             _ => None,\n         }\n     }"}, {"sha": "763adb007c3a4d791e8fbea3a4ad5bc702f26e60", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -210,11 +210,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // Note: does not attempt to resolve type variables we encounter.\n         // See above for details.\n         match b.sty {\n-            ty::TyRawPtr(mt_b) => {\n+            ty::RawPtr(mt_b) => {\n                 return self.coerce_unsafe_ptr(a, b, mt_b.mutbl);\n             }\n \n-            ty::TyRef(r_b, ty, mutbl) => {\n+            ty::Ref(r_b, ty, mutbl) => {\n                 let mt_b = ty::TypeAndMut { ty, mutbl };\n                 return self.coerce_borrowed_pointer(a, b, r_b, mt_b);\n             }\n@@ -223,20 +223,20 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n \n         match a.sty {\n-            ty::TyFnDef(..) => {\n+            ty::FnDef(..) => {\n                 // Function items are coercible to any closure\n                 // type; function pointers are not (that would\n                 // require double indirection).\n                 // Additionally, we permit coercion of function\n                 // items to drop the unsafe qualifier.\n                 self.coerce_from_fn_item(a, b)\n             }\n-            ty::TyFnPtr(a_f) => {\n+            ty::FnPtr(a_f) => {\n                 // We permit coercion of fn pointers to drop the\n                 // unsafe qualifier.\n                 self.coerce_from_fn_pointer(a, a_f, b)\n             }\n-            ty::TyClosure(def_id_a, substs_a) => {\n+            ty::Closure(def_id_a, substs_a) => {\n                 // Non-capturing closures are coercible to\n                 // function pointers\n                 self.coerce_closure_to_fn(a, def_id_a, substs_a, b)\n@@ -267,7 +267,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // yield.\n \n         let (r_a, mt_a) = match a.sty {\n-            ty::TyRef(r_a, ty, mutbl) => {\n+            ty::Ref(r_a, ty, mutbl) => {\n                 let mt_a = ty::TypeAndMut { ty, mutbl };\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (r_a, mt_a)\n@@ -429,7 +429,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n         let r_borrow = match ty.sty {\n-            ty::TyRef(r_borrow, _, _) => r_borrow,\n+            ty::Ref(r_borrow, _, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n         let mutbl = match mt_b.mutbl {\n@@ -473,7 +473,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.\n         let reborrow = match (&source.sty, &target.sty) {\n-            (&ty::TyRef(_, ty_a, mutbl_a), &ty::TyRef(_, _, mutbl_b)) => {\n+            (&ty::Ref(_, ty_a, mutbl_a), &ty::Ref(_, _, mutbl_b)) => {\n                 coerce_mutbls(mutbl_a, mutbl_b)?;\n \n                 let coercion = Coercion(self.cause.span);\n@@ -498,7 +498,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                     })\n                 }))\n             }\n-            (&ty::TyRef(_, ty_a, mt_a), &ty::TyRawPtr(ty::TypeAndMut { mutbl: mt_b, .. })) => {\n+            (&ty::Ref(_, ty_a, mt_a), &ty::RawPtr(ty::TypeAndMut { mutbl: mt_b, .. })) => {\n                 coerce_mutbls(mt_a, mt_b)?;\n \n                 Some((Adjustment {\n@@ -562,7 +562,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n                     if unsize_did == tr.def_id() {\n                         let sty = &tr.skip_binder().input_types().nth(1).unwrap().sty;\n-                        if let ty::TyTuple(..) = sty {\n+                        if let ty::Tuple(..) = sty {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n                             has_unsized_tuple_coercion = true;\n                         }\n@@ -619,7 +619,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         where F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n               G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>\n     {\n-        if let ty::TyFnPtr(fn_ty_b) = b.sty {\n+        if let ty::FnPtr(fn_ty_b) = b.sty {\n             match (fn_ty_a.unsafety(), fn_ty_b.unsafety()) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n@@ -659,7 +659,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         debug!(\"coerce_from_fn_item(a={:?}, b={:?})\", a, b);\n \n         match b.sty {\n-            ty::TyFnPtr(_) => {\n+            ty::FnPtr(_) => {\n                 let a_sig = a.fn_sig(self.tcx);\n                 let InferOk { value: a_sig, mut obligations } =\n                     self.normalize_associated_types_in_as_infer_ok(self.cause.span, &a_sig);\n@@ -699,7 +699,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         let node_id_a = self.tcx.hir.as_local_node_id(def_id_a).unwrap();\n         match b.sty {\n-            ty::TyFnPtr(_) if self.tcx.with_freevars(node_id_a, |v| v.is_empty()) => {\n+            ty::FnPtr(_) if self.tcx.with_freevars(node_id_a, |v| v.is_empty()) => {\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to\n@@ -722,8 +722,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={:?}, b={:?})\", a, b);\n \n         let (is_ref, mt_a) = match a.sty {\n-            ty::TyRef(_, ty, mutbl) => (true, ty::TypeAndMut { ty, mutbl }),\n-            ty::TyRawPtr(mt) => (false, mt),\n+            ty::Ref(_, ty, mutbl) => (true, ty::TypeAndMut { ty, mutbl }),\n+            ty::RawPtr(mt) => (false, mt),\n             _ => {\n                 return self.unify_and(a, b, identity);\n             }\n@@ -811,7 +811,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n-        if let (&ty::TyFnDef(..), &ty::TyFnDef(..)) = (&prev_ty.sty, &new_ty.sty) {\n+        if let (&ty::FnDef(..), &ty::FnDef(..)) = (&prev_ty.sty, &new_ty.sty) {\n             // Don't reify if the function types have a LUB, i.e. they\n             // are the same function and their parameters have a LUB.\n             let lub_ty = self.commit_if_ok(|_| {\n@@ -881,7 +881,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mutbl_adj)), .. }\n                 ] => {\n                     match self.node_ty(expr.hir_id).sty {\n-                        ty::TyRef(_, _, mt_orig) => {\n+                        ty::Ref(_, _, mt_orig) => {\n                             let mutbl_adj: hir::Mutability = mutbl_adj.into();\n                             // Reborrow that we can safely ignore, because\n                             // the next adjustment can only be a Deref"}, {"sha": "cf558c3acb7960c82e6501e44718612944cce9af", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If the expected type is an enum with any variants whose sole\n         // field is of the found type, suggest such variants. See Issue\n         // #42764.\n-        if let ty::TyAdt(expected_adt, substs) = expected.sty {\n+        if let ty::Adt(expected_adt, substs) = expected.sty {\n             let mut compatible_variants = vec![];\n             for variant in &expected_adt.variants {\n                 if variant.fields.len() == 1 {\n@@ -259,9 +259,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         match (&expected.sty, &checked_ty.sty) {\n-            (&ty::TyRef(_, exp, _), &ty::TyRef(_, check, _)) => match (&exp.sty, &check.sty) {\n-                (&ty::TyStr, &ty::TyArray(arr, _)) |\n-                (&ty::TyStr, &ty::TySlice(arr)) if arr == self.tcx.types.u8 => {\n+            (&ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.sty, &check.sty) {\n+                (&ty::TyStr, &ty::Array(arr, _)) |\n+                (&ty::TyStr, &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.node {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n                             if src.starts_with(\"b\\\"\") {\n@@ -272,8 +272,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                 },\n-                (&ty::TyArray(arr, _), &ty::TyStr) |\n-                (&ty::TySlice(arr), &ty::TyStr) if arr == self.tcx.types.u8 => {\n+                (&ty::Array(arr, _), &ty::TyStr) |\n+                (&ty::Slice(arr), &ty::TyStr) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.node {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n                             if src.starts_with(\"\\\"\") {\n@@ -286,7 +286,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 _ => {}\n             },\n-            (&ty::TyRef(_, _, mutability), _) => {\n+            (&ty::Ref(_, _, mutability), _) => {\n                 // Check if it can work when put into a ref. For example:\n                 //\n                 // ```\n@@ -325,7 +325,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            (_, &ty::TyRef(_, checked, _)) => {\n+            (_, &ty::Ref(_, checked, _)) => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest adding a `*`, or removing\n                 // a `&`."}, {"sha": "9d3cbf910e05958f3633f0d6c02fe9af944b1471", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -45,7 +45,7 @@ pub fn check_drop_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let dtor_self_type = tcx.type_of(drop_impl_did);\n     let dtor_predicates = tcx.predicates_of(drop_impl_did);\n     match dtor_self_type.sty {\n-        ty::TyAdt(adt_def, self_to_impl_substs) => {\n+        ty::Adt(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(tcx,\n                                                           drop_impl_did,\n                                                           dtor_self_type,"}, {"sha": "f410f4b9af3c5b2f187011aac77556291bcbd299", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -463,7 +463,7 @@ fn match_intrinsic_type_to_type<'a, 'tcx>(\n \n     match *expected {\n         Void => match t.sty {\n-            ty::TyTuple(ref v) if v.is_empty() => {},\n+            ty::Tuple(ref v) if v.is_empty() => {},\n             _ => simple_error(&format!(\"`{}`\", t), \"()\"),\n         },\n         // (The width we pass to LLVM doesn't concern the type checker.)\n@@ -491,7 +491,7 @@ fn match_intrinsic_type_to_type<'a, 'tcx>(\n         },\n         Pointer(ref inner_expected, ref _llvm_type, const_) => {\n             match t.sty {\n-                ty::TyRawPtr(ty::TypeAndMut { ty, mutbl }) => {\n+                ty::RawPtr(ty::TypeAndMut { ty, mutbl }) => {\n                     if (mutbl == hir::MutImmutable) != const_ {\n                         simple_error(&format!(\"`{}`\", t),\n                                      if const_ {\"const pointer\"} else {\"mut pointer\"})\n@@ -537,7 +537,7 @@ fn match_intrinsic_type_to_type<'a, 'tcx>(\n         }\n         Aggregate(_flatten, ref expected_contents) => {\n             match t.sty {\n-                ty::TyTuple(contents) => {\n+                ty::Tuple(contents) => {\n                     if contents.len() != expected_contents.len() {\n                         simple_error(&format!(\"tuple with length {}\", contents.len()),\n                                      &format!(\"tuple with length {}\", expected_contents.len()));"}, {"sha": "6057c18663a6e7f6fcc74153fa265b7117c2f418", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             .include_raw_pointers()\n             .filter_map(|(ty, _)| {\n                 match ty.sty {\n-                    ty::TyDynamic(ref data, ..) => data.principal().map(|p| closure(self, ty, p)),\n+                    ty::Dynamic(ref data, ..) => data.principal().map(|p| closure(self, ty, p)),\n                     _ => None,\n                 }\n             })\n@@ -479,7 +479,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n                         if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::TyRef(region, _, mutbl) = method.sig.output().sty {\n+                            if let ty::Ref(region, _, mutbl) = method.sig.output().sty {\n                                 *deref = OverloadedDeref {\n                                     region,\n                                     mutbl,\n@@ -538,7 +538,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n         self.write_method_call(expr.hir_id, method);\n \n-        let (region, mutbl) = if let ty::TyRef(r, _, mutbl) = method.sig.inputs()[0].sty {\n+        let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].sty {\n             (r, mutbl)\n         } else {\n             span_bug!(expr.span, \"input to place op is not a ref?\");\n@@ -605,7 +605,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             })\n             .any(|trait_pred| {\n                 match trait_pred.skip_binder().self_ty().sty {\n-                    ty::TyDynamic(..) => true,\n+                    ty::Dynamic(..) => true,\n                     _ => false,\n                 }\n             })"}, {"sha": "46ccbb01c388232ab754a7b87a741602b540b1ef", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -314,7 +314,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     from_unsafe_deref: reached_raw_pointer,\n                     unsize: false,\n                 };\n-                if let ty::TyRawPtr(_) = ty.sty {\n+                if let ty::RawPtr(_) = ty.sty {\n                     // all the subsequent steps will be from_unsafe_deref\n                     reached_raw_pointer = true;\n                 }\n@@ -324,7 +324,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let final_ty = autoderef.maybe_ambiguous_final_ty();\n         match final_ty.sty {\n-            ty::TyInfer(ty::TyVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) => {\n                 // Ended in an inference variable. If we are doing\n                 // a real method lookup, this is a hard error because it's\n                 // possible that there will be multiple applicable methods.\n@@ -356,7 +356,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // just ignore it.\n                 }\n             }\n-            ty::TyArray(elem_ty, _) => {\n+            ty::Array(elem_ty, _) => {\n                 let dereferences = steps.len() - 1;\n \n                 steps.push(CandidateStep {\n@@ -368,7 +368,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     unsize: true,\n                 });\n             }\n-            ty::TyError => return None,\n+            ty::Error => return None,\n             _ => (),\n         }\n \n@@ -450,13 +450,13 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let lang_items = self.tcx.lang_items();\n \n         match self_ty.sty {\n-            ty::TyDynamic(ref data, ..) => {\n+            ty::Dynamic(ref data, ..) => {\n                 if let Some(p) = data.principal() {\n                     self.assemble_inherent_candidates_from_object(self_ty, p);\n                     self.assemble_inherent_impl_candidates_for_type(p.def_id());\n                 }\n             }\n-            ty::TyAdt(def, _) => {\n+            ty::Adt(def, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(def.did);\n             }\n             ty::TyForeign(did) => {\n@@ -476,7 +476,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let lang_def_id = lang_items.str_alloc_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TySlice(_) => {\n+            ty::Slice(_) => {\n                 let lang_def_id = lang_items.slice_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n \n@@ -489,11 +489,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let lang_def_id = lang_items.slice_u8_alloc_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n                 let lang_def_id = lang_items.const_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 let lang_def_id = lang_items.mut_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n@@ -919,7 +919,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 pick.autoderefs = step.autoderefs;\n \n                 // Insert a `&*` or `&mut *` if this is a reference type:\n-                if let ty::TyRef(_, _, mutbl) = step.self_ty.sty {\n+                if let ty::Ref(_, _, mutbl) = step.self_ty.sty {\n                     pick.autoderefs += 1;\n                     pick.autoref = Some(mutbl);\n                 }"}, {"sha": "15aae83c5b90bffe46439031fdd13763742e7aab", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -32,7 +32,7 @@ use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::hir;\n use rustc::hir::print;\n use rustc::infer::type_variable::TypeVariableOrigin;\n-use rustc::ty::TyAdt;\n+use rustc::ty::Adt;\n \n use std::cmp::Ordering;\n \n@@ -45,9 +45,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match ty.sty {\n             // Not all of these (e.g. unsafe fns) implement FnOnce\n             // so we look for these beforehand\n-            ty::TyClosure(..) |\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) => true,\n+            ty::Closure(..) |\n+            ty::FnDef(..) |\n+            ty::FnPtr(_) => true,\n             // If it's not a simple function, look for things which implement FnOnce\n             _ => {\n                 let fn_once = match tcx.lang_items().require(FnOnceTraitLangItem) {\n@@ -199,7 +199,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let item_kind = if is_method {\n                     \"method\"\n                 } else if actual.is_enum() {\n-                    if let TyAdt(ref adt_def, _) = actual.sty {\n+                    if let Adt(ref adt_def, _) = actual.sty {\n                         let names = adt_def.variants.iter().map(|s| &s.name);\n                         suggestion = find_best_match_for_name(names,\n                                                               &item_name.as_str(),\n@@ -338,7 +338,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(expr) = rcvr_expr {\n                     for (ty, _) in self.autoderef(span, rcvr_ty) {\n                         match ty.sty {\n-                            ty::TyAdt(def, substs) if !def.is_enum() => {\n+                            ty::Adt(def, substs) if !def.is_enum() => {\n                                 let variant = &def.non_enum_variant();\n                                 if let Some(index) = self.tcx.find_field_index(item_name, variant) {\n                                     let field = &variant.fields[index];\n@@ -638,10 +638,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             -> bool {\n         fn is_local(ty: Ty) -> bool {\n             match ty.sty {\n-                ty::TyAdt(def, _) => def.did.is_local(),\n+                ty::Adt(def, _) => def.did.is_local(),\n                 ty::TyForeign(did) => did.is_local(),\n \n-                ty::TyDynamic(ref tr, ..) => tr.principal()\n+                ty::Dynamic(ref tr, ..) => tr.principal()\n                     .map_or(false, |p| p.def_id().is_local()),\n \n                 ty::TyParam(_) => true,"}, {"sha": "1230ccf4400671c81387a23702a1ddc42945522e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -214,7 +214,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // Anonymized types found in explicit return types and their\n     // associated fresh inference variable. Writeback resolves these\n     // variables to get the concrete type, which can be used to\n-    // deanonymize TyAnon, after typeck is done with all functions.\n+    // deanonymize Anon, after typeck is done with all functions.\n     anon_types: RefCell<DefIdMap<AnonTypeDecl<'tcx>>>,\n \n     /// Each type parameter has an implicit region bound that\n@@ -311,7 +311,7 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     /// for examples of where this comes up,.\n     fn rvalue_hint(fcx: &FnCtxt<'a, 'gcx, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n         match fcx.tcx.struct_tail(ty).sty {\n-            ty::TySlice(_) | ty::TyStr | ty::TyDynamic(..) => {\n+            ty::Slice(_) | ty::TyStr | ty::Dynamic(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n             }\n             _ => ExpectHasType(ty)\n@@ -1137,7 +1137,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     if let Some(panic_impl_did) = fcx.tcx.lang_items().panic_impl() {\n         if panic_impl_did == fcx.tcx.hir.local_def_id(fn_id) {\n             if let Some(panic_info_did) = fcx.tcx.lang_items().panic_info() {\n-                if declared_ret_ty.sty != ty::TyNever {\n+                if declared_ret_ty.sty != ty::Never {\n                     fcx.tcx.sess.span_err(\n                         decl.output.span(),\n                         \"return type should be `!`\",\n@@ -1148,8 +1148,8 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                 let span = fcx.tcx.hir.span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_panic_info = match inputs[0].sty {\n-                        ty::TyRef(region, ty, mutbl) => match ty.sty {\n-                            ty::TyAdt(ref adt, _) => {\n+                        ty::Ref(region, ty, mutbl) => match ty.sty {\n+                            ty::Adt(ref adt, _) => {\n                                 adt.did == panic_info_did &&\n                                     mutbl == hir::Mutability::MutImmutable &&\n                                     *region != RegionKind::ReStatic\n@@ -1190,7 +1190,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     if let Some(alloc_error_handler_did) = fcx.tcx.lang_items().oom() {\n         if alloc_error_handler_did == fcx.tcx.hir.local_def_id(fn_id) {\n             if let Some(alloc_layout_did) = fcx.tcx.lang_items().alloc_layout() {\n-                if declared_ret_ty.sty != ty::TyNever {\n+                if declared_ret_ty.sty != ty::Never {\n                     fcx.tcx.sess.span_err(\n                         decl.output.span(),\n                         \"return type should be `!`\",\n@@ -1201,7 +1201,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                 let span = fcx.tcx.hir.span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_alloc_layout = match inputs[0].sty {\n-                        ty::TyAdt(ref adt, _) => {\n+                        ty::Adt(ref adt, _) => {\n                             adt.did == alloc_layout_did\n                         },\n                         _ => false,\n@@ -1633,7 +1633,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n     let t = tcx.type_of(def_id);\n     match t.sty {\n-        ty::TyAdt(def, substs) if def.is_struct() => {\n+        ty::Adt(def, substs) if def.is_struct() => {\n             let fields = &def.non_enum_variant().fields;\n             if fields.is_empty() {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n@@ -1693,7 +1693,7 @@ fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return false;\n     }\n     match t.sty {\n-        ty::TyAdt(def, substs) if def.is_struct() || def.is_union() => {\n+        ty::Adt(def, substs) if def.is_struct() || def.is_union() => {\n             if tcx.adt_def(def.did).repr.align > 0 {\n                 return true;\n             }\n@@ -1702,7 +1702,7 @@ fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             for field in &def.non_enum_variant().fields {\n                 let f = field.ty(tcx, substs);\n                 match f.sty {\n-                    ty::TyAdt(def, _) => {\n+                    ty::Adt(def, _) => {\n                         if check_packed_inner(tcx, def.did, stack) {\n                             return true;\n                         }\n@@ -1982,7 +1982,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn resolve_type_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"resolve_type_vars_with_obligations(ty={:?})\", ty);\n \n-        // No TyInfer()? Nothing needs doing.\n+        // No Infer()? Nothing needs doing.\n         if !ty.has_infer_types() {\n             debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n@@ -2331,7 +2331,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // feature(never_type) is enabled, unconstrained ints with i32,\n     // unconstrained floats with f64.\n     // Fallback becomes very dubious if we have encountered type-checking errors.\n-    // In that case, fallback to TyError.\n+    // In that case, fallback to Error.\n     // The return value indicates whether fallback has occurred.\n     fn fallback_if_possible(&self, ty: Ty<'tcx>) -> bool {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n@@ -2481,7 +2481,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let mut self_ty = adjusted_ty;\n             if unsize {\n                 // We only unsize arrays here.\n-                if let ty::TyArray(element_ty, _) = adjusted_ty.sty {\n+                if let ty::Array(element_ty, _) = adjusted_ty.sty {\n                     self_ty = self.tcx.mk_slice(element_ty);\n                 } else {\n                     continue;\n@@ -2500,7 +2500,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let method = self.register_infer_ok_obligations(ok);\n \n                 let mut adjustments = autoderef.adjust_steps(needs);\n-                if let ty::TyRef(region, _, r_mutbl) = method.sig.inputs()[0].sty {\n+                if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].sty {\n                     let mutbl = match r_mutbl {\n                         hir::MutImmutable => AutoBorrowMutability::Immutable,\n                         hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -2694,15 +2694,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let formal_tys = if tuple_arguments == TupleArguments {\n             let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n             match tuple_type.sty {\n-                ty::TyTuple(arg_types) if arg_types.len() != args.len() => {\n+                ty::Tuple(arg_types) if arg_types.len() != args.len() => {\n                     param_count_error(arg_types.len(), args.len(), \"E0057\", false, false);\n                     expected_arg_tys = &[];\n                     self.err_args(args.len())\n                 }\n-                ty::TyTuple(arg_types) => {\n+                ty::Tuple(arg_types) => {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n                         Some(&ty) => match ty.sty {\n-                            ty::TyTuple(ref tys) => &tys,\n+                            ty::Tuple(ref tys) => &tys,\n                             _ => &[]\n                         },\n                         None => &[]\n@@ -2840,7 +2840,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::TyUint(ast::UintTy::U8) | ty::TyUint(ast::UintTy::U16) => {\n                         variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n                     }\n-                    ty::TyFnDef(..) => {\n+                    ty::FnDef(..) => {\n                         let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n                         let ptr_ty = self.resolve_type_vars_if_possible(&ptr_ty);\n                         variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n@@ -2878,8 +2878,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     match ty.sty {\n                         ty::TyInt(_) | ty::TyUint(_) => Some(ty),\n                         ty::TyChar => Some(tcx.types.u8),\n-                        ty::TyRawPtr(..) => Some(tcx.types.usize),\n-                        ty::TyFnDef(..) | ty::TyFnPtr(_) => Some(tcx.types.usize),\n+                        ty::RawPtr(..) => Some(tcx.types.usize),\n+                        ty::FnDef(..) | ty::FnPtr(_) => Some(tcx.types.usize),\n                         _ => None\n                     }\n                 });\n@@ -3179,7 +3179,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n         while let Some((base_t, _)) = autoderef.next() {\n             match base_t.sty {\n-                ty::TyAdt(base_def, substs) if !base_def.is_enum() => {\n+                ty::Adt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\",  base_t);\n                     let (ident, def_scope) =\n                         self.tcx.adjust_ident(field, base_def.did, self.body_id);\n@@ -3201,7 +3201,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         private_candidate = Some((base_def.did, field_ty));\n                     }\n                 }\n-                ty::TyTuple(ref tys) => {\n+                ty::Tuple(ref tys) => {\n                     let fstr = field.as_str();\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n@@ -3246,7 +3246,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let mut err = self.no_such_field_err(field.span, field, expr_t);\n \n                 match expr_t.sty {\n-                    ty::TyAdt(def, _) if !def.is_enum() => {\n+                    ty::Adt(def, _) if !def.is_enum() => {\n                         if let Some(suggested_field_name) =\n                             Self::suggest_field_name(def.non_enum_variant(),\n                                                      &field.as_str(), vec![]) {\n@@ -3262,7 +3262,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }\n                             };\n                     }\n-                    ty::TyRawPtr(..) => {\n+                    ty::RawPtr(..) => {\n                         let base = self.tcx.hir.node_to_pretty_string(base.id);\n                         let msg = format!(\"`{}` is a native pointer; try dereferencing it\", base);\n                         let suggestion = format!(\"(*{}).{}\", base, field);\n@@ -3336,7 +3336,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut err = self.type_error_struct_with_diag(\n             field.ident.span,\n             |actual| match ty.sty {\n-                ty::TyAdt(adt, ..) if adt.is_enum() => {\n+                ty::Adt(adt, ..) if adt.is_enum() => {\n                     struct_span_err!(self.tcx.sess, field.ident.span, E0559,\n                                     \"{} `{}::{}` has no field named `{}`\",\n                                     kind_name, actual, variant.name, field.ident)\n@@ -3357,7 +3357,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                            format!(\"field does not exist - did you mean `{}`?\", field_name));\n         } else {\n             match ty.sty {\n-                ty::TyAdt(adt, ..) => {\n+                ty::Adt(adt, ..) => {\n                     if adt.is_enum() {\n                         err.span_label(field.ident.span,\n                                        format!(\"`{}::{}` does not have this field\",\n@@ -3395,7 +3395,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.demand_eqtype(span, adt_ty_hint, adt_ty);\n \n         let (substs, adt_kind, kind_name) = match &adt_ty.sty{\n-            &ty::TyAdt(adt, substs) => {\n+            &ty::Adt(adt, substs) => {\n                 (substs, adt.adt_kind(), adt.variant_descr())\n             }\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n@@ -3520,7 +3520,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             Def::Variant(..) => {\n                 match ty.sty {\n-                    ty::TyAdt(adt, substs) => {\n+                    ty::Adt(adt, substs) => {\n                         Some((adt.variant_of_def(def), adt.did, substs))\n                     }\n                     _ => bug!(\"unexpected type: {:?}\", ty.sty)\n@@ -3529,7 +3529,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Struct(..) | Def::Union(..) | Def::TyAlias(..) |\n             Def::AssociatedTy(..) | Def::SelfTy(..) => {\n                 match ty.sty {\n-                    ty::TyAdt(adt, substs) if !adt.is_enum() => {\n+                    ty::Adt(adt, substs) if !adt.is_enum() => {\n                         Some((adt.non_enum_variant(), adt.did, substs))\n                     }\n                     _ => None,\n@@ -3578,7 +3578,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Prohibit struct expressions when non exhaustive flag is set.\n-        if let ty::TyAdt(adt, _) = struct_ty.sty {\n+        if let ty::Adt(adt, _) = struct_ty.sty {\n             if !adt.did.is_local() && adt.is_non_exhaustive() {\n                 span_err!(self.tcx.sess, expr.span, E0639,\n                           \"cannot create non-exhaustive {} using struct expression\",\n@@ -3595,7 +3595,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if !error_happened {\n                 self.check_expr_has_type_or_error(base_expr, struct_ty);\n                 match struct_ty.sty {\n-                    ty::TyAdt(adt, substs) if adt.is_struct() => {\n+                    ty::Adt(adt, substs) if adt.is_struct() => {\n                         let fru_field_types = adt.non_enum_variant().fields.iter().map(|f| {\n                             self.normalize_associated_types_in(expr.span, &f.ty(self.tcx, substs))\n                         }).collect();\n@@ -3625,7 +3625,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// strict, _|_ can appear in the type of an expression that does not,\n     /// itself, diverge: for example, fn() -> _|_.)\n     /// Note that inspecting a type's structure *directly* may expose the fact\n-    /// that there are actually multiple representations for `TyError`, so avoid\n+    /// that there are actually multiple representations for `Error`, so avoid\n     /// that when err needs to be handled differently.\n     fn check_expr_with_expectation_and_needs(&self,\n                                                    expr: &'gcx hir::Expr,\n@@ -3684,7 +3684,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Box(ref subexpr) => {\n                 let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n-                        ty::TyAdt(def, _) if def.is_box()\n+                        ty::Adt(def, _) if def.is_box()\n                             => Expectation::rvalue_hint(self, ty.boxed_ty()),\n                         _ => NoExpectation\n                     }\n@@ -3728,7 +3728,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             } else if let Some(ok) = self.try_overloaded_deref(\n                                     expr.span, oprnd_t, needs) {\n                                 let method = self.register_infer_ok_obligations(ok);\n-                                if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                                if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n                                     let mutbl = match mutbl {\n                                         hir::MutImmutable => AutoBorrowMutability::Immutable,\n                                         hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -3773,7 +3773,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprKind::AddrOf(mutbl, ref oprnd) => {\n                 let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n-                        ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                        ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n                             if self.is_place_expr(&oprnd) {\n                                 // Places may legitimately have unsized types.\n                                 // For example, dereferences of a fat pointer and\n@@ -4086,7 +4086,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Array(ref args) => {\n                 let uty = expected.to_option(self).and_then(|uty| {\n                     match uty.sty {\n-                        ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n+                        ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n                         _ => None\n                     }\n                 });\n@@ -4133,7 +4133,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let uty = match expected {\n                     ExpectHasType(uty) => {\n                         match uty.sty {\n-                            ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n+                            ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n                             _ => None\n                         }\n                     }\n@@ -4165,7 +4165,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if element_ty.references_error() {\n                     tcx.types.err\n                 } else if let Ok(count) = count {\n-                    tcx.mk_ty(ty::TyArray(t, count))\n+                    tcx.mk_ty(ty::Array(t, count))\n                 } else {\n                     tcx.types.err\n                 }\n@@ -4174,7 +4174,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let flds = expected.only_has_type(self).and_then(|ty| {\n                     let ty = self.resolve_type_vars_with_obligations(ty);\n                     match ty.sty {\n-                        ty::TyTuple(ref flds) => Some(&flds[..]),\n+                        ty::Tuple(ref flds) => Some(&flds[..]),\n                         _ => None\n                     }\n                 });\n@@ -4228,7 +4228,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                    \"cannot index into a value of type `{}`\",\n                                                    base_t);\n                             // Try to give some advice about indexing tuples.\n-                            if let ty::TyTuple(..) = base_t.sty {\n+                            if let ty::Tuple(..) = base_t.sty {\n                                 let mut needs_note = true;\n                                 // If the index is an integer, we can show the actual\n                                 // fixed expression:\n@@ -5020,7 +5020,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             // If no type arguments were provided, we have to infer them.\n                             // This case also occurs as a result of some malformed input, e.g.\n                             // a lifetime argument being given instead of a type paramter.\n-                            // Using inference instead of `TyError` gives better error messages.\n+                            // Using inference instead of `Error` gives better error messages.\n                             self.var_for_def(span, param)\n                         }\n                     }\n@@ -5158,7 +5158,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if let ty::TyParam(ty::ParamTy { idx, .. }) = leaf_ty.sty {\n             debug!(\"Found use of ty param num {}\", idx);\n             types_used[idx as usize - own_counts.lifetimes] = true;\n-        } else if let ty::TyError = leaf_ty.sty {\n+        } else if let ty::Error = leaf_ty.sty {\n             // If there is already another error, do not emit\n             // an error for not using a type Parameter.\n             assert!(tcx.sess.err_count() > 0);"}, {"sha": "dd8c8a8102a88fcc8cff07a76d1acb90b2eb8452", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -13,7 +13,7 @@\n use super::{FnCtxt, Needs};\n use super::method::MethodCallee;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::TyKind::{TyRef, TyAdt, TyStr, TyUint, TyNever, TyTuple, TyChar, TyArray};\n+use rustc::ty::TyKind::{Ref, Adt, TyStr, TyUint, Never, Tuple, TyChar, Array};\n use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n@@ -204,7 +204,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Ok(method) => {\n                 let by_ref_binop = !op.node.is_by_value();\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n-                    if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n                         let mutbl = match mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -221,7 +221,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n                 if by_ref_binop {\n-                    if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[1].sty {\n+                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[1].sty {\n                         let mutbl = match mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -265,7 +265,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     format!(\"cannot use `{}=` on type `{}`\",\n                                     op.node.as_str(), lhs_ty));\n                             let mut suggested_deref = false;\n-                            if let TyRef(_, mut rty, _) = lhs_ty.sty {\n+                            if let Ref(_, mut rty, _) = lhs_ty.sty {\n                                 if {\n                                     !self.infcx.type_moves_by_default(self.param_env,\n                                                                         rty,\n@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             .is_ok()\n                                 } {\n                                     if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        while let TyRef(_, rty_inner, _) = rty.sty {\n+                                        while let Ref(_, rty_inner, _) = rty.sty {\n                                             rty = rty_inner;\n                                         }\n                                         let msg = &format!(\n@@ -333,7 +333,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             op.node.as_str(),\n                                             lhs_ty);\n                             let mut suggested_deref = false;\n-                            if let TyRef(_, mut rty, _) = lhs_ty.sty {\n+                            if let Ref(_, mut rty, _) = lhs_ty.sty {\n                                 if {\n                                     !self.infcx.type_moves_by_default(self.param_env,\n                                                                         rty,\n@@ -344,7 +344,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             .is_ok()\n                                 } {\n                                     if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        while let TyRef(_, rty_inner, _) = rty.sty {\n+                                        while let Ref(_, rty_inner, _) = rty.sty {\n                                             rty = rty_inner;\n                                         }\n                                         let msg = &format!(\n@@ -429,7 +429,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If this function returns true it means a note was printed, so we don't need\n         // to print the normal \"implementation of `std::ops::Add` might be missing\" note\n         match (&lhs_ty.sty, &rhs_ty.sty) {\n-            (&TyRef(_, l_ty, _), &TyRef(_, r_ty, _))\n+            (&Ref(_, l_ty, _), &Ref(_, r_ty, _))\n             if l_ty.sty == TyStr && r_ty.sty == TyStr => {\n                 if !is_assign {\n                     err.span_label(expr.span,\n@@ -443,7 +443,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 true\n             }\n-            (&TyRef(_, l_ty, _), &TyAdt(..))\n+            (&Ref(_, l_ty, _), &Adt(..))\n             if l_ty.sty == TyStr && &format!(\"{:?}\", rhs_ty) == \"std::string::String\" => {\n                 err.span_label(expr.span,\n                     \"`+` can't be used to concatenate a `&str` with a `String`\");\n@@ -492,8 +492,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         TyUint(_) if op == hir::UnNeg => {\n                             err.note(\"unsigned values cannot be negated\");\n                         },\n-                        TyStr | TyNever | TyChar | TyTuple(_) | TyArray(_,_) => {},\n-                        TyRef(_, ref lty, _) if lty.sty == TyStr => {},\n+                        TyStr | Never | TyChar | Tuple(_) | Array(_,_) => {},\n+                        Ref(_, ref lty, _) if lty.sty == TyStr => {},\n                         _ => {\n                             let missing_trait = match op {\n                                 hir::UnNeg => \"std::ops::Neg\","}, {"sha": "7401609998d15894f88e81052f95a0144d2b231b", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -589,7 +589,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 // For overloaded derefs, base_ty is the input to `Deref::deref`,\n                 // but it's a reference type uing the same region as the output.\n                 let base_ty = self.resolve_expr_type_adjusted(base);\n-                if let ty::TyRef(r_ptr, _, _) = base_ty.sty {\n+                if let ty::Ref(r_ptr, _, _) = base_ty.sty {\n                     self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n                 }\n \n@@ -702,22 +702,22 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                from_ty,\n                to_ty);\n         match (&from_ty.sty, &to_ty.sty) {\n-            /*From:*/ (&ty::TyRef(from_r, from_ty, _),\n-            /*To:  */  &ty::TyRef(to_r, to_ty, _)) => {\n+            /*From:*/ (&ty::Ref(from_r, from_ty, _),\n+            /*To:  */  &ty::Ref(to_r, to_ty, _)) => {\n                 // Target cannot outlive source, naturally.\n                 self.sub_regions(infer::Reborrow(cast_expr.span), to_r, from_r);\n                 self.walk_cast(cast_expr, from_ty, to_ty);\n             }\n \n             /*From:*/ (_,\n-            /*To:  */  &ty::TyDynamic(.., r)) => {\n+            /*To:  */  &ty::Dynamic(.., r)) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n                 self.type_must_outlive(infer::RelateObjectBound(cast_expr.span), from_ty, r);\n             }\n \n-            /*From:*/ (&ty::TyAdt(from_def, _),\n-            /*To:  */  &ty::TyAdt(to_def, _)) if from_def.is_box() && to_def.is_box() => {\n+            /*From:*/ (&ty::Adt(from_def, _),\n+            /*To:  */  &ty::Adt(to_def, _)) if from_def.is_box() && to_def.is_box() => {\n                 self.walk_cast(cast_expr, from_ty.boxed_ty(), to_ty.boxed_ty());\n             }\n \n@@ -736,7 +736,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn constrain_callee(&mut self, callee_expr: &hir::Expr) {\n         let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n         match callee_ty.sty {\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) => { }\n+            ty::FnDef(..) | ty::FnPtr(_) => { }\n             _ => {\n                 // this should not happen, but it does if the program is\n                 // erroneous\n@@ -914,9 +914,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                self.ty_to_string(indexed_ty));\n \n         let r_index_expr = ty::ReScope(region::Scope::Node(index_expr.hir_id.local_id));\n-        if let ty::TyRef(r_ptr, r_ty, _) = indexed_ty.sty {\n+        if let ty::Ref(r_ptr, r_ty, _) = indexed_ty.sty {\n             match r_ty.sty {\n-                ty::TySlice(_) | ty::TyStr => {\n+                ty::Slice(_) | ty::TyStr => {\n                     self.sub_regions(infer::IndexSlice(index_expr.span),\n                                      self.tcx.mk_region(r_index_expr), r_ptr);\n                 }\n@@ -1089,7 +1089,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                id, mutbl, cmt_borrowed);\n \n         let rptr_ty = self.resolve_node_type(id);\n-        if let ty::TyRef(r, _, _) = rptr_ty.sty {\n+        if let ty::Ref(r, _, _) = rptr_ty.sty {\n             debug!(\"rptr_ty={}\",  rptr_ty);\n             self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n         }"}, {"sha": "41df937980ff3430e69f29a35bd1a3b03a421a8d", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -109,9 +109,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Extract the type of the closure.\n         let (closure_def_id, substs) = match self.node_ty(closure_hir_id).sty {\n-            ty::TyClosure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n-            ty::TyGenerator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n-            ty::TyError => {\n+            ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n+            ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n+            ty::Error => {\n                 // #51714: skip analysis when we have already encountered type errors\n                 return;\n             }"}, {"sha": "54b295601ea5e2fe7b4c3178642d3f524727bcf6", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -576,7 +576,7 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n         fldop: |ty| {\n-            if let ty::TyAnon(def_id, substs) = ty.sty {\n+            if let ty::Anon(def_id, substs) = ty.sty {\n                 trace!(\"check_existential_types: anon_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n                 // only check named existential types\n@@ -674,7 +674,7 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                         }\n                     }\n                 } // if is_named_existential_type\n-            } // if let TyAnon\n+            } // if let Anon\n             ty\n         },\n         reg_op: |reg| reg,"}, {"sha": "2550d414bc09643f794d9c4ed055bdc0bfb865a5", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -174,7 +174,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n             match tables.expr_ty_adjusted(&base).sty {\n                 // All valid indexing looks like this\n-                ty::TyRef(_, base_ty, _) => {\n+                ty::Ref(_, base_ty, _) => {\n                     let index_ty = tables.expr_ty_adjusted(&index);\n                     let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n "}, {"sha": "d01e7dbdfefe5904c85afa31e3e4857ade43f0e6", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n     match tcx.type_of(impl_did).sty {\n-        ty::TyAdt(..) => {}\n+        ty::Adt(..) => {}\n         _ => {\n             // Destructors only work on nominal types.\n             if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_did) {\n@@ -217,23 +217,23 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n             (mt_a.ty, mt_b.ty, unsize_trait, None)\n         };\n         let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n-            (&ty::TyRef(r_a, ty_a, mutbl_a), &ty::TyRef(r_b, ty_b, mutbl_b)) => {\n+            (&ty::Ref(r_a, ty_a, mutbl_a), &ty::Ref(r_b, ty_b, mutbl_b)) => {\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n                 let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n                 let mt_b = ty::TypeAndMut { ty: ty_b, mutbl: mutbl_b };\n                 check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ref(r_b, ty))\n             }\n \n-            (&ty::TyRef(_, ty_a, mutbl_a), &ty::TyRawPtr(mt_b)) => {\n+            (&ty::Ref(_, ty_a, mutbl_a), &ty::RawPtr(mt_b)) => {\n                 let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n                 check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n             }\n \n-            (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n+            (&ty::RawPtr(mt_a), &ty::RawPtr(mt_b)) => {\n                 check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n             }\n \n-            (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) if def_a.is_struct() &&\n+            (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b)) if def_a.is_struct() &&\n                                                                           def_b.is_struct() => {\n                 if def_a != def_b {\n                     let source_path = gcx.item_path_str(def_a.did);"}, {"sha": "f3433b7c9db3296a18f0b1bec61b9a974fbee9c9", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -102,13 +102,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n         let self_ty = self.tcx.type_of(def_id);\n         let lang_items = self.tcx.lang_items();\n         match self_ty.sty {\n-            ty::TyAdt(def, _) => {\n+            ty::Adt(def, _) => {\n                 self.check_def_id(item, def.did);\n             }\n             ty::TyForeign(did) => {\n                 self.check_def_id(item, did);\n             }\n-            ty::TyDynamic(ref data, ..) if data.principal().is_some() => {\n+            ty::Dynamic(ref data, ..) if data.principal().is_some() => {\n                 self.check_def_id(item, data.principal().unwrap().def_id());\n             }\n             ty::TyChar => {\n@@ -127,31 +127,31 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n                                           \"str\",\n                                           item.span);\n             }\n-            ty::TySlice(slice_item) if slice_item == self.tcx.types.u8 => {\n+            ty::Slice(slice_item) if slice_item == self.tcx.types.u8 => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.slice_u8_impl(),\n                                           lang_items.slice_u8_alloc_impl(),\n                                           \"slice_u8\",\n                                           \"[u8]\",\n                                           item.span);\n             }\n-            ty::TySlice(_) => {\n+            ty::Slice(_) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.slice_impl(),\n                                           lang_items.slice_alloc_impl(),\n                                           \"slice\",\n                                           \"[T]\",\n                                           item.span);\n             }\n-            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.const_ptr_impl(),\n                                           None,\n                                           \"const_ptr\",\n                                           \"*const T\",\n                                           item.span);\n             }\n-            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.mut_ptr_impl(),\n                                           None,\n@@ -271,7 +271,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n                                           \"f64\",\n                                           item.span);\n             }\n-            ty::TyError => {\n+            ty::Error => {\n                 return;\n             }\n             _ => {"}, {"sha": "168cf47fb5266e3df036ca3f0a4a76551b93f28b", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -157,7 +157,7 @@ fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeI\n     tcx.specialization_graph_of(trait_def_id);\n \n     // check for overlap with the automatic `impl Trait for Trait`\n-    if let ty::TyDynamic(ref data, ..) = trait_ref.self_ty().sty {\n+    if let ty::Dynamic(ref data, ..) = trait_ref.self_ty().sty {\n         // This is something like impl Trait1 for Trait2. Illegal\n         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n "}, {"sha": "1dad6b722dc31d78c6945fd5fa029e6a0e0da1b3", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -114,7 +114,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                    !trait_def_id.is_local() {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n-                        ty::TyAdt(self_def, _) => Some(self_def.did),\n+                        ty::Adt(self_def, _) => Some(self_def.did),\n                         ty::TyForeign(did) => Some(did),\n                         _ => None,\n                     };"}, {"sha": "20bbc475e7dc9475278eed7d46c15edf3dbc392b", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -62,7 +62,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         match t.sty {\n-            ty::TyProjection(..) | ty::TyAnon(..) if !self.include_nonconstraining => {\n+            ty::Projection(..) | ty::Anon(..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return false;\n             }"}, {"sha": "eddbac3f5417bc18293750f31fde75675a5bfa06", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -185,7 +185,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let main_def_id = tcx.hir.local_def_id(main_id);\n     let main_t = tcx.type_of(main_def_id);\n     match main_t.sty {\n-        ty::TyFnDef(..) => {\n+        ty::FnDef(..) => {\n             match tcx.hir.find(main_id) {\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n@@ -257,7 +257,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let start_def_id = tcx.hir.local_def_id(start_id);\n     let start_t = tcx.type_of(start_def_id);\n     match start_t.sty {\n-        ty::TyFnDef(..) => {\n+        ty::FnDef(..) => {\n             match tcx.hir.find(start_id) {\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {"}, {"sha": "ec36fa0fbc14531572d1a1b8a5cc1ea3313b8782", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -85,7 +85,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n                     // Calculating the predicate requirements necessary\n                     // for item_did.\n                     //\n-                    // For field of type &'a T (reference) or TyAdt\n+                    // For field of type &'a T (reference) or Adt\n                     // (struct/enum/union) there will be outlive\n                     // requirements for adt_def.\n                     let field_ty = self.tcx.type_of(field_def.did);\n@@ -138,16 +138,16 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n             // a predicate requirement of T: 'a (T outlives 'a).\n             //\n             // We also want to calculate potential predicates for the T\n-            ty::TyRef(region, rty, _) => {\n-                debug!(\"TyRef\");\n+            ty::Ref(region, rty, _) => {\n+                debug!(\"Ref\");\n                 insert_outlives_predicate(tcx, rty.into(), region, required_predicates);\n             }\n \n-            // For each TyAdt (struct/enum/union) type `Foo<'a, T>`, we\n+            // For each Adt (struct/enum/union) type `Foo<'a, T>`, we\n             // can load the current set of inferred and explicit\n             // predicates from `global_inferred_outlives` and filter the\n             // ones that are TypeOutlives.\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 // First check the inferred predicates\n                 //\n                 // Example 1:\n@@ -166,7 +166,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // round we will get `U: 'b`. We then apply the substitution\n                 // `['b => 'a, U => T]` and thus get the requirement that `T:\n                 // 'a` holds for `Foo`.\n-                debug!(\"TyAdt\");\n+                debug!(\"Adt\");\n                 if let Some(unsubstituted_predicates) = global_inferred_outlives.get(&def.did) {\n                     for unsubstituted_predicate in unsubstituted_predicates {\n                         // `unsubstituted_predicate` is `U: 'b` in the\n@@ -195,7 +195,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 );\n             }\n \n-            ty::TyDynamic(obj, ..) => {\n+            ty::Dynamic(obj, ..) => {\n                 // This corresponds to `dyn Trait<..>`. In this case, we should\n                 // use the explicit predicates as well.\n \n@@ -204,7 +204,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // `dyn Trait` at this stage. Therefore when checking explicit\n                 // predicates in `check_explicit_predicates` we need to ignore\n                 // checking the explicit_map for Self type.\n-                debug!(\"TyDynamic\");\n+                debug!(\"Dynamic\");\n                 debug!(\"field_ty = {}\", &field_ty);\n                 debug!(\"ty in field = {}\", &ty);\n                 if let Some(ex_trait_ref) = obj.principal() {\n@@ -219,10 +219,10 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 }\n             }\n \n-            ty::TyProjection(obj) => {\n+            ty::Projection(obj) => {\n                 // This corresponds to `<T as Foo<'a>>::Bar`. In this case, we should use the\n                 // explicit predicates as well.\n-                debug!(\"TyProjection\");\n+                debug!(\"Projection\");\n                 check_explicit_predicates(\n                     tcx,\n                     &tcx.associated_item(obj.item_def_id).container.id(),"}, {"sha": "83f94e2de08fdc9ec317184939f2222ce660097b", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         let inferred_start = self.terms_cx.inferred_starts[&id];\n         let current_item = &CurrentItem { inferred_start };\n         match tcx.type_of(def_id).sty {\n-            ty::TyAdt(def, _) => {\n+            ty::Adt(def, _) => {\n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::TyFnDef(..) => {\n+            ty::FnDef(..) => {\n                 self.add_constraints_from_sig(current_item,\n                                               tcx.fn_sig(def_id),\n                                               self.covariant);\n@@ -262,51 +262,51 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         match ty.sty {\n             ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n-            ty::TyStr | ty::TyNever | ty::TyForeign(..) => {\n+            ty::TyStr | ty::Never | ty::TyForeign(..) => {\n                 // leaf type -- noop\n             }\n \n-            ty::TyFnDef(..) |\n-            ty::TyGenerator(..) |\n-            ty::TyClosure(..) => {\n+            ty::FnDef(..) |\n+            ty::Generator(..) |\n+            ty::Closure(..) => {\n                 bug!(\"Unexpected closure type in variance computation\");\n             }\n \n-            ty::TyRef(region, ty, mutbl) => {\n+            ty::Ref(region, ty, mutbl) => {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(current, region, contra);\n                 self.add_constraints_from_mt(current, &ty::TypeAndMut { ty, mutbl }, variance);\n             }\n \n-            ty::TyArray(typ, _) |\n-            ty::TySlice(typ) => {\n+            ty::Array(typ, _) |\n+            ty::Slice(typ) => {\n                 self.add_constraints_from_ty(current, typ, variance);\n             }\n \n-            ty::TyRawPtr(ref mt) => {\n+            ty::RawPtr(ref mt) => {\n                 self.add_constraints_from_mt(current, mt, variance);\n             }\n \n-            ty::TyTuple(subtys) => {\n+            ty::Tuple(subtys) => {\n                 for &subty in subtys {\n                     self.add_constraints_from_ty(current, subty, variance);\n                 }\n             }\n \n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 self.add_constraints_from_substs(current, def.did, substs, variance);\n             }\n \n-            ty::TyProjection(ref data) => {\n+            ty::Projection(ref data) => {\n                 let tcx = self.tcx();\n                 self.add_constraints_from_trait_ref(current, data.trait_ref(tcx), variance);\n             }\n \n-            ty::TyAnon(_, substs) => {\n+            ty::Anon(_, substs) => {\n                 self.add_constraints_from_invariant_substs(current, substs, variance);\n             }\n \n-            ty::TyDynamic(ref data, r) => {\n+            ty::Dynamic(ref data, r) => {\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(current, r, contra);\n@@ -327,17 +327,17 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraint(current, data.idx, variance);\n             }\n \n-            ty::TyFnPtr(sig) => {\n+            ty::FnPtr(sig) => {\n                 self.add_constraints_from_sig(current, sig, variance);\n             }\n \n-            ty::TyError => {\n+            ty::Error => {\n                 // we encounter this when walking the trait references for object\n-                // types, where we use TyError as the Self type\n+                // types, where we use Error as the Self type\n             }\n \n-            ty::TyGeneratorWitness(..) |\n-            ty::TyInfer(..) => {\n+            ty::GeneratorWitness(..) |\n+            ty::Infer(..) => {\n                 bug!(\"unexpected type encountered in \\\n                       variance inference: {}\",\n                      ty);"}, {"sha": "7116a42cead83b5dacb5a99706b07075e52845dc", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             debug!(\"id={} variances={:?}\", id, variances);\n \n             // Functions can have unused type parameters: make those invariant.\n-            if let ty::TyFnDef(..) = tcx.type_of(def_id).sty {\n+            if let ty::FnDef(..) = tcx.type_of(def_id).sty {\n                 for variance in &mut variances {\n                     if *variance == ty::Bivariant {\n                         *variance = ty::Invariant;"}, {"sha": "57ddc09f32d9467976e4c34130a3f96a3396205d", "filename": "src/librustdoc/clean/def_ctor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -20,7 +20,7 @@ where F: Fn(& dyn Fn(DefId) -> Def) -> Vec<Item> {\n     let ty = cx.tcx.type_of(def_id);\n \n     match ty.sty {\n-        ty::TyAdt(adt, _) => callback(&match adt.adt_kind() {\n+        ty::Adt(adt, _) => callback(&match adt.adt_kind() {\n             AdtKind::Struct => Def::Struct,\n             AdtKind::Enum => Def::Enum,\n             AdtKind::Union => Def::Union,"}, {"sha": "25b83e08011f42b610cba749aeadb2ef1e6cf05d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -1077,7 +1077,7 @@ fn external_generic_args(cx: &DocContext, trait_did: Option<DefId>, has_self: bo\n         Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n             assert_eq!(types.len(), 1);\n             let inputs = match types[0].sty {\n-                ty::TyTuple(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n+                ty::Tuple(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n                 _ => {\n                     return GenericArgs::AngleBracketed {\n                         lifetimes,\n@@ -1089,7 +1089,7 @@ fn external_generic_args(cx: &DocContext, trait_did: Option<DefId>, has_self: bo\n             let output = None;\n             // FIXME(#20299) return type comes from a projection now\n             // match types[1].sty {\n-            //     ty::TyTuple(ref v) if v.is_empty() => None, // -> ()\n+            //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n             //     _ => Some(types[1].clean(cx))\n             // };\n             GenericArgs::Parenthesized {\n@@ -1133,9 +1133,9 @@ impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n         // collect any late bound regions\n         let mut late_bounds = vec![];\n         for ty_s in trait_ref.input_types().skip(1) {\n-            if let ty::TyTuple(ts) = ty_s.sty {\n+            if let ty::Tuple(ts) = ty_s.sty {\n                 for &ty_s in ts {\n-                    if let ty::TyRef(ref reg, _, _) = ty_s.sty {\n+                    if let ty::Ref(ref reg, _, _) = ty_s.sty {\n                         if let &ty::RegionKind::ReLateBound(..) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(Lifetime(name)) = reg.clean(cx) {\n@@ -1979,7 +1979,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     let self_arg_ty = *sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n                         decl.inputs.values[0].type_ = Generic(String::from(\"Self\"));\n-                    } else if let ty::TyRef(_, ty, _) = self_arg_ty.sty {\n+                    } else if let ty::Ref(_, ty, _) = self_arg_ty.sty {\n                         if ty == self_ty {\n                             match decl.inputs.values[0].type_ {\n                                 BorrowedRef{ref mut type_, ..} => {\n@@ -2506,7 +2506,7 @@ impl Clean<Type> for hir::Ty {\n             TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 let mut def = Def::Err;\n                 let ty = hir_ty_to_ty(cx.tcx, self);\n-                if let ty::TyProjection(proj) = ty.sty {\n+                if let ty::Projection(proj) = ty.sty {\n                     def = Def::Trait(proj.trait_ref(cx.tcx).def_id);\n                 }\n                 let trait_path = hir::Path {\n@@ -2545,15 +2545,15 @@ impl Clean<Type> for hir::Ty {\n impl<'tcx> Clean<Type> for Ty<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Type {\n         match self.sty {\n-            ty::TyNever => Never,\n+            ty::Never => Never,\n             ty::TyBool => Primitive(PrimitiveType::Bool),\n             ty::TyChar => Primitive(PrimitiveType::Char),\n             ty::TyInt(int_ty) => Primitive(int_ty.into()),\n             ty::TyUint(uint_ty) => Primitive(uint_ty.into()),\n             ty::TyFloat(float_ty) => Primitive(float_ty.into()),\n             ty::TyStr => Primitive(PrimitiveType::Str),\n-            ty::TySlice(ty) => Slice(box ty.clean(cx)),\n-            ty::TyArray(ty, n) => {\n+            ty::Slice(ty) => Slice(box ty.clean(cx)),\n+            ty::Array(ty, n) => {\n                 let mut n = cx.tcx.lift(&n).expect(\"array lift failed\");\n                 if let ConstValue::Unevaluated(def_id, substs) = n.val {\n                     let param_env = cx.tcx.param_env(def_id);\n@@ -2568,15 +2568,15 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let n = print_const(cx, n);\n                 Array(box ty.clean(cx), n)\n             }\n-            ty::TyRawPtr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n-            ty::TyRef(r, ty, mutbl) => BorrowedRef {\n+            ty::RawPtr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n+            ty::Ref(r, ty, mutbl) => BorrowedRef {\n                 lifetime: r.clean(cx),\n                 mutability: mutbl.clean(cx),\n                 type_: box ty.clean(cx),\n             },\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) => {\n-                let ty = cx.tcx.lift(self).expect(\"TyFnPtr lift failed\");\n+            ty::FnDef(..) |\n+            ty::FnPtr(_) => {\n+                let ty = cx.tcx.lift(self).expect(\"FnPtr lift failed\");\n                 let sig = ty.fn_sig(cx.tcx);\n                 BareFunction(box BareFunctionDecl {\n                     unsafety: sig.unsafety(),\n@@ -2585,7 +2585,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     abi: sig.abi(),\n                 })\n             }\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 let did = def.did;\n                 let kind = match def.adt_kind() {\n                     AdtKind::Struct => TypeKind::Struct,\n@@ -2613,7 +2613,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     is_generic: false,\n                 }\n             }\n-            ty::TyDynamic(ref obj, ref reg) => {\n+            ty::Dynamic(ref obj, ref reg) => {\n                 if let Some(principal) = obj.principal() {\n                     let did = principal.def_id();\n                     inline::record_extern_fqn(cx, did, TypeKind::Trait);\n@@ -2657,17 +2657,17 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     Never\n                 }\n             }\n-            ty::TyTuple(ref t) => Tuple(t.clean(cx)),\n+            ty::Tuple(ref t) => Tuple(t.clean(cx)),\n \n-            ty::TyProjection(ref data) => data.clean(cx),\n+            ty::Projection(ref data) => data.clean(cx),\n \n             ty::TyParam(ref p) => Generic(p.name.to_string()),\n \n-            ty::TyAnon(def_id, substs) => {\n+            ty::Anon(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n                 let predicates_of = cx.tcx.predicates_of(def_id);\n-                let substs = cx.tcx.lift(&substs).expect(\"TyAnon lift failed\");\n+                let substs = cx.tcx.lift(&substs).expect(\"Anon lift failed\");\n                 let bounds = predicates_of.instantiate(cx.tcx, substs);\n                 let mut regions = vec![];\n                 let mut has_sized = false;\n@@ -2717,11 +2717,11 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 ImplTrait(bounds)\n             }\n \n-            ty::TyClosure(..) | ty::TyGenerator(..) => Tuple(vec![]), // FIXME(pcwalton)\n+            ty::Closure(..) | ty::Generator(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n-            ty::TyGeneratorWitness(..) => panic!(\"TyGeneratorWitness\"),\n-            ty::TyInfer(..) => panic!(\"TyInfer\"),\n-            ty::TyError => panic!(\"TyError\"),\n+            ty::GeneratorWitness(..) => panic!(\"GeneratorWitness\"),\n+            ty::Infer(..) => panic!(\"Infer\"),\n+            ty::Error => panic!(\"Error\"),\n         }\n     }\n }"}, {"sha": "64efea4f42f85c690e874c5694ce49964e315a59", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n                         Ok((ty.def, Some(format!(\"{}.{}\", out, item_name))))\n                     } else {\n                         match cx.tcx.type_of(did).sty {\n-                            ty::TyAdt(def, _) => {\n+                            ty::Adt(def, _) => {\n                                 if let Some(item) = if def.is_enum() {\n                                     def.all_fields().find(|item| item.ident.name == item_name)\n                                 } else {"}, {"sha": "e8f1a0826d61f9e408128abf01c65040cfab7311", "filename": "src/test/run-pass/auxiliary/issue13507.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -50,25 +50,25 @@ pub mod testtypes {\n     // Tests TyStr\n     pub type FooStr = str;\n \n-    // Tests TyArray\n+    // Tests Array\n     pub type FooArray = [u8; 1];\n \n-    // Tests TySlice\n+    // Tests Slice\n     pub type FooSlice = [u8];\n \n     // Tests Box (of u8)\n     pub type FooBox = Box<u8>;\n \n-    // Tests TyRawPtr\n+    // Tests RawPtr\n     pub type FooPtr = *const u8;\n \n-    // Tests TyRef\n+    // Tests Ref\n     pub type FooRef = &'static u8;\n \n-    // Tests TyFnPtr\n+    // Tests FnPtr\n     pub type FooFnPtr = fn(u8) -> bool;\n \n-    // Tests TyDynamic\n+    // Tests Dynamic\n     pub trait FooTrait {\n         fn foo_method(&self) -> usize;\n     }\n@@ -85,13 +85,13 @@ pub mod testtypes {\n         VarB(usize, usize)\n     }\n \n-    // Tests TyTuple\n+    // Tests Tuple\n     pub type FooNil = ();\n     pub type FooTuple = (u8, i8, bool);\n \n     // Skipping TyParam\n \n-    // Skipping TyInfer\n+    // Skipping Infer\n \n-    // Skipping TyError\n+    // Skipping Error\n }"}, {"sha": "c95885518ea2f44d7cd83ee98a86e06d27d7e9bd", "filename": "src/test/run-pass/unboxed-closures-unique-type-id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f637da50c56a22f745fd056691da8c86824cd9b/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs?ref=6f637da50c56a22f745fd056691da8c86824cd9b", "patch": "@@ -12,7 +12,7 @@\n //\n //    error: internal compiler error: get_unique_type_id_of_type() -\n //    unexpected type: closure,\n-//    TyClosure(syntax::ast::DefId{krate: 0, node: 66},\n+//    Closure(syntax::ast::DefId{krate: 0, node: 66},\n //    ReScope(63))\n //\n // This is a regression test for issue #17021."}]}