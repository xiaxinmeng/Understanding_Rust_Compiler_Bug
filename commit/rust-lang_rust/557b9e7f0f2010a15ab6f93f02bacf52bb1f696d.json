{"sha": "557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1N2I5ZTdmMGYyMDEwYTE1YWI2ZjkzZjAyYmFjZjUyYmIxZjY5NmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-18T18:06:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-18T18:06:42Z"}, "message": "auto merge of #14879 : Ryman/rust/resolve_super_hint_cut, r=alexcrichton", "tree": {"sha": "d70c9a4e74ac9e4f95379ed9c4fbd9c82c5a200e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d70c9a4e74ac9e4f95379ed9c4fbd9c82c5a200e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "html_url": "https://github.com/rust-lang/rust/commit/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4416b32768030bf6b5419242db3712c7c36e258c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4416b32768030bf6b5419242db3712c7c36e258c", "html_url": "https://github.com/rust-lang/rust/commit/4416b32768030bf6b5419242db3712c7c36e258c"}, {"sha": "3791a8508750b48fa4e7e8a325284144877feb8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3791a8508750b48fa4e7e8a325284144877feb8c", "html_url": "https://github.com/rust-lang/rust/commit/3791a8508750b48fa4e7e8a325284144877feb8c"}], "stats": {"total": 445, "additions": 250, "deletions": 195}, "files": [{"sha": "5ce63b94b2499b6f9cf4fdb06c502c0f4e1184f9", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 177, "deletions": 135, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -206,10 +206,12 @@ impl ReducedGraphParent {\n     }\n }\n \n+type ErrorMessage = Option<(Span, String)>;\n+\n enum ResolveResult<T> {\n-    Failed,         // Failed to resolve the name.\n-    Indeterminate,  // Couldn't determine due to unresolved globs.\n-    Success(T)      // Successfully resolved the import.\n+    Failed(ErrorMessage),   // Failed to resolve the name, optional helpful error message.\n+    Indeterminate,          // Couldn't determine due to unresolved globs.\n+    Success(T)              // Successfully resolved the import.\n }\n \n impl<T> ResolveResult<T> {\n@@ -1485,26 +1487,22 @@ impl<'a> Resolver<'a> {\n \n             ViewItemExternCrate(name, _, node_id) => {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n-                match self.session.cstore.find_extern_mod_stmt_cnum(node_id) {\n-                    Some(crate_id) => {\n-                        let def_id = DefId { krate: crate_id, node: 0 };\n-                        self.external_exports.insert(def_id);\n-                        let parent_link = ModuleParentLink\n-                            (parent.module().downgrade(), name);\n-                        let external_module = Rc::new(Module::new(parent_link,\n-                                                                  Some(def_id),\n-                                                                  NormalModuleKind,\n-                                                                  false,\n-                                                                  true));\n-\n-                        parent.module().external_module_children\n-                              .borrow_mut().insert(name.name,\n-                                                   external_module.clone());\n-\n-                        self.build_reduced_graph_for_external_crate(\n-                            external_module);\n-                    }\n-                    None => {}  // Ignore.\n+                for &crate_id in self.session.cstore\n+                                     .find_extern_mod_stmt_cnum(node_id).iter() {\n+                    let def_id = DefId { krate: crate_id, node: 0 };\n+                    self.external_exports.insert(def_id);\n+                    let parent_link =\n+                        ModuleParentLink(parent.module().downgrade(), name);\n+                    let external_module = Rc::new(Module::new(parent_link,\n+                                                              Some(def_id),\n+                                                              NormalModuleKind,\n+                                                              false,\n+                                                              true));\n+                    debug!(\"(build reduced graph for item) found extern `{}`\",\n+                            self.module_to_str(&*external_module));\n+                    parent.module().external_module_children.borrow_mut()\n+                                   .insert(name.name, external_module.clone());\n+                    self.build_reduced_graph_for_external_crate(external_module);\n                 }\n             }\n         }\n@@ -1997,7 +1995,9 @@ impl<'a> Resolver<'a> {\n     fn resolve_imports_for_module_subtree(&mut self, module_: Rc<Module>) {\n         debug!(\"(resolving imports for module subtree) resolving {}\",\n                self.module_to_str(&*module_));\n+        let orig_module = replace(&mut self.current_module, module_.clone());\n         self.resolve_imports_for_module(module_.clone());\n+        self.current_module = orig_module;\n \n         self.populate_module_if_necessary(&module_);\n         for (_, child_node) in module_.children.borrow().iter() {\n@@ -2032,22 +2032,21 @@ impl<'a> Resolver<'a> {\n             let import_directive = imports.get(import_index);\n             match self.resolve_import_for_module(module.clone(),\n                                                  import_directive) {\n-                Failed => {\n-                    // We presumably emitted an error. Continue.\n-                    let msg = format!(\"failed to resolve import `{}`\",\n-                                   self.import_path_to_str(\n-                                       import_directive.module_path\n-                                                       .as_slice(),\n-                                       import_directive.subclass));\n-                    self.resolve_error(import_directive.span, msg.as_slice());\n-                }\n-                Indeterminate => {\n-                    // Bail out. We'll come around next time.\n-                    break;\n-                }\n-                Success(()) => {\n-                    // Good. Continue.\n+                Failed(err) => {\n+                    let (span, help) = match err {\n+                        Some((span, msg)) => (span, format!(\". {}\", msg)),\n+                        None => (import_directive.span, String::new())\n+                    };\n+                    let msg = format!(\"unresolved import `{}`{}\",\n+                                      self.import_path_to_str(\n+                                          import_directive.module_path\n+                                                          .as_slice(),\n+                                          import_directive.subclass),\n+                                      help);\n+                    self.resolve_error(span, msg.as_slice());\n                 }\n+                Indeterminate => break, // Bail out. We'll come around next time.\n+                Success(()) => () // Good. Continue.\n             }\n \n             module.resolved_import_count\n@@ -2111,7 +2110,7 @@ impl<'a> Resolver<'a> {\n                                  module_: Rc<Module>,\n                                  import_directive: &ImportDirective)\n                                  -> ResolveResult<()> {\n-        let mut resolution_result = Failed;\n+        let mut resolution_result = Failed(None);\n         let module_path = &import_directive.module_path;\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in \\\n@@ -2129,8 +2128,10 @@ impl<'a> Resolver<'a> {\n                                            DontUseLexicalScope,\n                                            import_directive.span,\n                                            ImportSearch) {\n-\n-                Failed => None,\n+                Failed(err) => {\n+                    resolution_result = Failed(err);\n+                    None\n+                },\n                 Indeterminate => {\n                     resolution_result = Indeterminate;\n                     None\n@@ -2408,12 +2409,10 @@ impl<'a> Resolver<'a> {\n         }\n \n         if value_result.is_unbound() && type_result.is_unbound() {\n-            let msg = format!(\"unresolved import: there is no \\\n-                               `{}` in `{}`\",\n+            let msg = format!(\"There is no `{}` in `{}`\",\n                               token::get_ident(source),\n                               self.module_to_str(&*containing_module));\n-            self.resolve_error(directive.span, msg.as_slice());\n-            return Failed;\n+            return Failed(Some((directive.span, msg)));\n         }\n         let value_used_public = value_used_reexport || value_used_public;\n         let type_used_public = type_used_reexport || type_used_public;\n@@ -2611,6 +2610,22 @@ impl<'a> Resolver<'a> {\n                                      name_search_type: NameSearchType,\n                                      lp: LastPrivate)\n                                 -> ResolveResult<(Rc<Module>, LastPrivate)> {\n+        fn search_parent_externals(needle: Name, module: &Rc<Module>)\n+                                -> Option<Rc<Module>> {\n+            module.external_module_children.borrow()\n+                                            .find_copy(&needle)\n+                                            .map(|_| module.clone())\n+                                            .or_else(|| {\n+                match module.parent_link.clone() {\n+                    ModuleParentLink(parent, _) => {\n+                        search_parent_externals(needle,\n+                                                &parent.upgrade().unwrap())\n+                    }\n+                   _ => None\n+                }\n+            })\n+        }\n+\n         let mut search_module = module_;\n         let mut index = index;\n         let module_path_len = module_path.len();\n@@ -2626,29 +2641,41 @@ impl<'a> Resolver<'a> {\n                                               TypeNS,\n                                               name_search_type,\n                                               false) {\n-                Failed => {\n+                Failed(None) => {\n                     let segment_name = token::get_ident(name);\n                     let module_name = self.module_to_str(&*search_module);\n-                    if \"???\" == module_name.as_slice() {\n-                        let span = Span {\n-                            lo: span.lo,\n-                            hi: span.lo + Pos::from_uint(segment_name.get().len()),\n-                            expn_info: span.expn_info,\n-                        };\n-                        self.resolve_error(span,\n-                                           format!(\"unresolved import. maybe \\\n-                                                    a missing `extern crate \\\n-                                                    {}`?\",\n-                                                   segment_name).as_slice());\n-                        return Failed;\n-                    }\n-                    self.resolve_error(span,\n-                                       format!(\"unresolved import: could not \\\n-                                                find `{}` in `{}`.\",\n-                                               segment_name,\n-                                               module_name).as_slice());\n-                    return Failed;\n+                    let mut span = span;\n+                    let msg = if \"???\" == module_name.as_slice() {\n+                        span.hi = span.lo + Pos::from_uint(segment_name.get().len());\n+\n+                        match search_parent_externals(name.name,\n+                                                     &self.current_module) {\n+                            Some(module) => {\n+                                let path_str = self.idents_to_str(module_path);\n+                                let target_mod_str = self.module_to_str(&*module);\n+                                let current_mod_str =\n+                                    self.module_to_str(&*self.current_module);\n+\n+                                let prefix = if target_mod_str == current_mod_str {\n+                                    \"self::\".to_string()\n+                                } else {\n+                                    format!(\"{}::\", target_mod_str)\n+                                };\n+\n+                                format!(\"Did you mean `{}{}`?\", prefix, path_str)\n+                            },\n+                            None => format!(\"Maybe a missing `extern crate {}`?\",\n+                                            segment_name),\n+                        }\n+                    } else {\n+                        format!(\"Could not find `{}` in `{}`.\",\n+                                segment_name,\n+                                module_name)\n+                    };\n+\n+                    return Failed(Some((span, msg)));\n                 }\n+                Failed(err) => return Failed(err),\n                 Indeterminate => {\n                     debug!(\"(resolving module path for import) module \\\n                             resolution is indeterminate: {}\",\n@@ -2662,13 +2689,10 @@ impl<'a> Resolver<'a> {\n                         Some(ref type_def) => {\n                             match type_def.module_def {\n                                 None => {\n-                                    // Not a module.\n-                                    self.resolve_error(\n-                                        span,\n-                                        format!(\"not a module `{}`\",\n-                                                token::get_ident(name))\n-                                                .as_slice());\n-                                    return Failed;\n+                                    let msg = format!(\"Not a module `{}`\",\n+                                                        token::get_ident(name));\n+\n+                                    return Failed(Some((span, msg)));\n                                 }\n                                 Some(ref module_def) => {\n                                     // If we're doing the search for an\n@@ -2678,11 +2702,10 @@ impl<'a> Resolver<'a> {\n                                            module_def.kind.get()) {\n                                         (ImportSearch, TraitModuleKind) |\n                                         (ImportSearch, ImplModuleKind) => {\n-                                            self.resolve_error(\n-                                                span,\n-                                                \"cannot import from a trait \\\n-                                                 or type implementation\");\n-                                            return Failed;\n+                                            let msg =\n+                                                \"Cannot import from a trait or \\\n+                                                type implementation\".to_string();\n+                                            return Failed(Some((span, msg)));\n                                         }\n                                         (_, _) => {\n                                             search_module = module_def.clone();\n@@ -2708,11 +2731,9 @@ impl<'a> Resolver<'a> {\n                         }\n                         None => {\n                             // There are no type bindings at all.\n-                            self.resolve_error(\n-                                span,\n-                                format!(\"not a module `{}`\",\n-                                        token::get_ident(name)).as_slice());\n-                            return Failed;\n+                            let msg = format!(\"Not a module `{}`\",\n+                                              token::get_ident(name));\n+                            return Failed(Some((span, msg)));\n                         }\n                     }\n                 }\n@@ -2752,24 +2773,22 @@ impl<'a> Resolver<'a> {\n         let start_index;\n         let last_private;\n         match module_prefix_result {\n-            Failed => {\n+            Failed(None) => {\n                 let mpath = self.idents_to_str(module_path);\n-                match mpath.as_slice().rfind(':') {\n+                let mpath = mpath.as_slice();\n+                match mpath.rfind(':') {\n                     Some(idx) => {\n-                        self.resolve_error(\n-                            span,\n-                            format!(\"unresolved import: could not find `{}` \\\n-                                     in `{}`\",\n-                                    // idx +- 1 to account for the colons on \\\n-                                    // either side\n-                                    mpath.as_slice().slice_from(idx + 1),\n-                                    mpath.as_slice()\n-                                         .slice_to(idx - 1)).as_slice());\n+                        let msg = format!(\"Could not find `{}` in `{}`\",\n+                                            // idx +- 1 to account for the\n+                                            // colons on either side\n+                                            mpath.slice_from(idx + 1),\n+                                            mpath.slice_to(idx - 1));\n+                        return Failed(Some((span, msg)));\n                     },\n-                    None => (),\n-                };\n-                return Failed;\n+                    None => return Failed(None),\n+                }\n             }\n+            Failed(err) => return Failed(err),\n             Indeterminate => {\n                 debug!(\"(resolving module path for import) indeterminate; \\\n                         bailing\");\n@@ -2791,14 +2810,10 @@ impl<'a> Resolver<'a> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        let result = self.resolve_module_in_lexical_scope(\n-                            module_,\n-                            module_path[0]);\n-                        match result {\n-                            Failed => {\n-                                self.resolve_error(span, \"unresolved name\");\n-                                return Failed;\n-                            }\n+                        match self.resolve_module_in_lexical_scope(\n+                                                            module_,\n+                                                            module_path[0]) {\n+                            Failed(err) => return Failed(err),\n                             Indeterminate => {\n                                 debug!(\"(resolving module path for import) \\\n                                         indeterminate; bailing\");\n@@ -2905,7 +2920,7 @@ impl<'a> Resolver<'a> {\n                     // No more parents. This module was unresolved.\n                     debug!(\"(resolving item in lexical scope) unresolved \\\n                             module\");\n-                    return Failed;\n+                    return Failed(None);\n                 }\n                 ModuleParentLink(parent_module_node, _) => {\n                     match search_module.kind.get() {\n@@ -2915,7 +2930,7 @@ impl<'a> Resolver<'a> {\n                                     scope) unresolved module: not \\\n                                     searching through module \\\n                                     parents\");\n-                            return Failed;\n+                            return Failed(None);\n                         }\n                         ExternModuleKind |\n                         TraitModuleKind |\n@@ -2936,9 +2951,10 @@ impl<'a> Resolver<'a> {\n                                               namespace,\n                                               PathSearch,\n                                               true) {\n-                Failed => {\n-                    // Continue up the search chain.\n-                }\n+                Failed(Some((span, msg))) =>\n+                    self.resolve_error(span, format!(\"failed to resolve. {}\",\n+                                                     msg)),\n+                Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n                     // We couldn't see through the higher scope because of an\n                     // unresolved import higher up. Bail.\n@@ -2976,7 +2992,7 @@ impl<'a> Resolver<'a> {\n                                 debug!(\"!!! (resolving module in lexical \\\n                                         scope) module wasn't actually a \\\n                                         module!\");\n-                                return Failed;\n+                                return Failed(None);\n                             }\n                             Some(ref module_def) => {\n                                 return Success(module_def.clone());\n@@ -2986,7 +3002,7 @@ impl<'a> Resolver<'a> {\n                     None => {\n                         debug!(\"!!! (resolving module in lexical scope) module\n                                 wasn't actually a module!\");\n-                        return Failed;\n+                        return Failed(None);\n                     }\n                 }\n             }\n@@ -2995,10 +3011,9 @@ impl<'a> Resolver<'a> {\n                         bailing\");\n                 return Indeterminate;\n             }\n-            Failed => {\n-                debug!(\"(resolving module in lexical scope) failed to \\\n-                        resolve\");\n-                return Failed;\n+            Failed(err) => {\n+                debug!(\"(resolving module in lexical scope) failed to resolve\");\n+                return Failed(err);\n             }\n         }\n     }\n@@ -3076,7 +3091,7 @@ impl<'a> Resolver<'a> {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    self.module_to_str(&*containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n-                None => return Failed,\n+                None => return Failed(None),\n                 Some(new_module) => {\n                     containing_module = new_module;\n                     i += 1;\n@@ -3173,7 +3188,7 @@ impl<'a> Resolver<'a> {\n         // We're out of luck.\n         debug!(\"(resolving name in module) failed to resolve `{}`\",\n                token::get_name(name).get());\n-        return Failed;\n+        return Failed(None);\n     }\n \n     fn report_unresolved_imports(&mut self, module_: Rc<Module>) {\n@@ -4531,8 +4546,15 @@ impl<'a> Resolver<'a> {\n             Indeterminate => {\n                 fail!(\"unexpected indeterminate result\");\n             }\n+            Failed(err) => {\n+                match err {\n+                    Some((span, msg)) => {\n+                        self.resolve_error(span, format!(\"failed to resolve: {}\",\n+                                                         msg));\n+                    }\n+                    None => ()\n+                }\n \n-            Failed => {\n                 debug!(\"(resolve bare identifier pattern) failed to find {}\",\n                         token::get_ident(name));\n                 return BareIdentifierPatternUnresolved;\n@@ -4697,17 +4719,22 @@ impl<'a> Resolver<'a> {\n                                        UseLexicalScope,\n                                        path.span,\n                                        PathSearch) {\n-            Failed => {\n-                let msg = format!(\"use of undeclared module `{}`\",\n-                                  self.idents_to_str(module_path_idents.as_slice()));\n-                self.resolve_error(path.span, msg.as_slice());\n-                return None;\n-            }\n+            Failed(err) => {\n+                let (span, msg) = match err {\n+                    Some((span, msg)) => (span, msg),\n+                    None => {\n+                        let msg = format!(\"Use of undeclared module `{}`\",\n+                                          self.idents_to_str(\n+                                               module_path_idents.as_slice()));\n+                        (path.span, msg)\n+                    }\n+                };\n \n-            Indeterminate => {\n-                fail!(\"indeterminate unexpected\");\n+                self.resolve_error(span, format!(\"failed to resolve. {}\",\n+                                                 msg.as_slice()));\n+                return None;\n             }\n-\n+            Indeterminate => fail!(\"indeterminate unexpected\"),\n             Success((resulting_module, resulting_last_private)) => {\n                 containing_module = resulting_module;\n                 last_private = resulting_last_private;\n@@ -4768,10 +4795,19 @@ impl<'a> Resolver<'a> {\n                                                  path.span,\n                                                  PathSearch,\n                                                  LastMod(AllPublic)) {\n-            Failed => {\n-                let msg = format!(\"use of undeclared module `::{}`\",\n-                                  self.idents_to_str(module_path_idents.as_slice()));\n-                self.resolve_error(path.span, msg.as_slice());\n+            Failed(err) => {\n+                let (span, msg) = match err {\n+                    Some((span, msg)) => (span, msg),\n+                    None => {\n+                        let msg = format!(\"Use of undeclared module `::{}`\",\n+                                          self.idents_to_str(\n+                                               module_path_idents.as_slice()));\n+                        (path.span, msg)\n+                    }\n+                };\n+\n+                self.resolve_error(span, format!(\"failed to resolve. {}\",\n+                                                 msg.as_slice()));\n                 return None;\n             }\n \n@@ -4864,7 +4900,13 @@ impl<'a> Resolver<'a> {\n             Indeterminate => {\n                 fail!(\"unexpected indeterminate result\");\n             }\n-            Failed => {\n+            Failed(err) => {\n+                match err {\n+                    Some((span, msg)) =>\n+                        self.resolve_error(span, format!(\"failed to resolve. {}\", msg)),\n+                    None => ()\n+                }\n+\n                 debug!(\"(resolving item path by identifier in lexical scope) \\\n                          failed to resolve {}\", token::get_ident(ident));\n                 return None;\n@@ -4879,9 +4921,9 @@ impl<'a> Resolver<'a> {\n         rs\n     }\n \n-    fn resolve_error(&self, span: Span, s: &str) {\n+    fn resolve_error<T: Str>(&self, span: Span, s: T) {\n         if self.emit_errors {\n-            self.session.span_err(span, s);\n+            self.session.span_err(span, s.as_slice());\n         }\n     }\n \n@@ -5480,7 +5522,7 @@ impl<'a> Resolver<'a> {\n     //\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n-    fn module_to_str(&mut self, module: &Module) -> String {\n+    fn module_to_str(&self, module: &Module) -> String {\n         let mut idents = Vec::new();\n \n         fn collect_mod(idents: &mut Vec<ast::Ident>, module: &Module) {"}, {"sha": "3814656282585f65a25cd9dd19a1d0e6e2087570", "filename": "src/test/compile-fail-fulldeps/phase-syntax-doesnt-resolve.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail-fulldeps%2Fphase-syntax-doesnt-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail-fulldeps%2Fphase-syntax-doesnt-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fphase-syntax-doesnt-resolve.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -19,7 +19,6 @@ extern crate macro_crate_test;\n \n fn main() {\n     macro_crate_test::foo();\n-    //~^ ERROR unresolved name\n-    //~^^ ERROR use of undeclared module `macro_crate_test`\n-    //~^^^ ERROR unresolved name `macro_crate_test::foo`.\n+    //~^ ERROR failed to resolve. Use of undeclared module `macro_crate_test`\n+    //~^^ ERROR unresolved name `macro_crate_test::foo`.\n }"}, {"sha": "f393442de10110aefbe849dd157bc64130746948", "filename": "src/test/compile-fail/import-from-missing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fimport-from-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fimport-from-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-from-missing.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:failed to resolve import\n use spam::{ham, eggs};\n+//~^ ERROR unresolved import `spam::eggs`. There is no `eggs` in `spam`\n \n mod spam {\n     pub fn ham() { }"}, {"sha": "844d527a546077a1600c958deeecc6dce9e17caf", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:failed to resolve import\n use zed::bar;\n use zed::baz;\n+//~^ ERROR unresolved import `zed::baz`. There is no `baz` in `zed`\n \n \n mod zed {"}, {"sha": "f674d19ca5c9a8b6055388ce1fdb33e12a86f2ed", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use baz::zed::bar;  //~ ERROR unresolved import\n-//~^ ERROR failed to resolve import\n+use baz::zed::bar;\n+//~^ ERROR unresolved import `baz::zed::bar`. Could not find `zed` in `baz`.\n \n \n mod baz {}"}, {"sha": "ee998e57c56c9ac806276e5bc28da356fc6c6c6e", "filename": "src/test/compile-fail/issue-12612.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fissue-12612.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fissue-12612.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12612.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -16,8 +16,7 @@ use foo::bar;\n \n mod test {\n     use bar::foo;\n-    //~^ ERROR: unresolved import\n-    //~^^ ERROR: failed to resolve import\n+    //~^ ERROR unresolved import `bar::foo`. Maybe a missing `extern crate bar`?\n }\n \n fn main() {}"}, {"sha": "355be1562df2bdb555c5acaff7d0ee4d76ce5283", "filename": "src/test/compile-fail/issue-13404.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fissue-13404.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fissue-13404.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13404.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -10,8 +10,7 @@\n \n use a::f;\n use b::f;\n-//~^ ERROR: unresolved import\n-//~^^ ERROR: failed to resolve import\n+//~^ ERROR: unresolved import `b::f`. There is no `f` in `b`\n \n mod a { pub fn f() {} }\n mod b { }"}, {"sha": "46d9a558d9ea973bf8b6e3c75a45e5680b334c1b", "filename": "src/test/compile-fail/issue-1697.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -12,8 +12,6 @@\n \n #![feature(globs)]\n \n-use unresolved::*; //~ ERROR unresolved import. maybe a missing\n-//~^ ERROR failed to resolve import\n+use unresolved::*; //~ ERROR unresolved import `unresolved::*`. Maybe a missing `extern crate unres\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "335012cedb84c1335e1e1136cfddbf41cdda44fb", "filename": "src/test/compile-fail/issue-2123.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fissue-2123.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fissue-2123.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2123.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use x = m::f; //~ ERROR failed to resolve import\n-              //~^ unresolved import: there is no `f` in `m`\n+use x = m::f; //~ ERROR unresolved import `m::f`. There is no `f` in `m`\n \n-mod m {\n-}\n+mod m {}\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "335012cedb84c1335e1e1136cfddbf41cdda44fb", "filename": "src/test/compile-fail/issue-2937.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fissue-2937.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fissue-2937.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2937.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use x = m::f; //~ ERROR failed to resolve import\n-              //~^ ERROR unresolved import: there is no `f` in `m`\n+use x = m::f; //~ ERROR unresolved import `m::f`. There is no `f` in `m`\n \n-mod m {\n-}\n+mod m {}\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "3e731a2d2fed4b3e32ee83d5f682278d1ec5e5ba", "filename": "src/test/compile-fail/macro-inner-attributes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -25,9 +25,8 @@ test!(b,\n #[qux]\n fn main() {\n     a::bar();\n-    //~^ ERROR use of undeclared module `a`\n-    //~^^ ERROR unresolved name\n-    //~^^^ ERROR unresolved name `a::bar`\n+    //~^ ERROR failed to resolve. Use of undeclared module `a`\n+    //~^^ ERROR unresolved name `a::bar`\n     b::bar();\n }\n "}, {"sha": "5a5b6eb8436d71d62a9d83e240930248d3bac1d4", "filename": "src/test/compile-fail/privacy2.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -24,14 +24,13 @@ mod bar {\n pub fn foo() {}\n \n fn test1() {\n-    use bar::foo; //~ ERROR: unresolved import\n-    //~^ ERROR: failed to resolve\n+    use bar::foo;\n+    //~^ ERROR unresolved import `bar::foo`. There is no `foo` in `bar`\n }\n \n fn test2() {\n     use bar::glob::foo;\n-    //~^ ERROR: there is no\n-    //~^^ ERROR: failed to resolve\n+    //~^ ERROR unresolved import `bar::glob::foo`. There is no `foo` in `bar::glob`\n }\n \n #[start] fn main(_: int, _: **u8) -> int { 3 }"}, {"sha": "6898a0cde17f569854427ddfc1bf16357dd5c135", "filename": "src/test/compile-fail/privacy3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fprivacy3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fprivacy3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy3.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -25,8 +25,8 @@ mod bar {\n pub fn foo() {}\n \n fn test1() {\n-    use bar::gpriv; //~ ERROR: unresolved import\n-    //~^ ERROR: failed to resolve\n+    use bar::gpriv;\n+    //~^ ERROR unresolved import `bar::gpriv`. There is no `gpriv` in `bar`\n     gpriv();\n }\n "}, {"sha": "ed143fdff687f1098c884bcd077446c1d591938a", "filename": "src/test/compile-fail/resolve_self_super_hint.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {\n+    extern crate collections;\n+    use collections::HashMap;\n+//~^ ERROR unresolved import `collections::HashMap`. Did you mean `self::collections`?\n+    mod b {\n+        use collections::HashMap;\n+//~^ ERROR unresolved import `collections::HashMap`. Did you mean `a::collections`?\n+        mod c {\n+            use collections::HashMap;\n+//~^ ERROR unresolved import `collections::HashMap`. Did you mean `a::collections`?\n+            mod d {\n+                use collections::HashMap;\n+//~^ ERROR unresolved import `collections::HashMap`. Did you mean `a::collections`?\n+            }\n+        }\n+    }\n+}"}, {"sha": "309b6773f604ef5a3a223b4a060d3f2b5b96cd7f", "filename": "src/test/compile-fail/super-at-top-level.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::f; //~ ERROR failed to resolve import\n+use super::f; //~ ERROR unresolved import `super::f`\n \n fn main() {\n }"}, {"sha": "b5dcd5d165d4c0477cf0caab38b284569f636db7", "filename": "src/test/compile-fail/unresolved-import.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use foo::bar; //~ ERROR unresolved import. maybe a missing `extern crate foo`?\n-              //~^ ERROR failed to resolve import `foo::bar`\n-use x = bar::baz; //~ ERROR unresolved import: there is no `baz` in `bar`\n-                  //~^ ERROR failed to resolve import `bar::baz`\n+use foo::bar; //~ ERROR unresolved import `foo::bar`. Maybe a missing `extern crate foo`?\n+\n+use x = bar::baz; //~ ERROR unresolved import `bar::baz`. There is no `baz` in `bar`\n \n mod bar {\n     struct bar;"}, {"sha": "8e197b901e610b5a3395756c7a0ed76a89b050ec", "filename": "src/test/compile-fail/use-from-trait-xc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -12,10 +12,10 @@\n \n extern crate use_from_trait_xc;\n \n-use use_from_trait_xc::Trait::foo;  //~ ERROR cannot import from a trait or type implementation\n-//~^ ERROR failed to resolve import\n-use use_from_trait_xc::Foo::new;    //~ ERROR cannot import from a trait or type implementation\n-//~^ ERROR failed to resolve import\n+use use_from_trait_xc::Trait::foo;\n+//~^ ERROR unresolved import `use_from_trait_xc::Trait::foo`. Cannot import from a trait or type imp\n \n-fn main() {\n-}\n+use use_from_trait_xc::Foo::new;\n+//~^ ERROR unresolved import `use_from_trait_xc::Foo::new`. Cannot import from a trait or type imple\n+\n+fn main() {}"}, {"sha": "c9eea3c5df255a05af6c61dad67b9397b8aaab52", "filename": "src/test/compile-fail/use-from-trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557b9e7f0f2010a15ab6f93f02bacf52bb1f696d/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs?ref=557b9e7f0f2010a15ab6f93f02bacf52bb1f696d", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use Trait::foo;  //~ ERROR cannot import from a trait or type implementation\n-//~^ ERROR failed to resolve import\n-use Foo::new;    //~ ERROR cannot import from a trait or type implementation\n-//~^ ERROR failed to resolve import\n+use Trait::foo;\n+//~^ ERROR unresolved import `Trait::foo`. Cannot import from a trait or type implementation\n+use Foo::new;\n+//~^ ERROR unresolved import `Foo::new`. Cannot import from a trait or type implementation\n \n pub trait Trait {\n     fn foo();"}]}