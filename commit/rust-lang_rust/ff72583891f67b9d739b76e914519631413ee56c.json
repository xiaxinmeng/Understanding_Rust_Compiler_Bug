{"sha": "ff72583891f67b9d739b76e914519631413ee56c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNzI1ODM4OTFmNjdiOWQ3MzliNzZlOTE0NTE5NjMxNDEzZWU1NmM=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-09-04T05:25:22Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-09-04T17:31:45Z"}, "message": "Attach documentation to the bitflags! macro itself\n\nThis is in consistent with the style demonstrated in the std::macros module.", "tree": {"sha": "d5870bd11e7ee79fa7a48bbd6227fe9238832461", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5870bd11e7ee79fa7a48bbd6227fe9238832461"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff72583891f67b9d739b76e914519631413ee56c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff72583891f67b9d739b76e914519631413ee56c", "html_url": "https://github.com/rust-lang/rust/commit/ff72583891f67b9d739b76e914519631413ee56c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff72583891f67b9d739b76e914519631413ee56c/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca60b743d7755f486158318212d33f0cc99a81ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca60b743d7755f486158318212d33f0cc99a81ed", "html_url": "https://github.com/rust-lang/rust/commit/ca60b743d7755f486158318212d33f0cc99a81ed"}], "stats": {"total": 195, "additions": 98, "deletions": 97}, "files": [{"sha": "f540398fcaa94ab179851b2da91c1213ef7e28aa", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 98, "deletions": 97, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/ff72583891f67b9d739b76e914519631413ee56c/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff72583891f67b9d739b76e914519631413ee56c/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=ff72583891f67b9d739b76e914519631413ee56c", "patch": "@@ -8,106 +8,107 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The `bitflags!` macro generates a `struct` that holds a set of C-style\n-//! bitmask flags. It is useful for creating typesafe wrappers for C APIs.\n-//!\n-//! The flags should only be defined for integer types, otherwise unexpected\n-//! type errors may occur at compile time.\n-//!\n-//! # Example\n-//!\n-//! ~~~rust\n-//! bitflags!(\n-//!     flags Flags: u32 {\n-//!         static FlagA       = 0x00000001,\n-//!         static FlagB       = 0x00000010,\n-//!         static FlagC       = 0x00000100,\n-//!         static FlagABC     = FlagA.bits\n-//!                            | FlagB.bits\n-//!                            | FlagC.bits,\n-//!     }\n-//! )\n-//!\n-//! fn main() {\n-//!     let e1 = FlagA | FlagC;\n-//!     let e2 = FlagB | FlagC;\n-//!     assert!((e1 | e2) == FlagABC);   // union\n-//!     assert!((e1 & e2) == FlagC);     // intersection\n-//!     assert!((e1 - e2) == FlagA);     // set difference\n-//!     assert!(!e2 == FlagA);           // set complement\n-//! }\n-//! ~~~\n-//!\n-//! The generated `struct`s can also be extended with type and trait implementations:\n-//!\n-//! ~~~rust\n-//! use std::fmt;\n-//!\n-//! bitflags!(\n-//!     flags Flags: u32 {\n-//!         static FlagA   = 0x00000001,\n-//!         static FlagB   = 0x00000010,\n-//!     }\n-//! )\n-//!\n-//! impl Flags {\n-//!     pub fn clear(&mut self) {\n-//!         self.bits = 0;  // The `bits` field can be accessed from within the\n-//!                         // same module where the `bitflags!` macro was invoked.\n-//!     }\n-//! }\n-//!\n-//! impl fmt::Show for Flags {\n-//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-//!         write!(f, \"hi!\")\n-//!     }\n-//! }\n-//!\n-//! fn main() {\n-//!     let mut flags = FlagA | FlagB;\n-//!     flags.clear();\n-//!     assert!(flags.is_empty());\n-//!     assert_eq!(format!(\"{}\", flags).as_slice(), \"hi!\");\n-//! }\n-//! ~~~\n-//!\n-//! # Attributes\n-//!\n-//! Attributes can be attached to the generated `struct` by placing them\n-//! before the `flags` keyword.\n-//!\n-//! # Derived traits\n-//!\n-//! The `PartialEq` and `Clone` traits are automatically derived for the `struct` using\n-//! the `deriving` attribute. Additional traits can be derived by providing an\n-//! explicit `deriving` attribute on `flags`.\n-//!\n-//! # Operators\n-//!\n-//! The following operator traits are implemented for the generated `struct`:\n-//!\n-//! - `BitOr`: union\n-//! - `BitAnd`: intersection\n-//! - `Sub`: set difference\n-//! - `Not`: set complement\n-//!\n-//! # Methods\n-//!\n-//! The following methods are defined for the generated `struct`:\n-//!\n-//! - `empty`: an empty set of flags\n-//! - `all`: the set of all flags\n-//! - `bits`: the raw value of the flags currently stored\n-//! - `is_empty`: `true` if no flags are currently stored\n-//! - `is_all`: `true` if all flags are currently set\n-//! - `intersects`: `true` if there are flags common to both `self` and `other`\n-//! - `contains`: `true` all of the flags in `other` are contained within `self`\n-//! - `insert`: inserts the specified flags in-place\n-//! - `remove`: removes the specified flags in-place\n-\n #![experimental]\n #![macro_escape]\n \n+//! A typesafe bitmask flag generator.\n+\n+/// The `bitflags!` macro generates a `struct` that holds a set of C-style\n+/// bitmask flags. It is useful for creating typesafe wrappers for C APIs.\n+///\n+/// The flags should only be defined for integer types, otherwise unexpected\n+/// type errors may occur at compile time.\n+///\n+/// # Example\n+///\n+/// ~~~rust\n+/// bitflags!(\n+///     flags Flags: u32 {\n+///         static FlagA       = 0x00000001,\n+///         static FlagB       = 0x00000010,\n+///         static FlagC       = 0x00000100,\n+///         static FlagABC     = FlagA.bits\n+///                            | FlagB.bits\n+///                            | FlagC.bits,\n+///     }\n+/// )\n+///\n+/// fn main() {\n+///     let e1 = FlagA | FlagC;\n+///     let e2 = FlagB | FlagC;\n+///     assert!((e1 | e2) == FlagABC);   // union\n+///     assert!((e1 & e2) == FlagC);     // intersection\n+///     assert!((e1 - e2) == FlagA);     // set difference\n+///     assert!(!e2 == FlagA);           // set complement\n+/// }\n+/// ~~~\n+///\n+/// The generated `struct`s can also be extended with type and trait implementations:\n+///\n+/// ~~~rust\n+/// use std::fmt;\n+///\n+/// bitflags!(\n+///     flags Flags: u32 {\n+///         static FlagA   = 0x00000001,\n+///         static FlagB   = 0x00000010,\n+///     }\n+/// )\n+///\n+/// impl Flags {\n+///     pub fn clear(&mut self) {\n+///         self.bits = 0;  // The `bits` field can be accessed from within the\n+///                         // same module where the `bitflags!` macro was invoked.\n+///     }\n+/// }\n+///\n+/// impl fmt::Show for Flags {\n+///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+///         write!(f, \"hi!\")\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut flags = FlagA | FlagB;\n+///     flags.clear();\n+///     assert!(flags.is_empty());\n+///     assert_eq!(format!(\"{}\", flags).as_slice(), \"hi!\");\n+/// }\n+/// ~~~\n+///\n+/// # Attributes\n+///\n+/// Attributes can be attached to the generated `struct` by placing them\n+/// before the `flags` keyword.\n+///\n+/// # Derived traits\n+///\n+/// The `PartialEq` and `Clone` traits are automatically derived for the `struct` using\n+/// the `deriving` attribute. Additional traits can be derived by providing an\n+/// explicit `deriving` attribute on `flags`.\n+///\n+/// # Operators\n+///\n+/// The following operator traits are implemented for the generated `struct`:\n+///\n+/// - `BitOr`: union\n+/// - `BitAnd`: intersection\n+/// - `Sub`: set difference\n+/// - `Not`: set complement\n+///\n+/// # Methods\n+///\n+/// The following methods are defined for the generated `struct`:\n+///\n+/// - `empty`: an empty set of flags\n+/// - `all`: the set of all flags\n+/// - `bits`: the raw value of the flags currently stored\n+/// - `is_empty`: `true` if no flags are currently stored\n+/// - `is_all`: `true` if all flags are currently set\n+/// - `intersects`: `true` if there are flags common to both `self` and `other`\n+/// - `contains`: `true` all of the flags in `other` are contained within `self`\n+/// - `insert`: inserts the specified flags in-place\n+/// - `remove`: removes the specified flags in-place\n #[macro_export]\n macro_rules! bitflags(\n     ($(#[$attr:meta])* flags $BitFlags:ident: $T:ty {"}]}