{"sha": "7355d971a954ed63293e4191f6677f60c1bc07d9", "node_id": "C_kwDOAAsO6NoAKDczNTVkOTcxYTk1NGVkNjMyOTNlNDE5MWY2Njc3ZjYwYzFiYzA3ZDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-17T06:51:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-17T06:51:45Z"}, "message": "Auto merge of #96825 - kckeiks:remove-item-like-visitor-trait, r=cjgillot\n\n Retire `ItemLikeVisitor` trait\n\nIssue #95004\ncc `@cjgillot`", "tree": {"sha": "9a7af35fa8a2bfd6eb06840114de6a625ba84f54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a7af35fa8a2bfd6eb06840114de6a625ba84f54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7355d971a954ed63293e4191f6677f60c1bc07d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7355d971a954ed63293e4191f6677f60c1bc07d9", "html_url": "https://github.com/rust-lang/rust/commit/7355d971a954ed63293e4191f6677f60c1bc07d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7355d971a954ed63293e4191f6677f60c1bc07d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e8cd63d60d55361ae0a62ce87280171d40b6d32", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e8cd63d60d55361ae0a62ce87280171d40b6d32", "html_url": "https://github.com/rust-lang/rust/commit/1e8cd63d60d55361ae0a62ce87280171d40b6d32"}, {"sha": "48fd66613b17aabba3c20557d5802d2cdd122e71", "url": "https://api.github.com/repos/rust-lang/rust/commits/48fd66613b17aabba3c20557d5802d2cdd122e71", "html_url": "https://github.com/rust-lang/rust/commit/48fd66613b17aabba3c20557d5802d2cdd122e71"}], "stats": {"total": 1431, "additions": 640, "deletions": 791}, "files": [{"sha": "1254d3a1618562b51787d667c6d2afada44dac21", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 36, "deletions": 44, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -1,7 +1,40 @@\n //! HIR walker for walking the contents of nodes.\n //!\n-//! **For an overview of the visitor strategy, see the docs on the\n-//! `super::itemlikevisit::ItemLikeVisitor` trait.**\n+//! Here are the three available patterns for the visitor strategy,\n+//! in roughly the order of desirability:\n+//!\n+//! 1. **Shallow visit**: Get a simple callback for every item (or item-like thing) in the HIR.\n+//!    - Example: find all items with a `#[foo]` attribute on them.\n+//!    - How: Use the `hir_crate_items` or `hir_module_items` query to traverse over item-like ids\n+//!       (ItemId, TraitItemId, etc.) and use tcx.def_kind and `tcx.hir().item*(id)` to filter and\n+//!       access actual item-like thing, respectively.\n+//!    - Pro: Efficient; just walks the lists of item ids and gives users control whether to access\n+//!       the hir_owners themselves or not.\n+//!    - Con: Don't get information about nesting\n+//!    - Con: Don't have methods for specific bits of HIR, like \"on\n+//!      every expr, do this\".\n+//! 2. **Deep visit**: Want to scan for specific kinds of HIR nodes within\n+//!    an item, but don't care about how item-like things are nested\n+//!    within one another.\n+//!    - Example: Examine each expression to look for its type and do some check or other.\n+//!    - How: Implement `intravisit::Visitor` and override the `NestedFilter` type to\n+//!      `nested_filter::OnlyBodies` (and implement `nested_visit_map`), and use\n+//!      `tcx.hir().deep_visit_all_item_likes(&mut visitor)`. Within your\n+//!      `intravisit::Visitor` impl, implement methods like `visit_expr()` (don't forget to invoke\n+//!      `intravisit::walk_expr()` to keep walking the subparts).\n+//!    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n+//!    - Pro: Integrates well into dependency tracking.\n+//!    - Con: Don't get information about nesting between items\n+//! 3. **Nested visit**: Want to visit the whole HIR and you care about the nesting between\n+//!    item-like things.\n+//!    - Example: Lifetime resolution, which wants to bring lifetimes declared on the\n+//!      impl into scope while visiting the impl-items, and then back out again.\n+//!    - How: Implement `intravisit::Visitor` and override the `NestedFilter` type to\n+//!      `nested_filter::All` (and implement `nested_visit_map`). Walk your crate with\n+//!      `tcx.hir().walk_toplevel_module(visitor)` invoked on `tcx.hir().krate()`.\n+//!    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n+//!    - Pro: Preserves nesting information\n+//!    - Con: Does not integrate well into dependency tracking.\n //!\n //! If you have decided to use this visitor, here are some general\n //! notes on how to do so:\n@@ -32,43 +65,12 @@\n //! example generator inference, and possibly also HIR borrowck.\n \n use crate::hir::*;\n-use crate::itemlikevisit::{ItemLikeVisitor, ParItemLikeVisitor};\n+use crate::itemlikevisit::ParItemLikeVisitor;\n use rustc_ast::walk_list;\n use rustc_ast::{Attribute, Label};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n \n-pub struct DeepVisitor<'v, V> {\n-    visitor: &'v mut V,\n-}\n-\n-impl<'v, V> DeepVisitor<'v, V> {\n-    pub fn new(base: &'v mut V) -> Self {\n-        DeepVisitor { visitor: base }\n-    }\n-}\n-\n-impl<'v, 'hir, V> ItemLikeVisitor<'hir> for DeepVisitor<'v, V>\n-where\n-    V: Visitor<'hir>,\n-{\n-    fn visit_item(&mut self, item: &'hir Item<'hir>) {\n-        self.visitor.visit_item(item);\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'hir TraitItem<'hir>) {\n-        self.visitor.visit_trait_item(trait_item);\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'hir ImplItem<'hir>) {\n-        self.visitor.visit_impl_item(impl_item);\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &'hir ForeignItem<'hir>) {\n-        self.visitor.visit_foreign_item(foreign_item);\n-    }\n-}\n-\n pub trait IntoVisitor<'hir> {\n     type Visitor: Visitor<'hir>;\n     fn into_visitor(&self) -> Self::Visitor;\n@@ -315,16 +317,6 @@ pub trait Visitor<'v>: Sized {\n         walk_body(self, b);\n     }\n \n-    /// When invoking `visit_all_item_likes()`, you need to supply an\n-    /// item-like visitor. This method converts an \"intra-visit\"\n-    /// visitor into an item-like visitor that walks the entire tree.\n-    /// If you use this, you probably don't want to process the\n-    /// contents of nested item-like things, since the outer loop will\n-    /// visit them as well.\n-    fn as_deep_visitor(&mut self) -> DeepVisitor<'_, Self> {\n-        DeepVisitor::new(self)\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n \n     fn visit_id(&mut self, _hir_id: HirId) {"}, {"sha": "a490268dc9f94d46b4b6d8edca2ade54a807e656", "filename": "compiler/rustc_hir/src/itemlikevisit.rs", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_hir%2Fsrc%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_hir%2Fsrc%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fitemlikevisit.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -1,55 +1,5 @@\n use super::{ForeignItem, ImplItem, Item, TraitItem};\n \n-/// The \"item-like visitor\" defines only the top-level methods\n-/// that can be invoked by `Crate::visit_all_item_likes()`. Whether\n-/// this trait is the right one to implement will depend on the\n-/// overall pattern you need. Here are the three available patterns,\n-/// in roughly the order of desirability:\n-///\n-/// 1. **Shallow visit**: Get a simple callback for every item (or item-like thing) in the HIR.\n-///    - Example: find all items with a `#[foo]` attribute on them.\n-///    - How: Implement `ItemLikeVisitor` and call `tcx.hir().visit_all_item_likes()`.\n-///    - Pro: Efficient; just walks the lists of item-like things, not the nodes themselves.\n-///    - Con: Don't get information about nesting\n-///    - Con: Don't have methods for specific bits of HIR, like \"on\n-///      every expr, do this\".\n-/// 2. **Deep visit**: Want to scan for specific kinds of HIR nodes within\n-///    an item, but don't care about how item-like things are nested\n-///    within one another.\n-///    - Example: Examine each expression to look for its type and do some check or other.\n-///    - How: Implement `intravisit::Visitor` and override the `NestedFilter` type to\n-///      `nested_filter::OnlyBodies` (and implement `nested_visit_map`), and use\n-///      `tcx.hir().visit_all_item_likes(&mut visitor.as_deep_visitor())`. Within your\n-///      `intravisit::Visitor` impl, implement methods like `visit_expr()` (don't forget to invoke\n-///      `intravisit::walk_expr()` to keep walking the subparts).\n-///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n-///    - Pro: Integrates well into dependency tracking.\n-///    - Con: Don't get information about nesting between items\n-/// 3. **Nested visit**: Want to visit the whole HIR and you care about the nesting between\n-///    item-like things.\n-///    - Example: Lifetime resolution, which wants to bring lifetimes declared on the\n-///      impl into scope while visiting the impl-items, and then back out again.\n-///    - How: Implement `intravisit::Visitor` and override the `NestedFilter` type to\n-///      `nested_filter::All` (and implement `nested_visit_map`). Walk your crate with\n-///      `tcx.hir().walk_toplevel_module(visitor)` invoked on `tcx.hir().krate()`.\n-///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n-///    - Pro: Preserves nesting information\n-///    - Con: Does not integrate well into dependency tracking.\n-///\n-/// Note: the methods of `ItemLikeVisitor` intentionally have no\n-/// defaults, so that as we expand the list of item-like things, we\n-/// revisit the various visitors to see if they need to change. This\n-/// is harder to do with `intravisit::Visitor`, so when you add a new\n-/// `visit_nested_foo()` method, it is recommended that you search for\n-/// existing `fn visit_nested` methods to see where changes are\n-/// needed.\n-pub trait ItemLikeVisitor<'hir> {\n-    fn visit_item(&mut self, item: &'hir Item<'hir>);\n-    fn visit_trait_item(&mut self, trait_item: &'hir TraitItem<'hir>);\n-    fn visit_impl_item(&mut self, impl_item: &'hir ImplItem<'hir>);\n-    fn visit_foreign_item(&mut self, foreign_item: &'hir ForeignItem<'hir>);\n-}\n-\n /// A parallel variant of `ItemLikeVisitor`.\n pub trait ParItemLikeVisitor<'hir> {\n     fn visit_item(&self, item: &'hir Item<'hir>);"}, {"sha": "a89b9eafaa62d6e24825306622e6aeff2ed9c939", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -75,7 +75,7 @@ pub fn assert_dep_graph(tcx: TyCtxt<'_>) {\n             let mut visitor =\n                 IfThisChanged { tcx, if_this_changed: vec![], then_this_would_need: vec![] };\n             visitor.process_attrs(hir::CRATE_HIR_ID);\n-            tcx.hir().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+            tcx.hir().deep_visit_all_item_likes(&mut visitor);\n             (visitor.if_this_changed, visitor.then_this_would_need)\n         };\n "}, {"sha": "ebf6a5521702b75a0c6ff85384d556bd63b151e9", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -14,7 +14,6 @@ use rustc_hir::def_id::{\n };\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items;\n use rustc_hir::{AnonConst, GenericParamKind};\n use rustc_index::bit_set::GrowableBitSet;\n@@ -453,7 +452,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             return;\n         }\n \n-        self.tcx.hir().visit_all_item_likes(&mut self.as_deep_visitor());\n+        self.tcx.hir().deep_visit_all_item_likes(self);\n     }\n \n     fn encode_def_path_table(&mut self) {\n@@ -2243,26 +2242,16 @@ pub fn provide(providers: &mut Providers) {\n         traits_in_crate: |tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n \n-            #[derive(Default)]\n-            struct TraitsVisitor {\n-                traits: Vec<DefId>,\n-            }\n-            impl ItemLikeVisitor<'_> for TraitsVisitor {\n-                fn visit_item(&mut self, item: &hir::Item<'_>) {\n-                    if let hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..) = item.kind {\n-                        self.traits.push(item.def_id.to_def_id());\n-                    }\n+            let mut traits = Vec::new();\n+            for id in tcx.hir().items() {\n+                if matches!(tcx.def_kind(id.def_id), DefKind::Trait | DefKind::TraitAlias) {\n+                    traits.push(id.def_id.to_def_id())\n                 }\n-                fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n-                fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {}\n-                fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n             }\n \n-            let mut visitor = TraitsVisitor::default();\n-            tcx.hir().visit_all_item_likes(&mut visitor);\n             // Bring everything into deterministic order.\n-            visitor.traits.sort_by_cached_key(|&def_id| tcx.def_path_hash(def_id));\n-            tcx.arena.alloc_slice(&visitor.traits)\n+            traits.sort_by_cached_key(|&def_id| tcx.def_path_hash(def_id));\n+            tcx.arena.alloc_slice(&traits)\n         },\n \n         ..*providers"}, {"sha": "9976b0e9862041ba63e52ea09c21b8e8633a627c", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -9,7 +9,6 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::*;\n use rustc_index::vec::Idx;\n use rustc_middle::hir::nested_filter;\n@@ -161,6 +160,10 @@ impl<'hir> Map<'hir> {\n         self.tcx.hir_crate_items(()).items.iter().copied()\n     }\n \n+    pub fn module_items(self, module: LocalDefId) -> impl Iterator<Item = ItemId> + 'hir {\n+        self.tcx.hir_module_items(module).items()\n+    }\n+\n     pub fn par_for_each_item(self, f: impl Fn(ItemId) + Sync + Send) {\n         par_for_each_in(&self.tcx.hir_crate_items(()).items[..], |id| f(*id));\n     }\n@@ -603,16 +606,16 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Visits all items in the crate in some deterministic (but\n-    /// unspecified) order. If you just need to process every item,\n-    /// but don't care about nesting, this method is the best choice.\n+    /// unspecified) order. If you need to process every item,\n+    /// and care about nesting -- usually because your algorithm\n+    /// follows lexical scoping rules -- then this method is the best choice.\n+    /// If you don't care about nesting, you should use the `tcx.hir_crate_items()` query\n+    /// or `items()` instead.\n     ///\n-    /// If you do care about nesting -- usually because your algorithm\n-    /// follows lexical scoping rules -- then you want a different\n-    /// approach. You should override `visit_nested_item` in your\n-    /// visitor and then call `intravisit::walk_crate` instead.\n-    pub fn visit_all_item_likes<V>(self, visitor: &mut V)\n+    /// Please see the notes in `intravisit.rs` for more information.\n+    pub fn deep_visit_all_item_likes<V>(self, visitor: &mut V)\n     where\n-        V: itemlikevisit::ItemLikeVisitor<'hir>,\n+        V: Visitor<'hir>,\n     {\n         let krate = self.krate();\n         for owner in krate.owners.iter().filter_map(|i| i.as_owner()) {\n@@ -643,9 +646,12 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn visit_item_likes_in_module<V>(self, module: LocalDefId, visitor: &mut V)\n+    /// If you don't care about nesting, you should use the\n+    /// `tcx.hir_module_items()` query or `module_items()` instead.\n+    /// Please see notes in `deep_visit_all_item_likes`.\n+    pub fn deep_visit_item_likes_in_module<V>(self, module: LocalDefId, visitor: &mut V)\n     where\n-        V: ItemLikeVisitor<'hir>,\n+        V: Visitor<'hir>,\n     {\n         let module = self.tcx.hir_module_items(module);\n \n@@ -666,7 +672,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn for_each_module(self, f: impl Fn(LocalDefId)) {\n+    pub fn for_each_module(self, mut f: impl FnMut(LocalDefId)) {\n         let crate_items = self.tcx.hir_crate_items(());\n         for module in crate_items.submodules.iter() {\n             f(*module)"}, {"sha": "d56e87bbb47453c77c30831ec126d2a6ddf251cb", "filename": "compiler/rustc_middle/src/hir/nested_filter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fnested_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fnested_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fnested_filter.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::intravisit::nested_filter::NestedFilter;\n /// constant arguments of types, e.g. in `let _: [(); /* HERE */];`.\n ///\n /// **This is the most common choice.** A very common pattern is\n-/// to use `visit_all_item_likes()` as an outer loop,\n+/// to use `deep_visit_all_item_likes()` as an outer loop,\n /// and to have the visitor that visits the contents of each item\n /// using this setting.\n pub struct OnlyBodies(());"}, {"sha": "91eea01bfb9b936648f7ca8ea139ee6bcd02bded", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -1995,7 +1995,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Look up the name of a definition across crates. This does not look at HIR.\n-    fn opt_item_name(self, def_id: DefId) -> Option<Symbol> {\n+    pub fn opt_item_name(self, def_id: DefId) -> Option<Symbol> {\n         if let Some(cnum) = def_id.as_crate_root() {\n             Some(self.crate_name(cnum))\n         } else {"}, {"sha": "d08382700a80ab9d3a8827a251691f0785008429", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -170,7 +170,7 @@ fn mir_keys(tcx: TyCtxt<'_>, (): ()) -> FxIndexSet<LocalDefId> {\n             intravisit::walk_struct_def(self, v)\n         }\n     }\n-    tcx.hir().visit_all_item_likes(&mut GatherCtors { tcx, set: &mut set }.as_deep_visitor());\n+    tcx.hir().deep_visit_all_item_likes(&mut GatherCtors { tcx, set: &mut set });\n \n     set\n }"}, {"sha": "ab3319a1186aedc899cb6a583c8e3502d0cf5f8c", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -2390,7 +2390,7 @@ fn check_non_exported_macro_for_invalid_attrs(tcx: TyCtxt<'_>, item: &Item<'_>)\n \n fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let check_attr_visitor = &mut CheckAttrVisitor { tcx };\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut check_attr_visitor.as_deep_visitor());\n+    tcx.hir().deep_visit_item_likes_in_module(module_def_id, check_attr_visitor);\n     if module_def_id.is_top_level_module() {\n         check_attr_visitor.check_attributes(CRATE_HIR_ID, DUMMY_SP, Target::Mod, None);\n         check_invalid_crate_level_attr(tcx, tcx.hir().krate_attrs());"}, {"sha": "04d6e9f205abd56b40cc5c9e8dedb7bcd78219bd", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 58, "deletions": 71, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -57,89 +57,71 @@ impl NonConstExpr {\n \n fn check_mod_const_bodies(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let mut vis = CheckConstVisitor::new(tcx);\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut vis.as_deep_visitor());\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckConstTraitVisitor::new(tcx));\n+    tcx.hir().deep_visit_item_likes_in_module(module_def_id, &mut vis);\n }\n \n pub(crate) fn provide(providers: &mut Providers) {\n     *providers = Providers { check_mod_const_bodies, ..*providers };\n }\n \n-struct CheckConstTraitVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'tcx> CheckConstTraitVisitor<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        CheckConstTraitVisitor { tcx }\n-    }\n-}\n-\n-impl<'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for CheckConstTraitVisitor<'tcx> {\n-    /// check for const trait impls, and errors if the impl uses provided/default functions\n-    /// of the trait being implemented; as those provided functions can be non-const.\n-    fn visit_item<'hir>(&mut self, item: &'hir hir::Item<'hir>) {\n-        let _: Option<_> = try {\n-            if let hir::ItemKind::Impl(ref imp) = item.kind && let hir::Constness::Const = imp.constness {\n-                    let trait_def_id = imp.of_trait.as_ref()?.trait_def_id()?;\n-                    let ancestors = self\n-                        .tcx\n-                        .trait_def(trait_def_id)\n-                        .ancestors(self.tcx, item.def_id.to_def_id())\n-                        .ok()?;\n-                    let mut to_implement = Vec::new();\n-\n-                    for trait_item in self.tcx.associated_items(trait_def_id).in_definition_order()\n+fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n+    let _: Option<_> = try {\n+        if let hir::ItemKind::Impl(ref imp) = item.kind && let hir::Constness::Const = imp.constness {\n+            let trait_def_id = imp.of_trait.as_ref()?.trait_def_id()?;\n+            let ancestors = tcx\n+                .trait_def(trait_def_id)\n+                .ancestors(tcx, item.def_id.to_def_id())\n+                .ok()?;\n+            let mut to_implement = Vec::new();\n+\n+            for trait_item in tcx.associated_items(trait_def_id).in_definition_order()\n+            {\n+                if let ty::AssocItem {\n+                    kind: ty::AssocKind::Fn,\n+                    defaultness,\n+                    def_id: trait_item_id,\n+                    ..\n+                } = *trait_item\n+                {\n+                    // we can ignore functions that do not have default bodies:\n+                    // if those are unimplemented it will be caught by typeck.\n+                    if !defaultness.has_value()\n+                        || tcx\n+                        .has_attr(trait_item_id, sym::default_method_body_is_const)\n                     {\n-                        if let ty::AssocItem {\n-                            kind: ty::AssocKind::Fn,\n-                            defaultness,\n-                            def_id: trait_item_id,\n-                            ..\n-                        } = *trait_item\n-                        {\n-                            // we can ignore functions that do not have default bodies:\n-                            // if those are unimplemented it will be caught by typeck.\n-                            if !defaultness.has_value()\n-                                || self\n-                                    .tcx\n-                                    .has_attr(trait_item_id, sym::default_method_body_is_const)\n-                            {\n-                                continue;\n-                            }\n-\n-                            let is_implemented = ancestors\n-                                .leaf_def(self.tcx, trait_item_id)\n-                                .map(|node_item| !node_item.defining_node.is_from_trait())\n-                                .unwrap_or(false);\n-\n-                            if !is_implemented {\n-                                to_implement.push(self.tcx.item_name(trait_item_id).to_string());\n-                            }\n-                        }\n+                        continue;\n                     }\n \n-                    // all nonconst trait functions (not marked with #[default_method_body_is_const])\n-                    // must be implemented\n-                    if !to_implement.is_empty() {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                item.span,\n-                                \"const trait implementations may not use non-const default functions\",\n-                            )\n-                            .note(&format!(\"`{}` not implemented\", to_implement.join(\"`, `\")))\n-                            .emit();\n+                    let is_implemented = ancestors\n+                        .leaf_def(tcx, trait_item_id)\n+                        .map(|node_item| !node_item.defining_node.is_from_trait())\n+                        .unwrap_or(false);\n+\n+                    if !is_implemented {\n+                        to_implement.push(trait_item_id);\n                     }\n+                }\n             }\n-        };\n-    }\n-\n-    fn visit_trait_item<'hir>(&mut self, _: &'hir hir::TraitItem<'hir>) {}\n-\n-    fn visit_impl_item<'hir>(&mut self, _: &'hir hir::ImplItem<'hir>) {}\n \n-    fn visit_foreign_item<'hir>(&mut self, _: &'hir hir::ForeignItem<'hir>) {}\n+            // all nonconst trait functions (not marked with #[default_method_body_is_const])\n+            // must be implemented\n+            if !to_implement.is_empty() {\n+                let not_implemented = to_implement\n+                    .into_iter()\n+                    .map(|did| tcx.item_name(did).to_string())\n+                    .collect::<Vec<_>>()\n+                    .join(\"`, `\");\n+                tcx\n+                    .sess\n+                    .struct_span_err(\n+                        item.span,\n+                        \"const trait implementations may not use non-const default functions\",\n+                    )\n+                    .note(&format!(\"`{}` not implemented\", not_implemented))\n+                    .emit();\n+            }\n+        }\n+    };\n }\n \n #[derive(Copy, Clone)]\n@@ -270,6 +252,11 @@ impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n         self.tcx.hir()\n     }\n \n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n+        intravisit::walk_item(self, item);\n+        check_item(self.tcx, item);\n+    }\n+\n     fn visit_anon_const(&mut self, anon: &'tcx hir::AnonConst) {\n         let kind = Some(hir::ConstContext::Const);\n         self.recurse_into(kind, None, |this| intravisit::walk_anon_const(this, anon));"}, {"sha": "e78d9a59982842b92879b36d5bc9928dd901970c", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 81, "deletions": 58, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -8,7 +8,6 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{Node, PatKind, TyKind};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n@@ -468,7 +467,7 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n     tcx.lint_level_at_node(lint::builtin::DEAD_CODE, id).0 == lint::Allow\n }\n \n-// This visitor seeds items that\n+// These check_* functions seeds items that\n //   1) We want to explicitly consider as live:\n //     * Item annotated with #[allow(dead_code)]\n //         - This is done so that if we want to suppress warnings for a\n@@ -481,90 +480,105 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n //   or\n //   2) We are not sure to be live or not\n //     * Implementations of traits and trait methods\n-struct LifeSeeder<'tcx> {\n-    worklist: Vec<LocalDefId>,\n+fn check_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    // see `MarkSymbolVisitor::struct_constructors`\n-    struct_constructors: FxHashMap<LocalDefId, LocalDefId>,\n-}\n-\n-impl<'v, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let allow_dead_code = has_allow_dead_code_or_lang_attr(self.tcx, item.hir_id());\n-        if allow_dead_code {\n-            self.worklist.push(item.def_id);\n-        }\n-        match item.kind {\n-            hir::ItemKind::Enum(ref enum_def, _) => {\n-                let hir = self.tcx.hir();\n+    worklist: &mut Vec<LocalDefId>,\n+    struct_constructors: &mut FxHashMap<LocalDefId, LocalDefId>,\n+    id: hir::ItemId,\n+) {\n+    let allow_dead_code = has_allow_dead_code_or_lang_attr(tcx, id.hir_id());\n+    if allow_dead_code {\n+        worklist.push(id.def_id);\n+    }\n+\n+    match tcx.def_kind(id.def_id) {\n+        DefKind::Enum => {\n+            let item = tcx.hir().item(id);\n+            if let hir::ItemKind::Enum(ref enum_def, _) = item.kind {\n+                let hir = tcx.hir();\n                 if allow_dead_code {\n-                    self.worklist.extend(\n+                    worklist.extend(\n                         enum_def.variants.iter().map(|variant| hir.local_def_id(variant.id)),\n                     );\n                 }\n \n                 for variant in enum_def.variants {\n                     if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n-                        self.struct_constructors\n+                        struct_constructors\n                             .insert(hir.local_def_id(ctor_hir_id), hir.local_def_id(variant.id));\n                     }\n                 }\n             }\n-            hir::ItemKind::Impl(hir::Impl { ref of_trait, items, .. }) => {\n-                if of_trait.is_some() {\n-                    self.worklist.push(item.def_id);\n-                }\n-                for impl_item_ref in *items {\n-                    let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                    if of_trait.is_some()\n-                        || has_allow_dead_code_or_lang_attr(self.tcx, impl_item.hir_id())\n-                    {\n-                        self.worklist.push(impl_item_ref.id.def_id);\n-                    }\n+        }\n+        DefKind::Impl => {\n+            let of_trait = tcx.impl_trait_ref(id.def_id);\n+\n+            if of_trait.is_some() {\n+                worklist.push(id.def_id);\n+            }\n+\n+            // get DefIds from another query\n+            let local_def_ids = tcx\n+                .associated_item_def_ids(id.def_id)\n+                .iter()\n+                .filter_map(|def_id| def_id.as_local());\n+\n+            // And we access the Map here to get HirId from LocalDefId\n+            for id in local_def_ids {\n+                if of_trait.is_some()\n+                    || has_allow_dead_code_or_lang_attr(tcx, tcx.hir().local_def_id_to_hir_id(id))\n+                {\n+                    worklist.push(id);\n                 }\n             }\n-            hir::ItemKind::Struct(ref variant_data, _) => {\n+        }\n+        DefKind::Struct => {\n+            let item = tcx.hir().item(id);\n+            if let hir::ItemKind::Struct(ref variant_data, _) = item.kind {\n                 if let Some(ctor_hir_id) = variant_data.ctor_hir_id() {\n-                    self.struct_constructors\n-                        .insert(self.tcx.hir().local_def_id(ctor_hir_id), item.def_id);\n+                    struct_constructors.insert(tcx.hir().local_def_id(ctor_hir_id), item.def_id);\n                 }\n             }\n-            hir::ItemKind::GlobalAsm(_) => {\n-                // global_asm! is always live.\n-                self.worklist.push(item.def_id);\n-            }\n-            _ => (),\n         }\n+        DefKind::GlobalAsm => {\n+            // global_asm! is always live.\n+            worklist.push(id.def_id);\n+        }\n+        _ => {}\n     }\n+}\n \n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n-        use hir::TraitItemKind::{Const, Fn};\n+fn check_trait_item<'tcx>(tcx: TyCtxt<'tcx>, worklist: &mut Vec<LocalDefId>, id: hir::TraitItemId) {\n+    use hir::TraitItemKind::{Const, Fn};\n+    if matches!(tcx.def_kind(id.def_id), DefKind::AssocConst | DefKind::AssocFn) {\n+        let trait_item = tcx.hir().trait_item(id);\n         if matches!(trait_item.kind, Const(_, Some(_)) | Fn(_, hir::TraitFn::Provided(_)))\n-            && has_allow_dead_code_or_lang_attr(self.tcx, trait_item.hir_id())\n+            && has_allow_dead_code_or_lang_attr(tcx, trait_item.hir_id())\n         {\n-            self.worklist.push(trait_item.def_id);\n+            worklist.push(trait_item.def_id);\n         }\n     }\n+}\n \n-    fn visit_impl_item(&mut self, _item: &hir::ImplItem<'_>) {\n-        // ignore: we are handling this in `visit_item` above\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem<'_>) {\n-        use hir::ForeignItemKind::{Fn, Static};\n-        if matches!(foreign_item.kind, Static(..) | Fn(..))\n-            && has_allow_dead_code_or_lang_attr(self.tcx, foreign_item.hir_id())\n-        {\n-            self.worklist.push(foreign_item.def_id);\n-        }\n+fn check_foreign_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    worklist: &mut Vec<LocalDefId>,\n+    id: hir::ForeignItemId,\n+) {\n+    if matches!(tcx.def_kind(id.def_id), DefKind::Static(_) | DefKind::Fn)\n+        && has_allow_dead_code_or_lang_attr(tcx, id.hir_id())\n+    {\n+        worklist.push(id.def_id);\n     }\n }\n \n fn create_and_seed_worklist<'tcx>(\n     tcx: TyCtxt<'tcx>,\n ) -> (Vec<LocalDefId>, FxHashMap<LocalDefId, LocalDefId>) {\n     let access_levels = &tcx.privacy_access_levels(());\n-    let worklist = access_levels\n+    // see `MarkSymbolVisitor::struct_constructors`\n+    let mut struct_constructors = Default::default();\n+    let mut worklist = access_levels\n         .map\n         .iter()\n         .filter_map(\n@@ -576,11 +590,20 @@ fn create_and_seed_worklist<'tcx>(\n         .chain(tcx.entry_fn(()).and_then(|(def_id, _)| def_id.as_local()))\n         .collect::<Vec<_>>();\n \n-    // Seed implemented trait items\n-    let mut life_seeder = LifeSeeder { worklist, tcx, struct_constructors: Default::default() };\n-    tcx.hir().visit_all_item_likes(&mut life_seeder);\n+    let crate_items = tcx.hir_crate_items(());\n+    for id in crate_items.items() {\n+        check_item(tcx, &mut worklist, &mut struct_constructors, id);\n+    }\n+\n+    for id in crate_items.trait_items() {\n+        check_trait_item(tcx, &mut worklist, id);\n+    }\n+\n+    for id in crate_items.foreign_items() {\n+        check_foreign_item(tcx, &mut worklist, id);\n+    }\n \n-    (life_seeder.worklist, life_seeder.struct_constructors)\n+    (worklist, struct_constructors)\n }\n \n fn live_symbols_and_ignored_derived_traits<'tcx>("}, {"sha": "8305830bc988ff87d044d385f495140b76f714fb", "filename": "compiler/rustc_passes/src/debugger_visualizer.rs", "status": "modified", "additions": 64, "deletions": 91, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -5,105 +5,74 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::resolve_path;\n use rustc_hir as hir;\n use rustc_hir::def_id::CrateNum;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::{HirId, Target};\n+use rustc_hir::HirId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::{sym, DebuggerVisualizerFile, DebuggerVisualizerType};\n \n use std::sync::Arc;\n \n-struct DebuggerVisualizerCollector<'tcx> {\n-    debugger_visualizers: FxHashSet<DebuggerVisualizerFile>,\n+fn check_for_debugger_visualizer<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'v, 'tcx> ItemLikeVisitor<'v> for DebuggerVisualizerCollector<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let target = Target::from_item(item);\n-        match target {\n-            Target::Mod => {\n-                self.check_for_debugger_visualizer(item.hir_id());\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _: &hir::TraitItem<'_>) {}\n-\n-    fn visit_impl_item(&mut self, _: &hir::ImplItem<'_>) {}\n-\n-    fn visit_foreign_item(&mut self, _: &hir::ForeignItem<'_>) {}\n-}\n-\n-impl<'tcx> DebuggerVisualizerCollector<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> DebuggerVisualizerCollector<'tcx> {\n-        DebuggerVisualizerCollector { tcx, debugger_visualizers: FxHashSet::default() }\n-    }\n-\n-    fn check_for_debugger_visualizer(&mut self, hir_id: HirId) {\n-        let attrs = self.tcx.hir().attrs(hir_id);\n-        for attr in attrs {\n-            if attr.has_name(sym::debugger_visualizer) {\n-                let list = match attr.meta_item_list() {\n-                    Some(list) => list,\n+    hir_id: HirId,\n+    debugger_visualizers: &mut FxHashSet<DebuggerVisualizerFile>,\n+) {\n+    let attrs = tcx.hir().attrs(hir_id);\n+    for attr in attrs {\n+        if attr.has_name(sym::debugger_visualizer) {\n+            let list = match attr.meta_item_list() {\n+                Some(list) => list,\n+                _ => continue,\n+            };\n+\n+            let meta_item = match list.len() {\n+                1 => match list[0].meta_item() {\n+                    Some(meta_item) => meta_item,\n                     _ => continue,\n-                };\n-\n-                let meta_item = match list.len() {\n-                    1 => match list[0].meta_item() {\n-                        Some(meta_item) => meta_item,\n-                        _ => continue,\n-                    },\n-                    _ => continue,\n-                };\n-\n-                let file = match (meta_item.name_or_empty(), meta_item.value_str()) {\n-                    (sym::natvis_file, Some(value)) => {\n-                        match resolve_path(&self.tcx.sess.parse_sess, value.as_str(), attr.span) {\n-                            Ok(file) => file,\n-                            Err(mut err) => {\n-                                err.emit();\n-                                continue;\n-                            }\n+                },\n+                _ => continue,\n+            };\n+\n+            let file = match (meta_item.name_or_empty(), meta_item.value_str()) {\n+                (sym::natvis_file, Some(value)) => {\n+                    match resolve_path(&tcx.sess.parse_sess, value.as_str(), attr.span) {\n+                        Ok(file) => file,\n+                        Err(mut err) => {\n+                            err.emit();\n+                            continue;\n                         }\n                     }\n-                    (_, _) => continue,\n+                }\n+                (_, _) => continue,\n+            };\n+\n+            if file.is_file() {\n+                let contents = match std::fs::read(&file) {\n+                    Ok(contents) => contents,\n+                    Err(err) => {\n+                        tcx.sess\n+                            .struct_span_err(\n+                                attr.span,\n+                                &format!(\n+                                    \"Unable to read contents of file `{}`. {}\",\n+                                    file.display(),\n+                                    err\n+                                ),\n+                            )\n+                            .emit();\n+                        continue;\n+                    }\n                 };\n \n-                if file.is_file() {\n-                    let contents = match std::fs::read(&file) {\n-                        Ok(contents) => contents,\n-                        Err(err) => {\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(\n-                                    attr.span,\n-                                    &format!(\n-                                        \"Unable to read contents of file `{}`. {}\",\n-                                        file.display(),\n-                                        err\n-                                    ),\n-                                )\n-                                .emit();\n-                            continue;\n-                        }\n-                    };\n-\n-                    self.debugger_visualizers.insert(DebuggerVisualizerFile::new(\n-                        Arc::from(contents),\n-                        DebuggerVisualizerType::Natvis,\n-                    ));\n-                } else {\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(\n-                            attr.span,\n-                            &format!(\"{} is not a valid file\", file.display()),\n-                        )\n-                        .emit();\n-                }\n+                debugger_visualizers.insert(DebuggerVisualizerFile::new(\n+                    Arc::from(contents),\n+                    DebuggerVisualizerType::Natvis,\n+                ));\n+            } else {\n+                tcx.sess\n+                    .struct_span_err(attr.span, &format!(\"{} is not a valid file\", file.display()))\n+                    .emit();\n             }\n         }\n     }\n@@ -114,17 +83,21 @@ fn debugger_visualizers<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> Vec<Debugger\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     // Initialize the collector.\n-    let mut collector = DebuggerVisualizerCollector::new(tcx);\n+    let mut debugger_visualizers = FxHashSet::default();\n \n     // Collect debugger visualizers in this crate.\n-    tcx.hir().visit_all_item_likes(&mut collector);\n+    tcx.hir().for_each_module(|id| {\n+        check_for_debugger_visualizer(\n+            tcx,\n+            tcx.hir().local_def_id_to_hir_id(id),\n+            &mut debugger_visualizers,\n+        )\n+    });\n \n     // Collect debugger visualizers on the crate attributes.\n-    collector.check_for_debugger_visualizer(CRATE_HIR_ID);\n+    check_for_debugger_visualizer(tcx, CRATE_HIR_ID, &mut debugger_visualizers);\n \n     // Extract out the found debugger_visualizer items.\n-    let DebuggerVisualizerCollector { debugger_visualizers, .. } = collector;\n-\n     let mut visualizers = debugger_visualizers.into_iter().collect::<Vec<_>>();\n \n     // Sort the visualizers so we always get a deterministic query result."}, {"sha": "e6b69d8986cf83e07e7e4622de0e1402699866d0", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -10,49 +10,22 @@\n //! * Compiler internal types like `Ty` and `TyCtxt`\n \n use rustc_ast as ast;\n-use rustc_hir as hir;\n use rustc_hir::diagnostic_items::DiagnosticItems;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_span::symbol::{sym, Symbol};\n \n-struct DiagnosticItemCollector<'tcx> {\n+fn observe_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    diagnostic_items: DiagnosticItems,\n-}\n-\n-impl<'v, 'tcx> ItemLikeVisitor<'v> for DiagnosticItemCollector<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        self.observe_item(item.def_id);\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n-        self.observe_item(trait_item.def_id);\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n-        self.observe_item(impl_item.def_id);\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem<'_>) {\n-        self.observe_item(foreign_item.def_id);\n-    }\n-}\n-\n-impl<'tcx> DiagnosticItemCollector<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> DiagnosticItemCollector<'tcx> {\n-        DiagnosticItemCollector { tcx, diagnostic_items: DiagnosticItems::default() }\n-    }\n-\n-    fn observe_item(&mut self, def_id: LocalDefId) {\n-        let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-        let attrs = self.tcx.hir().attrs(hir_id);\n-        if let Some(name) = extract(attrs) {\n-            // insert into our table\n-            collect_item(self.tcx, &mut self.diagnostic_items, name, def_id.to_def_id());\n-        }\n+    diagnostic_items: &mut DiagnosticItems,\n+    def_id: LocalDefId,\n+) {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let attrs = tcx.hir().attrs(hir_id);\n+    if let Some(name) = extract(attrs) {\n+        // insert into our table\n+        collect_item(tcx, diagnostic_items, name, def_id.to_def_id());\n     }\n }\n \n@@ -95,12 +68,28 @@ fn diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> DiagnosticItems\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     // Initialize the collector.\n-    let mut collector = DiagnosticItemCollector::new(tcx);\n+    let mut diagnostic_items = DiagnosticItems::default();\n \n     // Collect diagnostic items in this crate.\n-    tcx.hir().visit_all_item_likes(&mut collector);\n+    let crate_items = tcx.hir_crate_items(());\n+\n+    for id in crate_items.items() {\n+        observe_item(tcx, &mut diagnostic_items, id.def_id);\n+    }\n+\n+    for id in crate_items.trait_items() {\n+        observe_item(tcx, &mut diagnostic_items, id.def_id);\n+    }\n+\n+    for id in crate_items.impl_items() {\n+        observe_item(tcx, &mut diagnostic_items, id.def_id);\n+    }\n+\n+    for id in crate_items.foreign_items() {\n+        observe_item(tcx, &mut diagnostic_items, id.def_id);\n+    }\n \n-    collector.diagnostic_items\n+    diagnostic_items\n }\n \n /// Traverse and collect all the diagnostic items in all crates."}, {"sha": "b90d44e2af57cd5de7b4cc78dcae000cb6f6e72e", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -1,8 +1,8 @@\n use rustc_ast::entry::EntryPointType;\n use rustc_errors::struct_span_err;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::{ForeignItem, ImplItem, Item, ItemKind, Node, TraitItem, CRATE_HIR_ID};\n+use rustc_hir::{ItemId, Node, CRATE_HIR_ID};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{DefIdTree, TyCtxt};\n use rustc_session::config::{CrateType, EntryFnType};\n@@ -25,25 +25,6 @@ struct EntryContext<'tcx> {\n     non_main_fns: Vec<Span>,\n }\n \n-impl<'tcx> ItemLikeVisitor<'tcx> for EntryContext<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n-        let at_root = self.tcx.opt_local_parent(item.def_id) == Some(CRATE_DEF_ID);\n-        find_item(item, self, at_root);\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &'tcx TraitItem<'tcx>) {\n-        // Entry fn is never a trait item.\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem<'tcx>) {\n-        // Entry fn is never a trait item.\n-    }\n-\n-    fn visit_foreign_item(&mut self, _: &'tcx ForeignItem<'tcx>) {\n-        // Entry fn is never a foreign item.\n-    }\n-}\n-\n fn entry_fn(tcx: TyCtxt<'_>, (): ()) -> Option<(DefId, EntryFnType)> {\n     let any_exe = tcx.sess.crate_types().iter().any(|ty| *ty == CrateType::Executable);\n     if !any_exe {\n@@ -59,28 +40,35 @@ fn entry_fn(tcx: TyCtxt<'_>, (): ()) -> Option<(DefId, EntryFnType)> {\n     let mut ctxt =\n         EntryContext { tcx, attr_main_fn: None, start_fn: None, non_main_fns: Vec::new() };\n \n-    tcx.hir().visit_all_item_likes(&mut ctxt);\n+    for id in tcx.hir().items() {\n+        find_item(id, &mut ctxt);\n+    }\n \n     configure_main(tcx, &ctxt)\n }\n \n // Beware, this is duplicated in `librustc_builtin_macros/test_harness.rs`\n // (with `ast::Item`), so make sure to keep them in sync.\n-fn entry_point_type(ctxt: &EntryContext<'_>, item: &Item<'_>, at_root: bool) -> EntryPointType {\n-    let attrs = ctxt.tcx.hir().attrs(item.hir_id());\n+// A small optimization was added so that hir::Item is fetched only when needed.\n+// An equivalent optimization was not applied to the duplicated code in test_harness.rs.\n+fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> EntryPointType {\n+    let attrs = ctxt.tcx.hir().attrs(id.hir_id());\n     if ctxt.tcx.sess.contains_name(attrs, sym::start) {\n         EntryPointType::Start\n     } else if ctxt.tcx.sess.contains_name(attrs, sym::rustc_main) {\n         EntryPointType::MainAttr\n-    } else if item.ident.name == sym::main {\n-        if at_root {\n-            // This is a top-level function so can be `main`.\n-            EntryPointType::MainNamed\n+    } else {\n+        if let Some(name) = ctxt.tcx.opt_item_name(id.def_id.to_def_id())\n+            && name == sym::main {\n+            if at_root {\n+                // This is a top-level function so can be `main`.\n+                EntryPointType::MainNamed\n+            } else {\n+                EntryPointType::OtherMain\n+            }\n         } else {\n-            EntryPointType::OtherMain\n+            EntryPointType::None\n         }\n-    } else {\n-        EntryPointType::None\n     }\n }\n \n@@ -89,11 +77,13 @@ fn throw_attr_err(sess: &Session, span: Span, attr: &str) {\n         .emit();\n }\n \n-fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_>, at_root: bool) {\n-    match entry_point_type(ctxt, item, at_root) {\n+fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n+    let at_root = ctxt.tcx.opt_local_parent(id.def_id) == Some(CRATE_DEF_ID);\n+\n+    match entry_point_type(ctxt, id, at_root) {\n         EntryPointType::None => (),\n-        _ if !matches!(item.kind, ItemKind::Fn(..)) => {\n-            let attrs = ctxt.tcx.hir().attrs(item.hir_id());\n+        _ if !matches!(ctxt.tcx.def_kind(id.def_id), DefKind::Fn) => {\n+            let attrs = ctxt.tcx.hir().attrs(id.hir_id());\n             if let Some(attr) = ctxt.tcx.sess.find_by_name(attrs, sym::start) {\n                 throw_attr_err(&ctxt.tcx.sess, attr.span, \"start\");\n             }\n@@ -103,31 +93,39 @@ fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_>, at_root: bool) {\n         }\n         EntryPointType::MainNamed => (),\n         EntryPointType::OtherMain => {\n-            ctxt.non_main_fns.push(item.span);\n+            ctxt.non_main_fns.push(ctxt.tcx.def_span(id.def_id));\n         }\n         EntryPointType::MainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n-                ctxt.attr_main_fn = Some((item.def_id, item.span));\n+                ctxt.attr_main_fn = Some((id.def_id, ctxt.tcx.def_span(id.def_id.to_def_id())));\n             } else {\n                 struct_span_err!(\n                     ctxt.tcx.sess,\n-                    item.span,\n+                    ctxt.tcx.def_span(id.def_id.to_def_id()),\n                     E0137,\n                     \"multiple functions with a `#[main]` attribute\"\n                 )\n-                .span_label(item.span, \"additional `#[main]` function\")\n+                .span_label(\n+                    ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    \"additional `#[main]` function\",\n+                )\n                 .span_label(ctxt.attr_main_fn.unwrap().1, \"first `#[main]` function\")\n                 .emit();\n             }\n         }\n         EntryPointType::Start => {\n             if ctxt.start_fn.is_none() {\n-                ctxt.start_fn = Some((item.def_id, item.span));\n+                ctxt.start_fn = Some((id.def_id, ctxt.tcx.def_span(id.def_id.to_def_id())));\n             } else {\n-                struct_span_err!(ctxt.tcx.sess, item.span, E0138, \"multiple `start` functions\")\n-                    .span_label(ctxt.start_fn.unwrap().1, \"previous `#[start]` function here\")\n-                    .span_label(item.span, \"multiple `start` functions\")\n-                    .emit();\n+                struct_span_err!(\n+                    ctxt.tcx.sess,\n+                    ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    E0138,\n+                    \"multiple `start` functions\"\n+                )\n+                .span_label(ctxt.start_fn.unwrap().1, \"previous `#[start]` function here\")\n+                .span_label(ctxt.tcx.def_span(id.def_id.to_def_id()), \"multiple `start` functions\")\n+                .emit();\n             }\n         }\n     }"}, {"sha": "23ff0a91159708ee0dfd0871a6e366c552c90f12", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 26, "deletions": 44, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -3,7 +3,6 @@ use rustc_data_structures::sync::Lock;\n use rustc_hir as hir;\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::intravisit;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{HirId, ItemLocalId};\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n@@ -20,8 +19,14 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n     let hir_map = tcx.hir();\n \n     hir_map.par_for_each_module(|module_id| {\n-        hir_map\n-            .visit_item_likes_in_module(module_id, &mut OuterVisitor { hir_map, errors: &errors })\n+        let mut v = HirIdValidator {\n+            hir_map,\n+            owner: None,\n+            hir_ids_seen: Default::default(),\n+            errors: &errors,\n+        };\n+\n+        tcx.hir().deep_visit_item_likes_in_module(module_id, &mut v);\n     });\n \n     let errors = errors.into_inner();\n@@ -39,45 +44,16 @@ struct HirIdValidator<'a, 'hir> {\n     errors: &'a Lock<Vec<String>>,\n }\n \n-struct OuterVisitor<'a, 'hir> {\n-    hir_map: Map<'hir>,\n-    errors: &'a Lock<Vec<String>>,\n-}\n-\n-impl<'a, 'hir> OuterVisitor<'a, 'hir> {\n-    fn new_inner_visitor(&self, hir_map: Map<'hir>) -> HirIdValidator<'a, 'hir> {\n+impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n+    fn new_visitor(&self, hir_map: Map<'hir>) -> HirIdValidator<'a, 'hir> {\n         HirIdValidator {\n             hir_map,\n             owner: None,\n             hir_ids_seen: Default::default(),\n             errors: self.errors,\n         }\n     }\n-}\n-\n-impl<'a, 'hir> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n-    fn visit_item(&mut self, i: &'hir hir::Item<'hir>) {\n-        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.def_id, |this| intravisit::walk_item(this, i));\n-    }\n-\n-    fn visit_trait_item(&mut self, i: &'hir hir::TraitItem<'hir>) {\n-        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.def_id, |this| intravisit::walk_trait_item(this, i));\n-    }\n-\n-    fn visit_impl_item(&mut self, i: &'hir hir::ImplItem<'hir>) {\n-        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.def_id, |this| intravisit::walk_impl_item(this, i));\n-    }\n-\n-    fn visit_foreign_item(&mut self, i: &'hir hir::ForeignItem<'hir>) {\n-        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.def_id, |this| intravisit::walk_foreign_item(this, i));\n-    }\n-}\n \n-impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n     #[cold]\n     #[inline(never)]\n     fn error(&self, f: impl FnOnce() -> String) {\n@@ -146,6 +122,11 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n         self.hir_map\n     }\n \n+    fn visit_item(&mut self, i: &'hir hir::Item<'hir>) {\n+        let mut inner_visitor = self.new_visitor(self.hir_map);\n+        inner_visitor.check(i.def_id, |this| intravisit::walk_item(this, i));\n+    }\n+\n     fn visit_id(&mut self, hir_id: HirId) {\n         let owner = self.owner.expect(\"no owner\");\n \n@@ -163,17 +144,18 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n         self.hir_ids_seen.insert(hir_id.local_id);\n     }\n \n-    fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef) {\n-        // Explicitly do nothing here. ImplItemRefs contain hir::Visibility\n-        // values that actually belong to an ImplItem instead of the ItemKind::Impl\n-        // we are currently in. So for those it's correct that they have a\n-        // different owner.\n+    fn visit_foreign_item(&mut self, i: &'hir hir::ForeignItem<'hir>) {\n+        let mut inner_visitor = self.new_visitor(self.hir_map);\n+        inner_visitor.check(i.def_id, |this| intravisit::walk_foreign_item(this, i));\n+    }\n+\n+    fn visit_trait_item(&mut self, i: &'hir hir::TraitItem<'hir>) {\n+        let mut inner_visitor = self.new_visitor(self.hir_map);\n+        inner_visitor.check(i.def_id, |this| intravisit::walk_trait_item(this, i));\n     }\n \n-    fn visit_foreign_item_ref(&mut self, _: &'hir hir::ForeignItemRef) {\n-        // Explicitly do nothing here. ForeignItemRefs contain hir::Visibility\n-        // values that actually belong to an ForeignItem instead of the ItemKind::ForeignMod\n-        // we are currently in. So for those it's correct that they have a\n-        // different owner.\n+    fn visit_impl_item(&mut self, i: &'hir hir::ImplItem<'hir>) {\n+        let mut inner_visitor = self.new_visitor(self.hir_map);\n+        inner_visitor.check(i.def_id, |this| intravisit::walk_impl_item(this, i));\n     }\n }"}, {"sha": "95f6f7ef864a210c9952954371b8ae2f43435507", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -17,7 +17,7 @@ use rustc_target::asm::{InlineAsmRegOrRegClass, InlineAsmType};\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n \n fn check_mod_intrinsics(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut ItemVisitor { tcx }.as_deep_visitor());\n+    tcx.hir().deep_visit_item_likes_in_module(module_def_id, &mut ItemVisitor { tcx });\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "fd03f657111d99c62a30adf2407a5030773e28e4", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 67, "deletions": 79, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -1,8 +1,6 @@\n use rustc_ast::Attribute;\n-use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::ItemKind;\n use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n@@ -12,97 +10,87 @@ use rustc_target::abi::{HasDataLayout, TargetDataLayout};\n pub fn test_layout(tcx: TyCtxt<'_>) {\n     if tcx.features().rustc_attrs {\n         // if the `rustc_attrs` feature is not enabled, don't bother testing layout\n-        tcx.hir().visit_all_item_likes(&mut LayoutTest { tcx });\n-    }\n-}\n-\n-struct LayoutTest<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'tcx> ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        match item.kind {\n-            ItemKind::TyAlias(..)\n-            | ItemKind::Enum(..)\n-            | ItemKind::Struct(..)\n-            | ItemKind::Union(..) => {\n-                for attr in self.tcx.get_attrs(item.def_id.to_def_id(), sym::rustc_layout) {\n-                    self.dump_layout_of(item.def_id, item, attr);\n+        for id in tcx.hir().items() {\n+            if matches!(\n+                tcx.def_kind(id.def_id),\n+                DefKind::TyAlias | DefKind::Enum | DefKind::Struct | DefKind::Union\n+            ) {\n+                for attr in tcx.get_attrs(id.def_id.to_def_id(), sym::rustc_layout) {\n+                    dump_layout_of(tcx, id.def_id, attr);\n                 }\n             }\n-            _ => {}\n         }\n     }\n-\n-    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem<'tcx>) {}\n-    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem<'tcx>) {}\n-    fn visit_foreign_item(&mut self, _: &'tcx hir::ForeignItem<'tcx>) {}\n }\n \n-impl<'tcx> LayoutTest<'tcx> {\n-    fn dump_layout_of(&self, item_def_id: LocalDefId, item: &hir::Item<'tcx>, attr: &Attribute) {\n-        let tcx = self.tcx;\n-        let param_env = self.tcx.param_env(item_def_id);\n-        let ty = self.tcx.type_of(item_def_id);\n-        match self.tcx.layout_of(param_env.and(ty)) {\n-            Ok(ty_layout) => {\n-                // Check out the `#[rustc_layout(..)]` attribute to tell what to dump.\n-                // The `..` are the names of fields to dump.\n-                let meta_items = attr.meta_item_list().unwrap_or_default();\n-                for meta_item in meta_items {\n-                    match meta_item.name_or_empty() {\n-                        sym::abi => {\n-                            self.tcx.sess.span_err(item.span, &format!(\"abi: {:?}\", ty_layout.abi));\n-                        }\n+fn dump_layout_of<'tcx>(tcx: TyCtxt<'tcx>, item_def_id: LocalDefId, attr: &Attribute) {\n+    let tcx = tcx;\n+    let param_env = tcx.param_env(item_def_id);\n+    let ty = tcx.type_of(item_def_id);\n+    match tcx.layout_of(param_env.and(ty)) {\n+        Ok(ty_layout) => {\n+            // Check out the `#[rustc_layout(..)]` attribute to tell what to dump.\n+            // The `..` are the names of fields to dump.\n+            let meta_items = attr.meta_item_list().unwrap_or_default();\n+            for meta_item in meta_items {\n+                match meta_item.name_or_empty() {\n+                    sym::abi => {\n+                        tcx.sess.span_err(\n+                            tcx.def_span(item_def_id.to_def_id()),\n+                            &format!(\"abi: {:?}\", ty_layout.abi),\n+                        );\n+                    }\n \n-                        sym::align => {\n-                            self.tcx\n-                                .sess\n-                                .span_err(item.span, &format!(\"align: {:?}\", ty_layout.align));\n-                        }\n+                    sym::align => {\n+                        tcx.sess.span_err(\n+                            tcx.def_span(item_def_id.to_def_id()),\n+                            &format!(\"align: {:?}\", ty_layout.align),\n+                        );\n+                    }\n \n-                        sym::size => {\n-                            self.tcx\n-                                .sess\n-                                .span_err(item.span, &format!(\"size: {:?}\", ty_layout.size));\n-                        }\n+                    sym::size => {\n+                        tcx.sess.span_err(\n+                            tcx.def_span(item_def_id.to_def_id()),\n+                            &format!(\"size: {:?}\", ty_layout.size),\n+                        );\n+                    }\n \n-                        sym::homogeneous_aggregate => {\n-                            self.tcx.sess.span_err(\n-                                item.span,\n-                                &format!(\n-                                    \"homogeneous_aggregate: {:?}\",\n-                                    ty_layout\n-                                        .homogeneous_aggregate(&UnwrapLayoutCx { tcx, param_env }),\n-                                ),\n-                            );\n-                        }\n+                    sym::homogeneous_aggregate => {\n+                        tcx.sess.span_err(\n+                            tcx.def_span(item_def_id.to_def_id()),\n+                            &format!(\n+                                \"homogeneous_aggregate: {:?}\",\n+                                ty_layout.homogeneous_aggregate(&UnwrapLayoutCx { tcx, param_env }),\n+                            ),\n+                        );\n+                    }\n \n-                        sym::debug => {\n-                            let normalized_ty = self.tcx.normalize_erasing_regions(\n-                                param_env.with_reveal_all_normalized(self.tcx),\n-                                ty,\n-                            );\n-                            self.tcx.sess.span_err(\n-                                item.span,\n-                                &format!(\"layout_of({:?}) = {:#?}\", normalized_ty, *ty_layout),\n-                            );\n-                        }\n+                    sym::debug => {\n+                        let normalized_ty = tcx.normalize_erasing_regions(\n+                            param_env.with_reveal_all_normalized(tcx),\n+                            ty,\n+                        );\n+                        tcx.sess.span_err(\n+                            tcx.def_span(item_def_id.to_def_id()),\n+                            &format!(\"layout_of({:?}) = {:#?}\", normalized_ty, *ty_layout),\n+                        );\n+                    }\n \n-                        name => {\n-                            self.tcx.sess.span_err(\n-                                meta_item.span(),\n-                                &format!(\"unrecognized field name `{}`\", name),\n-                            );\n-                        }\n+                    name => {\n+                        tcx.sess.span_err(\n+                            meta_item.span(),\n+                            &format!(\"unrecognized field name `{}`\", name),\n+                        );\n                     }\n                 }\n             }\n+        }\n \n-            Err(layout_error) => {\n-                self.tcx.sess.span_err(item.span, &format!(\"layout error: {:?}\", layout_error));\n-            }\n+        Err(layout_error) => {\n+            tcx.sess.span_err(\n+                tcx.def_span(item_def_id.to_def_id()),\n+                &format!(\"layout error: {:?}\", layout_error),\n+            );\n         }\n     }\n }"}, {"sha": "ce5253adf10d83d6da4b53081237d7cf1d230fe1", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -140,7 +140,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_>) -> String {\n }\n \n fn check_mod_liveness(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut IrMaps::new(tcx).as_deep_visitor());\n+    tcx.hir().deep_visit_item_likes_in_module(module_def_id, &mut IrMaps::new(tcx));\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "e0dac09870df74637365e5d8c607241d66c05889", "filename": "compiler/rustc_passes/src/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Floops.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -31,9 +31,9 @@ struct CheckLoopVisitor<'a, 'hir> {\n }\n \n fn check_mod_loops(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    tcx.hir().visit_item_likes_in_module(\n+    tcx.hir().deep_visit_item_likes_in_module(\n         module_def_id,\n-        &mut CheckLoopVisitor { sess: &tcx.sess, hir_map: tcx.hir(), cx: Normal }.as_deep_visitor(),\n+        &mut CheckLoopVisitor { sess: &tcx.sess, hir_map: tcx.hir(), cx: Normal },\n     );\n }\n "}, {"sha": "5d7768c8240def357cffa30570cafbd93c2363e7", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -14,10 +14,7 @@ use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n fn check_mod_naked_functions(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    tcx.hir().visit_item_likes_in_module(\n-        module_def_id,\n-        &mut CheckNakedFunctions { tcx }.as_deep_visitor(),\n-    );\n+    tcx.hir().deep_visit_item_likes_in_module(module_def_id, &mut CheckNakedFunctions { tcx });\n }\n \n crate fn provide(providers: &mut Providers) {"}, {"sha": "0ded6a421f57f30b20a2b948ee8c25db1dbba214", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 62, "deletions": 69, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -10,7 +10,6 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::middle::privacy;\n@@ -314,79 +313,60 @@ impl<'tcx> ReachableContext<'tcx> {\n     }\n }\n \n-// Some methods from non-exported (completely private) trait impls still have to be\n-// reachable if they are called from inlinable code. Generally, it's not known until\n-// monomorphization if a specific trait impl item can be reachable or not. So, we\n-// conservatively mark all of them as reachable.\n-// FIXME: One possible strategy for pruning the reachable set is to avoid marking impl\n-// items of non-exported traits (or maybe all local traits?) unless their respective\n-// trait items are used from inlinable code through method call syntax or UFCS, or their\n-// trait is a lang item.\n-struct CollectPrivateImplItemsVisitor<'a, 'tcx> {\n+fn check_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    access_levels: &'a privacy::AccessLevels,\n-    worklist: &'a mut Vec<LocalDefId>,\n-}\n+    id: hir::ItemId,\n+    worklist: &mut Vec<LocalDefId>,\n+    access_levels: &privacy::AccessLevels,\n+) {\n+    if has_custom_linkage(tcx, id.def_id) {\n+        worklist.push(id.def_id);\n+    }\n \n-impl CollectPrivateImplItemsVisitor<'_, '_> {\n-    fn push_to_worklist_if_has_custom_linkage(&mut self, def_id: LocalDefId) {\n-        // Anything which has custom linkage gets thrown on the worklist no\n-        // matter where it is in the crate, along with \"special std symbols\"\n-        // which are currently akin to allocator symbols.\n-        if self.tcx.def_kind(def_id).has_codegen_attrs() {\n-            let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n-            if codegen_attrs.contains_extern_indicator()\n-                || codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n-                // FIXME(nbdd0121): `#[used]` are marked as reachable here so it's picked up by\n-                // `linked_symbols` in cg_ssa. They won't be exported in binary or cdylib due to their\n-                // `SymbolExportLevel::Rust` export level but may end up being exported in dylibs.\n-                || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED)\n-                || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n-            {\n-                self.worklist.push(def_id);\n-            }\n-        }\n+    if !matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n+        return;\n     }\n-}\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        self.push_to_worklist_if_has_custom_linkage(item.def_id);\n-\n-        // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n-            item.kind\n-        {\n-            if !self.access_levels.is_reachable(item.def_id) {\n-                // FIXME(#53488) remove `let`\n-                let tcx = self.tcx;\n-                self.worklist.extend(items.iter().map(|ii_ref| ii_ref.id.def_id));\n-\n-                let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res else {\n-                    unreachable!();\n-                };\n+    // We need only trait impls here, not inherent impls, and only non-exported ones\n+    let item = tcx.hir().item(id);\n+    if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n+        item.kind\n+    {\n+        if !access_levels.is_reachable(item.def_id) {\n+            // FIXME(#53488) remove `let`\n+            let tcx = tcx;\n+            worklist.extend(items.iter().map(|ii_ref| ii_ref.id.def_id));\n \n-                if !trait_def_id.is_local() {\n-                    return;\n-                }\n+            let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res else {\n+                unreachable!();\n+            };\n \n-                self.worklist.extend(\n-                    tcx.provided_trait_methods(trait_def_id)\n-                        .map(|assoc| assoc.def_id.expect_local()),\n-                );\n+            if !trait_def_id.is_local() {\n+                return;\n             }\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n \n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n-        self.push_to_worklist_if_has_custom_linkage(impl_item.def_id);\n+            worklist.extend(\n+                tcx.provided_trait_methods(trait_def_id).map(|assoc| assoc.def_id.expect_local()),\n+            );\n+        }\n     }\n+}\n \n-    fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {\n-        // We never export foreign functions as they have no body to export.\n+fn has_custom_linkage<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> bool {\n+    // Anything which has custom linkage gets thrown on the worklist no\n+    // matter where it is in the crate, along with \"special std symbols\"\n+    // which are currently akin to allocator symbols.\n+    if !tcx.def_kind(def_id).has_codegen_attrs() {\n+        return false;\n     }\n+    let codegen_attrs = tcx.codegen_fn_attrs(def_id);\n+    codegen_attrs.contains_extern_indicator()\n+        || codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n+        // FIXME(nbdd0121): `#[used]` are marked as reachable here so it's picked up by\n+        // `linked_symbols` in cg_ssa. They won't be exported in binary or cdylib due to their\n+        // `SymbolExportLevel::Rust` export level but may end up being exported in dylibs.\n+        || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED)\n+        || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n }\n \n fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n@@ -418,12 +398,25 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n         }\n     }\n     {\n-        let mut collect_private_impl_items = CollectPrivateImplItemsVisitor {\n-            tcx,\n-            access_levels,\n-            worklist: &mut reachable_context.worklist,\n-        };\n-        tcx.hir().visit_all_item_likes(&mut collect_private_impl_items);\n+        // Some methods from non-exported (completely private) trait impls still have to be\n+        // reachable if they are called from inlinable code. Generally, it's not known until\n+        // monomorphization if a specific trait impl item can be reachable or not. So, we\n+        // conservatively mark all of them as reachable.\n+        // FIXME: One possible strategy for pruning the reachable set is to avoid marking impl\n+        // items of non-exported traits (or maybe all local traits?) unless their respective\n+        // trait items are used from inlinable code through method call syntax or UFCS, or their\n+        // trait is a lang item.\n+        let crate_items = tcx.hir_crate_items(());\n+\n+        for id in crate_items.items() {\n+            check_item(tcx, id, &mut reachable_context.worklist, access_levels);\n+        }\n+\n+        for id in crate_items.impl_items() {\n+            if has_custom_linkage(tcx, id.def_id) {\n+                reachable_context.worklist.push(id.def_id);\n+            }\n+        }\n     }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch."}, {"sha": "58195fce281975b5e0245c204214c6e5cbc955a0", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -661,7 +661,7 @@ fn stability_index(tcx: TyCtxt<'_>, (): ()) -> Index {\n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors.\n fn check_mod_unstable_api_usage(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut Checker { tcx }.as_deep_visitor());\n+    tcx.hir().deep_visit_item_likes_in_module(module_def_id, &mut Checker { tcx });\n }\n \n pub(crate) fn provide(providers: &mut Providers) {\n@@ -837,7 +837,7 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n         let mut missing = MissingStabilityAnnotations { tcx, access_levels };\n         missing.check_missing_stability(CRATE_DEF_ID, tcx.hir().span(CRATE_HIR_ID));\n         tcx.hir().walk_toplevel_module(&mut missing);\n-        tcx.hir().visit_all_item_likes(&mut missing.as_deep_visitor());\n+        tcx.hir().deep_visit_all_item_likes(&mut missing);\n     }\n \n     let declared_lang_features = &tcx.features().declared_lang_features;"}, {"sha": "4d3c730dc90896d340e79899e1ef6f84138d9960", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 84, "deletions": 81, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -14,8 +14,8 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n-use rustc_hir::intravisit::{self, DeepVisitor, Visitor};\n-use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n+use rustc_hir::intravisit::{self, Visitor};\n+use rustc_hir::{AssocItemKind, HirIdSet, ItemId, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n@@ -1802,12 +1802,12 @@ impl<'tcx> DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n     }\n }\n \n-struct PrivateItemsInPublicInterfacesVisitor<'tcx> {\n+struct PrivateItemsInPublicInterfacesChecker<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     old_error_set_ancestry: LocalDefIdSet,\n }\n \n-impl<'tcx> PrivateItemsInPublicInterfacesVisitor<'tcx> {\n+impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n     fn check(\n         &self,\n         def_id: LocalDefId,\n@@ -1841,110 +1841,110 @@ impl<'tcx> PrivateItemsInPublicInterfacesVisitor<'tcx> {\n             check.ty();\n         }\n     }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'tcx> {\n-    type NestedFilter = nested_filter::OnlyBodies;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.tcx.hir()\n-    }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n+    pub fn check_item(&mut self, id: ItemId) {\n         let tcx = self.tcx;\n-        let item_visibility = tcx.visibility(item.def_id);\n+        let item_visibility = tcx.visibility(id.def_id);\n+        let def_kind = tcx.def_kind(id.def_id);\n \n-        match item.kind {\n-            // Crates are always public.\n-            hir::ItemKind::ExternCrate(..) => {}\n-            // All nested items are checked by `visit_item`.\n-            hir::ItemKind::Mod(..) => {}\n-            // Checked in resolve.\n-            hir::ItemKind::Use(..) => {}\n-            // No subitems.\n-            hir::ItemKind::Macro(..) | hir::ItemKind::GlobalAsm(..) => {}\n-            // Subitems of these items have inherited publicity.\n-            hir::ItemKind::Const(..)\n-            | hir::ItemKind::Static(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::TyAlias(..) => {\n-                self.check(item.def_id, item_visibility).generics().predicates().ty();\n+        match def_kind {\n+            DefKind::Const | DefKind::Static(_) | DefKind::Fn | DefKind::TyAlias => {\n+                self.check(id.def_id, item_visibility).generics().predicates().ty();\n             }\n-            hir::ItemKind::OpaqueTy(..) => {\n+            DefKind::OpaqueTy => {\n                 // `ty()` for opaque types is the underlying type,\n                 // it's not a part of interface, so we skip it.\n-                self.check(item.def_id, item_visibility).generics().bounds();\n+                self.check(id.def_id, item_visibility).generics().bounds();\n             }\n-            hir::ItemKind::Trait(.., trait_item_refs) => {\n-                self.check(item.def_id, item_visibility).generics().predicates();\n+            DefKind::Trait => {\n+                let item = tcx.hir().item(id);\n+                if let hir::ItemKind::Trait(.., trait_item_refs) = item.kind {\n+                    self.check(item.def_id, item_visibility).generics().predicates();\n \n-                for trait_item_ref in trait_item_refs {\n-                    self.check_assoc_item(\n-                        trait_item_ref.id.def_id,\n-                        trait_item_ref.kind,\n-                        trait_item_ref.defaultness,\n-                        item_visibility,\n-                    );\n-\n-                    if let AssocItemKind::Type = trait_item_ref.kind {\n-                        self.check(trait_item_ref.id.def_id, item_visibility).bounds();\n+                    for trait_item_ref in trait_item_refs {\n+                        self.check_assoc_item(\n+                            trait_item_ref.id.def_id,\n+                            trait_item_ref.kind,\n+                            trait_item_ref.defaultness,\n+                            item_visibility,\n+                        );\n+\n+                        if let AssocItemKind::Type = trait_item_ref.kind {\n+                            self.check(trait_item_ref.id.def_id, item_visibility).bounds();\n+                        }\n                     }\n                 }\n             }\n-            hir::ItemKind::TraitAlias(..) => {\n-                self.check(item.def_id, item_visibility).generics().predicates();\n+            DefKind::TraitAlias => {\n+                self.check(id.def_id, item_visibility).generics().predicates();\n             }\n-            hir::ItemKind::Enum(ref def, _) => {\n-                self.check(item.def_id, item_visibility).generics().predicates();\n+            DefKind::Enum => {\n+                let item = tcx.hir().item(id);\n+                if let hir::ItemKind::Enum(ref def, _) = item.kind {\n+                    self.check(item.def_id, item_visibility).generics().predicates();\n \n-                for variant in def.variants {\n-                    for field in variant.data.fields() {\n-                        self.check(self.tcx.hir().local_def_id(field.hir_id), item_visibility).ty();\n+                    for variant in def.variants {\n+                        for field in variant.data.fields() {\n+                            self.check(self.tcx.hir().local_def_id(field.hir_id), item_visibility)\n+                                .ty();\n+                        }\n                     }\n                 }\n             }\n             // Subitems of foreign modules have their own publicity.\n-            hir::ItemKind::ForeignMod { items, .. } => {\n-                for foreign_item in items {\n-                    let vis = tcx.visibility(foreign_item.id.def_id);\n-                    self.check(foreign_item.id.def_id, vis).generics().predicates().ty();\n+            DefKind::ForeignMod => {\n+                let item = tcx.hir().item(id);\n+                if let hir::ItemKind::ForeignMod { items, .. } = item.kind {\n+                    for foreign_item in items {\n+                        let vis = tcx.visibility(foreign_item.id.def_id);\n+                        self.check(foreign_item.id.def_id, vis).generics().predicates().ty();\n+                    }\n                 }\n             }\n             // Subitems of structs and unions have their own publicity.\n-            hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                self.check(item.def_id, item_visibility).generics().predicates();\n+            DefKind::Struct | DefKind::Union => {\n+                let item = tcx.hir().item(id);\n+                if let hir::ItemKind::Struct(ref struct_def, _)\n+                | hir::ItemKind::Union(ref struct_def, _) = item.kind\n+                {\n+                    self.check(item.def_id, item_visibility).generics().predicates();\n \n-                for field in struct_def.fields() {\n-                    let def_id = tcx.hir().local_def_id(field.hir_id);\n-                    let field_visibility = tcx.visibility(def_id);\n-                    self.check(def_id, min(item_visibility, field_visibility, tcx)).ty();\n+                    for field in struct_def.fields() {\n+                        let def_id = tcx.hir().local_def_id(field.hir_id);\n+                        let field_visibility = tcx.visibility(def_id);\n+                        self.check(def_id, min(item_visibility, field_visibility, tcx)).ty();\n+                    }\n                 }\n             }\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity.\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n-            hir::ItemKind::Impl(ref impl_) => {\n-                let impl_vis = ty::Visibility::of_impl(item.def_id, tcx, &Default::default());\n-                // check that private components do not appear in the generics or predicates of inherent impls\n-                // this check is intentionally NOT performed for impls of traits, per #90586\n-                if impl_.of_trait.is_none() {\n-                    self.check(item.def_id, impl_vis).generics().predicates();\n-                }\n-                for impl_item_ref in impl_.items {\n-                    let impl_item_vis = if impl_.of_trait.is_none() {\n-                        min(tcx.visibility(impl_item_ref.id.def_id), impl_vis, tcx)\n-                    } else {\n-                        impl_vis\n-                    };\n-                    self.check_assoc_item(\n-                        impl_item_ref.id.def_id,\n-                        impl_item_ref.kind,\n-                        impl_item_ref.defaultness,\n-                        impl_item_vis,\n-                    );\n+            DefKind::Impl => {\n+                let item = tcx.hir().item(id);\n+                if let hir::ItemKind::Impl(ref impl_) = item.kind {\n+                    let impl_vis = ty::Visibility::of_impl(item.def_id, tcx, &Default::default());\n+                    // check that private components do not appear in the generics or predicates of inherent impls\n+                    // this check is intentionally NOT performed for impls of traits, per #90586\n+                    if impl_.of_trait.is_none() {\n+                        self.check(item.def_id, impl_vis).generics().predicates();\n+                    }\n+                    for impl_item_ref in impl_.items {\n+                        let impl_item_vis = if impl_.of_trait.is_none() {\n+                            min(tcx.visibility(impl_item_ref.id.def_id), impl_vis, tcx)\n+                        } else {\n+                            impl_vis\n+                        };\n+                        self.check_assoc_item(\n+                            impl_item_ref.id.def_id,\n+                            impl_item_ref.kind,\n+                            impl_item_ref.defaultness,\n+                            impl_item_vis,\n+                        );\n+                    }\n                 }\n             }\n+            _ => {}\n         }\n     }\n }\n@@ -2069,7 +2069,7 @@ fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n     }\n \n     // Check for private types and traits in public interfaces.\n-    let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n+    let mut checker = PrivateItemsInPublicInterfacesChecker {\n         tcx,\n         // Only definition IDs are ever searched in `old_error_set_ancestry`,\n         // so we can filter away all non-definition IDs at this point.\n@@ -2078,5 +2078,8 @@ fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n             .filter_map(|hir_id| tcx.hir().opt_local_def_id(hir_id))\n             .collect(),\n     };\n-    tcx.hir().visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n+\n+    for id in tcx.hir().items() {\n+        checker.check_item(id);\n+    }\n }"}, {"sha": "29134bd168cf9da95cde21ccc1dbce5c967ad13e", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -59,10 +59,7 @@ struct OnlySelfBounds(bool);\n // Main entry point\n \n fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    tcx.hir().visit_item_likes_in_module(\n-        module_def_id,\n-        &mut CollectItemTypesVisitor { tcx }.as_deep_visitor(),\n-    );\n+    tcx.hir().deep_visit_item_likes_in_module(module_def_id, &mut CollectItemTypesVisitor { tcx });\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "e0aed1e1ed434cf228db4581906b8a68737093ac", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -303,7 +303,7 @@ crate fn run(\n         // Run call-finder on all items\n         let mut calls = FxHashMap::default();\n         let mut finder = FindCalls { calls: &mut calls, tcx, map: tcx.hir(), cx, target_crates };\n-        tcx.hir().visit_all_item_likes(&mut finder.as_deep_visitor());\n+        tcx.hir().deep_visit_all_item_likes(&mut finder);\n \n         // Sort call locations within a given file in document order\n         for fn_calls in calls.values_mut() {"}, {"sha": "c3b82aa853c786e757577df794518aa2a7c6ca6a", "filename": "src/test/run-make-fulldeps/obtain-borrowck/driver.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -21,7 +21,7 @@ extern crate rustc_session;\n use rustc_borrowck::consumers::BodyWithBorrowckFacts;\n use rustc_driver::Compilation;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_hir::def::DefKind;\n use rustc_interface::interface::Compiler;\n use rustc_interface::{Config, Queries};\n use rustc_middle::ty::query::query_values::mir_borrowck;\n@@ -65,11 +65,34 @@ impl rustc_driver::Callbacks for CompilerCalls {\n         queries.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n             // Collect definition ids of MIR bodies.\n             let hir = tcx.hir();\n-            let mut visitor = HirVisitor { bodies: Vec::new() };\n-            hir.visit_all_item_likes(&mut visitor);\n+            let mut bodies = Vec::new();\n+\n+            let crate_items = tcx.hir_crate_items(());\n+            for id in crate_items.items() {\n+                if matches!(tcx.def_kind(id.def_id), DefKind::Fn) {\n+                    bodies.push(id.def_id);\n+                }\n+            }\n+\n+            for id in crate_items.trait_items() {\n+                if matches!(tcx.def_kind(id.def_id), DefKind::AssocFn) {\n+                    let trait_item = hir.trait_item(id);\n+                    if let rustc_hir::TraitItemKind::Fn(_, trait_fn) = &trait_item.kind {\n+                        if let rustc_hir::TraitFn::Provided(_) = trait_fn {\n+                            bodies.push(trait_item.def_id);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            for id in crate_items.impl_items() {\n+                if matches!(tcx.def_kind(id.def_id), DefKind::AssocFn) {\n+                    bodies.push(id.def_id);\n+                }\n+            }\n \n             // Trigger borrow checking of all bodies.\n-            for def_id in visitor.bodies {\n+            for def_id in bodies {\n                 let _ = tcx.optimized_mir(def_id);\n             }\n \n@@ -121,35 +144,6 @@ fn mir_borrowck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> mir_borrowck<'tc\n     original_mir_borrowck(tcx, def_id)\n }\n \n-/// Visitor that collects all body definition ids mentioned in the program.\n-struct HirVisitor {\n-    bodies: Vec<LocalDefId>,\n-}\n-\n-impl<'tcx> ItemLikeVisitor<'tcx> for HirVisitor {\n-    fn visit_item(&mut self, item: &rustc_hir::Item) {\n-        if let rustc_hir::ItemKind::Fn(..) = item.kind {\n-            self.bodies.push(item.def_id);\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &rustc_hir::TraitItem) {\n-        if let rustc_hir::TraitItemKind::Fn(_, trait_fn) = &trait_item.kind {\n-            if let rustc_hir::TraitFn::Provided(_) = trait_fn {\n-                self.bodies.push(trait_item.def_id);\n-            }\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &rustc_hir::ImplItem) {\n-        if let rustc_hir::ImplItemKind::Fn(..) = impl_item.kind {\n-            self.bodies.push(impl_item.def_id);\n-        }\n-    }\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &rustc_hir::ForeignItem) {}\n-}\n-\n /// Pull MIR bodies stored in the thread-local.\n fn get_bodies<'tcx>(tcx: TyCtxt<'tcx>) -> Vec<(String, BodyWithBorrowckFacts<'tcx>)> {\n     MIR_BODIES.with(|state| {"}, {"sha": "fa8c39427323c8fd89e7d87bf3cf2991c10393c8", "filename": "src/test/ui/error-codes/E0138.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/src%2Ftest%2Fui%2Ferror-codes%2FE0138.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/src%2Ftest%2Fui%2Ferror-codes%2FE0138.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0138.stderr?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -2,10 +2,10 @@ error[E0138]: multiple `start` functions\n   --> $DIR/E0138.rs:7:1\n    |\n LL | fn foo(argc: isize, argv: *const *const u8) -> isize { 0 }\n-   | ---------------------------------------------------------- previous `#[start]` function here\n+   | ---------------------------------------------------- previous `#[start]` function here\n ...\n LL | fn f(argc: isize, argv: *const *const u8) -> isize { 0 }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ multiple `start` functions\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ multiple `start` functions\n \n error: aborting due to previous error\n "}, {"sha": "3d64b0a67a1dfe5fafe61e52cdfe2c67110facfb", "filename": "src/test/ui/main-wrong-location.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/src%2Ftest%2Fui%2Fmain-wrong-location.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/src%2Ftest%2Fui%2Fmain-wrong-location.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmain-wrong-location.stderr?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -8,7 +8,7 @@ note: here is a function named `main`\n   --> $DIR/main-wrong-location.rs:4:5\n    |\n LL |     fn main() { }\n-   |     ^^^^^^^^^^^^^\n+   |     ^^^^^^^^^\n    = note: you have one or more functions named `main` not defined at the crate level\n    = help: consider moving the `main` function definitions\n "}, {"sha": "6db7f247a9925cb3ff2530837c3b80ed2e391498", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7355d971a954ed63293e4191f6677f60c1bc07d9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7355d971a954ed63293e4191f6677f60c1bc07d9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=7355d971a954ed63293e4191f6677f60c1bc07d9", "patch": "@@ -74,11 +74,10 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr, ExprKind, FnDecl,\n-    ForeignItem, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource,\n+    HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource,\n     Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind,\n     TraitRef, TyKind, UnOp,\n };\n@@ -2068,35 +2067,6 @@ pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n     false\n }\n \n-struct TestItemNamesVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    names: Vec<Symbol>,\n-}\n-\n-impl<'hir> ItemLikeVisitor<'hir> for TestItemNamesVisitor<'hir> {\n-    fn visit_item(&mut self, item: &Item<'_>) {\n-        if let ItemKind::Const(ty, _body) = item.kind {\n-            if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n-                // We could also check for the type name `test::TestDescAndFn`\n-                if let Res::Def(DefKind::Struct, _) = path.res {\n-                    let has_test_marker = self\n-                        .tcx\n-                        .hir()\n-                        .attrs(item.hir_id())\n-                        .iter()\n-                        .any(|a| a.has_name(sym::rustc_test_marker));\n-                    if has_test_marker {\n-                        self.names.push(item.ident.name);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    fn visit_trait_item(&mut self, _: &TraitItem<'_>) {}\n-    fn visit_impl_item(&mut self, _: &ImplItem<'_>) {}\n-    fn visit_foreign_item(&mut self, _: &ForeignItem<'_>) {}\n-}\n-\n static TEST_ITEM_NAMES_CACHE: SyncOnceCell<Mutex<FxHashMap<LocalDefId, Vec<Symbol>>>> = SyncOnceCell::new();\n \n fn with_test_item_names<'tcx>(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(&[Symbol]) -> bool) -> bool {\n@@ -2105,10 +2075,28 @@ fn with_test_item_names<'tcx>(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(\n     match map.entry(module) {\n         Entry::Occupied(entry) => f(entry.get()),\n         Entry::Vacant(entry) => {\n-            let mut visitor = TestItemNamesVisitor { tcx, names: Vec::new() };\n-            tcx.hir().visit_item_likes_in_module(module, &mut visitor);\n-            visitor.names.sort_unstable();\n-            f(&*entry.insert(visitor.names))\n+            let mut names = Vec::new();\n+            for id in tcx.hir().module_items(module) {\n+                if matches!(tcx.def_kind(id.def_id), DefKind::Const)\n+                    && let item = tcx.hir().item(id)\n+                    && let ItemKind::Const(ty, _body) = item.kind {\n+                    if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n+                        // We could also check for the type name `test::TestDescAndFn`\n+                        if let Res::Def(DefKind::Struct, _) = path.res {\n+                            let has_test_marker = tcx\n+                                .hir()\n+                                .attrs(item.hir_id())\n+                                .iter()\n+                                .any(|a| a.has_name(sym::rustc_test_marker));\n+                            if has_test_marker {\n+                                names.push(item.ident.name);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            names.sort_unstable();\n+            f(&*entry.insert(names))\n         },\n     }\n }"}]}