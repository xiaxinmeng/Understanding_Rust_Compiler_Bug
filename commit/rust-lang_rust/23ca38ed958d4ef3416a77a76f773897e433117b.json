{"sha": "23ca38ed958d4ef3416a77a76f773897e433117b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzY2EzOGVkOTU4ZDRlZjM0MTZhNzdhNzZmNzczODk3ZTQzMzExN2I=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-01T16:33:34Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-01T17:22:29Z"}, "message": "Factor out some pattern-stack related functions", "tree": {"sha": "ac3bba3b3589e019b1bc6e7da2554f58f5809864", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac3bba3b3589e019b1bc6e7da2554f58f5809864"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23ca38ed958d4ef3416a77a76f773897e433117b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23ca38ed958d4ef3416a77a76f773897e433117b", "html_url": "https://github.com/rust-lang/rust/commit/23ca38ed958d4ef3416a77a76f773897e433117b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23ca38ed958d4ef3416a77a76f773897e433117b/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "403d6bd995dc6a5e708dfe28f36e900ff94723e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/403d6bd995dc6a5e708dfe28f36e900ff94723e1", "html_url": "https://github.com/rust-lang/rust/commit/403d6bd995dc6a5e708dfe28f36e900ff94723e1"}], "stats": {"total": 64, "additions": 52, "deletions": 12}, "files": [{"sha": "2bbe097047cbdc0f1fa115fce00a033c18f1ee55", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 52, "deletions": 12, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/23ca38ed958d4ef3416a77a76f773897e433117b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23ca38ed958d4ef3416a77a76f773897e433117b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=23ca38ed958d4ef3416a77a76f773897e433117b", "patch": "@@ -379,6 +379,25 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     fn iter(&self) -> impl Iterator<Item = &Pat<'tcx>> {\n         self.0.iter().map(|p| *p)\n     }\n+\n+    /// This computes `D(self)`. See top of the file for explanations.\n+    fn specialize_wildcard(&self) -> Option<Self> {\n+        if self.head().is_wildcard() { Some(self.to_tail()) } else { None }\n+    }\n+\n+    /// This computes `S(constructor, self)`. See top of the file for explanations.\n+    fn specialize_constructor<'a, 'q>(\n+        &self,\n+        cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+        constructor: &Constructor<'tcx>,\n+        wild_patterns: &[&'q Pat<'tcx>],\n+    ) -> Option<PatStack<'q, 'tcx>>\n+    where\n+        'a: 'q,\n+        'p: 'q,\n+    {\n+        specialize(cx, self, constructor, wild_patterns)\n+    }\n }\n \n impl<'p, 'tcx> Default for PatStack<'p, 'tcx> {\n@@ -407,6 +426,30 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     pub fn push(&mut self, row: PatStack<'p, 'tcx>) {\n         self.0.push(row)\n     }\n+\n+    /// This computes `D(self)`. See top of the file for explanations.\n+    fn specialize_wildcard(&self) -> Self {\n+        self.0.iter().filter_map(|r| r.specialize_wildcard()).collect()\n+    }\n+\n+    /// This computes `S(constructor, self)`. See top of the file for explanations.\n+    fn specialize_constructor<'a, 'q>(\n+        &self,\n+        cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+        constructor: &Constructor<'tcx>,\n+        wild_patterns: &[&'q Pat<'tcx>],\n+    ) -> Matrix<'q, 'tcx>\n+    where\n+        'a: 'q,\n+        'p: 'q,\n+    {\n+        Matrix(\n+            self.0\n+                .iter()\n+                .filter_map(|r| r.specialize_constructor(cx, constructor, wild_patterns))\n+                .collect(),\n+        )\n+    }\n }\n \n /// Pretty-printer for matrices of patterns, example:\n@@ -1423,11 +1466,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             .find(|result| result.is_useful())\n             .unwrap_or(NotUseful)\n         } else {\n-            let matrix = rows\n-                .iter()\n-                .filter_map(|r| if r.head().is_wildcard() { Some(r.to_tail()) } else { None })\n-                .collect();\n-            match is_useful(cx, &matrix, &v.to_tail(), witness, hir_id) {\n+            let matrix = matrix.specialize_wildcard();\n+            let v = v.to_tail();\n+            match is_useful(cx, &matrix, &v, witness, hir_id) {\n                 UsefulWithWitness(pats) => {\n                     let cx = &*cx;\n                     // In this case, there's at least one \"free\"\n@@ -1523,7 +1564,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n /// to the specialised version of both the pattern matrix `P` and the new pattern `q`.\n fn is_useful_specialized<'p, 'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    &Matrix(ref m): &Matrix<'p, 'tcx>,\n+    matrix: &Matrix<'p, 'tcx>,\n     v: &PatStack<'_, 'tcx>,\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n@@ -1535,9 +1576,8 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n     let wild_patterns_owned: Vec<_> =\n         sub_pat_tys.iter().map(|ty| Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild }).collect();\n     let wild_patterns: Vec<_> = wild_patterns_owned.iter().collect();\n-    let matrix =\n-        Matrix(m.iter().filter_map(|r| specialize(cx, &r, &ctor, &wild_patterns)).collect());\n-    match specialize(cx, v, &ctor, &wild_patterns) {\n+    let matrix = matrix.specialize_constructor(cx, &ctor, &wild_patterns);\n+    match v.specialize_constructor(cx, &ctor, &wild_patterns) {\n         Some(v) => match is_useful(cx, &matrix, &v, witness, hir_id) {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n                 witnesses\n@@ -2013,7 +2053,7 @@ fn specialize<'p, 'a: 'p, 'q: 'p, 'tcx>(\n ) -> Option<PatStack<'p, 'tcx>> {\n     let pat = r.head();\n \n-    let head = match *pat.kind {\n+    let new_head = match *pat.kind {\n         PatKind::AscribeUserType { ref subpattern, .. } => {\n             specialize(cx, &PatStack::from_pattern(subpattern), constructor, wild_patterns)\n         }\n@@ -2167,9 +2207,9 @@ fn specialize<'p, 'a: 'p, 'q: 'p, 'tcx>(\n             bug!(\"support for or-patterns has not been fully implemented yet.\");\n         }\n     };\n-    debug!(\"specialize({:#?}, {:#?}) = {:#?}\", r.head(), wild_patterns, head);\n+    debug!(\"specialize({:#?}, {:#?}) = {:#?}\", r.head(), wild_patterns, new_head);\n \n-    head.map(|head| {\n+    new_head.map(|head| {\n         let mut head = head.0;\n         head.extend_from_slice(&r.0[1..]);\n         PatStack::from_vec(head)"}]}