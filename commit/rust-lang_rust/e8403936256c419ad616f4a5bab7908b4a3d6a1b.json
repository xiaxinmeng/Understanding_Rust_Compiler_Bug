{"sha": "e8403936256c419ad616f4a5bab7908b4a3d6a1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NDAzOTM2MjU2YzQxOWFkNjE2ZjRhNWJhYjc5MDhiNGEzZDZhMWI=", "commit": {"author": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2015-05-16T23:25:17Z"}, "committer": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2015-05-16T23:25:17Z"}, "message": "Make `Arc` support DSTs", "tree": {"sha": "eafe522c8971c43913eec7c5ce5a89965c89ce27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eafe522c8971c43913eec7c5ce5a89965c89ce27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8403936256c419ad616f4a5bab7908b4a3d6a1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8403936256c419ad616f4a5bab7908b4a3d6a1b", "html_url": "https://github.com/rust-lang/rust/commit/e8403936256c419ad616f4a5bab7908b4a3d6a1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8403936256c419ad616f4a5bab7908b4a3d6a1b/comments", "author": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d332aead906922409e54e6321fbdc774208e692f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d332aead906922409e54e6321fbdc774208e692f", "html_url": "https://github.com/rust-lang/rust/commit/d332aead906922409e54e6321fbdc774208e692f"}], "stats": {"total": 779, "additions": 743, "deletions": 36}, "files": [{"sha": "ff942444a617638a0b2b222fd5d1f84edcf074c4", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 50, "deletions": 36, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e8403936256c419ad616f4a5bab7908b4a3d6a1b/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8403936256c419ad616f4a5bab7908b4a3d6a1b/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=e8403936256c419ad616f4a5bab7908b4a3d6a1b", "patch": "@@ -77,11 +77,12 @@ use core::atomic;\n use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n use core::fmt;\n use core::cmp::Ordering;\n-use core::mem::{min_align_of, size_of};\n+use core::mem::{min_align_of_val, size_of_val};\n+use core::intrinsics::drop_in_place;\n use core::mem;\n use core::nonzero::NonZero;\n-use core::ops::Deref;\n-use core::ptr;\n+use core::ops::{Deref, CoerceUnsized};\n+use core::marker::Unsize;\n use core::hash::{Hash, Hasher};\n use heap::deallocate;\n \n@@ -118,15 +119,16 @@ use heap::deallocate;\n /// ```\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Arc<T> {\n+pub struct Arc<T: ?Sized> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _ptr: NonZero<*mut ArcInner<T>>,\n }\n \n-unsafe impl<T: Sync + Send> Send for Arc<T> { }\n-unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n+unsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> { }\n+unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> { }\n \n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n \n /// A weak pointer to an `Arc`.\n ///\n@@ -135,30 +137,30 @@ unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n #[unsafe_no_drop_flag]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n-pub struct Weak<T> {\n+pub struct Weak<T: ?Sized> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _ptr: NonZero<*mut ArcInner<T>>,\n }\n \n-unsafe impl<T: Sync + Send> Send for Weak<T> { }\n-unsafe impl<T: Sync + Send> Sync for Weak<T> { }\n+unsafe impl<T: ?Sized + Sync + Send> Send for Weak<T> { }\n+unsafe impl<T: ?Sized + Sync + Send> Sync for Weak<T> { }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Weak<T> {\n+impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }\n }\n \n-struct ArcInner<T> {\n+struct ArcInner<T: ?Sized> {\n     strong: atomic::AtomicUsize,\n     weak: atomic::AtomicUsize,\n     data: T,\n }\n \n-unsafe impl<T: Sync + Send> Send for ArcInner<T> {}\n-unsafe impl<T: Sync + Send> Sync for ArcInner<T> {}\n+unsafe impl<T: ?Sized + Sync + Send> Send for ArcInner<T> {}\n+unsafe impl<T: ?Sized + Sync + Send> Sync for ArcInner<T> {}\n \n impl<T> Arc<T> {\n     /// Constructs a new `Arc<T>`.\n@@ -182,7 +184,9 @@ impl<T> Arc<T> {\n         };\n         Arc { _ptr: unsafe { NonZero::new(mem::transmute(x)) } }\n     }\n+}\n \n+impl<T: ?Sized> Arc<T> {\n     /// Downgrades the `Arc<T>` to a `Weak<T>` reference.\n     ///\n     /// # Examples\n@@ -204,7 +208,7 @@ impl<T> Arc<T> {\n     }\n }\n \n-impl<T> Arc<T> {\n+impl<T: ?Sized> Arc<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // This unsafety is ok because while this arc is alive we're guaranteed\n@@ -222,24 +226,24 @@ impl<T> Arc<T> {\n \n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n-        drop(ptr::read(&self.inner().data));\n+        drop_in_place(&mut (*ptr).data);\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(), min_align_of::<ArcInner<T>>())\n+            deallocate(ptr as *mut u8, size_of_val(&*ptr), min_align_of_val(&*ptr))\n         }\n     }\n }\n \n /// Get the number of weak references to this value.\n #[inline]\n #[unstable(feature = \"alloc\")]\n-pub fn weak_count<T>(this: &Arc<T>) -> usize { this.inner().weak.load(SeqCst) - 1 }\n+pub fn weak_count<T: ?Sized>(this: &Arc<T>) -> usize { this.inner().weak.load(SeqCst) - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n #[unstable(feature = \"alloc\")]\n-pub fn strong_count<T>(this: &Arc<T>) -> usize { this.inner().strong.load(SeqCst) }\n+pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { this.inner().strong.load(SeqCst) }\n \n \n /// Returns a mutable reference to the contained value if the `Arc<T>` is unique.\n@@ -264,7 +268,7 @@ pub fn strong_count<T>(this: &Arc<T>) -> usize { this.inner().strong.load(SeqCst\n /// ```\n #[inline]\n #[unstable(feature = \"alloc\")]\n-pub fn get_mut<T>(this: &mut Arc<T>) -> Option<&mut T> {\n+pub fn get_mut<T: ?Sized>(this: &mut Arc<T>) -> Option<&mut T> {\n     if strong_count(this) == 1 && weak_count(this) == 0 {\n         // This unsafety is ok because we're guaranteed that the pointer\n         // returned is the *only* pointer that will ever be returned to T. Our\n@@ -279,7 +283,7 @@ pub fn get_mut<T>(this: &mut Arc<T>) -> Option<&mut T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for Arc<T> {\n+impl<T: ?Sized> Clone for Arc<T> {\n     /// Makes a clone of the `Arc<T>`.\n     ///\n     /// This increases the strong reference count.\n@@ -313,7 +317,7 @@ impl<T> Clone for Arc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Deref for Arc<T> {\n+impl<T: ?Sized> Deref for Arc<T> {\n     type Target = T;\n \n     #[inline]\n@@ -356,7 +360,7 @@ impl<T: Clone> Arc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Arc<T> {\n+impl<T: ?Sized> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n     ///\n     /// This will decrement the strong reference count. If the strong reference\n@@ -390,7 +394,7 @@ impl<T> Drop for Arc<T> {\n         // it's run more than once)\n         let ptr = *self._ptr;\n         // if ptr.is_null() { return }\n-        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n+        if ptr as usize == 0 || ptr as usize == mem::POST_DROP_USIZE { return }\n \n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n         // with other threads unless we are going to delete the object. This\n@@ -424,7 +428,7 @@ impl<T> Drop for Arc<T> {\n \n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n-impl<T> Weak<T> {\n+impl<T: ?Sized> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n     /// Upgrades the `Weak<T>` reference to an `Arc<T>`, if possible.\n@@ -465,7 +469,7 @@ impl<T> Weak<T> {\n \n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n-impl<T> Clone for Weak<T> {\n+impl<T: ?Sized> Clone for Weak<T> {\n     /// Makes a clone of the `Weak<T>`.\n     ///\n     /// This increases the weak reference count.\n@@ -489,7 +493,7 @@ impl<T> Clone for Weak<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Weak<T> {\n+impl<T: ?Sized> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///\n     /// This will decrement the weak reference count.\n@@ -520,21 +524,22 @@ impl<T> Drop for Weak<T> {\n         let ptr = *self._ptr;\n \n         // see comments above for why this check is here\n-        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n+        if ptr as usize == 0 || ptr as usize == mem::POST_DROP_USIZE { return }\n \n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about\n         // the memory orderings\n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n-                                min_align_of::<ArcInner<T>>()) }\n+            unsafe { deallocate(ptr as *mut u8,\n+                                size_of_val(&*ptr),\n+                                min_align_of_val(&*ptr)) }\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialEq> PartialEq for Arc<T> {\n+impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc<T>`s.\n     ///\n     /// Two `Arc<T>`s are equal if their inner value are equal.\n@@ -566,7 +571,7 @@ impl<T: PartialEq> PartialEq for Arc<T> {\n     fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialOrd> PartialOrd for Arc<T> {\n+impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     /// Partial comparison for two `Arc<T>`s.\n     ///\n     /// The two are compared by calling `partial_cmp()` on their inner values.\n@@ -645,21 +650,21 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> Ord for Arc<T> {\n+impl<T: ?Sized + Ord> Ord for Arc<T> {\n     fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Eq> Eq for Arc<T> {}\n+impl<T: ?Sized + Eq> Eq for Arc<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Display> fmt::Display for Arc<T> {\n+impl<T: ?Sized + fmt::Display> fmt::Display for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Arc<T> {\n+impl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n@@ -679,7 +684,7 @@ impl<T: Default> Default for Arc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Hash> Hash for Arc<T> {\n+impl<T: ?Sized + Hash> Hash for Arc<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state)\n     }\n@@ -906,4 +911,13 @@ mod tests {\n     // Make sure deriving works with Arc<T>\n     #[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n     struct Foo { inner: Arc<i32> }\n+\n+    #[test]\n+    fn test_unsized() {\n+        let x: Arc<[i32]> = Arc::new([1, 2, 3]);\n+        assert_eq!(format!(\"{:?}\", x), \"[1, 2, 3]\");\n+        let y = x.clone().downgrade();\n+        drop(x);\n+        assert!(y.upgrade().is_none());\n+    }\n }"}, {"sha": "290b0566fd1b53d768858dc38e17df26049b0aec", "filename": "src/liballoc/arc_stage0.rs", "status": "added", "additions": 686, "deletions": 0, "changes": 686, "blob_url": "https://github.com/rust-lang/rust/blob/e8403936256c419ad616f4a5bab7908b4a3d6a1b/src%2Fliballoc%2Farc_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8403936256c419ad616f4a5bab7908b4a3d6a1b/src%2Fliballoc%2Farc_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc_stage0.rs?ref=e8403936256c419ad616f4a5bab7908b4a3d6a1b", "patch": "@@ -0,0 +1,686 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+//! Threadsafe reference-counted boxes (the `Arc<T>` type).\n+//!\n+//! The `Arc<T>` type provides shared ownership of an immutable value.\n+//! Destruction is deterministic, and will occur as soon as the last owner is\n+//! gone. It is marked as `Send` because it uses atomic reference counting.\n+//!\n+//! If you do not need thread-safety, and just need shared ownership, consider\n+//! the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n+//! does not use atomics, making it both thread-unsafe as well as significantly\n+//! faster when updating the reference count.\n+//!\n+//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n+//! to the box. A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n+//! will return `None` if the value has already been dropped.\n+//!\n+//! For example, a tree with parent pointers can be represented by putting the\n+//! nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n+//! as `Weak<T>` pointers.\n+//!\n+//! # Examples\n+//!\n+//! Sharing some immutable data between threads:\n+//!\n+//! ```no_run\n+//! use std::sync::Arc;\n+//! use std::thread;\n+//!\n+//! let five = Arc::new(5);\n+//!\n+//! for _ in 0..10 {\n+//!     let five = five.clone();\n+//!\n+//!     thread::spawn(move || {\n+//!         println!(\"{:?}\", five);\n+//!     });\n+//! }\n+//! ```\n+//!\n+//! Sharing mutable data safely between threads with a `Mutex`:\n+//!\n+//! ```no_run\n+//! use std::sync::{Arc, Mutex};\n+//! use std::thread;\n+//!\n+//! let five = Arc::new(Mutex::new(5));\n+//!\n+//! for _ in 0..10 {\n+//!     let five = five.clone();\n+//!\n+//!     thread::spawn(move || {\n+//!         let mut number = five.lock().unwrap();\n+//!\n+//!         *number += 1;\n+//!\n+//!         println!(\"{}\", *number); // prints 6\n+//!     });\n+//! }\n+//! ```\n+\n+use boxed::Box;\n+\n+use core::prelude::*;\n+\n+use core::atomic;\n+use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n+use core::fmt;\n+use core::cmp::Ordering;\n+use core::mem::{min_align_of, size_of};\n+use core::mem;\n+use core::nonzero::NonZero;\n+use core::ops::Deref;\n+use core::ptr;\n+use core::hash::{Hash, Hasher};\n+use heap::deallocate;\n+\n+/// An atomically reference counted wrapper for shared state.\n+///\n+/// # Examples\n+///\n+/// In this example, a large vector of floats is shared between several threads.\n+/// With simple pipes, without `Arc`, a copy would have to be made for each\n+/// thread.\n+///\n+/// When you clone an `Arc<T>`, it will create another pointer to the data and\n+/// increase the reference counter.\n+///\n+/// ```\n+/// # #![feature(alloc, core)]\n+/// use std::sync::Arc;\n+/// use std::thread;\n+///\n+/// fn main() {\n+///     let numbers: Vec<_> = (0..100u32).collect();\n+///     let shared_numbers = Arc::new(numbers);\n+///\n+///     for _ in 0..10 {\n+///         let child_numbers = shared_numbers.clone();\n+///\n+///         thread::spawn(move || {\n+///             let local_numbers = &child_numbers[..];\n+///\n+///             // Work with the local numbers\n+///         });\n+///     }\n+/// }\n+/// ```\n+#[unsafe_no_drop_flag]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Arc<T> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _ptr: NonZero<*mut ArcInner<T>>,\n+}\n+\n+unsafe impl<T: Sync + Send> Send for Arc<T> { }\n+unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n+\n+\n+/// A weak pointer to an `Arc`.\n+///\n+/// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n+/// used to break cycles between `Arc` pointers.\n+#[unsafe_no_drop_flag]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n+pub struct Weak<T> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _ptr: NonZero<*mut ArcInner<T>>,\n+}\n+\n+unsafe impl<T: Sync + Send> Send for Weak<T> { }\n+unsafe impl<T: Sync + Send> Sync for Weak<T> { }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Debug> fmt::Debug for Weak<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"(Weak)\")\n+    }\n+}\n+\n+struct ArcInner<T> {\n+    strong: atomic::AtomicUsize,\n+    weak: atomic::AtomicUsize,\n+    data: T,\n+}\n+\n+unsafe impl<T: Sync + Send> Send for ArcInner<T> {}\n+unsafe impl<T: Sync + Send> Sync for ArcInner<T> {}\n+\n+impl<T> Arc<T> {\n+    /// Constructs a new `Arc<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new(data: T) -> Arc<T> {\n+        // Start the weak pointer count as 1 which is the weak pointer that's\n+        // held by all the strong pointers (kinda), see std/rc.rs for more info\n+        let x: Box<_> = box ArcInner {\n+            strong: atomic::AtomicUsize::new(1),\n+            weak: atomic::AtomicUsize::new(1),\n+            data: data,\n+        };\n+        Arc { _ptr: unsafe { NonZero::new(mem::transmute(x)) } }\n+    }\n+\n+    /// Downgrades the `Arc<T>` to a `Weak<T>` reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    /// ```\n+    #[unstable(feature = \"alloc\",\n+               reason = \"Weak pointers may not belong in this module.\")]\n+    pub fn downgrade(&self) -> Weak<T> {\n+        // See the clone() impl for why this is relaxed\n+        self.inner().weak.fetch_add(1, Relaxed);\n+        Weak { _ptr: self._ptr }\n+    }\n+}\n+\n+impl<T> Arc<T> {\n+    #[inline]\n+    fn inner(&self) -> &ArcInner<T> {\n+        // This unsafety is ok because while this arc is alive we're guaranteed\n+        // that the inner pointer is valid. Furthermore, we know that the\n+        // `ArcInner` structure itself is `Sync` because the inner data is\n+        // `Sync` as well, so we're ok loaning out an immutable pointer to these\n+        // contents.\n+        unsafe { &**self._ptr }\n+    }\n+\n+    // Non-inlined part of `drop`.\n+    #[inline(never)]\n+    unsafe fn drop_slow(&mut self) {\n+        let ptr = *self._ptr;\n+\n+        // Destroy the data at this time, even though we may not free the box\n+        // allocation itself (there may still be weak pointers lying around).\n+        drop(ptr::read(&self.inner().data));\n+\n+        if self.inner().weak.fetch_sub(1, Release) == 1 {\n+            atomic::fence(Acquire);\n+            deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(), min_align_of::<ArcInner<T>>())\n+        }\n+    }\n+}\n+\n+/// Get the number of weak references to this value.\n+#[inline]\n+#[unstable(feature = \"alloc\")]\n+pub fn weak_count<T>(this: &Arc<T>) -> usize { this.inner().weak.load(SeqCst) - 1 }\n+\n+/// Get the number of strong references to this value.\n+#[inline]\n+#[unstable(feature = \"alloc\")]\n+pub fn strong_count<T>(this: &Arc<T>) -> usize { this.inner().strong.load(SeqCst) }\n+\n+\n+/// Returns a mutable reference to the contained value if the `Arc<T>` is unique.\n+///\n+/// Returns `None` if the `Arc<T>` is not unique.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![feature(alloc)]\n+/// extern crate alloc;\n+/// # fn main() {\n+/// use alloc::arc::{Arc, get_mut};\n+///\n+/// let mut x = Arc::new(3);\n+/// *get_mut(&mut x).unwrap() = 4;\n+/// assert_eq!(*x, 4);\n+///\n+/// let _y = x.clone();\n+/// assert!(get_mut(&mut x).is_none());\n+/// # }\n+/// ```\n+#[inline]\n+#[unstable(feature = \"alloc\")]\n+pub fn get_mut<T>(this: &mut Arc<T>) -> Option<&mut T> {\n+    if strong_count(this) == 1 && weak_count(this) == 0 {\n+        // This unsafety is ok because we're guaranteed that the pointer\n+        // returned is the *only* pointer that will ever be returned to T. Our\n+        // reference count is guaranteed to be 1 at this point, and we required\n+        // the Arc itself to be `mut`, so we're returning the only possible\n+        // reference to the inner data.\n+        let inner = unsafe { &mut **this._ptr };\n+        Some(&mut inner.data)\n+    } else {\n+        None\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Clone for Arc<T> {\n+    /// Makes a clone of the `Arc<T>`.\n+    ///\n+    /// This increases the strong reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// five.clone();\n+    /// ```\n+    #[inline]\n+    fn clone(&self) -> Arc<T> {\n+        // Using a relaxed ordering is alright here, as knowledge of the\n+        // original reference prevents other threads from erroneously deleting\n+        // the object.\n+        //\n+        // As explained in the [Boost documentation][1], Increasing the\n+        // reference counter can always be done with memory_order_relaxed: New\n+        // references to an object can only be formed from an existing\n+        // reference, and passing an existing reference from one thread to\n+        // another must already provide any required synchronization.\n+        //\n+        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n+        self.inner().strong.fetch_add(1, Relaxed);\n+        Arc { _ptr: self._ptr }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Deref for Arc<T> {\n+    type Target = T;\n+\n+    #[inline]\n+    fn deref(&self) -> &T {\n+        &self.inner().data\n+    }\n+}\n+\n+impl<T: Clone> Arc<T> {\n+    /// Make a mutable reference from the given `Arc<T>`.\n+    ///\n+    /// This is also referred to as a copy-on-write operation because the inner\n+    /// data is cloned if the reference count is greater than one.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::new(5);\n+    ///\n+    /// let mut_five = five.make_unique();\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"alloc\")]\n+    pub fn make_unique(&mut self) -> &mut T {\n+        // Note that we hold a strong reference, which also counts as a weak\n+        // reference, so we only clone if there is an additional reference of\n+        // either kind.\n+        if self.inner().strong.load(SeqCst) != 1 ||\n+           self.inner().weak.load(SeqCst) != 1 {\n+            *self = Arc::new((**self).clone())\n+        }\n+        // As with `get_mut()`, the unsafety is ok because our reference was\n+        // either unique to begin with, or became one upon cloning the contents.\n+        let inner = unsafe { &mut **self._ptr };\n+        &mut inner.data\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Drop for Arc<T> {\n+    /// Drops the `Arc<T>`.\n+    ///\n+    /// This will decrement the strong reference count. If the strong reference\n+    /// count becomes zero and the only other references are `Weak<T>` ones,\n+    /// `drop`s the inner value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::sync::Arc;\n+    ///\n+    /// {\n+    ///     let five = Arc::new(5);\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(five); // explicit drop\n+    /// }\n+    /// {\n+    ///     let five = Arc::new(5);\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n+    #[inline]\n+    fn drop(&mut self) {\n+        // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n+        // more than once (but it is guaranteed to be zeroed after the first if\n+        // it's run more than once)\n+        let ptr = *self._ptr;\n+        // if ptr.is_null() { return }\n+        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n+\n+        // Because `fetch_sub` is already atomic, we do not need to synchronize\n+        // with other threads unless we are going to delete the object. This\n+        // same logic applies to the below `fetch_sub` to the `weak` count.\n+        if self.inner().strong.fetch_sub(1, Release) != 1 { return }\n+\n+        // This fence is needed to prevent reordering of use of the data and\n+        // deletion of the data.  Because it is marked `Release`, the decreasing\n+        // of the reference count synchronizes with this `Acquire` fence. This\n+        // means that use of the data happens before decreasing the reference\n+        // count, which happens before this fence, which happens before the\n+        // deletion of the data.\n+        //\n+        // As explained in the [Boost documentation][1],\n+        //\n+        // > It is important to enforce any possible access to the object in one\n+        // > thread (through an existing reference) to *happen before* deleting\n+        // > the object in a different thread. This is achieved by a \"release\"\n+        // > operation after dropping a reference (any access to the object\n+        // > through this reference must obviously happened before), and an\n+        // > \"acquire\" operation before deleting the object.\n+        //\n+        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n+        atomic::fence(Acquire);\n+\n+        unsafe {\n+            self.drop_slow()\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n+impl<T> Weak<T> {\n+    /// Upgrades a weak reference to a strong reference.\n+    ///\n+    /// Upgrades the `Weak<T>` reference to an `Arc<T>`, if possible.\n+    ///\n+    /// Returns `None` if there were no strong references and the data was\n+    /// destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    ///\n+    /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n+    /// ```\n+    pub fn upgrade(&self) -> Option<Arc<T>> {\n+        // We use a CAS loop to increment the strong count instead of a\n+        // fetch_add because once the count hits 0 it must never be above 0.\n+        let inner = self.inner();\n+        loop {\n+            let n = inner.strong.load(SeqCst);\n+            if n == 0 { return None }\n+            let old = inner.strong.compare_and_swap(n, n + 1, SeqCst);\n+            if old == n { return Some(Arc { _ptr: self._ptr }) }\n+        }\n+    }\n+\n+    #[inline]\n+    fn inner(&self) -> &ArcInner<T> {\n+        // See comments above for why this is \"safe\"\n+        unsafe { &**self._ptr }\n+    }\n+}\n+\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n+impl<T> Clone for Weak<T> {\n+    /// Makes a clone of the `Weak<T>`.\n+    ///\n+    /// This increases the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::sync::Arc;\n+    ///\n+    /// let weak_five = Arc::new(5).downgrade();\n+    ///\n+    /// weak_five.clone();\n+    /// ```\n+    #[inline]\n+    fn clone(&self) -> Weak<T> {\n+        // See comments in Arc::clone() for why this is relaxed\n+        self.inner().weak.fetch_add(1, Relaxed);\n+        Weak { _ptr: self._ptr }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Drop for Weak<T> {\n+    /// Drops the `Weak<T>`.\n+    ///\n+    /// This will decrement the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::sync::Arc;\n+    ///\n+    /// {\n+    ///     let five = Arc::new(5);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(weak_five); // explicit drop\n+    /// }\n+    /// {\n+    ///     let five = Arc::new(5);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n+    fn drop(&mut self) {\n+        let ptr = *self._ptr;\n+\n+        // see comments above for why this check is here\n+        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n+\n+        // If we find out that we were the last weak pointer, then its time to\n+        // deallocate the data entirely. See the discussion in Arc::drop() about\n+        // the memory orderings\n+        if self.inner().weak.fetch_sub(1, Release) == 1 {\n+            atomic::fence(Acquire);\n+            unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n+                                min_align_of::<ArcInner<T>>()) }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: PartialEq> PartialEq for Arc<T> {\n+    /// Equality for two `Arc<T>`s.\n+    ///\n+    /// Two `Arc<T>`s are equal if their inner value are equal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// five == Arc::new(5);\n+    /// ```\n+    fn eq(&self, other: &Arc<T>) -> bool { *(*self) == *(*other) }\n+\n+    /// Inequality for two `Arc<T>`s.\n+    ///\n+    /// Two `Arc<T>`s are unequal if their inner value are unequal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// five != Arc::new(5);\n+    /// ```\n+    fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: PartialOrd> PartialOrd for Arc<T> {\n+    /// Partial comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `partial_cmp()` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// five.partial_cmp(&Arc::new(5));\n+    /// ```\n+    fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> {\n+        (**self).partial_cmp(&**other)\n+    }\n+\n+    /// Less-than comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `<` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// five < Arc::new(5);\n+    /// ```\n+    fn lt(&self, other: &Arc<T>) -> bool { *(*self) < *(*other) }\n+\n+    /// 'Less-than or equal to' comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `<=` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// five <= Arc::new(5);\n+    /// ```\n+    fn le(&self, other: &Arc<T>) -> bool { *(*self) <= *(*other) }\n+\n+    /// Greater-than comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `>` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// five > Arc::new(5);\n+    /// ```\n+    fn gt(&self, other: &Arc<T>) -> bool { *(*self) > *(*other) }\n+\n+    /// 'Greater-than or equal to' comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `>=` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// five >= Arc::new(5);\n+    /// ```\n+    fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Ord> Ord for Arc<T> {\n+    fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Eq> Eq for Arc<T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Display> fmt::Display for Arc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&**self, f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Debug> fmt::Debug for Arc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&**self, f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> fmt::Pointer for Arc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Pointer::fmt(&*self._ptr, f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Default> Default for Arc<T> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn default() -> Arc<T> { Arc::new(Default::default()) }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Hash> Hash for Arc<T> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        (**self).hash(state)\n+    }\n+}"}, {"sha": "45dcea909f44a4f6d3af4caceeac82c8aebfe7e4", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e8403936256c419ad616f4a5bab7908b4a3d6a1b/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8403936256c419ad616f4a5bab7908b4a3d6a1b/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=e8403936256c419ad616f4a5bab7908b4a3d6a1b", "patch": "@@ -112,7 +112,14 @@ pub mod boxed;\n mod boxed { pub use std::boxed::{Box, HEAP}; }\n #[cfg(test)]\n mod boxed_test;\n+#[cfg(not(stage0))]\n pub mod arc;\n+#[cfg(stage0)]\n+mod arc_stage0;\n+#[cfg(stage0)]\n+pub mod arc {\n+    pub use arc_stage0::*;\n+}\n pub mod rc;\n \n /// Common out-of-memory routine"}]}