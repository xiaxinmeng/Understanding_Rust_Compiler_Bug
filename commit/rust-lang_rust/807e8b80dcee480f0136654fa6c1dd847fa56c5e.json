{"sha": "807e8b80dcee480f0136654fa6c1dd847fa56c5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwN2U4YjgwZGNlZTQ4MGYwMTM2NjU0ZmE2YzFkZDg0N2ZhNTZjNWU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-08T16:48:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-08T16:48:19Z"}, "message": "Rollup merge of #71581 - GuillaumeGomez:unify-lints-handling, r=kinnison\n\nUnify lints handling in rustdoc\n\nThis is a small cleanup. The goal is to unify a bit things to make the reading simpler.\n\nr? @kinnison\n\ncc @rust-lang/rustdoc", "tree": {"sha": "c14a89fce10b6962cbe47dae8a4ce4cc9cbb11d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c14a89fce10b6962cbe47dae8a4ce4cc9cbb11d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/807e8b80dcee480f0136654fa6c1dd847fa56c5e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetY1UCRBK7hj4Ov3rIwAAdHIIACcQPN5mdbmDVWOXd6trfzBV\n9sdCm8b4VM73fGWSA9OY+DxEGBeMyfhChLWduXmemkYC9TNm5krH/9Dl7ixVJVJx\np6O97CWyuH94cSIDezf7EcPF5poJQGDENQ4VV1SGF+8J+UfAQIKn9R6HKB3KhUGf\nfq5/sbTqYruibtkKN+oYOjLjD38Ugo6y3hxjWjxJFzxD6JgnJN/gdahwYXaQHZc2\nM0ZgTXijaFTjrqo0kVY4SSLO5waqyQpmgXQZAcnHJ9P/ZWb+5EBTt09VJxCHMhhB\ngn+tn/1+6qXP4LqhUa26V5PxxdWTknJCzIL87hMuo2fY+KO+yn+GpPE/Ge95t0s=\n=4/2q\n-----END PGP SIGNATURE-----\n", "payload": "tree c14a89fce10b6962cbe47dae8a4ce4cc9cbb11d2\nparent 7b805396bf46dce972692a6846ce2ad8481c5f85\nparent 9ae85e19dfb6172692908c514f4b4613fe8fe792\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588956499 +0200\ncommitter GitHub <noreply@github.com> 1588956499 +0200\n\nRollup merge of #71581 - GuillaumeGomez:unify-lints-handling, r=kinnison\n\nUnify lints handling in rustdoc\n\nThis is a small cleanup. The goal is to unify a bit things to make the reading simpler.\n\nr? @kinnison\n\ncc @rust-lang/rustdoc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/807e8b80dcee480f0136654fa6c1dd847fa56c5e", "html_url": "https://github.com/rust-lang/rust/commit/807e8b80dcee480f0136654fa6c1dd847fa56c5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/807e8b80dcee480f0136654fa6c1dd847fa56c5e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b805396bf46dce972692a6846ce2ad8481c5f85", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b805396bf46dce972692a6846ce2ad8481c5f85", "html_url": "https://github.com/rust-lang/rust/commit/7b805396bf46dce972692a6846ce2ad8481c5f85"}, {"sha": "9ae85e19dfb6172692908c514f4b4613fe8fe792", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ae85e19dfb6172692908c514f4b4613fe8fe792", "html_url": "https://github.com/rust-lang/rust/commit/9ae85e19dfb6172692908c514f4b4613fe8fe792"}], "stats": {"total": 138, "additions": 69, "deletions": 69}, "files": [{"sha": "51ad1f04340489007b488985a6367ce0b880df84", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 60, "deletions": 36, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/807e8b80dcee480f0136654fa6c1dd847fa56c5e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/807e8b80dcee480f0136654fa6c1dd847fa56c5e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=807e8b80dcee480f0136654fa6c1dd847fa56c5e", "patch": "@@ -204,6 +204,56 @@ pub fn new_handler(\n     )\n }\n \n+/// This function is used to setup the lint initialization. By default, in rustdoc, everything\n+/// is \"allowed\". Depending if we run in test mode or not, we want some of them to be at their\n+/// default level. For example, the \"INVALID_CODEBLOCK_ATTRIBUTE\" lint is activated in both\n+/// modes.\n+///\n+/// A little detail easy to forget is that there is a way to set the lint level for all lints\n+/// through the \"WARNINGS\" lint. To prevent this to happen, we set it back to its \"normal\" level\n+/// inside this function.\n+///\n+/// It returns a tuple containing:\n+///  * Vector of tuples of lints' name and their associated \"max\" level\n+///  * HashMap of lint id with their associated \"max\" level\n+pub fn init_lints<F>(\n+    mut whitelisted_lints: Vec<String>,\n+    lint_opts: Vec<(String, lint::Level)>,\n+    filter_call: F,\n+) -> (Vec<(String, lint::Level)>, FxHashMap<lint::LintId, lint::Level>)\n+where\n+    F: Fn(&lint::Lint) -> Option<(String, lint::Level)>,\n+{\n+    let warnings_lint_name = lint::builtin::WARNINGS.name;\n+\n+    whitelisted_lints.push(warnings_lint_name.to_owned());\n+    whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n+\n+    let lints = || {\n+        lint::builtin::HardwiredLints::get_lints()\n+            .into_iter()\n+            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n+    };\n+\n+    let lint_opts = lints()\n+        .filter_map(|lint| if lint.name == warnings_lint_name { None } else { filter_call(lint) })\n+        .chain(lint_opts.into_iter())\n+        .collect::<Vec<_>>();\n+\n+    let lint_caps = lints()\n+        .filter_map(|lint| {\n+            // We don't want to whitelist *all* lints so let's\n+            // ignore those ones.\n+            if whitelisted_lints.iter().any(|l| lint.name == l) {\n+                None\n+            } else {\n+                Some((lint::LintId::of(lint), lint::Allow))\n+            }\n+        })\n+        .collect();\n+    (lint_opts, lint_caps)\n+}\n+\n pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOptions) {\n     // Parse, resolve, and typecheck the given crate.\n \n@@ -247,7 +297,6 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     let input = Input::File(input);\n \n     let intra_link_resolution_failure_name = lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE.name;\n-    let warnings_lint_name = lint::builtin::WARNINGS.name;\n     let missing_docs = rustc_lint::builtin::MISSING_DOCS.name;\n     let missing_doc_example = rustc_lint::builtin::MISSING_DOC_CODE_EXAMPLES.name;\n     let private_doc_tests = rustc_lint::builtin::PRIVATE_DOC_TESTS.name;\n@@ -256,8 +305,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n     // In addition to those specific lints, we also need to whitelist those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n-    let mut whitelisted_lints = vec![\n-        warnings_lint_name.to_owned(),\n+    let whitelisted_lints = vec![\n         intra_link_resolution_failure_name.to_owned(),\n         missing_docs.to_owned(),\n         missing_doc_example.to_owned(),\n@@ -266,39 +314,15 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         invalid_codeblock_attribute_name.to_owned(),\n     ];\n \n-    whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n-\n-    let lints = || {\n-        lint::builtin::HardwiredLints::get_lints()\n-            .into_iter()\n-            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n-    };\n-\n-    let lint_opts = lints()\n-        .filter_map(|lint| {\n-            if lint.name == warnings_lint_name\n-                || lint.name == intra_link_resolution_failure_name\n-                || lint.name == invalid_codeblock_attribute_name\n-            {\n-                None\n-            } else {\n-                Some((lint.name_lower(), lint::Allow))\n-            }\n-        })\n-        .chain(lint_opts.into_iter())\n-        .collect::<Vec<_>>();\n-\n-    let lint_caps = lints()\n-        .filter_map(|lint| {\n-            // We don't want to whitelist *all* lints so let's\n-            // ignore those ones.\n-            if whitelisted_lints.iter().any(|l| lint.name == l) {\n-                None\n-            } else {\n-                Some((lint::LintId::of(lint), lint::Allow))\n-            }\n-        })\n-        .collect();\n+    let (lint_opts, lint_caps) = init_lints(whitelisted_lints, lint_opts, |lint| {\n+        if lint.name == intra_link_resolution_failure_name\n+            || lint.name == invalid_codeblock_attribute_name\n+        {\n+            None\n+        } else {\n+            Some((lint.name_lower(), lint::Allow))\n+        }\n+    });\n \n     let crate_types =\n         if proc_macro_crate { vec![CrateType::ProcMacro] } else { vec![CrateType::Rlib] };"}, {"sha": "4a9ad39e2362e173d0d9aa985462f68422bc1978", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/807e8b80dcee480f0136654fa6c1dd847fa56c5e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/807e8b80dcee480f0136654fa6c1dd847fa56c5e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=807e8b80dcee480f0136654fa6c1dd847fa56c5e", "patch": "@@ -28,6 +28,7 @@ use std::str;\n \n use crate::clean::Attributes;\n use crate::config::Options;\n+use crate::core::init_lints;\n use crate::html::markdown::{self, ErrorCodes, Ignore, LangString};\n use crate::passes::span_of_attrs;\n \n@@ -45,44 +46,19 @@ pub struct TestOptions {\n pub fn run(options: Options) -> i32 {\n     let input = config::Input::File(options.input.clone());\n \n-    let warnings_lint_name = lint::builtin::WARNINGS.name;\n     let invalid_codeblock_attribute_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTE.name;\n \n     // In addition to those specific lints, we also need to whitelist those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n-    let mut whitelisted_lints =\n-        vec![warnings_lint_name.to_owned(), invalid_codeblock_attribute_name.to_owned()];\n+    let whitelisted_lints = vec![invalid_codeblock_attribute_name.to_owned()];\n \n-    whitelisted_lints.extend(options.lint_opts.iter().map(|(lint, _)| lint).cloned());\n-\n-    let lints = || {\n-        lint::builtin::HardwiredLints::get_lints()\n-            .into_iter()\n-            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n-    };\n-\n-    let lint_opts = lints()\n-        .filter_map(|lint| {\n-            if lint.name == warnings_lint_name || lint.name == invalid_codeblock_attribute_name {\n-                None\n-            } else {\n-                Some((lint.name_lower(), lint::Allow))\n-            }\n-        })\n-        .chain(options.lint_opts.clone().into_iter())\n-        .collect::<Vec<_>>();\n-\n-    let lint_caps = lints()\n-        .filter_map(|lint| {\n-            // We don't want to whitelist *all* lints so let's\n-            // ignore those ones.\n-            if whitelisted_lints.iter().any(|l| lint.name == l) {\n-                None\n-            } else {\n-                Some((lint::LintId::of(lint), lint::Allow))\n-            }\n-        })\n-        .collect();\n+    let (lint_opts, lint_caps) = init_lints(whitelisted_lints, options.lint_opts.clone(), |lint| {\n+        if lint.name == invalid_codeblock_attribute_name {\n+            None\n+        } else {\n+            Some((lint.name_lower(), lint::Allow))\n+        }\n+    });\n \n     let crate_types =\n         if options.proc_macro_crate { vec![CrateType::ProcMacro] } else { vec![CrateType::Rlib] };"}]}