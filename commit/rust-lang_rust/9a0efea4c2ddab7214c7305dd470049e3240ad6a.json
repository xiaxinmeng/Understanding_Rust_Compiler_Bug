{"sha": "9a0efea4c2ddab7214c7305dd470049e3240ad6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMGVmZWE0YzJkZGFiNzIxNGM3MzA1ZGQ0NzAwNDllMzI0MGFkNmE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-13T11:35:04Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:29Z"}, "message": "rustc: pre-compute field placements out of Layout.", "tree": {"sha": "c50eb695011e95c0e792eb2f9b93e311ba72c608", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c50eb695011e95c0e792eb2f9b93e311ba72c608"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a0efea4c2ddab7214c7305dd470049e3240ad6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a0efea4c2ddab7214c7305dd470049e3240ad6a", "html_url": "https://github.com/rust-lang/rust/commit/9a0efea4c2ddab7214c7305dd470049e3240ad6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a0efea4c2ddab7214c7305dd470049e3240ad6a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "html_url": "https://github.com/rust-lang/rust/commit/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9"}], "stats": {"total": 369, "additions": 228, "deletions": 141}, "files": [{"sha": "a08a9ddcd1ab31f82cf42885080b586c79fb4ce0", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 210, "deletions": 124, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9a0efea4c2ddab7214c7305dd470049e3240ad6a", "patch": "@@ -836,7 +836,7 @@ impl<'a, 'tcx> Struct {\n             }\n \n             (&FatPointer { non_zero: true, .. }, _) => {\n-                Ok(Some((layout.field_offset(tcx, FAT_PTR_ADDR), Pointer)))\n+                Ok(Some((layout.fields.offset(FAT_PTR_ADDR), Pointer)))\n             }\n \n             // Is this the NonZero lang item wrapping a pointer or integer type?\n@@ -846,11 +846,11 @@ impl<'a, 'tcx> Struct {\n                     // FIXME(eddyb) also allow floating-point types here.\n                     Scalar { value: value @ Int(_), non_zero: false } |\n                     Scalar { value: value @ Pointer, non_zero: false } => {\n-                        Ok(Some((layout.field_offset(tcx, 0), value)))\n+                        Ok(Some((layout.fields.offset(0), value)))\n                     }\n                     FatPointer { non_zero: false, .. } => {\n-                        Ok(Some((layout.field_offset(tcx, 0) +\n-                                 field.field_offset(tcx, FAT_PTR_ADDR),\n+                        Ok(Some((layout.fields.offset(0) +\n+                                 field.fields.offset(FAT_PTR_ADDR),\n                                  Pointer)))\n                     }\n                     _ => Ok(None)\n@@ -862,7 +862,7 @@ impl<'a, 'tcx> Struct {\n                 variant.non_zero_field(\n                     tcx,\n                     param_env,\n-                    (0..layout.field_count()).map(|i| layout.field(cx, i)))\n+                    (0..layout.fields.count()).map(|i| layout.field(cx, i)))\n             }\n \n             // Is this a fixed-size array of something non-zero\n@@ -991,6 +991,59 @@ pub const FAT_PTR_ADDR: usize = 0;\n /// - For a slice, this is the length.\n pub const FAT_PTR_EXTRA: usize = 1;\n \n+/// Describes how the fields of a type are located in memory.\n+#[derive(Copy, Clone, Debug)]\n+pub enum FieldPlacement<'a> {\n+    /// Array-like placement. Can also express\n+    /// unions, by using a stride of zero bytes.\n+    Linear {\n+        stride: Size,\n+        count: u64\n+    },\n+\n+    /// Struct-like placement, with precomputed offsets.\n+    ///\n+    /// Fields are guaranteed to not overlap, but note that gaps\n+    /// before, between and after all the fields are NOT always\n+    /// padding, and as such their contents may not be discarded.\n+    /// For example, enum variants leave a gap at the start,\n+    /// where the discriminant field in the enum layout goes.\n+    Arbitrary {\n+        offsets: &'a [Size]\n+    }\n+}\n+\n+impl<'a> FieldPlacement<'a> {\n+    pub fn union(count: usize) -> Self {\n+        FieldPlacement::Linear {\n+            stride: Size::from_bytes(0),\n+            count: count as u64\n+        }\n+    }\n+\n+    pub fn count(&self) -> usize {\n+        match *self {\n+            FieldPlacement::Linear { count, .. } => {\n+                let usize_count = count as usize;\n+                assert_eq!(usize_count as u64, count);\n+                usize_count\n+            }\n+            FieldPlacement::Arbitrary { offsets } => offsets.len()\n+        }\n+    }\n+\n+    pub fn offset(&self, i: usize) -> Size {\n+        match *self {\n+            FieldPlacement::Linear { stride, count, .. } => {\n+                let i = i as u64;\n+                assert!(i < count);\n+                stride * i\n+            }\n+            FieldPlacement::Arbitrary { offsets } => offsets[i]\n+        }\n+    }\n+}\n+\n /// Type layout, from which size and alignment can be cheaply computed.\n /// For ADTs, it also includes field placement and enum optimizations.\n /// NOTE: Because Layout is interned, redundant information should be\n@@ -1105,9 +1158,15 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct CachedLayout<'tcx> {\n+    pub layout: &'tcx Layout,\n+    pub fields: FieldPlacement<'tcx>,\n+}\n+\n fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                        -> Result<&'tcx Layout, LayoutError<'tcx>>\n+                        -> Result<CachedLayout<'tcx>, LayoutError<'tcx>>\n {\n     let (param_env, ty) = query.into_parts();\n \n@@ -1136,10 +1195,59 @@ impl<'a, 'tcx> Layout {\n     fn compute_uncached(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         param_env: ty::ParamEnv<'tcx>,\n                         ty: Ty<'tcx>)\n-                        -> Result<&'tcx Layout, LayoutError<'tcx>> {\n-        let success = |layout| Ok(tcx.intern_layout(layout));\n+                        -> Result<CachedLayout<'tcx>, LayoutError<'tcx>> {\n         let cx = (tcx, param_env);\n         let dl = cx.data_layout();\n+        let success = |layout| {\n+            let layout = tcx.intern_layout(layout);\n+            let fields = match *layout {\n+                Scalar { .. } |\n+                CEnum { .. } |\n+                RawNullablePointer { .. } |\n+                StructWrappedNullablePointer { .. } => {\n+                    FieldPlacement::union(0)\n+                }\n+\n+                Vector { element, count } => {\n+                    FieldPlacement::Linear {\n+                        stride: element.size(tcx),\n+                        count\n+                    }\n+                }\n+\n+                Array { element_size, count, .. } => {\n+                    FieldPlacement::Linear {\n+                        stride: element_size,\n+                        count\n+                    }\n+                }\n+\n+                FatPointer { .. } => {\n+                    FieldPlacement::Linear {\n+                        stride: Pointer.size(tcx),\n+                        count: 2\n+                    }\n+                }\n+\n+                Univariant(ref variant) => {\n+                    FieldPlacement::Arbitrary {\n+                        offsets: &variant.offsets\n+                    }\n+                }\n+\n+                UntaggedUnion(_) => {\n+                    // Handle unions through the type rather than Layout.\n+                    let def = ty.ty_adt_def().unwrap();\n+                    FieldPlacement::union(def.struct_variant().fields.len())\n+                }\n+\n+                General { .. } => FieldPlacement::union(1)\n+            };\n+            Ok(CachedLayout {\n+                layout,\n+                fields\n+            })\n+        };\n         assert!(!ty.has_infer_types());\n \n         let ptr_layout = |pointee: Ty<'tcx>| {\n@@ -1536,7 +1644,11 @@ impl<'a, 'tcx> Layout {\n                 if ty == normalized {\n                     return Err(LayoutError::Unknown(ty));\n                 }\n-                return Ok(cx.layout_of(normalized)?.layout);\n+                let layout = cx.layout_of(normalized)?;\n+                return Ok(CachedLayout {\n+                    layout: layout.layout,\n+                    fields: layout.fields\n+                });\n             }\n             ty::TyParam(_) => {\n                 return Err(LayoutError::Unknown(ty));\n@@ -1656,61 +1768,6 @@ impl<'a, 'tcx> Layout {\n         }\n     }\n \n-    pub fn field_offset<C: HasDataLayout>(&self,\n-                                          cx: C,\n-                                          i: usize,\n-                                          variant_index: Option<usize>)\n-                                          -> Size {\n-        let dl = cx.data_layout();\n-\n-        match *self {\n-            Scalar { .. } |\n-            CEnum { .. } |\n-            UntaggedUnion(_) |\n-            RawNullablePointer { .. } => {\n-                Size::from_bytes(0)\n-            }\n-\n-            Vector { element, count } => {\n-                let element_size = element.size(dl);\n-                let i = i as u64;\n-                assert!(i < count);\n-                Size::from_bytes(element_size.bytes() * count)\n-            }\n-\n-            Array { element_size, count, .. } => {\n-                let i = i as u64;\n-                assert!(i < count);\n-                Size::from_bytes(element_size.bytes() * count)\n-            }\n-\n-            FatPointer { metadata, .. } => {\n-                // Effectively a (ptr, meta) tuple.\n-                assert!(i < 2);\n-                if i == 0 {\n-                    Size::from_bytes(0)\n-                } else {\n-                    Pointer.size(dl).abi_align(metadata.align(dl))\n-                }\n-            }\n-\n-            Univariant(ref variant) => variant.offsets[i],\n-\n-            General { ref variants, .. } => {\n-                let v = variant_index.expect(\"variant index required\");\n-                variants[v].offsets[i]\n-            }\n-\n-            StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n-                if Some(nndiscr as usize) == variant_index {\n-                    nonnull.offsets[i]\n-                } else {\n-                    Size::from_bytes(0)\n-                }\n-            }\n-        }\n-    }\n-\n     /// This is invoked by the `layout_raw` query to record the final\n     /// layout of each type.\n     #[inline]\n@@ -2077,6 +2134,7 @@ pub struct FullLayout<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub variant_index: Option<usize>,\n     pub layout: &'tcx Layout,\n+    pub fields: FieldPlacement<'tcx>,\n }\n \n impl<'tcx> Deref for FullLayout<'tcx> {\n@@ -2130,90 +2188,94 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (TyCtxt<'a, 'tcx, 'tcx>, ty::ParamEnv<'tcx\n         let (tcx, param_env) = self;\n \n         let ty = tcx.normalize_associated_type_in_env(&ty, param_env.reveal_all());\n-        let layout = tcx.layout_raw(param_env.reveal_all().and(ty));\n+        let cached = tcx.layout_raw(param_env.reveal_all().and(ty))?;\n \n         // NB: This recording is normally disabled; when enabled, it\n-        // can however trigger recursive invocations of `layout()`.\n+        // can however trigger recursive invocations of `layout_of`.\n         // Therefore, we execute it *after* the main query has\n         // completed, to avoid problems around recursive structures\n         // and the like. (Admitedly, I wasn't able to reproduce a problem\n         // here, but it seems like the right thing to do. -nmatsakis)\n-        if let Ok(l) = layout {\n-            Layout::record_layout_for_printing(tcx, ty, param_env, l);\n-        }\n+        Layout::record_layout_for_printing(tcx, ty, param_env, cached.layout);\n+\n+        Ok(FullLayout {\n+            ty,\n+            variant_index: None,\n+            layout: cached.layout,\n+            fields: cached.fields\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>,\n+                                       ty::ParamEnv<'tcx>) {\n+    type FullLayout = Result<FullLayout<'tcx>, LayoutError<'tcx>>;\n+\n+    /// Computes the layout of a type. Note that this implicitly\n+    /// executes in \"reveal all\" mode.\n+    #[inline]\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::FullLayout {\n+        let (tcx_at, param_env) = self;\n+\n+        let ty = tcx_at.tcx.normalize_associated_type_in_env(&ty, param_env.reveal_all());\n+        let cached = tcx_at.layout_raw(param_env.reveal_all().and(ty))?;\n+\n+        // NB: This recording is normally disabled; when enabled, it\n+        // can however trigger recursive invocations of `layout_of`.\n+        // Therefore, we execute it *after* the main query has\n+        // completed, to avoid problems around recursive structures\n+        // and the like. (Admitedly, I wasn't able to reproduce a problem\n+        // here, but it seems like the right thing to do. -nmatsakis)\n+        Layout::record_layout_for_printing(tcx_at.tcx, ty, param_env, cached.layout);\n \n         Ok(FullLayout {\n             ty,\n             variant_index: None,\n-            layout: layout?,\n+            layout: cached.layout,\n+            fields: cached.fields\n         })\n     }\n }\n \n impl<'a, 'tcx> FullLayout<'tcx> {\n     pub fn for_variant(&self, variant_index: usize) -> Self {\n-        let is_enum = match self.ty.sty {\n-            ty::TyAdt(def, _) => def.is_enum(),\n-            _ => false\n+        let variants = match self.ty.sty {\n+            ty::TyAdt(def, _) if def.is_enum() => &def.variants[..],\n+            _ => &[]\n+        };\n+        let count = if variants.is_empty() {\n+            0\n+        } else {\n+            variants[variant_index].fields.len()\n         };\n-        assert!(is_enum);\n-        FullLayout {\n-            variant_index: Some(variant_index),\n-            ..*self\n-        }\n-    }\n-\n-    pub fn field_offset<C: HasDataLayout>(&self, cx: C, i: usize) -> Size {\n-        self.layout.field_offset(cx, i, self.variant_index)\n-    }\n \n-    pub fn field_count(&self) -> usize {\n-        // Handle enum/union through the type rather than Layout.\n-        if let ty::TyAdt(def, _) = self.ty.sty {\n-            let v = if def.is_enum() {\n-                if def.variants.is_empty() {\n-                    return 0;\n-                }\n-                match self.variant_index {\n-                    None => match *self.layout {\n-                        // Discriminant field for enums (where applicable).\n-                        General { .. } => return 1,\n-                        _ if def.variants.len() > 1 => return 0,\n-\n-                        // Enums with one variant behave like structs.\n-                        _ => 0\n-                    },\n-                    Some(v) => v\n+        let fields = match *self.layout {\n+            Univariant(ref variant) => {\n+                FieldPlacement::Arbitrary {\n+                    offsets: &variant.offsets\n                 }\n-            } else {\n-                0\n-            };\n-\n-            return def.variants[v].fields.len();\n-        }\n-\n-        match *self.layout {\n-            Scalar { .. } => {\n-                bug!(\"FullLayout::field_count({:?}): not applicable\", self)\n             }\n \n-            // Handled above (the TyAdt case).\n-            CEnum { .. } |\n-            General { .. } |\n-            UntaggedUnion(_) |\n-            RawNullablePointer { .. } |\n-            StructWrappedNullablePointer { .. } => bug!(),\n-\n-            FatPointer { .. } => 2,\n+            General { ref variants, .. } => {\n+                FieldPlacement::Arbitrary {\n+                    offsets: &variants[variant_index].offsets\n+                }\n+            }\n \n-            Vector { count, .. } |\n-            Array { count, .. } => {\n-                let usize_count = count as usize;\n-                assert_eq!(usize_count as u64, count);\n-                usize_count\n+            StructWrappedNullablePointer { nndiscr, ref nonnull, .. }\n+                    if nndiscr as usize == variant_index => {\n+                FieldPlacement::Arbitrary {\n+                    offsets: &nonnull.offsets\n+                }\n             }\n \n-            Univariant(ref variant) => variant.offsets.len(),\n+            _ => FieldPlacement::union(count)\n+        };\n+\n+        FullLayout {\n+            variant_index: Some(variant_index),\n+            fields,\n+            ..*self\n         }\n     }\n \n@@ -2384,6 +2446,30 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout\n     }\n }\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for FieldPlacement<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use ty::layout::FieldPlacement::*;\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            Linear { count, stride } => {\n+                count.hash_stable(hcx, hasher);\n+                stride.hash_stable(hcx, hasher);\n+            }\n+            Arbitrary { offsets } => {\n+                offsets.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ::ty::layout::CachedLayout<'tcx> {\n+    layout,\n+    fields\n+});\n+\n impl_stable_hash_for!(enum ::ty::layout::Integer {\n     I1,\n     I8,"}, {"sha": "674677630890335f7041d29676b788228e17c051", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=9a0efea4c2ddab7214c7305dd470049e3240ad6a", "patch": "@@ -34,7 +34,6 @@ use session::config::OutputFilenames;\n use traits::Vtable;\n use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n-use ty::layout::{Layout, LayoutError};\n use ty::steal::Steal;\n use ty::subst::Substs;\n use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n@@ -265,7 +264,8 @@ define_maps! { <'tcx>\n     [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] fn needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                                  -> Result<&'tcx Layout, LayoutError<'tcx>>,\n+                                  -> Result<ty::layout::CachedLayout<'tcx>,\n+                                            ty::layout::LayoutError<'tcx>>,\n \n     [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)\n                                     -> Rc<Vec<(CrateNum, LinkagePreference)>>,"}, {"sha": "7badea86c1abae43c47417e0dab920837e5f3579", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=9a0efea4c2ddab7214c7305dd470049e3240ad6a", "patch": "@@ -17,6 +17,7 @@ use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::LayoutOf;\n use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::{Substs, Subst};\n@@ -313,7 +314,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           if tcx.fn_sig(def_id).abi() == Abi::RustIntrinsic {\n             let layout_of = |ty: Ty<'tcx>| {\n                 let ty = tcx.erase_regions(&ty);\n-                tcx.at(e.span).layout_raw(cx.param_env.reveal_all().and(ty)).map_err(|err| {\n+                (tcx.at(e.span), cx.param_env).layout_of(ty).map_err(|err| {\n                     ConstEvalErr { span: e.span, kind: LayoutError(err) }\n                 })\n             };"}, {"sha": "1b4cbd687df4b453704b0dca5555b825efb78762", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=9a0efea4c2ddab7214c7305dd470049e3240ad6a", "patch": "@@ -334,7 +334,7 @@ impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n                 let mut unaligned_offset = Size::from_bytes(0);\n                 let mut result = None;\n \n-                for i in 0..self.field_count() {\n+                for i in 0..self.fields.count() {\n                     if unaligned_offset != variant.offsets[i] {\n                         return None;\n                     }\n@@ -371,7 +371,7 @@ impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n                 let mut max = Size::from_bytes(0);\n                 let mut result = None;\n \n-                for i in 0..self.field_count() {\n+                for i in 0..self.fields.count() {\n                     let field = self.field(ccx, i);\n                     match (result, field.homogeneous_aggregate(ccx)) {\n                         // The field itself must be a homogeneous aggregate."}, {"sha": "ec87429c2b228c2b1502880a9c9da004dd9cc5b1", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=9a0efea4c2ddab7214c7305dd470049e3240ad6a", "patch": "@@ -209,7 +209,7 @@ pub fn memory_index_to_gep(index: u64) -> u64 {\n pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  layout: FullLayout<'tcx>,\n                                  variant: &layout::Struct) -> Vec<Type> {\n-    let field_count = layout.field_count();\n+    let field_count = layout.fields.count();\n     debug!(\"struct_llfields: variant: {:?}\", variant);\n     let mut offset = Size::from_bytes(0);\n     let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);"}, {"sha": "4db33b9204a1ef628d55f07ea7b0163ee4ceaaec", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=9a0efea4c2ddab7214c7305dd470049e3240ad6a", "patch": "@@ -30,7 +30,7 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         Layout::Scalar { value: layout::F32, .. } |\n         Layout::Scalar { value: layout::F64, .. } => true,\n         Layout::Univariant { .. } => {\n-            if layout.field_count() == 1 {\n+            if layout.fields.count() == 1 {\n                 is_single_fp_element(ccx, layout.field(ccx, 0))\n             } else {\n                 false"}, {"sha": "362ceb606013992f5f07737d9ec4e83b03eca39b", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=9a0efea4c2ddab7214c7305dd470049e3240ad6a", "patch": "@@ -25,7 +25,7 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         Layout::Scalar { value: layout::F32, .. } |\n         Layout::Scalar { value: layout::F64, .. } => true,\n         Layout::Univariant { .. } => {\n-            if layout.field_count() == 1 {\n+            if layout.fields.count() == 1 {\n                 is_single_fp_element(ccx, layout.field(ccx, 0))\n             } else {\n                 false"}, {"sha": "95470b075640b2109b38afc59cb0a990e48c26d8", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=9a0efea4c2ddab7214c7305dd470049e3240ad6a", "patch": "@@ -102,14 +102,14 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n             }\n \n             Layout::Univariant(ref variant) => {\n-                for i in 0..layout.field_count() {\n+                for i in 0..layout.fields.count() {\n                     let field_off = off + variant.offsets[i];\n                     classify(ccx, layout.field(ccx, i), cls, field_off)?;\n                 }\n             }\n \n             Layout::UntaggedUnion { .. } => {\n-                for i in 0..layout.field_count() {\n+                for i in 0..layout.fields.count() {\n                     classify(ccx, layout.field(ccx, i), cls, off)?;\n                 }\n             }"}, {"sha": "e08141f2fc39ec9dc33bd703c712042e6980e737", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=9a0efea4c2ddab7214c7305dd470049e3240ad6a", "patch": "@@ -429,15 +429,15 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             type_metadata: type_metadata(cx,\n                 cx.tcx().mk_mut_ptr(cx.tcx().types.u8),\n                 syntax_pos::DUMMY_SP),\n-            offset: layout.field_offset(cx, 0),\n+            offset: layout.fields.offset(0),\n             size: data_ptr_field.size(cx),\n             align: data_ptr_field.align(cx),\n             flags: DIFlags::FlagArtificial,\n         },\n         MemberDescription {\n             name: \"vtable\".to_string(),\n             type_metadata: type_metadata(cx, vtable_field.ty, syntax_pos::DUMMY_SP),\n-            offset: layout.field_offset(cx, 1),\n+            offset: layout.fields.offset(1),\n             size: vtable_field.size(cx),\n             align: vtable_field.align(cx),\n             flags: DIFlags::FlagArtificial,\n@@ -1321,8 +1321,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                                 layout: FullLayout<'tcx>,\n                                                 offset: Size,\n                                                 size: Size) {\n-                    for i in 0..layout.field_count() {\n-                        let field_offset = layout.field_offset(ccx, i);\n+                    for i in 0..layout.fields.count() {\n+                        let field_offset = layout.fields.offset(i);\n                         if field_offset > offset {\n                             continue;\n                         }\n@@ -1414,7 +1414,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n \n     let layout = layout.for_variant(variant_index);\n-    let mut field_tys = (0..layout.field_count()).map(|i| {\n+    let mut field_tys = (0..layout.fields.count()).map(|i| {\n         layout.field(cx, i).ty\n     }).collect::<Vec<_>>();\n "}, {"sha": "61c0820539d5609083a51da175358c4c04889ed0", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=9a0efea4c2ddab7214c7305dd470049e3240ad6a", "patch": "@@ -74,7 +74,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let field_ty = layout.field(ccx, layout.field_count() - 1).ty;\n+            let field_ty = layout.field(ccx, layout.fields.count() - 1).ty;\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding"}, {"sha": "2bd76308c9187cb94737f4ca6cb4fc5951cedbec", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0efea4c2ddab7214c7305dd470049e3240ad6a/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=9a0efea4c2ddab7214c7305dd470049e3240ad6a", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let meta = self.llextra;\n \n \n-        let offset = l.field_offset(ccx, ix).bytes();\n+        let offset = l.fields.offset(ix).bytes();\n         let unaligned_offset = C_usize(ccx, offset);\n \n         // Get the alignment of the field"}]}