{"sha": "e97d61672b3f31e4d54589bed20286aca02bf42b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5N2Q2MTY3MmIzZjMxZTRkNTQ1ODliZWQyMDI4NmFjYTAyYmY0MmI=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-08-24T06:30:17Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T03:10:10Z"}, "message": "path2: Implement PosixPath\n\nFixes #5389 (new conventions for Path constructor)", "tree": {"sha": "2ceb0954c8de1f68f07bfd058c108a0aa3d66d9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ceb0954c8de1f68f07bfd058c108a0aa3d66d9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e97d61672b3f31e4d54589bed20286aca02bf42b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e97d61672b3f31e4d54589bed20286aca02bf42b", "html_url": "https://github.com/rust-lang/rust/commit/e97d61672b3f31e4d54589bed20286aca02bf42b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e97d61672b3f31e4d54589bed20286aca02bf42b/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2028340921658424c9ffbf4305c82e2394f46bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2028340921658424c9ffbf4305c82e2394f46bd", "html_url": "https://github.com/rust-lang/rust/commit/d2028340921658424c9ffbf4305c82e2394f46bd"}], "stats": {"total": 771, "additions": 770, "deletions": 1}, "files": [{"sha": "a98fcc40e189da50c6937e348d1d196109f1863a", "filename": "src/libstd/path2.rs", "status": "modified", "additions": 770, "deletions": 1, "changes": 771, "blob_url": "https://github.com/rust-lang/rust/blob/e97d61672b3f31e4d54589bed20286aca02bf42b/src%2Flibstd%2Fpath2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97d61672b3f31e4d54589bed20286aca02bf42b/src%2Flibstd%2Fpath2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2.rs?ref=e97d61672b3f31e4d54589bed20286aca02bf42b", "patch": "@@ -10,14 +10,18 @@\n \n //! Cross-platform file path handling (re-write)\n \n+use container::Container;\n use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::Eq;\n use from_str::FromStr;\n+use iterator::{AdditiveIterator, Extendable, Iterator};\n use option::{Option, None, Some};\n use str;\n-use str::{OwnedStr, Str, StrSlice};\n+use str::{OwnedStr, Str, StrSlice, StrVector};\n use to_str::ToStr;\n+use util;\n+use vec::{ImmutableVector, OwnedVector};\n \n /// Typedef for the platform-native path type\n #[cfg(unix)]\n@@ -26,6 +30,16 @@ pub type Path = PosixPath;\n //#[cfg(windows)]\n //pub type Path = WindowsPath;\n \n+/// Typedef for the platform-native component iterator\n+#[cfg(unix)]\n+pub type ComponentIter<'self> = PosixComponentIter<'self>;\n+// /// Typedef for the platform-native component iterator\n+//#[cfg(windows)]\n+//pub type ComponentIter<'self> = WindowsComponentIter<'self>;\n+\n+/// Iterator that yields successive components of a PosixPath\n+type PosixComponentIter<'self> = str::CharSplitIterator<'self, char>;\n+\n /// Represents a POSIX file path\n #[deriving(Clone, DeepClone)]\n pub struct PosixPath {\n@@ -260,6 +274,312 @@ impl ToCStr for PosixPath {\n     }\n }\n \n+impl GenericPath for PosixPath {\n+    #[inline]\n+    fn from_str(s: &str) -> PosixPath {\n+        PosixPath::new(s)\n+    }\n+\n+    #[inline]\n+    fn as_str<'a>(&'a self) -> &'a str {\n+        self.repr.as_slice()\n+    }\n+\n+    fn dirname<'a>(&'a self) -> &'a str {\n+        match self.sepidx {\n+            None if \"..\" == self.repr => \"..\",\n+            None => \".\",\n+            Some(0) => self.repr.slice_to(1),\n+            Some(idx) if self.repr.slice_from(idx+1) == \"..\" => self.repr.as_slice(),\n+            Some(idx) => self.repr.slice_to(idx)\n+        }\n+    }\n+\n+    fn filename<'a>(&'a self) -> &'a str {\n+        match self.sepidx {\n+            None if \".\" == self.repr || \"..\" == self.repr => \"\",\n+            None => self.repr.as_slice(),\n+            Some(idx) if self.repr.slice_from(idx+1) == \"..\" => \"\",\n+            Some(idx) => self.repr.slice_from(idx+1)\n+        }\n+    }\n+\n+    fn set_dirname(&mut self, dirname: &str) {\n+        match self.sepidx {\n+            None if \".\" == self.repr || \"..\" == self.repr => {\n+                self.repr = PosixPath::normalize(dirname);\n+            }\n+            None => {\n+                let mut s = str::with_capacity(dirname.len() + self.repr.len() + 1);\n+                s.push_str(dirname);\n+                s.push_char(posix::sep);\n+                s.push_str(self.repr);\n+                self.repr = PosixPath::normalize(s);\n+            }\n+            Some(0) if self.repr.len() == 1 && self.repr[0] == posix::sep as u8 => {\n+                self.repr = PosixPath::normalize(dirname);\n+            }\n+            Some(idx) if dirname == \"\" => {\n+                let s = PosixPath::normalize(self.repr.slice_from(idx+1));\n+                self.repr = s;\n+            }\n+            Some(idx) if self.repr.slice_from(idx+1) == \"..\" => {\n+                self.repr = PosixPath::normalize(dirname);\n+            }\n+            Some(idx) => {\n+                let mut s = str::with_capacity(dirname.len() + self.repr.len() - idx);\n+                s.push_str(dirname);\n+                s.push_str(self.repr.slice_from(idx));\n+                self.repr = PosixPath::normalize(s);\n+            }\n+        }\n+        self.sepidx = self.repr.rfind(posix::sep);\n+    }\n+\n+    fn set_filename(&mut self, filename: &str) {\n+        match self.sepidx {\n+            None if \"..\" == self.repr => {\n+                let mut s = str::with_capacity(3 + filename.len());\n+                s.push_str(\"..\");\n+                s.push_char(posix::sep);\n+                s.push_str(filename);\n+                self.repr = PosixPath::normalize(s);\n+            }\n+            None => {\n+                self.repr = PosixPath::normalize(filename);\n+            }\n+            Some(idx) if self.repr.slice_from(idx+1) == \"..\" => {\n+                let mut s = str::with_capacity(self.repr.len() + 1 + filename.len());\n+                s.push_str(self.repr);\n+                s.push_char(posix::sep);\n+                s.push_str(filename);\n+                self.repr = PosixPath::normalize(s);\n+            }\n+            Some(idx) => {\n+                let mut s = str::with_capacity(self.repr.len() - idx + filename.len());\n+                s.push_str(self.repr.slice_to(idx+1));\n+                s.push_str(filename);\n+                self.repr = PosixPath::normalize(s);\n+            }\n+        }\n+        self.sepidx = self.repr.rfind(posix::sep);\n+    }\n+\n+    fn push(&mut self, path: &str) {\n+        if !path.is_empty() {\n+            if path[0] == posix::sep as u8 {\n+                self.repr = PosixPath::normalize(path);\n+            }  else {\n+                let mut s = str::with_capacity(self.repr.len() + path.len() + 1);\n+                s.push_str(self.repr);\n+                s.push_char(posix::sep);\n+                s.push_str(path);\n+                self.repr = PosixPath::normalize(s);\n+            }\n+            self.sepidx = self.repr.rfind(posix::sep);\n+        }\n+    }\n+\n+    fn push_path(&mut self, path: &PosixPath) {\n+        self.push(path.as_str());\n+    }\n+\n+    fn pop_opt(&mut self) -> Option<~str> {\n+        match self.sepidx {\n+            None if \".\" == self.repr => None,\n+            None => {\n+                let mut s = ~\".\";\n+                util::swap(&mut s, &mut self.repr);\n+                self.sepidx = None;\n+                Some(s)\n+            }\n+            Some(0) if \"/\" == self.repr => None,\n+            Some(idx) => {\n+                let s = self.repr.slice_from(idx+1).to_owned();\n+                if idx == 0 {\n+                    self.repr.truncate(idx+1);\n+                } else {\n+                    self.repr.truncate(idx);\n+                }\n+                self.sepidx = self.repr.rfind(posix::sep);\n+                Some(s)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_absolute(&self) -> bool {\n+        self.repr[0] == posix::sep as u8\n+    }\n+\n+    fn is_ancestor_of(&self, other: &PosixPath) -> bool {\n+        if self.is_absolute() != other.is_absolute() {\n+            false\n+        } else {\n+            let mut ita = self.component_iter();\n+            let mut itb = other.component_iter();\n+            if \".\" == self.repr {\n+                return match itb.next() {\n+                    Some(\"..\") => false,\n+                    _ => true\n+                };\n+            }\n+            loop {\n+                match (ita.next(), itb.next()) {\n+                    (None, _) => break,\n+                    (Some(a), Some(b)) if a == b => { loop },\n+                    (Some(\"..\"), _) => {\n+                        // if ita contains only .. components, it's an ancestor\n+                        return ita.all(|x| x == \"..\");\n+                    }\n+                    _ => return false\n+                }\n+            }\n+            true\n+        }\n+    }\n+\n+    fn path_relative_from(&self, base: &PosixPath) -> Option<PosixPath> {\n+        if self.is_absolute() != base.is_absolute() {\n+            if self.is_absolute() {\n+                Some(self.clone())\n+            } else {\n+                None\n+            }\n+        } else {\n+            let mut ita = self.component_iter();\n+            let mut itb = base.component_iter();\n+            let mut comps = ~[];\n+            loop {\n+                match (ita.next(), itb.next()) {\n+                    (None, None) => break,\n+                    (Some(a), None) => {\n+                        comps.push(a);\n+                        comps.extend(&mut ita);\n+                        break;\n+                    }\n+                    (None, _) => comps.push(\"..\"),\n+                    (Some(a), Some(b)) if comps.is_empty() && a == b => (),\n+                    (Some(a), Some(\".\")) => comps.push(a),\n+                    (Some(_), Some(\"..\")) => return None,\n+                    (Some(a), Some(_)) => {\n+                        comps.push(\"..\");\n+                        for _ in itb {\n+                            comps.push(\"..\");\n+                        }\n+                        comps.push(a);\n+                        comps.extend(&mut ita);\n+                        break;\n+                    }\n+                }\n+            }\n+            Some(PosixPath::new(comps.connect(str::from_char(posix::sep))))\n+        }\n+    }\n+}\n+\n+impl PosixPath {\n+    /// Returns a new PosixPath from a string\n+    pub fn new(s: &str) -> PosixPath {\n+        let s = PosixPath::normalize(s);\n+        assert!(!s.is_empty());\n+        let idx = s.rfind(posix::sep);\n+        PosixPath{ repr: s, sepidx: idx }\n+    }\n+\n+    /// Converts the PosixPath into an owned string\n+    pub fn into_str(self) -> ~str {\n+        self.repr\n+    }\n+\n+    /// Returns a normalized string representation of a path, by removing all empty\n+    /// components, and unnecessary . and .. components.\n+    pub fn normalize<S: Str>(s: S) -> ~str {\n+        // borrowck is being very picky\n+        let val = {\n+            let is_abs = !s.as_slice().is_empty() && s.as_slice()[0] == posix::sep as u8;\n+            let s_ = if is_abs { s.as_slice().slice_from(1) } else { s.as_slice() };\n+            let comps = normalize_helper(s_, is_abs, posix::sep);\n+            match comps {\n+                None => None,\n+                Some(comps) => {\n+                    let sepstr = str::from_char(posix::sep);\n+                    if is_abs && comps.is_empty() {\n+                        Some(sepstr)\n+                    } else {\n+                        let n = if is_abs { comps.len() } else { comps.len() - 1} +\n+                                comps.iter().map(|s| s.len()).sum();\n+                        let mut s = str::with_capacity(n);\n+                        let mut it = comps.move_iter();\n+                        if !is_abs {\n+                            match it.next() {\n+                                None => (),\n+                                Some(comp) => s.push_str(comp)\n+                            }\n+                        }\n+                        for comp in it {\n+                            s.push_str(sepstr);\n+                            s.push_str(comp);\n+                        }\n+                        Some(s)\n+                    }\n+                }\n+            }\n+        };\n+        match val {\n+            None => s.into_owned(),\n+            Some(val) => val\n+        }\n+    }\n+\n+    /// Returns an iterator that yields each component of the path in turn.\n+    /// Does not distinguish between absolute and relative paths, e.g.\n+    /// /a/b/c and a/b/c yield the same set of components.\n+    /// A path of \"/\" yields no components. A path of \".\" yields one component.\n+    pub fn component_iter<'a>(&'a self) -> PosixComponentIter<'a> {\n+        let s = if self.repr[0] == posix::sep as u8 {\n+            self.repr.slice_from(1)\n+        } else { self.repr.as_slice() };\n+        let mut ret = s.split_iter(posix::sep);\n+        if s.is_empty() {\n+            // consume the empty \"\" component\n+            ret.next();\n+        }\n+        ret\n+    }\n+}\n+\n+// None result means the string didn't need normalizing\n+fn normalize_helper<'a, Sep: str::CharEq>(s: &'a str, is_abs: bool, sep: Sep) -> Option<~[&'a str]> {\n+    if is_abs && s.as_slice().is_empty() {\n+        return None;\n+    }\n+    let mut comps: ~[&'a str] = ~[];\n+    let mut n_up = 0u;\n+    let mut changed = false;\n+    for comp in s.split_iter(sep) {\n+        match comp {\n+            \"\" => { changed = true; }\n+            \".\" => { changed = true; }\n+            \"..\" if is_abs && comps.is_empty() => { changed = true; }\n+            \"..\" if comps.len() == n_up => { comps.push(\"..\"); n_up += 1; }\n+            \"..\" => { comps.pop_opt(); changed = true; }\n+            x => comps.push(x)\n+        }\n+    }\n+    if changed {\n+        if comps.is_empty() && !is_abs {\n+            if s == \".\" {\n+                return None;\n+            }\n+            comps.push(\".\");\n+        }\n+        Some(comps)\n+    } else {\n+        None\n+    }\n+}\n+\n /// Various POSIX helpers\n pub mod posix {\n     /// The standard path separator character\n@@ -283,3 +603,452 @@ pub mod windows {\n         u == sep || u == '/'\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use option::{Some, None};\n+    use iterator::Iterator;\n+    use vec::Vector;\n+\n+    macro_rules! t(\n+        ($path:expr, $exp:expr) => (\n+            {\n+                let path = $path;\n+                assert_eq!(path.as_str(), $exp);\n+            }\n+        )\n+    )\n+\n+    #[test]\n+    fn test_posix_paths() {\n+        t!(PosixPath::new(\"\"), \".\");\n+        t!(PosixPath::new(\"/\"), \"/\");\n+        t!(PosixPath::new(\"hi\"), \"hi\");\n+        t!(PosixPath::new(\"/lib\"), \"/lib\");\n+        t!(PosixPath::new(\"hi/there\"), \"hi/there\");\n+        t!(PosixPath::new(\"hi/there.txt\"), \"hi/there.txt\");\n+\n+        t!(PosixPath::new(\"hi/there/\"), \"hi/there\");\n+        t!(PosixPath::new(\"hi/../there\"), \"there\");\n+        t!(PosixPath::new(\"../hi/there\"), \"../hi/there\");\n+        t!(PosixPath::new(\"/../hi/there\"), \"/hi/there\");\n+        t!(PosixPath::new(\"foo/..\"), \".\");\n+        t!(PosixPath::new(\"/foo/..\"), \"/\");\n+        t!(PosixPath::new(\"/foo/../..\"), \"/\");\n+        t!(PosixPath::new(\"/foo/../../bar\"), \"/bar\");\n+        t!(PosixPath::new(\"/./hi/./there/.\"), \"/hi/there\");\n+        t!(PosixPath::new(\"/./hi/./there/./..\"), \"/hi\");\n+        t!(PosixPath::new(\"foo/../..\"), \"..\");\n+        t!(PosixPath::new(\"foo/../../..\"), \"../..\");\n+        t!(PosixPath::new(\"foo/../../bar\"), \"../bar\");\n+\n+        assert_eq!(PosixPath::new(\"foo/bar\").into_str(), ~\"foo/bar\");\n+        assert_eq!(PosixPath::new(\"/foo/../../bar\").into_str(), ~\"/bar\");\n+    }\n+\n+    #[test]\n+    fn test_posix_components() {\n+        macro_rules! t(\n+            ($path:expr, $op:ident, $exp:expr) => (\n+                {\n+                    let path = PosixPath::new($path);\n+                    assert_eq!(path.$op(), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(\"a/b/c\", filename, \"c\");\n+        t!(\"/a/b/c\", filename, \"c\");\n+        t!(\"a\", filename, \"a\");\n+        t!(\"/a\", filename, \"a\");\n+        t!(\".\", filename, \"\");\n+        t!(\"/\", filename, \"\");\n+        t!(\"..\", filename, \"\");\n+        t!(\"../..\", filename, \"\");\n+\n+        t!(\"a/b/c\", dirname, \"a/b\");\n+        t!(\"/a/b/c\", dirname, \"/a/b\");\n+        t!(\"a\", dirname, \".\");\n+        t!(\"/a\", dirname, \"/\");\n+        t!(\".\", dirname, \".\");\n+        t!(\"/\", dirname, \"/\");\n+        t!(\"..\", dirname, \"..\");\n+        t!(\"../..\", dirname, \"../..\");\n+\n+        t!(\"hi/there.txt\", filestem, \"there\");\n+        t!(\"hi/there\", filestem, \"there\");\n+        t!(\"there.txt\", filestem, \"there\");\n+        t!(\"there\", filestem, \"there\");\n+        t!(\".\", filestem, \"\");\n+        t!(\"/\", filestem, \"\");\n+        t!(\"foo/.bar\", filestem, \".bar\");\n+        t!(\".bar\", filestem, \".bar\");\n+        t!(\"..bar\", filestem, \".\");\n+        t!(\"hi/there..txt\", filestem, \"there.\");\n+        t!(\"..\", filestem, \"\");\n+        t!(\"../..\", filestem, \"\");\n+\n+        t!(\"hi/there.txt\", extension, Some(\"txt\"));\n+        t!(\"hi/there\", extension, None);\n+        t!(\"there.txt\", extension, Some(\"txt\"));\n+        t!(\"there\", extension, None);\n+        t!(\".\", extension, None);\n+        t!(\"/\", extension, None);\n+        t!(\"foo/.bar\", extension, None);\n+        t!(\".bar\", extension, None);\n+        t!(\"..bar\", extension, Some(\"bar\"));\n+        t!(\"hi/there..txt\", extension, Some(\"txt\"));\n+        t!(\"..\", extension, None);\n+        t!(\"../..\", extension, None);\n+    }\n+\n+    #[test]\n+    fn test_posix_push() {\n+        macro_rules! t(\n+            ($path:expr, $join:expr) => (\n+                {\n+                    let path = ($path);\n+                    let join = ($join);\n+                    let mut p1 = PosixPath::new(path);\n+                    p1.push(join);\n+                    let p2 = PosixPath::new(path);\n+                    assert_eq!(p1, p2.join(join));\n+                }\n+            )\n+        )\n+\n+        t!(\"a/b/c\", \"..\");\n+        t!(\"/a/b/c\", \"d\");\n+        t!(\"a/b\", \"c/d\");\n+        t!(\"a/b\", \"/c/d\");\n+    }\n+\n+    #[test]\n+    fn test_posix_push_path() {\n+        macro_rules! t(\n+            ($path:expr, $push:expr, $exp:expr) => (\n+                {\n+                    let mut p = PosixPath::new($path);\n+                    let push = PosixPath::new($push);\n+                    p.push_path(&push);\n+                    assert_eq!(p.as_str(), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(\"a/b/c\", \"d\", \"a/b/c/d\");\n+        t!(\"/a/b/c\", \"d\", \"/a/b/c/d\");\n+        t!(\"a/b\", \"c/d\", \"a/b/c/d\");\n+        t!(\"a/b\", \"/c/d\", \"/c/d\");\n+        t!(\"a/b\", \".\", \"a/b\");\n+        t!(\"a/b\", \"../c\", \"a/c\");\n+    }\n+\n+    #[test]\n+    fn test_posix_pop() {\n+        macro_rules! t(\n+            ($path:expr, $left:expr, $right:expr) => (\n+                {\n+                    let mut p = PosixPath::new($path);\n+                    let file = p.pop_opt();\n+                    assert_eq!(p.as_str(), $left);\n+                    assert_eq!(file.map(|s| s.as_slice()), $right);\n+                }\n+            )\n+        )\n+\n+        t!(\"a/b/c\", \"a/b\", Some(\"c\"));\n+        t!(\"a\", \".\", Some(\"a\"));\n+        t!(\".\", \".\", None);\n+        t!(\"/a\", \"/\", Some(\"a\"));\n+        t!(\"/\", \"/\", None);\n+    }\n+\n+    #[test]\n+    fn test_posix_join() {\n+        t!(PosixPath::new(\"a/b/c\").join(\"..\"), \"a/b\");\n+        t!(PosixPath::new(\"/a/b/c\").join(\"d\"), \"/a/b/c/d\");\n+        t!(PosixPath::new(\"a/b\").join(\"c/d\"), \"a/b/c/d\");\n+        t!(PosixPath::new(\"a/b\").join(\"/c/d\"), \"/c/d\");\n+        t!(PosixPath::new(\".\").join(\"a/b\"), \"a/b\");\n+        t!(PosixPath::new(\"/\").join(\"a/b\"), \"/a/b\");\n+    }\n+\n+    #[test]\n+    fn test_posix_join_path() {\n+        macro_rules! t(\n+            ($path:expr, $join:expr, $exp:expr) => (\n+                {\n+                    let path = PosixPath::new($path);\n+                    let join = PosixPath::new($join);\n+                    let res = path.join_path(&join);\n+                    assert_eq!(res.as_str(), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(\"a/b/c\", \"..\", \"a/b\");\n+        t!(\"/a/b/c\", \"d\", \"/a/b/c/d\");\n+        t!(\"a/b\", \"c/d\", \"a/b/c/d\");\n+        t!(\"a/b\", \"/c/d\", \"/c/d\");\n+        t!(\".\", \"a/b\", \"a/b\");\n+        t!(\"/\", \"a/b\", \"/a/b\");\n+    }\n+\n+    #[test]\n+    fn test_posix_with_helpers() {\n+        t!(PosixPath::new(\"a/b/c\").with_dirname(\"d\"), \"d/c\");\n+        t!(PosixPath::new(\"a/b/c\").with_dirname(\"d/e\"), \"d/e/c\");\n+        t!(PosixPath::new(\"a/b/c\").with_dirname(\"\"), \"c\");\n+        t!(PosixPath::new(\"a/b/c\").with_dirname(\"/\"), \"/c\");\n+        t!(PosixPath::new(\"a/b/c\").with_dirname(\".\"), \"c\");\n+        t!(PosixPath::new(\"a/b/c\").with_dirname(\"..\"), \"../c\");\n+        t!(PosixPath::new(\"/\").with_dirname(\"foo\"), \"foo\");\n+        t!(PosixPath::new(\"/\").with_dirname(\"\"), \".\");\n+        t!(PosixPath::new(\"/foo\").with_dirname(\"bar\"), \"bar/foo\");\n+        t!(PosixPath::new(\"..\").with_dirname(\"foo\"), \"foo\");\n+        t!(PosixPath::new(\"../..\").with_dirname(\"foo\"), \"foo\");\n+        t!(PosixPath::new(\"foo\").with_dirname(\"..\"), \"../foo\");\n+        t!(PosixPath::new(\"foo\").with_dirname(\"../..\"), \"../../foo\");\n+\n+        t!(PosixPath::new(\"a/b/c\").with_filename(\"d\"), \"a/b/d\");\n+        t!(PosixPath::new(\".\").with_filename(\"foo\"), \"foo\");\n+        t!(PosixPath::new(\"/a/b/c\").with_filename(\"d\"), \"/a/b/d\");\n+        t!(PosixPath::new(\"/\").with_filename(\"foo\"), \"/foo\");\n+        t!(PosixPath::new(\"/a\").with_filename(\"foo\"), \"/foo\");\n+        t!(PosixPath::new(\"foo\").with_filename(\"bar\"), \"bar\");\n+        t!(PosixPath::new(\"a/b/c\").with_filename(\"\"), \"a/b\");\n+        t!(PosixPath::new(\"a/b/c\").with_filename(\".\"), \"a/b\");\n+        t!(PosixPath::new(\"a/b/c\").with_filename(\"..\"), \"a\");\n+        t!(PosixPath::new(\"/a\").with_filename(\"\"), \"/\");\n+        t!(PosixPath::new(\"foo\").with_filename(\"\"), \".\");\n+        t!(PosixPath::new(\"a/b/c\").with_filename(\"d/e\"), \"a/b/d/e\");\n+        t!(PosixPath::new(\"a/b/c\").with_filename(\"/d\"), \"a/b/d\");\n+        t!(PosixPath::new(\"..\").with_filename(\"foo\"), \"../foo\");\n+        t!(PosixPath::new(\"../..\").with_filename(\"foo\"), \"../../foo\");\n+\n+        t!(PosixPath::new(\"hi/there.txt\").with_filestem(\"here\"), \"hi/here.txt\");\n+        t!(PosixPath::new(\"hi/there.txt\").with_filestem(\"\"), \"hi/.txt\");\n+        t!(PosixPath::new(\"hi/there.txt\").with_filestem(\".\"), \"hi/..txt\");\n+        t!(PosixPath::new(\"hi/there.txt\").with_filestem(\"..\"), \"hi/...txt\");\n+        t!(PosixPath::new(\"hi/there.txt\").with_filestem(\"/\"), \"hi/.txt\");\n+        t!(PosixPath::new(\"hi/there.txt\").with_filestem(\"foo/bar\"), \"hi/foo/bar.txt\");\n+        t!(PosixPath::new(\"hi/there.foo.txt\").with_filestem(\"here\"), \"hi/here.txt\");\n+        t!(PosixPath::new(\"hi/there\").with_filestem(\"here\"), \"hi/here\");\n+        t!(PosixPath::new(\"hi/there\").with_filestem(\"\"), \"hi\");\n+        t!(PosixPath::new(\"hi\").with_filestem(\"\"), \".\");\n+        t!(PosixPath::new(\"/hi\").with_filestem(\"\"), \"/\");\n+        t!(PosixPath::new(\"hi/there\").with_filestem(\"..\"), \".\");\n+        t!(PosixPath::new(\"hi/there\").with_filestem(\".\"), \"hi\");\n+        t!(PosixPath::new(\"hi/there.\").with_filestem(\"foo\"), \"hi/foo.\");\n+        t!(PosixPath::new(\"hi/there.\").with_filestem(\"\"), \"hi\");\n+        t!(PosixPath::new(\"hi/there.\").with_filestem(\".\"), \".\");\n+        t!(PosixPath::new(\"hi/there.\").with_filestem(\"..\"), \"hi/...\");\n+        t!(PosixPath::new(\"/\").with_filestem(\"foo\"), \"/foo\");\n+        t!(PosixPath::new(\".\").with_filestem(\"foo\"), \"foo\");\n+        t!(PosixPath::new(\"hi/there..\").with_filestem(\"here\"), \"hi/here.\");\n+        t!(PosixPath::new(\"hi/there..\").with_filestem(\"\"), \"hi\");\n+\n+        t!(PosixPath::new(\"hi/there.txt\").with_extension(\"exe\"), \"hi/there.exe\");\n+        t!(PosixPath::new(\"hi/there.txt\").with_extension(\"\"), \"hi/there\");\n+        t!(PosixPath::new(\"hi/there.txt\").with_extension(\".\"), \"hi/there..\");\n+        t!(PosixPath::new(\"hi/there.txt\").with_extension(\"..\"), \"hi/there...\");\n+        t!(PosixPath::new(\"hi/there\").with_extension(\"txt\"), \"hi/there.txt\");\n+        t!(PosixPath::new(\"hi/there\").with_extension(\".\"), \"hi/there..\");\n+        t!(PosixPath::new(\"hi/there\").with_extension(\"..\"), \"hi/there...\");\n+        t!(PosixPath::new(\"hi/there.\").with_extension(\"txt\"), \"hi/there.txt\");\n+        t!(PosixPath::new(\"hi/.foo\").with_extension(\"txt\"), \"hi/.foo.txt\");\n+        t!(PosixPath::new(\"hi/there.txt\").with_extension(\".foo\"), \"hi/there..foo\");\n+        t!(PosixPath::new(\"/\").with_extension(\"txt\"), \"/\");\n+        t!(PosixPath::new(\"/\").with_extension(\".\"), \"/\");\n+        t!(PosixPath::new(\"/\").with_extension(\"..\"), \"/\");\n+        t!(PosixPath::new(\".\").with_extension(\"txt\"), \".\");\n+    }\n+\n+    #[test]\n+    fn test_posix_setters() {\n+        macro_rules! t(\n+            ($path:expr, $set:ident, $with:ident, $arg:expr) => (\n+                {\n+                    let path = ($path);\n+                    let arg = ($arg);\n+                    let mut p1 = PosixPath::new(path);\n+                    p1.$set(arg);\n+                    let p2 = PosixPath::new(path);\n+                    assert_eq!(p1, p2.$with(arg));\n+                }\n+            )\n+        )\n+\n+        t!(\"a/b/c\", set_dirname, with_dirname, \"d\");\n+        t!(\"a/b/c\", set_dirname, with_dirname, \"d/e\");\n+        t!(\"/\", set_dirname, with_dirname, \"foo\");\n+        t!(\"/foo\", set_dirname, with_dirname, \"bar\");\n+        t!(\"a/b/c\", set_dirname, with_dirname, \"\");\n+        t!(\"../..\", set_dirname, with_dirname, \"x\");\n+        t!(\"foo\", set_dirname, with_dirname, \"../..\");\n+\n+        t!(\"a/b/c\", set_filename, with_filename, \"d\");\n+        t!(\"/\", set_filename, with_filename, \"foo\");\n+        t!(\".\", set_filename, with_filename, \"foo\");\n+        t!(\"a/b\", set_filename, with_filename, \"\");\n+        t!(\"a\", set_filename, with_filename, \"\");\n+\n+        t!(\"hi/there.txt\", set_filestem, with_filestem, \"here\");\n+        t!(\"hi/there.\", set_filestem, with_filestem, \"here\");\n+        t!(\"hi/there\", set_filestem, with_filestem, \"here\");\n+        t!(\"hi/there.txt\", set_filestem, with_filestem, \"\");\n+        t!(\"hi/there\", set_filestem, with_filestem, \"\");\n+\n+        t!(\"hi/there.txt\", set_extension, with_extension, \"exe\");\n+        t!(\"hi/there.\", set_extension, with_extension, \"txt\");\n+        t!(\"hi/there\", set_extension, with_extension, \"txt\");\n+        t!(\"hi/there.txt\", set_extension, with_extension, \"\");\n+        t!(\"hi/there\", set_extension, with_extension, \"\");\n+        t!(\".\", set_extension, with_extension, \"txt\");\n+    }\n+\n+    #[test]\n+    fn test_posix_dir_file_path() {\n+        t!(PosixPath::new(\"hi/there\").dir_path(), \"hi\");\n+        t!(PosixPath::new(\"hi\").dir_path(), \".\");\n+        t!(PosixPath::new(\"/hi\").dir_path(), \"/\");\n+        t!(PosixPath::new(\"/\").dir_path(), \"/\");\n+        t!(PosixPath::new(\"..\").dir_path(), \"..\");\n+        t!(PosixPath::new(\"../..\").dir_path(), \"../..\");\n+\n+        macro_rules! t(\n+            ($path:expr, $exp:expr) => (\n+                {\n+                    let path = $path;\n+                    let left = path.map(|p| p.as_str());\n+                    assert_eq!(left, $exp);\n+                }\n+            )\n+        )\n+\n+        t!(PosixPath::new(\"hi/there\").file_path(), Some(\"there\"));\n+        t!(PosixPath::new(\"hi\").file_path(), Some(\"hi\"));\n+        t!(PosixPath::new(\".\").file_path(), None);\n+        t!(PosixPath::new(\"/\").file_path(), None);\n+        t!(PosixPath::new(\"..\").file_path(), None);\n+        t!(PosixPath::new(\"../..\").file_path(), None);\n+    }\n+\n+    #[test]\n+    fn test_posix_is_absolute() {\n+        assert_eq!(PosixPath::new(\"a/b/c\").is_absolute(), false);\n+        assert_eq!(PosixPath::new(\"/a/b/c\").is_absolute(), true);\n+        assert_eq!(PosixPath::new(\"a\").is_absolute(), false);\n+        assert_eq!(PosixPath::new(\"/a\").is_absolute(), true);\n+        assert_eq!(PosixPath::new(\".\").is_absolute(), false);\n+        assert_eq!(PosixPath::new(\"/\").is_absolute(), true);\n+        assert_eq!(PosixPath::new(\"..\").is_absolute(), false);\n+        assert_eq!(PosixPath::new(\"../..\").is_absolute(), false);\n+    }\n+\n+    #[test]\n+    fn test_posix_is_ancestor_of() {\n+        macro_rules! t(\n+            ($path:expr, $dest:expr, $exp:expr) => (\n+                {\n+                    let path = PosixPath::new($path);\n+                    let dest = PosixPath::new($dest);\n+                    assert_eq!(path.is_ancestor_of(&dest), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(\"a/b/c\", \"a/b/c/d\", true);\n+        t!(\"a/b/c\", \"a/b/c\", true);\n+        t!(\"a/b/c\", \"a/b\", false);\n+        t!(\"/a/b/c\", \"/a/b/c\", true);\n+        t!(\"/a/b\", \"/a/b/c\", true);\n+        t!(\"/a/b/c/d\", \"/a/b/c\", false);\n+        t!(\"/a/b\", \"a/b/c\", false);\n+        t!(\"a/b\", \"/a/b/c\", false);\n+        t!(\"a/b/c\", \"a/b/d\", false);\n+        t!(\"../a/b/c\", \"a/b/c\", false);\n+        t!(\"a/b/c\", \"../a/b/c\", false);\n+        t!(\"a/b/c\", \"a/b/cd\", false);\n+        t!(\"a/b/cd\", \"a/b/c\", false);\n+        t!(\"../a/b\", \"../a/b/c\", true);\n+        t!(\".\", \"a/b\", true);\n+        t!(\".\", \".\", true);\n+        t!(\"/\", \"/\", true);\n+        t!(\"/\", \"/a/b\", true);\n+        t!(\"..\", \"a/b\", true);\n+        t!(\"../..\", \"a/b\", true);\n+    }\n+\n+    #[test]\n+    fn test_posix_path_relative_from() {\n+        macro_rules! t(\n+            ($path:expr, $other:expr, $exp:expr) => (\n+                {\n+                    let path = PosixPath::new($path);\n+                    let other = PosixPath::new($other);\n+                    let res = path.path_relative_from(&other);\n+                    assert_eq!(res.map(|x| x.as_str()), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(\"a/b/c\", \"a/b\", Some(\"c\"));\n+        t!(\"a/b/c\", \"a/b/d\", Some(\"../c\"));\n+        t!(\"a/b/c\", \"a/b/c/d\", Some(\"..\"));\n+        t!(\"a/b/c\", \"a/b/c\", Some(\".\"));\n+        t!(\"a/b/c\", \"a/b/c/d/e\", Some(\"../..\"));\n+        t!(\"a/b/c\", \"a/d/e\", Some(\"../../b/c\"));\n+        t!(\"a/b/c\", \"d/e/f\", Some(\"../../../a/b/c\"));\n+        t!(\"a/b/c\", \"/a/b/c\", None);\n+        t!(\"/a/b/c\", \"a/b/c\", Some(\"/a/b/c\"));\n+        t!(\"/a/b/c\", \"/a/b/c/d\", Some(\"..\"));\n+        t!(\"/a/b/c\", \"/a/b\", Some(\"c\"));\n+        t!(\"/a/b/c\", \"/a/b/c/d/e\", Some(\"../..\"));\n+        t!(\"/a/b/c\", \"/a/d/e\", Some(\"../../b/c\"));\n+        t!(\"/a/b/c\", \"/d/e/f\", Some(\"../../../a/b/c\"));\n+        t!(\"hi/there.txt\", \"hi/there\", Some(\"../there.txt\"));\n+        t!(\".\", \"a\", Some(\"..\"));\n+        t!(\".\", \"a/b\", Some(\"../..\"));\n+        t!(\".\", \".\", Some(\".\"));\n+        t!(\"a\", \".\", Some(\"a\"));\n+        t!(\"a/b\", \".\", Some(\"a/b\"));\n+        t!(\"..\", \".\", Some(\"..\"));\n+        t!(\"a/b/c\", \"a/b/c\", Some(\".\"));\n+        t!(\"/a/b/c\", \"/a/b/c\", Some(\".\"));\n+        t!(\"/\", \"/\", Some(\".\"));\n+        t!(\"/\", \".\", Some(\"/\"));\n+        t!(\"../../a\", \"b\", Some(\"../../../a\"));\n+        t!(\"a\", \"../../b\", None);\n+        t!(\"../../a\", \"../../b\", Some(\"../a\"));\n+        t!(\"../../a\", \"../../a/b\", Some(\"..\"));\n+        t!(\"../../a/b\", \"../../a\", Some(\"b\"));\n+    }\n+\n+    #[test]\n+    fn test_posix_component_iter() {\n+        macro_rules! t(\n+            ($path:expr, $exp:expr) => (\n+                {\n+                    let path = PosixPath::new($path);\n+                    let comps = path.component_iter().to_owned_vec();\n+                    assert_eq!(comps.as_slice(), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(\"a/b/c\", [\"a\", \"b\", \"c\"]);\n+        t!(\"a/b/d\", [\"a\", \"b\", \"d\"]);\n+        t!(\"a/b/cd\", [\"a\", \"b\", \"cd\"]);\n+        t!(\"/a/b/c\", [\"a\", \"b\", \"c\"]);\n+        t!(\"a\", [\"a\"]);\n+        t!(\"/a\", [\"a\"]);\n+        t!(\"/\", []);\n+        t!(\".\", [\".\"]);\n+        t!(\"..\", [\"..\"]);\n+        t!(\"../..\", [\"..\", \"..\"]);\n+        t!(\"../../foo\", [\"..\", \"..\", \"foo\"]);\n+    }\n+}"}]}