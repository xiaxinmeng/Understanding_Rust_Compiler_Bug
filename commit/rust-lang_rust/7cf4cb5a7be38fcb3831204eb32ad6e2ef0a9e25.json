{"sha": "7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZjRjYjVhN2JlMzhmY2IzODMxMjA0ZWIzMmFkNmUyZWYwYTllMjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-03-23T14:27:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-23T14:27:06Z"}, "message": "Rollup merge of #48265 - SimonSapin:nonzero, r=KodrAus\n\nAdd 12 num::NonZero* types for primitive integers, deprecate core::nonzero\n\nRFC: https://github.com/rust-lang/rfcs/pull/2307\nTracking issue: ~~https://github.com/rust-lang/rust/issues/27730~~ https://github.com/rust-lang/rust/issues/49137\nFixes https://github.com/rust-lang/rust/issues/27730", "tree": {"sha": "9997fb91ff9e2a46755aabf8fb2ae2c141eae380", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9997fb91ff9e2a46755aabf8fb2ae2c141eae380"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJatQ66CRBK7hj4Ov3rIwAAdHIIAHrCsIXCH2uloEIOcx4bkcjl\nTe41nKUT8jPyiMkN1qUAKSevrdN0XLj8/lINuhsNnCWvCUFG9WijM8KgZDqIYkPy\nw7CMx6ajKX3kIA1Ma4ORQ0vJ/kbXuscDGDU7e4wOmKocC1sd7SPjJBkCCBrkkmpU\nVbEf8ZccxGQZLfgrkk0j0BR6qiiCMLn6SAxIznz6/9obRG6+Gl13AaFilgBcWPc6\nf+b1L9/+x8zFUryLWZggBubkDNl/KYxpxebfgfcnYFIWoI1WEV9rsKw0Cha4TNsw\nwr9GYh9VxB0tYAjfRnKeRtrKegEZkJ99QIKRN9Lw6m2XVm++AyMPVhDtWisx2TA=\n=h/Kh\n-----END PGP SIGNATURE-----\n", "payload": "tree 9997fb91ff9e2a46755aabf8fb2ae2c141eae380\nparent 55e1104dd918a809d2751d325c11d59c85485a2e\nparent a23f685296b2edd59acc998411340184b958ec82\nauthor Alex Crichton <alex@alexcrichton.com> 1521815226 -0500\ncommitter GitHub <noreply@github.com> 1521815226 -0500\n\nRollup merge of #48265 - SimonSapin:nonzero, r=KodrAus\n\nAdd 12 num::NonZero* types for primitive integers, deprecate core::nonzero\n\nRFC: https://github.com/rust-lang/rfcs/pull/2307\nTracking issue: ~~https://github.com/rust-lang/rust/issues/27730~~ https://github.com/rust-lang/rust/issues/49137\nFixes https://github.com/rust-lang/rust/issues/27730\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "html_url": "https://github.com/rust-lang/rust/commit/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55e1104dd918a809d2751d325c11d59c85485a2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/55e1104dd918a809d2751d325c11d59c85485a2e", "html_url": "https://github.com/rust-lang/rust/commit/55e1104dd918a809d2751d325c11d59c85485a2e"}, {"sha": "a23f685296b2edd59acc998411340184b958ec82", "url": "https://api.github.com/repos/rust-lang/rust/commits/a23f685296b2edd59acc998411340184b958ec82", "html_url": "https://github.com/rust-lang/rust/commit/a23f685296b2edd59acc998411340184b958ec82"}], "stats": {"total": 299, "additions": 210, "deletions": 89}, "files": [{"sha": "464f8f2f4eced25d14eca2f3bfeb6c8b40f523c1", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -43,8 +43,7 @@\n \n use core::marker::PhantomData;\n use core::mem;\n-use core::nonzero::NonZero;\n-use core::ptr::{self, Unique};\n+use core::ptr::{self, Unique, NonNull};\n use core::slice;\n \n use boxed::Box;\n@@ -149,14 +148,12 @@ impl<K, V> BoxedNode<K, V> {\n         }\n     }\n \n-    unsafe fn from_ptr(ptr: NonZero<*const LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::new_unchecked(ptr.get() as *mut LeafNode<K, V>) }\n+    unsafe fn from_ptr(ptr: NonNull<LeafNode<K, V>>) -> Self {\n+        BoxedNode { ptr: Unique::from(ptr) }\n     }\n \n-    fn as_ptr(&self) -> NonZero<*const LeafNode<K, V>> {\n-        unsafe {\n-            NonZero::from(self.ptr.as_ref())\n-        }\n+    fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n+        NonNull::from(self.ptr)\n     }\n }\n \n@@ -276,7 +273,7 @@ impl<K, V> Root<K, V> {\n ///   `NodeRef` could be pointing to either type of node.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n-    node: NonZero<*const LeafNode<K, V>>,\n+    node: NonNull<LeafNode<K, V>>,\n     // This is null unless the borrow type is `Mut`\n     root: *const Root<K, V>,\n     _marker: PhantomData<(BorrowType, Type)>\n@@ -302,15 +299,15 @@ unsafe impl<K: Send, V: Send, Type> Send\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     fn as_internal(&self) -> &InternalNode<K, V> {\n         unsafe {\n-            &*(self.node.get() as *const InternalNode<K, V>)\n+            &*(self.node.as_ptr() as *mut InternalNode<K, V>)\n         }\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n         unsafe {\n-            &mut *(self.node.get() as *mut InternalNode<K, V>)\n+            &mut *(self.node.as_ptr() as *mut InternalNode<K, V>)\n         }\n     }\n }\n@@ -352,7 +349,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n \n     fn as_leaf(&self) -> &LeafNode<K, V> {\n         unsafe {\n-            &*self.node.get()\n+            self.node.as_ref()\n         }\n     }\n \n@@ -382,7 +379,8 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         >,\n         Self\n     > {\n-        if let Some(non_zero) = NonZero::new(self.as_leaf().parent as *const LeafNode<K, V>) {\n+        let parent_as_leaf = self.as_leaf().parent as *const LeafNode<K, V>;\n+        if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n                 node: NodeRef {\n                     height: self.height + 1,\n@@ -498,7 +496,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n     fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n         unsafe {\n-            &mut *(self.node.get() as *mut LeafNode<K, V>)\n+            self.node.as_mut()\n         }\n     }\n \n@@ -1241,12 +1239,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 }\n \n                 Heap.dealloc(\n-                    right_node.node.get() as *mut u8,\n+                    right_node.node.as_ptr() as *mut u8,\n                     Layout::new::<InternalNode<K, V>>(),\n                 );\n             } else {\n                 Heap.dealloc(\n-                    right_node.node.get() as *mut u8,\n+                    right_node.node.as_ptr() as *mut u8,\n                     Layout::new::<LeafNode<K, V>>(),\n                 );\n             }"}, {"sha": "c8ee166fee3e9240383a7ff37c77a0c2e15be536", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -146,13 +146,12 @@\n //!\n //! ```\n //! #![feature(core_intrinsics)]\n-//! #![feature(shared)]\n //! use std::cell::Cell;\n-//! use std::ptr::Shared;\n+//! use std::ptr::NonNull;\n //! use std::intrinsics::abort;\n //!\n //! struct Rc<T: ?Sized> {\n-//!     ptr: Shared<RcBox<T>>\n+//!     ptr: NonNull<RcBox<T>>\n //! }\n //!\n //! struct RcBox<T: ?Sized> {"}, {"sha": "19836d98844e292d7be235601e344664faac182f", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -9,9 +9,10 @@\n // except according to those terms.\n \n //! Exposes the NonZero lang item which provides optimization hints.\n-#![unstable(feature = \"nonzero\",\n-            reason = \"needs an RFC to flesh out the design\",\n-            issue = \"27730\")]\n+#![unstable(feature = \"nonzero\", reason = \"deprecated\", issue = \"49137\")]\n+#![rustc_deprecated(reason = \"use `std::ptr::NonNull` or `std::num::NonZero*` instead\",\n+                    since = \"1.26.0\")]\n+#![allow(deprecated)]\n \n use ops::CoerceUnsized;\n \n@@ -62,14 +63,11 @@ impl_zeroable_for_integer_types! {\n /// NULL or 0 that might allow certain optimizations.\n #[lang = \"non_zero\"]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\n-pub struct NonZero<T: Zeroable>(T);\n+pub struct NonZero<T: Zeroable>(pub(crate) T);\n \n impl<T: Zeroable> NonZero<T> {\n     /// Creates an instance of NonZero with the provided value.\n     /// You must indeed ensure that the value is actually \"non-zero\".\n-    #[unstable(feature = \"nonzero\",\n-               reason = \"needs an RFC to flesh out the design\",\n-               issue = \"27730\")]\n     #[inline]\n     pub const unsafe fn new_unchecked(inner: T) -> Self {\n         NonZero(inner)"}, {"sha": "18e0aa453d8df2c71674be7bf554a4ebb5bd7c48", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -15,9 +15,98 @@\n use convert::TryFrom;\n use fmt;\n use intrinsics;\n+#[allow(deprecated)] use nonzero::NonZero;\n use ops;\n use str::FromStr;\n \n+macro_rules! impl_nonzero_fmt {\n+    ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n+        $(\n+            #[$stability]\n+            impl fmt::$Trait for $Ty {\n+                #[inline]\n+                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                    self.get().fmt(f)\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+macro_rules! nonzero_integers {\n+    ( #[$stability: meta] $( $Ty: ident($Int: ty); )+ ) => {\n+        $(\n+            /// An integer that is known not to equal zero.\n+            ///\n+            /// This may enable some memory layout optimization such as:\n+            ///\n+            /// ```rust\n+            /// # #![feature(nonzero)]\n+            /// use std::mem::size_of;\n+            /// assert_eq!(size_of::<Option<std::num::NonZeroU32>>(), size_of::<u32>());\n+            /// ```\n+            #[$stability]\n+            #[allow(deprecated)]\n+            #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+            pub struct $Ty(NonZero<$Int>);\n+\n+            #[allow(deprecated)]\n+            impl $Ty {\n+                /// Create a non-zero without checking the value.\n+                ///\n+                /// # Safety\n+                ///\n+                /// The value must not be zero.\n+                #[$stability]\n+                #[inline]\n+                pub const unsafe fn new_unchecked(n: $Int) -> Self {\n+                    $Ty(NonZero(n))\n+                }\n+\n+                /// Create a non-zero if the given value is not zero.\n+                #[$stability]\n+                #[inline]\n+                pub fn new(n: $Int) -> Option<Self> {\n+                    if n != 0 {\n+                        Some($Ty(NonZero(n)))\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Returns the value as a primitive type.\n+                #[$stability]\n+                #[inline]\n+                pub fn get(self) -> $Int {\n+                    self.0 .0\n+                }\n+\n+            }\n+\n+            impl_nonzero_fmt! {\n+                #[$stability]\n+                (Debug, Display, Binary, Octal, LowerHex, UpperHex) for $Ty\n+            }\n+        )+\n+    }\n+}\n+\n+nonzero_integers! {\n+    #[unstable(feature = \"nonzero\", issue = \"49137\")]\n+    NonZeroU8(u8); NonZeroI8(i8);\n+    NonZeroU16(u16); NonZeroI16(i16);\n+    NonZeroU32(u32); NonZeroI32(i32);\n+    NonZeroU64(u64); NonZeroI64(i64);\n+    NonZeroUsize(usize); NonZeroIsize(isize);\n+}\n+\n+nonzero_integers! {\n+    // Change this to `#[unstable(feature = \"i128\", issue = \"35118\")]`\n+    // if other NonZero* integer types are stabilizied before 128-bit integers\n+    #[unstable(feature = \"nonzero\", issue = \"49137\")]\n+    NonZeroU128(u128); NonZeroI128(i128);\n+}\n+\n /// Provides intentionally-wrapped arithmetic on `T`.\n ///\n /// Operations like `+` on `u32` values is intended to never overflow,"}, {"sha": "cebd5989e96cd2a78c187a3aa048fd550b0e727a", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -23,7 +23,7 @@ use fmt;\n use hash;\n use marker::{PhantomData, Unsize};\n use mem;\n-use nonzero::NonZero;\n+#[allow(deprecated)] use nonzero::NonZero;\n \n use cmp::Ordering::{self, Less, Equal, Greater};\n \n@@ -2285,6 +2285,7 @@ impl<T: ?Sized> PartialOrd for *mut T {\n #[unstable(feature = \"ptr_internals\", issue = \"0\",\n            reason = \"use NonNull instead and consider PhantomData<T> \\\n                      (if you also use #[may_dangle]), Send, and/or Sync\")]\n+#[allow(deprecated)]\n pub struct Unique<T: ?Sized> {\n     pointer: NonZero<*const T>,\n     // NOTE: this marker has no consequences for variance, but is necessary\n@@ -2332,24 +2333,29 @@ impl<T: Sized> Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+#[allow(deprecated)]\n impl<T: ?Sized> Unique<T> {\n     /// Creates a new `Unique`.\n     ///\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        Unique { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n+        Unique { pointer: NonZero(ptr as _), _marker: PhantomData }\n     }\n \n     /// Creates a new `Unique` if `ptr` is non-null.\n     pub fn new(ptr: *mut T) -> Option<Self> {\n-        NonZero::new(ptr as *const T).map(|nz| Unique { pointer: nz, _marker: PhantomData })\n+        if !ptr.is_null() {\n+            Some(Unique { pointer: NonZero(ptr as _), _marker: PhantomData })\n+        } else {\n+            None\n+        }\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n     pub fn as_ptr(self) -> *mut T {\n-        self.pointer.get() as *mut T\n+        self.pointer.0 as *mut T\n     }\n \n     /// Dereferences the content.\n@@ -2392,16 +2398,18 @@ impl<T: ?Sized> fmt::Pointer for Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> From<&'a mut T> for Unique<T> {\n     fn from(reference: &'a mut T) -> Self {\n-        Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n+        Unique { pointer: NonZero(reference as _), _marker: PhantomData }\n     }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> From<&'a T> for Unique<T> {\n     fn from(reference: &'a T) -> Self {\n-        Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n+        Unique { pointer: NonZero(reference as _), _marker: PhantomData }\n     }\n }\n \n@@ -2412,11 +2420,6 @@ impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n     }\n }\n \n-/// Previous name of `NonNull`.\n-#[rustc_deprecated(since = \"1.25.0\", reason = \"renamed to `NonNull`\")]\n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-pub type Shared<T> = NonNull<T>;\n-\n /// `*mut T` but non-zero and covariant.\n ///\n /// This is often the correct thing to use when building data structures using\n@@ -2436,7 +2439,7 @@ pub type Shared<T> = NonNull<T>;\n /// provide a public API that follows the normal shared XOR mutable rules of Rust.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n pub struct NonNull<T: ?Sized> {\n-    pointer: NonZero<*const T>,\n+    #[allow(deprecated)] pointer: NonZero<*const T>,\n }\n \n /// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n@@ -2463,6 +2466,7 @@ impl<T: Sized> NonNull<T> {\n     }\n }\n \n+#[allow(deprecated)]\n impl<T: ?Sized> NonNull<T> {\n     /// Creates a new `NonNull`.\n     ///\n@@ -2471,19 +2475,23 @@ impl<T: ?Sized> NonNull<T> {\n     /// `ptr` must be non-null.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        NonNull { pointer: NonZero::new_unchecked(ptr) }\n+        NonNull { pointer: NonZero(ptr as _) }\n     }\n \n     /// Creates a new `NonNull` if `ptr` is non-null.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     pub fn new(ptr: *mut T) -> Option<Self> {\n-        NonZero::new(ptr as *const T).map(|nz| NonNull { pointer: nz })\n+        if !ptr.is_null() {\n+            Some(NonNull { pointer: NonZero(ptr as _) })\n+        } else {\n+            None\n+        }\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     pub fn as_ptr(self) -> *mut T {\n-        self.pointer.get() as *mut T\n+        self.pointer.0 as *mut T\n     }\n \n     /// Dereferences the content.\n@@ -2581,15 +2589,17 @@ impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> From<&'a mut T> for NonNull<T> {\n     fn from(reference: &'a mut T) -> Self {\n-        NonNull { pointer: NonZero::from(reference) }\n+        NonNull { pointer: NonZero(reference as _) }\n     }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> From<&'a T> for NonNull<T> {\n     fn from(reference: &'a T) -> Self {\n-        NonNull { pointer: NonZero::from(reference) }\n+        NonNull { pointer: NonZero(reference as _) }\n     }\n }"}, {"sha": "8d39298bac3d1b1b3cd13210987fac5e94a1bf71", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -8,36 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::nonzero::NonZero;\n+use core::num::NonZeroU32;\n use core::option::Option;\n use core::option::Option::{Some, None};\n use std::mem::size_of;\n \n #[test]\n fn test_create_nonzero_instance() {\n     let _a = unsafe {\n-        NonZero::new_unchecked(21)\n+        NonZeroU32::new_unchecked(21)\n     };\n }\n \n #[test]\n fn test_size_nonzero_in_option() {\n-    assert_eq!(size_of::<NonZero<u32>>(), size_of::<Option<NonZero<u32>>>());\n+    assert_eq!(size_of::<NonZeroU32>(), size_of::<Option<NonZeroU32>>());\n }\n \n #[test]\n fn test_match_on_nonzero_option() {\n     let a = Some(unsafe {\n-        NonZero::new_unchecked(42)\n+        NonZeroU32::new_unchecked(42)\n     });\n     match a {\n         Some(val) => assert_eq!(val.get(), 42),\n-        None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n+        None => panic!(\"unexpected None while matching on Some(NonZeroU32(_))\")\n     }\n \n-    match unsafe { Some(NonZero::new_unchecked(43)) } {\n+    match unsafe { Some(NonZeroU32::new_unchecked(43)) } {\n         Some(val) => assert_eq!(val.get(), 43),\n-        None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n+        None => panic!(\"unexpected None while matching on Some(NonZeroU32(_))\")\n     }\n }\n \n@@ -98,3 +98,26 @@ fn test_match_option_string() {\n         None => panic!(\"unexpected None while matching on Some(String { ... })\")\n     }\n }\n+\n+mod atom {\n+    use core::num::NonZeroU32;\n+\n+    #[derive(PartialEq, Eq)]\n+    pub struct Atom {\n+        index: NonZeroU32, // private\n+    }\n+    pub const FOO_ATOM: Atom = Atom { index: unsafe { NonZeroU32::new_unchecked(7) } };\n+}\n+\n+macro_rules! atom {\n+    (\"foo\") => { atom::FOO_ATOM }\n+}\n+\n+#[test]\n+fn test_match_nonzero_const_pattern() {\n+    match atom!(\"foo\") {\n+        // Using as a pattern is supported by the compiler:\n+        atom!(\"foo\") => {}\n+        _ => panic!(\"Expected the const item as a pattern to match.\")\n+    }\n+}"}, {"sha": "e7b58ae1564aa1683a86a36d92c5ee81eae26a47", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -19,11 +19,11 @@ use syntax_pos::{Span, DUMMY_SP};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n use core::intrinsics;\n-use core::nonzero::NonZero;\n use std::fmt;\n use std::iter;\n use std::marker::PhantomData;\n use std::mem;\n+use std::num::NonZeroUsize;\n \n /// An entity in the Rust typesystem, which can be one of\n /// several kinds (only types and lifetimes for now).\n@@ -32,7 +32,7 @@ use std::mem;\n /// indicate the type (`Ty` or `Region`) it points to.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Kind<'tcx> {\n-    ptr: NonZero<usize>,\n+    ptr: NonZeroUsize,\n     marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>)>\n }\n \n@@ -63,7 +63,7 @@ impl<'tcx> UnpackedKind<'tcx> {\n \n         Kind {\n             ptr: unsafe {\n-                NonZero::new_unchecked(ptr | tag)\n+                NonZeroUsize::new_unchecked(ptr | tag)\n             },\n             marker: PhantomData\n         }"}, {"sha": "37512e4bcd57f334e971f44aff537f61475d2eba", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -8,18 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::nonzero::NonZero;\n+use std::num::NonZeroU32;\n use std::u32;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct NodeIndex {\n-    index: NonZero<u32>,\n+    index: NonZeroU32,\n }\n \n impl NodeIndex {\n     pub fn new(value: usize) -> NodeIndex {\n         assert!(value < (u32::MAX as usize));\n-        NodeIndex { index: NonZero::new((value as u32) + 1).unwrap() }\n+        NodeIndex { index: NonZeroU32::new((value as u32) + 1).unwrap() }\n     }\n \n     pub fn get(self) -> usize {"}, {"sha": "9f6cf8c036e19a686e44febe3a783e252f8dd44c", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -29,17 +29,17 @@ mod abs_domain;\n // (which is likely to yield a subtle off-by-one error).\n pub(crate) mod indexes {\n     use std::fmt;\n-    use core::nonzero::NonZero;\n+    use std::num::NonZeroUsize;\n     use rustc_data_structures::indexed_vec::Idx;\n \n     macro_rules! new_index {\n         ($Index:ident, $debug_name:expr) => {\n             #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-            pub struct $Index(NonZero<usize>);\n+            pub struct $Index(NonZeroUsize);\n \n             impl Idx for $Index {\n                 fn new(idx: usize) -> Self {\n-                    $Index(NonZero::new(idx + 1).unwrap())\n+                    $Index(NonZeroUsize::new(idx + 1).unwrap())\n                 }\n                 fn index(self) -> usize {\n                     self.0.get() - 1"}, {"sha": "36eb72918221004e9da36b038e598bd5d169da47", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -282,6 +282,7 @@\n #![feature(macro_vis_matcher)]\n #![feature(needs_panic_runtime)]\n #![feature(exhaustive_patterns)]\n+#![feature(nonzero)]\n #![feature(num_bits_bytes)]\n #![feature(old_wrapping)]\n #![feature(on_unimplemented)]"}, {"sha": "6f537fd5c50e11e11de41b66058a7f572f744a1c", "filename": "src/libstd/num.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibstd%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Flibstd%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -21,6 +21,17 @@ pub use core::num::{FpCategory, ParseIntError, ParseFloatError, TryFromIntError}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::Wrapping;\n \n+#[unstable(feature = \"nonzero\", issue = \"49137\")]\n+pub use core::num::{\n+    NonZeroU8, NonZeroI8, NonZeroU16, NonZeroI16, NonZeroU32, NonZeroI32,\n+    NonZeroU64, NonZeroI64, NonZeroUsize, NonZeroIsize,\n+};\n+\n+// Change this to `#[unstable(feature = \"i128\", issue = \"35118\")]`\n+// if other NonZero* integer types are stabilizied before 128-bit integers\n+#[unstable(feature = \"nonzero\", issue = \"49137\")]\n+pub use core::num::{NonZeroU128, NonZeroI128};\n+\n #[cfg(test)] use fmt;\n #[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n "}, {"sha": "12f17a1575e8211a09ca43a4ec28e96fad193b49", "filename": "src/test/run-pass/enum-null-pointer-opt.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -10,10 +10,9 @@\n \n #![feature(nonzero, core)]\n \n-extern crate core;\n-\n-use core::nonzero::NonZero;\n use std::mem::size_of;\n+use std::num::NonZeroUsize;\n+use std::ptr::NonNull;\n use std::rc::Rc;\n use std::sync::Arc;\n \n@@ -59,8 +58,8 @@ fn main() {\n     assert_eq!(size_of::<[Box<isize>; 1]>(), size_of::<Option<[Box<isize>; 1]>>());\n \n     // Should apply to NonZero\n-    assert_eq!(size_of::<NonZero<usize>>(), size_of::<Option<NonZero<usize>>>());\n-    assert_eq!(size_of::<NonZero<*mut i8>>(), size_of::<Option<NonZero<*mut i8>>>());\n+    assert_eq!(size_of::<NonZeroUsize>(), size_of::<Option<NonZeroUsize>>());\n+    assert_eq!(size_of::<NonNull<i8>>(), size_of::<Option<NonNull<i8>>>());\n \n     // Should apply to types that use NonZero internally\n     assert_eq!(size_of::<Vec<isize>>(), size_of::<Option<Vec<isize>>>());"}, {"sha": "9547b2f08a6bcc8bc3fce498c12c6ecb7aebc49a", "filename": "src/test/run-pass/issue-23433.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Ftest%2Frun-pass%2Fissue-23433.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Ftest%2Frun-pass%2Fissue-23433.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23433.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Don't fail if we encounter a NonZero<*T> where T is an unsized type\n+// Don't fail if we encounter a NonNull<T> where T is an unsized type\n \n use std::ptr::NonNull;\n "}, {"sha": "875883a2cca7fe74e8ecc883f2066f7354a49be0", "filename": "src/test/ui/print_type_sizes/niche-filling.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -14,7 +14,7 @@\n // This file illustrates how niche-filling enums are handled,\n // modelled after cases like `Option<&u32>`, `Option<bool>` and such.\n //\n-// It uses NonZero directly, rather than `&_` or `Unique<_>`, because\n+// It uses NonZeroU32 rather than `&_` or `Unique<_>`, because\n // the test is not set up to deal with target-dependent pointer width.\n //\n // It avoids using u64/i64 because on some targets that is only 4-byte\n@@ -25,8 +25,7 @@\n #![feature(nonzero)]\n #![allow(dead_code)]\n \n-extern crate core;\n-use core::nonzero::{NonZero, Zeroable};\n+use std::num::NonZeroU32;\n \n pub enum MyOption<T> { None, Some(T) }\n \n@@ -36,40 +35,32 @@ impl<T> Default for MyOption<T> {\n \n pub enum EmbeddedDiscr {\n     None,\n-    Record { pre: u8, val: NonZero<u32>, post: u16 },\n+    Record { pre: u8, val: NonZeroU32, post: u16 },\n }\n \n impl Default for EmbeddedDiscr {\n     fn default() -> Self { EmbeddedDiscr::None }\n }\n \n #[derive(Default)]\n-pub struct IndirectNonZero<T: Zeroable + One> {\n+pub struct IndirectNonZero {\n     pre: u8,\n-    nested: NestedNonZero<T>,\n+    nested: NestedNonZero,\n     post: u16,\n }\n \n-pub struct NestedNonZero<T: Zeroable> {\n+pub struct NestedNonZero {\n     pre: u8,\n-    val: NonZero<T>,\n+    val: NonZeroU32,\n     post: u16,\n }\n \n-impl<T: Zeroable+One> Default for NestedNonZero<T> {\n+impl Default for NestedNonZero {\n     fn default() -> Self {\n-        NestedNonZero { pre: 0, val: NonZero::new(T::one()).unwrap(), post: 0 }\n+        NestedNonZero { pre: 0, val: NonZeroU32::new(1).unwrap(), post: 0 }\n     }\n }\n \n-pub trait One {\n-    fn one() -> Self;\n-}\n-\n-impl One for u32 {\n-    fn one() -> Self { 1 }\n-}\n-\n pub enum Enum4<A, B, C, D> {\n     One(A),\n     Two(B),\n@@ -79,9 +70,9 @@ pub enum Enum4<A, B, C, D> {\n \n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    let _x: MyOption<NonZero<u32>> = Default::default();\n+    let _x: MyOption<NonZeroU32> = Default::default();\n     let _y: EmbeddedDiscr = Default::default();\n-    let _z: MyOption<IndirectNonZero<u32>> = Default::default();\n+    let _z: MyOption<IndirectNonZero> = Default::default();\n     let _a: MyOption<bool> = Default::default();\n     let _b: MyOption<char> = Default::default();\n     let _c: MyOption<std::cmp::Ordering> = Default::default();"}, {"sha": "79f9ef5a231d38bad05b799e861b8f9fc3d3d092", "filename": "src/test/ui/print_type_sizes/niche-filling.stdout", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout?ref=7cf4cb5a7be38fcb3831204eb32ad6e2ef0a9e25", "patch": "@@ -1,9 +1,9 @@\n-print-type-size type: `IndirectNonZero<u32>`: 12 bytes, alignment: 4 bytes\n+print-type-size type: `IndirectNonZero`: 12 bytes, alignment: 4 bytes\n print-type-size     field `.nested`: 8 bytes\n print-type-size     field `.post`: 2 bytes\n print-type-size     field `.pre`: 1 bytes\n print-type-size     end padding: 1 bytes\n-print-type-size type: `MyOption<IndirectNonZero<u32>>`: 12 bytes, alignment: 4 bytes\n+print-type-size type: `MyOption<IndirectNonZero>`: 12 bytes, alignment: 4 bytes\n print-type-size     variant `None`: 0 bytes\n print-type-size     variant `Some`: 12 bytes\n print-type-size         field `.0`: 12 bytes\n@@ -14,7 +14,7 @@ print-type-size         field `.val`: 4 bytes\n print-type-size         field `.post`: 2 bytes\n print-type-size         field `.pre`: 1 bytes\n print-type-size     end padding: 1 bytes\n-print-type-size type: `NestedNonZero<u32>`: 8 bytes, alignment: 4 bytes\n+print-type-size type: `NestedNonZero`: 8 bytes, alignment: 4 bytes\n print-type-size     field `.val`: 4 bytes\n print-type-size     field `.post`: 2 bytes\n print-type-size     field `.pre`: 1 bytes\n@@ -32,12 +32,14 @@ print-type-size type: `MyOption<char>`: 4 bytes, alignment: 4 bytes\n print-type-size     variant `None`: 0 bytes\n print-type-size     variant `Some`: 4 bytes\n print-type-size         field `.0`: 4 bytes\n-print-type-size type: `MyOption<core::nonzero::NonZero<u32>>`: 4 bytes, alignment: 4 bytes\n+print-type-size type: `MyOption<std::num::NonZeroU32>`: 4 bytes, alignment: 4 bytes\n print-type-size     variant `None`: 0 bytes\n print-type-size     variant `Some`: 4 bytes\n print-type-size         field `.0`: 4 bytes\n print-type-size type: `core::nonzero::NonZero<u32>`: 4 bytes, alignment: 4 bytes\n print-type-size     field `.0`: 4 bytes\n+print-type-size type: `std::num::NonZeroU32`: 4 bytes, alignment: 4 bytes\n+print-type-size     field `.0`: 4 bytes\n print-type-size type: `Enum4<(), (), (), MyOption<u8>>`: 2 bytes, alignment: 1 bytes\n print-type-size     variant `One`: 0 bytes\n print-type-size         field `.0`: 0 bytes"}]}