{"sha": "dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiY2MzZmU2M2E3MWQ5MmQxOTRkOTlkZmQ1ZTczZmI2MmQwOWU3OWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-29T20:39:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-29T20:39:37Z"}, "message": "auto merge of #6110 : bjz/rust/numeric-traits, r=pcwalton\n\nAs discussed on issue #4819, I have created four new traits: `Algebraic`, `Trigonometric`, `Exponential` and `Hyperbolic`, and moved the appropriate methods into them from `Real`.\r\n\r\n~~~rust\r\npub trait Algebraic {\r\n    fn pow(&self, n: Self) -> Self;\r\n    fn sqrt(&self) -> Self;\r\n    fn rsqrt(&self) -> Self;\r\n    fn cbrt(&self) -> Self;\r\n    fn hypot(&self, other: Self) -> Self;\r\n}\r\n\r\npub trait Trigonometric {\r\n    fn sin(&self) -> Self;\r\n    fn cos(&self) -> Self;\r\n    fn tan(&self) -> Self;\r\n    fn asin(&self) -> Self;\r\n    fn acos(&self) -> Self;\r\n    fn atan(&self) -> Self;\r\n    fn atan2(&self, other: Self) -> Self;\r\n}\r\n\r\npub trait Exponential {\r\n    fn exp(&self) -> Self;\r\n    fn exp2(&self) -> Self;\r\n    fn expm1(&self) -> Self;\r\n    fn log(&self) -> Self;\r\n    fn log2(&self) -> Self;\r\n    fn log10(&self) -> Self;\r\n}\r\n\r\npub trait Hyperbolic: Exponential {\r\n    fn sinh(&self) -> Self;\r\n    fn cosh(&self) -> Self;\r\n    fn tanh(&self) -> Self;\r\n}\r\n~~~\r\n\r\nThere was some discussion over whether we should shorten the names, for example `Trig` and `Exp`. No abbreviations have been agreed on yet, but this could be considered in the future.\r\n\r\nAdditionally, `Integer::divisible_by` has been renamed to `Integer::is_multiple_of`.", "tree": {"sha": "642f815ad0d6a4043531bb0bfa521e459febaf50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/642f815ad0d6a4043531bb0bfa521e459febaf50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "html_url": "https://github.com/rust-lang/rust/commit/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76ec35ae743ee299484a48b233bc64cf3779097d", "url": "https://api.github.com/repos/rust-lang/rust/commits/76ec35ae743ee299484a48b233bc64cf3779097d", "html_url": "https://github.com/rust-lang/rust/commit/76ec35ae743ee299484a48b233bc64cf3779097d"}, {"sha": "500078e147e1e5f5cf9bd57459ebbdda652d97ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/500078e147e1e5f5cf9bd57459ebbdda652d97ed", "html_url": "https://github.com/rust-lang/rust/commit/500078e147e1e5f5cf9bd57459ebbdda652d97ed"}], "stats": {"total": 638, "additions": 380, "deletions": 258}, "files": [{"sha": "f9a56f613d54276c7acb56b484abd6cf50e28a1d", "filename": "src/libcore/core.rc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -105,8 +105,9 @@ pub use old_iter::{ExtendedMutableIter};\n pub use iter::Times;\n \n pub use num::{Num, NumCast};\n-pub use num::{Orderable, Signed, Unsigned, Integer};\n-pub use num::{Round, Fractional, Real, RealExt};\n+pub use num::{Orderable, Signed, Unsigned, Round};\n+pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};\n+pub use num::{Integer, Fractional, Real, RealExt};\n pub use num::{Bitwise, BitCount, Bounded};\n pub use num::{Primitive, Int, Float};\n "}, {"sha": "e687f482fa98c1bfcb0f5ebfa52b5d835db445ee", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 70, "deletions": 72, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -11,7 +11,6 @@\n //! Operations and constants for `f32`\n \n use from_str;\n-use libc::c_int;\n use num::{Zero, One, strconv};\n use prelude::*;\n \n@@ -102,8 +101,8 @@ delegate!(\n     fn sinh(n: c_float) -> c_float = c_float_utils::sinh,\n     fn tan(n: c_float) -> c_float = c_float_utils::tan,\n     fn tanh(n: c_float) -> c_float = c_float_utils::tanh,\n-    fn tgamma(n: c_float) -> c_float = c_float_utils::tgamma)\n-\n+    fn tgamma(n: c_float) -> c_float = c_float_utils::tgamma\n+)\n \n // These are not defined inside consts:: for consistency with\n // the integer types\n@@ -368,154 +367,153 @@ impl Fractional for f32 {\n     fn recip(&self) -> f32 { 1.0 / *self }\n }\n \n-impl Real for f32 {\n-    /// Archimedes' constant\n+impl Algebraic for f32 {\n     #[inline(always)]\n-    fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n-\n-    /// 2.0 * pi\n-    #[inline(always)]\n-    fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n-\n-    /// pi / 2.0\n-    #[inline(always)]\n-    fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n-\n-    /// pi / 3.0\n-    #[inline(always)]\n-    fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n+    fn pow(&self, n: f32) -> f32 { pow(*self, n) }\n \n-    /// pi / 4.0\n     #[inline(always)]\n-    fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n+    fn sqrt(&self) -> f32 { sqrt(*self) }\n \n-    /// pi / 6.0\n     #[inline(always)]\n-    fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n+    fn rsqrt(&self) -> f32 { self.sqrt().recip() }\n \n-    /// pi / 8.0\n     #[inline(always)]\n-    fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n+    fn cbrt(&self) -> f32 { cbrt(*self) }\n \n-    /// 1 .0/ pi\n     #[inline(always)]\n-    fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n+    fn hypot(&self, other: f32) -> f32 { hypot(*self, other) }\n+}\n \n-    /// 2.0 / pi\n+impl Trigonometric for f32 {\n     #[inline(always)]\n-    fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n+    fn sin(&self) -> f32 { sin(*self) }\n \n-    /// 2.0 / sqrt(pi)\n     #[inline(always)]\n-    fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n+    fn cos(&self) -> f32 { cos(*self) }\n \n-    /// sqrt(2.0)\n     #[inline(always)]\n-    fn sqrt2() -> f32 { 1.41421356237309504880168872420969808 }\n+    fn tan(&self) -> f32 { tan(*self) }\n \n-    /// 1.0 / sqrt(2.0)\n     #[inline(always)]\n-    fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }\n+    fn asin(&self) -> f32 { asin(*self) }\n \n-    /// Euler's number\n     #[inline(always)]\n-    fn e() -> f32 { 2.71828182845904523536028747135266250 }\n+    fn acos(&self) -> f32 { acos(*self) }\n \n-    /// log2(e)\n     #[inline(always)]\n-    fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n+    fn atan(&self) -> f32 { atan(*self) }\n \n-    /// log10(e)\n     #[inline(always)]\n-    fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n+    fn atan2(&self, other: f32) -> f32 { atan2(*self, other) }\n+}\n \n-    /// log(2.0)\n+impl Exponential for f32 {\n     #[inline(always)]\n-    fn log_2() -> f32 { 0.693147180559945309417232121458176568 }\n+    fn exp(&self) -> f32 { exp(*self) }\n \n-    /// log(10.0)\n     #[inline(always)]\n-    fn log_10() -> f32 { 2.30258509299404568401799145468436421 }\n+    fn exp2(&self) -> f32 { exp2(*self) }\n \n     #[inline(always)]\n-    fn pow(&self, n: f32) -> f32 { pow(*self, n) }\n+    fn expm1(&self) -> f32 { expm1(*self) }\n \n     #[inline(always)]\n-    fn exp(&self) -> f32 { exp(*self) }\n+    fn log(&self) -> f32 { ln(*self) }\n \n     #[inline(always)]\n-    fn exp2(&self) -> f32 { exp2(*self) }\n+    fn log2(&self) -> f32 { log2(*self) }\n \n     #[inline(always)]\n-    fn expm1(&self) -> f32 { expm1(*self) }\n+    fn log10(&self) -> f32 { log10(*self) }\n+}\n \n+impl Hyperbolic for f32 {\n     #[inline(always)]\n-    fn ldexp(&self, n: int) -> f32 { ldexp(*self, n as c_int) }\n+    fn sinh(&self) -> f32 { sinh(*self) }\n \n     #[inline(always)]\n-    fn log(&self) -> f32 { ln(*self) }\n+    fn cosh(&self) -> f32 { cosh(*self) }\n \n     #[inline(always)]\n-    fn log2(&self) -> f32 { log2(*self) }\n+    fn tanh(&self) -> f32 { tanh(*self) }\n+}\n \n+impl Real for f32 {\n+    /// Archimedes' constant\n     #[inline(always)]\n-    fn log10(&self) -> f32 { log10(*self) }\n+    fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n \n+    /// 2.0 * pi\n     #[inline(always)]\n-    fn log_radix(&self) -> f32 { log_radix(*self) as f32 }\n+    fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n \n+    /// pi / 2.0\n     #[inline(always)]\n-    fn ilog_radix(&self) -> int { ilog_radix(*self) as int }\n+    fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n \n+    /// pi / 3.0\n     #[inline(always)]\n-    fn sqrt(&self) -> f32 { sqrt(*self) }\n+    fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n \n+    /// pi / 4.0\n     #[inline(always)]\n-    fn rsqrt(&self) -> f32 { self.sqrt().recip() }\n+    fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n \n+    /// pi / 6.0\n     #[inline(always)]\n-    fn cbrt(&self) -> f32 { cbrt(*self) }\n+    fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n \n-    /// Converts to degrees, assuming the number is in radians\n+    /// pi / 8.0\n     #[inline(always)]\n-    fn to_degrees(&self) -> f32 { *self * (180.0 / Real::pi::<f32>()) }\n+    fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n \n-    /// Converts to radians, assuming the number is in degrees\n+    /// 1 .0/ pi\n     #[inline(always)]\n-    fn to_radians(&self) -> f32 { *self * (Real::pi::<f32>() / 180.0) }\n+    fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n \n+    /// 2.0 / pi\n     #[inline(always)]\n-    fn hypot(&self, other: f32) -> f32 { hypot(*self, other) }\n+    fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n \n+    /// 2.0 / sqrt(pi)\n     #[inline(always)]\n-    fn sin(&self) -> f32 { sin(*self) }\n+    fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n \n+    /// sqrt(2.0)\n     #[inline(always)]\n-    fn cos(&self) -> f32 { cos(*self) }\n+    fn sqrt2() -> f32 { 1.41421356237309504880168872420969808 }\n \n+    /// 1.0 / sqrt(2.0)\n     #[inline(always)]\n-    fn tan(&self) -> f32 { tan(*self) }\n+    fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }\n \n+    /// Euler's number\n     #[inline(always)]\n-    fn asin(&self) -> f32 { asin(*self) }\n+    fn e() -> f32 { 2.71828182845904523536028747135266250 }\n \n+    /// log2(e)\n     #[inline(always)]\n-    fn acos(&self) -> f32 { acos(*self) }\n+    fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n \n+    /// log10(e)\n     #[inline(always)]\n-    fn atan(&self) -> f32 { atan(*self) }\n+    fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n \n+    /// log(2.0)\n     #[inline(always)]\n-    fn atan2(&self, other: f32) -> f32 { atan2(*self, other) }\n+    fn log_2() -> f32 { 0.693147180559945309417232121458176568 }\n \n+    /// log(10.0)\n     #[inline(always)]\n-    fn sinh(&self) -> f32 { sinh(*self) }\n+    fn log_10() -> f32 { 2.30258509299404568401799145468436421 }\n \n+    /// Converts to degrees, assuming the number is in radians\n     #[inline(always)]\n-    fn cosh(&self) -> f32 { cosh(*self) }\n+    fn to_degrees(&self) -> f32 { *self * (180.0 / Real::pi::<f32>()) }\n \n+    /// Converts to radians, assuming the number is in degrees\n     #[inline(always)]\n-    fn tanh(&self) -> f32 { tanh(*self) }\n+    fn to_radians(&self) -> f32 { *self * (Real::pi::<f32>() / 180.0) }\n }\n \n impl Bounded for f32 {"}, {"sha": "d00e6ae2c0d7936032aa8a761a83c1dbc24bd9d1", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -109,7 +109,8 @@ delegate!(\n     fn jn(i: c_int, n: c_double) -> c_double = c_double_utils::jn,\n     fn y0(n: c_double) -> c_double = c_double_utils::y0,\n     fn y1(n: c_double) -> c_double = c_double_utils::y1,\n-    fn yn(i: c_int, n: c_double) -> c_double = c_double_utils::yn)\n+    fn yn(i: c_int, n: c_double) -> c_double = c_double_utils::yn\n+)\n \n // FIXME (#1433): obtain these in a different way\n \n@@ -378,154 +379,153 @@ impl Fractional for f64 {\n     fn recip(&self) -> f64 { 1.0 / *self }\n }\n \n-impl Real for f64 {\n-    /// Archimedes' constant\n+impl Algebraic for f64 {\n     #[inline(always)]\n-    fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n-\n-    /// 2.0 * pi\n-    #[inline(always)]\n-    fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n-\n-    /// pi / 2.0\n-    #[inline(always)]\n-    fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n+    fn pow(&self, n: f64) -> f64 { pow(*self, n) }\n \n-    /// pi / 3.0\n     #[inline(always)]\n-    fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n-\n-    /// pi / 4.0\n-    #[inline(always)]\n-    fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n+    fn sqrt(&self) -> f64 { sqrt(*self) }\n \n-    /// pi / 6.0\n     #[inline(always)]\n-    fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n+    fn rsqrt(&self) -> f64 { self.sqrt().recip() }\n \n-    /// pi / 8.0\n     #[inline(always)]\n-    fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n+    fn cbrt(&self) -> f64 { cbrt(*self) }\n \n-    /// 1.0 / pi\n     #[inline(always)]\n-    fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n+    fn hypot(&self, other: f64) -> f64 { hypot(*self, other) }\n+}\n \n-    /// 2.0 / pi\n+impl Trigonometric for f64 {\n     #[inline(always)]\n-    fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n+    fn sin(&self) -> f64 { sin(*self) }\n \n-    /// 2.0 / sqrt(pi)\n     #[inline(always)]\n-    fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n+    fn cos(&self) -> f64 { cos(*self) }\n \n-    /// sqrt(2.0)\n     #[inline(always)]\n-    fn sqrt2() -> f64 { 1.41421356237309504880168872420969808 }\n+    fn tan(&self) -> f64 { tan(*self) }\n \n-    /// 1.0 / sqrt(2.0)\n     #[inline(always)]\n-    fn frac_1_sqrt2() -> f64 { 0.707106781186547524400844362104849039 }\n+    fn asin(&self) -> f64 { asin(*self) }\n \n-    /// Euler's number\n     #[inline(always)]\n-    fn e() -> f64 { 2.71828182845904523536028747135266250 }\n+    fn acos(&self) -> f64 { acos(*self) }\n \n-    /// log2(e)\n     #[inline(always)]\n-    fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n+    fn atan(&self) -> f64 { atan(*self) }\n \n-    /// log10(e)\n     #[inline(always)]\n-    fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n+    fn atan2(&self, other: f64) -> f64 { atan2(*self, other) }\n+}\n \n-    /// log(2.0)\n+impl Exponential for f64 {\n     #[inline(always)]\n-    fn log_2() -> f64 { 0.693147180559945309417232121458176568 }\n+    fn exp(&self) -> f64 { exp(*self) }\n \n-    /// log(10.0)\n     #[inline(always)]\n-    fn log_10() -> f64 { 2.30258509299404568401799145468436421 }\n+    fn exp2(&self) -> f64 { exp2(*self) }\n \n     #[inline(always)]\n-    fn pow(&self, n: f64) -> f64 { pow(*self, n) }\n+    fn expm1(&self) -> f64 { expm1(*self) }\n \n     #[inline(always)]\n-    fn exp(&self) -> f64 { exp(*self) }\n+    fn log(&self) -> f64 { ln(*self) }\n \n     #[inline(always)]\n-    fn exp2(&self) -> f64 { exp2(*self) }\n+    fn log2(&self) -> f64 { log2(*self) }\n \n     #[inline(always)]\n-    fn expm1(&self) -> f64 { expm1(*self) }\n+    fn log10(&self) -> f64 { log10(*self) }\n+}\n \n+impl Hyperbolic for f64 {\n     #[inline(always)]\n-    fn ldexp(&self, n: int) -> f64 { ldexp(*self, n as c_int) }\n+    fn sinh(&self) -> f64 { sinh(*self) }\n \n     #[inline(always)]\n-    fn log(&self) -> f64 { ln(*self) }\n+    fn cosh(&self) -> f64 { cosh(*self) }\n \n     #[inline(always)]\n-    fn log2(&self) -> f64 { log2(*self) }\n+    fn tanh(&self) -> f64 { tanh(*self) }\n+}\n \n+impl Real for f64 {\n+    /// Archimedes' constant\n     #[inline(always)]\n-    fn log10(&self) -> f64 { log10(*self) }\n+    fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n \n+    /// 2.0 * pi\n     #[inline(always)]\n-    fn log_radix(&self) -> f64 { log_radix(*self) }\n+    fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n \n+    /// pi / 2.0\n     #[inline(always)]\n-    fn ilog_radix(&self) -> int { ilog_radix(*self) as int }\n+    fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n \n+    /// pi / 3.0\n     #[inline(always)]\n-    fn sqrt(&self) -> f64 { sqrt(*self) }\n+    fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n \n+    /// pi / 4.0\n     #[inline(always)]\n-    fn rsqrt(&self) -> f64 { self.sqrt().recip() }\n+    fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n \n+    /// pi / 6.0\n     #[inline(always)]\n-    fn cbrt(&self) -> f64 { cbrt(*self) }\n+    fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n \n-    /// Converts to degrees, assuming the number is in radians\n+    /// pi / 8.0\n     #[inline(always)]\n-    fn to_degrees(&self) -> f64 { *self * (180.0 / Real::pi::<f64>()) }\n+    fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n \n-    /// Converts to radians, assuming the number is in degrees\n+    /// 1.0 / pi\n     #[inline(always)]\n-    fn to_radians(&self) -> f64 { *self * (Real::pi::<f64>() / 180.0) }\n+    fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n \n+    /// 2.0 / pi\n     #[inline(always)]\n-    fn hypot(&self, other: f64) -> f64 { hypot(*self, other) }\n+    fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n \n+    /// 2.0 / sqrt(pi)\n     #[inline(always)]\n-    fn sin(&self) -> f64 { sin(*self) }\n+    fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n \n+    /// sqrt(2.0)\n     #[inline(always)]\n-    fn cos(&self) -> f64 { cos(*self) }\n+    fn sqrt2() -> f64 { 1.41421356237309504880168872420969808 }\n \n+    /// 1.0 / sqrt(2.0)\n     #[inline(always)]\n-    fn tan(&self) -> f64 { tan(*self) }\n+    fn frac_1_sqrt2() -> f64 { 0.707106781186547524400844362104849039 }\n \n+    /// Euler's number\n     #[inline(always)]\n-    fn asin(&self) -> f64 { asin(*self) }\n+    fn e() -> f64 { 2.71828182845904523536028747135266250 }\n \n+    /// log2(e)\n     #[inline(always)]\n-    fn acos(&self) -> f64 { acos(*self) }\n+    fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n \n+    /// log10(e)\n     #[inline(always)]\n-    fn atan(&self) -> f64 { atan(*self) }\n+    fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n \n+    /// log(2.0)\n     #[inline(always)]\n-    fn atan2(&self, other: f64) -> f64 { atan2(*self, other) }\n+    fn log_2() -> f64 { 0.693147180559945309417232121458176568 }\n \n+    /// log(10.0)\n     #[inline(always)]\n-    fn sinh(&self) -> f64 { sinh(*self) }\n+    fn log_10() -> f64 { 2.30258509299404568401799145468436421 }\n \n+    /// Converts to degrees, assuming the number is in radians\n     #[inline(always)]\n-    fn cosh(&self) -> f64 { cosh(*self) }\n+    fn to_degrees(&self) -> f64 { *self * (180.0 / Real::pi::<f64>()) }\n \n+    /// Converts to radians, assuming the number is in degrees\n     #[inline(always)]\n-    fn tanh(&self) -> f64 { tanh(*self) }\n+    fn to_radians(&self) -> f64 { *self * (Real::pi::<f64>() / 180.0) }\n }\n \n impl RealExt for f64 {"}, {"sha": "3aa8848cdbed24be2d28062db49477b8bb5708d9", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 110, "deletions": 69, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -453,154 +453,195 @@ impl Fractional for float {\n     fn recip(&self) -> float { 1.0 / *self }\n }\n \n-impl Real for float {\n-    /// Archimedes' constant\n-    #[inline(always)]\n-    fn pi() -> float { 3.14159265358979323846264338327950288 }\n-\n-    /// 2.0 * pi\n-    #[inline(always)]\n-    fn two_pi() -> float { 6.28318530717958647692528676655900576 }\n-\n-    /// pi / 2.0\n-    #[inline(always)]\n-    fn frac_pi_2() -> float { 1.57079632679489661923132169163975144 }\n-\n-    /// pi / 3.0\n+impl Algebraic for float {\n     #[inline(always)]\n-    fn frac_pi_3() -> float { 1.04719755119659774615421446109316763 }\n+    fn pow(&self, n: float) -> float {\n+        (*self as f64).pow(n as f64) as float\n+    }\n \n-    /// pi / 4.0\n     #[inline(always)]\n-    fn frac_pi_4() -> float { 0.785398163397448309615660845819875721 }\n+    fn sqrt(&self) -> float {\n+        (*self as f64).sqrt() as float\n+    }\n \n-    /// pi / 6.0\n     #[inline(always)]\n-    fn frac_pi_6() -> float { 0.52359877559829887307710723054658381 }\n+    fn rsqrt(&self) -> float {\n+        (*self as f64).rsqrt() as float\n+    }\n \n-    /// pi / 8.0\n     #[inline(always)]\n-    fn frac_pi_8() -> float { 0.39269908169872415480783042290993786 }\n+    fn cbrt(&self) -> float {\n+        (*self as f64).cbrt() as float\n+    }\n \n-    /// 1.0 / pi\n     #[inline(always)]\n-    fn frac_1_pi() -> float { 0.318309886183790671537767526745028724 }\n+    fn hypot(&self, other: float) -> float {\n+        (*self as f64).hypot(other as f64) as float\n+    }\n+}\n \n-    /// 2.0 / pi\n+impl Trigonometric for float {\n     #[inline(always)]\n-    fn frac_2_pi() -> float { 0.636619772367581343075535053490057448 }\n+    fn sin(&self) -> float {\n+        (*self as f64).sin() as float\n+    }\n \n-    /// 2 .0/ sqrt(pi)\n     #[inline(always)]\n-    fn frac_2_sqrtpi() -> float { 1.12837916709551257389615890312154517 }\n+    fn cos(&self) -> float {\n+        (*self as f64).cos() as float\n+    }\n \n-    /// sqrt(2.0)\n     #[inline(always)]\n-    fn sqrt2() -> float { 1.41421356237309504880168872420969808 }\n+    fn tan(&self) -> float {\n+        (*self as f64).tan() as float\n+    }\n \n-    /// 1.0 / sqrt(2.0)\n     #[inline(always)]\n-    fn frac_1_sqrt2() -> float { 0.707106781186547524400844362104849039 }\n+    fn asin(&self) -> float {\n+        (*self as f64).asin() as float\n+    }\n \n-    /// Euler's number\n     #[inline(always)]\n-    fn e() -> float { 2.71828182845904523536028747135266250 }\n+    fn acos(&self) -> float {\n+        (*self as f64).acos() as float\n+    }\n \n-    /// log2(e)\n     #[inline(always)]\n-    fn log2_e() -> float { 1.44269504088896340735992468100189214 }\n+    fn atan(&self) -> float {\n+        (*self as f64).atan() as float\n+    }\n \n-    /// log10(e)\n     #[inline(always)]\n-    fn log10_e() -> float { 0.434294481903251827651128918916605082 }\n+    fn atan2(&self, other: float) -> float {\n+        (*self as f64).atan2(other as f64) as float\n+    }\n+}\n \n-    /// log(2.0)\n+impl Exponential for float {\n     #[inline(always)]\n-    fn log_2() -> float { 0.693147180559945309417232121458176568 }\n+    fn exp(&self) -> float {\n+        (*self as f64).exp() as float\n+    }\n \n-    /// log(10.0)\n     #[inline(always)]\n-    fn log_10() -> float { 2.30258509299404568401799145468436421 }\n+    fn exp2(&self) -> float {\n+        (*self as f64).exp2() as float\n+    }\n \n     #[inline(always)]\n-    fn pow(&self, n: float) -> float { pow(*self as f64, n as f64) as float }\n+    fn expm1(&self) -> float {\n+        (*self as f64).expm1() as float\n+    }\n \n     #[inline(always)]\n-    fn exp(&self) -> float { exp(*self as f64) as float }\n+    fn log(&self) -> float {\n+        (*self as f64).log() as float\n+    }\n \n     #[inline(always)]\n-    fn exp2(&self) -> float { exp2(*self as f64) as float }\n+    fn log2(&self) -> float {\n+        (*self as f64).log2() as float\n+    }\n \n     #[inline(always)]\n-    fn expm1(&self) -> float { expm1(*self as f64) as float }\n+    fn log10(&self) -> float {\n+        (*self as f64).log10() as float\n+    }\n+}\n \n+impl Hyperbolic for float {\n     #[inline(always)]\n-    fn ldexp(&self, n: int) -> float { ldexp(*self as f64, n as c_int) as float }\n+    fn sinh(&self) -> float {\n+        (*self as f64).sinh() as float\n+    }\n \n     #[inline(always)]\n-    fn log(&self) -> float { ln(*self as f64) as float }\n+    fn cosh(&self) -> float {\n+        (*self as f64).cosh() as float\n+    }\n \n     #[inline(always)]\n-    fn log2(&self) -> float { log2(*self as f64) as float }\n+    fn tanh(&self) -> float {\n+        (*self as f64).tanh() as float\n+    }\n+}\n \n+impl Real for float {\n+    /// Archimedes' constant\n     #[inline(always)]\n-    fn log10(&self) -> float { log10(*self as f64) as float }\n+    fn pi() -> float { 3.14159265358979323846264338327950288 }\n \n+    /// 2.0 * pi\n     #[inline(always)]\n-    fn log_radix(&self) -> float { log_radix(*self as f64) as float }\n+    fn two_pi() -> float { 6.28318530717958647692528676655900576 }\n \n+    /// pi / 2.0\n     #[inline(always)]\n-    fn ilog_radix(&self) -> int { ilog_radix(*self as f64) as int }\n+    fn frac_pi_2() -> float { 1.57079632679489661923132169163975144 }\n \n+    /// pi / 3.0\n     #[inline(always)]\n-    fn sqrt(&self) -> float { sqrt(*self) }\n+    fn frac_pi_3() -> float { 1.04719755119659774615421446109316763 }\n \n+    /// pi / 4.0\n     #[inline(always)]\n-    fn rsqrt(&self) -> float { self.sqrt().recip() }\n+    fn frac_pi_4() -> float { 0.785398163397448309615660845819875721 }\n \n+    /// pi / 6.0\n     #[inline(always)]\n-    fn cbrt(&self) -> float { cbrt(*self as f64) as float }\n+    fn frac_pi_6() -> float { 0.52359877559829887307710723054658381 }\n \n-    /// Converts to degrees, assuming the number is in radians\n+    /// pi / 8.0\n     #[inline(always)]\n-    fn to_degrees(&self) -> float { *self * (180.0 / Real::pi::<float>()) }\n+    fn frac_pi_8() -> float { 0.39269908169872415480783042290993786 }\n \n-    /// Converts to radians, assuming the number is in degrees\n+    /// 1.0 / pi\n     #[inline(always)]\n-    fn to_radians(&self) -> float { *self * (Real::pi::<float>() / 180.0) }\n+    fn frac_1_pi() -> float { 0.318309886183790671537767526745028724 }\n \n+    /// 2.0 / pi\n     #[inline(always)]\n-    fn hypot(&self, other: float) -> float { hypot(*self as f64, other as f64) as float }\n+    fn frac_2_pi() -> float { 0.636619772367581343075535053490057448 }\n \n+    /// 2 .0/ sqrt(pi)\n     #[inline(always)]\n-    fn sin(&self) -> float { sin(*self) }\n+    fn frac_2_sqrtpi() -> float { 1.12837916709551257389615890312154517 }\n \n+    /// sqrt(2.0)\n     #[inline(always)]\n-    fn cos(&self) -> float { cos(*self) }\n+    fn sqrt2() -> float { 1.41421356237309504880168872420969808 }\n \n+    /// 1.0 / sqrt(2.0)\n     #[inline(always)]\n-    fn tan(&self) -> float { tan(*self) }\n+    fn frac_1_sqrt2() -> float { 0.707106781186547524400844362104849039 }\n \n+    /// Euler's number\n     #[inline(always)]\n-    fn asin(&self) -> float { asin(*self as f64) as float }\n+    fn e() -> float { 2.71828182845904523536028747135266250 }\n \n+    /// log2(e)\n     #[inline(always)]\n-    fn acos(&self) -> float { acos(*self as f64) as float }\n+    fn log2_e() -> float { 1.44269504088896340735992468100189214 }\n \n+    /// log10(e)\n     #[inline(always)]\n-    fn atan(&self) -> float { atan(*self) }\n+    fn log10_e() -> float { 0.434294481903251827651128918916605082 }\n \n+    /// log(2.0)\n     #[inline(always)]\n-    fn atan2(&self, other: float) -> float { atan2(*self as f64, other as f64) as float }\n+    fn log_2() -> float { 0.693147180559945309417232121458176568 }\n \n+    /// log(10.0)\n     #[inline(always)]\n-    fn sinh(&self) -> float { sinh(*self as f64) as float }\n+    fn log_10() -> float { 2.30258509299404568401799145468436421 }\n \n+    /// Converts to degrees, assuming the number is in radians\n     #[inline(always)]\n-    fn cosh(&self) -> float { cosh(*self as f64) as float }\n+    fn to_degrees(&self) -> float { (*self as f64).to_degrees() as float }\n \n+    /// Converts to radians, assuming the number is in degrees\n     #[inline(always)]\n-    fn tanh(&self) -> float { tanh(*self as f64) as float }\n+    fn to_radians(&self) -> float { (*self as f64).to_radians() as float }\n }\n \n impl RealExt for float {"}, {"sha": "ec38a32c039d6d9d142913e34869783383229e46", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -406,11 +406,11 @@ impl Integer for T {\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n     #[inline(always)]\n-    fn divisible_by(&self, other: &T) -> bool { *self % *other == 0 }\n+    fn is_multiple_of(&self, other: &T) -> bool { *self % *other == 0 }\n \n     /// Returns `true` if the number is divisible by `2`\n     #[inline(always)]\n-    fn is_even(&self) -> bool { self.divisible_by(&2) }\n+    fn is_even(&self) -> bool { self.is_multiple_of(&2) }\n \n     /// Returns `true` if the number is not divisible by `2`\n     #[inline(always)]\n@@ -682,6 +682,42 @@ mod tests {\n         assert_eq!(-(0b11 as T) - (1 as T), (0b11 as T).not());\n     }\n \n+    #[test]\n+    fn test_multiple_of() {\n+        assert!((6 as T).is_multiple_of(&(6 as T)));\n+        assert!((6 as T).is_multiple_of(&(3 as T)));\n+        assert!((6 as T).is_multiple_of(&(1 as T)));\n+        assert!((-8 as T).is_multiple_of(&(4 as T)));\n+        assert!((8 as T).is_multiple_of(&(-1 as T)));\n+        assert!((-8 as T).is_multiple_of(&(-2 as T)));\n+    }\n+\n+    #[test]\n+    fn test_even() {\n+        assert_eq!((-4 as T).is_even(), true);\n+        assert_eq!((-3 as T).is_even(), false);\n+        assert_eq!((-2 as T).is_even(), true);\n+        assert_eq!((-1 as T).is_even(), false);\n+        assert_eq!((0 as T).is_even(), true);\n+        assert_eq!((1 as T).is_even(), false);\n+        assert_eq!((2 as T).is_even(), true);\n+        assert_eq!((3 as T).is_even(), false);\n+        assert_eq!((4 as T).is_even(), true);\n+    }\n+\n+    #[test]\n+    fn test_odd() {\n+        assert_eq!((-4 as T).is_odd(), false);\n+        assert_eq!((-3 as T).is_odd(), true);\n+        assert_eq!((-2 as T).is_odd(), false);\n+        assert_eq!((-1 as T).is_odd(), true);\n+        assert_eq!((0 as T).is_odd(), false);\n+        assert_eq!((1 as T).is_odd(), true);\n+        assert_eq!((2 as T).is_odd(), false);\n+        assert_eq!((3 as T).is_odd(), true);\n+        assert_eq!((4 as T).is_odd(), false);\n+    }\n+\n     #[test]\n     fn test_bitcount() {\n         assert_eq!((0b010101 as T).population_count(), 3);"}, {"sha": "3e43ebfef12228152ba43c8a5eb09a24cabba120", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -85,7 +85,8 @@ pub trait Integer: Num\n \n     fn gcd(&self, other: &Self) -> Self;\n     fn lcm(&self, other: &Self) -> Self;\n-    fn divisible_by(&self, other: &Self) -> bool;\n+\n+    fn is_multiple_of(&self, other: &Self) -> bool;\n     fn is_even(&self) -> bool;\n     fn is_odd(&self) -> bool;\n }\n@@ -105,14 +106,47 @@ pub trait Fractional: Num\n     fn recip(&self) -> Self;\n }\n \n+pub trait Algebraic {\n+    fn pow(&self, n: Self) -> Self;\n+    fn sqrt(&self) -> Self;\n+    fn rsqrt(&self) -> Self;\n+    fn cbrt(&self) -> Self;\n+    fn hypot(&self, other: Self) -> Self;\n+}\n+\n+pub trait Trigonometric {\n+    fn sin(&self) -> Self;\n+    fn cos(&self) -> Self;\n+    fn tan(&self) -> Self;\n+    fn asin(&self) -> Self;\n+    fn acos(&self) -> Self;\n+    fn atan(&self) -> Self;\n+    fn atan2(&self, other: Self) -> Self;\n+}\n+\n+pub trait Exponential {\n+    fn exp(&self) -> Self;\n+    fn exp2(&self) -> Self;\n+    fn expm1(&self) -> Self;\n+    fn log(&self) -> Self;\n+    fn log2(&self) -> Self;\n+    fn log10(&self) -> Self;\n+}\n+\n+pub trait Hyperbolic: Exponential {\n+    fn sinh(&self) -> Self;\n+    fn cosh(&self) -> Self;\n+    fn tanh(&self) -> Self;\n+}\n+\n ///\n /// Defines constants and methods common to real numbers\n ///\n pub trait Real: Signed\n-              + Fractional {\n-    // FIXME (#5527): usages of `int` should be replaced with an associated\n-    // integer type once these are implemented\n-\n+              + Fractional\n+              + Algebraic\n+              + Trigonometric\n+              + Hyperbolic {\n     // Common Constants\n     // FIXME (#5527): These should be associated constants\n     fn pi() -> Self;\n@@ -133,41 +167,9 @@ pub trait Real: Signed\n     fn log_2() -> Self;\n     fn log_10() -> Self;\n \n-    // Exponential functions\n-    fn pow(&self, n: Self) -> Self;\n-    fn exp(&self) -> Self;\n-    fn exp2(&self) -> Self;\n-    fn expm1(&self) -> Self;\n-    fn ldexp(&self, n: int) -> Self;\n-    fn log(&self) -> Self;\n-    fn log2(&self) -> Self;\n-    fn log10(&self) -> Self;\n-    fn log_radix(&self) -> Self;\n-    fn ilog_radix(&self) -> int;\n-    fn sqrt(&self) -> Self;\n-    fn rsqrt(&self) -> Self;\n-    fn cbrt(&self) -> Self;\n-\n     // Angular conversions\n     fn to_degrees(&self) -> Self;\n     fn to_radians(&self) -> Self;\n-\n-    // Triganomic functions\n-    fn hypot(&self, other: Self) -> Self;\n-    fn sin(&self) -> Self;\n-    fn cos(&self) -> Self;\n-    fn tan(&self) -> Self;\n-\n-    // Inverse triganomic functions\n-    fn asin(&self) -> Self;\n-    fn acos(&self) -> Self;\n-    fn atan(&self) -> Self;\n-    fn atan2(&self, other: Self) -> Self;\n-\n-    // Hyperbolic triganomic functions\n-    fn sinh(&self) -> Self;\n-    fn cosh(&self) -> Self;\n-    fn tanh(&self) -> Self;\n }\n \n ///"}, {"sha": "3dfdd22c42dc1996a993865626a555fba5c52516", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -238,11 +238,11 @@ impl Integer for T {\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n     #[inline(always)]\n-    fn divisible_by(&self, other: &T) -> bool { *self % *other == 0 }\n+    fn is_multiple_of(&self, other: &T) -> bool { *self % *other == 0 }\n \n     /// Returns `true` if the number is divisible by `2`\n     #[inline(always)]\n-    fn is_even(&self) -> bool { self.divisible_by(&2) }\n+    fn is_even(&self) -> bool { self.is_multiple_of(&2) }\n \n     /// Returns `true` if the number is not divisible by `2`\n     #[inline(always)]\n@@ -415,6 +415,31 @@ mod tests {\n         assert_eq!((99 as T).lcm(&17), 1683 as T);\n     }\n \n+    #[test]\n+    fn test_multiple_of() {\n+        assert!((6 as T).is_multiple_of(&(6 as T)));\n+        assert!((6 as T).is_multiple_of(&(3 as T)));\n+        assert!((6 as T).is_multiple_of(&(1 as T)));\n+    }\n+\n+    #[test]\n+    fn test_even() {\n+        assert_eq!((0 as T).is_even(), true);\n+        assert_eq!((1 as T).is_even(), false);\n+        assert_eq!((2 as T).is_even(), true);\n+        assert_eq!((3 as T).is_even(), false);\n+        assert_eq!((4 as T).is_even(), true);\n+    }\n+\n+    #[test]\n+    fn test_odd() {\n+        assert_eq!((0 as T).is_odd(), false);\n+        assert_eq!((1 as T).is_odd(), true);\n+        assert_eq!((2 as T).is_odd(), false);\n+        assert_eq!((3 as T).is_odd(), true);\n+        assert_eq!((4 as T).is_odd(), false);\n+    }\n+\n     #[test]\n     fn test_bitwise() {\n         assert_eq!(0b1110 as T, (0b1100 as T).bitor(&(0b1010 as T)));"}, {"sha": "9a2e480ce6e543b5e6703e38363c838676ca1a1f", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -39,8 +39,9 @@ pub use old_iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n pub use old_iter::{ExtendedMutableIter};\n pub use iter::Times;\n pub use num::{Num, NumCast};\n-pub use num::{Orderable, Signed, Unsigned, Integer};\n-pub use num::{Round, Fractional, Real, RealExt};\n+pub use num::{Orderable, Signed, Unsigned, Round};\n+pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};\n+pub use num::{Integer, Fractional, Real, RealExt};\n pub use num::{Bitwise, BitCount, Bounded};\n pub use num::{Primitive, Int, Float};\n pub use path::GenericPath;"}, {"sha": "e97b3b5eeec48af4426b36ae3f27e4a5da11a465", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -428,7 +428,7 @@ impl Integer for BigUint {\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n     #[inline(always)]\n-    fn divisible_by(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }\n+    fn is_multiple_of(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }\n \n     /// Returns `true` if the number is divisible by `2`\n     #[inline(always)]\n@@ -973,7 +973,7 @@ impl Integer for BigInt {\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n     #[inline(always)]\n-    fn divisible_by(&self, other: &BigInt) -> bool { self.data.divisible_by(&other.data) }\n+    fn is_multiple_of(&self, other: &BigInt) -> bool { self.data.is_multiple_of(&other.data) }\n \n     /// Returns `true` if the number is divisible by `2`\n     #[inline(always)]"}, {"sha": "a7c170c1cd6da20ffa6d2a7884274a24b21a484d", "filename": "src/libstd/num/rational.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibstd%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Flibstd%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Frational.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -203,6 +203,9 @@ impl<T: Copy + Num + Ord>\n     }\n }\n \n+impl<T: Copy + Num + Ord>\n+    Num for Ratio<T> {}\n+\n /* Utils */\n impl<T: Copy + Num + Ord>\n     Round for Ratio<T> {\n@@ -242,6 +245,12 @@ impl<T: Copy + Num + Ord>\n     }\n }\n \n+impl<T: Copy + Num + Ord> Fractional for Ratio<T> {\n+    #[inline]\n+    fn recip(&self) -> Ratio<T> {\n+        Ratio::new_raw(self.denom, self.numer)\n+    }\n+}\n \n /* String conversions */\n impl<T: ToStr> ToStr for Ratio<T> {\n@@ -446,6 +455,15 @@ mod test {\n         assert_eq!(_3_2.fract(), _1_2);\n     }\n \n+    #[test]\n+    fn test_recip() {\n+        assert_eq!(_1 * _1.recip(), _1);\n+        assert_eq!(_2 * _2.recip(), _1);\n+        assert_eq!(_1_2 * _1_2.recip(), _1);\n+        assert_eq!(_3_2 * _3_2.recip(), _1);\n+        assert_eq!(_neg1_2 * _neg1_2.recip(), _1);\n+    }\n+\n     #[test]\n     fn test_to_from_str() {\n         fn test(r: Rational, s: ~str) {"}]}