{"sha": "8ac25f119eb45d425370d9f7f093bc206e6c4a9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYzI1ZjExOWViNDVkNDI1MzcwZDlmN2YwOTNiYzIwNmU2YzRhOWY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-25T14:00:10Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-26T15:23:40Z"}, "message": "Keep track of visibility during def collection", "tree": {"sha": "7a9bcbcb2c46a549baa7a411a99cd7c9eb39423d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a9bcbcb2c46a549baa7a411a99cd7c9eb39423d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ac25f119eb45d425370d9f7f093bc206e6c4a9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac25f119eb45d425370d9f7f093bc206e6c4a9f", "html_url": "https://github.com/rust-lang/rust/commit/8ac25f119eb45d425370d9f7f093bc206e6c4a9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79c90b5641d2934864c587380e4f050ab63ac029", "url": "https://api.github.com/repos/rust-lang/rust/commits/79c90b5641d2934864c587380e4f050ab63ac029", "html_url": "https://github.com/rust-lang/rust/commit/79c90b5641d2934864c587380e4f050ab63ac029"}], "stats": {"total": 174, "additions": 120, "deletions": 54}, "files": [{"sha": "88c4a121689b9504137182f1fe02d4881a00f12f", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=8ac25f119eb45d425370d9f7f093bc206e6c4a9f", "patch": "@@ -543,7 +543,10 @@ where\n             };\n             self.body.item_scope.define_def(def);\n             if let Some(name) = name {\n-                self.body.item_scope.push_res(name.as_name(), def.into());\n+                let vis = crate::visibility::ResolvedVisibility::Public; // FIXME determine correctly\n+                self.body\n+                    .item_scope\n+                    .push_res(name.as_name(), crate::per_ns::PerNs::from_def(def, vis));\n             }\n         }\n     }"}, {"sha": "d77f37f67081ced032726c27204da09f7466a989", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=8ac25f119eb45d425370d9f7f093bc206e6c4a9f", "patch": "@@ -5,7 +5,10 @@ use hir_expand::name::Name;\n use once_cell::sync::Lazy;\n use rustc_hash::FxHashMap;\n \n-use crate::{per_ns::PerNs, AdtId, BuiltinType, ImplId, MacroDefId, ModuleDefId, TraitId};\n+use crate::{\n+    per_ns::PerNs, visibility::ResolvedVisibility, AdtId, BuiltinType, ImplId, MacroDefId,\n+    ModuleDefId, TraitId,\n+};\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ItemScope {\n@@ -30,7 +33,9 @@ pub struct ItemScope {\n static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n     BuiltinType::ALL\n         .iter()\n-        .map(|(name, ty)| (name.clone(), PerNs::types(ty.clone().into())))\n+        .map(|(name, ty)| {\n+            (name.clone(), PerNs::types(ty.clone().into(), ResolvedVisibility::Public))\n+        })\n         .collect()\n });\n \n@@ -144,29 +149,37 @@ impl ItemScope {\n         changed\n     }\n \n+    #[cfg(test)]\n     pub(crate) fn collect_resolutions(&self) -> Vec<(Name, PerNs)> {\n         self.visible.iter().map(|(name, res)| (name.clone(), res.clone())).collect()\n     }\n \n+    pub(crate) fn collect_resolutions_with_vis(\n+        &self,\n+        vis: ResolvedVisibility,\n+    ) -> Vec<(Name, PerNs)> {\n+        self.visible.iter().map(|(name, res)| (name.clone(), res.with_visibility(vis))).collect()\n+    }\n+\n     pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroDefId> {\n         self.legacy_macros.clone()\n     }\n }\n \n-impl From<ModuleDefId> for PerNs {\n-    fn from(def: ModuleDefId) -> PerNs {\n+impl PerNs {\n+    pub(crate) fn from_def(def: ModuleDefId, v: ResolvedVisibility) -> PerNs {\n         match def {\n-            ModuleDefId::ModuleId(_) => PerNs::types(def),\n-            ModuleDefId::FunctionId(_) => PerNs::values(def),\n+            ModuleDefId::ModuleId(_) => PerNs::types(def, v),\n+            ModuleDefId::FunctionId(_) => PerNs::values(def, v),\n             ModuleDefId::AdtId(adt) => match adt {\n-                AdtId::StructId(_) | AdtId::UnionId(_) => PerNs::both(def, def),\n-                AdtId::EnumId(_) => PerNs::types(def),\n+                AdtId::StructId(_) | AdtId::UnionId(_) => PerNs::both(def, def, v),\n+                AdtId::EnumId(_) => PerNs::types(def, v),\n             },\n-            ModuleDefId::EnumVariantId(_) => PerNs::both(def, def),\n-            ModuleDefId::ConstId(_) | ModuleDefId::StaticId(_) => PerNs::values(def),\n-            ModuleDefId::TraitId(_) => PerNs::types(def),\n-            ModuleDefId::TypeAliasId(_) => PerNs::types(def),\n-            ModuleDefId::BuiltinType(_) => PerNs::types(def),\n+            ModuleDefId::EnumVariantId(_) => PerNs::both(def, def, v),\n+            ModuleDefId::ConstId(_) | ModuleDefId::StaticId(_) => PerNs::values(def, v),\n+            ModuleDefId::TraitId(_) => PerNs::types(def, v),\n+            ModuleDefId::TypeAliasId(_) => PerNs::types(def, v),\n+            ModuleDefId::BuiltinType(_) => PerNs::types(def, v),\n         }\n     }\n }"}, {"sha": "5b84780373fa0836ce6834cc53ed176a3827f5e9", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=8ac25f119eb45d425370d9f7f093bc206e6c4a9f", "patch": "@@ -24,6 +24,7 @@ use crate::{\n     },\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n+    visibility::ResolvedVisibility,\n     AdtId, AstId, ConstLoc, ContainerId, EnumLoc, EnumVariantId, FunctionLoc, ImplLoc, Intern,\n     LocalModuleId, ModuleDefId, ModuleId, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n };\n@@ -214,7 +215,10 @@ where\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n         // crate root, even if the parent modules is **not** visible.\n         if export {\n-            self.update(self.def_map.root, &[(name, PerNs::macros(macro_))]);\n+            self.update(\n+                self.def_map.root,\n+                &[(name, PerNs::macros(macro_, ResolvedVisibility::Public))],\n+            );\n         }\n     }\n \n@@ -351,6 +355,10 @@ where\n         let import_id = directive.import_id;\n         let import = &directive.import;\n         let def = directive.status.namespaces();\n+        let vis = self\n+            .def_map\n+            .resolve_visibility(self.db, module_id, &directive.import.visibility)\n+            .unwrap_or(ResolvedVisibility::Public);\n \n         if import.is_glob {\n             log::debug!(\"glob import: {:?}\", import);\n@@ -365,8 +373,10 @@ where\n                         let item_map = self.db.crate_def_map(m.krate);\n                         let scope = &item_map[m.local_id].scope;\n \n+                        // TODO: only use names we can see\n+\n                         // Module scoped macros is included\n-                        let items = scope.collect_resolutions();\n+                        let items = scope.collect_resolutions_with_vis(vis);\n \n                         self.update(module_id, &items);\n                     } else {\n@@ -375,8 +385,10 @@ where\n                         // additions\n                         let scope = &self.def_map[m.local_id].scope;\n \n+                        // TODO: only use names we can see\n+\n                         // Module scoped macros is included\n-                        let items = scope.collect_resolutions();\n+                        let items = scope.collect_resolutions_with_vis(vis);\n \n                         self.update(module_id, &items);\n                         // record the glob import in case we add further items\n@@ -396,7 +408,7 @@ where\n                         .map(|(local_id, variant_data)| {\n                             let name = variant_data.name.clone();\n                             let variant = EnumVariantId { parent: e, local_id };\n-                            let res = PerNs::both(variant.into(), variant.into());\n+                            let res = PerNs::both(variant.into(), variant.into(), vis);\n                             (name, res)\n                         })\n                         .collect::<Vec<_>>();\n@@ -422,7 +434,7 @@ where\n                         }\n                     }\n \n-                    self.update(module_id, &[(name, def)]);\n+                    self.update(module_id, &[(name, def.with_visibility(vis))]);\n                 }\n                 None => tested_by!(bogus_paths),\n             }\n@@ -701,8 +713,9 @@ where\n         modules[self.module_id].children.insert(name.clone(), res);\n         let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: res };\n         let def: ModuleDefId = module.into();\n+        let vis = ResolvedVisibility::Public; // TODO handle module visibility\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n-        self.def_collector.update(self.module_id, &[(name, def.into())]);\n+        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis))]);\n         res\n     }\n \n@@ -716,6 +729,7 @@ where\n \n         let name = def.name.clone();\n         let container = ContainerId::ModuleId(module);\n+        let vis = &def.visibility;\n         let def: ModuleDefId = match def.kind {\n             raw::DefKind::Function(ast_id) => FunctionLoc {\n                 container: container.into(),\n@@ -761,7 +775,12 @@ where\n             .into(),\n         };\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n-        self.def_collector.update(self.module_id, &[(name, def.into())])\n+        let vis = self\n+            .def_collector\n+            .def_map\n+            .resolve_visibility(self.def_collector.db, self.module_id, vis)\n+            .unwrap_or(ResolvedVisibility::Public);\n+        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis))])\n     }\n \n     fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {"}, {"sha": "a56e3f08bb899d53f752382feda9427c1f886755", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=8ac25f119eb45d425370d9f7f093bc206e6c4a9f", "patch": "@@ -62,7 +62,9 @@ impl ResolvePathResult {\n \n impl CrateDefMap {\n     pub(super) fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs {\n-        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n+        self.extern_prelude\n+            .get(name)\n+            .map_or(PerNs::none(), |&it| PerNs::types(it, ResolvedVisibility::Public))\n     }\n \n     pub(crate) fn resolve_visibility(\n@@ -115,17 +117,21 @@ impl CrateDefMap {\n             PathKind::DollarCrate(krate) => {\n                 if krate == self.krate {\n                     tested_by!(macro_dollar_crate_self);\n-                    PerNs::types(ModuleId { krate: self.krate, local_id: self.root }.into())\n+                    PerNs::types(\n+                        ModuleId { krate: self.krate, local_id: self.root }.into(),\n+                        ResolvedVisibility::Public,\n+                    )\n                 } else {\n                     let def_map = db.crate_def_map(krate);\n                     let module = ModuleId { krate, local_id: def_map.root };\n                     tested_by!(macro_dollar_crate_other);\n-                    PerNs::types(module.into())\n+                    PerNs::types(module.into(), ResolvedVisibility::Public)\n                 }\n             }\n-            PathKind::Crate => {\n-                PerNs::types(ModuleId { krate: self.krate, local_id: self.root }.into())\n-            }\n+            PathKind::Crate => PerNs::types(\n+                ModuleId { krate: self.krate, local_id: self.root }.into(),\n+                ResolvedVisibility::Public,\n+            ),\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n             // rust-lang/rust#57745)\n@@ -153,7 +159,10 @@ impl CrateDefMap {\n                 let m = successors(Some(original_module), |m| self.modules[*m].parent)\n                     .nth(lvl as usize);\n                 if let Some(local_id) = m {\n-                    PerNs::types(ModuleId { krate: self.krate, local_id }.into())\n+                    PerNs::types(\n+                        ModuleId { krate: self.krate, local_id }.into(),\n+                        ResolvedVisibility::Public,\n+                    )\n                 } else {\n                     log::debug!(\"super path in root module\");\n                     return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n@@ -167,15 +176,15 @@ impl CrateDefMap {\n                 };\n                 if let Some(def) = self.extern_prelude.get(&segment) {\n                     log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    PerNs::types(*def)\n+                    PerNs::types(*def, ResolvedVisibility::Public)\n                 } else {\n                     return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n             }\n         };\n \n         for (i, segment) in segments {\n-            let curr = match curr_per_ns.take_types() {\n+            let (curr, vis) = match curr_per_ns.take_types_vis() {\n                 Some(r) => r,\n                 None => {\n                     // we still have path segments left, but the path so far\n@@ -216,11 +225,11 @@ impl CrateDefMap {\n                     match enum_data.variant(&segment) {\n                         Some(local_id) => {\n                             let variant = EnumVariantId { parent: e, local_id };\n-                            PerNs::both(variant.into(), variant.into())\n+                            PerNs::both(variant.into(), variant.into(), ResolvedVisibility::Public)\n                         }\n                         None => {\n                             return ResolvePathResult::with(\n-                                PerNs::types(e.into()),\n+                                PerNs::types(e.into(), vis),\n                                 ReachedFixedPoint::Yes,\n                                 Some(i),\n                                 Some(self.krate),\n@@ -238,7 +247,7 @@ impl CrateDefMap {\n                     );\n \n                     return ResolvePathResult::with(\n-                        PerNs::types(s),\n+                        PerNs::types(s, vis),\n                         ReachedFixedPoint::Yes,\n                         Some(i),\n                         Some(self.krate),\n@@ -262,11 +271,15 @@ impl CrateDefMap {\n         //  - current module / scope\n         //  - extern prelude\n         //  - std prelude\n-        let from_legacy_macro =\n-            self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n+        let from_legacy_macro = self[module]\n+            .scope\n+            .get_legacy_macro(name)\n+            .map_or_else(PerNs::none, |m| PerNs::macros(m, ResolvedVisibility::Public));\n         let from_scope = self[module].scope.get(name, shadow);\n-        let from_extern_prelude =\n-            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n+        let from_extern_prelude = self\n+            .extern_prelude\n+            .get(name)\n+            .map_or(PerNs::none(), |&it| PerNs::types(it, ResolvedVisibility::Public));\n         let from_prelude = self.resolve_in_prelude(db, name, shadow);\n \n         from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)"}, {"sha": "16e61a6a58f37e2364d2e1d7131005baf33947ab", "filename": "crates/ra_hir_def/src/per_ns.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs?ref=8ac25f119eb45d425370d9f7f093bc206e6c4a9f", "patch": "@@ -5,13 +5,13 @@\n \n use hir_expand::MacroDefId;\n \n-use crate::ModuleDefId;\n+use crate::{visibility::ResolvedVisibility, ModuleDefId};\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub struct PerNs {\n-    pub types: Option<ModuleDefId>,\n-    pub values: Option<ModuleDefId>,\n-    pub macros: Option<MacroDefId>,\n+    pub types: Option<(ModuleDefId, ResolvedVisibility)>,\n+    pub values: Option<(ModuleDefId, ResolvedVisibility)>,\n+    pub macros: Option<(MacroDefId, ResolvedVisibility)>,\n }\n \n impl Default for PerNs {\n@@ -25,36 +25,48 @@ impl PerNs {\n         PerNs { types: None, values: None, macros: None }\n     }\n \n-    pub fn values(t: ModuleDefId) -> PerNs {\n-        PerNs { types: None, values: Some(t), macros: None }\n+    pub fn values(t: ModuleDefId, v: ResolvedVisibility) -> PerNs {\n+        PerNs { types: None, values: Some((t, v)), macros: None }\n     }\n \n-    pub fn types(t: ModuleDefId) -> PerNs {\n-        PerNs { types: Some(t), values: None, macros: None }\n+    pub fn types(t: ModuleDefId, v: ResolvedVisibility) -> PerNs {\n+        PerNs { types: Some((t, v)), values: None, macros: None }\n     }\n \n-    pub fn both(types: ModuleDefId, values: ModuleDefId) -> PerNs {\n-        PerNs { types: Some(types), values: Some(values), macros: None }\n+    pub fn both(types: ModuleDefId, values: ModuleDefId, v: ResolvedVisibility) -> PerNs {\n+        PerNs { types: Some((types, v)), values: Some((values, v)), macros: None }\n     }\n \n-    pub fn macros(macro_: MacroDefId) -> PerNs {\n-        PerNs { types: None, values: None, macros: Some(macro_) }\n+    pub fn macros(macro_: MacroDefId, v: ResolvedVisibility) -> PerNs {\n+        PerNs { types: None, values: None, macros: Some((macro_, v)) }\n     }\n \n     pub fn is_none(&self) -> bool {\n         self.types.is_none() && self.values.is_none() && self.macros.is_none()\n     }\n \n     pub fn take_types(self) -> Option<ModuleDefId> {\n+        self.types.map(|it| it.0)\n+    }\n+\n+    pub fn take_types_vis(self) -> Option<(ModuleDefId, ResolvedVisibility)> {\n         self.types\n     }\n \n     pub fn take_values(self) -> Option<ModuleDefId> {\n-        self.values\n+        self.values.map(|it| it.0)\n     }\n \n     pub fn take_macros(self) -> Option<MacroDefId> {\n-        self.macros\n+        self.macros.map(|it| it.0)\n+    }\n+\n+    pub fn with_visibility(self, vis: ResolvedVisibility) -> PerNs {\n+        PerNs {\n+            types: self.types.map(|(it, _)| (it, vis)),\n+            values: self.values.map(|(it, _)| (it, vis)),\n+            macros: self.macros.map(|(it, _)| (it, vis)),\n+        }\n     }\n \n     pub fn or(self, other: PerNs) -> PerNs {"}, {"sha": "950bf6c79a1d34697319cdc7af03bdfd3647fe80", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac25f119eb45d425370d9f7f093bc206e6c4a9f/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=8ac25f119eb45d425370d9f7f093bc206e6c4a9f", "patch": "@@ -466,10 +466,16 @@ impl Scope {\n                     f(name.clone(), ScopeDef::PerNs(def));\n                 });\n                 m.crate_def_map[m.module_id].scope.legacy_macros().for_each(|(name, macro_)| {\n-                    f(name.clone(), ScopeDef::PerNs(PerNs::macros(macro_)));\n+                    f(\n+                        name.clone(),\n+                        ScopeDef::PerNs(PerNs::macros(macro_, ResolvedVisibility::Public)),\n+                    );\n                 });\n                 m.crate_def_map.extern_prelude.iter().for_each(|(name, &def)| {\n-                    f(name.clone(), ScopeDef::PerNs(PerNs::types(def.into())));\n+                    f(\n+                        name.clone(),\n+                        ScopeDef::PerNs(PerNs::types(def.into(), ResolvedVisibility::Public)),\n+                    );\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);"}]}