{"sha": "ccb4e8423e50fef0f13a642715c3e617ee9f78fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYjRlODQyM2U1MGZlZjBmMTNhNjQyNzE1YzNlNjE3ZWU5Zjc4ZmU=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-03-29T01:47:29Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-03-29T05:32:08Z"}, "message": "Fix massive performance issue in read_to_end\n\nwith_end_to_cap is enormously expensive now that it's initializing\nmemory since it involves 64k allocation + memset on every call. This is\nmost noticable when calling read_to_end on very small readers, where the\nnew version if **4 orders of magnitude** faster.\n\nBufReader also depended on with_end_to_cap so I've rewritten it in its\noriginal form.\n\nAs a bonus, converted the buffered IO struct Debug impls to use the\ndebug builders.\n\nFixes #23815", "tree": {"sha": "41b8423da7c42def2bffba2fc14402d8f4df3afe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41b8423da7c42def2bffba2fc14402d8f4df3afe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccb4e8423e50fef0f13a642715c3e617ee9f78fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccb4e8423e50fef0f13a642715c3e617ee9f78fe", "html_url": "https://github.com/rust-lang/rust/commit/ccb4e8423e50fef0f13a642715c3e617ee9f78fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccb4e8423e50fef0f13a642715c3e617ee9f78fe/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e7385aae9d58c8e12137d7c07aad48551048c13", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e7385aae9d58c8e12137d7c07aad48551048c13", "html_url": "https://github.com/rust-lang/rust/commit/3e7385aae9d58c8e12137d7c07aad48551048c13"}], "stats": {"total": 136, "additions": 77, "deletions": 59}, "files": [{"sha": "98581fc43f89e978584db5a707d05aad051ac6f8", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ccb4e8423e50fef0f13a642715c3e617ee9f78fe/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb4e8423e50fef0f13a642715c3e617ee9f78fe/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=ccb4e8423e50fef0f13a642715c3e617ee9f78fe", "patch": "@@ -18,8 +18,9 @@ use io::prelude::*;\n use cmp;\n use error::{self, FromError};\n use fmt;\n-use io::{self, Cursor, DEFAULT_BUF_SIZE, Error, ErrorKind};\n+use io::{self, DEFAULT_BUF_SIZE, Error, ErrorKind};\n use ptr;\n+use iter;\n \n /// Wraps a `Read` and buffers input from it\n ///\n@@ -30,7 +31,9 @@ use ptr;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufReader<R> {\n     inner: R,\n-    buf: Cursor<Vec<u8>>,\n+    buf: Vec<u8>,\n+    pos: usize,\n+    cap: usize,\n }\n \n impl<R: Read> BufReader<R> {\n@@ -43,9 +46,13 @@ impl<R: Read> BufReader<R> {\n     /// Creates a new `BufReader` with the specified buffer capacity\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(cap: usize, inner: R) -> BufReader<R> {\n+        let mut buf = Vec::with_capacity(cap);\n+        buf.extend(iter::repeat(0).take(cap));\n         BufReader {\n             inner: inner,\n-            buf: Cursor::new(Vec::with_capacity(cap)),\n+            buf: buf,\n+            pos: 0,\n+            cap: 0,\n         }\n     }\n \n@@ -74,12 +81,15 @@ impl<R: Read> Read for BufReader<R> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n         // entirely.\n-        if self.buf.get_ref().len() == self.buf.position() as usize &&\n-            buf.len() >= self.buf.get_ref().capacity() {\n+        if self.pos == self.cap && buf.len() >= self.buf.len() {\n             return self.inner.read(buf);\n         }\n-        try!(self.fill_buf());\n-        self.buf.read(buf)\n+        let nread = {\n+            let mut rem = try!(self.fill_buf());\n+            try!(rem.read(buf))\n+        };\n+        self.consume(nread);\n+        Ok(nread)\n     }\n }\n \n@@ -88,26 +98,25 @@ impl<R: Read> BufRead for BufReader<R> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> {\n         // If we've reached the end of our internal buffer then we need to fetch\n         // some more data from the underlying reader.\n-        if self.buf.position() as usize == self.buf.get_ref().len() {\n-            self.buf.set_position(0);\n-            let v = self.buf.get_mut();\n-            v.truncate(0);\n-            let inner = &mut self.inner;\n-            try!(super::with_end_to_cap(v, |b| inner.read(b)));\n+        if self.pos == self.cap {\n+            self.cap = try!(self.inner.read(&mut self.buf));\n+            self.pos = 0;\n         }\n-        self.buf.fill_buf()\n+        Ok(&self.buf[self.pos..self.cap])\n     }\n \n     fn consume(&mut self, amt: usize) {\n-        self.buf.consume(amt)\n+        self.pos = cmp::min(self.pos + amt, self.cap);\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"BufReader {{ reader: {:?}, buffer: {}/{} }}\",\n-               self.inner, self.buf.position(), self.buf.get_ref().len())\n+        fmt.debug_struct(\"BufReader\")\n+            .field(\"reader\", &self.inner)\n+            .field(\"buffer\", &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()))\n+            .finish()\n     }\n }\n \n@@ -222,8 +231,10 @@ impl<W: Write> Write for BufWriter<W> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> fmt::Debug for BufWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"BufWriter {{ writer: {:?}, buffer: {}/{} }}\",\n-               self.inner.as_ref().unwrap(), self.buf.len(), self.buf.capacity())\n+        fmt.debug_struct(\"BufWriter\")\n+            .field(\"writer\", &self.inner.as_ref().unwrap())\n+            .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n+            .finish()\n     }\n }\n \n@@ -337,9 +348,11 @@ impl<W: Write> Write for LineWriter<W> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> fmt::Debug for LineWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"LineWriter {{ writer: {:?}, buffer: {}/{} }}\",\n-               self.inner.inner, self.inner.buf.len(),\n-               self.inner.buf.capacity())\n+        fmt.debug_struct(\"LineWriter\")\n+            .field(\"writer\", &self.inner.inner)\n+            .field(\"buffer\",\n+                   &format_args!(\"{}/{}\", self.inner.buf.len(), self.inner.buf.capacity()))\n+            .finish()\n     }\n }\n \n@@ -415,10 +428,10 @@ impl<S: Read + Write> BufStream<S> {\n     /// Any leftover data in the read buffer is lost.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> Result<S, IntoInnerError<BufStream<S>>> {\n-        let BufReader { inner: InternalBufWriter(w), buf } = self.inner;\n+        let BufReader { inner: InternalBufWriter(w), buf, pos, cap } = self.inner;\n         w.into_inner().map_err(|IntoInnerError(w, e)| {\n             IntoInnerError(BufStream {\n-                inner: BufReader { inner: InternalBufWriter(w), buf: buf },\n+                inner: BufReader { inner: InternalBufWriter(w), buf: buf, pos: pos, cap: cap },\n             }, e)\n         })\n     }\n@@ -452,10 +465,12 @@ impl<S: Write> fmt::Debug for BufStream<S> where S: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let reader = &self.inner;\n         let writer = &self.inner.inner.0;\n-        write!(fmt, \"BufStream {{ stream: {:?}, write_buffer: {}/{}, read_buffer: {}/{} }}\",\n-               writer.inner,\n-               writer.buf.len(), writer.buf.capacity(),\n-               reader.buf.position(), reader.buf.get_ref().len())\n+        fmt.debug_struct(\"BufStream\")\n+            .field(\"stream\", &writer.inner)\n+            .field(\"write_buffer\", &format_args!(\"{}/{}\", writer.buf.len(), writer.buf.capacity()))\n+            .field(\"read_buffer\",\n+                   &format_args!(\"{}/{}\", reader.cap - reader.pos, reader.buf.len()))\n+            .finish()\n     }\n }\n "}, {"sha": "4a93d96beccfa9c0056f64dabc16339194647971", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ccb4e8423e50fef0f13a642715c3e617ee9f78fe/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb4e8423e50fef0f13a642715c3e617ee9f78fe/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=ccb4e8423e50fef0f13a642715c3e617ee9f78fe", "patch": "@@ -48,30 +48,6 @@ mod stdio;\n \n const DEFAULT_BUF_SIZE: usize = 64 * 1024;\n \n-// Acquires a slice of the vector `v` from its length to its capacity\n-// (after initializing the data), reads into it, and then updates the length.\n-//\n-// This function is leveraged to efficiently read some bytes into a destination\n-// vector without extra copying and taking advantage of the space that's already\n-// in `v`.\n-fn with_end_to_cap<F>(v: &mut Vec<u8>, f: F) -> Result<usize>\n-    where F: FnOnce(&mut [u8]) -> Result<usize>\n-{\n-    let len = v.len();\n-    let new_area = v.capacity() - len;\n-    v.extend(iter::repeat(0).take(new_area));\n-    match f(&mut v[len..]) {\n-        Ok(n) => {\n-            v.truncate(len + n);\n-            Ok(n)\n-        }\n-        Err(e) => {\n-            v.truncate(len);\n-            Err(e)\n-        }\n-    }\n-}\n-\n // A few methods below (read_to_string, read_line) will append data into a\n // `String` buffer, but we need to be pretty careful when doing this. The\n // implementation will just call `.as_mut_vec()` and then delegate to a\n@@ -116,19 +92,45 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n     }\n }\n \n+// This uses an adaptive system to extend the vector when it fills. We want to\n+// avoid paying to allocate and zero a huge chunk of memory if the reader only\n+// has 4 bytes while still making large reads if the reader does have a ton\n+// of data to return. Simply tacking on an extra DEFAULT_BUF_SIZE space every\n+// time is 4,500 times (!) slower than this if the reader has a very small\n+// amount of data to return.\n fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n-    let mut read = 0;\n+    let start_len = buf.len();\n+    let mut len = start_len;\n+    let mut cap_bump = 16;\n+    let ret;\n     loop {\n-        if buf.capacity() == buf.len() {\n-            buf.reserve(DEFAULT_BUF_SIZE);\n+        if len == buf.len() {\n+            if buf.capacity() == buf.len() {\n+                if cap_bump < DEFAULT_BUF_SIZE {\n+                    cap_bump *= 2;\n+                }\n+                buf.reserve(cap_bump);\n+            }\n+            let new_area = buf.capacity() - buf.len();\n+            buf.extend(iter::repeat(0).take(new_area));\n         }\n-        match with_end_to_cap(buf, |b| r.read(b)) {\n-            Ok(0) => return Ok(read),\n-            Ok(n) => read += n,\n+\n+        match r.read(&mut buf[len..]) {\n+            Ok(0) => {\n+                ret = Ok(len - start_len);\n+                break;\n+            }\n+            Ok(n) => len += n,\n             Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n-            Err(e) => return Err(e),\n+            Err(e) => {\n+                ret = Err(e);\n+                break;\n+            }\n         }\n     }\n+\n+    buf.truncate(len);\n+    ret\n }\n \n /// A trait for objects which are byte-oriented sources."}, {"sha": "b7cb8f9ed50fdcbec680f17db933b23fca299ae4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccb4e8423e50fef0f13a642715c3e617ee9f78fe/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb4e8423e50fef0f13a642715c3e617ee9f78fe/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ccb4e8423e50fef0f13a642715c3e617ee9f78fe", "patch": "@@ -128,6 +128,7 @@\n #![feature(into_cow)]\n #![feature(slice_patterns)]\n #![feature(std_misc)]\n+#![feature(debug_builders)]\n #![cfg_attr(test, feature(test, rustc_private, std_misc))]\n \n // Don't link to std. We are std."}]}