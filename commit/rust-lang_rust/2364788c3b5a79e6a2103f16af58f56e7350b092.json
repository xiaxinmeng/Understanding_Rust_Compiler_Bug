{"sha": "2364788c3b5a79e6a2103f16af58f56e7350b092", "node_id": "C_kwDOAAsO6NoAKDIzNjQ3ODhjM2I1YTc5ZTZhMjEwM2YxNmFmNThmNTZlNzM1MGIwOTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-05T12:55:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-05T12:55:36Z"}, "message": "Auto merge of #12948 - Veykril:classify-ops, r=Veykril\n\nfeat: Handle operators like their trait functions in the IDE\n\nAllows hover and goto implementation to work on `?`, indexing brackets, binary operators, prefix operators and `await`. Regarding `await`, hover will continue to show the keyword docs while goto implementation will bring the user to the `poll` function of the `Future` implementation.\n![Code_CJmZ3FGFVn](https://user-images.githubusercontent.com/3757771/183076683-c9899bd6-60d3-461b-965f-0c0f9745e2e8.gif)\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/12810", "tree": {"sha": "133e884cb07b9ddc9cfc5d5df41ec62ef0615f02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/133e884cb07b9ddc9cfc5d5df41ec62ef0615f02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2364788c3b5a79e6a2103f16af58f56e7350b092", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2364788c3b5a79e6a2103f16af58f56e7350b092", "html_url": "https://github.com/rust-lang/rust/commit/2364788c3b5a79e6a2103f16af58f56e7350b092", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2364788c3b5a79e6a2103f16af58f56e7350b092/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb522717016044ab63de0ee1375800787d4c72f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb522717016044ab63de0ee1375800787d4c72f4", "html_url": "https://github.com/rust-lang/rust/commit/cb522717016044ab63de0ee1375800787d4c72f4"}, {"sha": "8aa50e08af4bd2ecc6b2132d2db48edabe51f352", "url": "https://api.github.com/repos/rust-lang/rust/commits/8aa50e08af4bd2ecc6b2132d2db48edabe51f352", "html_url": "https://github.com/rust-lang/rust/commit/8aa50e08af4bd2ecc6b2132d2db48edabe51f352"}], "stats": {"total": 531, "additions": 463, "deletions": 68}, "files": [{"sha": "47d191822d841af60e5ae81977cabc7b45747e56", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=2364788c3b5a79e6a2103f16af58f56e7350b092", "patch": "@@ -381,6 +381,7 @@ pub mod known {\n         bitor,\n         bitxor_assign,\n         bitxor,\n+        branch,\n         deref_mut,\n         deref,\n         div_assign,\n@@ -396,6 +397,7 @@ pub mod known {\n         not,\n         owned_box,\n         partial_ord,\n+        poll,\n         r#fn,\n         rem_assign,\n         rem,"}, {"sha": "2a13106390d9f7f90773d1377bdc8b24351ca393", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 7, "deletions": 56, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=2364788c3b5a79e6a2103f16af58f56e7350b092", "patch": "@@ -10,13 +10,13 @@ use chalk_ir::{\n     cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n };\n use hir_def::{\n-    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, Literal, Ordering, Statement, UnaryOp},\n+    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n-    ConstParamId, FieldId, FunctionId, ItemContainerId, Lookup,\n+    ConstParamId, FieldId, ItemContainerId, Lookup,\n };\n-use hir_expand::name::{name, Name};\n+use hir_expand::name::Name;\n use stdx::always;\n use syntax::ast::RangeOp;\n \n@@ -28,7 +28,7 @@ use crate::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n     mapping::{from_chalk, ToChalk},\n-    method_resolution::{self, VisibleFromModule},\n+    method_resolution::{self, lang_names_for_bin_op, VisibleFromModule},\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::{generics, Generics},\n@@ -947,7 +947,9 @@ impl<'a> InferenceContext<'a> {\n         let lhs_ty = self.infer_expr(lhs, &lhs_expectation);\n         let rhs_ty = self.table.new_type_var();\n \n-        let func = self.resolve_binop_method(op);\n+        let func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n+            self.db.trait_data(self.resolve_lang_item(lang_item)?.as_trait()?).method_by_name(&name)\n+        });\n         let func = match func {\n             Some(func) => func,\n             None => {\n@@ -1473,55 +1475,4 @@ impl<'a> InferenceContext<'a> {\n             },\n         })\n     }\n-\n-    fn resolve_binop_method(&self, op: BinaryOp) -> Option<FunctionId> {\n-        let (name, lang_item) = match op {\n-            BinaryOp::LogicOp(_) => return None,\n-            BinaryOp::ArithOp(aop) => match aop {\n-                ArithOp::Add => (name!(add), name!(add)),\n-                ArithOp::Mul => (name!(mul), name!(mul)),\n-                ArithOp::Sub => (name!(sub), name!(sub)),\n-                ArithOp::Div => (name!(div), name!(div)),\n-                ArithOp::Rem => (name!(rem), name!(rem)),\n-                ArithOp::Shl => (name!(shl), name!(shl)),\n-                ArithOp::Shr => (name!(shr), name!(shr)),\n-                ArithOp::BitXor => (name!(bitxor), name!(bitxor)),\n-                ArithOp::BitOr => (name!(bitor), name!(bitor)),\n-                ArithOp::BitAnd => (name!(bitand), name!(bitand)),\n-            },\n-            BinaryOp::Assignment { op: Some(aop) } => match aop {\n-                ArithOp::Add => (name!(add_assign), name!(add_assign)),\n-                ArithOp::Mul => (name!(mul_assign), name!(mul_assign)),\n-                ArithOp::Sub => (name!(sub_assign), name!(sub_assign)),\n-                ArithOp::Div => (name!(div_assign), name!(div_assign)),\n-                ArithOp::Rem => (name!(rem_assign), name!(rem_assign)),\n-                ArithOp::Shl => (name!(shl_assign), name!(shl_assign)),\n-                ArithOp::Shr => (name!(shr_assign), name!(shr_assign)),\n-                ArithOp::BitXor => (name!(bitxor_assign), name!(bitxor_assign)),\n-                ArithOp::BitOr => (name!(bitor_assign), name!(bitor_assign)),\n-                ArithOp::BitAnd => (name!(bitand_assign), name!(bitand_assign)),\n-            },\n-            BinaryOp::CmpOp(cop) => match cop {\n-                CmpOp::Eq { negated: false } => (name!(eq), name!(eq)),\n-                CmpOp::Eq { negated: true } => (name!(ne), name!(eq)),\n-                CmpOp::Ord { ordering: Ordering::Less, strict: false } => {\n-                    (name!(le), name!(partial_ord))\n-                }\n-                CmpOp::Ord { ordering: Ordering::Less, strict: true } => {\n-                    (name!(lt), name!(partial_ord))\n-                }\n-                CmpOp::Ord { ordering: Ordering::Greater, strict: false } => {\n-                    (name!(ge), name!(partial_ord))\n-                }\n-                CmpOp::Ord { ordering: Ordering::Greater, strict: true } => {\n-                    (name!(gt), name!(partial_ord))\n-                }\n-            },\n-            BinaryOp::Assignment { op: None } => return None,\n-        };\n-\n-        let trait_ = self.resolve_lang_item(lang_item)?.as_trait()?;\n-\n-        self.db.trait_data(trait_).method_by_name(&name)\n-    }\n }"}, {"sha": "64622545f8408b190cec4f87e906a0627d515a6a", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=2364788c3b5a79e6a2103f16af58f56e7350b092", "patch": "@@ -336,7 +336,7 @@ impl InherentImpls {\n     }\n }\n \n-pub fn inherent_impl_crates_query(\n+pub(crate) fn inherent_impl_crates_query(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n     fp: TyFingerprint,\n@@ -419,6 +419,55 @@ pub fn def_crates(\n     }\n }\n \n+pub fn lang_names_for_bin_op(op: syntax::ast::BinaryOp) -> Option<(Name, Name)> {\n+    use hir_expand::name;\n+    use syntax::ast::{ArithOp, BinaryOp, CmpOp, Ordering};\n+    Some(match op {\n+        BinaryOp::LogicOp(_) => return None,\n+        BinaryOp::ArithOp(aop) => match aop {\n+            ArithOp::Add => (name!(add), name!(add)),\n+            ArithOp::Mul => (name!(mul), name!(mul)),\n+            ArithOp::Sub => (name!(sub), name!(sub)),\n+            ArithOp::Div => (name!(div), name!(div)),\n+            ArithOp::Rem => (name!(rem), name!(rem)),\n+            ArithOp::Shl => (name!(shl), name!(shl)),\n+            ArithOp::Shr => (name!(shr), name!(shr)),\n+            ArithOp::BitXor => (name!(bitxor), name!(bitxor)),\n+            ArithOp::BitOr => (name!(bitor), name!(bitor)),\n+            ArithOp::BitAnd => (name!(bitand), name!(bitand)),\n+        },\n+        BinaryOp::Assignment { op: Some(aop) } => match aop {\n+            ArithOp::Add => (name!(add_assign), name!(add_assign)),\n+            ArithOp::Mul => (name!(mul_assign), name!(mul_assign)),\n+            ArithOp::Sub => (name!(sub_assign), name!(sub_assign)),\n+            ArithOp::Div => (name!(div_assign), name!(div_assign)),\n+            ArithOp::Rem => (name!(rem_assign), name!(rem_assign)),\n+            ArithOp::Shl => (name!(shl_assign), name!(shl_assign)),\n+            ArithOp::Shr => (name!(shr_assign), name!(shr_assign)),\n+            ArithOp::BitXor => (name!(bitxor_assign), name!(bitxor_assign)),\n+            ArithOp::BitOr => (name!(bitor_assign), name!(bitor_assign)),\n+            ArithOp::BitAnd => (name!(bitand_assign), name!(bitand_assign)),\n+        },\n+        BinaryOp::CmpOp(cop) => match cop {\n+            CmpOp::Eq { negated: false } => (name!(eq), name!(eq)),\n+            CmpOp::Eq { negated: true } => (name!(ne), name!(eq)),\n+            CmpOp::Ord { ordering: Ordering::Less, strict: false } => {\n+                (name!(le), name!(partial_ord))\n+            }\n+            CmpOp::Ord { ordering: Ordering::Less, strict: true } => {\n+                (name!(lt), name!(partial_ord))\n+            }\n+            CmpOp::Ord { ordering: Ordering::Greater, strict: false } => {\n+                (name!(ge), name!(partial_ord))\n+            }\n+            CmpOp::Ord { ordering: Ordering::Greater, strict: true } => {\n+                (name!(gt), name!(partial_ord))\n+            }\n+        },\n+        BinaryOp::Assignment { op: None } => return None,\n+    })\n+}\n+\n /// Look up the method with the given name.\n pub(crate) fn lookup_method(\n     ty: &Canonical<Ty>,"}, {"sha": "416b6f58061da344580f4d9b672c6006e4749852", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=2364788c3b5a79e6a2103f16af58f56e7350b092", "patch": "@@ -357,6 +357,26 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_method_call(call).map(Function::from)\n     }\n \n+    pub fn resolve_await_to_poll(&self, await_expr: &ast::AwaitExpr) -> Option<Function> {\n+        self.imp.resolve_await_to_poll(await_expr).map(Function::from)\n+    }\n+\n+    pub fn resolve_prefix_expr(&self, prefix_expr: &ast::PrefixExpr) -> Option<Function> {\n+        self.imp.resolve_prefix_expr(prefix_expr).map(Function::from)\n+    }\n+\n+    pub fn resolve_index_expr(&self, index_expr: &ast::IndexExpr) -> Option<Function> {\n+        self.imp.resolve_index_expr(index_expr).map(Function::from)\n+    }\n+\n+    pub fn resolve_bin_expr(&self, bin_expr: &ast::BinExpr) -> Option<Function> {\n+        self.imp.resolve_bin_expr(bin_expr).map(Function::from)\n+    }\n+\n+    pub fn resolve_try_expr(&self, try_expr: &ast::TryExpr) -> Option<Function> {\n+        self.imp.resolve_try_expr(try_expr).map(Function::from)\n+    }\n+\n     pub fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         self.imp.resolve_method_call_as_callable(call)\n     }\n@@ -1066,6 +1086,26 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(call.syntax())?.resolve_method_call(self.db, call)\n     }\n \n+    fn resolve_await_to_poll(&self, await_expr: &ast::AwaitExpr) -> Option<FunctionId> {\n+        self.analyze(await_expr.syntax())?.resolve_await_to_poll(self.db, await_expr)\n+    }\n+\n+    fn resolve_prefix_expr(&self, prefix_expr: &ast::PrefixExpr) -> Option<FunctionId> {\n+        self.analyze(prefix_expr.syntax())?.resolve_prefix_expr(self.db, prefix_expr)\n+    }\n+\n+    fn resolve_index_expr(&self, index_expr: &ast::IndexExpr) -> Option<FunctionId> {\n+        self.analyze(index_expr.syntax())?.resolve_index_expr(self.db, index_expr)\n+    }\n+\n+    fn resolve_bin_expr(&self, bin_expr: &ast::BinExpr) -> Option<FunctionId> {\n+        self.analyze(bin_expr.syntax())?.resolve_bin_expr(self.db, bin_expr)\n+    }\n+\n+    fn resolve_try_expr(&self, try_expr: &ast::TryExpr) -> Option<FunctionId> {\n+        self.analyze(try_expr.syntax())?.resolve_try_expr(self.db, try_expr)\n+    }\n+\n     fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         self.analyze(call.syntax())?.resolve_method_call_as_callable(self.db, call)\n     }"}, {"sha": "f5e2e44307090151c24908cd5cf11a5896b0e709", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 115, "deletions": 5, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=2364788c3b5a79e6a2103f16af58f56e7350b092", "patch": "@@ -25,15 +25,20 @@ use hir_def::{\n     Lookup, ModuleDefId, VariantId,\n };\n use hir_expand::{\n-    builtin_fn_macro::BuiltinFnLikeExpander, hygiene::Hygiene, name::AsName, HirFileId, InFile,\n+    builtin_fn_macro::BuiltinFnLikeExpander,\n+    hygiene::Hygiene,\n+    name,\n+    name::{AsName, Name},\n+    HirFileId, InFile,\n };\n use hir_ty::{\n     diagnostics::{\n         record_literal_missing_fields, record_pattern_missing_fields, unsafe_expressions,\n         UnsafeExpr,\n     },\n-    method_resolution, Adjust, Adjustment, AutoBorrow, InferenceResult, Interner, Substitution,\n-    TyExt, TyKind, TyLoweringContext,\n+    method_resolution::{self, lang_names_for_bin_op},\n+    Adjust, Adjustment, AutoBorrow, InferenceResult, Interner, Substitution, Ty, TyExt, TyKind,\n+    TyLoweringContext,\n };\n use itertools::Itertools;\n use smallvec::SmallVec;\n@@ -255,8 +260,90 @@ impl SourceAnalyzer {\n     ) -> Option<FunctionId> {\n         let expr_id = self.expr_id(db, &call.clone().into())?;\n         let (f_in_trait, substs) = self.infer.as_ref()?.method_resolution(expr_id)?;\n-        let f_in_impl = self.resolve_impl_method(db, f_in_trait, &substs);\n-        f_in_impl.or(Some(f_in_trait))\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, &substs))\n+    }\n+\n+    pub(crate) fn resolve_await_to_poll(\n+        &self,\n+        db: &dyn HirDatabase,\n+        await_expr: &ast::AwaitExpr,\n+    ) -> Option<FunctionId> {\n+        let ty = self.ty_of_expr(db, &await_expr.expr()?.into())?;\n+\n+        let op_fn = db\n+            .lang_item(self.resolver.krate(), hir_expand::name![poll].to_smol_str())?\n+            .as_function()?;\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+    }\n+\n+    pub(crate) fn resolve_prefix_expr(\n+        &self,\n+        db: &dyn HirDatabase,\n+        prefix_expr: &ast::PrefixExpr,\n+    ) -> Option<FunctionId> {\n+        let lang_item_name = match prefix_expr.op_kind()? {\n+            ast::UnaryOp::Deref => name![deref],\n+            ast::UnaryOp::Not => name![not],\n+            ast::UnaryOp::Neg => name![neg],\n+        };\n+        let ty = self.ty_of_expr(db, &prefix_expr.expr()?.into())?;\n+\n+        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+    }\n+\n+    pub(crate) fn resolve_index_expr(\n+        &self,\n+        db: &dyn HirDatabase,\n+        index_expr: &ast::IndexExpr,\n+    ) -> Option<FunctionId> {\n+        let base_ty = self.ty_of_expr(db, &index_expr.base()?.into())?;\n+        let index_ty = self.ty_of_expr(db, &index_expr.index()?.into())?;\n+\n+        let lang_item_name = name![index];\n+\n+        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn)\n+            .push(base_ty.clone())\n+            .push(index_ty.clone())\n+            .build();\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+    }\n+\n+    pub(crate) fn resolve_bin_expr(\n+        &self,\n+        db: &dyn HirDatabase,\n+        binop_expr: &ast::BinExpr,\n+    ) -> Option<FunctionId> {\n+        let op = binop_expr.op_kind()?;\n+        let lhs = self.ty_of_expr(db, &binop_expr.lhs()?.into())?;\n+        let rhs = self.ty_of_expr(db, &binop_expr.rhs()?.into())?;\n+\n+        let op_fn = lang_names_for_bin_op(op)\n+            .and_then(|(name, lang_item)| self.lang_trait_fn(db, &lang_item, &name))?;\n+        let substs =\n+            hir_ty::TyBuilder::subst_for_def(db, op_fn).push(lhs.clone()).push(rhs.clone()).build();\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+    }\n+\n+    pub(crate) fn resolve_try_expr(\n+        &self,\n+        db: &dyn HirDatabase,\n+        try_expr: &ast::TryExpr,\n+    ) -> Option<FunctionId> {\n+        let ty = self.ty_of_expr(db, &try_expr.expr()?.into())?;\n+\n+        let op_fn =\n+            db.lang_item(self.resolver.krate(), name![branch].to_smol_str())?.as_function()?;\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n \n     pub(crate) fn resolve_field(\n@@ -666,6 +753,29 @@ impl SourceAnalyzer {\n         let fun_data = db.function_data(func);\n         method_resolution::lookup_impl_method(self_ty, db, trait_env, impled_trait, &fun_data.name)\n     }\n+\n+    fn resolve_impl_method_or_trait_def(\n+        &self,\n+        db: &dyn HirDatabase,\n+        func: FunctionId,\n+        substs: &Substitution,\n+    ) -> FunctionId {\n+        self.resolve_impl_method(db, func, substs).unwrap_or(func)\n+    }\n+\n+    fn lang_trait_fn(\n+        &self,\n+        db: &dyn HirDatabase,\n+        lang_trait: &Name,\n+        method_name: &Name,\n+    ) -> Option<FunctionId> {\n+        db.trait_data(db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?)\n+            .method_by_name(method_name)\n+    }\n+\n+    fn ty_of_expr(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<&Ty> {\n+        self.infer.as_ref()?.type_of_expr.get(self.expr_id(db, &expr)?)\n+    }\n }\n \n fn scope_for("}, {"sha": "6c13c039723b297a2a5b22645893b2c4c4e09590", "filename": "crates/ide-db/src/defs.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fdefs.rs?ref=2364788c3b5a79e6a2103f16af58f56e7350b092", "patch": "@@ -127,10 +127,12 @@ impl Definition {\n     }\n }\n \n+// FIXME: IdentClass as a name no longer fits\n #[derive(Debug)]\n pub enum IdentClass {\n     NameClass(NameClass),\n     NameRefClass(NameRefClass),\n+    Operator(OperatorClass),\n }\n \n impl IdentClass {\n@@ -147,6 +149,11 @@ impl IdentClass {\n                         .map(IdentClass::NameClass)\n                         .or_else(|| NameRefClass::classify_lifetime(sema, &lifetime).map(IdentClass::NameRefClass))\n                 },\n+                ast::AwaitExpr(await_expr) => OperatorClass::classify_await(sema, &await_expr).map(IdentClass::Operator),\n+                ast::BinExpr(bin_expr) => OperatorClass::classify_bin(sema, &bin_expr).map(IdentClass::Operator),\n+                ast::IndexExpr(index_expr) => OperatorClass::classify_index(sema, &index_expr).map(IdentClass::Operator),\n+                ast::PrefixExpr(prefix_expr) => OperatorClass::classify_prefix(sema,&prefix_expr).map(IdentClass::Operator),\n+                ast::TryExpr(try_expr) => OperatorClass::classify_try(sema,&try_expr).map(IdentClass::Operator),\n                 _ => None,\n             }\n         }\n@@ -184,6 +191,33 @@ impl IdentClass {\n                 res.push(Definition::Local(local_ref));\n                 res.push(Definition::Field(field_ref));\n             }\n+            IdentClass::Operator(\n+                OperatorClass::Await(func)\n+                | OperatorClass::Prefix(func)\n+                | OperatorClass::Bin(func)\n+                | OperatorClass::Index(func)\n+                | OperatorClass::Try(func),\n+            ) => res.push(Definition::Function(func)),\n+        }\n+        res\n+    }\n+\n+    pub fn definitions_no_ops(self) -> ArrayVec<Definition, 2> {\n+        let mut res = ArrayVec::new();\n+        match self {\n+            IdentClass::NameClass(NameClass::Definition(it) | NameClass::ConstReference(it)) => {\n+                res.push(it)\n+            }\n+            IdentClass::NameClass(NameClass::PatFieldShorthand { local_def, field_ref }) => {\n+                res.push(Definition::Local(local_def));\n+                res.push(Definition::Field(field_ref));\n+            }\n+            IdentClass::NameRefClass(NameRefClass::Definition(it)) => res.push(it),\n+            IdentClass::NameRefClass(NameRefClass::FieldShorthand { local_ref, field_ref }) => {\n+                res.push(Definition::Local(local_ref));\n+                res.push(Definition::Field(field_ref));\n+            }\n+            IdentClass::Operator(_) => (),\n         }\n         res\n     }\n@@ -332,6 +366,52 @@ impl NameClass {\n     }\n }\n \n+#[derive(Debug)]\n+pub enum OperatorClass {\n+    Await(Function),\n+    Prefix(Function),\n+    Index(Function),\n+    Try(Function),\n+    Bin(Function),\n+}\n+\n+impl OperatorClass {\n+    pub fn classify_await(\n+        sema: &Semantics<'_, RootDatabase>,\n+        await_expr: &ast::AwaitExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_await_to_poll(await_expr).map(OperatorClass::Await)\n+    }\n+\n+    pub fn classify_prefix(\n+        sema: &Semantics<'_, RootDatabase>,\n+        prefix_expr: &ast::PrefixExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_prefix_expr(prefix_expr).map(OperatorClass::Prefix)\n+    }\n+\n+    pub fn classify_try(\n+        sema: &Semantics<'_, RootDatabase>,\n+        try_expr: &ast::TryExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_try_expr(try_expr).map(OperatorClass::Try)\n+    }\n+\n+    pub fn classify_index(\n+        sema: &Semantics<'_, RootDatabase>,\n+        index_expr: &ast::IndexExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_index_expr(index_expr).map(OperatorClass::Index)\n+    }\n+\n+    pub fn classify_bin(\n+        sema: &Semantics<'_, RootDatabase>,\n+        bin_expr: &ast::BinExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_bin_expr(bin_expr).map(OperatorClass::Bin)\n+    }\n+}\n+\n /// This is similar to [`NameClass`], but works for [`ast::NameRef`] rather than\n /// for [`ast::Name`]. Similarly, what looks like a reference in syntax is a\n /// reference most of the time, but there are a couple of annoying exceptions."}, {"sha": "b2123b9a87938545f4e9609e4e586289b8634aa9", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 121, "deletions": 1, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=2364788c3b5a79e6a2103f16af58f56e7350b092", "patch": "@@ -39,7 +39,11 @@ pub(crate) fn goto_definition(\n             | T![super]\n             | T![crate]\n             | T![Self]\n-            | COMMENT => 2,\n+            | COMMENT => 4,\n+            // index and prefix ops\n+            T!['['] | T![']'] | T![?] | T![*] | T![-] | T![!] => 3,\n+            kind if kind.is_keyword() => 2,\n+            T!['('] | T![')'] => 2,\n             kind if kind.is_trivia() => 0,\n             _ => 1,\n         })?;\n@@ -1628,6 +1632,122 @@ macro_rules! foo {\n }\n \n foo!(bar$0);\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_await_poll() {\n+        check(\n+            r#\"\n+//- minicore: future\n+\n+struct MyFut;\n+\n+impl core::future::Future for MyFut {\n+    type Output = ();\n+\n+    fn poll(\n+     //^^^^\n+        self: std::pin::Pin<&mut Self>,\n+        cx: &mut std::task::Context<'_>\n+    ) -> std::task::Poll<Self::Output>\n+    {\n+        ()\n+    }\n+}\n+\n+fn f() {\n+    MyFut.await$0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_try_op() {\n+        check(\n+            r#\"\n+//- minicore: try\n+\n+struct Struct;\n+\n+impl core::ops::Try for Struct {\n+    fn branch(\n+     //^^^^^^\n+        self\n+    ) {}\n+}\n+\n+fn f() {\n+    Struct?$0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_index_op() {\n+        check(\n+            r#\"\n+//- minicore: index\n+\n+struct Struct;\n+\n+impl core::ops::Index<usize> for Struct {\n+    fn index(\n+     //^^^^^\n+        self\n+    ) {}\n+}\n+\n+fn f() {\n+    Struct[0]$0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_prefix_op() {\n+        check(\n+            r#\"\n+//- minicore: deref\n+\n+struct Struct;\n+\n+impl core::ops::Deref for Struct {\n+    fn deref(\n+     //^^^^^\n+        self\n+    ) {}\n+}\n+\n+fn f() {\n+    $0*Struct;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_bin_op() {\n+        check(\n+            r#\"\n+//- minicore: add\n+\n+struct Struct;\n+\n+impl core::ops::Add for Struct {\n+    fn add(\n+     //^^^\n+        self\n+    ) {}\n+}\n+\n+fn f() {\n+    Struct +$0 Struct;\n+}\n \"#,\n         );\n     }"}, {"sha": "f190da326e455fd8a6563df8ad19fd73d1aff90d", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=2364788c3b5a79e6a2103f16af58f56e7350b092", "patch": "@@ -333,7 +333,8 @@ fn cover_range(r0: Option<TextRange>, r1: Option<TextRange>) -> Option<TextRange\n fn find_defs(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken) -> FxHashSet<Definition> {\n     sema.descend_into_macros(token)\n         .into_iter()\n-        .filter_map(|token| IdentClass::classify_token(sema, &token).map(IdentClass::definitions))\n+        .filter_map(|token| IdentClass::classify_token(sema, &token))\n+        .map(IdentClass::definitions_no_ops)\n         .flatten()\n         .collect()\n }"}, {"sha": "3ada181f1ed2ba63a3e69d775af8a9bc3c35ab25", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=2364788c3b5a79e6a2103f16af58f56e7350b092", "patch": "@@ -9,7 +9,7 @@ use either::Either;\n use hir::{HasSource, Semantics};\n use ide_db::{\n     base_db::FileRange,\n-    defs::{Definition, IdentClass},\n+    defs::{Definition, IdentClass, OperatorClass},\n     famous_defs::FamousDefs,\n     helpers::pick_best_token,\n     FxIndexSet, RootDatabase,\n@@ -101,7 +101,10 @@ pub(crate) fn hover(\n     let offset = range.start();\n \n     let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n-        IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | T![Self] => 3,\n+        IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | T![Self] => 4,\n+        // index and prefix ops\n+        T!['['] | T![']'] | T![?] | T![*] | T![-] | T![!] => 3,\n+        kind if kind.is_keyword() => 2,\n         T!['('] | T![')'] => 2,\n         kind if kind.is_trivia() => 0,\n         _ => 1,\n@@ -136,6 +139,11 @@ pub(crate) fn hover(\n         .filter_map(|token| {\n             let node = token.parent()?;\n             let class = IdentClass::classify_token(sema, token)?;\n+            if let IdentClass::Operator(OperatorClass::Await(_)) = class {\n+                // It's better for us to fall back to the keyword hover here,\n+                // rendering poll is very confusing\n+                return None;\n+            }\n             Some(class.definitions().into_iter().zip(iter::once(node).cycle()))\n         })\n         .flatten()"}, {"sha": "c6274264b8f1a55770cd1a478bc8559a5c7ff9c3", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=2364788c3b5a79e6a2103f16af58f56e7350b092", "patch": "@@ -5051,3 +5051,37 @@ fn f() {\n             ```\"#]],\n     );\n }\n+\n+#[test]\n+fn hover_deref() {\n+    check(\n+        r#\"\n+//- minicore: deref\n+\n+struct Struct(usize);\n+\n+impl core::ops::Deref for Struct {\n+    type Target = usize;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn f() {\n+    $0*Struct(0);\n+}\n+\"#,\n+        expect![[r#\"\n+            ***\n+\n+            ```rust\n+            test::Struct\n+            ```\n+\n+            ```rust\n+            fn deref(&self) -> &Self::Target\n+            ```\n+        \"#]],\n+    );\n+}"}, {"sha": "4f758967b46194538d41c753da10372f997ba7de", "filename": "crates/ide/src/moniker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmoniker.rs?ref=2364788c3b5a79e6a2103f16af58f56e7350b092", "patch": "@@ -90,7 +90,7 @@ pub(crate) fn moniker(\n         .descend_into_macros(original_token.clone())\n         .into_iter()\n         .filter_map(|token| {\n-            IdentClass::classify_token(sema, &token).map(IdentClass::definitions).map(|it| {\n+            IdentClass::classify_token(sema, &token).map(IdentClass::definitions_no_ops).map(|it| {\n                 it.into_iter().flat_map(|def| def_to_moniker(sema.db, def, current_crate))\n             })\n         })"}, {"sha": "cc79ee55b7dac2be43bf41ae084af390ae198b0e", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2364788c3b5a79e6a2103f16af58f56e7350b092/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=2364788c3b5a79e6a2103f16af58f56e7350b092", "patch": "@@ -204,7 +204,7 @@ impl StaticIndex<'_> {\n \n fn get_definition(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken) -> Option<Definition> {\n     for token in sema.descend_into_macros(token) {\n-        let def = IdentClass::classify_token(sema, &token).map(IdentClass::definitions);\n+        let def = IdentClass::classify_token(sema, &token).map(IdentClass::definitions_no_ops);\n         if let Some(&[x]) = def.as_deref() {\n             return Some(x);\n         } else {"}]}