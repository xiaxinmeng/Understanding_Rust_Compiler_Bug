{"sha": "1d612a6ec48390c38d577cd35369e0891fe6cb6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNjEyYTZlYzQ4MzkwYzM4ZDU3N2NkMzUzNjllMDg5MWZlNmNiNmU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-16T13:56:26Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-16T14:04:00Z"}, "message": "De-duplicate `add_group` callsite in qualify_path", "tree": {"sha": "3dd360e2bf60ba22c71a2a9d0c048eb86057a817", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dd360e2bf60ba22c71a2a9d0c048eb86057a817"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d612a6ec48390c38d577cd35369e0891fe6cb6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d612a6ec48390c38d577cd35369e0891fe6cb6e", "html_url": "https://github.com/rust-lang/rust/commit/1d612a6ec48390c38d577cd35369e0891fe6cb6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d612a6ec48390c38d577cd35369e0891fe6cb6e/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc11475a2a0f06d5083a7032764a50e5f8ade130", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc11475a2a0f06d5083a7032764a50e5f8ade130", "html_url": "https://github.com/rust-lang/rust/commit/bc11475a2a0f06d5083a7032764a50e5f8ade130"}], "stats": {"total": 229, "additions": 108, "deletions": 121}, "files": [{"sha": "f436bdbbfa63fbb394afa48eb206539f928bc8a2", "filename": "crates/assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 108, "deletions": 121, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/1d612a6ec48390c38d577cd35369e0891fe6cb6e/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d612a6ec48390c38d577cd35369e0891fe6cb6e/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=1d612a6ec48390c38d577cd35369e0891fe6cb6e", "patch": "@@ -5,7 +5,7 @@ use ide_db::RootDatabase;\n use syntax::{\n     ast,\n     ast::{make, ArgListOwner},\n-    AstNode, TextRange,\n+    AstNode,\n };\n use test_utils::mark;\n \n@@ -16,8 +16,6 @@ use crate::{\n     AssistId, AssistKind, GroupLabel,\n };\n \n-const ASSIST_ID: AssistId = AssistId(\"qualify_path\", AssistKind::QuickFix);\n-\n // Assist: qualify_path\n //\n // If the name is unresolved, provides all possible qualified paths for it.\n@@ -51,162 +49,151 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n         return None;\n     }\n \n+    let candidate = import_assets.import_candidate();\n     let range = ctx.sema.original_range(import_assets.syntax_under_caret()).range;\n-    match import_assets.import_candidate() {\n-        ImportCandidate::QualifierStart(candidate) => {\n+\n+    let qualify_candidate = match candidate {\n+        ImportCandidate::QualifierStart(_) => {\n+            mark::hit!(qualify_path_qualifier_start);\n             let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n             let segment = path.segment()?;\n-            qualify_path_qualifier_start(acc, proposed_imports, range, segment, &candidate.name)\n+            QualifyCandidate::QualifierStart(segment)\n         }\n-        ImportCandidate::UnqualifiedName(candidate) => {\n-            qualify_path_unqualified_name(acc, proposed_imports, range, &candidate.name)\n+        ImportCandidate::UnqualifiedName(_) => {\n+            mark::hit!(qualify_path_unqualified_name);\n+            QualifyCandidate::UnqualifiedName\n         }\n         ImportCandidate::TraitAssocItem(_) => {\n+            mark::hit!(qualify_path_trait_assoc_item);\n             let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n             let (qualifier, segment) = (path.qualifier()?, path.segment()?);\n-            qualify_path_trait_assoc_item(acc, proposed_imports, range, qualifier, segment)\n+            QualifyCandidate::TraitAssocItem(qualifier, segment)\n         }\n         ImportCandidate::TraitMethod(_) => {\n+            mark::hit!(qualify_path_trait_method);\n             let mcall_expr = ast::MethodCallExpr::cast(import_assets.syntax_under_caret().clone())?;\n-            qualify_path_trait_method(acc, ctx.sema.db, proposed_imports, range, mcall_expr)?;\n+            QualifyCandidate::TraitMethod(ctx.sema.db, mcall_expr)\n         }\n     };\n-    Some(())\n-}\n \n-// a test that covers this -> `associated_struct_const`\n-fn qualify_path_qualifier_start(\n-    acc: &mut Assists,\n-    proposed_imports: Vec<(hir::ModPath, hir::ItemInNs)>,\n-    range: TextRange,\n-    segment: ast::PathSegment,\n-    qualifier_start: &ast::NameRef,\n-) {\n-    mark::hit!(qualify_path_qualifier_start);\n-    let group_label = GroupLabel(format!(\"Qualify {}\", qualifier_start));\n-    for (import, _) in proposed_imports {\n+    let group_label = group_label(candidate);\n+    for (import, item) in proposed_imports {\n         acc.add_group(\n             &group_label,\n-            ASSIST_ID,\n-            format!(\"Qualify with `{}`\", &import),\n+            AssistId(\"qualify_path\", AssistKind::QuickFix),\n+            label(candidate, &import),\n             range,\n             |builder| {\n-                let import = mod_path_to_ast(&import);\n-                builder.replace(range, format!(\"{}::{}\", import, segment));\n+                qualify_candidate.qualify(\n+                    |replace_with: String| builder.replace(range, replace_with),\n+                    import,\n+                    item,\n+                )\n             },\n         );\n     }\n+    Some(())\n }\n \n-// a test that covers this -> `applicable_when_found_an_import_partial`\n-fn qualify_path_unqualified_name(\n-    acc: &mut Assists,\n-    proposed_imports: Vec<(hir::ModPath, hir::ItemInNs)>,\n-    range: TextRange,\n-    name: &ast::NameRef,\n-) {\n-    mark::hit!(qualify_path_unqualified_name);\n-    let group_label = GroupLabel(format!(\"Qualify {}\", name));\n-    for (import, _) in proposed_imports {\n-        acc.add_group(\n-            &group_label,\n-            ASSIST_ID,\n-            format!(\"Qualify as `{}`\", &import),\n-            range,\n-            |builder| builder.replace(range, mod_path_to_ast(&import).to_string()),\n-        );\n-    }\n+enum QualifyCandidate<'db> {\n+    QualifierStart(ast::PathSegment),\n+    UnqualifiedName,\n+    TraitAssocItem(ast::Path, ast::PathSegment),\n+    TraitMethod(&'db RootDatabase, ast::MethodCallExpr),\n }\n \n-// a test that covers this -> `associated_trait_const`\n-fn qualify_path_trait_assoc_item(\n-    acc: &mut Assists,\n-    proposed_imports: Vec<(hir::ModPath, hir::ItemInNs)>,\n-    range: TextRange,\n-    qualifier: ast::Path,\n-    segment: ast::PathSegment,\n-) {\n-    mark::hit!(qualify_path_trait_assoc_item);\n-    let group_label = GroupLabel(format!(\"Qualify {}\", &segment));\n-    for (import, _) in proposed_imports {\n-        acc.add_group(\n-            &group_label,\n-            ASSIST_ID,\n-            format!(\"Qualify with cast as `{}`\", &import),\n-            range,\n-            |builder| {\n+impl QualifyCandidate<'_> {\n+    fn qualify(&self, mut replacer: impl FnMut(String), import: hir::ModPath, item: hir::ItemInNs) {\n+        match self {\n+            QualifyCandidate::QualifierStart(segment) => {\n                 let import = mod_path_to_ast(&import);\n-                builder.replace(range, format!(\"<{} as {}>::{}\", qualifier, import, segment));\n-            },\n-        );\n+                replacer(format!(\"{}::{}\", import, segment));\n+            }\n+            QualifyCandidate::UnqualifiedName => replacer(mod_path_to_ast(&import).to_string()),\n+            QualifyCandidate::TraitAssocItem(qualifier, segment) => {\n+                let import = mod_path_to_ast(&import);\n+                replacer(format!(\"<{} as {}>::{}\", qualifier, import, segment));\n+            }\n+            &QualifyCandidate::TraitMethod(db, ref mcall_expr) => {\n+                Self::qualify_trait_method(db, mcall_expr, replacer, import, item);\n+            }\n+        }\n+    }\n+\n+    fn qualify_trait_method(\n+        db: &RootDatabase,\n+        mcall_expr: &ast::MethodCallExpr,\n+        mut replacer: impl FnMut(String),\n+        import: hir::ModPath,\n+        item: hir::ItemInNs,\n+    ) -> Option<()> {\n+        let receiver = mcall_expr.receiver()?;\n+        let trait_method_name = mcall_expr.name_ref()?;\n+        let arg_list = mcall_expr.arg_list().map(|arg_list| arg_list.args());\n+        let trait_ = item_as_trait(item)?;\n+        let method = find_trait_method(db, trait_, &trait_method_name)?;\n+        if let Some(self_access) = method.self_param(db).map(|sp| sp.access(db)) {\n+            let import = mod_path_to_ast(&import);\n+            let receiver = match self_access {\n+                hir::Access::Shared => make::expr_ref(receiver, false),\n+                hir::Access::Exclusive => make::expr_ref(receiver, true),\n+                hir::Access::Owned => receiver,\n+            };\n+            replacer(format!(\n+                \"{}::{}{}\",\n+                import,\n+                trait_method_name,\n+                match arg_list.clone() {\n+                    Some(args) => make::arg_list(iter::once(receiver).chain(args)),\n+                    None => make::arg_list(iter::once(receiver)),\n+                }\n+            ));\n+        }\n+        Some(())\n     }\n }\n \n-// a test that covers this -> `trait_method`\n-fn qualify_path_trait_method(\n-    acc: &mut Assists,\n+fn find_trait_method(\n     db: &RootDatabase,\n-    proposed_imports: Vec<(hir::ModPath, hir::ItemInNs)>,\n-    range: TextRange,\n-    mcall_expr: ast::MethodCallExpr,\n-) -> Option<()> {\n-    mark::hit!(qualify_path_trait_method);\n-\n-    let receiver = mcall_expr.receiver()?;\n-    let trait_method_name = mcall_expr.name_ref()?;\n-    let arg_list = mcall_expr.arg_list().map(|arg_list| arg_list.args());\n-    let group_label = GroupLabel(format!(\"Qualify {}\", trait_method_name));\n-    let find_method = |item: &hir::AssocItem| {\n-        item.name(db).map(|name| name == trait_method_name.as_name()).unwrap_or(false)\n-    };\n-    for (import, trait_) in proposed_imports.into_iter().filter_map(filter_trait) {\n-        acc.add_group(\n-            &group_label,\n-            ASSIST_ID,\n-            format!(\"Qualify `{}`\", &import),\n-            range,\n-            |builder| {\n-                let import = mod_path_to_ast(&import);\n-                if let Some(hir::AssocItem::Function(method)) =\n-                    trait_.items(db).into_iter().find(find_method)\n-                {\n-                    if let Some(self_access) = method.self_param(db).map(|sp| sp.access(db)) {\n-                        let receiver = receiver.clone();\n-                        let receiver = match self_access {\n-                            hir::Access::Shared => make::expr_ref(receiver, false),\n-                            hir::Access::Exclusive => make::expr_ref(receiver, true),\n-                            hir::Access::Owned => receiver,\n-                        };\n-                        builder.replace(\n-                            range,\n-                            format!(\n-                                \"{}::{}{}\",\n-                                import,\n-                                trait_method_name,\n-                                match arg_list.clone() {\n-                                    Some(args) => make::arg_list(iter::once(receiver).chain(args)),\n-                                    None => make::arg_list(iter::once(receiver)),\n-                                }\n-                            ),\n-                        );\n-                    }\n-                }\n-            },\n-        );\n+    trait_: hir::Trait,\n+    trait_method_name: &ast::NameRef,\n+) -> Option<hir::Function> {\n+    if let Some(hir::AssocItem::Function(method)) =\n+        trait_.items(db).into_iter().find(|item: &hir::AssocItem| {\n+            item.name(db).map(|name| name == trait_method_name.as_name()).unwrap_or(false)\n+        })\n+    {\n+        Some(method)\n+    } else {\n+        None\n     }\n-    Some(())\n }\n \n-fn filter_trait(\n-    (import, trait_): (hir::ModPath, hir::ItemInNs),\n-) -> Option<(hir::ModPath, hir::Trait)> {\n-    if let hir::ModuleDef::Trait(trait_) = hir::ModuleDef::from(trait_.as_module_def_id()?) {\n-        Some((import, trait_))\n+fn item_as_trait(item: hir::ItemInNs) -> Option<hir::Trait> {\n+    if let hir::ModuleDef::Trait(trait_) = hir::ModuleDef::from(item.as_module_def_id()?) {\n+        Some(trait_)\n     } else {\n         None\n     }\n }\n \n+fn group_label(candidate: &ImportCandidate) -> GroupLabel {\n+    let name = match candidate {\n+        ImportCandidate::UnqualifiedName(it) | ImportCandidate::QualifierStart(it) => &it.name,\n+        ImportCandidate::TraitAssocItem(it) | ImportCandidate::TraitMethod(it) => &it.name,\n+    };\n+    GroupLabel(format!(\"Qualify {}\", name))\n+}\n+\n+fn label(candidate: &ImportCandidate, import: &hir::ModPath) -> String {\n+    match candidate {\n+        ImportCandidate::UnqualifiedName(_) => format!(\"Qualify as `{}`\", &import),\n+        ImportCandidate::QualifierStart(_) => format!(\"Qualify with `{}`\", &import),\n+        ImportCandidate::TraitAssocItem(_) => format!(\"Qualify `{}`\", &import),\n+        ImportCandidate::TraitMethod(_) => format!(\"Qualify with cast as `{}`\", &import),\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};"}]}