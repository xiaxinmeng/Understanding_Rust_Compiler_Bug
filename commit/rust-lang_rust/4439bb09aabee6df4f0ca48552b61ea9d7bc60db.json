{"sha": "4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MzliYjA5YWFiZWU2ZGY0ZjBjYTQ4NTUyYjYxZWE5ZDdiYzYwZGI=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-03-01T10:28:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-01T10:28:10Z"}, "message": "Rollup merge of #69579 - petrochenkov:noprevspan, r=Centril\n\nparser: Remove `Parser::prev_span`\n\nFollow-up to https://github.com/rust-lang/rust/pull/69384.\nr? @Centril", "tree": {"sha": "b8e984955d096614ced60c35a9329bc8120148bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8e984955d096614ced60c35a9329bc8120148bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeW446CRBK7hj4Ov3rIwAAdHIIAB6XcFLnt7xeSxhZY44o55ax\nMjb63aBwP5SM7t1hbyjV+TK2WpqnyNAq1tLFGf7s3mPf1UlgeAyyejQLdlNrIcdZ\nbKpfNIyipBpU0hWMg26LrnxXytKBQGjen4L0ylwFUfUZSshhya0/qsMP+xO8IeHf\n2bRUobPh2X7ex81L6uCka3Ne90nmLwWO4+4/kzjf9EuMWTOdiQlJksWqEntxZsDt\nDQgKSEv++b8m5EeRkbeOyWowvn27b3djGm+vFEzTCUoj5GUay5uU2mN52zKi7OoN\n/s15j5d2GX8eJYMK5TJRKN4hnW2asmupDLQUfGdMT4pfwMYawvgW085jjD4AIVI=\n=9J8t\n-----END PGP SIGNATURE-----\n", "payload": "tree b8e984955d096614ced60c35a9329bc8120148bb\nparent 48ec25224b1e252608a0458585dc5e0847ed91c4\nparent 7de9a72ca3769f55b415372f1f59f70ccf1f66fe\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1583058490 +0900\ncommitter GitHub <noreply@github.com> 1583058490 +0900\n\nRollup merge of #69579 - petrochenkov:noprevspan, r=Centril\n\nparser: Remove `Parser::prev_span`\n\nFollow-up to https://github.com/rust-lang/rust/pull/69384.\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "html_url": "https://github.com/rust-lang/rust/commit/4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48ec25224b1e252608a0458585dc5e0847ed91c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/48ec25224b1e252608a0458585dc5e0847ed91c4", "html_url": "https://github.com/rust-lang/rust/commit/48ec25224b1e252608a0458585dc5e0847ed91c4"}, {"sha": "7de9a72ca3769f55b415372f1f59f70ccf1f66fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/7de9a72ca3769f55b415372f1f59f70ccf1f66fe", "html_url": "https://github.com/rust-lang/rust/commit/7de9a72ca3769f55b415372f1f59f70ccf1f66fe"}], "stats": {"total": 445, "additions": 231, "deletions": 214}, "files": [{"sha": "9811a6621afa51726112b007f36d7915ad3ade25", "filename": "src/librustc_builtin_macros/asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -151,7 +151,7 @@ fn parse_inline_asm<'a>(\n \n                     let constraint = parse_asm_str(&mut p)?;\n \n-                    let span = p.prev_span;\n+                    let span = p.prev_token.span;\n \n                     p.expect(&token::OpenDelim(token::Paren))?;\n                     let expr = p.parse_expr()?;\n@@ -202,15 +202,15 @@ fn parse_inline_asm<'a>(\n                     if constraint.as_str().starts_with('=') {\n                         struct_span_err!(\n                             cx.parse_sess.span_diagnostic,\n-                            p.prev_span,\n+                            p.prev_token.span,\n                             E0662,\n                             \"input operand constraint contains '='\"\n                         )\n                         .emit();\n                     } else if constraint.as_str().starts_with('+') {\n                         struct_span_err!(\n                             cx.parse_sess.span_diagnostic,\n-                            p.prev_span,\n+                            p.prev_token.span,\n                             E0663,\n                             \"input operand constraint contains '+'\"\n                         )\n@@ -233,11 +233,11 @@ fn parse_inline_asm<'a>(\n                     let s = parse_asm_str(&mut p)?;\n \n                     if OPTIONS.iter().any(|&opt| s == opt) {\n-                        cx.span_warn(p.prev_span, \"expected a clobber, found an option\");\n+                        cx.span_warn(p.prev_token.span, \"expected a clobber, found an option\");\n                     } else if s.as_str().starts_with('{') || s.as_str().ends_with('}') {\n                         struct_span_err!(\n                             cx.parse_sess.span_diagnostic,\n-                            p.prev_span,\n+                            p.prev_token.span,\n                             E0664,\n                             \"clobber should not be surrounded by braces\"\n                         )\n@@ -259,7 +259,7 @@ fn parse_inline_asm<'a>(\n                 } else if option == sym::intel {\n                     dialect = AsmDialect::Intel;\n                 } else {\n-                    cx.span_warn(p.prev_span, \"unrecognized option\");\n+                    cx.span_warn(p.prev_token.span, \"unrecognized option\");\n                 }\n \n                 if p.token == token::Comma {"}, {"sha": "5da4a540940c24055e44c8a63767c7758d817846", "filename": "src/librustc_builtin_macros/assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_builtin_macros%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_builtin_macros%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fassert.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -106,7 +106,7 @@ fn parse_assert<'a>(\n     let custom_message =\n         if let token::Literal(token::Lit { kind: token::Str, .. }) = parser.token.kind {\n             let mut err = cx.struct_span_warn(parser.token.span, \"unexpected string literal\");\n-            let comma_span = parser.prev_span.shrink_to_hi();\n+            let comma_span = parser.prev_token.span.shrink_to_hi();\n             err.span_suggestion_short(\n                 comma_span,\n                 \"try adding a comma\","}, {"sha": "c5f8b2dd862a51403c953d85b966f0815e246789", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -116,7 +116,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::OpenDelim(token::Bracket))?;\n                 let item = self.parse_attr_item()?;\n                 self.expect(&token::CloseDelim(token::Bracket))?;\n-                let hi = self.prev_span;\n+                let hi = self.prev_token.span;\n \n                 let attr_sp = lo.to(hi);\n \n@@ -255,7 +255,7 @@ impl<'a> Parser<'a> {\n         while self.token.kind != token::Eof {\n             let lo = self.token.span;\n             let item = self.parse_attr_item()?;\n-            expanded_attrs.push((item, lo.to(self.prev_span)));\n+            expanded_attrs.push((item, lo.to(self.prev_token.span)));\n             if !self.eat(&token::Comma) {\n                 break;\n             }\n@@ -303,7 +303,7 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let path = self.parse_path(PathStyle::Mod)?;\n         let kind = self.parse_meta_item_kind()?;\n-        let span = lo.to(self.prev_span);\n+        let span = lo.to(self.prev_token.span);\n         Ok(ast::MetaItem { path, kind, span })\n     }\n "}, {"sha": "0759c43d45206281ae7eaf94034dcc48514a63cd", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -260,24 +260,24 @@ impl<'a> Parser<'a> {\n             };\n             (\n                 format!(\"expected one of {}, found {}\", expect, actual),\n-                (self.prev_span.shrink_to_hi(), format!(\"expected one of {}\", short_expect)),\n+                (self.prev_token.span.shrink_to_hi(), format!(\"expected one of {}\", short_expect)),\n             )\n         } else if expected.is_empty() {\n             (\n                 format!(\"unexpected token: {}\", actual),\n-                (self.prev_span, \"unexpected token after this\".to_string()),\n+                (self.prev_token.span, \"unexpected token after this\".to_string()),\n             )\n         } else {\n             (\n                 format!(\"expected {}, found {}\", expect, actual),\n-                (self.prev_span.shrink_to_hi(), format!(\"expected {}\", expect)),\n+                (self.prev_token.span.shrink_to_hi(), format!(\"expected {}\", expect)),\n             )\n         };\n         self.last_unexpected_token_span = Some(self.token.span);\n         let mut err = self.struct_span_err(self.token.span, &msg_exp);\n         let sp = if self.token == token::Eof {\n             // This is EOF; don't want to point at the following char, but rather the last token.\n-            self.prev_span\n+            self.prev_token.span\n         } else {\n             label_sp\n         };\n@@ -298,7 +298,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let sm = self.sess.source_map();\n-        if self.prev_span == DUMMY_SP {\n+        if self.prev_token.span == DUMMY_SP {\n             // Account for macro context where the previous span might not be\n             // available to avoid incorrect output (#54841).\n             err.span_label(self.token.span, label_exp);\n@@ -577,7 +577,7 @@ impl<'a> Parser<'a> {\n         match inner_op.kind {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // Respan to include both operators.\n-                let op_span = op.span.to(self.prev_span);\n+                let op_span = op.span.to(self.prev_token.span);\n                 let mut err =\n                     self.struct_span_err(op_span, \"comparison operators cannot be chained\");\n \n@@ -632,7 +632,7 @@ impl<'a> Parser<'a> {\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n-                                mk_err_expr(self, inner_op.span.to(self.prev_span))\n+                                mk_err_expr(self, inner_op.span.to(self.prev_token.span))\n                             }\n                             Err(mut expr_err) => {\n                                 expr_err.cancel();\n@@ -654,7 +654,7 @@ impl<'a> Parser<'a> {\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n-                                mk_err_expr(self, inner_op.span.to(self.prev_span))\n+                                mk_err_expr(self, inner_op.span.to(self.prev_token.span))\n                             }\n                         }\n                     } else {\n@@ -723,7 +723,7 @@ impl<'a> Parser<'a> {\n \n         self.bump(); // `+`\n         let bounds = self.parse_generic_bounds(None)?;\n-        let sum_span = ty.span.to(self.prev_span);\n+        let sum_span = ty.span.to(self.prev_token.span);\n \n         let mut err = struct_span_err!(\n             self.sess.span_diagnostic,\n@@ -790,7 +790,7 @@ impl<'a> Parser<'a> {\n \n         let mut path = ast::Path { segments: Vec::new(), span: DUMMY_SP };\n         self.parse_path_segments(&mut path.segments, T::PATH_STYLE)?;\n-        path.span = ty_span.to(self.prev_span);\n+        path.span = ty_span.to(self.prev_token.span);\n \n         let ty_str = self.span_to_snippet(ty_span).unwrap_or_else(|_| pprust::ty_to_string(&ty));\n         self.struct_span_err(path.span, \"missing angle brackets in associated item path\")\n@@ -809,9 +809,9 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn maybe_consume_incorrect_semicolon(&mut self, items: &[P<Item>]) -> bool {\n         if self.eat(&token::Semi) {\n-            let mut err = self.struct_span_err(self.prev_span, \"expected item, found `;`\");\n+            let mut err = self.struct_span_err(self.prev_token.span, \"expected item, found `;`\");\n             err.span_suggestion_short(\n-                self.prev_span,\n+                self.prev_token.span,\n                 \"remove this semicolon\",\n                 String::new(),\n                 Applicability::MachineApplicable,\n@@ -854,10 +854,10 @@ impl<'a> Parser<'a> {\n             }\n             // We don't want to point at the following span after DUMMY_SP.\n             // This happens when the parser finds an empty TokenStream.\n-            _ if self.prev_span == DUMMY_SP => (self.token.span, self.token.span),\n+            _ if self.prev_token.span == DUMMY_SP => (self.token.span, self.token.span),\n             // EOF, don't want to point at the following char, but rather the last token.\n-            (token::Eof, None) => (self.prev_span, self.token.span),\n-            _ => (self.prev_span.shrink_to_hi(), self.token.span),\n+            (token::Eof, None) => (self.prev_token.span, self.token.span),\n+            _ => (self.prev_token.span.shrink_to_hi(), self.token.span),\n         };\n         let msg = format!(\n             \"expected `{}`, found {}\",\n@@ -894,10 +894,10 @@ impl<'a> Parser<'a> {\n         let sm = self.sess.source_map();\n         let msg = format!(\"expected `;`, found `{}`\", super::token_descr(&self.token));\n         let appl = Applicability::MachineApplicable;\n-        if self.token.span == DUMMY_SP || self.prev_span == DUMMY_SP {\n+        if self.token.span == DUMMY_SP || self.prev_token.span == DUMMY_SP {\n             // Likely inside a macro, can't provide meaninful suggestions.\n             return self.expect(&token::Semi).map(drop);\n-        } else if !sm.is_multiline(self.prev_span.until(self.token.span)) {\n+        } else if !sm.is_multiline(self.prev_token.span.until(self.token.span)) {\n             // The current token is in the same line as the prior token, not recoverable.\n         } else if self.look_ahead(1, |t| {\n             t == &token::CloseDelim(token::Brace) || t.can_begin_expr() && t.kind != token::Colon\n@@ -910,7 +910,7 @@ impl<'a> Parser<'a> {\n             //   let x = 32:\n             //   let y = 42;\n             self.bump();\n-            let sp = self.prev_span;\n+            let sp = self.prev_token.span;\n             self.struct_span_err(sp, &msg)\n                 .span_suggestion(sp, \"change this to `;`\", \";\".to_string(), appl)\n                 .emit();\n@@ -927,7 +927,7 @@ impl<'a> Parser<'a> {\n             //\n             //   let x = 32\n             //   let y = 42;\n-            let sp = self.prev_span.shrink_to_hi();\n+            let sp = self.prev_token.span.shrink_to_hi();\n             self.struct_span_err(sp, &msg)\n                 .span_label(self.token.span, \"unexpected token\")\n                 .span_suggestion_short(sp, \"add `;` here\", \";\".to_string(), appl)\n@@ -961,7 +961,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::OpenDelim(token::Paren))?;\n         let expr = self.parse_expr()?;\n         self.expect(&token::CloseDelim(token::Paren))?;\n-        Ok((self.prev_span, expr, false))\n+        Ok((self.prev_token.span, expr, false))\n     }\n \n     fn recover_await_prefix(&mut self, await_sp: Span) -> PResult<'a, (Span, P<Expr>, bool)> {\n@@ -1036,10 +1036,10 @@ impl<'a> Parser<'a> {\n                     .span_to_snippet(pat.span.trim_start(begin_par_sp).unwrap())\n                     .unwrap_or_else(|_| pprust::pat_to_string(&pat));\n \n-                self.struct_span_err(self.prev_span, \"unexpected closing `)`\")\n+                self.struct_span_err(self.prev_token.span, \"unexpected closing `)`\")\n                     .span_label(begin_par_sp, \"opening `(`\")\n                     .span_suggestion(\n-                        begin_par_sp.to(self.prev_span),\n+                        begin_par_sp.to(self.prev_token.span),\n                         \"remove parenthesis in `for` loop\",\n                         format!(\"{} in {}\", pat_str, pprust::expr_to_string(&expr)),\n                         // With e.g. `for (x) in y)` this would replace `(x) in y)`\n@@ -1091,7 +1091,7 @@ impl<'a> Parser<'a> {\n                 err.emit();\n                 // Recover from parse error, callers expect the closing delim to be consumed.\n                 self.consume_block(delim, ConsumeClosingDelim::Yes);\n-                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, AttrVec::new())\n+                self.mk_expr(lo.to(self.prev_token.span), ExprKind::Err, AttrVec::new())\n             }\n         }\n     }\n@@ -1138,7 +1138,7 @@ impl<'a> Parser<'a> {\n                     err.span_label(sp, \"unclosed delimiter\");\n                 }\n                 err.span_suggestion_short(\n-                    self.prev_span.shrink_to_hi(),\n+                    self.prev_token.span.shrink_to_hi(),\n                     &format!(\"{} may belong here\", delim.to_string()),\n                     delim.to_string(),\n                     Applicability::MaybeIncorrect,\n@@ -1246,9 +1246,9 @@ impl<'a> Parser<'a> {\n     pub(super) fn check_for_for_in_in_typo(&mut self, in_span: Span) {\n         if self.eat_keyword(kw::In) {\n             // a common typo: `for _ in in bar {}`\n-            self.struct_span_err(self.prev_span, \"expected iterable, found keyword `in`\")\n+            self.struct_span_err(self.prev_token.span, \"expected iterable, found keyword `in`\")\n                 .span_suggestion_short(\n-                    in_span.until(self.prev_span),\n+                    in_span.until(self.prev_token.span),\n                     \"remove the duplicated `in`\",\n                     String::new(),\n                     Applicability::MachineApplicable,"}, {"sha": "18ddd23588e48c60ab08cf02497445dd21b4654c", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 69, "deletions": 60, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -166,7 +166,7 @@ impl<'a> Parser<'a> {\n             // Adjust the span for interpolated LHS to point to the `$lhs` token\n             // and not to what it refers to.\n             let lhs_span = match self.prev_token.kind {\n-                TokenKind::Interpolated(..) => self.prev_span,\n+                TokenKind::Interpolated(..) => self.prev_token.span,\n                 _ => lhs.span,\n             };\n \n@@ -523,7 +523,7 @@ impl<'a> Parser<'a> {\n         expr.map(|e| {\n             (\n                 match self.prev_token.kind {\n-                    TokenKind::Interpolated(..) => self.prev_span,\n+                    TokenKind::Interpolated(..) => self.prev_token.span,\n                     _ => e.span,\n                 },\n                 e,\n@@ -614,7 +614,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_assoc_op_ascribe(&mut self, lhs: P<Expr>, lhs_span: Span) -> PResult<'a, P<Expr>> {\n         let maybe_path = self.could_ascription_be_path(&lhs.kind);\n-        self.last_type_ascription = Some((self.prev_span, maybe_path));\n+        self.last_type_ascription = Some((self.prev_token.span, maybe_path));\n         let lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n         self.sess.gated_spans.gate(sym::type_ascription, lhs.span);\n         Ok(lhs)\n@@ -636,7 +636,7 @@ impl<'a> Parser<'a> {\n             let found_raw = self.eat_keyword(kw::Raw);\n             assert!(found_raw);\n             let mutability = self.parse_const_or_mut().unwrap();\n-            self.sess.gated_spans.gate(sym::raw_ref_op, lo.to(self.prev_span));\n+            self.sess.gated_spans.gate(sym::raw_ref_op, lo.to(self.prev_token.span));\n             (ast::BorrowKind::Raw, mutability)\n         } else {\n             // `mut?`\n@@ -683,7 +683,7 @@ impl<'a> Parser<'a> {\n         loop {\n             if self.eat(&token::Question) {\n                 // `expr?`\n-                e = self.mk_expr(lo.to(self.prev_span), ExprKind::Try(e), AttrVec::new());\n+                e = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Try(e), AttrVec::new());\n                 continue;\n             }\n             if self.eat(&token::Dot) {\n@@ -735,8 +735,8 @@ impl<'a> Parser<'a> {\n         let fstr = sym.as_str();\n         let msg = format!(\"unexpected token: `{}`\", sym);\n \n-        let mut err = self.struct_span_err(self.prev_span, &msg);\n-        err.span_label(self.prev_span, \"unexpected token\");\n+        let mut err = self.struct_span_err(self.prev_token.span, &msg);\n+        err.span_label(self.prev_token.span, \"unexpected token\");\n \n         if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n             let float = match fstr.parse::<f64>() {\n@@ -756,7 +756,7 @@ impl<'a> Parser<'a> {\n                 s.s.word(fstr.splitn(2, '.').last().unwrap().to_string())\n             });\n             err.span_suggestion(\n-                lo.to(self.prev_span),\n+                lo.to(self.prev_token.span),\n                 \"try parenthesizing the first index\",\n                 sugg,\n                 Applicability::MachineApplicable,\n@@ -782,7 +782,7 @@ impl<'a> Parser<'a> {\n     /// Parse a function call expression, `expr(...)`.\n     fn parse_fn_call_expr(&mut self, lo: Span, fun: P<Expr>) -> P<Expr> {\n         let seq = self.parse_paren_expr_seq().map(|args| {\n-            self.mk_expr(lo.to(self.prev_span), self.mk_call(fun, args), AttrVec::new())\n+            self.mk_expr(lo.to(self.prev_token.span), self.mk_call(fun, args), AttrVec::new())\n         });\n         self.recover_seq_parse_error(token::Paren, lo, seq)\n     }\n@@ -792,7 +792,7 @@ impl<'a> Parser<'a> {\n         self.bump(); // `[`\n         let index = self.parse_expr()?;\n         self.expect(&token::CloseDelim(token::Bracket))?;\n-        Ok(self.mk_expr(lo.to(self.prev_span), self.mk_index(base, index), AttrVec::new()))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), self.mk_index(base, index), AttrVec::new()))\n     }\n \n     /// Assuming we have just parsed `.`, continue parsing into an expression.\n@@ -809,7 +809,7 @@ impl<'a> Parser<'a> {\n             let mut args = self.parse_paren_expr_seq()?;\n             args.insert(0, self_arg);\n \n-            let span = lo.to(self.prev_span);\n+            let span = lo.to(self.prev_token.span);\n             Ok(self.mk_expr(span, ExprKind::MethodCall(segment, args), AttrVec::new()))\n         } else {\n             // Field access `expr.f`\n@@ -821,7 +821,7 @@ impl<'a> Parser<'a> {\n                 .emit();\n             }\n \n-            let span = lo.to(self.prev_span);\n+            let span = lo.to(self.prev_token.span);\n             Ok(self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), AttrVec::new()))\n         }\n     }\n@@ -867,18 +867,18 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::If) {\n             self.parse_if_expr(attrs)\n         } else if self.eat_keyword(kw::For) {\n-            self.parse_for_expr(None, self.prev_span, attrs)\n+            self.parse_for_expr(None, self.prev_token.span, attrs)\n         } else if self.eat_keyword(kw::While) {\n-            self.parse_while_expr(None, self.prev_span, attrs)\n+            self.parse_while_expr(None, self.prev_token.span, attrs)\n         } else if let Some(label) = self.eat_label() {\n             self.parse_labeled_expr(label, attrs)\n         } else if self.eat_keyword(kw::Loop) {\n-            self.parse_loop_expr(None, self.prev_span, attrs)\n+            self.parse_loop_expr(None, self.prev_token.span, attrs)\n         } else if self.eat_keyword(kw::Continue) {\n             let kind = ExprKind::Continue(self.eat_label());\n-            Ok(self.mk_expr(lo.to(self.prev_span), kind, attrs))\n+            Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n         } else if self.eat_keyword(kw::Match) {\n-            let match_sp = self.prev_span;\n+            let match_sp = self.prev_token.span;\n             self.parse_match_expr(attrs).map_err(|mut err| {\n                 err.span_label(match_sp, \"while parsing this match expression\");\n                 err\n@@ -921,7 +921,7 @@ impl<'a> Parser<'a> {\n                     self.parse_closure_expr(attrs)\n                 }\n             } else if self.eat_keyword(kw::Await) {\n-                self.recover_incorrect_await_syntax(lo, self.prev_span, attrs)\n+                self.recover_incorrect_await_syntax(lo, self.prev_token.span, attrs)\n             } else {\n                 self.parse_lit_expr(attrs)\n             }\n@@ -934,7 +934,7 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         match self.parse_opt_lit() {\n             Some(literal) => {\n-                let expr = self.mk_expr(lo.to(self.prev_span), ExprKind::Lit(literal), attrs);\n+                let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Lit(literal), attrs);\n                 self.maybe_recover_from_bad_qpath(expr, true)\n             }\n             None => return Err(self.expected_expression_found()),\n@@ -960,7 +960,7 @@ impl<'a> Parser<'a> {\n             // `(e,)` is a tuple with only one field, `e`.\n             ExprKind::Tup(es)\n         };\n-        let expr = self.mk_expr(lo.to(self.prev_span), kind, attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n@@ -995,7 +995,7 @@ impl<'a> Parser<'a> {\n                 ExprKind::Array(vec![first_expr])\n             }\n         };\n-        let expr = self.mk_expr(lo.to(self.prev_span), kind, attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n@@ -1011,7 +1011,7 @@ impl<'a> Parser<'a> {\n                 args: self.parse_mac_args()?,\n                 prior_type_ascription: self.last_type_ascription,\n             };\n-            (self.prev_span, ExprKind::Mac(mac))\n+            (self.prev_token.span, ExprKind::Mac(mac))\n         } else if self.check(&token::OpenDelim(token::Brace)) {\n             if let Some(expr) = self.maybe_parse_struct_expr(lo, &path, &attrs) {\n                 return expr;\n@@ -1055,7 +1055,7 @@ impl<'a> Parser<'a> {\n         self.bump(); // `do`\n         self.bump(); // `catch`\n \n-        let span_dc = lo.to(self.prev_span);\n+        let span_dc = lo.to(self.prev_token.span);\n         self.struct_span_err(span_dc, \"found removed `do catch` syntax\")\n             .span_suggestion(\n                 span_dc,\n@@ -1076,15 +1076,15 @@ impl<'a> Parser<'a> {\n \n     /// Parse `\"return\" expr?`.\n     fn parse_return_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let kind = ExprKind::Ret(self.parse_expr_opt()?);\n-        let expr = self.mk_expr(lo.to(self.prev_span), kind, attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n     /// Parse `\"('label \":\")? break expr?`.\n     fn parse_break_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let label = self.eat_label();\n         let kind = if self.token != token::OpenDelim(token::Brace)\n             || !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n@@ -1093,15 +1093,15 @@ impl<'a> Parser<'a> {\n         } else {\n             None\n         };\n-        let expr = self.mk_expr(lo.to(self.prev_span), ExprKind::Break(label, kind), attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Break(label, kind), attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n     /// Parse `\"yield\" expr?`.\n     fn parse_yield_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let kind = ExprKind::Yield(self.parse_expr_opt()?);\n-        let span = lo.to(self.prev_span);\n+        let span = lo.to(self.prev_token.span);\n         self.sess.gated_spans.gate(sym::generators, span);\n         let expr = self.mk_expr(span, kind, attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n@@ -1306,7 +1306,11 @@ impl<'a> Parser<'a> {\n         let expr = self.mk_expr(lit.span, ExprKind::Lit(lit), AttrVec::new());\n \n         if minus_present {\n-            Ok(self.mk_expr(lo.to(self.prev_span), self.mk_unary(UnOp::Neg, expr), AttrVec::new()))\n+            Ok(self.mk_expr(\n+                lo.to(self.prev_token.span),\n+                self.mk_unary(UnOp::Neg, expr),\n+                AttrVec::new(),\n+            ))\n         } else {\n             Ok(expr)\n         }\n@@ -1344,12 +1348,12 @@ impl<'a> Parser<'a> {\n             if self.normalized_token.span.rust_2018() { self.parse_asyncness() } else { Async::No };\n         if asyncness.is_async() {\n             // Feature-gate `async ||` closures.\n-            self.sess.gated_spans.gate(sym::async_closure, self.prev_span);\n+            self.sess.gated_spans.gate(sym::async_closure, self.normalized_prev_token.span);\n         }\n \n         let capture_clause = self.parse_capture_clause();\n         let decl = self.parse_fn_block_decl()?;\n-        let decl_hi = self.prev_span;\n+        let decl_hi = self.prev_token.span;\n         let body = match decl.output {\n             FnRetTy::Default(_) => {\n                 let restrictions = self.restrictions - Restrictions::STMT_EXPR;\n@@ -1404,7 +1408,7 @@ impl<'a> Parser<'a> {\n         let ty = if self.eat(&token::Colon) {\n             self.parse_ty()?\n         } else {\n-            self.mk_ty(self.prev_span, TyKind::Infer)\n+            self.mk_ty(self.prev_token.span, TyKind::Infer)\n         };\n         Ok(Param {\n             attrs: attrs.into(),\n@@ -1418,7 +1422,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses an `if` expression (`if` token already eaten).\n     fn parse_if_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let cond = self.parse_cond_expr()?;\n \n         // Verify that the parsed `if` condition makes sense as a condition. If it is a block, then\n@@ -1437,7 +1441,7 @@ impl<'a> Parser<'a> {\n             })?\n         };\n         let els = if self.eat_keyword(kw::Else) { Some(self.parse_else_expr()?) } else { None };\n-        Ok(self.mk_expr(lo.to(self.prev_span), ExprKind::If(cond, thn, els), attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els), attrs))\n     }\n \n     fn error_missing_if_cond(&self, lo: Span, span: Span) -> P<ast::Block> {\n@@ -1463,7 +1467,7 @@ impl<'a> Parser<'a> {\n     /// Parses a `let $pat = $expr` pseudo-expression.\n     /// The `let` token has already been eaten.\n     fn parse_let_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let pat = self.parse_top_pat(GateOr::No)?;\n         self.expect(&token::Eq)?;\n         let expr = self.with_res(Restrictions::NO_STRUCT_LITERAL, |this| {\n@@ -1503,7 +1507,7 @@ impl<'a> Parser<'a> {\n         if !self.eat_keyword(kw::In) {\n             self.error_missing_in_for_loop();\n         }\n-        self.check_for_for_in_in_typo(self.prev_span);\n+        self.check_for_for_in_in_typo(self.prev_token.span);\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n \n         let pat = self.recover_parens_around_for_head(pat, &expr, begin_paren);\n@@ -1512,11 +1516,11 @@ impl<'a> Parser<'a> {\n         attrs.extend(iattrs);\n \n         let kind = ExprKind::ForLoop(pat, expr, loop_block, opt_label);\n-        Ok(self.mk_expr(lo.to(self.prev_span), kind, attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n     }\n \n     fn error_missing_in_for_loop(&self) {\n-        let in_span = self.prev_span.between(self.token.span);\n+        let in_span = self.prev_token.span.between(self.token.span);\n         self.struct_span_err(in_span, \"missing `in` in `for` loop\")\n             .span_suggestion_short(\n                 in_span,\n@@ -1538,7 +1542,7 @@ impl<'a> Parser<'a> {\n         let cond = self.parse_cond_expr()?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        Ok(self.mk_expr(lo.to(self.prev_span), ExprKind::While(cond, body, opt_label), attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::While(cond, body, opt_label), attrs))\n     }\n \n     /// Parses `loop { ... }` (`loop` token already eaten).\n@@ -1550,7 +1554,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        Ok(self.mk_expr(lo.to(self.prev_span), ExprKind::Loop(body, opt_label), attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::Loop(body, opt_label), attrs))\n     }\n \n     fn eat_label(&mut self) -> Option<Label> {\n@@ -1562,8 +1566,8 @@ impl<'a> Parser<'a> {\n \n     /// Parses a `match ... { ... }` expression (`match` token already eaten).\n     fn parse_match_expr(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let match_span = self.prev_span;\n-        let lo = self.prev_span;\n+        let match_span = self.prev_token.span;\n+        let lo = self.prev_token.span;\n         let scrutinee = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n             if self.token == token::Semi {\n@@ -1676,8 +1680,10 @@ impl<'a> Parser<'a> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         if self.eat_keyword(kw::Catch) {\n-            let mut error =\n-                self.struct_span_err(self.prev_span, \"keyword `catch` cannot follow a `try` block\");\n+            let mut error = self.struct_span_err(\n+                self.prev_token.span,\n+                \"keyword `catch` cannot follow a `try` block\",\n+            );\n             error.help(\"try using `match` on the result of the `try` block instead\");\n             error.emit();\n             Err(error)\n@@ -1711,7 +1717,7 @@ impl<'a> Parser<'a> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let kind = ExprKind::Async(capture_clause, DUMMY_NODE_ID, body);\n-        Ok(self.mk_expr(lo.to(self.prev_span), kind, attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n     }\n \n     fn is_async_block(&self) -> bool {\n@@ -1775,7 +1781,7 @@ impl<'a> Parser<'a> {\n         pth: ast::Path,\n         mut attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n-        let struct_sp = lo.to(self.prev_span);\n+        let struct_sp = lo.to(self.prev_token.span);\n         self.bump();\n         let mut fields = Vec::new();\n         let mut base = None;\n@@ -1784,7 +1790,7 @@ impl<'a> Parser<'a> {\n \n         while self.token != token::CloseDelim(token::Brace) {\n             if self.eat(&token::DotDot) {\n-                let exp_span = self.prev_span;\n+                let exp_span = self.prev_token.span;\n                 match self.parse_expr() {\n                     Ok(e) => base = Some(e),\n                     Err(mut e) => {\n@@ -1828,7 +1834,7 @@ impl<'a> Parser<'a> {\n                     if let Some(f) = recovery_field {\n                         fields.push(f);\n                         e.span_suggestion(\n-                            self.prev_span.shrink_to_hi(),\n+                            self.prev_token.span.shrink_to_hi(),\n                             \"try adding a comma\",\n                             \",\".into(),\n                             Applicability::MachineApplicable,\n@@ -1868,15 +1874,18 @@ impl<'a> Parser<'a> {\n         if self.token != token::Comma {\n             return;\n         }\n-        self.struct_span_err(span.to(self.prev_span), \"cannot use a comma after the base struct\")\n-            .span_suggestion_short(\n-                self.token.span,\n-                \"remove this comma\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            )\n-            .note(\"the base struct must always be the last field\")\n-            .emit();\n+        self.struct_span_err(\n+            span.to(self.prev_token.span),\n+            \"cannot use a comma after the base struct\",\n+        )\n+        .span_suggestion_short(\n+            self.token.span,\n+            \"remove this comma\",\n+            String::new(),\n+            Applicability::MachineApplicable,\n+        )\n+        .note(\"the base struct must always be the last field\")\n+        .emit();\n         self.recover_stmt();\n     }\n \n@@ -1966,7 +1975,7 @@ impl<'a> Parser<'a> {\n         limits: RangeLimits,\n     ) -> PResult<'a, ExprKind> {\n         if end.is_none() && limits == RangeLimits::Closed {\n-            self.error_inclusive_range_with_no_end(self.prev_span);\n+            self.error_inclusive_range_with_no_end(self.prev_token.span);\n             Ok(ExprKind::Err)\n         } else {\n             Ok(ExprKind::Range(start, end, limits))\n@@ -1990,7 +1999,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn mk_await_expr(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        let span = lo.to(self.prev_span);\n+        let span = lo.to(self.prev_token.span);\n         let await_expr = self.mk_expr(span, ExprKind::Await(self_arg), AttrVec::new());\n         self.recover_from_await_method_call();\n         Ok(await_expr)"}, {"sha": "59fd5f7c4be1fc55f414cdb6dce37c985048f1c2", "filename": "src/librustc_parse/parser/generics.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -29,7 +29,7 @@ impl<'a> Parser<'a> {\n \n         // Parse optional colon and param bounds.\n         let bounds = if self.eat(&token::Colon) {\n-            self.parse_generic_bounds(Some(self.prev_span))?\n+            self.parse_generic_bounds(Some(self.prev_token.span))?\n         } else {\n             Vec::new()\n         };\n@@ -54,7 +54,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        self.sess.gated_spans.gate(sym::const_generics, lo.to(self.prev_span));\n+        self.sess.gated_spans.gate(sym::const_generics, lo.to(self.prev_token.span));\n \n         Ok(GenericParam {\n             ident,\n@@ -150,15 +150,15 @@ impl<'a> Parser<'a> {\n         let (params, span) = if self.eat_lt() {\n             let params = self.parse_generic_params()?;\n             self.expect_gt()?;\n-            (params, span_lo.to(self.prev_span))\n+            (params, span_lo.to(self.prev_token.span))\n         } else {\n-            (vec![], self.prev_span.shrink_to_hi())\n+            (vec![], self.prev_token.span.shrink_to_hi())\n         };\n         Ok(ast::Generics {\n             params,\n             where_clause: WhereClause {\n                 predicates: Vec::new(),\n-                span: self.prev_span.shrink_to_hi(),\n+                span: self.prev_token.span.shrink_to_hi(),\n             },\n             span,\n         })\n@@ -171,12 +171,12 @@ impl<'a> Parser<'a> {\n     /// ```\n     pub(super) fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n         let mut where_clause =\n-            WhereClause { predicates: Vec::new(), span: self.prev_span.shrink_to_hi() };\n+            WhereClause { predicates: Vec::new(), span: self.prev_token.span.shrink_to_hi() };\n \n         if !self.eat_keyword(kw::Where) {\n             return Ok(where_clause);\n         }\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n \n         // We are considering adding generics to the `where` keyword as an alternative higher-rank\n         // parameter syntax (as in `where<'a>` or `where<T>`. To avoid that being a breaking\n@@ -199,7 +199,11 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Colon)?;\n                 let bounds = self.parse_lt_param_bounds();\n                 where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n-                    ast::WhereRegionPredicate { span: lo.to(self.prev_span), lifetime, bounds },\n+                    ast::WhereRegionPredicate {\n+                        span: lo.to(self.prev_token.span),\n+                        lifetime,\n+                        bounds,\n+                    },\n                 ));\n             } else if self.check_type() {\n                 where_clause.predicates.push(self.parse_ty_where_predicate()?);\n@@ -212,7 +216,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        where_clause.span = lo.to(self.prev_span);\n+        where_clause.span = lo.to(self.prev_token.span);\n         Ok(where_clause)\n     }\n \n@@ -231,9 +235,9 @@ impl<'a> Parser<'a> {\n         // or with mandatory equality sign and the second type.\n         let ty = self.parse_ty()?;\n         if self.eat(&token::Colon) {\n-            let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n+            let bounds = self.parse_generic_bounds(Some(self.prev_token.span))?;\n             Ok(ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                span: lo.to(self.prev_span),\n+                span: lo.to(self.prev_token.span),\n                 bound_generic_params: lifetime_defs,\n                 bounded_ty: ty,\n                 bounds,\n@@ -243,7 +247,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n             let rhs_ty = self.parse_ty()?;\n             Ok(ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n-                span: lo.to(self.prev_span),\n+                span: lo.to(self.prev_token.span),\n                 lhs_ty: ty,\n                 rhs_ty,\n                 id: ast::DUMMY_NODE_ID,"}, {"sha": "9bca1d09901590654ce46fc13b70d2b817050a92", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -95,7 +95,7 @@ impl<'a> Parser<'a> {\n         let kind = self.parse_item_kind(&mut attrs, mac_allowed, lo, &vis, &mut def, req_name)?;\n         if let Some((ident, kind)) = kind {\n             self.error_on_unconsumed_default(def, &kind);\n-            let span = lo.to(self.prev_span);\n+            let span = lo.to(self.prev_token.span);\n             let id = DUMMY_NODE_ID;\n             let item = Item { ident, attrs, id, kind, vis, span, tokens: None };\n             return Ok(Some(item));\n@@ -247,8 +247,8 @@ impl<'a> Parser<'a> {\n         //\n         //     pub   S {}\n         //        ^^^ `sp` points here\n-        let sp = self.prev_span.between(self.token.span);\n-        let full_sp = self.prev_span.to(self.token.span);\n+        let sp = self.prev_token.span.between(self.token.span);\n+        let full_sp = self.prev_token.span.to(self.token.span);\n         let ident_sp = self.token.span;\n         if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n             // possible public struct definition where `struct` was forgotten\n@@ -402,7 +402,7 @@ impl<'a> Parser<'a> {\n             let mut generics = Generics::default();\n             // impl A for B {}\n             //    /\\ this is where `generics.span` should point when there are no type params.\n-            generics.span = self.prev_span.shrink_to_hi();\n+            generics.span = self.prev_token.span.shrink_to_hi();\n             generics\n         };\n \n@@ -423,7 +423,7 @@ impl<'a> Parser<'a> {\n         let err_path = |span| ast::Path::from_ident(Ident::new(kw::Invalid, span));\n         let ty_first = if self.token.is_keyword(kw::For) && self.look_ahead(1, |t| t != &token::Lt)\n         {\n-            let span = self.prev_span.between(self.token.span);\n+            let span = self.prev_token.span.between(self.token.span);\n             self.struct_span_err(span, \"missing trait in a trait impl\").emit();\n             P(Ty { kind: TyKind::Path(None, err_path(span)), span, id: DUMMY_NODE_ID })\n         } else {\n@@ -432,12 +432,12 @@ impl<'a> Parser<'a> {\n \n         // If `for` is missing we try to recover.\n         let has_for = self.eat_keyword(kw::For);\n-        let missing_for_span = self.prev_span.between(self.token.span);\n+        let missing_for_span = self.prev_token.span.between(self.token.span);\n \n         let ty_second = if self.token == token::DotDot {\n             // We need to report this error after `cfg` expansion for compatibility reasons\n             self.bump(); // `..`, do not add it to expected tokens\n-            Some(self.mk_ty(self.prev_span, TyKind::Err))\n+            Some(self.mk_ty(self.prev_token.span, TyKind::Err))\n         } else if has_for || self.token.can_begin_type() {\n             Some(self.parse_ty()?)\n         } else {\n@@ -524,15 +524,15 @@ impl<'a> Parser<'a> {\n                     self.struct_span_err(non_item_span, \"non-item in item list\")\n                         .span_label(open_brace_span, \"item list starts here\")\n                         .span_label(non_item_span, \"non-item starts here\")\n-                        .span_label(self.prev_span, \"item list ends here\")\n+                        .span_label(self.prev_token.span, \"item list ends here\")\n                         .emit();\n                     break;\n                 }\n                 Ok(Some(item)) => items.extend(item),\n                 Err(mut err) => {\n                     self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n                     err.span_label(open_brace_span, \"while parsing this item list starting here\")\n-                        .span_label(self.prev_span, \"the item list ends here\")\n+                        .span_label(self.prev_token.span, \"the item list ends here\")\n                         .emit();\n                     break;\n                 }\n@@ -573,7 +573,7 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(1, |t| t.is_non_raw_ident_where(|i| i.name != kw::As))\n         {\n             self.bump(); // `default`\n-            Defaultness::Default(self.prev_span)\n+            Defaultness::Default(self.normalized_prev_token.span)\n         } else {\n             Defaultness::Final\n         }\n@@ -599,11 +599,14 @@ impl<'a> Parser<'a> {\n \n         // Parse optional colon and supertrait bounds.\n         let had_colon = self.eat(&token::Colon);\n-        let span_at_colon = self.prev_span;\n-        let bounds =\n-            if had_colon { self.parse_generic_bounds(Some(self.prev_span))? } else { Vec::new() };\n+        let span_at_colon = self.prev_token.span;\n+        let bounds = if had_colon {\n+            self.parse_generic_bounds(Some(self.prev_token.span))?\n+        } else {\n+            Vec::new()\n+        };\n \n-        let span_before_eq = self.prev_span;\n+        let span_before_eq = self.prev_token.span;\n         if self.eat(&token::Eq) {\n             // It's a trait alias.\n             if had_colon {\n@@ -615,7 +618,7 @@ impl<'a> Parser<'a> {\n             tps.where_clause = self.parse_where_clause()?;\n             self.expect_semi()?;\n \n-            let whole_span = lo.to(self.prev_span);\n+            let whole_span = lo.to(self.prev_token.span);\n             if is_auto == IsAuto::Yes {\n                 let msg = \"trait aliases cannot be `auto`\";\n                 self.struct_span_err(whole_span, msg).span_label(whole_span, msg).emit();\n@@ -719,7 +722,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Ok(UseTree { prefix, kind, span: lo.to(self.prev_span) })\n+        Ok(UseTree { prefix, kind, span: lo.to(self.prev_token.span) })\n     }\n \n     /// Parses `*` or `{...}`.\n@@ -793,7 +796,7 @@ impl<'a> Parser<'a> {\n             // Do not include `-` as part of the expected tokens list.\n             while self.eat(&dash) {\n                 fixed_crate_name = true;\n-                replacement.push((self.prev_span, \"_\".to_string()));\n+                replacement.push((self.prev_token.span, \"_\".to_string()));\n                 idents.push(self.parse_ident()?);\n             }\n         }\n@@ -887,7 +890,7 @@ impl<'a> Parser<'a> {\n     /// Recover on `const mut` with `const` already eaten.\n     fn recover_const_mut(&mut self, const_span: Span) {\n         if self.eat_keyword(kw::Mut) {\n-            let span = self.prev_span;\n+            let span = self.prev_token.span;\n             self.struct_span_err(span, \"const globals cannot be mutable\")\n                 .span_label(span, \"cannot be mutable\")\n                 .span_suggestion(\n@@ -994,7 +997,7 @@ impl<'a> Parser<'a> {\n             attrs: variant_attrs,\n             data: struct_def,\n             disr_expr,\n-            span: vlo.to(self.prev_span),\n+            span: vlo.to(self.prev_token.span),\n             is_placeholder: false,\n         };\n \n@@ -1161,7 +1164,7 @@ impl<'a> Parser<'a> {\n             }\n             token::CloseDelim(token::Brace) => {}\n             token::DocComment(_) => {\n-                let previous_span = self.prev_span;\n+                let previous_span = self.prev_token.span;\n                 let mut err = self.span_fatal_err(self.token.span, Error::UselessDocComment);\n                 self.bump(); // consume the doc comment\n                 let comma_after_doc_seen = self.eat(&token::Comma);\n@@ -1186,7 +1189,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             _ => {\n-                let sp = self.prev_span.shrink_to_hi();\n+                let sp = self.prev_token.span.shrink_to_hi();\n                 let mut err = self.struct_span_err(\n                     sp,\n                     &format!(\"expected `,`, or `}}`, found {}\", super::token_descr(&self.token)),\n@@ -1219,7 +1222,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n         Ok(StructField {\n-            span: lo.to(self.prev_span),\n+            span: lo.to(self.prev_token.span),\n             ident: Some(name),\n             vis,\n             id: DUMMY_NODE_ID,\n@@ -1257,7 +1260,7 @@ impl<'a> Parser<'a> {\n             return self.unexpected();\n         };\n \n-        self.sess.gated_spans.gate(sym::decl_macro, lo.to(self.prev_span));\n+        self.sess.gated_spans.gate(sym::decl_macro, lo.to(self.prev_token.span));\n         Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: false })))\n     }\n \n@@ -1511,11 +1514,11 @@ impl<'a> Parser<'a> {\n         let (mut params, _) = self.parse_paren_comma_seq(|p| {\n             let param = p.parse_param_general(req_name, first_param).or_else(|mut e| {\n                 e.emit();\n-                let lo = p.prev_span;\n+                let lo = p.prev_token.span;\n                 // Skip every token until next possible arg or end.\n                 p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n                 // Create a placeholder argument for proper arg count (issue #34264).\n-                Ok(dummy_arg(Ident::new(kw::Invalid, lo.to(p.prev_span))))\n+                Ok(dummy_arg(Ident::new(kw::Invalid, lo.to(p.prev_token.span))))\n             });\n             // ...now that we've parsed the first argument, `self` is no longer allowed.\n             first_param = false;\n@@ -1575,7 +1578,7 @@ impl<'a> Parser<'a> {\n             }\n             match ty {\n                 Ok(ty) => {\n-                    let ident = Ident::new(kw::Invalid, self.prev_span);\n+                    let ident = Ident::new(kw::Invalid, self.prev_token.span);\n                     let bm = BindingMode::ByValue(Mutability::Not);\n                     let pat = self.mk_pat_ident(ty.span, bm, ident);\n                     (pat, ty)\n@@ -1627,7 +1630,7 @@ impl<'a> Parser<'a> {\n         // Parse `self` or `self: TYPE`. We already know the current token is `self`.\n         let parse_self_possibly_typed = |this: &mut Self, m| {\n             let eself_ident = expect_self_ident(this);\n-            let eself_hi = this.prev_span;\n+            let eself_hi = this.prev_token.span;\n             let eself = if this.eat(&token::Colon) {\n                 SelfKind::Explicit(this.parse_ty()?, m)\n             } else {\n@@ -1641,7 +1644,7 @@ impl<'a> Parser<'a> {\n             let span = this.token.span;\n             this.struct_span_err(span, msg).span_label(span, msg).emit();\n \n-            Ok((SelfKind::Value(Mutability::Not), expect_self_ident(this), this.prev_span))\n+            Ok((SelfKind::Value(Mutability::Not), expect_self_ident(this), this.prev_token.span))\n         };\n \n         // Parse optional `self` parameter of a method.\n@@ -1674,7 +1677,7 @@ impl<'a> Parser<'a> {\n                     // `&not_self`\n                     return Ok(None);\n                 };\n-                (eself, expect_self_ident(self), self.prev_span)\n+                (eself, expect_self_ident(self), self.prev_token.span)\n             }\n             // `*self`\n             token::BinOp(token::Star) if is_isolated_self(self, 1) => {"}, {"sha": "74101fef8e39b606eed2e708db6661e4ccfd5340", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -78,7 +78,7 @@ macro_rules! maybe_recover_from_interpolated_ty_qpath {\n                 if let token::NtTy(ty) = &**nt {\n                     let ty = ty.clone();\n                     $self.bump();\n-                    return $self.maybe_recover_from_bad_qpath_stage_2($self.prev_span, ty);\n+                    return $self.maybe_recover_from_bad_qpath_stage_2($self.prev_token.span, ty);\n                 }\n             }\n         }\n@@ -103,8 +103,6 @@ pub struct Parser<'a> {\n     /// Use this if you need to check for `token::Ident` or `token::Lifetime` specifically,\n     /// this also includes edition checks for edition-specific keyword identifiers.\n     pub normalized_prev_token: Token,\n-    /// FIXME: Remove in favor of the equivalent `prev_token.span`.\n-    pub prev_span: Span,\n     restrictions: Restrictions,\n     /// Used to determine the path to externally loaded source files.\n     pub(super) directory: Directory,\n@@ -379,7 +377,6 @@ impl<'a> Parser<'a> {\n             normalized_token: Token::dummy(),\n             prev_token: Token::dummy(),\n             normalized_prev_token: Token::dummy(),\n-            prev_span: DUMMY_SP,\n             restrictions: Restrictions::empty(),\n             recurse_into_file_modules,\n             directory: Directory {\n@@ -498,7 +495,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => Err(match self.prev_token.kind {\n                 TokenKind::DocComment(..) => {\n-                    self.span_fatal_err(self.prev_span, Error::UselessDocComment)\n+                    self.span_fatal_err(self.prev_token.span, Error::UselessDocComment)\n                 }\n                 _ => self.expected_ident_found(),\n             }),\n@@ -706,7 +703,7 @@ impl<'a> Parser<'a> {\n                             break;\n                         }\n                         Err(mut expect_err) => {\n-                            let sp = self.prev_span.shrink_to_hi();\n+                            let sp = self.prev_token.span.shrink_to_hi();\n                             let token_str = pprust::token_kind_to_string(t);\n \n                             // Attempt to keep parsing if it was a similar separator.\n@@ -850,9 +847,6 @@ impl<'a> Parser<'a> {\n         self.normalized_prev_token = self.normalized_token.take();\n         self.set_token(next_token);\n \n-        // Update fields derived from the previous token.\n-        self.prev_span = self.prev_token.span;\n-\n         // Diagnostics.\n         self.expected_tokens.clear();\n     }\n@@ -899,12 +893,20 @@ impl<'a> Parser<'a> {\n \n     /// Parses unsafety: `unsafe` or nothing.\n     fn parse_unsafety(&mut self) -> Unsafe {\n-        if self.eat_keyword(kw::Unsafe) { Unsafe::Yes(self.prev_span) } else { Unsafe::No }\n+        if self.eat_keyword(kw::Unsafe) {\n+            Unsafe::Yes(self.normalized_prev_token.span)\n+        } else {\n+            Unsafe::No\n+        }\n     }\n \n     /// Parses constness: `const` or nothing.\n     fn parse_constness(&mut self) -> Const {\n-        if self.eat_keyword(kw::Const) { Const::Yes(self.prev_span) } else { Const::No }\n+        if self.eat_keyword(kw::Const) {\n+            Const::Yes(self.normalized_prev_token.span)\n+        } else {\n+            Const::No\n+        }\n     }\n \n     /// Parses mutability (`mut` or nothing).\n@@ -928,7 +930,7 @@ impl<'a> Parser<'a> {\n         {\n             self.expect_no_suffix(self.token.span, \"a tuple index\", suffix);\n             self.bump();\n-            Ok(Ident::new(symbol, self.prev_span))\n+            Ok(Ident::new(symbol, self.prev_token.span))\n         } else {\n             self.parse_ident_common(false)\n         }\n@@ -958,7 +960,7 @@ impl<'a> Parser<'a> {\n                 }\n             } else if !delimited_only {\n                 if self.eat(&token::Eq) {\n-                    let eq_span = self.prev_span;\n+                    let eq_span = self.prev_token.span;\n                     let mut is_interpolated_expr = false;\n                     if let token::Interpolated(nt) = &self.token.kind {\n                         if let token::NtExpr(..) = **nt {\n@@ -1061,8 +1063,8 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));\n         if self.is_crate_vis() {\n             self.bump(); // `crate`\n-            self.sess.gated_spans.gate(sym::crate_visibility_modifier, self.prev_span);\n-            return Ok(respan(self.prev_span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n+            self.sess.gated_spans.gate(sym::crate_visibility_modifier, self.prev_token.span);\n+            return Ok(respan(self.prev_token.span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n         }\n \n         if !self.eat_keyword(kw::Pub) {\n@@ -1071,7 +1073,7 @@ impl<'a> Parser<'a> {\n             // beginning of the current token would seem to be the \"Schelling span\".\n             return Ok(respan(self.token.span.shrink_to_lo(), VisibilityKind::Inherited));\n         }\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n \n         if self.check(&token::OpenDelim(token::Paren)) {\n             // We don't `self.bump()` the `(` yet because this might be a struct definition where\n@@ -1086,15 +1088,15 @@ impl<'a> Parser<'a> {\n                 self.bump(); // `crate`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n                 let vis = VisibilityKind::Crate(CrateSugar::PubCrate);\n-                return Ok(respan(lo.to(self.prev_span), vis));\n+                return Ok(respan(lo.to(self.prev_token.span), vis));\n             } else if self.is_keyword_ahead(1, &[kw::In]) {\n                 // Parse `pub(in path)`.\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n                 let path = self.parse_path(PathStyle::Mod)?; // `path`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n                 let vis = VisibilityKind::Restricted { path: P(path), id: ast::DUMMY_NODE_ID };\n-                return Ok(respan(lo.to(self.prev_span), vis));\n+                return Ok(respan(lo.to(self.prev_token.span), vis));\n             } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren))\n                 && self.is_keyword_ahead(1, &[kw::Super, kw::SelfLower])\n             {\n@@ -1103,7 +1105,7 @@ impl<'a> Parser<'a> {\n                 let path = self.parse_path(PathStyle::Mod)?; // `super`/`self`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n                 let vis = VisibilityKind::Restricted { path: P(path), id: ast::DUMMY_NODE_ID };\n-                return Ok(respan(lo.to(self.prev_span), vis));\n+                return Ok(respan(lo.to(self.prev_token.span), vis));\n             } else if let FollowedByType::No = fbt {\n                 // Provide this diagnostic if a type cannot follow;\n                 // in particular, if this is not a tuple struct."}, {"sha": "b436f1969bb48aa110641269b066a3ed747d9859", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -90,7 +90,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let hi = if self.token.span.is_dummy() { inner_lo } else { self.prev_span };\n+        let hi = if self.token.span.is_dummy() { inner_lo } else { self.prev_token.span };\n \n         Ok(Mod { inner: inner_lo.to(hi), items, inline: true })\n     }"}, {"sha": "45d1aacdd3cc6cf226abbb2164c52cad273f2606", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -48,7 +48,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_top_pat(&mut self, gate_or: GateOr) -> PResult<'a, P<Pat>> {\n         // Allow a '|' before the pats (RFCs 1925, 2530, and 2535).\n         let gated_leading_vert = self.eat_or_separator(None) && gate_or == GateOr::Yes;\n-        let leading_vert_span = self.prev_span;\n+        let leading_vert_span = self.prev_token.span;\n \n         // Parse the possibly-or-pattern.\n         let pat = self.parse_pat_with_or(None, gate_or, RecoverComma::Yes)?;\n@@ -115,7 +115,7 @@ impl<'a> Parser<'a> {\n             self.maybe_recover_unexpected_comma(pat.span, rc)?;\n             pats.push(pat);\n         }\n-        let or_pattern_span = lo.to(self.prev_span);\n+        let or_pattern_span = lo.to(self.prev_token.span);\n \n         // Feature gate the or-pattern if instructed:\n         if gate_or == GateOr::Yes {\n@@ -206,7 +206,7 @@ impl<'a> Parser<'a> {\n             // end of the comma-sequence so we know the span to suggest parenthesizing.\n             err.cancel();\n         }\n-        let seq_span = lo.to(self.prev_span);\n+        let seq_span = lo.to(self.prev_token.span);\n         let mut err = self.struct_span_err(comma_span, \"unexpected `,` in pattern\");\n         if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n             err.span_suggestion(\n@@ -311,7 +311,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::Box) {\n             // Parse `box pat`\n             let pat = self.parse_pat_with_range_pat(false, None)?;\n-            self.sess.gated_spans.gate(sym::box_patterns, lo.to(self.prev_span));\n+            self.sess.gated_spans.gate(sym::box_patterns, lo.to(self.prev_token.span));\n             PatKind::Box(pat)\n         } else if self.can_be_ident_pat() {\n             // Parse `ident @ pat`\n@@ -328,7 +328,7 @@ impl<'a> Parser<'a> {\n                 // Parse an unqualified path\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n-            let span = lo.to(self.prev_span);\n+            let span = lo.to(self.prev_token.span);\n \n             if qself.is_none() && self.check(&token::Not) {\n                 self.parse_pat_mac_invoc(path)?\n@@ -353,7 +353,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        let pat = self.mk_pat(lo.to(self.prev_span), pat);\n+        let pat = self.mk_pat(lo.to(self.prev_token.span), pat);\n         let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n         let pat = self.recover_intersection_pat(pat)?;\n \n@@ -459,7 +459,7 @@ impl<'a> Parser<'a> {\n         if let token::Lifetime(name) = self.token.kind {\n             self.bump(); // `'a`\n \n-            let span = self.prev_span;\n+            let span = self.prev_token.span;\n             self.struct_span_err(span, &format!(\"unexpected lifetime `{}` in pattern\", name))\n                 .span_suggestion(\n                     span,\n@@ -487,7 +487,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a mutable binding with the `mut` token already eaten.\n     fn parse_pat_ident_mut(&mut self) -> PResult<'a, PatKind> {\n-        let mut_span = self.prev_span;\n+        let mut_span = self.prev_token.span;\n \n         if self.eat_keyword(kw::Ref) {\n             return self.recover_mut_ref_ident(mut_span);\n@@ -522,7 +522,7 @@ impl<'a> Parser<'a> {\n     /// Recover on `mut ref? ident @ pat` and suggest\n     /// that the order of `mut` and `ref` is incorrect.\n     fn recover_mut_ref_ident(&mut self, lo: Span) -> PResult<'a, PatKind> {\n-        let mutref_span = lo.to(self.prev_span);\n+        let mutref_span = lo.to(self.prev_token.span);\n         self.struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n             .span_suggestion(\n                 mutref_span,\n@@ -582,7 +582,7 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        let span = lo.to(self.prev_span);\n+        let span = lo.to(self.prev_token.span);\n         self.struct_span_err(span, \"`mut` on a binding may not be repeated\")\n             .span_suggestion(\n                 span,\n@@ -629,12 +629,12 @@ impl<'a> Parser<'a> {\n         } else if self.eat(&token::DotDotEq) {\n             RangeEnd::Included(RangeSyntax::DotDotEq)\n         } else if self.eat(&token::DotDot) {\n-            self.sess.gated_spans.gate(sym::exclusive_range_pattern, self.prev_span);\n+            self.sess.gated_spans.gate(sym::exclusive_range_pattern, self.prev_token.span);\n             RangeEnd::Excluded\n         } else {\n             return None;\n         };\n-        Some(respan(self.prev_span, re))\n+        Some(respan(self.prev_token.span, re))\n     }\n \n     /// Parse a range pattern `$begin $form $end?` where `$form = \"..\" | \"...\" | \"..=\" ;`.\n@@ -678,7 +678,7 @@ impl<'a> Parser<'a> {\n     /// expression syntax `...expr` for splatting in expressions.\n     fn parse_pat_range_to(&mut self, mut re: Spanned<RangeEnd>) -> PResult<'a, PatKind> {\n         let end = self.parse_pat_range_end()?;\n-        self.sess.gated_spans.gate(sym::half_open_range_patterns, re.span.to(self.prev_span));\n+        self.sess.gated_spans.gate(sym::half_open_range_patterns, re.span.to(self.prev_token.span));\n         if let RangeEnd::Included(ref mut syn @ RangeSyntax::DotDotDot) = &mut re.node {\n             *syn = RangeSyntax::DotDotEq;\n             self.struct_span_err(re.span, \"range-to patterns with `...` are not allowed\")\n@@ -714,7 +714,7 @@ impl<'a> Parser<'a> {\n                 // Parse an unqualified path\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n-            let hi = self.prev_span;\n+            let hi = self.prev_token.span;\n             Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), AttrVec::new()))\n         } else {\n             self.parse_literal_maybe_minus()\n@@ -762,9 +762,8 @@ impl<'a> Parser<'a> {\n         // binding mode then we do not end up here, because the lookahead\n         // will direct us over to `parse_enum_variant()`.\n         if self.token == token::OpenDelim(token::Paren) {\n-            return Err(\n-                self.struct_span_err(self.prev_span, \"expected identifier, found enum pattern\")\n-            );\n+            return Err(self\n+                .struct_span_err(self.prev_token.span, \"expected identifier, found enum pattern\"));\n         }\n \n         Ok(PatKind::Ident(binding_mode, ident, sub))\n@@ -826,7 +825,7 @@ impl<'a> Parser<'a> {\n \n             // check that a comma comes after every field\n             if !ate_comma {\n-                let err = self.struct_span_err(self.prev_span, \"expected `,`\");\n+                let err = self.struct_span_err(self.prev_token.span, \"expected `,`\");\n                 if let Some(mut delayed) = delayed_err {\n                     delayed.emit();\n                 }\n@@ -958,7 +957,7 @@ impl<'a> Parser<'a> {\n             let is_ref = self.eat_keyword(kw::Ref);\n             let is_mut = self.eat_keyword(kw::Mut);\n             let fieldname = self.parse_ident()?;\n-            hi = self.prev_span;\n+            hi = self.prev_token.span;\n \n             let bind_type = match (is_ref, is_mut) {\n                 (true, true) => BindingMode::ByRef(Mutability::Mut),"}, {"sha": "355b6429a7494fdc8122120e81b88c766ffeb357", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -50,7 +50,7 @@ impl<'a> Parser<'a> {\n     /// `<T as U>::F::a<S>` (without disambiguator)\n     /// `<T as U>::F::a::<S>` (with disambiguator)\n     pub(super) fn parse_qpath(&mut self, style: PathStyle) -> PResult<'a, (QSelf, Path)> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let ty = self.parse_ty()?;\n \n         // `path` will contain the prefix of the path up to the `>`,\n@@ -61,7 +61,7 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(kw::As) {\n             let path_lo = self.token.span;\n             path = self.parse_path(PathStyle::Type)?;\n-            path_span = path_lo.to(self.prev_span);\n+            path_span = path_lo.to(self.prev_token.span);\n         } else {\n             path_span = self.token.span.to(self.token.span);\n             path = ast::Path { segments: Vec::new(), span: path_span };\n@@ -81,7 +81,7 @@ impl<'a> Parser<'a> {\n         let qself = QSelf { ty, path_span, position: path.segments.len() };\n         self.parse_path_segments(&mut path.segments, style)?;\n \n-        Ok((qself, Path { segments: path.segments, span: lo.to(self.prev_span) }))\n+        Ok((qself, Path { segments: path.segments, span: lo.to(self.prev_token.span) }))\n     }\n \n     /// Recover from an invalid single colon, when the user likely meant a qualified path.\n@@ -103,11 +103,11 @@ impl<'a> Parser<'a> {\n \n         self.diagnostic()\n             .struct_span_err(\n-                self.prev_span,\n+                self.prev_token.span,\n                 \"found single colon before projection in qualified path\",\n             )\n             .span_suggestion(\n-                self.prev_span,\n+                self.prev_token.span,\n                 \"use double colon\",\n                 \"::\".to_string(),\n                 Applicability::MachineApplicable,\n@@ -144,7 +144,7 @@ impl<'a> Parser<'a> {\n         }\n         self.parse_path_segments(&mut segments, style)?;\n \n-        Ok(Path { segments, span: lo.to(self.prev_span) })\n+        Ok(Path { segments, span: lo.to(self.prev_token.span) })\n     }\n \n     pub(super) fn parse_path_segments(\n@@ -221,12 +221,12 @@ impl<'a> Parser<'a> {\n                     let (args, constraints) =\n                         self.parse_generic_args_with_leading_angle_bracket_recovery(style, lo)?;\n                     self.expect_gt()?;\n-                    let span = lo.to(self.prev_span);\n+                    let span = lo.to(self.prev_token.span);\n                     AngleBracketedArgs { args, constraints, span }.into()\n                 } else {\n                     // `(T, U) -> R`\n                     let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n-                    let span = ident.span.to(self.prev_span);\n+                    let span = ident.span.to(self.prev_token.span);\n                     let output = self.parse_ret_ty(AllowPlus::No, RecoverQPath::No)?;\n                     ParenthesizedArgs { inputs, output, span }.into()\n                 };\n@@ -412,13 +412,13 @@ impl<'a> Parser<'a> {\n                     AssocTyConstraintKind::Equality { ty: self.parse_ty()? }\n                 } else if self.eat(&token::Colon) {\n                     AssocTyConstraintKind::Bound {\n-                        bounds: self.parse_generic_bounds(Some(self.prev_span))?,\n+                        bounds: self.parse_generic_bounds(Some(self.prev_token.span))?,\n                     }\n                 } else {\n                     unreachable!();\n                 };\n \n-                let span = lo.to(self.prev_span);\n+                let span = lo.to(self.prev_token.span);\n \n                 // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n                 if let AssocTyConstraintKind::Bound { .. } = kind {\n@@ -473,7 +473,7 @@ impl<'a> Parser<'a> {\n         // lose that information after parsing.\n         if !misplaced_assoc_ty_constraints.is_empty() {\n             let mut err = self.struct_span_err(\n-                args_lo.to(self.prev_span),\n+                args_lo.to(self.prev_token.span),\n                 \"associated type bindings must be declared after generic parameters\",\n             );\n             for span in misplaced_assoc_ty_constraints {"}, {"sha": "e38a7f2f1c2a251b59087a72c0bbe957c840dfd4", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -104,23 +104,23 @@ impl<'a> Parser<'a> {\n         let expr = if self.check(&token::OpenDelim(token::Brace)) {\n             self.parse_struct_expr(lo, path, AttrVec::new())?\n         } else {\n-            let hi = self.prev_span;\n+            let hi = self.prev_token.span;\n             self.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())\n         };\n \n         let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n             let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n             this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n         })?;\n-        Ok(self.mk_stmt(lo.to(self.prev_span), StmtKind::Expr(expr)))\n+        Ok(self.mk_stmt(lo.to(self.prev_token.span), StmtKind::Expr(expr)))\n     }\n \n     /// Parses a statement macro `mac!(args)` provided a `path` representing `mac`.\n     /// At this point, the `!` token after the path has already been eaten.\n     fn parse_stmt_mac(&mut self, lo: Span, attrs: AttrVec, path: ast::Path) -> PResult<'a, Stmt> {\n         let args = self.parse_mac_args()?;\n         let delim = args.delim();\n-        let hi = self.prev_span;\n+        let hi = self.prev_token.span;\n \n         let style =\n             if delim == token::Brace { MacStmtStyle::Braces } else { MacStmtStyle::NoBraces };\n@@ -146,7 +146,7 @@ impl<'a> Parser<'a> {\n     fn error_outer_attrs(&self, attrs: &[Attribute]) {\n         if !attrs.is_empty() {\n             if matches!(self.prev_token.kind, TokenKind::DocComment(..)) {\n-                self.span_fatal_err(self.prev_span, Error::UselessDocComment).emit();\n+                self.span_fatal_err(self.prev_token.span, Error::UselessDocComment).emit();\n             } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n                 self.struct_span_err(self.token.span, \"expected statement after outer attribute\")\n                     .emit();\n@@ -170,19 +170,19 @@ impl<'a> Parser<'a> {\n \n     fn parse_local_mk(&mut self, lo: Span, attrs: AttrVec) -> PResult<'a, Stmt> {\n         let local = self.parse_local(attrs)?;\n-        Ok(self.mk_stmt(lo.to(self.prev_span), StmtKind::Local(local)))\n+        Ok(self.mk_stmt(lo.to(self.prev_token.span), StmtKind::Local(local)))\n     }\n \n     /// Parses a local variable declaration.\n     fn parse_local(&mut self, attrs: AttrVec) -> PResult<'a, P<Local>> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let pat = self.parse_top_pat(GateOr::Yes)?;\n \n         let (err, ty) = if self.eat(&token::Colon) {\n             // Save the state of the parser before parsing type normally, in case there is a `:`\n             // instead of an `=` typo.\n             let parser_snapshot_before_type = self.clone();\n-            let colon_sp = self.prev_span;\n+            let colon_sp = self.prev_token.span;\n             match self.parse_ty() {\n                 Ok(ty) => (None, Some(ty)),\n                 Err(mut err) => {\n@@ -235,7 +235,7 @@ impl<'a> Parser<'a> {\n                 return Err(err);\n             }\n         };\n-        let hi = if self.token == token::Semi { self.token.span } else { self.prev_span };\n+        let hi = if self.token == token::Semi { self.token.span } else { self.prev_token.span };\n         Ok(P(ast::Local { ty, pat, init, id: DUMMY_NODE_ID, span: lo.to(hi), attrs }))\n     }\n \n@@ -287,7 +287,7 @@ impl<'a> Parser<'a> {\n                 }\n                 let stmt_span = if self.eat(&token::Semi) {\n                     // Expand the span to include the semicolon.\n-                    stmt.span.with_hi(self.prev_span.hi())\n+                    stmt.span.with_hi(self.prev_token.span.hi())\n                 } else {\n                     stmt.span\n                 };\n@@ -350,7 +350,7 @@ impl<'a> Parser<'a> {\n                 continue;\n             };\n         }\n-        Ok(self.mk_block(stmts, s, lo.to(self.prev_span)))\n+        Ok(self.mk_block(stmts, s, lo.to(self.prev_token.span)))\n     }\n \n     /// Parses a statement, including the trailing semicolon.\n@@ -393,7 +393,7 @@ impl<'a> Parser<'a> {\n                     e.emit();\n                     self.recover_stmt();\n                     // Don't complain about type errors in body tail after parse error (#57383).\n-                    let sp = expr.span.to(self.prev_span);\n+                    let sp = expr.span.to(self.prev_token.span);\n                     stmt.kind = StmtKind::Expr(self.mk_expr_err(sp));\n                 }\n             }\n@@ -407,7 +407,7 @@ impl<'a> Parser<'a> {\n         if eat_semi && self.eat(&token::Semi) {\n             stmt = stmt.add_trailing_semicolon();\n         }\n-        stmt.span = stmt.span.to(self.prev_span);\n+        stmt.span = stmt.span.to(self.prev_token.span);\n         Ok(Some(stmt))\n     }\n "}, {"sha": "3d2b0c014ac4977ed29a3bdb8921cb5190e99c99", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4439bb09aabee6df4f0ca48552b61ea9d7bc60db/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=4439bb09aabee6df4f0ca48552b61ea9d7bc60db", "patch": "@@ -177,7 +177,7 @@ impl<'a> Parser<'a> {\n             return Err(err);\n         };\n \n-        let span = lo.to(self.prev_span);\n+        let span = lo.to(self.prev_token.span);\n         let ty = self.mk_ty(span, kind);\n \n         // Try to recover from use of `+` with incorrect priority.\n@@ -236,19 +236,19 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, TyKind> {\n         assert_ne!(self.token, token::Question);\n \n-        let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));\n+        let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_token.span));\n         let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n         if parse_plus {\n             self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n-            bounds.append(&mut self.parse_generic_bounds(Some(self.prev_span))?);\n+            bounds.append(&mut self.parse_generic_bounds(Some(self.prev_token.span))?);\n         }\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n     }\n \n     /// Parses a raw pointer type: `*[const | mut] $type`.\n     fn parse_ty_ptr(&mut self) -> PResult<'a, TyKind> {\n         let mutbl = self.parse_const_or_mut().unwrap_or_else(|| {\n-            let span = self.prev_span;\n+            let span = self.prev_token.span;\n             let msg = \"expected mut or const in raw pointer type\";\n             self.struct_span_err(span, msg)\n                 .span_label(span, msg)\n@@ -368,7 +368,7 @@ impl<'a> Parser<'a> {\n     fn error_illegal_c_varadic_ty(&self, lo: Span) {\n         struct_span_err!(\n             self.sess.span_diagnostic,\n-            lo.to(self.prev_span),\n+            lo.to(self.prev_token.span),\n             E0743,\n             \"C-variadic type `...` may not be nested inside another type\",\n         )\n@@ -431,7 +431,7 @@ impl<'a> Parser<'a> {\n         let mut err = self.struct_span_err(negative_bounds, \"negative bounds are not supported\");\n         err.span_label(last_span, \"negative bounds are not supported\");\n         if let Some(bound_list) = colon_span {\n-            let bound_list = bound_list.to(self.prev_span);\n+            let bound_list = bound_list.to(self.prev_token.span);\n             let mut new_bound_list = String::new();\n             if !bounds.is_empty() {\n                 let mut snippets = bounds.iter().map(|bound| self.span_to_snippet(bound.span()));\n@@ -456,7 +456,7 @@ impl<'a> Parser<'a> {\n     /// BOUND = TY_BOUND | LT_BOUND\n     /// ```\n     fn parse_generic_bound(&mut self) -> PResult<'a, Result<GenericBound, Span>> {\n-        let anchor_lo = self.prev_span;\n+        let anchor_lo = self.prev_token.span;\n         let lo = self.token.span;\n         let has_parens = self.eat(&token::OpenDelim(token::Paren));\n         let inner_lo = self.token.span;\n@@ -470,7 +470,7 @@ impl<'a> Parser<'a> {\n             self.parse_generic_ty_bound(lo, has_parens, modifiers)?\n         };\n \n-        Ok(if is_negative { Err(anchor_lo.to(self.prev_span)) } else { Ok(bound) })\n+        Ok(if is_negative { Err(anchor_lo.to(self.prev_token.span)) } else { Ok(bound) })\n     }\n \n     /// Parses a lifetime (\"outlives\") bound, e.g. `'a`, according to:\n@@ -510,15 +510,15 @@ impl<'a> Parser<'a> {\n \n     /// Recover on `('lifetime)` with `(` already eaten.\n     fn recover_paren_lifetime(&mut self, lo: Span, inner_lo: Span) -> PResult<'a, ()> {\n-        let inner_span = inner_lo.to(self.prev_span);\n+        let inner_span = inner_lo.to(self.prev_token.span);\n         self.expect(&token::CloseDelim(token::Paren))?;\n         let mut err = self.struct_span_err(\n-            lo.to(self.prev_span),\n+            lo.to(self.prev_token.span),\n             \"parenthesized lifetime bounds are not supported\",\n         );\n         if let Ok(snippet) = self.span_to_snippet(inner_span) {\n             err.span_suggestion_short(\n-                lo.to(self.prev_span),\n+                lo.to(self.prev_token.span),\n                 \"remove the parentheses\",\n                 snippet,\n                 Applicability::MachineApplicable,\n@@ -541,20 +541,20 @@ impl<'a> Parser<'a> {\n         }\n \n         // `? ...`\n-        let first_question = self.prev_span;\n+        let first_question = self.prev_token.span;\n         if !self.eat_keyword(kw::Const) {\n             return BoundModifiers { maybe: Some(first_question), maybe_const: None };\n         }\n \n         // `?const ...`\n-        let maybe_const = first_question.to(self.prev_span);\n+        let maybe_const = first_question.to(self.prev_token.span);\n         self.sess.gated_spans.gate(sym::const_trait_bound_opt_out, maybe_const);\n         if !self.eat(&token::Question) {\n             return BoundModifiers { maybe: None, maybe_const: Some(maybe_const) };\n         }\n \n         // `?const ? ...`\n-        let second_question = self.prev_span;\n+        let second_question = self.prev_token.span;\n         BoundModifiers { maybe: Some(second_question), maybe_const: Some(maybe_const) }\n     }\n \n@@ -578,7 +578,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let modifier = modifiers.to_trait_bound_modifier();\n-        let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n+        let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_token.span));\n         Ok(GenericBound::Trait(poly_trait, modifier))\n     }\n "}]}