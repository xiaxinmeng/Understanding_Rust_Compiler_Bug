{"sha": "34c5cd9a64d8537236626c4ccbed39a924cd38e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YzVjZDlhNjRkODUzNzIzNjYyNmM0Y2NiZWQzOWE5MjRjZDM4ZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-19T23:04:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-19T23:04:41Z"}, "message": "Auto merge of #73511 - Manishearth:rollup-3iffxd8, r=Manishearth\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #71568 (Document unsafety in slice/sort.rs)\n - #72709 (`#[deny(unsafe_op_in_unsafe_fn)]` in liballoc)\n - #73214 (Add asm!() support for hexagon)\n - #73248 (save_analysis: improve handling of enum struct variant)\n - #73257 (ty: projections in `transparent_newtype_field`)\n - #73261 (Suggest `?Sized` when applicable for ADTs)\n - #73300 (Implement crate-level-only lints checking.)\n - #73334 (Note numeric literals that can never fit in an expected type)\n - #73357 (Use `LocalDefId` for import IDs in trait map)\n - #73364 (asm: Allow multiple template string arguments; interpret them as newline-separated)\n - #73382 (Only display other method receiver candidates if they actually apply)\n - #73465 (Add specialization of `ToString for char`)\n - #73489 (Refactor hir::Place)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "b9b73acf0895861bf6991337643170178e2c890d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9b73acf0895861bf6991337643170178e2c890d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34c5cd9a64d8537236626c4ccbed39a924cd38e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34c5cd9a64d8537236626c4ccbed39a924cd38e2", "html_url": "https://github.com/rust-lang/rust/commit/34c5cd9a64d8537236626c4ccbed39a924cd38e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34c5cd9a64d8537236626c4ccbed39a924cd38e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d8bd9b74dc0cf06d881bac645698ccbcf9d9c5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d8bd9b74dc0cf06d881bac645698ccbcf9d9c5e", "html_url": "https://github.com/rust-lang/rust/commit/2d8bd9b74dc0cf06d881bac645698ccbcf9d9c5e"}, {"sha": "a88182f94b0141a8df54fe86aad07d857baff911", "url": "https://api.github.com/repos/rust-lang/rust/commits/a88182f94b0141a8df54fe86aad07d857baff911", "html_url": "https://github.com/rust-lang/rust/commit/a88182f94b0141a8df54fe86aad07d857baff911"}], "stats": {"total": 3306, "additions": 2503, "deletions": 803}, "files": [{"sha": "a941bc9348f2cde0765ae2feb9d9628904882f25", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 46, "deletions": 24, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -68,10 +68,13 @@ Let us see another example that also uses an input:\n let i: u64 = 3;\n let o: u64;\n unsafe {\n-    asm!(\"\n-        mov {0}, {1}\n-        add {0}, {number}\n-    \", out(reg) o, in(reg) i, number = const 5);\n+    asm!(\n+        \"mov {0}, {1}\",\n+        \"add {0}, {number}\",\n+        out(reg) o,\n+        in(reg) i,\n+        number = const 5,\n+    );\n }\n assert_eq!(o, 8);\n ```\n@@ -82,13 +85,18 @@ and then adding `5` to it.\n \n The example shows a few things:\n \n-First we can see that inputs are declared by writing `in` instead of `out`.\n+First, we can see that `asm!` allows multiple template string arguments; each\n+one is treated as a separate line of assembly code, as if they were all joined\n+together with newlines between them. This makes it easy to format assembly\n+code.\n+\n+Second, we can see that inputs are declared by writing `in` instead of `out`.\n \n-Second one of our operands has a type we haven't seen yet, `const`.\n+Third, one of our operands has a type we haven't seen yet, `const`.\n This tells the compiler to expand this argument to value directly inside the assembly template.\n This is only possible for constants and literals.\n \n-Third we can see that we can specify an argument number, or name as in any format string.\n+Fourth, we can see that we can specify an argument number, or name as in any format string.\n For inline assembly templates this is particularly useful as arguments are often used more than once.\n For more complex inline assembly using this facility is generally recommended, as it improves\n readability, and allows reordering instructions without changing the argument order.\n@@ -137,10 +145,13 @@ let mut a: u64 = 4;\n let b: u64 = 4;\n let c: u64 = 4;\n unsafe {\n-    asm!(\"\n-        add {0}, {1}\n-        add {0}, {2}\n-    \", inout(reg) a, in(reg) b, in(reg) c);\n+    asm!(\n+        \"add {0}, {1}\",\n+        \"add {0}, {2}\",\n+        inout(reg) a,\n+        in(reg) b,\n+        in(reg) c,\n+    );\n }\n assert_eq!(a, 12);\n ```\n@@ -233,7 +244,7 @@ unsafe {\n         // ECX 0 selects the L0 cache information.\n         inout(\"ecx\") 0 => ecx,\n         lateout(\"ebx\") ebx,\n-        lateout(\"edx\") _\n+        lateout(\"edx\") _,\n     );\n }\n \n@@ -255,12 +266,14 @@ This can also be used with a general register class (e.g. `reg`) to obtain a scr\n // Multiply x by 6 using shifts and adds\n let mut x: u64 = 4;\n unsafe {\n-    asm!(\"\n-        mov {tmp}, {x}\n-        shl {tmp}, 1\n-        shl {x}, 2\n-        add {x}, {tmp}\n-    \", x = inout(reg) x, tmp = out(reg) _);\n+    asm!(\n+        \"mov {tmp}, {x}\",\n+        \"shl {tmp}, 1\",\n+        \"shl {x}, 2\",\n+        \"add {x}, {tmp}\",\n+        x = inout(reg) x,\n+        tmp = out(reg) _,\n+    );\n }\n assert_eq!(x, 4 * 6);\n ```\n@@ -338,7 +351,7 @@ unsafe {\n     asm!(\n         \"add {0}, {1}\",\n         inlateout(reg) a, in(reg) b,\n-        options(pure, nomem, nostack)\n+        options(pure, nomem, nostack),\n     );\n }\n assert_eq!(a, 8);\n@@ -371,24 +384,26 @@ reg_operand := dir_spec \"(\" reg_spec \")\" operand_expr\n operand := reg_operand / \"const\" const_expr / \"sym\" path\n option := \"pure\" / \"nomem\" / \"readonly\" / \"preserves_flags\" / \"noreturn\" / \"att_syntax\"\n options := \"options(\" option *[\",\" option] [\",\"] \")\"\n-asm := \"asm!(\" format_string *(\",\" [ident \"=\"] operand) [\",\" options] [\",\"] \")\"\n+asm := \"asm!(\" format_string *(\",\" format_string) *(\",\" [ident \"=\"] operand) [\",\" options] [\",\"] \")\"\n ```\n \n-The macro will initially be supported only on ARM, AArch64, x86, x86-64 and RISC-V targets. Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n+The macro will initially be supported only on ARM, AArch64, Hexagon, x86, x86-64 and RISC-V targets. Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n \n [format-syntax]: https://doc.rust-lang.org/std/fmt/#syntax\n \n-## Template string\n+## Template string arguments\n \n The assembler template uses the same syntax as [format strings][format-syntax] (i.e. placeholders are specified by curly braces). The corresponding arguments are accessed in order, by index, or by name. However, implicit named arguments (introduced by [RFC #2795][rfc-2795]) are not supported.\n \n+An `asm!` invocation may have one or more template string arguments; an `asm!` with multiple template string arguments is treated as if all the strings were concatenated with a `\\n` between them. The expected usage is for each template string argument to correspond to a line of assembly code. All template string arguments must appear before any other arguments.\n+\n As with format strings, named arguments must appear after positional arguments. Explicit register operands must appear at the end of the operand list, after named arguments if any.\n \n Explicit register operands cannot be used by placeholders in the template string. All other named and positional operands must appear at least once in the template string, otherwise a compiler error is generated.\n \n The exact assembly code syntax is target-specific and opaque to the compiler except for the way operands are substituted into the template string to form the code passed to the assembler.\n \n-The 4 targets specified in this RFC (x86, ARM, AArch64, RISC-V) all use the assembly code syntax of the GNU assembler (GAS). On x86, the `.intel_syntax noprefix` mode of GAS is used by default. On ARM, the `.syntax unified` mode is used. These targets impose an additional restriction on the assembly code: any assembler state (e.g. the current section which can be changed with `.section`) must be restored to its original value at the end of the asm string. Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior.\n+The 5 targets specified in this RFC (x86, ARM, AArch64, RISC-V, Hexagon) all use the assembly code syntax of the GNU assembler (GAS). On x86, the `.intel_syntax noprefix` mode of GAS is used by default. On ARM, the `.syntax unified` mode is used. These targets impose an additional restriction on the assembly code: any assembler state (e.g. the current section which can be changed with `.section`) must be restored to its original value at the end of the asm string. Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior.\n \n [rfc-2795]: https://github.com/rust-lang/rfcs/pull/2795\n \n@@ -475,6 +490,7 @@ Here is the list of currently supported register classes:\n | NVPTX | `reg64` | None\\* | `l` |\n | RISC-V | `reg` | `x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E) | `r` |\n | RISC-V | `freg` | `f[0-31]` | `f` |\n+| Hexagon | `reg` | `r[0-28]` | `r` |\n \n > **Note**: On x86 we treat `reg_byte` differently from `reg` because the compiler can allocate `al` and `ah` separately whereas `reg` reserves the whole register.\n >\n@@ -509,6 +525,7 @@ Each register class has constraints on which value types they can be used with.\n | RISC-V64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n | RISC-V | `freg` | `f` | `f32` |\n | RISC-V | `freg` | `d` | `f64` |\n+| Hexagon | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n \n > **Note**: For the purposes of the above table pointers, function pointers and `isize`/`usize` are treated as the equivalent integer type (`i16`/`i32`/`i64` depending on the target).\n \n@@ -565,13 +582,16 @@ Some registers have multiple names. These are all treated by the compiler as ide\n | RISC-V | `f[10-17]` | `fa[0-7]` |\n | RISC-V | `f[18-27]` | `fs[2-11]` |\n | RISC-V | `f[28-31]` | `ft[8-11]` |\n+| Hexagon | `r29` | `sp` |\n+| Hexagon | `r30` | `fr` |\n+| Hexagon | `r31` | `lr` |\n \n Some registers cannot be used for input or output operands:\n \n | Architecture | Unsupported register | Reason |\n | ------------ | -------------------- | ------ |\n | All | `sp` | The stack pointer must be restored to its original value at the end of an asm code block. |\n-| All | `bp` (x86), `r11` (ARM), `x29` (AArch64), `x8` (RISC-V) | The frame pointer cannot be used as an input or output. |\n+| All | `bp` (x86), `r11` (ARM), `x29` (AArch64), `x8` (RISC-V), `fr` (Hexagon) | The frame pointer cannot be used as an input or output. |\n | x86 | `k0` | This is a constant zero register which can't be modified. |\n | x86 | `ip` | This is the program counter, not a real register. |\n | x86 | `mm[0-7]` | MMX registers are not currently supported (but may be in the future). |\n@@ -580,6 +600,7 @@ Some registers cannot be used for input or output operands:\n | ARM | `pc` | This is the program counter, not a real register. |\n | RISC-V | `x0` | This is a constant zero register which can't be modified. |\n | RISC-V | `gp`, `tp` | These registers are reserved and cannot be used as inputs or outputs. |\n+| Hexagon | `lr` | This is the link register which cannot be used as an input or output. |\n \n ## Template modifiers\n \n@@ -625,6 +646,7 @@ The supported modifiers are a subset of LLVM's (and GCC's) [asm template argumen\n | NVPTX | `reg64` | None | `rd0` | None |\n | RISC-V | `reg` | None | `x1` | None |\n | RISC-V | `freg` | None | `f0` | None |\n+| Hexagon | `reg` | None | `r0` | None |\n \n > Notes:\n > - on ARM `e` / `f`: this prints the low or high doubleword register name of a NEON quad (128-bit) register."}, {"sha": "98c7ac3f2ef17cde30f163dfd658c70a0bfeae45", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -77,7 +77,7 @@ pub struct Global;\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n-    __rust_alloc(layout.size(), layout.align())\n+    unsafe { __rust_alloc(layout.size(), layout.align()) }\n }\n \n /// Deallocate memory with the global allocator.\n@@ -99,7 +99,7 @@ pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n-    __rust_dealloc(ptr, layout.size(), layout.align())\n+    unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n }\n \n /// Reallocate memory with the global allocator.\n@@ -121,7 +121,7 @@ pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-    __rust_realloc(ptr, layout.size(), layout.align(), new_size)\n+    unsafe { __rust_realloc(ptr, layout.size(), layout.align(), new_size) }\n }\n \n /// Allocate zero-initialized memory with the global allocator.\n@@ -158,7 +158,7 @@ pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n-    __rust_alloc_zeroed(layout.size(), layout.align())\n+    unsafe { __rust_alloc_zeroed(layout.size(), layout.align()) }\n }\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n@@ -183,7 +183,7 @@ unsafe impl AllocRef for Global {\n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n-            dealloc(ptr.as_ptr(), layout)\n+            unsafe { dealloc(ptr.as_ptr(), layout) }\n         }\n     }\n \n@@ -209,16 +209,21 @@ unsafe impl AllocRef for Global {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if layout.size() == 0 => {\n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_layout =\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n                 self.alloc(new_layout, init)\n             }\n             ReallocPlacement::MayMove => {\n                 // `realloc` probably checks for `new_size > size` or something similar.\n-                intrinsics::assume(new_size > size);\n-                let ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                let ptr = unsafe {\n+                    intrinsics::assume(new_size > size);\n+                    realloc(ptr.as_ptr(), layout, new_size)\n+                };\n                 let memory =\n                     MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-                init.init_offset(memory, size);\n+                unsafe {\n+                    init.init_offset(memory, size);\n+                }\n                 Ok(memory)\n             }\n         }\n@@ -245,13 +250,17 @@ unsafe impl AllocRef for Global {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if new_size == 0 => {\n-                self.dealloc(ptr, layout);\n+                unsafe {\n+                    self.dealloc(ptr, layout);\n+                }\n                 Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n             }\n             ReallocPlacement::MayMove => {\n                 // `realloc` probably checks for `new_size < size` or something similar.\n-                intrinsics::assume(new_size < size);\n-                let ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                let ptr = unsafe {\n+                    intrinsics::assume(new_size < size);\n+                    realloc(ptr.as_ptr(), layout, new_size)\n+                };\n                 Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n             }\n         }\n@@ -264,7 +273,7 @@ unsafe impl AllocRef for Global {\n #[lang = \"exchange_malloc\"]\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n-    let layout = Layout::from_size_align_unchecked(size, align);\n+    let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n     match Global.alloc(layout, AllocInit::Uninitialized) {\n         Ok(memory) => memory.ptr.as_ptr(),\n         Err(_) => handle_alloc_error(layout),\n@@ -279,10 +288,12 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n // For example if `Box` is changed to  `struct Box<T: ?Sized, A: AllocRef>(Unique<T>, A)`,\n // this function has to be changed to `fn box_free<T: ?Sized, A: AllocRef>(Unique<T>, A)` as well.\n pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n-    let size = size_of_val(ptr.as_ref());\n-    let align = min_align_of_val(ptr.as_ref());\n-    let layout = Layout::from_size_align_unchecked(size, align);\n-    Global.dealloc(ptr.cast().into(), layout)\n+    unsafe {\n+        let size = size_of_val(ptr.as_ref());\n+        let align = min_align_of_val(ptr.as_ref());\n+        let layout = Layout::from_size_align_unchecked(size, align);\n+        Global.dealloc(ptr.cast().into(), layout)\n+    }\n }\n \n /// Abort on memory allocation error or failure."}, {"sha": "d10cbf1afab30b9bddff1aecd94bcec1b183da25", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -311,7 +311,7 @@ impl<T> Box<mem::MaybeUninit<T>> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<T> {\n-        Box::from_raw(Box::into_raw(self) as *mut T)\n+        unsafe { Box::from_raw(Box::into_raw(self) as *mut T) }\n     }\n }\n \n@@ -349,7 +349,7 @@ impl<T> Box<[mem::MaybeUninit<T>]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<[T]> {\n-        Box::from_raw(Box::into_raw(self) as *mut [T])\n+        unsafe { Box::from_raw(Box::into_raw(self) as *mut [T]) }\n     }\n }\n \n@@ -393,7 +393,7 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n-        Box(Unique::new_unchecked(raw))\n+        Box(unsafe { Unique::new_unchecked(raw) })\n     }\n \n     /// Consumes the `Box`, returning a wrapped raw pointer."}, {"sha": "15313e333ce732a876646d5fe533b77a58f4d0bf", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -1003,7 +1003,7 @@ impl<'a, T> Hole<'a, T> {\n     unsafe fn new(data: &'a mut [T], pos: usize) -> Self {\n         debug_assert!(pos < data.len());\n         // SAFE: pos should be inside the slice\n-        let elt = ptr::read(data.get_unchecked(pos));\n+        let elt = unsafe { ptr::read(data.get_unchecked(pos)) };\n         Hole { data, elt: ManuallyDrop::new(elt), pos }\n     }\n \n@@ -1025,7 +1025,7 @@ impl<'a, T> Hole<'a, T> {\n     unsafe fn get(&self, index: usize) -> &T {\n         debug_assert!(index != self.pos);\n         debug_assert!(index < self.data.len());\n-        self.data.get_unchecked(index)\n+        unsafe { self.data.get_unchecked(index) }\n     }\n \n     /// Move hole to new location\n@@ -1035,9 +1035,11 @@ impl<'a, T> Hole<'a, T> {\n     unsafe fn move_to(&mut self, index: usize) {\n         debug_assert!(index != self.pos);\n         debug_assert!(index < self.data.len());\n-        let index_ptr: *const _ = self.data.get_unchecked(index);\n-        let hole_ptr = self.data.get_unchecked_mut(self.pos);\n-        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n+        unsafe {\n+            let index_ptr: *const _ = self.data.get_unchecked(index);\n+            let hole_ptr = self.data.get_unchecked_mut(self.pos);\n+            ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n+        }\n         self.pos = index;\n     }\n }"}, {"sha": "2fcc8cc98737d4beb7c93346fd8e9196c9992f6a", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -1725,7 +1725,7 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n         &mut self,\n     ) -> Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>> {\n         let edge = self.cur_leaf_edge.as_ref()?;\n-        ptr::read(edge).next_kv().ok()\n+        unsafe { ptr::read(edge).next_kv().ok() }\n     }\n \n     /// Implementation of a typical `DrainFilter::next` method, given the predicate.\n@@ -1808,7 +1808,7 @@ impl<'a, K, V> Range<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        unwrap_unchecked(self.front.as_mut()).next_unchecked()\n+        unsafe { unwrap_unchecked(self.front.as_mut()).next_unchecked() }\n     }\n }\n \n@@ -1821,7 +1821,7 @@ impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n \n impl<'a, K, V> Range<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        unwrap_unchecked(self.back.as_mut()).next_back_unchecked()\n+        unsafe { unwrap_unchecked(self.back.as_mut()).next_back_unchecked() }\n     }\n }\n \n@@ -1859,7 +1859,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        unwrap_unchecked(self.front.as_mut()).next_unchecked()\n+        unsafe { unwrap_unchecked(self.front.as_mut()).next_unchecked() }\n     }\n }\n \n@@ -1880,7 +1880,7 @@ impl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        unwrap_unchecked(self.back.as_mut()).next_back_unchecked()\n+        unsafe { unwrap_unchecked(self.back.as_mut()).next_back_unchecked() }\n     }\n }\n "}, {"sha": "543ff41a4d48d55fc2b4616f39a8a17cc69c2a87", "filename": "src/liballoc/collections/btree/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -19,7 +19,9 @@ pub unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n         if cfg!(debug_assertions) {\n             panic!(\"'unchecked' unwrap on None in BTreeMap\");\n         } else {\n-            core::intrinsics::unreachable();\n+            unsafe {\n+                core::intrinsics::unreachable();\n+            }\n         }\n     })\n }"}, {"sha": "5478d822438b1ca3afd2f169f7d50422147dbd52", "filename": "src/liballoc/collections/btree/navigate.rs", "status": "modified", "additions": 58, "deletions": 42, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -64,8 +64,10 @@ macro_rules! def_next_kv_uncheched_dealloc {\n                 edge = match edge.$adjacent_kv() {\n                     Ok(internal_kv) => return internal_kv,\n                     Err(last_edge) => {\n-                        let parent_edge = last_edge.into_node().deallocate_and_ascend();\n-                        unwrap_unchecked(parent_edge).forget_node_type()\n+                        unsafe {\n+                            let parent_edge = last_edge.into_node().deallocate_and_ascend();\n+                            unwrap_unchecked(parent_edge).forget_node_type()\n+                        }\n                     }\n                 }\n             }\n@@ -82,9 +84,11 @@ def_next_kv_uncheched_dealloc! {unsafe fn next_back_kv_unchecked_dealloc: left_k\n /// Safety: The change closure must not panic.\n #[inline]\n unsafe fn replace<T, R>(v: &mut T, change: impl FnOnce(T) -> (T, R)) -> R {\n-    let value = ptr::read(v);\n+    let value = unsafe { ptr::read(v) };\n     let (new_value, ret) = change(value);\n-    ptr::write(v, new_value);\n+    unsafe {\n+        ptr::write(v, new_value);\n+    }\n     ret\n }\n \n@@ -93,22 +97,26 @@ impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Ed\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the last one in the tree.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        replace(self, |leaf_edge| {\n-            let kv = leaf_edge.next_kv();\n-            let kv = unwrap_unchecked(kv.ok());\n-            (kv.next_leaf_edge(), kv.into_kv())\n-        })\n+        unsafe {\n+            replace(self, |leaf_edge| {\n+                let kv = leaf_edge.next_kv();\n+                let kv = unwrap_unchecked(kv.ok());\n+                (kv.next_leaf_edge(), kv.into_kv())\n+            })\n+        }\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns references to the\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the first one in the tree.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        replace(self, |leaf_edge| {\n-            let kv = leaf_edge.next_back_kv();\n-            let kv = unwrap_unchecked(kv.ok());\n-            (kv.next_back_leaf_edge(), kv.into_kv())\n-        })\n+        unsafe {\n+            replace(self, |leaf_edge| {\n+                let kv = leaf_edge.next_back_kv();\n+                let kv = unwrap_unchecked(kv.ok());\n+                (kv.next_back_leaf_edge(), kv.into_kv())\n+            })\n+        }\n     }\n }\n \n@@ -119,14 +127,16 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the last one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        let kv = replace(self, |leaf_edge| {\n-            let kv = leaf_edge.next_kv();\n-            let kv = unwrap_unchecked(kv.ok());\n-            (ptr::read(&kv).next_leaf_edge(), kv)\n-        });\n-        // Doing the descend (and perhaps another move) invalidates the references\n-        // returned by `into_kv_mut`, so we have to do this last.\n-        kv.into_kv_mut()\n+        unsafe {\n+            let kv = replace(self, |leaf_edge| {\n+                let kv = leaf_edge.next_kv();\n+                let kv = unwrap_unchecked(kv.ok());\n+                (ptr::read(&kv).next_leaf_edge(), kv)\n+            });\n+            // Doing the descend (and perhaps another move) invalidates the references\n+            // returned by `into_kv_mut`, so we have to do this last.\n+            kv.into_kv_mut()\n+        }\n     }\n \n     /// Moves the leaf edge handle to the previous leaf and returns references to the\n@@ -135,14 +145,16 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the first one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        let kv = replace(self, |leaf_edge| {\n-            let kv = leaf_edge.next_back_kv();\n-            let kv = unwrap_unchecked(kv.ok());\n-            (ptr::read(&kv).next_back_leaf_edge(), kv)\n-        });\n-        // Doing the descend (and perhaps another move) invalidates the references\n-        // returned by `into_kv_mut`, so we have to do this last.\n-        kv.into_kv_mut()\n+        unsafe {\n+            let kv = replace(self, |leaf_edge| {\n+                let kv = leaf_edge.next_back_kv();\n+                let kv = unwrap_unchecked(kv.ok());\n+                (ptr::read(&kv).next_back_leaf_edge(), kv)\n+            });\n+            // Doing the descend (and perhaps another move) invalidates the references\n+            // returned by `into_kv_mut`, so we have to do this last.\n+            kv.into_kv_mut()\n+        }\n     }\n }\n \n@@ -159,12 +171,14 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   if the two preconditions above hold.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n-        replace(self, |leaf_edge| {\n-            let kv = next_kv_unchecked_dealloc(leaf_edge);\n-            let k = ptr::read(kv.reborrow().into_kv().0);\n-            let v = ptr::read(kv.reborrow().into_kv().1);\n-            (kv.next_leaf_edge(), (k, v))\n-        })\n+        unsafe {\n+            replace(self, |leaf_edge| {\n+                let kv = next_kv_unchecked_dealloc(leaf_edge);\n+                let k = ptr::read(kv.reborrow().into_kv().0);\n+                let v = ptr::read(kv.reborrow().into_kv().1);\n+                (kv.next_leaf_edge(), (k, v))\n+            })\n+        }\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns the key\n@@ -179,12 +193,14 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   if the two preconditions above hold.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n-        replace(self, |leaf_edge| {\n-            let kv = next_back_kv_unchecked_dealloc(leaf_edge);\n-            let k = ptr::read(kv.reborrow().into_kv().0);\n-            let v = ptr::read(kv.reborrow().into_kv().1);\n-            (kv.next_back_leaf_edge(), (k, v))\n-        })\n+        unsafe {\n+            replace(self, |leaf_edge| {\n+                let kv = next_back_kv_unchecked_dealloc(leaf_edge);\n+                let k = ptr::read(kv.reborrow().into_kv().0);\n+                let v = ptr::read(kv.reborrow().into_kv().1);\n+                (kv.next_back_leaf_edge(), (k, v))\n+            })\n+        }\n     }\n }\n "}, {"sha": "a4b6cf12a23bd92671d30db8cdc4eaa8b293aeed", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -107,7 +107,7 @@ impl<K, V> InternalNode<K, V> {\n     /// `len` of 0), there must be one initialized and valid edge. This function does not set up\n     /// such an edge.\n     unsafe fn new() -> Self {\n-        InternalNode { data: LeafNode::new(), edges: [MaybeUninit::UNINIT; 2 * B] }\n+        InternalNode { data: unsafe { LeafNode::new() }, edges: [MaybeUninit::UNINIT; 2 * B] }\n     }\n }\n \n@@ -131,7 +131,7 @@ impl<K, V> BoxedNode<K, V> {\n     }\n \n     unsafe fn from_ptr(ptr: NonNull<LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::new_unchecked(ptr.as_ptr()) }\n+        BoxedNode { ptr: unsafe { Unique::new_unchecked(ptr.as_ptr()) } }\n     }\n \n     fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n@@ -392,14 +392,16 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n         let height = self.height;\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(\n-            node.cast(),\n-            if height > 0 {\n-                Layout::new::<InternalNode<K, V>>()\n-            } else {\n-                Layout::new::<LeafNode<K, V>>()\n-            },\n-        );\n+        unsafe {\n+            Global.dealloc(\n+                node.cast(),\n+                if height > 0 {\n+                    Layout::new::<InternalNode<K, V>>()\n+                } else {\n+                    Layout::new::<LeafNode<K, V>>()\n+                },\n+            );\n+        }\n         ret\n     }\n }\n@@ -565,7 +567,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         debug_assert!(first <= self.len());\n         debug_assert!(after_last <= self.len() + 1);\n         for i in first..after_last {\n-            Handle::new_edge(self.reborrow_mut(), i).correct_parent_link();\n+            unsafe { Handle::new_edge(self.reborrow_mut(), i) }.correct_parent_link();\n         }\n     }\n \n@@ -789,7 +791,7 @@ impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeT\n         &mut self,\n     ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NodeType>, HandleType> {\n         // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n-        Handle { node: self.node.reborrow_mut(), idx: self.idx, _marker: PhantomData }\n+        Handle { node: unsafe { self.node.reborrow_mut() }, idx: self.idx, _marker: PhantomData }\n     }\n }\n \n@@ -885,7 +887,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     unsafe fn cast_unchecked<NewType>(\n         &mut self,\n     ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NewType>, marker::Edge> {\n-        Handle::new_edge(self.node.cast_unchecked(), self.idx)\n+        unsafe { Handle::new_edge(self.node.cast_unchecked(), self.idx) }\n     }\n \n     /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n@@ -1330,8 +1332,10 @@ unsafe fn move_kv<K, V>(\n     dest_offset: usize,\n     count: usize,\n ) {\n-    ptr::copy_nonoverlapping(source.0.add(source_offset), dest.0.add(dest_offset), count);\n-    ptr::copy_nonoverlapping(source.1.add(source_offset), dest.1.add(dest_offset), count);\n+    unsafe {\n+        ptr::copy_nonoverlapping(source.0.add(source_offset), dest.0.add(dest_offset), count);\n+        ptr::copy_nonoverlapping(source.1.add(source_offset), dest.1.add(dest_offset), count);\n+    }\n }\n \n // Source and destination must have the same height.\n@@ -1344,8 +1348,10 @@ unsafe fn move_edges<K, V>(\n ) {\n     let source_ptr = source.as_internal_mut().edges.as_mut_ptr();\n     let dest_ptr = dest.as_internal_mut().edges.as_mut_ptr();\n-    ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n-    dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n+    unsafe {\n+        ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n+        dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n+    }\n }\n \n impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n@@ -1459,12 +1465,16 @@ pub mod marker {\n }\n \n unsafe fn slice_insert<T>(slice: &mut [T], idx: usize, val: T) {\n-    ptr::copy(slice.as_ptr().add(idx), slice.as_mut_ptr().add(idx + 1), slice.len() - idx);\n-    ptr::write(slice.get_unchecked_mut(idx), val);\n+    unsafe {\n+        ptr::copy(slice.as_ptr().add(idx), slice.as_mut_ptr().add(idx + 1), slice.len() - idx);\n+        ptr::write(slice.get_unchecked_mut(idx), val);\n+    }\n }\n \n unsafe fn slice_remove<T>(slice: &mut [T], idx: usize) -> T {\n-    let ret = ptr::read(slice.get_unchecked(idx));\n-    ptr::copy(slice.as_ptr().add(idx + 1), slice.as_mut_ptr().add(idx), slice.len() - idx - 1);\n-    ret\n+    unsafe {\n+        let ret = ptr::read(slice.get_unchecked(idx));\n+        ptr::copy(slice.as_ptr().add(idx + 1), slice.as_mut_ptr().add(idx), slice.len() - idx - 1);\n+        ret\n+    }\n }"}, {"sha": "36b5785fdf6c5ed930340eb4b38d772d7dd21f4a", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -225,17 +225,17 @@ impl<T> LinkedList<T> {\n     /// maintain validity of aliasing pointers.\n     #[inline]\n     unsafe fn unlink_node(&mut self, mut node: NonNull<Node<T>>) {\n-        let node = node.as_mut(); // this one is ours now, we can create an &mut.\n+        let node = unsafe { node.as_mut() }; // this one is ours now, we can create an &mut.\n \n         // Not creating new mutable (unique!) references overlapping `element`.\n         match node.prev {\n-            Some(prev) => (*prev.as_ptr()).next = node.next,\n+            Some(prev) => unsafe { (*prev.as_ptr()).next = node.next },\n             // this node is the head node\n             None => self.head = node.next,\n         };\n \n         match node.next {\n-            Some(next) => (*next.as_ptr()).prev = node.prev,\n+            Some(next) => unsafe { (*next.as_ptr()).prev = node.prev },\n             // this node is the tail node\n             None => self.tail = node.prev,\n         };\n@@ -258,17 +258,23 @@ impl<T> LinkedList<T> {\n         // This method takes care not to create multiple mutable references to whole nodes at the same time,\n         // to maintain validity of aliasing pointers into `element`.\n         if let Some(mut existing_prev) = existing_prev {\n-            existing_prev.as_mut().next = Some(splice_start);\n+            unsafe {\n+                existing_prev.as_mut().next = Some(splice_start);\n+            }\n         } else {\n             self.head = Some(splice_start);\n         }\n         if let Some(mut existing_next) = existing_next {\n-            existing_next.as_mut().prev = Some(splice_end);\n+            unsafe {\n+                existing_next.as_mut().prev = Some(splice_end);\n+            }\n         } else {\n             self.tail = Some(splice_end);\n         }\n-        splice_start.as_mut().prev = existing_prev;\n-        splice_end.as_mut().next = existing_next;\n+        unsafe {\n+            splice_start.as_mut().prev = existing_prev;\n+            splice_end.as_mut().next = existing_next;\n+        }\n \n         self.len += splice_length;\n     }\n@@ -297,9 +303,13 @@ impl<T> LinkedList<T> {\n         if let Some(mut split_node) = split_node {\n             let first_part_head;\n             let first_part_tail;\n-            first_part_tail = split_node.as_mut().prev.take();\n+            unsafe {\n+                first_part_tail = split_node.as_mut().prev.take();\n+            }\n             if let Some(mut tail) = first_part_tail {\n-                tail.as_mut().next = None;\n+                unsafe {\n+                    tail.as_mut().next = None;\n+                }\n                 first_part_head = self.head;\n             } else {\n                 first_part_head = None;\n@@ -333,9 +343,13 @@ impl<T> LinkedList<T> {\n         if let Some(mut split_node) = split_node {\n             let second_part_head;\n             let second_part_tail;\n-            second_part_head = split_node.as_mut().next.take();\n+            unsafe {\n+                second_part_head = split_node.as_mut().next.take();\n+            }\n             if let Some(mut head) = second_part_head {\n-                head.as_mut().prev = None;\n+                unsafe {\n+                    head.as_mut().prev = None;\n+                }\n                 second_part_tail = self.tail;\n             } else {\n                 second_part_tail = None;"}, {"sha": "15f3a94ca2d6a84d1dc270114de33daddaa15efc", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 55, "deletions": 25, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -7,6 +7,8 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+// ignore-tidy-filelength\n+\n use core::array::LengthAtMost32;\n use core::cmp::{self, Ordering};\n use core::fmt;\n@@ -201,25 +203,27 @@ impl<T> VecDeque<T> {\n     /// Turn ptr into a slice\n     #[inline]\n     unsafe fn buffer_as_slice(&self) -> &[T] {\n-        slice::from_raw_parts(self.ptr(), self.cap())\n+        unsafe { slice::from_raw_parts(self.ptr(), self.cap()) }\n     }\n \n     /// Turn ptr into a mut slice\n     #[inline]\n     unsafe fn buffer_as_mut_slice(&mut self) -> &mut [T] {\n-        slice::from_raw_parts_mut(self.ptr(), self.cap())\n+        unsafe { slice::from_raw_parts_mut(self.ptr(), self.cap()) }\n     }\n \n     /// Moves an element out of the buffer\n     #[inline]\n     unsafe fn buffer_read(&mut self, off: usize) -> T {\n-        ptr::read(self.ptr().add(off))\n+        unsafe { ptr::read(self.ptr().add(off)) }\n     }\n \n     /// Writes an element into the buffer, moving it.\n     #[inline]\n     unsafe fn buffer_write(&mut self, off: usize, value: T) {\n-        ptr::write(self.ptr().add(off), value);\n+        unsafe {\n+            ptr::write(self.ptr().add(off), value);\n+        }\n     }\n \n     /// Returns `true` if the buffer is at full capacity.\n@@ -268,7 +272,9 @@ impl<T> VecDeque<T> {\n             len,\n             self.cap()\n         );\n-        ptr::copy(self.ptr().add(src), self.ptr().add(dst), len);\n+        unsafe {\n+            ptr::copy(self.ptr().add(src), self.ptr().add(dst), len);\n+        }\n     }\n \n     /// Copies a contiguous block of memory len long from src to dst\n@@ -290,7 +296,9 @@ impl<T> VecDeque<T> {\n             len,\n             self.cap()\n         );\n-        ptr::copy_nonoverlapping(self.ptr().add(src), self.ptr().add(dst), len);\n+        unsafe {\n+            ptr::copy_nonoverlapping(self.ptr().add(src), self.ptr().add(dst), len);\n+        }\n     }\n \n     /// Copies a potentially wrapping block of memory len long from src to dest.\n@@ -330,7 +338,9 @@ impl<T> VecDeque<T> {\n                 // 2 [_ _ A A A A B B _]\n                 //            D . . .\n                 //\n-                self.copy(dst, src, len);\n+                unsafe {\n+                    self.copy(dst, src, len);\n+                }\n             }\n             (false, false, true) => {\n                 // dst before src, src doesn't wrap, dst wraps\n@@ -341,8 +351,10 @@ impl<T> VecDeque<T> {\n                 // 3 [B B B B _ _ _ A A]\n                 //    . .           D .\n                 //\n-                self.copy(dst, src, dst_pre_wrap_len);\n-                self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                unsafe {\n+                    self.copy(dst, src, dst_pre_wrap_len);\n+                    self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                }\n             }\n             (true, false, true) => {\n                 // src before dst, src doesn't wrap, dst wraps\n@@ -353,8 +365,10 @@ impl<T> VecDeque<T> {\n                 // 3 [B B _ _ _ A A A A]\n                 //    . .           D .\n                 //\n-                self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n-                self.copy(dst, src, dst_pre_wrap_len);\n+                unsafe {\n+                    self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                    self.copy(dst, src, dst_pre_wrap_len);\n+                }\n             }\n             (false, true, false) => {\n                 // dst before src, src wraps, dst doesn't wrap\n@@ -365,8 +379,10 @@ impl<T> VecDeque<T> {\n                 // 3 [C C _ _ _ B B C C]\n                 //              D . . .\n                 //\n-                self.copy(dst, src, src_pre_wrap_len);\n-                self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                unsafe {\n+                    self.copy(dst, src, src_pre_wrap_len);\n+                    self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                }\n             }\n             (true, true, false) => {\n                 // src before dst, src wraps, dst doesn't wrap\n@@ -377,8 +393,10 @@ impl<T> VecDeque<T> {\n                 // 3 [C C A A _ _ _ C C]\n                 //    D . . .\n                 //\n-                self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n-                self.copy(dst, src, src_pre_wrap_len);\n+                unsafe {\n+                    self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                    self.copy(dst, src, src_pre_wrap_len);\n+                }\n             }\n             (false, true, true) => {\n                 // dst before src, src wraps, dst wraps\n@@ -392,9 +410,11 @@ impl<T> VecDeque<T> {\n                 //\n                 debug_assert!(dst_pre_wrap_len > src_pre_wrap_len);\n                 let delta = dst_pre_wrap_len - src_pre_wrap_len;\n-                self.copy(dst, src, src_pre_wrap_len);\n-                self.copy(dst + src_pre_wrap_len, 0, delta);\n-                self.copy(0, delta, len - dst_pre_wrap_len);\n+                unsafe {\n+                    self.copy(dst, src, src_pre_wrap_len);\n+                    self.copy(dst + src_pre_wrap_len, 0, delta);\n+                    self.copy(0, delta, len - dst_pre_wrap_len);\n+                }\n             }\n             (true, true, true) => {\n                 // src before dst, src wraps, dst wraps\n@@ -408,9 +428,11 @@ impl<T> VecDeque<T> {\n                 //\n                 debug_assert!(src_pre_wrap_len > dst_pre_wrap_len);\n                 let delta = src_pre_wrap_len - dst_pre_wrap_len;\n-                self.copy(delta, 0, len - src_pre_wrap_len);\n-                self.copy(0, self.cap() - delta, delta);\n-                self.copy(dst, src, dst_pre_wrap_len);\n+                unsafe {\n+                    self.copy(delta, 0, len - src_pre_wrap_len);\n+                    self.copy(0, self.cap() - delta, delta);\n+                    self.copy(dst, src, dst_pre_wrap_len);\n+                }\n             }\n         }\n     }\n@@ -440,13 +462,17 @@ impl<T> VecDeque<T> {\n             // Nop\n         } else if self.head < old_capacity - self.tail {\n             // B\n-            self.copy_nonoverlapping(old_capacity, 0, self.head);\n+            unsafe {\n+                self.copy_nonoverlapping(old_capacity, 0, self.head);\n+            }\n             self.head += old_capacity;\n             debug_assert!(self.head > self.tail);\n         } else {\n             // C\n             let new_tail = new_capacity - (old_capacity - self.tail);\n-            self.copy_nonoverlapping(new_tail, self.tail, old_capacity - self.tail);\n+            unsafe {\n+                self.copy_nonoverlapping(new_tail, self.tail, old_capacity - self.tail);\n+            }\n             self.tail = new_tail;\n             debug_assert!(self.head < self.tail);\n         }\n@@ -2297,7 +2323,9 @@ impl<T> VecDeque<T> {\n \n     unsafe fn rotate_left_inner(&mut self, mid: usize) {\n         debug_assert!(mid * 2 <= self.len());\n-        self.wrap_copy(self.head, self.tail, mid);\n+        unsafe {\n+            self.wrap_copy(self.head, self.tail, mid);\n+        }\n         self.head = self.wrap_add(self.head, mid);\n         self.tail = self.wrap_add(self.tail, mid);\n     }\n@@ -2306,7 +2334,9 @@ impl<T> VecDeque<T> {\n         debug_assert!(k * 2 <= self.len());\n         self.head = self.wrap_sub(self.head, k);\n         self.tail = self.wrap_sub(self.tail, k);\n-        self.wrap_copy(self.tail, self.head, k);\n+        unsafe {\n+            self.wrap_copy(self.tail, self.head, k);\n+        }\n     }\n }\n "}, {"sha": "41c2b221704e67ffb9e358e3174e418658df083b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -72,6 +72,7 @@\n #![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n #![allow(explicit_outlives_requirements)]\n #![allow(incomplete_features)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n #![feature(allocator_api)]\n@@ -118,6 +119,7 @@\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unicode_internals)]\n+#![feature(unsafe_block_in_unsafe_fn)]\n #![feature(unsize)]\n #![feature(unsized_locals)]\n #![feature(allocator_internals)]"}, {"sha": "15e81f9288722e0f5786ddf0a9ebf6b04cf422e8", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -108,7 +108,7 @@ impl<T> RawVec<T, Global> {\n     /// If the `ptr` and `capacity` come from a `RawVec`, then this is guaranteed.\n     #[inline]\n     pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n-        Self::from_raw_parts_in(ptr, capacity, Global)\n+        unsafe { Self::from_raw_parts_in(ptr, capacity, Global) }\n     }\n \n     /// Converts a `Box<[T]>` into a `RawVec<T>`.\n@@ -139,8 +139,10 @@ impl<T> RawVec<T, Global> {\n         );\n \n         let me = ManuallyDrop::new(self);\n-        let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n-        Box::from_raw(slice)\n+        unsafe {\n+            let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n+            Box::from_raw(slice)\n+        }\n     }\n }\n \n@@ -192,7 +194,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n     #[inline]\n     pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n-        Self { ptr: Unique::new_unchecked(ptr), cap: capacity, alloc: a }\n+        Self { ptr: unsafe { Unique::new_unchecked(ptr) }, cap: capacity, alloc: a }\n     }\n \n     /// Gets a raw pointer to the start of the allocation. Note that this is"}, {"sha": "6418c4a9823f20665b4b4dc0aa9a3d4fdbbb6d8b", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -35,7 +35,7 @@ fn allocator_param() {\n             }\n         }\n         unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-            Global.dealloc(ptr, layout)\n+            unsafe { Global.dealloc(ptr, layout) }\n         }\n     }\n "}, {"sha": "4d50ae9efca9532eb717f17db20985e2541e233e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 51, "deletions": 39, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -304,7 +304,7 @@ impl<T: ?Sized> Rc<T> {\n     }\n \n     unsafe fn from_ptr(ptr: *mut RcBox<T>) -> Self {\n-        Self::from_inner(NonNull::new_unchecked(ptr))\n+        Self::from_inner(unsafe { NonNull::new_unchecked(ptr) })\n     }\n }\n \n@@ -544,7 +544,7 @@ impl<T> Rc<[mem::MaybeUninit<T>]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Rc<[T]> {\n-        Rc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+        unsafe { Rc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _) }\n     }\n }\n \n@@ -643,13 +643,13 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        let offset = data_offset(ptr);\n+        let offset = unsafe { data_offset(ptr) };\n \n         // Reverse the offset to find the original RcBox.\n         let fake_ptr = ptr as *mut RcBox<T>;\n-        let rc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+        let rc_ptr = unsafe { set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset)) };\n \n-        Self::from_ptr(rc_ptr)\n+        unsafe { Self::from_ptr(rc_ptr) }\n     }\n \n     /// Consumes the `Rc`, returning the wrapped pointer as `NonNull<T>`.\n@@ -805,7 +805,7 @@ impl<T: ?Sized> Rc<T> {\n     #[inline]\n     #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n     pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n-        &mut this.ptr.as_mut().value\n+        unsafe { &mut this.ptr.as_mut().value }\n     }\n \n     #[inline]\n@@ -964,20 +964,24 @@ impl<T: ?Sized> Rc<T> {\n \n         // Initialize the RcBox\n         let inner = mem_to_rcbox(mem.ptr.as_ptr());\n-        debug_assert_eq!(Layout::for_value(&*inner), layout);\n+        unsafe {\n+            debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n-        ptr::write(&mut (*inner).strong, Cell::new(1));\n-        ptr::write(&mut (*inner).weak, Cell::new(1));\n+            ptr::write(&mut (*inner).strong, Cell::new(1));\n+            ptr::write(&mut (*inner).weak, Cell::new(1));\n+        }\n \n         inner\n     }\n \n     /// Allocates an `RcBox<T>` with sufficient space for an unsized inner value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n-        Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n-            set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>\n-        })\n+        unsafe {\n+            Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n+                set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>\n+            })\n+        }\n     }\n \n     fn from_box(v: Box<T>) -> Rc<T> {\n@@ -1006,9 +1010,11 @@ impl<T: ?Sized> Rc<T> {\n impl<T> Rc<[T]> {\n     /// Allocates an `RcBox<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n-        Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n-            ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>\n-        })\n+        unsafe {\n+            Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n+                ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>\n+            })\n+        }\n     }\n }\n \n@@ -1017,7 +1023,9 @@ impl<T> Rc<[T]> {\n /// For a slice/trait object, this sets the `data` field and leaves the rest\n /// unchanged. For a sized raw pointer, this simply sets the pointer.\n unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n-    ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    unsafe {\n+        ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    }\n     ptr\n }\n \n@@ -1026,11 +1034,11 @@ impl<T> Rc<[T]> {\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`\n     unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {\n-        let ptr = Self::allocate_for_slice(v.len());\n-\n-        ptr::copy_nonoverlapping(v.as_ptr(), &mut (*ptr).value as *mut [T] as *mut T, v.len());\n-\n-        Self::from_ptr(ptr)\n+        unsafe {\n+            let ptr = Self::allocate_for_slice(v.len());\n+            ptr::copy_nonoverlapping(v.as_ptr(), &mut (*ptr).value as *mut [T] as *mut T, v.len());\n+            Self::from_ptr(ptr)\n+        }\n     }\n \n     /// Constructs an `Rc<[T]>` from an iterator known to be of a certain size.\n@@ -1058,25 +1066,27 @@ impl<T> Rc<[T]> {\n             }\n         }\n \n-        let ptr = Self::allocate_for_slice(len);\n+        unsafe {\n+            let ptr = Self::allocate_for_slice(len);\n \n-        let mem = ptr as *mut _ as *mut u8;\n-        let layout = Layout::for_value(&*ptr);\n+            let mem = ptr as *mut _ as *mut u8;\n+            let layout = Layout::for_value(&*ptr);\n \n-        // Pointer to first element\n-        let elems = &mut (*ptr).value as *mut [T] as *mut T;\n+            // Pointer to first element\n+            let elems = &mut (*ptr).value as *mut [T] as *mut T;\n \n-        let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };\n+            let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };\n \n-        for (i, item) in iter.enumerate() {\n-            ptr::write(elems.add(i), item);\n-            guard.n_elems += 1;\n-        }\n+            for (i, item) in iter.enumerate() {\n+                ptr::write(elems.add(i), item);\n+                guard.n_elems += 1;\n+            }\n \n-        // All clear. Forget the guard so it doesn't free the new RcBox.\n-        forget(guard);\n+            // All clear. Forget the guard so it doesn't free the new RcBox.\n+            forget(guard);\n \n-        Self::from_ptr(ptr)\n+            Self::from_ptr(ptr)\n+        }\n     }\n }\n \n@@ -1786,10 +1796,12 @@ impl<T> Weak<T> {\n             Self::new()\n         } else {\n             // See Rc::from_raw for details\n-            let offset = data_offset(ptr);\n-            let fake_ptr = ptr as *mut RcBox<T>;\n-            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n-            Weak { ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\") }\n+            unsafe {\n+                let offset = data_offset(ptr);\n+                let fake_ptr = ptr as *mut RcBox<T>;\n+                let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+                Weak { ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\") }\n+            }\n         }\n     }\n }\n@@ -2106,7 +2118,7 @@ unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     // Because it is ?Sized, it will always be the last field in memory.\n     // Note: This is a detail of the current implementation of the compiler,\n     // and is not a guaranteed language detail. Do not rely on it outside of std.\n-    data_offset_align(align_of_val(&*ptr))\n+    unsafe { data_offset_align(align_of_val(&*ptr)) }\n }\n \n /// Computes the offset of the data field within `RcBox`."}, {"sha": "d7dc2174d665f3bce0a3ebb5da7da0b328b1576e", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -831,8 +831,7 @@ where\n {\n     let len = v.len();\n     let v = v.as_mut_ptr();\n-    let v_mid = v.add(mid);\n-    let v_end = v.add(len);\n+    let (v_mid, v_end) = unsafe { (v.add(mid), v.add(len)) };\n \n     // The merge process first copies the shorter run into `buf`. Then it traces the newly copied\n     // run and the longer run forwards (or backwards), comparing their next unconsumed elements and\n@@ -855,8 +854,10 @@ where\n \n     if mid <= len - mid {\n         // The left run is shorter.\n-        ptr::copy_nonoverlapping(v, buf, mid);\n-        hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n+        unsafe {\n+            ptr::copy_nonoverlapping(v, buf, mid);\n+            hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n+        }\n \n         // Initially, these pointers point to the beginnings of their arrays.\n         let left = &mut hole.start;\n@@ -866,17 +867,21 @@ where\n         while *left < hole.end && right < v_end {\n             // Consume the lesser side.\n             // If equal, prefer the left run to maintain stability.\n-            let to_copy = if is_less(&*right, &**left) {\n-                get_and_increment(&mut right)\n-            } else {\n-                get_and_increment(left)\n-            };\n-            ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n+            unsafe {\n+                let to_copy = if is_less(&*right, &**left) {\n+                    get_and_increment(&mut right)\n+                } else {\n+                    get_and_increment(left)\n+                };\n+                ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n+            }\n         }\n     } else {\n         // The right run is shorter.\n-        ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n-        hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n+        unsafe {\n+            ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n+            hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n+        }\n \n         // Initially, these pointers point past the ends of their arrays.\n         let left = &mut hole.dest;\n@@ -886,25 +891,27 @@ where\n         while v < *left && buf < *right {\n             // Consume the greater side.\n             // If equal, prefer the right run to maintain stability.\n-            let to_copy = if is_less(&*right.offset(-1), &*left.offset(-1)) {\n-                decrement_and_get(left)\n-            } else {\n-                decrement_and_get(right)\n-            };\n-            ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n+            unsafe {\n+                let to_copy = if is_less(&*right.offset(-1), &*left.offset(-1)) {\n+                    decrement_and_get(left)\n+                } else {\n+                    decrement_and_get(right)\n+                };\n+                ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n+            }\n         }\n     }\n     // Finally, `hole` gets dropped. If the shorter run was not fully consumed, whatever remains of\n     // it will now be copied into the hole in `v`.\n \n     unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n         let old = *ptr;\n-        *ptr = ptr.offset(1);\n+        *ptr = unsafe { ptr.offset(1) };\n         old\n     }\n \n     unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n-        *ptr = ptr.offset(-1);\n+        *ptr = unsafe { ptr.offset(-1) };\n         *ptr\n     }\n "}, {"sha": "57927c688479b5f72746d6220b271f58dd2c7e41", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -583,5 +583,5 @@ impl str {\n #[stable(feature = \"str_box_extras\", since = \"1.20.0\")]\n #[inline]\n pub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {\n-    Box::from_raw(Box::into_raw(v) as *mut str)\n+    unsafe { Box::from_raw(Box::into_raw(v) as *mut str) }\n }"}, {"sha": "64d9692244dde2ce0ebaefca78196c2dc029fdd6", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -724,7 +724,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(buf: *mut u8, length: usize, capacity: usize) -> String {\n-        String { vec: Vec::from_raw_parts(buf, length, capacity) }\n+        unsafe { String { vec: Vec::from_raw_parts(buf, length, capacity) } }\n     }\n \n     /// Converts a vector of bytes to a `String` without checking that the\n@@ -1329,9 +1329,11 @@ impl String {\n         let amt = bytes.len();\n         self.vec.reserve(amt);\n \n-        ptr::copy(self.vec.as_ptr().add(idx), self.vec.as_mut_ptr().add(idx + amt), len - idx);\n-        ptr::copy(bytes.as_ptr(), self.vec.as_mut_ptr().add(idx), amt);\n-        self.vec.set_len(len + amt);\n+        unsafe {\n+            ptr::copy(self.vec.as_ptr().add(idx), self.vec.as_mut_ptr().add(idx + amt), len - idx);\n+            ptr::copy(bytes.as_ptr(), self.vec.as_mut_ptr().add(idx), amt);\n+            self.vec.set_len(len + amt);\n+        }\n     }\n \n     /// Inserts a string slice into this `String` at a byte position.\n@@ -2228,6 +2230,14 @@ impl<T: fmt::Display + ?Sized> ToString for T {\n     }\n }\n \n+#[stable(feature = \"char_to_string_specialization\", since = \"1.46.0\")]\n+impl ToString for char {\n+    #[inline]\n+    fn to_string(&self) -> String {\n+        String::from(self.encode_utf8(&mut [0; 4]))\n+    }\n+}\n+\n #[stable(feature = \"str_to_string_specialization\", since = \"1.9.0\")]\n impl ToString for str {\n     #[inline]"}, {"sha": "826f0c8fa833fbf001e0aacb434ccddeab100e66", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 58, "deletions": 42, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -232,7 +232,7 @@ impl<T: ?Sized> Arc<T> {\n     }\n \n     unsafe fn from_ptr(ptr: *mut ArcInner<T>) -> Self {\n-        Self::from_inner(NonNull::new_unchecked(ptr))\n+        unsafe { Self::from_inner(NonNull::new_unchecked(ptr)) }\n     }\n }\n \n@@ -543,7 +543,7 @@ impl<T> Arc<[mem::MaybeUninit<T>]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Arc<[T]> {\n-        Arc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+        unsafe { Arc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _) }\n     }\n }\n \n@@ -642,13 +642,15 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        let offset = data_offset(ptr);\n+        unsafe {\n+            let offset = data_offset(ptr);\n \n-        // Reverse the offset to find the original ArcInner.\n-        let fake_ptr = ptr as *mut ArcInner<T>;\n-        let arc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            // Reverse the offset to find the original ArcInner.\n+            let fake_ptr = ptr as *mut ArcInner<T>;\n+            let arc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n \n-        Self::from_ptr(arc_ptr)\n+            Self::from_ptr(arc_ptr)\n+        }\n     }\n \n     /// Consumes the `Arc`, returning the wrapped pointer as `NonNull<T>`.\n@@ -807,7 +809,7 @@ impl<T: ?Sized> Arc<T> {\n     #[unstable(feature = \"arc_mutate_strong_count\", issue = \"71983\")]\n     pub unsafe fn incr_strong_count(ptr: *const T) {\n         // Retain Arc, but don't touch refcount by wrapping in ManuallyDrop\n-        let arc = mem::ManuallyDrop::new(Arc::<T>::from_raw(ptr));\n+        let arc = unsafe { mem::ManuallyDrop::new(Arc::<T>::from_raw(ptr)) };\n         // Now increase refcount, but don't drop new refcount either\n         let _arc_clone: mem::ManuallyDrop<_> = arc.clone();\n     }\n@@ -847,7 +849,7 @@ impl<T: ?Sized> Arc<T> {\n     #[inline]\n     #[unstable(feature = \"arc_mutate_strong_count\", issue = \"71983\")]\n     pub unsafe fn decr_strong_count(ptr: *const T) {\n-        mem::drop(Arc::from_raw(ptr));\n+        unsafe { mem::drop(Arc::from_raw(ptr)) };\n     }\n \n     #[inline]\n@@ -865,7 +867,7 @@ impl<T: ?Sized> Arc<T> {\n     unsafe fn drop_slow(&mut self) {\n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n-        ptr::drop_in_place(Self::get_mut_unchecked(self));\n+        unsafe { ptr::drop_in_place(Self::get_mut_unchecked(self)) };\n \n         // Drop the weak ref collectively held by all strong references\n         drop(Weak { ptr: self.ptr });\n@@ -917,20 +919,24 @@ impl<T: ?Sized> Arc<T> {\n \n         // Initialize the ArcInner\n         let inner = mem_to_arcinner(mem.ptr.as_ptr());\n-        debug_assert_eq!(Layout::for_value(&*inner), layout);\n+        debug_assert_eq!(unsafe { Layout::for_value(&*inner) }, layout);\n \n-        ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n-        ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n+        unsafe {\n+            ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n+            ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n+        }\n \n         inner\n     }\n \n     /// Allocates an `ArcInner<T>` with sufficient space for an unsized inner value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n-        Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n-            set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>\n-        })\n+        unsafe {\n+            Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n+                set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>\n+            })\n+        }\n     }\n \n     fn from_box(v: Box<T>) -> Arc<T> {\n@@ -959,9 +965,11 @@ impl<T: ?Sized> Arc<T> {\n impl<T> Arc<[T]> {\n     /// Allocates an `ArcInner<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {\n-        Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n-            ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>\n-        })\n+        unsafe {\n+            Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n+                ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>\n+            })\n+        }\n     }\n }\n \n@@ -970,7 +978,9 @@ impl<T> Arc<[T]> {\n /// For a slice/trait object, this sets the `data` field and leaves the rest\n /// unchanged. For a sized raw pointer, this simply sets the pointer.\n unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n-    ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    unsafe {\n+        ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    }\n     ptr\n }\n \n@@ -979,11 +989,13 @@ impl<T> Arc<[T]> {\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`.\n     unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {\n-        let ptr = Self::allocate_for_slice(v.len());\n+        unsafe {\n+            let ptr = Self::allocate_for_slice(v.len());\n \n-        ptr::copy_nonoverlapping(v.as_ptr(), &mut (*ptr).data as *mut [T] as *mut T, v.len());\n+            ptr::copy_nonoverlapping(v.as_ptr(), &mut (*ptr).data as *mut [T] as *mut T, v.len());\n \n-        Self::from_ptr(ptr)\n+            Self::from_ptr(ptr)\n+        }\n     }\n \n     /// Constructs an `Arc<[T]>` from an iterator known to be of a certain size.\n@@ -1011,25 +1023,27 @@ impl<T> Arc<[T]> {\n             }\n         }\n \n-        let ptr = Self::allocate_for_slice(len);\n+        unsafe {\n+            let ptr = Self::allocate_for_slice(len);\n \n-        let mem = ptr as *mut _ as *mut u8;\n-        let layout = Layout::for_value(&*ptr);\n+            let mem = ptr as *mut _ as *mut u8;\n+            let layout = Layout::for_value(&*ptr);\n \n-        // Pointer to first element\n-        let elems = &mut (*ptr).data as *mut [T] as *mut T;\n+            // Pointer to first element\n+            let elems = &mut (*ptr).data as *mut [T] as *mut T;\n \n-        let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };\n+            let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };\n \n-        for (i, item) in iter.enumerate() {\n-            ptr::write(elems.add(i), item);\n-            guard.n_elems += 1;\n-        }\n+            for (i, item) in iter.enumerate() {\n+                ptr::write(elems.add(i), item);\n+                guard.n_elems += 1;\n+            }\n \n-        // All clear. Forget the guard so it doesn't free the new ArcInner.\n-        mem::forget(guard);\n+            // All clear. Forget the guard so it doesn't free the new ArcInner.\n+            mem::forget(guard);\n \n-        Self::from_ptr(ptr)\n+            Self::from_ptr(ptr)\n+        }\n     }\n }\n \n@@ -1274,7 +1288,7 @@ impl<T: ?Sized> Arc<T> {\n     pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n         // We are careful to *not* create a reference covering the \"count\" fields, as\n         // this would alias with concurrent access to the reference counts (e.g. by `Weak`).\n-        &mut (*this.ptr.as_ptr()).data\n+        unsafe { &mut (*this.ptr.as_ptr()).data }\n     }\n \n     /// Determine whether this is the unique reference (including weak refs) to\n@@ -1551,10 +1565,12 @@ impl<T> Weak<T> {\n             Self::new()\n         } else {\n             // See Arc::from_raw for details\n-            let offset = data_offset(ptr);\n-            let fake_ptr = ptr as *mut ArcInner<T>;\n-            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n-            Weak { ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\") }\n+            unsafe {\n+                let offset = data_offset(ptr);\n+                let fake_ptr = ptr as *mut ArcInner<T>;\n+                let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+                Weak { ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\") }\n+            }\n         }\n     }\n }\n@@ -2260,7 +2276,7 @@ unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     // Because it is `?Sized`, it will always be the last field in memory.\n     // Note: This is a detail of the current implementation of the compiler,\n     // and is not a guaranteed language detail. Do not rely on it outside of std.\n-    data_offset_align(align_of_val(&*ptr))\n+    unsafe { data_offset_align(align_of_val(&*ptr)) }\n }\n \n /// Computes the offset of the data field within `ArcInner`."}, {"sha": "0d1cc99df47c552e24bccd7b7e22bd63b7ddd352", "filename": "src/liballoc/task.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -60,7 +60,7 @@ impl<W: Wake + Send + Sync + 'static> From<Arc<W>> for RawWaker {\n fn raw_waker<W: Wake + Send + Sync + 'static>(waker: Arc<W>) -> RawWaker {\n     // Increment the reference count of the arc to clone it.\n     unsafe fn clone_waker<W: Wake + Send + Sync + 'static>(waker: *const ()) -> RawWaker {\n-        Arc::incr_strong_count(waker as *const W);\n+        unsafe { Arc::incr_strong_count(waker as *const W) };\n         RawWaker::new(\n             waker as *const (),\n             &RawWakerVTable::new(clone_waker::<W>, wake::<W>, wake_by_ref::<W>, drop_waker::<W>),\n@@ -69,19 +69,20 @@ fn raw_waker<W: Wake + Send + Sync + 'static>(waker: Arc<W>) -> RawWaker {\n \n     // Wake by value, moving the Arc into the Wake::wake function\n     unsafe fn wake<W: Wake + Send + Sync + 'static>(waker: *const ()) {\n-        let waker: Arc<W> = Arc::from_raw(waker as *const W);\n+        let waker: Arc<W> = unsafe { Arc::from_raw(waker as *const W) };\n         <W as Wake>::wake(waker);\n     }\n \n     // Wake by reference, wrap the waker in ManuallyDrop to avoid dropping it\n     unsafe fn wake_by_ref<W: Wake + Send + Sync + 'static>(waker: *const ()) {\n-        let waker: ManuallyDrop<Arc<W>> = ManuallyDrop::new(Arc::from_raw(waker as *const W));\n+        let waker: ManuallyDrop<Arc<W>> =\n+            unsafe { ManuallyDrop::new(Arc::from_raw(waker as *const W)) };\n         <W as Wake>::wake_by_ref(&waker);\n     }\n \n     // Decrement the reference count of the Arc on drop\n     unsafe fn drop_waker<W: Wake + Send + Sync + 'static>(waker: *const ()) {\n-        Arc::decr_strong_count(waker as *const W);\n+        unsafe { Arc::decr_strong_count(waker as *const W) };\n     }\n \n     RawWaker::new("}, {"sha": "95c3b3b18616162feddc05e81bb2ec54f2863bfd", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -465,7 +465,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -> Vec<T> {\n-        Vec { buf: RawVec::from_raw_parts(ptr, capacity), len: length }\n+        unsafe { Vec { buf: RawVec::from_raw_parts(ptr, capacity), len: length } }\n     }\n \n     /// Returns the number of elements the vector can hold without\n@@ -1264,10 +1264,10 @@ impl<T> Vec<T> {\n     /// Appends elements to `Self` from other buffer.\n     #[inline]\n     unsafe fn append_elements(&mut self, other: *const [T]) {\n-        let count = (*other).len();\n+        let count = unsafe { (*other).len() };\n         self.reserve(count);\n         let len = self.len();\n-        ptr::copy_nonoverlapping(other as *const T, self.as_mut_ptr().add(len), count);\n+        unsafe { ptr::copy_nonoverlapping(other as *const T, self.as_mut_ptr().add(len), count) };\n         self.len += count;\n     }\n \n@@ -2965,15 +2965,16 @@ impl<T> Drain<'_, T> {\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n     /// Returns `true` if we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n     unsafe fn fill<I: Iterator<Item = T>>(&mut self, replace_with: &mut I) -> bool {\n-        let vec = self.vec.as_mut();\n+        let vec = unsafe { self.vec.as_mut() };\n         let range_start = vec.len;\n         let range_end = self.tail_start;\n-        let range_slice =\n-            slice::from_raw_parts_mut(vec.as_mut_ptr().add(range_start), range_end - range_start);\n+        let range_slice = unsafe {\n+            slice::from_raw_parts_mut(vec.as_mut_ptr().add(range_start), range_end - range_start)\n+        };\n \n         for place in range_slice {\n             if let Some(new_item) = replace_with.next() {\n-                ptr::write(place, new_item);\n+                unsafe { ptr::write(place, new_item) };\n                 vec.len += 1;\n             } else {\n                 return false;\n@@ -2984,14 +2985,16 @@ impl<T> Drain<'_, T> {\n \n     /// Makes room for inserting more elements before the tail.\n     unsafe fn move_tail(&mut self, additional: usize) {\n-        let vec = self.vec.as_mut();\n+        let vec = unsafe { self.vec.as_mut() };\n         let len = self.tail_start + self.tail_len;\n         vec.buf.reserve(len, additional);\n \n         let new_tail_start = self.tail_start + additional;\n-        let src = vec.as_ptr().add(self.tail_start);\n-        let dst = vec.as_mut_ptr().add(new_tail_start);\n-        ptr::copy(src, dst, self.tail_len);\n+        unsafe {\n+            let src = vec.as_ptr().add(self.tail_start);\n+            let dst = vec.as_mut_ptr().add(new_tail_start);\n+            ptr::copy(src, dst, self.tail_len);\n+        }\n         self.tail_start = new_tail_start;\n     }\n }"}, {"sha": "8b2ac294764ff5aa49fc17796b45a1a8f651910d", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 70, "deletions": 3, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -1,6 +1,6 @@\n //! Slice sorting\n //!\n-//! This module contains an sort algorithm based on Orson Peters' pattern-defeating quicksort,\n+//! This module contains a sorting algorithm based on Orson Peters' pattern-defeating quicksort,\n //! published at: https://github.com/orlp/pdqsort\n //!\n //! Unstable sorting is compatible with libcore because it doesn't allocate memory, unlike our\n@@ -20,6 +20,9 @@ struct CopyOnDrop<T> {\n \n impl<T> Drop for CopyOnDrop<T> {\n     fn drop(&mut self) {\n+        // SAFETY:  This is a helper class.\n+        //          Please refer to its usage for correctness.\n+        //          Namely, one must be sure that `src` and `dst` does not overlap as required by `ptr::copy_nonoverlapping`.\n         unsafe {\n             ptr::copy_nonoverlapping(self.src, self.dest, 1);\n         }\n@@ -32,6 +35,21 @@ where\n     F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n+    // SAFETY: The unsafe operations below involves indexing without a bound check (`get_unchecked` and `get_unchecked_mut`)\n+    // and copying memory (`ptr::copy_nonoverlapping`).\n+    //\n+    // a. Indexing:\n+    //  1. We checked the size of the array to >=2.\n+    //  2. All the indexing that we will do is always between {0 <= index < len} at most.\n+    //\n+    // b. Memory copying\n+    //  1. We are obtaining pointers to references which are guaranteed to be valid.\n+    //  2. They cannot overlap because we obtain pointers to difference indices of the slice.\n+    //     Namely, `i` and `i-1`.\n+    //  3. If the slice is properly aligned, the elements are properly aligned.\n+    //     It is the caller's responsibility to make sure the slice is properly aligned.\n+    //\n+    // See comments below for further detail.\n     unsafe {\n         // If the first two elements are out-of-order...\n         if len >= 2 && is_less(v.get_unchecked(1), v.get_unchecked(0)) {\n@@ -62,6 +80,21 @@ where\n     F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n+    // SAFETY: The unsafe operations below involves indexing without a bound check (`get_unchecked` and `get_unchecked_mut`)\n+    // and copying memory (`ptr::copy_nonoverlapping`).\n+    //\n+    // a. Indexing:\n+    //  1. We checked the size of the array to >= 2.\n+    //  2. All the indexing that we will do is always between `0 <= index < len-1` at most.\n+    //\n+    // b. Memory copying\n+    //  1. We are obtaining pointers to references which are guaranteed to be valid.\n+    //  2. They cannot overlap because we obtain pointers to difference indices of the slice.\n+    //     Namely, `i` and `i+1`.\n+    //  3. If the slice is properly aligned, the elements are properly aligned.\n+    //     It is the caller's responsibility to make sure the slice is properly aligned.\n+    //\n+    // See comments below for further detail.\n     unsafe {\n         // If the last two elements are out-of-order...\n         if len >= 2 && is_less(v.get_unchecked(len - 1), v.get_unchecked(len - 2)) {\n@@ -103,6 +136,8 @@ where\n     let mut i = 1;\n \n     for _ in 0..MAX_STEPS {\n+        // SAFETY: We already explicitly did the bound checking with `i < len`.\n+        // All our subsequent indexing is only in the range `0 <= index < len`\n         unsafe {\n             // Find the next pair of adjacent out-of-order elements.\n             while i < len && !is_less(v.get_unchecked(i), v.get_unchecked(i - 1)) {\n@@ -220,6 +255,7 @@ where\n     let mut offsets_l = [MaybeUninit::<u8>::uninit(); BLOCK];\n \n     // The current block on the right side (from `r.sub(block_r)` to `r`).\n+    // SAFETY: The documentation for .add() specifically mention that `vec.as_ptr().add(vec.len())` is always safe`\n     let mut r = unsafe { l.add(v.len()) };\n     let mut block_r = BLOCK;\n     let mut start_r = ptr::null_mut();\n@@ -268,6 +304,16 @@ where\n             let mut elem = l;\n \n             for i in 0..block_l {\n+                // SAFETY: The unsafety operations below involve the usage of the `offset`.\n+                //         According to the conditions required by the function, we satisfy them because:\n+                //         1. `offsets_l` is stack-allocated, and thus considered separate allocated object.\n+                //         2. The function `is_less` returns a `bool`.\n+                //            Casting a `bool` will never overflow `isize`.\n+                //         3. We have guaranteed that `block_l` will be `<= BLOCK`.\n+                //            Plus, `end_l` was initially set to the begin pointer of `offsets_` which was declared on the stack.\n+                //            Thus, we know that even in the worst case (all invocations of `is_less` returns false) we will only be at most 1 byte pass the end.\n+                //        Another unsafety operation here is dereferencing `elem`.\n+                //        However, `elem` was initially the begin pointer to the slice which is always valid.\n                 unsafe {\n                     // Branchless comparison.\n                     *end_l = i as u8;\n@@ -284,6 +330,17 @@ where\n             let mut elem = r;\n \n             for i in 0..block_r {\n+                // SAFETY: The unsafety operations below involve the usage of the `offset`.\n+                //         According to the conditions required by the function, we satisfy them because:\n+                //         1. `offsets_r` is stack-allocated, and thus considered separate allocated object.\n+                //         2. The function `is_less` returns a `bool`.\n+                //            Casting a `bool` will never overflow `isize`.\n+                //         3. We have guaranteed that `block_r` will be `<= BLOCK`.\n+                //            Plus, `end_r` was initially set to the begin pointer of `offsets_` which was declared on the stack.\n+                //            Thus, we know that even in the worst case (all invocations of `is_less` returns true) we will only be at most 1 byte pass the end.\n+                //        Another unsafety operation here is dereferencing `elem`.\n+                //        However, `elem` was initially `1 * sizeof(T)` past the end and we decrement it by `1 * sizeof(T)` before accessing it.\n+                //        Plus, `block_r` was asserted to be less than `BLOCK` and `elem` will therefore at most be pointing to the beginning of the slice.\n                 unsafe {\n                     // Branchless comparison.\n                     elem = elem.offset(-1);\n@@ -404,8 +461,13 @@ where\n         // Find the first pair of out-of-order elements.\n         let mut l = 0;\n         let mut r = v.len();\n+\n+        // SAFETY: The unsafety below involves indexing an array.\n+        // For the first one: We already do the bounds checking here with `l < r`.\n+        // For the second one: We initially have `l == 0` and `r == v.len()` and we checked that `l < r` at every indexing operation.\n+        //                     From here we know that `r` must be at least `r == l` which was shown to be valid from the first one.\n         unsafe {\n-            // Find the first element greater then or equal to the pivot.\n+            // Find the first element greater than or equal to the pivot.\n             while l < r && is_less(v.get_unchecked(l), pivot) {\n                 l += 1;\n             }\n@@ -444,6 +506,7 @@ where\n \n     // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n     // operation panics, the pivot will be automatically written back into the slice.\n+    // SAFETY: The pointer here is valid because it is obtained from a reference to a slice.\n     let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n     let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n     let pivot = &*tmp;\n@@ -452,8 +515,12 @@ where\n     let mut l = 0;\n     let mut r = v.len();\n     loop {\n+        // SAFETY: The unsafety below involves indexing an array.\n+        // For the first one: We already do the bounds checking here with `l < r`.\n+        // For the second one: We initially have `l == 0` and `r == v.len()` and we checked that `l < r` at every indexing operation.\n+        //                     From here we know that `r` must be at least `r == l` which was shown to be valid from the first one.\n         unsafe {\n-            // Find the first element greater that the pivot.\n+            // Find the first element greater than the pivot.\n             while l < r && !is_less(pivot, v.get_unchecked(l)) {\n                 l += 1;\n             }"}, {"sha": "e98d709539d79b6ef910d2db072a8a824dbe21c1", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -1905,7 +1905,7 @@ impl fmt::Display for InlineAsmTemplatePiece {\n                     match c {\n                         '{' => f.write_str(\"{{\")?,\n                         '}' => f.write_str(\"}}\")?,\n-                        _ => write!(f, \"{}\", c.escape_debug())?,\n+                        _ => c.fmt(f)?,\n                     }\n                 }\n                 Ok(())"}, {"sha": "29885679604647db049912609842e20d07d7de52", "filename": "src/librustc_builtin_macros/asm.rs", "status": "modified", "additions": 185, "deletions": 147, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -11,7 +11,7 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{InnerSpan, Span};\n \n struct AsmArgs {\n-    template: P<ast::Expr>,\n+    templates: Vec<P<ast::Expr>>,\n     operands: Vec<(ast::InlineAsmOperand, Span)>,\n     named_args: FxHashMap<Symbol, usize>,\n     reg_args: FxHashSet<usize>,\n@@ -52,21 +52,21 @@ fn parse_args<'a>(\n         return Err(err);\n     }\n \n-    let template = p.parse_expr()?;\n+    let first_template = p.parse_expr()?;\n     let mut args = AsmArgs {\n-        template,\n+        templates: vec![first_template],\n         operands: vec![],\n         named_args: FxHashMap::default(),\n         reg_args: FxHashSet::default(),\n         options: ast::InlineAsmOptions::empty(),\n         options_span: None,\n     };\n \n-    let mut first = true;\n+    let mut allow_templates = true;\n     while p.token != token::Eof {\n         if !p.eat(&token::Comma) {\n-            if first {\n-                // After `asm!(\"\"` we always expect *only* a comma...\n+            if allow_templates {\n+                // After a template string, we always expect *only* a comma...\n                 let mut err = ecx.struct_span_err(p.token.span, \"expected token: `,`\");\n                 err.span_label(p.token.span, \"expected `,`\");\n                 p.maybe_annotate_with_ascription(&mut err, false);\n@@ -76,14 +76,14 @@ fn parse_args<'a>(\n                 return Err(p.expect(&token::Comma).err().unwrap());\n             }\n         }\n-        first = false;\n         if p.token == token::Eof {\n             break;\n         } // accept trailing commas\n \n         // Parse options\n         if p.eat(&token::Ident(sym::options, false)) {\n             parse_options(&mut p, &mut args)?;\n+            allow_templates = false;\n             continue;\n         }\n \n@@ -94,6 +94,7 @@ fn parse_args<'a>(\n             let (ident, _) = p.token.ident().unwrap();\n             p.bump();\n             p.expect(&token::Eq)?;\n+            allow_templates = false;\n             Some(ident.name)\n         } else {\n             None\n@@ -135,8 +136,7 @@ fn parse_args<'a>(\n         } else if p.eat(&token::Ident(kw::Const, false)) {\n             let expr = p.parse_expr()?;\n             ast::InlineAsmOperand::Const { expr }\n-        } else {\n-            p.expect(&token::Ident(sym::sym, false))?;\n+        } else if p.eat(&token::Ident(sym::sym, false)) {\n             let expr = p.parse_expr()?;\n             match expr.kind {\n                 ast::ExprKind::Path(..) => {}\n@@ -147,8 +147,27 @@ fn parse_args<'a>(\n                 }\n             }\n             ast::InlineAsmOperand::Sym { expr }\n+        } else if allow_templates {\n+            let template = p.parse_expr()?;\n+            // If it can't possibly expand to a string, provide diagnostics here to include other\n+            // things it could have been.\n+            match template.kind {\n+                ast::ExprKind::Lit(ast::Lit { kind: ast::LitKind::Str(..), .. }) => {}\n+                ast::ExprKind::MacCall(..) => {}\n+                _ => {\n+                    let errstr = \"expected operand, options, or additional template string\";\n+                    let mut err = ecx.struct_span_err(template.span, errstr);\n+                    err.span_label(template.span, errstr);\n+                    return Err(err);\n+                }\n+            }\n+            args.templates.push(template);\n+            continue;\n+        } else {\n+            return Err(p.expect_one_of(&[], &[]).unwrap_err());\n         };\n \n+        allow_templates = false;\n         let span = span_start.to(p.prev_token.span);\n         let slot = args.operands.len();\n         args.operands.push((op, span));\n@@ -330,155 +349,180 @@ fn parse_reg<'a>(\n }\n \n fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast::Expr> {\n-    let msg = \"asm template must be a string literal\";\n-    let template_sp = args.template.span;\n-    let (template_str, template_style, template_span) =\n-        match expr_to_spanned_string(ecx, args.template, msg) {\n-            Ok(template) => template,\n-            Err(err) => {\n-                if let Some(mut err) = err {\n-                    err.emit();\n-                }\n-                return DummyResult::raw_expr(sp, true);\n-            }\n-        };\n-\n-    let str_style = match template_style {\n-        ast::StrStyle::Cooked => None,\n-        ast::StrStyle::Raw(raw) => Some(raw as usize),\n-    };\n-\n-    let template_str = &template_str.as_str();\n-    let template_snippet = ecx.source_map().span_to_snippet(template_sp).ok();\n-    let mut parser = parse::Parser::new(\n-        template_str,\n-        str_style,\n-        template_snippet,\n-        false,\n-        parse::ParseMode::InlineAsm,\n-    );\n-\n-    let mut unverified_pieces = Vec::new();\n-    while let Some(piece) = parser.next() {\n-        if !parser.errors.is_empty() {\n-            break;\n-        } else {\n-            unverified_pieces.push(piece);\n-        }\n-    }\n-\n-    if !parser.errors.is_empty() {\n-        let err = parser.errors.remove(0);\n-        let err_sp = template_span.from_inner(err.span);\n-        let mut e = ecx\n-            .struct_span_err(err_sp, &format!(\"invalid asm template string: {}\", err.description));\n-        e.span_label(err_sp, err.label + \" in asm template string\");\n-        if let Some(note) = err.note {\n-            e.note(&note);\n-        }\n-        if let Some((label, span)) = err.secondary_label {\n-            let err_sp = template_span.from_inner(span);\n-            e.span_label(err_sp, label);\n-        }\n-        e.emit();\n-        return DummyResult::raw_expr(sp, true);\n-    }\n-\n+    let mut template = vec![];\n     // Register operands are implicitly used since they are not allowed to be\n     // referenced in the template string.\n     let mut used = vec![false; args.operands.len()];\n     for pos in &args.reg_args {\n         used[*pos] = true;\n     }\n-\n     let named_pos: FxHashMap<usize, Symbol> =\n         args.named_args.iter().map(|(&sym, &idx)| (idx, sym)).collect();\n-    let mut arg_spans = parser.arg_places.iter().map(|span| template_span.from_inner(*span));\n-    let mut template = vec![];\n-    for piece in unverified_pieces {\n-        match piece {\n-            parse::Piece::String(s) => {\n-                template.push(ast::InlineAsmTemplatePiece::String(s.to_string()))\n+    let mut line_spans = Vec::with_capacity(args.templates.len());\n+    let mut curarg = 0;\n+\n+    for template_expr in args.templates.into_iter() {\n+        if !template.is_empty() {\n+            template.push(ast::InlineAsmTemplatePiece::String(\"\\n\".to_string()));\n+        }\n+\n+        let msg = \"asm template must be a string literal\";\n+        let template_sp = template_expr.span;\n+        let (template_str, template_style, template_span) =\n+            match expr_to_spanned_string(ecx, template_expr, msg) {\n+                Ok(template_part) => template_part,\n+                Err(err) => {\n+                    if let Some(mut err) = err {\n+                        err.emit();\n+                    }\n+                    return DummyResult::raw_expr(sp, true);\n+                }\n+            };\n+\n+        let str_style = match template_style {\n+            ast::StrStyle::Cooked => None,\n+            ast::StrStyle::Raw(raw) => Some(raw as usize),\n+        };\n+\n+        let template_str = &template_str.as_str();\n+        let template_snippet = ecx.source_map().span_to_snippet(template_sp).ok();\n+        let mut parser = parse::Parser::new(\n+            template_str,\n+            str_style,\n+            template_snippet,\n+            false,\n+            parse::ParseMode::InlineAsm,\n+        );\n+        parser.curarg = curarg;\n+\n+        let mut unverified_pieces = Vec::new();\n+        while let Some(piece) = parser.next() {\n+            if !parser.errors.is_empty() {\n+                break;\n+            } else {\n+                unverified_pieces.push(piece);\n             }\n-            parse::Piece::NextArgument(arg) => {\n-                let span = arg_spans.next().unwrap_or(template_sp);\n-\n-                let operand_idx = match arg.position {\n-                    parse::ArgumentIs(idx) | parse::ArgumentImplicitlyIs(idx) => {\n-                        if idx >= args.operands.len()\n-                            || named_pos.contains_key(&idx)\n-                            || args.reg_args.contains(&idx)\n-                        {\n-                            let msg = format!(\"invalid reference to argument at index {}\", idx);\n-                            let mut err = ecx.struct_span_err(span, &msg);\n-                            err.span_label(span, \"from here\");\n-\n-                            let positional_args =\n-                                args.operands.len() - args.named_args.len() - args.reg_args.len();\n-                            let positional = if positional_args != args.operands.len() {\n-                                \"positional \"\n+        }\n+\n+        if !parser.errors.is_empty() {\n+            let err = parser.errors.remove(0);\n+            let err_sp = template_span.from_inner(err.span);\n+            let msg = &format!(\"invalid asm template string: {}\", err.description);\n+            let mut e = ecx.struct_span_err(err_sp, msg);\n+            e.span_label(err_sp, err.label + \" in asm template string\");\n+            if let Some(note) = err.note {\n+                e.note(&note);\n+            }\n+            if let Some((label, span)) = err.secondary_label {\n+                let err_sp = template_span.from_inner(span);\n+                e.span_label(err_sp, label);\n+            }\n+            e.emit();\n+            return DummyResult::raw_expr(sp, true);\n+        }\n+\n+        curarg = parser.curarg;\n+\n+        let mut arg_spans = parser.arg_places.iter().map(|span| template_span.from_inner(*span));\n+        for piece in unverified_pieces {\n+            match piece {\n+                parse::Piece::String(s) => {\n+                    template.push(ast::InlineAsmTemplatePiece::String(s.to_string()))\n+                }\n+                parse::Piece::NextArgument(arg) => {\n+                    let span = arg_spans.next().unwrap_or(template_sp);\n+\n+                    let operand_idx = match arg.position {\n+                        parse::ArgumentIs(idx) | parse::ArgumentImplicitlyIs(idx) => {\n+                            if idx >= args.operands.len()\n+                                || named_pos.contains_key(&idx)\n+                                || args.reg_args.contains(&idx)\n+                            {\n+                                let msg = format!(\"invalid reference to argument at index {}\", idx);\n+                                let mut err = ecx.struct_span_err(span, &msg);\n+                                err.span_label(span, \"from here\");\n+\n+                                let positional_args = args.operands.len()\n+                                    - args.named_args.len()\n+                                    - args.reg_args.len();\n+                                let positional = if positional_args != args.operands.len() {\n+                                    \"positional \"\n+                                } else {\n+                                    \"\"\n+                                };\n+                                let msg = match positional_args {\n+                                    0 => format!(\"no {}arguments were given\", positional),\n+                                    1 => format!(\"there is 1 {}argument\", positional),\n+                                    x => format!(\"there are {} {}arguments\", x, positional),\n+                                };\n+                                err.note(&msg);\n+\n+                                if named_pos.contains_key(&idx) {\n+                                    err.span_label(args.operands[idx].1, \"named argument\");\n+                                    err.span_note(\n+                                        args.operands[idx].1,\n+                                        \"named arguments cannot be referenced by position\",\n+                                    );\n+                                } else if args.reg_args.contains(&idx) {\n+                                    err.span_label(\n+                                        args.operands[idx].1,\n+                                        \"explicit register argument\",\n+                                    );\n+                                    err.span_note(\n+                                        args.operands[idx].1,\n+                                        \"explicit register arguments cannot be used in the asm template\",\n+                                    );\n+                                }\n+                                err.emit();\n+                                None\n                             } else {\n-                                \"\"\n-                            };\n-                            let msg = match positional_args {\n-                                0 => format!(\"no {}arguments were given\", positional),\n-                                1 => format!(\"there is 1 {}argument\", positional),\n-                                x => format!(\"there are {} {}arguments\", x, positional),\n-                            };\n-                            err.note(&msg);\n-\n-                            if named_pos.contains_key(&idx) {\n-                                err.span_label(args.operands[idx].1, \"named argument\");\n-                                err.span_note(\n-                                    args.operands[idx].1,\n-                                    \"named arguments cannot be referenced by position\",\n-                                );\n-                            } else if args.reg_args.contains(&idx) {\n-                                err.span_label(args.operands[idx].1, \"explicit register argument\");\n-                                err.span_note(\n-                                    args.operands[idx].1,\n-                                    \"explicit register arguments cannot be used in the asm template\",\n-                                );\n+                                Some(idx)\n                             }\n-                            err.emit();\n-                            None\n-                        } else {\n-                            Some(idx)\n-                        }\n-                    }\n-                    parse::ArgumentNamed(name) => match args.named_args.get(&name) {\n-                        Some(&idx) => Some(idx),\n-                        None => {\n-                            let msg = format!(\"there is no argument named `{}`\", name);\n-                            ecx.struct_span_err(span, &msg[..]).emit();\n-                            None\n                         }\n-                    },\n-                };\n-\n-                let mut chars = arg.format.ty.chars();\n-                let mut modifier = chars.next();\n-                if chars.next().is_some() {\n-                    let span = arg\n-                        .format\n-                        .ty_span\n-                        .map(|sp| template_sp.from_inner(sp))\n-                        .unwrap_or(template_sp);\n-                    ecx.struct_span_err(span, \"asm template modifier must be a single character\")\n+                        parse::ArgumentNamed(name) => match args.named_args.get(&name) {\n+                            Some(&idx) => Some(idx),\n+                            None => {\n+                                let msg = format!(\"there is no argument named `{}`\", name);\n+                                ecx.struct_span_err(span, &msg[..]).emit();\n+                                None\n+                            }\n+                        },\n+                    };\n+\n+                    let mut chars = arg.format.ty.chars();\n+                    let mut modifier = chars.next();\n+                    if chars.next().is_some() {\n+                        let span = arg\n+                            .format\n+                            .ty_span\n+                            .map(|sp| template_sp.from_inner(sp))\n+                            .unwrap_or(template_sp);\n+                        ecx.struct_span_err(\n+                            span,\n+                            \"asm template modifier must be a single character\",\n+                        )\n                         .emit();\n-                    modifier = None;\n-                }\n+                        modifier = None;\n+                    }\n \n-                if let Some(operand_idx) = operand_idx {\n-                    used[operand_idx] = true;\n-                    template.push(ast::InlineAsmTemplatePiece::Placeholder {\n-                        operand_idx,\n-                        modifier,\n-                        span,\n-                    });\n+                    if let Some(operand_idx) = operand_idx {\n+                        used[operand_idx] = true;\n+                        template.push(ast::InlineAsmTemplatePiece::Placeholder {\n+                            operand_idx,\n+                            modifier,\n+                            span,\n+                        });\n+                    }\n                 }\n             }\n         }\n+\n+        if parser.line_spans.is_empty() {\n+            let template_num_lines = 1 + template_str.matches('\\n').count();\n+            line_spans.extend(std::iter::repeat(template_sp).take(template_num_lines));\n+        } else {\n+            line_spans.extend(parser.line_spans.iter().map(|span| template_span.from_inner(*span)));\n+        };\n     }\n \n     let mut unused_operands = vec![];\n@@ -525,12 +569,6 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n         }\n     }\n \n-    let line_spans = if parser.line_spans.is_empty() {\n-        vec![template_sp]\n-    } else {\n-        parser.line_spans.iter().map(|span| template_span.from_inner(*span)).collect()\n-    };\n-\n     let inline_asm =\n         ast::InlineAsm { template, operands: args.operands, options: args.options, line_spans };\n     P(ast::Expr {"}, {"sha": "2f9e49591c3811f45195ade7e7caccac3905e5b7", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -255,6 +255,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n                 InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {}\n                 InlineAsmArch::Nvptx64 => {}\n+                InlineAsmArch::Hexagon => {}\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -427,6 +428,7 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass) -> String {\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => \"x\",\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"w\",\n+            InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => \"h\",\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => \"r\",\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => \"l\",\n@@ -472,6 +474,7 @@ fn modifier_to_llvm(\n                 modifier\n             }\n         }\n+        InlineAsmRegClass::Hexagon(_) => None,\n         InlineAsmRegClass::Nvptx(_) => None,\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n         | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n@@ -523,6 +526,7 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n             cx.type_vector(cx.type_i64(), 2)\n         }\n+        InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => cx.type_i32(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => cx.type_i64(),"}, {"sha": "eb1db46fd2bda84ac3d54d16e7506e431e245760", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -12,6 +12,7 @@ use rustc_ast::node_id::NodeMap;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_macros::HashStable_Generic;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n@@ -2651,25 +2652,11 @@ pub type CaptureModeMap = NodeMap<CaptureBy>;\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used.\n #[derive(Clone, Debug)]\n-pub struct TraitCandidate<ID = HirId> {\n+pub struct TraitCandidate {\n     pub def_id: DefId,\n-    pub import_ids: SmallVec<[ID; 1]>,\n+    pub import_ids: SmallVec<[LocalDefId; 1]>,\n }\n \n-impl<ID> TraitCandidate<ID> {\n-    pub fn map_import_ids<F, T>(self, f: F) -> TraitCandidate<T>\n-    where\n-        F: Fn(ID) -> T,\n-    {\n-        let TraitCandidate { def_id, import_ids } = self;\n-        let import_ids = import_ids.into_iter().map(f).collect();\n-        TraitCandidate { def_id, import_ids }\n-    }\n-}\n-\n-// Trait method resolution\n-pub type TraitMap<ID = HirId> = NodeMap<Vec<TraitCandidate<ID>>>;\n-\n #[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum Node<'hir> {\n     Param(&'hir Param<'hir>),\n@@ -2741,14 +2728,8 @@ impl Node<'_> {\n     pub fn generics(&self) -> Option<&Generics<'_>> {\n         match self {\n             Node::TraitItem(TraitItem { generics, .. })\n-            | Node::ImplItem(ImplItem { generics, .. })\n-            | Node::Item(Item {\n-                kind:\n-                    ItemKind::Trait(_, _, generics, ..)\n-                    | ItemKind::Impl { generics, .. }\n-                    | ItemKind::Fn(_, generics, _),\n-                ..\n-            }) => Some(generics),\n+            | Node::ImplItem(ImplItem { generics, .. }) => Some(generics),\n+            Node::Item(item) => item.kind.generics(),\n             _ => None,\n         }\n     }"}, {"sha": "d891466611ad379611cd2ce32db66ec2761e8ec8", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -55,7 +55,8 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n     where\n         F: FnOnce(&mut Self),\n     {\n-        let push = self.context.builder.push(attrs, &self.context.lint_store);\n+        let is_crate_node = id == ast::CRATE_NODE_ID;\n+        let push = self.context.builder.push(attrs, &self.context.lint_store, is_crate_node);\n         self.check_id(id);\n         self.enter_attrs(attrs);\n         f(self);"}, {"sha": "f875e2750a5c56fa9b4464937ed1cb899910ac00", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -29,7 +29,7 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> LintLevelMap {\n     let mut builder = LintLevelMapBuilder { levels, tcx, store };\n     let krate = tcx.hir().krate();\n \n-    let push = builder.levels.push(&krate.item.attrs, &store);\n+    let push = builder.levels.push(&krate.item.attrs, &store, true);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n     for macro_def in krate.exported_macros {\n         builder.levels.register_id(macro_def.hir_id);\n@@ -109,7 +109,12 @@ impl<'s> LintLevelsBuilder<'s> {\n     ///   `#[allow]`\n     ///\n     /// Don't forget to call `pop`!\n-    pub fn push(&mut self, attrs: &[ast::Attribute], store: &LintStore) -> BuilderPush {\n+    pub fn push(\n+        &mut self,\n+        attrs: &[ast::Attribute],\n+        store: &LintStore,\n+        is_crate_node: bool,\n+    ) -> BuilderPush {\n         let mut specs = FxHashMap::default();\n         let sess = self.sess;\n         let bad_attr = |span| struct_span_err!(sess, span, E0452, \"malformed lint attribute input\");\n@@ -333,6 +338,40 @@ impl<'s> LintLevelsBuilder<'s> {\n             }\n         }\n \n+        if !is_crate_node {\n+            for (id, &(level, ref src)) in specs.iter() {\n+                if !id.lint.crate_level_only {\n+                    continue;\n+                }\n+\n+                let (lint_attr_name, lint_attr_span) = match *src {\n+                    LintSource::Node(name, span, _) => (name, span),\n+                    _ => continue,\n+                };\n+\n+                let lint = builtin::UNUSED_ATTRIBUTES;\n+                let (lint_level, lint_src) =\n+                    self.sets.get_lint_level(lint, self.cur, Some(&specs), self.sess);\n+                struct_lint_level(\n+                    self.sess,\n+                    lint,\n+                    lint_level,\n+                    lint_src,\n+                    Some(lint_attr_span.into()),\n+                    |lint| {\n+                        let mut db = lint.build(&format!(\n+                            \"{}({}) is ignored unless specified at crate level\",\n+                            level.as_str(),\n+                            lint_attr_name\n+                        ));\n+                        db.emit();\n+                    },\n+                );\n+                // don't set a separate error for every lint in the group\n+                break;\n+            }\n+        }\n+\n         for (id, &(level, ref src)) in specs.iter() {\n             if level == Level::Forbid {\n                 continue;\n@@ -449,7 +488,8 @@ impl LintLevelMapBuilder<'_, '_> {\n     where\n         F: FnOnce(&mut Self),\n     {\n-        let push = self.levels.push(attrs, self.store);\n+        let is_crate_hir = id == hir::CRATE_HIR_ID;\n+        let push = self.levels.push(attrs, self.store, is_crate_hir);\n         if push.changed {\n             self.levels.register_id(id);\n         }"}, {"sha": "064b0255397ce20a3cdfe7fe46fb99d683f84e22", "filename": "src/librustc_lint/non_ascii_idents.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnon_ascii_idents.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -8,20 +8,23 @@ use std::ops::Deref;\n declare_lint! {\n     pub NON_ASCII_IDENTS,\n     Allow,\n-    \"detects non-ASCII identifiers\"\n+    \"detects non-ASCII identifiers\",\n+    crate_level_only\n }\n \n declare_lint! {\n     pub UNCOMMON_CODEPOINTS,\n     Warn,\n-    \"detects uncommon Unicode codepoints in identifiers\"\n+    \"detects uncommon Unicode codepoints in identifiers\",\n+    crate_level_only\n }\n \n // FIXME: Change this to warn.\n declare_lint! {\n     pub CONFUSABLE_IDENTS,\n     Allow,\n-    \"detects visually confusable pairs between identifiers\"\n+    \"detects visually confusable pairs between identifiers\",\n+    crate_level_only\n }\n \n declare_lint_pass!(NonAsciiIdents => [NON_ASCII_IDENTS, UNCOMMON_CODEPOINTS, CONFUSABLE_IDENTS]);"}, {"sha": "aaef9871aa5572364dd8f6142f5eafa8ffebaa84", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -114,6 +114,7 @@ macro_rules! arena_types {\n \n             // This is used to decode the &'tcx [Span] for InlineAsm's line_spans.\n             [decode] span: rustc_span::Span, rustc_span::Span;\n+            [decode] used_trait_imports: rustc_data_structures::fx::FxHashSet<rustc_hir::def_id::LocalDefId>, rustc_data_structures::fx::FxHashSet<rustc_hir::def_id::LocalDefId>;\n         ], $tcx);\n     )\n }"}, {"sha": "78b9167ddd9679ca96b4f9da13b4bfd28259fe37", "filename": "src/librustc_middle/ich/impls_hir.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_middle%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_middle%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_hir.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -210,16 +210,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n }\n \n impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n-    type KeyType = (DefPathHash, SmallVec<[(DefPathHash, hir::ItemLocalId); 1]>);\n+    type KeyType = (DefPathHash, SmallVec<[DefPathHash; 1]>);\n \n     fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> Self::KeyType {\n         let hir::TraitCandidate { def_id, import_ids } = self;\n \n-        let import_keys = import_ids\n-            .iter()\n-            .map(|hir_id| (hcx.local_def_path_hash(hir_id.owner), hir_id.local_id))\n-            .collect();\n-        (hcx.def_path_hash(*def_id), import_keys)\n+        (\n+            hcx.def_path_hash(*def_id),\n+            import_ids.iter().map(|def_id| hcx.local_def_path_hash(*def_id)).collect(),\n+        )\n     }\n }\n "}, {"sha": "b3751beede25abecafcb2821784947e125abdeaf", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -526,7 +526,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query used_trait_imports(key: LocalDefId) -> &'tcx DefIdSet {\n+        query used_trait_imports(key: LocalDefId) -> &'tcx FxHashSet<LocalDefId> {\n             desc { |tcx| \"used_trait_imports `{}`\", tcx.def_path_str(key.to_def_id()) }\n             cache_on_disk_if { true }\n         }"}, {"sha": "c77c7b95bc095f2e1b0223a1afc0df3a66eedd11", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -35,7 +35,7 @@ use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefPathHash, Definitions};\n use rustc_hir::lang_items::{self, PanicLocationLangItem};\n use rustc_hir::{HirId, ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet, Node, TraitCandidate};\n@@ -390,7 +390,7 @@ pub struct TypeckTables<'tcx> {\n     /// This is used for warning unused imports. During type\n     /// checking, this `Lrc` should not be cloned: it must have a ref-count\n     /// of 1 so that we can insert things into the set mutably.\n-    pub used_trait_imports: Lrc<DefIdSet>,\n+    pub used_trait_imports: Lrc<FxHashSet<LocalDefId>>,\n \n     /// If any errors occurred while type-checking this body,\n     /// this field will be set to `Some(ErrorReported)`."}, {"sha": "e26e09ae6a942f49c7fe936804e47fa05dc1cba7", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -121,7 +121,7 @@ pub struct ResolverOutputs {\n     pub definitions: rustc_hir::definitions::Definitions,\n     pub cstore: Box<CrateStoreDyn>,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n-    pub trait_map: FxHashMap<hir::HirId, Vec<hir::TraitCandidate<hir::HirId>>>,\n+    pub trait_map: FxHashMap<hir::HirId, Vec<hir::TraitCandidate>>,\n     pub maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n     pub maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n     pub export_map: ExportMap<LocalDefId>,"}, {"sha": "a5b5a1090cbfd5052e0d6beb64b0b79581a87698", "filename": "src/librustc_parse_format/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_parse_format%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_parse_format%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse_format%2Flib.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -178,7 +178,7 @@ pub struct Parser<'a> {\n     /// Error messages accumulated during parsing\n     pub errors: Vec<ParseError>,\n     /// Current position of implicit positional argument pointer\n-    curarg: usize,\n+    pub curarg: usize,\n     /// `Some(raw count)` when the string is \"raw\", used to position spans correctly\n     style: Option<usize>,\n     /// Start and end byte offset of every successfully parsed argument\n@@ -243,11 +243,13 @@ impl<'a> Iterator for Parser<'a> {\n                 _ => Some(String(self.string(pos))),\n             }\n         } else {\n-            if self.is_literal && self.cur_line_start != self.input.len() {\n+            if self.is_literal {\n                 let start = self.to_span_index(self.cur_line_start);\n                 let end = self.to_span_index(self.input.len());\n-                self.line_spans.push(start.to(end));\n-                self.cur_line_start = self.input.len();\n+                let span = start.to(end);\n+                if self.line_spans.last() != Some(&span) {\n+                    self.line_spans.push(span);\n+                }\n             }\n             None\n         }"}, {"sha": "61f20df8cc6c03151a23cee02aaf63f95c88d501", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -24,6 +24,7 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::TraitCandidate;\n use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n@@ -2188,7 +2189,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n-    ) -> Vec<TraitCandidate<NodeId>> {\n+    ) -> Vec<TraitCandidate> {\n         debug!(\"(getting traits containing item) looking for '{}'\", ident.name);\n \n         let mut found_traits = Vec::new();\n@@ -2233,7 +2234,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         ident: Ident,\n         ns: Namespace,\n         module: Module<'a>,\n-        found_traits: &mut Vec<TraitCandidate<NodeId>>,\n+        found_traits: &mut Vec<TraitCandidate>,\n     ) {\n         assert!(ns == TypeNS || ns == ValueNS);\n         let mut traits = module.traits.borrow_mut();\n@@ -2292,13 +2293,13 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         &mut self,\n         mut kind: &NameBindingKind<'_>,\n         trait_name: Ident,\n-    ) -> SmallVec<[NodeId; 1]> {\n+    ) -> SmallVec<[LocalDefId; 1]> {\n         let mut import_ids = smallvec![];\n         while let NameBindingKind::Import { import, binding, .. } = kind {\n             let id = self.r.definitions.local_def_id(import.id);\n             self.r.maybe_unused_trait_imports.insert(id);\n             self.r.add_to_glob_map(&import, trait_name);\n-            import_ids.push(import.id);\n+            import_ids.push(id);\n             kind = &binding.kind;\n         }\n         import_ids"}, {"sha": "66e5612b627b40176d250a937bf6c770f752a56b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -38,7 +38,7 @@ use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::definitions::{DefKey, Definitions};\n use rustc_hir::PrimTy::{self, Bool, Char, Float, Int, Str, Uint};\n-use rustc_hir::TraitMap;\n+use rustc_hir::TraitCandidate;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::hir::exports::ExportMap;\n use rustc_middle::middle::cstore::{CrateStore, MetadataLoaderDyn};\n@@ -881,7 +881,7 @@ pub struct Resolver<'a> {\n     /// `CrateNum` resolutions of `extern crate` items.\n     extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     export_map: ExportMap<LocalDefId>,\n-    trait_map: TraitMap<NodeId>,\n+    trait_map: NodeMap<Vec<TraitCandidate>>,\n \n     /// A map from nodes to anonymous modules.\n     /// Anonymous modules are pseudo-modules that are implicitly created around items\n@@ -1287,14 +1287,7 @@ impl<'a> Resolver<'a> {\n         let trait_map = self\n             .trait_map\n             .into_iter()\n-            .map(|(k, v)| {\n-                (\n-                    definitions.node_id_to_hir_id(k),\n-                    v.into_iter()\n-                        .map(|tc| tc.map_import_ids(|id| definitions.node_id_to_hir_id(id)))\n-                        .collect(),\n-                )\n-            })\n+            .map(|(k, v)| (definitions.node_id_to_hir_id(k), v))\n             .collect();\n         let maybe_unused_trait_imports = self.maybe_unused_trait_imports;\n         let maybe_unused_extern_crates = self.maybe_unused_extern_crates;\n@@ -1325,17 +1318,7 @@ impl<'a> Resolver<'a> {\n             trait_map: self\n                 .trait_map\n                 .iter()\n-                .map(|(&k, v)| {\n-                    (\n-                        self.definitions.node_id_to_hir_id(k),\n-                        v.iter()\n-                            .cloned()\n-                            .map(|tc| {\n-                                tc.map_import_ids(|id| self.definitions.node_id_to_hir_id(id))\n-                            })\n-                            .collect(),\n-                    )\n-                })\n+                .map(|(&k, v)| (self.definitions.node_id_to_hir_id(k), v.clone()))\n                 .collect(),\n             glob_map: self.glob_map.clone(),\n             maybe_unused_trait_imports: self.maybe_unused_trait_imports.clone(),"}, {"sha": "f5c3e84c624267788ac42e888ff06da83a631a0c", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -518,24 +518,13 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_expr_data(&self, expr: &hir::Expr<'_>) -> Option<Data> {\n-        let hir_node = self.tcx.hir().expect_expr(expr.hir_id);\n-        let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n-        if ty.is_none() || matches!(ty.unwrap().kind, ty::Error(_)) {\n+        let ty = self.tables.expr_ty_adjusted_opt(expr)?;\n+        if matches!(ty.kind, ty::Error(_)) {\n             return None;\n         }\n         match expr.kind {\n             hir::ExprKind::Field(ref sub_ex, ident) => {\n-                let hir_node = match self.tcx.hir().find(sub_ex.hir_id) {\n-                    Some(Node::Expr(expr)) => expr,\n-                    _ => {\n-                        debug!(\n-                            \"Missing or weird node for sub-expression {} in {:?}\",\n-                            sub_ex.hir_id, expr\n-                        );\n-                        return None;\n-                    }\n-                };\n-                match self.tables.expr_ty_adjusted(&hir_node).kind {\n+                match self.tables.expr_ty_adjusted(&sub_ex).kind {\n                     ty::Adt(def, _) if !def.is_enum() => {\n                         let variant = &def.non_enum_variant();\n                         filter!(self.span_utils, ident.span);\n@@ -562,8 +551,8 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     hir::QPath::Resolved(_, path) => path.segments.last().unwrap(),\n                     hir::QPath::TypeRelative(_, segment) => segment,\n                 };\n-                match self.tables.expr_ty_adjusted(&hir_node).kind {\n-                    ty::Adt(def, _) if !def.is_enum() => {\n+                match ty.kind {\n+                    ty::Adt(def, _) => {\n                         let sub_span = segment.ident.span;\n                         filter!(self.span_utils, sub_span);\n                         let span = self.span_from_span(sub_span);\n@@ -574,9 +563,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                         }))\n                     }\n                     _ => {\n-                        // FIXME ty could legitimately be an enum, but then we will fail\n-                        // later if we try to look up the fields.\n-                        debug!(\"expected struct or union, found {:?}\", ty);\n+                        debug!(\"expected adt, found {:?}\", ty);\n                         None\n                     }\n                 }"}, {"sha": "0dcbee08abea1f7d1d473fe832112573a09cb740", "filename": "src/librustc_session/lint.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_session%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_session%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -88,6 +88,8 @@ pub struct Lint {\n \n     /// `Some` if this lint is feature gated, otherwise `None`.\n     pub feature_gate: Option<Symbol>,\n+\n+    pub crate_level_only: bool,\n }\n \n /// Extra information for a future incompatibility lint.\n@@ -111,6 +113,7 @@ impl Lint {\n             report_in_external_macro: false,\n             future_incompatible: None,\n             feature_gate: None,\n+            crate_level_only: false,\n         }\n     }\n \n@@ -336,6 +339,7 @@ macro_rules! declare_tool_lint {\n             future_incompatible: None,\n             is_plugin: true,\n             feature_gate: None,\n+            crate_level_only: false,\n         };\n     );\n }"}, {"sha": "5deee6eb48e6acc0c8d6e3ed3977adcce800df66", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -17,6 +17,7 @@ declare_lint! {\n         reference: \"issue #57571 <https://github.com/rust-lang/rust/issues/57571>\",\n         edition: None,\n     };\n+    crate_level_only\n }\n \n declare_lint! {\n@@ -75,7 +76,8 @@ declare_lint! {\n declare_lint! {\n     pub UNUSED_CRATE_DEPENDENCIES,\n     Allow,\n-    \"crate dependencies that are never used\"\n+    \"crate dependencies that are never used\",\n+    crate_level_only\n }\n \n declare_lint! {\n@@ -166,7 +168,8 @@ declare_lint! {\n declare_lint! {\n     pub UNKNOWN_CRATE_TYPES,\n     Deny,\n-    \"unknown crate type found in `#[crate_type]` directive\"\n+    \"unknown crate type found in `#[crate_type]` directive\",\n+    crate_level_only\n }\n \n declare_lint! {\n@@ -339,7 +342,8 @@ declare_lint! {\n declare_lint! {\n     pub ELIDED_LIFETIMES_IN_PATHS,\n     Allow,\n-    \"hidden lifetime parameters in types are deprecated\"\n+    \"hidden lifetime parameters in types are deprecated\",\n+    crate_level_only\n }\n \n declare_lint! {\n@@ -459,6 +463,7 @@ declare_lint! {\n         reference: \"issue #52234 <https://github.com/rust-lang/rust/issues/52234>\",\n         edition: None,\n     };\n+    crate_level_only\n }\n \n declare_lint! {"}, {"sha": "d41941d0b4cd7fe2710d7dda1c5c414a147824be", "filename": "src/librustc_target/asm/hexagon.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_target%2Fasm%2Fhexagon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_target%2Fasm%2Fhexagon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fhexagon.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -0,0 +1,93 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    Hexagon HexagonInlineAsmRegClass {\n+        reg,\n+    }\n+}\n+\n+impl HexagonInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg => types! { _: I8, I16, I32, F32; },\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    Hexagon HexagonInlineAsmReg HexagonInlineAsmRegClass {\n+        r0: reg = [\"r0\"],\n+        r1: reg = [\"r1\"],\n+        r2: reg = [\"r2\"],\n+        r3: reg = [\"r3\"],\n+        r4: reg = [\"r4\"],\n+        r5: reg = [\"r5\"],\n+        r6: reg = [\"r6\"],\n+        r7: reg = [\"r7\"],\n+        r8: reg = [\"r8\"],\n+        r9: reg = [\"r9\"],\n+        r10: reg = [\"r10\"],\n+        r11: reg = [\"r11\"],\n+        r12: reg = [\"r12\"],\n+        r13: reg = [\"r13\"],\n+        r14: reg = [\"r14\"],\n+        r15: reg = [\"r15\"],\n+        r16: reg = [\"r16\"],\n+        r17: reg = [\"r17\"],\n+        r18: reg = [\"r18\"],\n+        r19: reg = [\"r19\"],\n+        r20: reg = [\"r20\"],\n+        r21: reg = [\"r21\"],\n+        r22: reg = [\"r22\"],\n+        r23: reg = [\"r23\"],\n+        r24: reg = [\"r24\"],\n+        r25: reg = [\"r25\"],\n+        r26: reg = [\"r26\"],\n+        r27: reg = [\"r27\"],\n+        r28: reg = [\"r28\"],\n+        #error = [\"r29\", \"sp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"r30\", \"fr\"] =>\n+            \"the frame register cannot be used as an operand for inline asm\",\n+        #error = [\"r31\", \"lr\"] =>\n+            \"the link register cannot be used as an operand for inline asm\",\n+    }\n+}\n+\n+impl HexagonInlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        _modifier: Option<char>,\n+    ) -> fmt::Result {\n+        out.write_str(self.name())\n+    }\n+\n+    pub fn overlapping_regs(self, mut _cb: impl FnMut(HexagonInlineAsmReg)) {}\n+}"}, {"sha": "834d7c6d381a3b8250d155fd780cad9e755f70db", "filename": "src/librustc_target/asm/mod.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_target%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_target%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fmod.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -148,12 +148,14 @@ macro_rules! types {\n \n mod aarch64;\n mod arm;\n+mod hexagon;\n mod nvptx;\n mod riscv;\n mod x86;\n \n pub use aarch64::{AArch64InlineAsmReg, AArch64InlineAsmRegClass};\n pub use arm::{ArmInlineAsmReg, ArmInlineAsmRegClass};\n+pub use hexagon::{HexagonInlineAsmReg, HexagonInlineAsmRegClass};\n pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n pub use x86::{X86InlineAsmReg, X86InlineAsmRegClass};\n@@ -167,6 +169,7 @@ pub enum InlineAsmArch {\n     RiscV32,\n     RiscV64,\n     Nvptx64,\n+    Hexagon,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -181,6 +184,7 @@ impl FromStr for InlineAsmArch {\n             \"riscv32\" => Ok(Self::RiscV32),\n             \"riscv64\" => Ok(Self::RiscV64),\n             \"nvptx64\" => Ok(Self::Nvptx64),\n+            \"hexagon\" => Ok(Self::Hexagon),\n             _ => Err(()),\n         }\n     }\n@@ -203,6 +207,7 @@ pub enum InlineAsmReg {\n     AArch64(AArch64InlineAsmReg),\n     RiscV(RiscVInlineAsmReg),\n     Nvptx(NvptxInlineAsmReg),\n+    Hexagon(HexagonInlineAsmReg),\n }\n \n impl InlineAsmReg {\n@@ -212,6 +217,7 @@ impl InlineAsmReg {\n             Self::Arm(r) => r.name(),\n             Self::AArch64(r) => r.name(),\n             Self::RiscV(r) => r.name(),\n+            Self::Hexagon(r) => r.name(),\n         }\n     }\n \n@@ -221,6 +227,7 @@ impl InlineAsmReg {\n             Self::Arm(r) => InlineAsmRegClass::Arm(r.reg_class()),\n             Self::AArch64(r) => InlineAsmRegClass::AArch64(r.reg_class()),\n             Self::RiscV(r) => InlineAsmRegClass::RiscV(r.reg_class()),\n+            Self::Hexagon(r) => InlineAsmRegClass::Hexagon(r.reg_class()),\n         }\n     }\n \n@@ -246,6 +253,9 @@ impl InlineAsmReg {\n             InlineAsmArch::Nvptx64 => {\n                 Self::Nvptx(NvptxInlineAsmReg::parse(arch, has_feature, &name)?)\n             }\n+            InlineAsmArch::Hexagon => {\n+                Self::Hexagon(HexagonInlineAsmReg::parse(arch, has_feature, &name)?)\n+            }\n         })\n     }\n \n@@ -262,6 +272,7 @@ impl InlineAsmReg {\n             Self::Arm(r) => r.emit(out, arch, modifier),\n             Self::AArch64(r) => r.emit(out, arch, modifier),\n             Self::RiscV(r) => r.emit(out, arch, modifier),\n+            Self::Hexagon(r) => r.emit(out, arch, modifier),\n         }\n     }\n \n@@ -271,6 +282,7 @@ impl InlineAsmReg {\n             Self::Arm(r) => r.overlapping_regs(|r| cb(Self::Arm(r))),\n             Self::AArch64(_) => cb(self),\n             Self::RiscV(_) => cb(self),\n+            Self::Hexagon(r) => r.overlapping_regs(|r| cb(Self::Hexagon(r))),\n         }\n     }\n }\n@@ -292,6 +304,7 @@ pub enum InlineAsmRegClass {\n     AArch64(AArch64InlineAsmRegClass),\n     RiscV(RiscVInlineAsmRegClass),\n     Nvptx(NvptxInlineAsmRegClass),\n+    Hexagon(HexagonInlineAsmRegClass),\n }\n \n impl InlineAsmRegClass {\n@@ -302,6 +315,7 @@ impl InlineAsmRegClass {\n             Self::AArch64(r) => r.name(),\n             Self::RiscV(r) => r.name(),\n             Self::Nvptx(r) => r.name(),\n+            Self::Hexagon(r) => r.name(),\n         }\n     }\n \n@@ -315,6 +329,7 @@ impl InlineAsmRegClass {\n             Self::AArch64(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::AArch64),\n             Self::RiscV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::RiscV),\n             Self::Nvptx(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Nvptx),\n+            Self::Hexagon(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Hexagon),\n         }\n     }\n \n@@ -335,6 +350,7 @@ impl InlineAsmRegClass {\n             Self::AArch64(r) => r.suggest_modifier(arch, ty),\n             Self::RiscV(r) => r.suggest_modifier(arch, ty),\n             Self::Nvptx(r) => r.suggest_modifier(arch, ty),\n+            Self::Hexagon(r) => r.suggest_modifier(arch, ty),\n         }\n     }\n \n@@ -351,6 +367,7 @@ impl InlineAsmRegClass {\n             Self::AArch64(r) => r.default_modifier(arch),\n             Self::RiscV(r) => r.default_modifier(arch),\n             Self::Nvptx(r) => r.default_modifier(arch),\n+            Self::Hexagon(r) => r.default_modifier(arch),\n         }\n     }\n \n@@ -366,6 +383,7 @@ impl InlineAsmRegClass {\n             Self::AArch64(r) => r.supported_types(arch),\n             Self::RiscV(r) => r.supported_types(arch),\n             Self::Nvptx(r) => r.supported_types(arch),\n+            Self::Hexagon(r) => r.supported_types(arch),\n         }\n     }\n \n@@ -384,6 +402,9 @@ impl InlineAsmRegClass {\n                     Self::RiscV(RiscVInlineAsmRegClass::parse(arch, name)?)\n                 }\n                 InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmRegClass::parse(arch, name)?),\n+                InlineAsmArch::Hexagon => {\n+                    Self::Hexagon(HexagonInlineAsmRegClass::parse(arch, name)?)\n+                }\n             })\n         })\n     }\n@@ -397,6 +418,7 @@ impl InlineAsmRegClass {\n             Self::AArch64(r) => r.valid_modifiers(arch),\n             Self::RiscV(r) => r.valid_modifiers(arch),\n             Self::Nvptx(r) => r.valid_modifiers(arch),\n+            Self::Hexagon(r) => r.valid_modifiers(arch),\n         }\n     }\n }\n@@ -541,5 +563,10 @@ pub fn allocatable_registers(\n             nvptx::fill_reg_map(arch, has_feature, &mut map);\n             map\n         }\n+        InlineAsmArch::Hexagon => {\n+            let mut map = hexagon::regclass_map();\n+            hexagon::fill_reg_map(arch, has_feature, &mut map);\n+            map\n+        }\n     }\n }"}, {"sha": "060877f80adefd9dc6b1fb0c563f5159a5cabdc5", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 130, "deletions": 26, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n@@ -25,7 +26,7 @@ use rustc_middle::ty::{\n     TypeFoldable, WithConstness,\n };\n use rustc_session::DiagnosticMessageId;\n-use rustc_span::{ExpnKind, Span, DUMMY_SP};\n+use rustc_span::{ExpnKind, MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n \n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -1695,36 +1696,95 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n-        if let (\n-            ty::PredicateKind::Trait(pred, _),\n-            ObligationCauseCode::BindingObligation(item_def_id, span),\n-        ) = (obligation.predicate.kind(), &obligation.cause.code)\n-        {\n-            if let (Some(generics), true) = (\n-                self.tcx.hir().get_if_local(*item_def_id).as_ref().and_then(|n| n.generics()),\n-                Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),\n-            ) {\n-                for param in generics.params {\n-                    if param.span == *span\n-                        && !param.bounds.iter().any(|bound| {\n-                            bound.trait_ref().and_then(|trait_ref| trait_ref.trait_def_id())\n-                                == self.tcx.lang_items().sized_trait()\n-                        })\n-                    {\n-                        let (span, separator) = match param.bounds {\n-                            [] => (span.shrink_to_hi(), \":\"),\n-                            [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n-                        };\n-                        err.span_suggestion_verbose(\n-                            span,\n-                            \"consider relaxing the implicit `Sized` restriction\",\n-                            format!(\"{} ?Sized\", separator),\n-                            Applicability::MachineApplicable,\n+        let (pred, item_def_id, span) =\n+            match (obligation.predicate.kind(), &obligation.cause.code.peel_derives()) {\n+                (\n+                    ty::PredicateKind::Trait(pred, _),\n+                    ObligationCauseCode::BindingObligation(item_def_id, span),\n+                ) => (pred, item_def_id, span),\n+                _ => return,\n+            };\n+\n+        let node = match (\n+            self.tcx.hir().get_if_local(*item_def_id),\n+            Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),\n+        ) {\n+            (Some(node), true) => node,\n+            _ => return,\n+        };\n+        let generics = match node.generics() {\n+            Some(generics) => generics,\n+            None => return,\n+        };\n+        for param in generics.params {\n+            if param.span != *span\n+                || param.bounds.iter().any(|bound| {\n+                    bound.trait_ref().and_then(|trait_ref| trait_ref.trait_def_id())\n+                        == self.tcx.lang_items().sized_trait()\n+                })\n+            {\n+                continue;\n+            }\n+            match node {\n+                hir::Node::Item(\n+                    item\n+                    @\n+                    hir::Item {\n+                        kind:\n+                            hir::ItemKind::Enum(..)\n+                            | hir::ItemKind::Struct(..)\n+                            | hir::ItemKind::Union(..),\n+                        ..\n+                    },\n+                ) => {\n+                    // Suggesting `T: ?Sized` is only valid in an ADT if `T` is only used in a\n+                    // borrow. `struct S<'a, T: ?Sized>(&'a T);` is valid, `struct S<T: ?Sized>(T);`\n+                    // is not.\n+                    let mut visitor = FindTypeParam {\n+                        param: param.name.ident().name,\n+                        invalid_spans: vec![],\n+                        nested: false,\n+                    };\n+                    visitor.visit_item(item);\n+                    if !visitor.invalid_spans.is_empty() {\n+                        let mut multispan: MultiSpan = param.span.into();\n+                        multispan.push_span_label(\n+                            param.span,\n+                            format!(\"this could be changed to `{}: ?Sized`...\", param.name.ident()),\n+                        );\n+                        for sp in visitor.invalid_spans {\n+                            multispan.push_span_label(\n+                                sp,\n+                                format!(\n+                                    \"...if indirection was used here: `Box<{}>`\",\n+                                    param.name.ident(),\n+                                ),\n+                            );\n+                        }\n+                        err.span_help(\n+                            multispan,\n+                            &format!(\n+                                \"you could relax the implicit `Sized` bound on `{T}` if it were \\\n+                                 used through indirection like `&{T}` or `Box<{T}>`\",\n+                                T = param.name.ident(),\n+                            ),\n                         );\n                         return;\n                     }\n                 }\n+                _ => {}\n             }\n+            let (span, separator) = match param.bounds {\n+                [] => (span.shrink_to_hi(), \":\"),\n+                [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n+            };\n+            err.span_suggestion_verbose(\n+                span,\n+                \"consider relaxing the implicit `Sized` restriction\",\n+                format!(\"{} ?Sized\", separator),\n+                Applicability::MachineApplicable,\n+            );\n+            return;\n         }\n     }\n \n@@ -1744,6 +1804,50 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n     }\n }\n \n+/// Look for type `param` in an ADT being used only through a reference to confirm that suggesting\n+/// `param: ?Sized` would be a valid constraint.\n+struct FindTypeParam {\n+    param: rustc_span::Symbol,\n+    invalid_spans: Vec<Span>,\n+    nested: bool,\n+}\n+\n+impl<'v> Visitor<'v> for FindTypeParam {\n+    type Map = rustc_hir::intravisit::ErasedMap<'v>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+        // We collect the spans of all uses of the \"bare\" type param, like in `field: T` or\n+        // `field: (T, T)` where we could make `T: ?Sized` while skipping cases that are known to be\n+        // valid like `field: &'a T` or `field: *mut T` and cases that *might* have further `Sized`\n+        // obligations like `Box<T>` and `Vec<T>`, but we perform no extra analysis for those cases\n+        // and suggest `T: ?Sized` regardless of their obligations. This is fine because the errors\n+        // in that case should make what happened clear enough.\n+        match ty.kind {\n+            hir::TyKind::Ptr(_) | hir::TyKind::Rptr(..) | hir::TyKind::TraitObject(..) => {}\n+            hir::TyKind::Path(hir::QPath::Resolved(None, path))\n+                if path.segments.len() == 1 && path.segments[0].ident.name == self.param =>\n+            {\n+                if !self.nested {\n+                    self.invalid_spans.push(ty.span);\n+                }\n+            }\n+            hir::TyKind::Path(_) => {\n+                let prev = self.nested;\n+                self.nested = true;\n+                hir::intravisit::walk_ty(self, ty);\n+                self.nested = prev;\n+            }\n+            _ => {\n+                hir::intravisit::walk_ty(self, ty);\n+            }\n+        }\n+    }\n+}\n+\n pub fn recursive_type_with_infinite_size_error(\n     tcx: TyCtxt<'tcx>,\n     type_def_id: DefId,"}, {"sha": "bcfc0cf347cbcf94c9144615ef4b6f47bbc2bfbb", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -783,6 +783,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let literal_is_ty_suffixed = |expr: &hir::Expr<'_>| {\n             if let hir::ExprKind::Lit(lit) = &expr.kind { lit.node.is_suffixed() } else { false }\n         };\n+        let is_negative_int =\n+            |expr: &hir::Expr<'_>| matches!(expr.kind, hir::ExprKind::Unary(hir::UnOp::UnNeg, ..));\n+        let is_uint = |ty: Ty<'_>| matches!(ty.kind, ty::Uint(..));\n \n         let in_const_context = self.tcx.hir().is_inside_const_context(expr.hir_id);\n \n@@ -807,7 +810,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \"you can convert `{}` from `{}` to `{}`, matching the type of `{}`\",\n                         lhs_src, expected_ty, checked_ty, src\n                     );\n-                    let suggestion = format!(\"{}::from({})\", checked_ty, lhs_src,);\n+                    let suggestion = format!(\"{}::from({})\", checked_ty, lhs_src);\n                     (lhs_expr.span, msg, suggestion)\n                 } else {\n                     let msg = format!(\"{} and panic if the converted value wouldn't fit\", msg);\n@@ -822,8 +825,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             |err: &mut DiagnosticBuilder<'_>,\n              found_to_exp_is_fallible: bool,\n              exp_to_found_is_fallible: bool| {\n+                let always_fallible = found_to_exp_is_fallible\n+                    && (exp_to_found_is_fallible || expected_ty_expr.is_none());\n                 let msg = if literal_is_ty_suffixed(expr) {\n                     &lit_msg\n+                } else if always_fallible && (is_negative_int(expr) && is_uint(expected_ty)) {\n+                    // We now know that converting either the lhs or rhs is fallible. Before we\n+                    // suggest a fallible conversion, check if the value can never fit in the\n+                    // expected type.\n+                    let msg = format!(\"`{}` cannot fit into type `{}`\", src, expected_ty);\n+                    err.note(&msg);\n+                    return;\n                 } else if in_const_context {\n                     // Do not recommend `into` or `try_into` in const contexts.\n                     return;"}, {"sha": "6a00667637155d0b217fa80b53cf5b3366ec8e5e", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -888,10 +888,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     rcvr,\n                     probe::ProbeScope::AllTraits,\n                 ) {\n-                    err.span_label(\n-                        pick.item.ident.span,\n-                        &format!(\"the method is available for `{}` here\", new_rcvr_t),\n-                    );\n+                    debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n+                    // Make sure the method is defined for the *actual* receiver:\n+                    // we don't want to treat `Box<Self>` as a receiver if\n+                    // it only works because of an autoderef to `&self`\n+                    if pick.autoderefs == 0 {\n+                        err.span_label(\n+                            pick.item.ident.span,\n+                            &format!(\"the method is available for `{}` here\", new_rcvr_t),\n+                        );\n+                    }\n                 }\n             }\n         };"}, {"sha": "259c4a8664f1bf4fbbfd1dbf3f1ba21e0bcb977e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -194,11 +194,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.lookup_probe(span, segment.ident, self_ty, call_expr, ProbeScope::TraitsInScope)?;\n \n         for import_id in &pick.import_ids {\n-            let import_def_id = self.tcx.hir().local_def_id(*import_id);\n-            debug!(\"used_trait_import: {:?}\", import_def_id);\n+            debug!(\"used_trait_import: {:?}\", import_id);\n             Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n                 .unwrap()\n-                .insert(import_def_id.to_def_id());\n+                .insert(*import_id);\n         }\n \n         self.tcx.check_stability(pick.item.def_id, Some(call_expr.hir_id), span);\n@@ -461,9 +460,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let mut tables = self.tables.borrow_mut();\n             let used_trait_imports = Lrc::get_mut(&mut tables.used_trait_imports).unwrap();\n             for import_id in pick.import_ids {\n-                let import_def_id = tcx.hir().local_def_id(import_id);\n-                debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_def_id);\n-                used_trait_imports.insert(import_def_id.to_def_id());\n+                debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_id);\n+                used_trait_imports.insert(import_id);\n             }\n         }\n "}, {"sha": "eb8f76687174e90a5b4614bbd119da19e5910e57", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -28,6 +28,7 @@ use rustc_middle::ty::{\n };\n use rustc_session::config::nightly_options;\n use rustc_session::lint;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::query::method_autoderef::MethodAutoderefBadTy;\n@@ -129,7 +130,7 @@ struct Candidate<'tcx> {\n     xform_ret_ty: Option<Ty<'tcx>>,\n     item: ty::AssocItem,\n     kind: CandidateKind<'tcx>,\n-    import_ids: SmallVec<[hir::HirId; 1]>,\n+    import_ids: SmallVec<[LocalDefId; 1]>,\n }\n \n #[derive(Debug)]\n@@ -158,7 +159,7 @@ enum ProbeResult {\n pub struct Pick<'tcx> {\n     pub item: ty::AssocItem,\n     pub kind: PickKind<'tcx>,\n-    pub import_ids: SmallVec<[hir::HirId; 1]>,\n+    pub import_ids: SmallVec<[LocalDefId; 1]>,\n \n     // Indicates that the source expression should be autoderef'd N times\n     //\n@@ -930,7 +931,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     fn assemble_extension_candidates_for_trait(\n         &mut self,\n-        import_ids: &SmallVec<[hir::HirId; 1]>,\n+        import_ids: &SmallVec<[LocalDefId; 1]>,\n         trait_def_id: DefId,\n     ) -> Result<(), MethodError<'tcx>> {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\", trait_def_id);"}, {"sha": "775441cb746661b0236edf555afbf72f334c7f42", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -97,7 +97,7 @@ use rustc_errors::ErrorReported;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items::{\n@@ -840,7 +840,7 @@ fn has_typeck_tables(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n }\n \n-fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &DefIdSet {\n+fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &FxHashSet<LocalDefId> {\n     &*tcx.typeck_tables_of(def_id).used_trait_imports\n }\n "}, {"sha": "d3bccaaa3e4b98e3f8977c6b1964f995140cfd5c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -439,7 +439,10 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n-    fn constrain_adjustments(&mut self, expr: &hir::Expr<'_>) -> mc::McResult<mc::Place<'tcx>> {\n+    fn constrain_adjustments(\n+        &mut self,\n+        expr: &hir::Expr<'_>,\n+    ) -> mc::McResult<mc::PlaceWithHirId<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n         let mut place = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n@@ -480,12 +483,12 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     fn check_safety_of_rvalue_destructor_if_necessary(\n         &mut self,\n-        place: &mc::Place<'tcx>,\n+        place_with_id: &mc::PlaceWithHirId<'tcx>,\n         span: Span,\n     ) {\n-        if let mc::PlaceBase::Rvalue = place.base {\n-            if place.projections.is_empty() {\n-                let typ = self.resolve_type(place.ty);\n+        if let mc::PlaceBase::Rvalue = place_with_id.place.base {\n+            if place_with_id.place.projections.is_empty() {\n+                let typ = self.resolve_type(place_with_id.place.ty);\n                 let body_id = self.body_id;\n                 let _ = dropck::check_drop_obligations(self, typ, span, body_id);\n             }\n@@ -570,7 +573,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n-    fn link_pattern(&self, discr_cmt: mc::Place<'tcx>, root_pat: &hir::Pat<'_>) {\n+    fn link_pattern(&self, discr_cmt: mc::PlaceWithHirId<'tcx>, root_pat: &hir::Pat<'_>) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id }| {\n@@ -591,7 +594,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn link_autoref(\n         &self,\n         expr: &hir::Expr<'_>,\n-        expr_cmt: &mc::Place<'tcx>,\n+        expr_cmt: &mc::PlaceWithHirId<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n         debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n@@ -612,7 +615,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         id: hir::HirId,\n         mutbl: hir::Mutability,\n-        cmt_borrowed: &mc::Place<'tcx>,\n+        cmt_borrowed: &mc::PlaceWithHirId<'tcx>,\n     ) {\n         debug!(\n             \"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n@@ -635,12 +638,12 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         borrow_region: ty::Region<'tcx>,\n         borrow_kind: ty::BorrowKind,\n-        borrow_place: &mc::Place<'tcx>,\n+        borrow_place: &mc::PlaceWithHirId<'tcx>,\n     ) {\n-        let origin = infer::DataBorrowed(borrow_place.ty, span);\n-        self.type_must_outlive(origin, borrow_place.ty, borrow_region);\n+        let origin = infer::DataBorrowed(borrow_place.place.ty, span);\n+        self.type_must_outlive(origin, borrow_place.place.ty, borrow_region);\n \n-        for pointer_ty in borrow_place.deref_tys() {\n+        for pointer_ty in borrow_place.place.deref_tys() {\n             debug!(\n                 \"link_region(borrow_region={:?}, borrow_kind={:?}, pointer_ty={:?})\",\n                 borrow_region, borrow_kind, borrow_place\n@@ -656,7 +659,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                 _ => assert!(pointer_ty.is_box(), \"unexpected built-in deref type {}\", pointer_ty),\n             }\n         }\n-        if let mc::PlaceBase::Upvar(upvar_id) = borrow_place.base {\n+        if let mc::PlaceBase::Upvar(upvar_id) = borrow_place.place.base {\n             self.link_upvar_region(span, borrow_region, upvar_id);\n         }\n     }"}, {"sha": "0f3133e0695f10b5a35c7883a96c03ff46d80398", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -270,10 +270,13 @@ struct InferBorrowKind<'a, 'tcx> {\n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     fn adjust_upvar_borrow_kind_for_consume(\n         &mut self,\n-        place: &mc::Place<'tcx>,\n+        place_with_id: &mc::PlaceWithHirId<'tcx>,\n         mode: euv::ConsumeMode,\n     ) {\n-        debug!(\"adjust_upvar_borrow_kind_for_consume(place={:?}, mode={:?})\", place, mode);\n+        debug!(\n+            \"adjust_upvar_borrow_kind_for_consume(place_with_id={:?}, mode={:?})\",\n+            place_with_id, mode\n+        );\n \n         // we only care about moves\n         match mode {\n@@ -284,7 +287,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         }\n \n         let tcx = self.fcx.tcx;\n-        let upvar_id = if let PlaceBase::Upvar(upvar_id) = place.base {\n+        let upvar_id = if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             upvar_id\n         } else {\n             return;\n@@ -296,22 +299,22 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         self.adjust_closure_kind(\n             upvar_id.closure_expr_id,\n             ty::ClosureKind::FnOnce,\n-            place.span,\n+            tcx.hir().span(place_with_id.hir_id),\n             var_name(tcx, upvar_id.var_path.hir_id),\n         );\n \n         self.adjust_upvar_captures.insert(upvar_id, ty::UpvarCapture::ByValue);\n     }\n \n-    /// Indicates that `place` is being directly mutated (e.g., assigned\n+    /// Indicates that `place_with_id` is being directly mutated (e.g., assigned\n     /// to). If the place is based on a by-ref upvar, this implies that\n     /// the upvar must be borrowed using an `&mut` borrow.\n-    fn adjust_upvar_borrow_kind_for_mut(&mut self, place: &mc::Place<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_mut(place={:?})\", place);\n+    fn adjust_upvar_borrow_kind_for_mut(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>) {\n+        debug!(\"adjust_upvar_borrow_kind_for_mut(place_with_id={:?})\", place_with_id);\n \n-        if let PlaceBase::Upvar(upvar_id) = place.base {\n+        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             let mut borrow_kind = ty::MutBorrow;\n-            for pointer_ty in place.deref_tys() {\n+            for pointer_ty in place_with_id.place.deref_tys() {\n                 match pointer_ty.kind {\n                     // Raw pointers don't inherit mutability.\n                     ty::RawPtr(_) => return,\n@@ -323,20 +326,28 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n                     _ => (),\n                 }\n             }\n-            self.adjust_upvar_deref(upvar_id, place.span, borrow_kind);\n+            self.adjust_upvar_deref(\n+                upvar_id,\n+                self.fcx.tcx.hir().span(place_with_id.hir_id),\n+                borrow_kind,\n+            );\n         }\n     }\n \n-    fn adjust_upvar_borrow_kind_for_unique(&mut self, place: &mc::Place<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_unique(place={:?})\", place);\n+    fn adjust_upvar_borrow_kind_for_unique(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>) {\n+        debug!(\"adjust_upvar_borrow_kind_for_unique(place_with_id={:?})\", place_with_id);\n \n-        if let PlaceBase::Upvar(upvar_id) = place.base {\n-            if place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n+        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n+            if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n                 // Raw pointers don't inherit mutability.\n                 return;\n             }\n             // for a borrowed pointer to be unique, its base must be unique\n-            self.adjust_upvar_deref(upvar_id, place.span, ty::UniqueImmBorrow);\n+            self.adjust_upvar_deref(\n+                upvar_id,\n+                self.fcx.tcx.hir().span(place_with_id.hir_id),\n+                ty::UniqueImmBorrow,\n+            );\n         }\n     }\n \n@@ -453,26 +464,26 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n-    fn consume(&mut self, place: &mc::Place<'tcx>, mode: euv::ConsumeMode) {\n-        debug!(\"consume(place={:?},mode={:?})\", place, mode);\n-        self.adjust_upvar_borrow_kind_for_consume(place, mode);\n+    fn consume(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, mode: euv::ConsumeMode) {\n+        debug!(\"consume(place_with_id={:?},mode={:?})\", place_with_id, mode);\n+        self.adjust_upvar_borrow_kind_for_consume(place_with_id, mode);\n     }\n \n-    fn borrow(&mut self, place: &mc::Place<'tcx>, bk: ty::BorrowKind) {\n-        debug!(\"borrow(place={:?}, bk={:?})\", place, bk);\n+    fn borrow(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n+        debug!(\"borrow(place_with_id={:?}, bk={:?})\", place_with_id, bk);\n \n         match bk {\n             ty::ImmBorrow => {}\n             ty::UniqueImmBorrow => {\n-                self.adjust_upvar_borrow_kind_for_unique(place);\n+                self.adjust_upvar_borrow_kind_for_unique(place_with_id);\n             }\n             ty::MutBorrow => {\n-                self.adjust_upvar_borrow_kind_for_mut(place);\n+                self.adjust_upvar_borrow_kind_for_mut(place_with_id);\n             }\n         }\n     }\n \n-    fn mutate(&mut self, assignee_place: &mc::Place<'tcx>) {\n+    fn mutate(&mut self, assignee_place: &mc::PlaceWithHirId<'tcx>) {\n         debug!(\"mutate(assignee_place={:?})\", assignee_place);\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_place);"}, {"sha": "4704d8fc7666f09eec5d394a4a4439ed7b7396aa", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -4,10 +4,8 @@\n \n use crate::check::FnCtxt;\n \n-use rustc_data_structures::sync::Lrc;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefIdSet;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::InferCtxt;\n@@ -67,10 +65,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.visit_user_provided_sigs();\n         wbcx.visit_generator_interior_types();\n \n-        let used_trait_imports = mem::replace(\n-            &mut self.tables.borrow_mut().used_trait_imports,\n-            Lrc::new(DefIdSet::default()),\n-        );\n+        let used_trait_imports = mem::take(&mut self.tables.borrow_mut().used_trait_imports);\n         debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n         wbcx.tables.used_trait_imports = used_trait_imports;\n "}, {"sha": "81daf064bb36866a74d90663460cbfd2958766de", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -1,14 +1,14 @@\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIdSet, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint;\n use rustc_span::{Span, Symbol};\n \n pub fn check_crate(tcx: TyCtxt<'_>) {\n-    let mut used_trait_imports = DefIdSet::default();\n+    let mut used_trait_imports = FxHashSet::default();\n     for &body_id in tcx.hir().krate().bodies.keys() {\n         let item_def_id = tcx.hir().body_owner_def_id(body_id);\n         let imports = tcx.used_trait_imports(item_def_id);\n@@ -39,7 +39,7 @@ impl ItemLikeVisitor<'v> for CheckVisitor<'tcx> {\n \n struct CheckVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    used_trait_imports: DefIdSet,\n+    used_trait_imports: FxHashSet<LocalDefId>,\n }\n \n impl CheckVisitor<'tcx> {\n@@ -49,7 +49,7 @@ impl CheckVisitor<'tcx> {\n             return;\n         }\n \n-        if self.used_trait_imports.contains(&def_id.to_def_id()) {\n+        if self.used_trait_imports.contains(&def_id) {\n             return;\n         }\n "}, {"sha": "b72fae96e4ca0ac25d6d047c57c35ff140522ccd", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -5,7 +5,7 @@\n pub use self::ConsumeMode::*;\n \n // Export these here so that Clippy can use them.\n-pub use mc::{Place, PlaceBase, Projection};\n+pub use mc::{PlaceBase, PlaceWithHirId, Projection};\n \n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -25,13 +25,13 @@ use rustc_span::Span;\n pub trait Delegate<'tcx> {\n     // The value found at `place` is either copied or moved, depending\n     // on mode.\n-    fn consume(&mut self, place: &mc::Place<'tcx>, mode: ConsumeMode);\n+    fn consume(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, mode: ConsumeMode);\n \n     // The value found at `place` is being borrowed with kind `bk`.\n-    fn borrow(&mut self, place: &mc::Place<'tcx>, bk: ty::BorrowKind);\n+    fn borrow(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, bk: ty::BorrowKind);\n \n-    // The path at `place` is being assigned to.\n-    fn mutate(&mut self, assignee_place: &mc::Place<'tcx>);\n+    // The path at `place_with_id` is being assigned to.\n+    fn mutate(&mut self, assignee_place: &mc::PlaceWithHirId<'tcx>);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -113,11 +113,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         self.mc.tcx()\n     }\n \n-    fn delegate_consume(&mut self, place: &Place<'tcx>) {\n-        debug!(\"delegate_consume(place={:?})\", place);\n+    fn delegate_consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>) {\n+        debug!(\"delegate_consume(place_with_id={:?})\", place_with_id);\n \n-        let mode = copy_or_move(&self.mc, place);\n-        self.delegate.consume(place, mode);\n+        let mode = copy_or_move(&self.mc, place_with_id);\n+        self.delegate.consume(place_with_id, mode);\n     }\n \n     fn consume_exprs(&mut self, exprs: &[hir::Expr<'_>]) {\n@@ -129,22 +129,22 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     pub fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n-        let place = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate_consume(&place);\n+        let place_with_id = return_if_err!(self.mc.cat_expr(expr));\n+        self.delegate_consume(&place_with_id);\n         self.walk_expr(expr);\n     }\n \n     fn mutate_expr(&mut self, expr: &hir::Expr<'_>) {\n-        let place = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.mutate(&place);\n+        let place_with_id = return_if_err!(self.mc.cat_expr(expr));\n+        self.delegate.mutate(&place_with_id);\n         self.walk_expr(expr);\n     }\n \n     fn borrow_expr(&mut self, expr: &hir::Expr<'_>, bk: ty::BorrowKind) {\n         debug!(\"borrow_expr(expr={:?}, bk={:?})\", expr, bk);\n \n-        let place = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.borrow(&place, bk);\n+        let place_with_id = return_if_err!(self.mc.cat_expr(expr));\n+        self.delegate.borrow(&place_with_id, bk);\n \n         self.walk_expr(expr)\n     }\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n-        match with_place.ty.kind {\n+        match with_place.place.ty.kind {\n             ty::Adt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n@@ -422,14 +422,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     // process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr<'_>) {\n         let adjustments = self.mc.tables.expr_adjustments(expr);\n-        let mut place = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+        let mut place_with_id = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n         for adjustment in adjustments {\n             debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n             match adjustment.kind {\n                 adjustment::Adjust::NeverToAny | adjustment::Adjust::Pointer(_) => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    self.delegate_consume(&place);\n+                    self.delegate_consume(&place_with_id);\n                 }\n \n                 adjustment::Adjust::Deref(None) => {}\n@@ -441,14 +441,15 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 // this is an autoref of `x`.\n                 adjustment::Adjust::Deref(Some(ref deref)) => {\n                     let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n-                    self.delegate.borrow(&place, bk);\n+                    self.delegate.borrow(&place_with_id, bk);\n                 }\n \n                 adjustment::Adjust::Borrow(ref autoref) => {\n-                    self.walk_autoref(expr, &place, autoref);\n+                    self.walk_autoref(expr, &place_with_id, autoref);\n                 }\n             }\n-            place = return_if_err!(self.mc.cat_expr_adjusted(expr, place, &adjustment));\n+            place_with_id =\n+                return_if_err!(self.mc.cat_expr_adjusted(expr, place_with_id, &adjustment));\n         }\n     }\n \n@@ -458,7 +459,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     fn walk_autoref(\n         &mut self,\n         expr: &hir::Expr<'_>,\n-        base_place: &mc::Place<'tcx>,\n+        base_place: &mc::PlaceWithHirId<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n         debug!(\n@@ -479,7 +480,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_arm(&mut self, discr_place: &Place<'tcx>, arm: &hir::Arm<'_>) {\n+    fn walk_arm(&mut self, discr_place: &PlaceWithHirId<'tcx>, arm: &hir::Arm<'_>) {\n         self.walk_pat(discr_place, &arm.pat);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n@@ -491,12 +492,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n     /// let binding, and *not* a match arm or nested pat.)\n-    fn walk_irrefutable_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat<'_>) {\n+    fn walk_irrefutable_pat(&mut self, discr_place: &PlaceWithHirId<'tcx>, pat: &hir::Pat<'_>) {\n         self.walk_pat(discr_place, pat);\n     }\n \n     /// The core driver for walking a pattern\n-    fn walk_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat<'_>) {\n+    fn walk_pat(&mut self, discr_place: &PlaceWithHirId<'tcx>, pat: &hir::Pat<'_>) {\n         debug!(\"walk_pat(discr_place={:?}, pat={:?})\", discr_place, pat);\n \n         let tcx = self.tcx();\n@@ -569,7 +570,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         closure_hir_id: hir::HirId,\n         closure_span: Span,\n         var_id: hir::HirId,\n-    ) -> mc::McResult<mc::Place<'tcx>> {\n+    ) -> mc::McResult<mc::PlaceWithHirId<'tcx>> {\n         // Create the place for the variable being borrowed, from the\n         // perspective of the creator (parent) of the closure.\n         let var_ty = self.mc.node_ty(var_id)?;\n@@ -579,7 +580,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n fn copy_or_move<'a, 'tcx>(\n     mc: &mc::MemCategorizationContext<'a, 'tcx>,\n-    place: &Place<'tcx>,\n+    place_with_id: &PlaceWithHirId<'tcx>,\n ) -> ConsumeMode {\n-    if !mc.type_is_copy_modulo_regions(place.ty, place.span) { Move } else { Copy }\n+    if !mc.type_is_copy_modulo_regions(\n+        place_with_id.place.ty,\n+        mc.tcx().hir().span(place_with_id.hir_id),\n+    ) {\n+        Move\n+    } else {\n+        Copy\n+    }\n }"}, {"sha": "d619d37be2d7b9ef201c9037d63dd7f24de4f149", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 98, "deletions": 95, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -74,22 +74,24 @@ pub enum PlaceBase {\n }\n \n #[derive(Clone, Debug)]\n-pub enum Projection<'tcx> {\n+pub enum ProjectionKind<'tcx> {\n     /// A dereference of a pointer, reference or `Box<T>` of the given type\n     Deref(Ty<'tcx>),\n     /// An index or a field\n     Other,\n }\n \n+#[derive(Clone, Debug)]\n+pub struct Projection<'tcx> {\n+    /// Defines the type of access\n+    kind: ProjectionKind<'tcx>,\n+}\n+\n /// A `Place` represents how a value is located in memory.\n ///\n /// This is an HIR version of `mir::Place`\n #[derive(Clone, Debug)]\n pub struct Place<'tcx> {\n-    /// `HirId` of the expression or pattern producing this value.\n-    pub hir_id: hir::HirId,\n-    /// The `Span` of the expression or pattern producing this value.\n-    pub span: Span,\n     /// The type of the `Place`\n     pub ty: Ty<'tcx>,\n     /// The \"outermost\" place that holds this value.\n@@ -98,6 +100,32 @@ pub struct Place<'tcx> {\n     pub projections: Vec<Projection<'tcx>>,\n }\n \n+/// A `PlaceWithHirId` represents how a value is located in memory.\n+///\n+/// This is an HIR version of `mir::Place`\n+#[derive(Clone, Debug)]\n+pub struct PlaceWithHirId<'tcx> {\n+    /// `HirId` of the expression or pattern producing this value.\n+    pub hir_id: hir::HirId,\n+\n+    /// Information about the `Place`\n+    pub place: Place<'tcx>,\n+}\n+\n+impl<'tcx> PlaceWithHirId<'tcx> {\n+    crate fn new(\n+        hir_id: hir::HirId,\n+        ty: Ty<'tcx>,\n+        base: PlaceBase,\n+        projections: Vec<Projection<'tcx>>,\n+    ) -> PlaceWithHirId<'tcx> {\n+        PlaceWithHirId {\n+            hir_id: hir_id,\n+            place: Place { ty: ty, base: base, projections: projections },\n+        }\n+    }\n+}\n+\n impl<'tcx> Place<'tcx> {\n     /// Returns an iterator of the types that have to be dereferenced to access\n     /// the `Place`.\n@@ -107,7 +135,7 @@ impl<'tcx> Place<'tcx> {\n     ///`*const u32` then `&*const u32`.\n     crate fn deref_tys(&self) -> impl Iterator<Item = Ty<'tcx>> + '_ {\n         self.projections.iter().rev().filter_map(|proj| {\n-            if let Projection::Deref(deref_ty) = *proj { Some(deref_ty) } else { None }\n+            if let ProjectionKind::Deref(deref_ty) = proj.kind { Some(deref_ty) } else { None }\n         })\n     }\n }\n@@ -280,14 +308,14 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret_ty)\n     }\n \n-    crate fn cat_expr(&self, expr: &hir::Expr<'_>) -> McResult<Place<'tcx>> {\n+    crate fn cat_expr(&self, expr: &hir::Expr<'_>) -> McResult<PlaceWithHirId<'tcx>> {\n         // This recursion helper avoids going through *too many*\n         // adjustments, since *only* non-overloaded deref recurses.\n         fn helper<'a, 'tcx>(\n             mc: &MemCategorizationContext<'a, 'tcx>,\n             expr: &hir::Expr<'_>,\n             adjustments: &[adjustment::Adjustment<'tcx>],\n-        ) -> McResult<Place<'tcx>> {\n+        ) -> McResult<PlaceWithHirId<'tcx>> {\n             match adjustments.split_last() {\n                 None => mc.cat_expr_unadjusted(expr),\n                 Some((adjustment, previous)) => {\n@@ -302,9 +330,9 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     crate fn cat_expr_adjusted(\n         &self,\n         expr: &hir::Expr<'_>,\n-        previous: Place<'tcx>,\n+        previous: PlaceWithHirId<'tcx>,\n         adjustment: &adjustment::Adjustment<'tcx>,\n-    ) -> McResult<Place<'tcx>> {\n+    ) -> McResult<PlaceWithHirId<'tcx>> {\n         self.cat_expr_adjusted_with(expr, || Ok(previous), adjustment)\n     }\n \n@@ -313,9 +341,9 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         previous: F,\n         adjustment: &adjustment::Adjustment<'tcx>,\n-    ) -> McResult<Place<'tcx>>\n+    ) -> McResult<PlaceWithHirId<'tcx>>\n     where\n-        F: FnOnce() -> McResult<Place<'tcx>>,\n+        F: FnOnce() -> McResult<PlaceWithHirId<'tcx>>,\n     {\n         debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n         let target = self.resolve_vars_if_possible(&adjustment.target);\n@@ -342,7 +370,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    crate fn cat_expr_unadjusted(&self, expr: &hir::Expr<'_>) -> McResult<Place<'tcx>> {\n+    crate fn cat_expr_unadjusted(&self, expr: &hir::Expr<'_>) -> McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n@@ -418,7 +446,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         span: Span,\n         expr_ty: Ty<'tcx>,\n         res: Res,\n-    ) -> McResult<Place<'tcx>> {\n+    ) -> McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"cat_res: id={:?} expr={:?} def={:?}\", hir_id, expr_ty, res);\n \n         match res {\n@@ -433,25 +461,15 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             )\n             | Res::SelfCtor(..) => Ok(self.cat_rvalue(hir_id, span, expr_ty)),\n \n-            Res::Def(DefKind::Static, _) => Ok(Place {\n-                hir_id,\n-                span,\n-                ty: expr_ty,\n-                base: PlaceBase::StaticItem,\n-                projections: Vec::new(),\n-            }),\n+            Res::Def(DefKind::Static, _) => {\n+                Ok(PlaceWithHirId::new(hir_id, expr_ty, PlaceBase::StaticItem, Vec::new()))\n+            }\n \n             Res::Local(var_id) => {\n                 if self.upvars.map_or(false, |upvars| upvars.contains_key(&var_id)) {\n-                    self.cat_upvar(hir_id, span, var_id)\n+                    self.cat_upvar(hir_id, var_id)\n                 } else {\n-                    Ok(Place {\n-                        hir_id,\n-                        span,\n-                        ty: expr_ty,\n-                        base: PlaceBase::Local(var_id),\n-                        projections: Vec::new(),\n-                    })\n+                    Ok(PlaceWithHirId::new(hir_id, expr_ty, PlaceBase::Local(var_id), Vec::new()))\n                 }\n             }\n \n@@ -464,12 +482,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     /// Note: the actual upvar access contains invisible derefs of closure\n     /// environment and upvar reference as appropriate. Only regionck cares\n     /// about these dereferences, so we let it compute them as needed.\n-    fn cat_upvar(\n-        &self,\n-        hir_id: hir::HirId,\n-        span: Span,\n-        var_id: hir::HirId,\n-    ) -> McResult<Place<'tcx>> {\n+    fn cat_upvar(&self, hir_id: hir::HirId, var_id: hir::HirId) -> McResult<PlaceWithHirId<'tcx>> {\n         let closure_expr_def_id = self.body_owner;\n \n         let upvar_id = ty::UpvarId {\n@@ -478,41 +491,33 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         };\n         let var_ty = self.node_ty(var_id)?;\n \n-        let ret = Place {\n-            hir_id,\n-            span,\n-            ty: var_ty,\n-            base: PlaceBase::Upvar(upvar_id),\n-            projections: Vec::new(),\n-        };\n+        let ret = PlaceWithHirId::new(hir_id, var_ty, PlaceBase::Upvar(upvar_id), Vec::new());\n \n         debug!(\"cat_upvar ret={:?}\", ret);\n         Ok(ret)\n     }\n \n-    crate fn cat_rvalue(&self, hir_id: hir::HirId, span: Span, expr_ty: Ty<'tcx>) -> Place<'tcx> {\n+    crate fn cat_rvalue(\n+        &self,\n+        hir_id: hir::HirId,\n+        span: Span,\n+        expr_ty: Ty<'tcx>,\n+    ) -> PlaceWithHirId<'tcx> {\n         debug!(\"cat_rvalue hir_id={:?}, expr_ty={:?}, span={:?}\", hir_id, expr_ty, span);\n-        let ret =\n-            Place { hir_id, span, base: PlaceBase::Rvalue, projections: Vec::new(), ty: expr_ty };\n+        let ret = PlaceWithHirId::new(hir_id, expr_ty, PlaceBase::Rvalue, Vec::new());\n         debug!(\"cat_rvalue ret={:?}\", ret);\n         ret\n     }\n \n     crate fn cat_projection<N: HirNode>(\n         &self,\n         node: &N,\n-        base_place: Place<'tcx>,\n+        base_place: PlaceWithHirId<'tcx>,\n         ty: Ty<'tcx>,\n-    ) -> Place<'tcx> {\n-        let mut projections = base_place.projections;\n-        projections.push(Projection::Other);\n-        let ret = Place {\n-            hir_id: node.hir_id(),\n-            span: node.span(),\n-            ty,\n-            base: base_place.base,\n-            projections,\n-        };\n+    ) -> PlaceWithHirId<'tcx> {\n+        let mut projections = base_place.place.projections;\n+        projections.push(Projection { kind: ProjectionKind::Other });\n+        let ret = PlaceWithHirId::new(node.hir_id(), ty, base_place.place.base, projections);\n         debug!(\"cat_field ret {:?}\", ret);\n         ret\n     }\n@@ -521,7 +526,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr<'_>,\n         base: &hir::Expr<'_>,\n-    ) -> McResult<Place<'tcx>> {\n+    ) -> McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"cat_overloaded_place(expr={:?}, base={:?})\", expr, base);\n \n         // Reconstruct the output assuming it's a reference with the\n@@ -540,64 +545,62 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         self.cat_deref(expr, base)\n     }\n \n-    fn cat_deref(&self, node: &impl HirNode, base_place: Place<'tcx>) -> McResult<Place<'tcx>> {\n+    fn cat_deref(\n+        &self,\n+        node: &impl HirNode,\n+        base_place: PlaceWithHirId<'tcx>,\n+    ) -> McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"cat_deref: base_place={:?}\", base_place);\n \n-        let base_ty = base_place.ty;\n+        let base_ty = base_place.place.ty;\n         let deref_ty = match base_ty.builtin_deref(true) {\n             Some(mt) => mt.ty,\n             None => {\n                 debug!(\"explicit deref of non-derefable type: {:?}\", base_ty);\n                 return Err(());\n             }\n         };\n-        let mut projections = base_place.projections;\n-        projections.push(Projection::Deref(base_ty));\n-\n-        let ret = Place {\n-            hir_id: node.hir_id(),\n-            span: node.span(),\n-            ty: deref_ty,\n-            base: base_place.base,\n-            projections,\n-        };\n+        let mut projections = base_place.place.projections;\n+        projections.push(Projection { kind: ProjectionKind::Deref(base_ty) });\n+\n+        let ret = PlaceWithHirId::new(node.hir_id(), deref_ty, base_place.place.base, projections);\n         debug!(\"cat_deref ret {:?}\", ret);\n         Ok(ret)\n     }\n \n     crate fn cat_pattern<F>(\n         &self,\n-        place: Place<'tcx>,\n+        place: PlaceWithHirId<'tcx>,\n         pat: &hir::Pat<'_>,\n         mut op: F,\n     ) -> McResult<()>\n     where\n-        F: FnMut(&Place<'tcx>, &hir::Pat<'_>),\n+        F: FnMut(&PlaceWithHirId<'tcx>, &hir::Pat<'_>),\n     {\n         self.cat_pattern_(place, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n     fn cat_pattern_<F>(\n         &self,\n-        mut place: Place<'tcx>,\n+        mut place_with_id: PlaceWithHirId<'tcx>,\n         pat: &hir::Pat<'_>,\n         op: &mut F,\n     ) -> McResult<()>\n     where\n-        F: FnMut(&Place<'tcx>, &hir::Pat<'_>),\n+        F: FnMut(&PlaceWithHirId<'tcx>, &hir::Pat<'_>),\n     {\n-        // Here, `place` is the `Place` being matched and pat is the pattern it\n+        // Here, `place` is the `PlaceWithHirId` being matched and pat is the pattern it\n         // is being matched against.\n         //\n         // In general, the way that this works is that we walk down the pattern,\n-        // constructing a `Place` that represents the path that will be taken\n+        // constructing a `PlaceWithHirId` that represents the path that will be taken\n         // to reach the value being matched.\n \n-        debug!(\"cat_pattern(pat={:?}, place={:?})\", pat, place);\n+        debug!(\"cat_pattern(pat={:?}, place_with_id={:?})\", pat, place_with_id);\n \n-        // If (pattern) adjustments are active for this pattern, adjust the `Place` correspondingly.\n-        // `Place`s are constructed differently from patterns. For example, in\n+        // If (pattern) adjustments are active for this pattern, adjust the `PlaceWithHirId` correspondingly.\n+        // `PlaceWithHirId`s are constructed differently from patterns. For example, in\n         //\n         // ```\n         // match foo {\n@@ -607,7 +610,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // ```\n         //\n         // the pattern `&&Some(x,)` is represented as `Ref { Ref { TupleStruct }}`. To build the\n-        // corresponding `Place` we start with the `Place` for `foo`, and then, by traversing the\n+        // corresponding `PlaceWithHirId` we start with the `PlaceWithHirId` for `foo`, and then, by traversing the\n         // pattern, try to answer the question: given the address of `foo`, how is `x` reached?\n         //\n         // `&&Some(x,)` `place_foo`\n@@ -629,29 +632,29 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // `deref { deref { place_foo }}` instead of `place_foo` since the pattern is now `Some(x,)`\n         // and not `&&Some(x,)`, even though its assigned type is that of `&&Some(x,)`.\n         for _ in 0..self.tables.pat_adjustments().get(pat.hir_id).map(|v| v.len()).unwrap_or(0) {\n-            debug!(\"cat_pattern: applying adjustment to place={:?}\", place);\n-            place = self.cat_deref(pat, place)?;\n+            debug!(\"cat_pattern: applying adjustment to place_with_id={:?}\", place_with_id);\n+            place_with_id = self.cat_deref(pat, place_with_id)?;\n         }\n-        let place = place; // lose mutability\n-        debug!(\"cat_pattern: applied adjustment derefs to get place={:?}\", place);\n+        let place_with_id = place_with_id; // lose mutability\n+        debug!(\"cat_pattern: applied adjustment derefs to get place_with_id={:?}\", place_with_id);\n \n-        // Invoke the callback, but only now, after the `place` has adjusted.\n+        // Invoke the callback, but only now, after the `place_with_id` has adjusted.\n         //\n         // To see that this makes sense, consider `match &Some(3) { Some(x) => { ... }}`. In that\n-        // case, the initial `place` will be that for `&Some(3)` and the pattern is `Some(x)`. We\n+        // case, the initial `place_with_id` will be that for `&Some(3)` and the pattern is `Some(x)`. We\n         // don't want to call `op` with these incompatible values. As written, what happens instead\n         // is that `op` is called with the adjusted place (that for `*&Some(3)`) and the pattern\n         // `Some(x)` (which matches). Recursing once more, `*&Some(3)` and the pattern `Some(x)`\n         // result in the place `Downcast<Some>(*&Some(3)).0` associated to `x` and invoke `op` with\n         // that (where the `ref` on `x` is implied).\n-        op(&place, pat);\n+        op(&place_with_id, pat);\n \n         match pat.kind {\n             PatKind::TupleStruct(_, ref subpats, _) | PatKind::Tuple(ref subpats, _) => {\n                 // S(p1, ..., pN) or (p1, ..., pN)\n                 for subpat in subpats.iter() {\n                     let subpat_ty = self.pat_ty_adjusted(&subpat)?;\n-                    let sub_place = self.cat_projection(pat, place.clone(), subpat_ty);\n+                    let sub_place = self.cat_projection(pat, place_with_id.clone(), subpat_ty);\n                     self.cat_pattern_(sub_place, &subpat, op)?;\n                 }\n             }\n@@ -660,44 +663,44 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 // S { f1: p1, ..., fN: pN }\n                 for fp in field_pats {\n                     let field_ty = self.pat_ty_adjusted(&fp.pat)?;\n-                    let field_place = self.cat_projection(pat, place.clone(), field_ty);\n+                    let field_place = self.cat_projection(pat, place_with_id.clone(), field_ty);\n                     self.cat_pattern_(field_place, &fp.pat, op)?;\n                 }\n             }\n \n             PatKind::Or(pats) => {\n                 for pat in pats {\n-                    self.cat_pattern_(place.clone(), &pat, op)?;\n+                    self.cat_pattern_(place_with_id.clone(), &pat, op)?;\n                 }\n             }\n \n             PatKind::Binding(.., Some(ref subpat)) => {\n-                self.cat_pattern_(place, &subpat, op)?;\n+                self.cat_pattern_(place_with_id, &subpat, op)?;\n             }\n \n             PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n                 // box p1, &p1, &mut p1.  we can ignore the mutability of\n                 // PatKind::Ref since that information is already contained\n                 // in the type.\n-                let subplace = self.cat_deref(pat, place)?;\n+                let subplace = self.cat_deref(pat, place_with_id)?;\n                 self.cat_pattern_(subplace, &subpat, op)?;\n             }\n \n             PatKind::Slice(before, ref slice, after) => {\n-                let element_ty = match place.ty.builtin_index() {\n+                let element_ty = match place_with_id.place.ty.builtin_index() {\n                     Some(ty) => ty,\n                     None => {\n-                        debug!(\"explicit index of non-indexable type {:?}\", place);\n+                        debug!(\"explicit index of non-indexable type {:?}\", place_with_id);\n                         return Err(());\n                     }\n                 };\n-                let elt_place = self.cat_projection(pat, place.clone(), element_ty);\n+                let elt_place = self.cat_projection(pat, place_with_id.clone(), element_ty);\n                 for before_pat in before {\n                     self.cat_pattern_(elt_place.clone(), &before_pat, op)?;\n                 }\n                 if let Some(ref slice_pat) = *slice {\n                     let slice_pat_ty = self.pat_ty_adjusted(&slice_pat)?;\n-                    let slice_place = self.cat_projection(pat, place, slice_pat_ty);\n+                    let slice_place = self.cat_projection(pat, place_with_id, slice_pat_ty);\n                     self.cat_pattern_(slice_place, &slice_pat, op)?;\n                 }\n                 for after_pat in after {"}, {"sha": "ba2d8a363cd4eccd27df9c97ead98d048f45d9ed", "filename": "src/test/assembly/asm/hexagon-types.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fassembly%2Fasm%2Fhexagon-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fassembly%2Fasm%2Fhexagon-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fhexagon-types.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -0,0 +1,130 @@\n+// no-system-llvm\n+// assembly-output: emit-asm\n+// compile-flags: --target hexagon-unknown-linux-musl\n+\n+#![feature(no_core, lang_items, rustc_attrs, repr_simd)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(asm_sub_register, non_camel_case_types)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! stringify {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *const i32;\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for f32 {}\n+impl Copy for ptr {}\n+extern \"C\" {\n+    fn extern_func();\n+    static extern_static: u8;\n+}\n+\n+macro_rules! check {\n+    ($func:ident $ty:ident $class:ident) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            // Hack to avoid function merging\n+            extern \"Rust\" {\n+                fn dont_merge(s: &str);\n+            }\n+            dont_merge(stringify!($func));\n+\n+            let y;\n+            asm!(\"{} = {}\", out($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: sym_static:\n+// CHECK: InlineAsm Start\n+// CHECK: r0 = #extern_static\n+// CHECK: InlineAsm End\n+#[no_mangle]\n+pub unsafe fn sym_static() {\n+    // Hack to avoid function merging\n+    extern \"Rust\" {\n+        fn dont_merge(s: &str);\n+    }\n+    dont_merge(stringify!($func));\n+\n+    asm!(\"r0 = #{}\", sym extern_static);\n+}\n+\n+// CHECK-LABEL: sym_fn:\n+// CHECK: InlineAsm Start\n+// CHECK: r0 = #extern_func\n+// CHECK: InlineAsm End\n+#[no_mangle]\n+pub unsafe fn sym_fn() {\n+    // Hack to avoid function merging\n+    extern \"Rust\" {\n+        fn dont_merge(s: &str);\n+    }\n+    dont_merge(stringify!($func));\n+\n+    asm!(\"r0 = #{}\", sym extern_func);\n+}\n+\n+// This is a test for multi-instruction packets,\n+// which require the escaped braces.\n+//\n+// CHECK-LABEL: packet:\n+// CHECK: InlineAsm Start\n+// CHECK: {\n+// CHECK:   r{{[0-9]+}} = r0\n+// CHECK:   memw(r1) = r{{[0-9]+}}\n+// CHECK: }\n+// CHECK: InlineAsm End\n+#[no_mangle]\n+pub unsafe fn packet() {\n+    let val = 1024;\n+    asm!(\"{{\n+        {} = r0\n+        memw(r1) = {}\n+    }}\", out(reg) _, in(reg) &val);\n+}\n+\n+// CHECK-LABEL: ptr:\n+// CHECK: InlineAsm Start\n+// CHECK: r{{[0-9]+}} = r{{[0-9]+}}\n+// CHECK: InlineAsm End\n+check!(reg_ptr ptr reg);\n+\n+// CHECK-LABEL: reg_f32:\n+// CHECK: InlineAsm Start\n+// CHECK: r{{[0-9]+}} = r{{[0-9]+}}\n+// CHECK: InlineAsm End\n+check!(reg_f32 f32 reg);\n+\n+// CHECK-LABEL: reg_i32:\n+// CHECK: InlineAsm Start\n+// CHECK: r{{[0-9]+}} = r{{[0-9]+}}\n+// CHECK: InlineAsm End\n+check!(reg_i32 i32 reg);\n+\n+// CHECK-LABEL: reg_i8:\n+// CHECK: InlineAsm Start\n+// CHECK: r{{[0-9]+}} = r{{[0-9]+}}\n+// CHECK: InlineAsm End\n+check!(reg_i8 i8 reg);\n+\n+// CHECK-LABEL: reg_i16:\n+// CHECK: InlineAsm Start\n+// CHECK: r{{[0-9]+}} = r{{[0-9]+}}\n+// CHECK: InlineAsm End\n+check!(reg_i16 i16 reg);"}, {"sha": "b3d188dd708814cf50c3937d59eb7334ef73cb09", "filename": "src/test/pretty/asm.pp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fpretty%2Fasm.pp", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fpretty%2Fasm.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fasm.pp?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -22,5 +22,13 @@\n         asm!(\"{0}\", inout(reg) b);\n         asm!(\"{0} {1}\", out(reg) _, inlateout(reg) b => _);\n         asm!(\"\", out(\"al\") _, lateout(\"rbx\") _);\n+        asm!(\"inst1\\ninst2\");\n+        asm!(\"inst1 {0}, 42\\ninst2 {1}, 24\", in(reg) a, out(reg) b);\n+        asm!(\"inst2 {1}, 24\\ninst1 {0}, 42\", in(reg) a, out(reg) b);\n+        asm!(\"inst1 {0}, 42\\ninst2 {1}, 24\", in(reg) a, out(reg) b);\n+        asm!(\"inst1\\ninst2\");\n+        asm!(\"inst1\\ninst2\");\n+        asm!(\"inst1\\n\\tinst2\");\n+        asm!(\"inst1\\ninst2\\ninst3\\ninst4\");\n     }\n }"}, {"sha": "33f25e5216b4eafab08089c2f779fd22ba736544", "filename": "src/test/pretty/asm.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fpretty%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fpretty%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fasm.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -16,5 +16,14 @@ pub fn main() {\n         asm!(\"{name}\", name = inout(reg) b);\n         asm!(\"{} {}\", out(reg) _, inlateout(reg) b => _);\n         asm!(\"\", out(\"al\") _, lateout(\"rbx\") _);\n+        asm!(\"inst1\", \"inst2\");\n+        asm!(\"inst1 {}, 42\", \"inst2 {}, 24\", in(reg) a, out(reg) b);\n+        asm!(\"inst2 {1}, 24\", \"inst1 {0}, 42\", in(reg) a, out(reg) b);\n+        asm!(\"inst1 {}, 42\", \"inst2 {name}, 24\", in(reg) a, name = out(reg) b);\n+        asm!(\"inst1\n+inst2\");\n+        asm!(\"inst1\\ninst2\");\n+        asm!(\"inst1\\n\\tinst2\");\n+        asm!(\"inst1\\ninst2\", \"inst3\\ninst4\");\n     }\n }"}, {"sha": "fbf399d8b075c311b51cb36e3760789f7d604344", "filename": "src/test/ui/asm/parse-error.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -13,7 +13,7 @@ fn main() {\n         asm!(\"{}\" foo);\n         //~^ ERROR expected token: `,`\n         asm!(\"{}\", foo);\n-        //~^ ERROR expected one of\n+        //~^ ERROR expected operand, options, or additional template string\n         asm!(\"{}\", in foo);\n         //~^ ERROR expected `(`, found `foo`\n         asm!(\"{}\", in(reg foo));\n@@ -52,5 +52,13 @@ fn main() {\n         //~^ ERROR named arguments cannot follow explicit register arguments\n         asm!(\"{1}\", in(\"eax\") foo, const bar);\n         //~^ ERROR positional arguments cannot follow named arguments or explicit register arguments\n+        asm!(\"\", options(), \"\");\n+        //~^ ERROR expected one of\n+        asm!(\"{}\", in(reg) foo, \"{}\", out(reg) foo);\n+        //~^ ERROR expected one of\n+        asm!(format!(\"{{{}}}\", 0), in(reg) foo);\n+        //~^ ERROR asm template must be a string literal\n+        asm!(\"{1}\", format!(\"{{{}}}\", 0), in(reg) foo, out(reg) bar);\n+        //~^ ERROR asm template must be a string literal\n     }\n }"}, {"sha": "ba7e8f7a03ccad682165367ca555d91352895908", "filename": "src/test/ui/asm/parse-error.stderr", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -16,11 +16,11 @@ error: expected token: `,`\n LL |         asm!(\"{}\" foo);\n    |                   ^^^ expected `,`\n \n-error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `foo`\n+error: expected operand, options, or additional template string\n   --> $DIR/parse-error.rs:15:20\n    |\n LL |         asm!(\"{}\", foo);\n-   |                    ^^^ expected one of 8 possible tokens\n+   |                    ^^^ expected operand, options, or additional template string\n \n error: expected `(`, found `foo`\n   --> $DIR/parse-error.rs:17:23\n@@ -160,5 +160,33 @@ LL |         asm!(\"{1}\", in(\"eax\") foo, const bar);\n    |                     |\n    |                     explicit register argument\n \n-error: aborting due to 24 previous errors\n+error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"\"`\n+  --> $DIR/parse-error.rs:55:29\n+   |\n+LL |         asm!(\"\", options(), \"\");\n+   |                             ^^ expected one of 8 possible tokens\n+\n+error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"{}\"`\n+  --> $DIR/parse-error.rs:57:33\n+   |\n+LL |         asm!(\"{}\", in(reg) foo, \"{}\", out(reg) foo);\n+   |                                 ^^^^ expected one of 8 possible tokens\n+\n+error: asm template must be a string literal\n+  --> $DIR/parse-error.rs:59:14\n+   |\n+LL |         asm!(format!(\"{{{}}}\", 0), in(reg) foo);\n+   |              ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: asm template must be a string literal\n+  --> $DIR/parse-error.rs:61:21\n+   |\n+LL |         asm!(\"{1}\", format!(\"{{{}}}\", 0), in(reg) foo, out(reg) bar);\n+   |                     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 28 previous errors\n "}, {"sha": "1477e3dd5665ce6230819888ed21c50c8c4824da", "filename": "src/test/ui/asm/srcloc.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fasm%2Fsrcloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fasm%2Fsrcloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fsrcloc.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -40,5 +40,85 @@ fn main() {\n \n         asm!(\"movaps %xmm3, (%esi, 2)\", options(att_syntax));\n         //~^ WARN: scale factor without index register is ignored\n+\n+        asm!(\n+            \"invalid_instruction\",\n+        );\n+        //~^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\n+            \"mov eax, eax\",\n+            \"invalid_instruction\",\n+            \"mov eax, eax\",\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\n+            \"mov eax, eax\\n\",\n+            \"invalid_instruction\",\n+            \"mov eax, eax\",\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\n+            \"mov eax, eax\",\n+            concat!(\"invalid\", \"_\", \"instruction\"),\n+            \"mov eax, eax\",\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\n+            concat!(\"mov eax\", \", \", \"eax\"),\n+            concat!(\"invalid\", \"_\", \"instruction\"),\n+            concat!(\"mov eax\", \", \", \"eax\"),\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        // Make sure template strings get separated\n+        asm!(\n+            \"invalid_instruction1\",\n+            \"invalid_instruction2\",\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction1'\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n+\n+        asm!(\n+            concat!(\n+                \"invalid\", \"_\", \"instruction1\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction2\",\n+            ),\n+        );\n+        //~^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction1'\n+        //~^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n+\n+        asm!(\n+            concat!(\n+                \"invalid\", \"_\", \"instruction1\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction2\",\n+            ),\n+            concat!(\n+                \"invalid\", \"_\", \"instruction3\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction4\",\n+            ),\n+        );\n+        //~^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction1'\n+        //~^^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n+        //~^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction3'\n+        //~^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction4'\n+\n+        asm!(\n+            concat!(\n+                \"invalid\", \"_\", \"instruction1\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction2\", \"\\n\",\n+            ),\n+            concat!(\n+                \"invalid\", \"_\", \"instruction3\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction4\", \"\\n\",\n+            ),\n+        );\n+        //~^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction1'\n+        //~^^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n+        //~^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction3'\n+        //~^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction4'\n     }\n }"}, {"sha": "b62c8948289ddf1bf55575457bdc2e178c99d50c", "filename": "src/test/ui/asm/srcloc.stderr", "status": "modified", "additions": 205, "deletions": 1, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fasm%2Fsrcloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fasm%2Fsrcloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fsrcloc.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -82,5 +82,209 @@ note: instantiated into assembly here\n LL |     movaps %xmm3, (%esi, 2)\n    |                          ^\n \n-error: aborting due to 6 previous errors; 1 warning emitted\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:45:14\n+   |\n+LL |             \"invalid_instruction\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:51:14\n+   |\n+LL |             \"invalid_instruction\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:58:14\n+   |\n+LL |             \"invalid_instruction\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:4:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:65:13\n+   |\n+LL |             concat!(\"invalid\", \"_\", \"instruction\"),\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:72:13\n+   |\n+LL |             concat!(\"invalid\", \"_\", \"instruction\"),\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction1'\n+  --> $DIR/srcloc.rs:79:14\n+   |\n+LL |             \"invalid_instruction1\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction1\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction2'\n+  --> $DIR/srcloc.rs:80:14\n+   |\n+LL |             \"invalid_instruction2\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction2\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction1'\n+  --> $DIR/srcloc.rs:86:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction1\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction2'\n+  --> $DIR/srcloc.rs:86:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction2\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction1'\n+  --> $DIR/srcloc.rs:95:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction1\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction2'\n+  --> $DIR/srcloc.rs:95:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction2\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction3'\n+  --> $DIR/srcloc.rs:99:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:4:1\n+   |\n+LL | invalid_instruction3\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction4'\n+  --> $DIR/srcloc.rs:99:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:5:1\n+   |\n+LL | invalid_instruction4\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction1'\n+  --> $DIR/srcloc.rs:110:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction1\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction2'\n+  --> $DIR/srcloc.rs:110:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction2\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction3'\n+  --> $DIR/srcloc.rs:114:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:5:1\n+   |\n+LL | invalid_instruction3\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction4'\n+  --> $DIR/srcloc.rs:114:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:6:1\n+   |\n+LL | invalid_instruction4\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 23 previous errors; 1 warning emitted\n "}, {"sha": "006a334021b1419428d1f9813cfd2f85318e382d", "filename": "src/test/ui/dst/dst-sized-trait-param.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fdst%2Fdst-sized-trait-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fdst%2Fdst-sized-trait-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-sized-trait-param.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -9,6 +9,10 @@ LL | impl Foo<[isize]> for usize { }\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[isize]`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | trait Foo<T: ?Sized> : Sized { fn take(self, x: &T) { } } // Note: T is sized\n+   |            ^^^^^^^^\n \n error[E0277]: the size for values of type `[usize]` cannot be known at compilation time\n   --> $DIR/dst-sized-trait-param.rs:10:6"}, {"sha": "0c7995fde3273f838194afc92f360afe2fa229f0", "filename": "src/test/ui/extern/extern-types-unsized.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fextern%2Fextern-types-unsized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fextern%2Fextern-types-unsized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-types-unsized.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -26,6 +26,10 @@ LL |     assert_sized::<Foo>();\n    = help: within `Foo`, the trait `std::marker::Sized` is not implemented for `A`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `Foo`\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | fn assert_sized<T: ?Sized>() { }\n+   |                  ^^^^^^^^\n \n error[E0277]: the size for values of type `A` cannot be known at compilation time\n   --> $DIR/extern-types-unsized.rs:28:5\n@@ -39,6 +43,10 @@ LL |     assert_sized::<Bar<A>>();\n    = help: within `Bar<A>`, the trait `std::marker::Sized` is not implemented for `A`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `Bar<A>`\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | fn assert_sized<T: ?Sized>() { }\n+   |                  ^^^^^^^^\n \n error[E0277]: the size for values of type `A` cannot be known at compilation time\n   --> $DIR/extern-types-unsized.rs:31:5\n@@ -53,6 +61,10 @@ LL |     assert_sized::<Bar<Bar<A>>>();\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `Bar<A>`\n    = note: required because it appears within the type `Bar<Bar<A>>`\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | fn assert_sized<T: ?Sized>() { }\n+   |                  ^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "3cd4d0dd391af41490eebebb5b97cb4274cc60cc", "filename": "src/test/ui/impl-trait/no-method-suggested-traits.stderr", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -49,14 +49,6 @@ LL | use foo::Bar;\n error[E0599]: no method named `method` found for struct `std::rc::Rc<&mut std::boxed::Box<&char>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:32:43\n    |\n-LL |         fn method(&self) {}\n-   |            ------\n-   |            |\n-   |            the method is available for `std::boxed::Box<std::rc::Rc<&mut std::boxed::Box<&char>>>` here\n-   |            the method is available for `std::pin::Pin<std::rc::Rc<&mut std::boxed::Box<&char>>>` here\n-   |            the method is available for `std::sync::Arc<std::rc::Rc<&mut std::boxed::Box<&char>>>` here\n-   |            the method is available for `std::rc::Rc<std::rc::Rc<&mut std::boxed::Box<&char>>>` here\n-...\n LL |     std::rc::Rc::new(&mut Box::new(&'a')).method();\n    |                                           ^^^^^^ method not found in `std::rc::Rc<&mut std::boxed::Box<&char>>`\n    |\n@@ -83,16 +75,6 @@ error[E0599]: no method named `method` found for struct `std::rc::Rc<&mut std::b\n    |\n LL |     std::rc::Rc::new(&mut Box::new(&1i32)).method();\n    |                                            ^^^^^^ method not found in `std::rc::Rc<&mut std::boxed::Box<&i32>>`\n-   | \n-  ::: $DIR/auxiliary/no_method_suggested_traits.rs:8:12\n-   |\n-LL |         fn method(&self) {}\n-   |            ------\n-   |            |\n-   |            the method is available for `std::boxed::Box<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n-   |            the method is available for `std::pin::Pin<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n-   |            the method is available for `std::sync::Arc<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n-   |            the method is available for `std::rc::Rc<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\n help: the following trait is implemented but not in scope; perhaps add a `use` for it:"}, {"sha": "d7a4bf4f21f18dc946084e62b64fa2ce0796d2f8", "filename": "src/test/ui/issues/issue-10412.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -57,6 +57,10 @@ LL | impl<'self> Serializable<str> for &'self str {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | trait Serializable<'self, T: ?Sized> {\n+   |                            ^^^^^^^^\n \n error: aborting due to 9 previous errors\n "}, {"sha": "383cdd4979ad9ad46007915e25745e81e3b2d847", "filename": "src/test/ui/issues/issue-18919.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fissues%2Fissue-18919.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fissues%2Fissue-18919.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18919.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -9,6 +9,13 @@ LL | enum Option<T> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `dyn for<'r> std::ops::Fn(&'r isize) -> isize`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/issue-18919.rs:7:13\n+   |\n+LL | enum Option<T> {\n+   |             ^ this could be changed to `T: ?Sized`...\n+LL |     Some(T),\n+   |          - ...if indirection was used here: `Box<T>`\n \n error: aborting due to previous error\n "}, {"sha": "cffa52361696c93c21c41727c3a2befab1c64466", "filename": "src/test/ui/issues/issue-23281.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fissues%2Fissue-23281.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fissues%2Fissue-23281.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23281.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -9,6 +9,13 @@ LL | struct Vec<T> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn std::ops::Fn() + 'static)`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/issue-23281.rs:8:12\n+   |\n+LL | struct Vec<T> {\n+   |            ^ this could be changed to `T: ?Sized`...\n+LL |     t: T,\n+   |        - ...if indirection was used here: `Box<T>`\n \n error: aborting due to previous error\n "}, {"sha": "8dc9351260ebcc6a4bb3979e2d665723bb5fddfa", "filename": "src/test/ui/issues/issue-48508.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fissues%2Fissue-48508.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fissues%2Fissue-48508.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-48508.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -11,7 +11,7 @@\n // ignore-asmjs wasm2js does not support source maps yet\n \n #![feature(non_ascii_idents)]\n-#[allow(uncommon_codepoints)]\n+#![allow(uncommon_codepoints)]\n \n #[path = \"issue-48508-aux.rs\"]\n mod other_file;"}, {"sha": "d9673faa2142e4c5a226143f38a3308f67475ee1", "filename": "src/test/ui/lint/crate_level_only_lint.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Flint%2Fcrate_level_only_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Flint%2Fcrate_level_only_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fcrate_level_only_lint.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -0,0 +1,22 @@\n+#![deny(uncommon_codepoints, unused_attributes)]\n+\n+mod foo {\n+#![allow(uncommon_codepoints)]\n+//~^ ERROR allow(uncommon_codepoints) is ignored unless specified at crate level [unused_attributes]\n+//~| ERROR allow(uncommon_codepoints) is ignored unless specified at crate level [unused_attributes]\n+//~| ERROR allow(uncommon_codepoints) is ignored unless specified at crate level [unused_attributes]\n+\n+#[allow(uncommon_codepoints)]\n+//~^ ERROR allow(uncommon_codepoints) is ignored unless specified at crate level [unused_attributes]\n+//~| ERROR allow(uncommon_codepoints) is ignored unless specified at crate level [unused_attributes]\n+//~| ERROR allow(uncommon_codepoints) is ignored unless specified at crate level [unused_attributes]\n+const BAR: f64 = 0.000001;\n+\n+}\n+\n+#[allow(uncommon_codepoints)]\n+//~^ ERROR allow(uncommon_codepoints) is ignored unless specified at crate level [unused_attributes]\n+//~| ERROR allow(uncommon_codepoints) is ignored unless specified at crate level [unused_attributes]\n+//~| ERROR allow(uncommon_codepoints) is ignored unless specified at crate level [unused_attributes]\n+fn main() {\n+}"}, {"sha": "8fb06df2a481a68297e4b9ff65639fdd632f09e7", "filename": "src/test/ui/lint/crate_level_only_lint.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Flint%2Fcrate_level_only_lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Flint%2Fcrate_level_only_lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fcrate_level_only_lint.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -0,0 +1,62 @@\n+error: allow(uncommon_codepoints) is ignored unless specified at crate level\n+  --> $DIR/crate_level_only_lint.rs:4:10\n+   |\n+LL | #![allow(uncommon_codepoints)]\n+   |          ^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/crate_level_only_lint.rs:1:30\n+   |\n+LL | #![deny(uncommon_codepoints, unused_attributes)]\n+   |                              ^^^^^^^^^^^^^^^^^\n+\n+error: allow(uncommon_codepoints) is ignored unless specified at crate level\n+  --> $DIR/crate_level_only_lint.rs:9:9\n+   |\n+LL | #[allow(uncommon_codepoints)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: allow(uncommon_codepoints) is ignored unless specified at crate level\n+  --> $DIR/crate_level_only_lint.rs:17:9\n+   |\n+LL | #[allow(uncommon_codepoints)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: allow(uncommon_codepoints) is ignored unless specified at crate level\n+  --> $DIR/crate_level_only_lint.rs:4:10\n+   |\n+LL | #![allow(uncommon_codepoints)]\n+   |          ^^^^^^^^^^^^^^^^^^^\n+\n+error: allow(uncommon_codepoints) is ignored unless specified at crate level\n+  --> $DIR/crate_level_only_lint.rs:9:9\n+   |\n+LL | #[allow(uncommon_codepoints)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: allow(uncommon_codepoints) is ignored unless specified at crate level\n+  --> $DIR/crate_level_only_lint.rs:17:9\n+   |\n+LL | #[allow(uncommon_codepoints)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: allow(uncommon_codepoints) is ignored unless specified at crate level\n+  --> $DIR/crate_level_only_lint.rs:4:10\n+   |\n+LL | #![allow(uncommon_codepoints)]\n+   |          ^^^^^^^^^^^^^^^^^^^\n+\n+error: allow(uncommon_codepoints) is ignored unless specified at crate level\n+  --> $DIR/crate_level_only_lint.rs:9:9\n+   |\n+LL | #[allow(uncommon_codepoints)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: allow(uncommon_codepoints) is ignored unless specified at crate level\n+  --> $DIR/crate_level_only_lint.rs:17:9\n+   |\n+LL | #[allow(uncommon_codepoints)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "63e5f098a25d3656ae95e1a512d2e0b042fbe4e8", "filename": "src/test/ui/numeric/numeric-cast-no-fix.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-no-fix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-no-fix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-no-fix.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -0,0 +1,87 @@\n+#[allow(unused_must_use)]\n+fn main() {\n+    let x_usize: usize = 1;\n+    let x_u128: u128 = 2;\n+    let x_u64: u64 = 3;\n+    let x_u32: u32 = 4;\n+    let x_u16: u16 = 5;\n+    let x_u8: u8 = 6;\n+\n+    x_usize > -1_isize;\n+    //~^ ERROR mismatched types\n+    x_u128 > -1_isize;\n+    //~^ ERROR mismatched types\n+    x_u64 > -1_isize;\n+    //~^ ERROR mismatched types\n+    x_u32 > -1_isize;\n+    //~^ ERROR mismatched types\n+    x_u16 > -1_isize;\n+    //~^ ERROR mismatched types\n+    x_u8 > -1_isize;\n+    //~^ ERROR mismatched types\n+\n+    x_usize > -1_i128;\n+    //~^ ERROR mismatched types\n+    x_u128 > -1_i128;\n+    //~^ ERROR mismatched types\n+    x_u64 > -1_i128;\n+    //~^ ERROR mismatched types\n+    x_u32 > -1_i128;\n+    //~^ ERROR mismatched types\n+    x_u16 > -1_i128;\n+    //~^ ERROR mismatched types\n+    x_u8 > -1_i128;\n+    //~^ ERROR mismatched types\n+\n+    x_usize > -1_i64;\n+    //~^ ERROR mismatched types\n+    x_u128 > -1_i64;\n+    //~^ ERROR mismatched types\n+    x_u64 > -1_i64;\n+    //~^ ERROR mismatched types\n+    x_u32 > -1_i64;\n+    //~^ ERROR mismatched types\n+    x_u16 > -1_i64;\n+    //~^ ERROR mismatched types\n+    x_u8 > -1_i64;\n+    //~^ ERROR mismatched types\n+\n+    x_usize > -1_i32;\n+    //~^ ERROR mismatched types\n+    x_u128 > -1_i32;\n+    //~^ ERROR mismatched types\n+    x_u64 > -1_i32;\n+    //~^ ERROR mismatched types\n+    x_u32 > -1_i32;\n+    //~^ ERROR mismatched types\n+    x_u16 > -1_i32;\n+    //~^ ERROR mismatched types\n+    x_u8 > -1_i32;\n+    //~^ ERROR mismatched types\n+\n+    x_usize > -1_i16;\n+    //~^ ERROR mismatched types\n+    x_u128 > -1_i16;\n+    //~^ ERROR mismatched types\n+    x_u64 > -1_i16;\n+    //~^ ERROR mismatched types\n+    x_u32 > -1_i16;\n+    //~^ ERROR mismatched types\n+    x_u16 > -1_i16;\n+    //~^ ERROR mismatched types\n+    x_u8 > -1_i16;\n+    //~^ ERROR mismatched types\n+\n+    x_usize > -1_i8;\n+    //~^ ERROR mismatched types\n+    x_u128 > -1_i8;\n+    //~^ ERROR mismatched types\n+    x_u64 > -1_i8;\n+    //~^ ERROR mismatched types\n+    x_u32 > -1_i8;\n+    //~^ ERROR mismatched types\n+    x_u16 > -1_i8;\n+    //~^ ERROR mismatched types\n+    x_u8 > -1_i8;\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "4852e7047b47a3c5db48e13f4c88a101eb0a7983", "filename": "src/test/ui/numeric/numeric-cast-no-fix.stderr", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-no-fix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-no-fix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-no-fix.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -0,0 +1,324 @@\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:10:15\n+   |\n+LL |     x_usize > -1_isize;\n+   |               ^^^^^^^^ expected `usize`, found `isize`\n+   |\n+   = note: `-1_isize` cannot fit into type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:12:14\n+   |\n+LL |     x_u128 > -1_isize;\n+   |              ^^^^^^^^ expected `u128`, found `isize`\n+   |\n+   = note: `-1_isize` cannot fit into type `u128`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:14:13\n+   |\n+LL |     x_u64 > -1_isize;\n+   |             ^^^^^^^^ expected `u64`, found `isize`\n+   |\n+   = note: `-1_isize` cannot fit into type `u64`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:16:13\n+   |\n+LL |     x_u32 > -1_isize;\n+   |             ^^^^^^^^ expected `u32`, found `isize`\n+   |\n+   = note: `-1_isize` cannot fit into type `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:18:13\n+   |\n+LL |     x_u16 > -1_isize;\n+   |             ^^^^^^^^ expected `u16`, found `isize`\n+   |\n+   = note: `-1_isize` cannot fit into type `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:20:12\n+   |\n+LL |     x_u8 > -1_isize;\n+   |            ^^^^^^^^ expected `u8`, found `isize`\n+   |\n+help: you can convert `x_u8` from `u8` to `isize`, matching the type of `-1_isize`\n+   |\n+LL |     isize::from(x_u8) > -1_isize;\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:23:15\n+   |\n+LL |     x_usize > -1_i128;\n+   |               ^^^^^^^ expected `usize`, found `i128`\n+   |\n+   = note: `-1_i128` cannot fit into type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:25:14\n+   |\n+LL |     x_u128 > -1_i128;\n+   |              ^^^^^^^ expected `u128`, found `i128`\n+   |\n+   = note: `-1_i128` cannot fit into type `u128`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:27:13\n+   |\n+LL |     x_u64 > -1_i128;\n+   |             ^^^^^^^ expected `u64`, found `i128`\n+   |\n+help: you can convert `x_u64` from `u64` to `i128`, matching the type of `-1_i128`\n+   |\n+LL |     i128::from(x_u64) > -1_i128;\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:29:13\n+   |\n+LL |     x_u32 > -1_i128;\n+   |             ^^^^^^^ expected `u32`, found `i128`\n+   |\n+help: you can convert `x_u32` from `u32` to `i128`, matching the type of `-1_i128`\n+   |\n+LL |     i128::from(x_u32) > -1_i128;\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:31:13\n+   |\n+LL |     x_u16 > -1_i128;\n+   |             ^^^^^^^ expected `u16`, found `i128`\n+   |\n+help: you can convert `x_u16` from `u16` to `i128`, matching the type of `-1_i128`\n+   |\n+LL |     i128::from(x_u16) > -1_i128;\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:33:12\n+   |\n+LL |     x_u8 > -1_i128;\n+   |            ^^^^^^^ expected `u8`, found `i128`\n+   |\n+help: you can convert `x_u8` from `u8` to `i128`, matching the type of `-1_i128`\n+   |\n+LL |     i128::from(x_u8) > -1_i128;\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:36:15\n+   |\n+LL |     x_usize > -1_i64;\n+   |               ^^^^^^ expected `usize`, found `i64`\n+   |\n+   = note: `-1_i64` cannot fit into type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:38:14\n+   |\n+LL |     x_u128 > -1_i64;\n+   |              ^^^^^^ expected `u128`, found `i64`\n+   |\n+   = note: `-1_i64` cannot fit into type `u128`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:40:13\n+   |\n+LL |     x_u64 > -1_i64;\n+   |             ^^^^^^ expected `u64`, found `i64`\n+   |\n+   = note: `-1_i64` cannot fit into type `u64`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:42:13\n+   |\n+LL |     x_u32 > -1_i64;\n+   |             ^^^^^^ expected `u32`, found `i64`\n+   |\n+help: you can convert `x_u32` from `u32` to `i64`, matching the type of `-1_i64`\n+   |\n+LL |     i64::from(x_u32) > -1_i64;\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:44:13\n+   |\n+LL |     x_u16 > -1_i64;\n+   |             ^^^^^^ expected `u16`, found `i64`\n+   |\n+help: you can convert `x_u16` from `u16` to `i64`, matching the type of `-1_i64`\n+   |\n+LL |     i64::from(x_u16) > -1_i64;\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:46:12\n+   |\n+LL |     x_u8 > -1_i64;\n+   |            ^^^^^^ expected `u8`, found `i64`\n+   |\n+help: you can convert `x_u8` from `u8` to `i64`, matching the type of `-1_i64`\n+   |\n+LL |     i64::from(x_u8) > -1_i64;\n+   |     ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:49:15\n+   |\n+LL |     x_usize > -1_i32;\n+   |               ^^^^^^ expected `usize`, found `i32`\n+   |\n+   = note: `-1_i32` cannot fit into type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:51:14\n+   |\n+LL |     x_u128 > -1_i32;\n+   |              ^^^^^^ expected `u128`, found `i32`\n+   |\n+   = note: `-1_i32` cannot fit into type `u128`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:53:13\n+   |\n+LL |     x_u64 > -1_i32;\n+   |             ^^^^^^ expected `u64`, found `i32`\n+   |\n+   = note: `-1_i32` cannot fit into type `u64`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:55:13\n+   |\n+LL |     x_u32 > -1_i32;\n+   |             ^^^^^^ expected `u32`, found `i32`\n+   |\n+   = note: `-1_i32` cannot fit into type `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:57:13\n+   |\n+LL |     x_u16 > -1_i32;\n+   |             ^^^^^^ expected `u16`, found `i32`\n+   |\n+help: you can convert `x_u16` from `u16` to `i32`, matching the type of `-1_i32`\n+   |\n+LL |     i32::from(x_u16) > -1_i32;\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:59:12\n+   |\n+LL |     x_u8 > -1_i32;\n+   |            ^^^^^^ expected `u8`, found `i32`\n+   |\n+help: you can convert `x_u8` from `u8` to `i32`, matching the type of `-1_i32`\n+   |\n+LL |     i32::from(x_u8) > -1_i32;\n+   |     ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:62:15\n+   |\n+LL |     x_usize > -1_i16;\n+   |               ^^^^^^ expected `usize`, found `i16`\n+   |\n+   = note: `-1_i16` cannot fit into type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:64:14\n+   |\n+LL |     x_u128 > -1_i16;\n+   |              ^^^^^^ expected `u128`, found `i16`\n+   |\n+   = note: `-1_i16` cannot fit into type `u128`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:66:13\n+   |\n+LL |     x_u64 > -1_i16;\n+   |             ^^^^^^ expected `u64`, found `i16`\n+   |\n+   = note: `-1_i16` cannot fit into type `u64`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:68:13\n+   |\n+LL |     x_u32 > -1_i16;\n+   |             ^^^^^^ expected `u32`, found `i16`\n+   |\n+   = note: `-1_i16` cannot fit into type `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:70:13\n+   |\n+LL |     x_u16 > -1_i16;\n+   |             ^^^^^^ expected `u16`, found `i16`\n+   |\n+   = note: `-1_i16` cannot fit into type `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:72:12\n+   |\n+LL |     x_u8 > -1_i16;\n+   |            ^^^^^^ expected `u8`, found `i16`\n+   |\n+help: you can convert `x_u8` from `u8` to `i16`, matching the type of `-1_i16`\n+   |\n+LL |     i16::from(x_u8) > -1_i16;\n+   |     ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:75:15\n+   |\n+LL |     x_usize > -1_i8;\n+   |               ^^^^^ expected `usize`, found `i8`\n+   |\n+   = note: `-1_i8` cannot fit into type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:77:14\n+   |\n+LL |     x_u128 > -1_i8;\n+   |              ^^^^^ expected `u128`, found `i8`\n+   |\n+   = note: `-1_i8` cannot fit into type `u128`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:79:13\n+   |\n+LL |     x_u64 > -1_i8;\n+   |             ^^^^^ expected `u64`, found `i8`\n+   |\n+   = note: `-1_i8` cannot fit into type `u64`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:81:13\n+   |\n+LL |     x_u32 > -1_i8;\n+   |             ^^^^^ expected `u32`, found `i8`\n+   |\n+   = note: `-1_i8` cannot fit into type `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:83:13\n+   |\n+LL |     x_u16 > -1_i8;\n+   |             ^^^^^ expected `u16`, found `i8`\n+   |\n+   = note: `-1_i8` cannot fit into type `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-no-fix.rs:85:12\n+   |\n+LL |     x_u8 > -1_i8;\n+   |            ^^^^^ expected `u8`, found `i8`\n+   |\n+   = note: `-1_i8` cannot fit into type `u8`\n+\n+error: aborting due to 36 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "2eab3ebc7687d8cf1dbf6f85ec9bddb43bd54488", "filename": "src/test/ui/repeat_count.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Frepeat_count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Frepeat_count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat_count.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -39,12 +39,16 @@ error[E0308]: mismatched types\n    |\n LL |     let f = [0; -4_isize];\n    |                 ^^^^^^^^ expected `usize`, found `isize`\n+   |\n+   = note: `-4_isize` cannot fit into type `usize`\n \n error[E0308]: mismatched types\n   --> $DIR/repeat_count.rs:22:23\n    |\n LL |     let f = [0_usize; -1_isize];\n    |                       ^^^^^^^^ expected `usize`, found `isize`\n+   |\n+   = note: `-1_isize` cannot fit into type `usize`\n \n error[E0308]: mismatched types\n   --> $DIR/repeat_count.rs:25:17"}, {"sha": "ef64d799b65cfcbd374320406dee2b2cd33eef8f", "filename": "src/test/ui/suggestions/adt-param-with-implicit-sized-bound.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -0,0 +1,28 @@\n+trait Trait {\n+    fn func1() -> Struct1<Self>; //~ ERROR E0277\n+    fn func2<'a>() -> Struct2<'a, Self>; //~ ERROR E0277\n+    fn func3() -> Struct3<Self>; //~ ERROR E0277\n+    fn func4() -> Struct4<Self>; //~ ERROR E0277\n+}\n+\n+struct Struct1<T>{\n+    _t: std::marker::PhantomData<*const T>,\n+}\n+struct Struct2<'a, T>{\n+    _t: &'a T,\n+}\n+struct Struct3<T>{\n+    _t: T,\n+}\n+\n+struct X<T>(T);\n+\n+struct Struct4<T>{\n+    _t: X<T>,\n+}\n+\n+struct Struct5<T: ?Sized>{\n+    _t: X<T>, //~ ERROR E0277\n+}\n+\n+fn main() {}"}, {"sha": "ee08f51f802703dc509c8f40536cf943db0d4be2", "filename": "src/test/ui/suggestions/adt-param-with-implicit-sized-bound.stderr", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -0,0 +1,107 @@\n+error[E0277]: the size for values of type `T` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:25:5\n+   |\n+LL | struct X<T>(T);\n+   |          - required by this bound in `X`\n+...\n+LL | struct Struct5<T: ?Sized>{\n+   |                - this type parameter needs to be `std::marker::Sized`\n+LL |     _t: X<T>,\n+   |     ^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `T`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:18:10\n+   |\n+LL | struct X<T>(T);\n+   |          ^  - ...if indirection was used here: `Box<T>`\n+   |          |\n+   |          this could be changed to `T: ?Sized`...\n+\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:2:19\n+   |\n+LL |     fn func1() -> Struct1<Self>;\n+   |                   ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+...\n+LL | struct Struct1<T>{\n+   |                - required by this bound in `Struct1`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `Self`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL |     fn func1() -> Struct1<Self> where Self: std::marker::Sized;\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | struct Struct1<T: ?Sized>{\n+   |                 ^^^^^^^^\n+\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:3:23\n+   |\n+LL |     fn func2<'a>() -> Struct2<'a, Self>;\n+   |                       ^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+...\n+LL | struct Struct2<'a, T>{\n+   |                    - required by this bound in `Struct2`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `Self`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL |     fn func2<'a>() -> Struct2<'a, Self> where Self: std::marker::Sized;\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | struct Struct2<'a, T: ?Sized>{\n+   |                     ^^^^^^^^\n+\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:4:19\n+   |\n+LL |     fn func3() -> Struct3<Self>;\n+   |                   ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+...\n+LL | struct Struct3<T>{\n+   |                - required by this bound in `Struct3`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `Self`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:14:16\n+   |\n+LL | struct Struct3<T>{\n+   |                ^ this could be changed to `T: ?Sized`...\n+LL |     _t: T,\n+   |         - ...if indirection was used here: `Box<T>`\n+help: consider further restricting `Self`\n+   |\n+LL |     fn func3() -> Struct3<Self> where Self: std::marker::Sized;\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:5:19\n+   |\n+LL |     fn func4() -> Struct4<Self>;\n+   |                   ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+...\n+LL | struct Struct4<T>{\n+   |                - required by this bound in `Struct4`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `Self`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL |     fn func4() -> Struct4<Self> where Self: std::marker::Sized;\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | struct Struct4<T: ?Sized>{\n+   |                 ^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "3be4f1109731176d132b4bd27ae86e38932082ee", "filename": "src/test/ui/traits/trait-item-privacy.stderr", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -20,13 +20,6 @@ error[E0599]: no method named `b` found for struct `S` in the current scope\n LL | struct S;\n    | --------- method `b` not found for this\n ...\n-LL |         fn b(&self) { }\n-   |            -\n-   |            |\n-   |            the method is available for `std::boxed::Box<S>` here\n-   |            the method is available for `std::sync::Arc<S>` here\n-   |            the method is available for `std::rc::Rc<S>` here\n-...\n LL |     S.b();\n    |       ^ method not found in `S`\n    |"}, {"sha": "1908aee25ea7bf6e094db07ba296ff89b8937534", "filename": "src/test/ui/unsized/unsized-enum.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized%2Funsized-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized%2Funsized-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-enum.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -11,6 +11,13 @@ LL | fn foo2<T: ?Sized>() { not_sized::<Foo<T>>() }\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `U` if it were used through indirection like `&U` or `Box<U>`\n+  --> $DIR/unsized-enum.rs:4:10\n+   |\n+LL | enum Foo<U> { FooSome(U), FooNone }\n+   |          ^            - ...if indirection was used here: `Box<U>`\n+   |          |\n+   |          this could be changed to `U: ?Sized`...\n \n error: aborting due to previous error\n "}, {"sha": "e0f077d66f99c8920ea3372279d71c7706251dea", "filename": "src/test/ui/unsized/unsized-inherent-impl-self-type.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized%2Funsized-inherent-impl-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized%2Funsized-inherent-impl-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-inherent-impl-self-type.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -11,6 +11,13 @@ LL | impl<X: ?Sized> S5<X> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `Y` if it were used through indirection like `&Y` or `Box<Y>`\n+  --> $DIR/unsized-inherent-impl-self-type.rs:5:11\n+   |\n+LL | struct S5<Y>(Y);\n+   |           ^  - ...if indirection was used here: `Box<Y>`\n+   |           |\n+   |           this could be changed to `Y: ?Sized`...\n \n error: aborting due to previous error\n "}, {"sha": "d92d1d9113e5c56377e8ac4415114357a52562a5", "filename": "src/test/ui/unsized/unsized-struct.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized%2Funsized-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized%2Funsized-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-struct.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -11,6 +11,13 @@ LL | fn foo2<T: ?Sized>() { not_sized::<Foo<T>>() }\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/unsized-struct.rs:4:12\n+   |\n+LL | struct Foo<T> { data: T }\n+   |            ^          - ...if indirection was used here: `Box<T>`\n+   |            |\n+   |            this could be changed to `T: ?Sized`...\n \n error[E0277]: the size for values of type `T` cannot be known at compilation time\n   --> $DIR/unsized-struct.rs:13:24"}, {"sha": "73c5439da53b67e83e3c1b66033ef78a04b7ce43", "filename": "src/test/ui/unsized/unsized-trait-impl-self-type.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-self-type.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -11,6 +11,13 @@ LL | impl<X: ?Sized> T3<X> for S5<X> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `Y` if it were used through indirection like `&Y` or `Box<Y>`\n+  --> $DIR/unsized-trait-impl-self-type.rs:8:11\n+   |\n+LL | struct S5<Y>(Y);\n+   |           ^  - ...if indirection was used here: `Box<Y>`\n+   |           |\n+   |           this could be changed to `Y: ?Sized`...\n \n error: aborting due to previous error\n "}, {"sha": "e423a9bdeab6f9f1c00b86f6a5ca516fdb3c9df9", "filename": "src/test/ui/unsized/unsized-trait-impl-trait-arg.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-trait-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-trait-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-trait-arg.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -11,6 +11,10 @@ LL | impl<X: ?Sized> T2<X> for S4<X> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | trait T2<Z: ?Sized> {\n+   |           ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "e0a0389dc46908247f7093f74dd12a77d554e496", "filename": "src/test/ui/unsized3.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized3.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -48,6 +48,10 @@ LL |     f5(x1);\n    = help: within `S<X>`, the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `S<X>`\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | fn f5<Y: ?Sized>(x: &Y) {}\n+   |        ^^^^^^^^\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized3.rs:40:8\n@@ -91,6 +95,10 @@ LL |     f5(&(32, *x1));\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `S<X>`\n    = note: required because it appears within the type `({integer}, S<X>)`\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | fn f5<Y: ?Sized>(x: &Y) {}\n+   |        ^^^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "e616a5cf0f9c216a7a473b472f883df748f27de8", "filename": "src/test/ui/unsized7.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Funsized7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized7.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -11,6 +11,10 @@ LL | impl<X: ?Sized + T> T1<X> for S3<X> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | trait T1<Z: T + ?Sized> {\n+   |               ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "731d31ac34f628d7009c171e5d2c0977fd00a21b", "filename": "src/test/ui/wf/wf-fn-where-clause.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fwf%2Fwf-fn-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftest%2Fui%2Fwf%2Fwf-fn-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-fn-where-clause.stderr?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -23,6 +23,13 @@ LL | struct Vec<T> {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn std::marker::Copy + 'static)`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/wf-fn-where-clause.rs:16:12\n+   |\n+LL | struct Vec<T> {\n+   |            ^ this could be changed to `T: ?Sized`...\n+LL |     t: T,\n+   |        - ...if indirection was used here: `Box<T>`\n \n error[E0038]: the trait `std::marker::Copy` cannot be made into an object\n   --> $DIR/wf-fn-where-clause.rs:12:16"}, {"sha": "59af475af175e2c484318fe1cbfb354965d3a9ea", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_target::abi::LayoutOf;\n-use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Place, PlaceBase};\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceWithHirId, PlaceBase};\n \n use crate::utils::span_lint;\n \n@@ -112,9 +112,9 @@ fn is_argument(map: rustc_middle::hir::map::Map<'_>, id: HirId) -> bool {\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n-    fn consume(&mut self, cmt: &Place<'tcx>, mode: ConsumeMode) {\n-        if cmt.projections.is_empty() {\n-            if let PlaceBase::Local(lid) = cmt.base {\n+    fn consume(&mut self, cmt: &PlaceWithHirId<'tcx>, mode: ConsumeMode) {\n+        if cmt.place.projections.is_empty() {\n+            if let PlaceBase::Local(lid) = cmt.place.base {\n                 if let ConsumeMode::Move = mode {\n                     // moved out or in. clearly can't be localized\n                     self.set.remove(&lid);\n@@ -132,16 +132,16 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n     }\n \n-    fn borrow(&mut self, cmt: &Place<'tcx>, _: ty::BorrowKind) {\n-        if cmt.projections.is_empty() {\n-            if let PlaceBase::Local(lid) = cmt.base {\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, _: ty::BorrowKind) {\n+        if cmt.place.projections.is_empty() {\n+            if let PlaceBase::Local(lid) = cmt.place.base {\n                 self.set.remove(&lid);\n             }\n         }\n     }\n \n-    fn mutate(&mut self, cmt: &Place<'tcx>) {\n-        if cmt.projections.is_empty() {\n+    fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>) {\n+        if cmt.place.projections.is_empty() {\n             let map = &self.cx.tcx.hir();\n             if is_argument(*map, cmt.hir_id) {\n                 // Skip closure arguments\n@@ -150,7 +150,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                     return;\n                 }\n \n-                if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n+                if is_non_trait_box(cmt.place.ty) && !self.is_large_box(cmt.place.ty) {\n                     self.set.insert(cmt.hir_id);\n                 }\n                 return;"}, {"sha": "83093ec51bd9037dd52569934fcb72bc1576b8f3", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -28,7 +28,7 @@ use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n-use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Place, PlaceBase};\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceWithHirId, PlaceBase};\n use std::iter::{once, Iterator};\n use std::mem;\n \n@@ -1489,42 +1489,43 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n     }\n }\n \n-struct MutatePairDelegate {\n+struct MutatePairDelegate<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     hir_id_low: Option<HirId>,\n     hir_id_high: Option<HirId>,\n     span_low: Option<Span>,\n     span_high: Option<Span>,\n }\n \n-impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n-    fn consume(&mut self, _: &Place<'tcx>, _: ConsumeMode) {}\n+impl<'a, 'tcx> Delegate<'tcx> for MutatePairDelegate<'a, 'tcx> {\n+    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, cmt: &Place<'tcx>, bk: ty::BorrowKind) {\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n-            if let PlaceBase::Local(id) = cmt.base {\n+            if let PlaceBase::Local(id) = cmt.place.base {\n                 if Some(id) == self.hir_id_low {\n-                    self.span_low = Some(cmt.span)\n+                    self.span_low = Some(self.cx.tcx.hir().span(cmt.hir_id))\n                 }\n                 if Some(id) == self.hir_id_high {\n-                    self.span_high = Some(cmt.span)\n+                    self.span_high = Some(self.cx.tcx.hir().span(cmt.hir_id))\n                 }\n             }\n         }\n     }\n \n-    fn mutate(&mut self, cmt: &Place<'tcx>) {\n-        if let PlaceBase::Local(id) = cmt.base {\n+    fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>) {\n+        if let PlaceBase::Local(id) = cmt.place.base {\n             if Some(id) == self.hir_id_low {\n-                self.span_low = Some(cmt.span)\n+                self.span_low = Some(self.cx.tcx.hir().span(cmt.hir_id))\n             }\n             if Some(id) == self.hir_id_high {\n-                self.span_high = Some(cmt.span)\n+                self.span_high = Some(self.cx.tcx.hir().span(cmt.hir_id))\n             }\n         }\n     }\n }\n \n-impl<'tcx> MutatePairDelegate {\n+impl<'a, 'tcx> MutatePairDelegate<'a, 'tcx> {\n     fn mutation_span(&self) -> (Option<Span>, Option<Span>) {\n         (self.span_low, self.span_high)\n     }\n@@ -1579,12 +1580,13 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr<'_>) -> Option<Hi\n     None\n }\n \n-fn check_for_mutation(\n-    cx: &LateContext<'_, '_>,\n+fn check_for_mutation<'a, 'tcx> (\n+    cx: &LateContext<'a, 'tcx>,\n     body: &Expr<'_>,\n     bound_ids: &[Option<HirId>],\n ) -> (Option<Span>, Option<Span>) {\n     let mut delegate = MutatePairDelegate {\n+        cx: cx,\n         hir_id_low: bound_ids[0],\n         hir_id_high: bound_ids[1],\n         span_low: None,"}, {"sha": "ca87deac9891c905913b99430bca8859ae6cfb2a", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -326,21 +326,21 @@ struct MovedVariablesCtxt {\n }\n \n impl MovedVariablesCtxt {\n-    fn move_common(&mut self, cmt: &euv::Place<'_>) {\n-        if let euv::PlaceBase::Local(vid) = cmt.base {\n+    fn move_common(&mut self, cmt: &euv::PlaceWithHirId<'_>) {\n+        if let euv::PlaceBase::Local(vid) = cmt.place.base {\n             self.moved_vars.insert(vid);\n         }\n     }\n }\n \n impl<'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt {\n-    fn consume(&mut self, cmt: &euv::Place<'tcx>, mode: euv::ConsumeMode) {\n+    fn consume(&mut self, cmt: &euv::PlaceWithHirId<'tcx>, mode: euv::ConsumeMode) {\n         if let euv::ConsumeMode::Move = mode {\n             self.move_common(cmt);\n         }\n     }\n \n-    fn borrow(&mut self, _: &euv::Place<'tcx>, _: ty::BorrowKind) {}\n+    fn borrow(&mut self, _: &euv::PlaceWithHirId<'tcx>, _: ty::BorrowKind) {}\n \n-    fn mutate(&mut self, _: &euv::Place<'tcx>) {}\n+    fn mutate(&mut self, _: &euv::PlaceWithHirId<'tcx>) {}\n }"}, {"sha": "6a7a1f1ceaaef8fabe9cfa38e331e237b303db8c", "filename": "src/tools/clippy/clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5cd9a64d8537236626c4ccbed39a924cd38e2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=34c5cd9a64d8537236626c4ccbed39a924cd38e2", "patch": "@@ -8,7 +8,7 @@ use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n use rustc_span::symbol::{Ident, Symbol};\n-use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Place, PlaceBase};\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceWithHirId, PlaceBase};\n \n /// Returns a set of mutated local variable IDs, or `None` if mutations could not be determined.\n pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n@@ -46,8 +46,8 @@ struct MutVarsDelegate {\n \n impl<'tcx> MutVarsDelegate {\n     #[allow(clippy::similar_names)]\n-    fn update(&mut self, cat: &Place<'tcx>) {\n-        match cat.base {\n+    fn update(&mut self, cat: &PlaceWithHirId<'tcx>) {\n+        match cat.place.base {\n             PlaceBase::Local(id) => {\n                 self.used_mutably.insert(id);\n             },\n@@ -63,15 +63,15 @@ impl<'tcx> MutVarsDelegate {\n }\n \n impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n-    fn consume(&mut self, _: &Place<'tcx>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, cmt: &Place<'tcx>, bk: ty::BorrowKind) {\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             self.update(&cmt)\n         }\n     }\n \n-    fn mutate(&mut self, cmt: &Place<'tcx>) {\n+    fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>) {\n         self.update(&cmt)\n     }\n }"}]}