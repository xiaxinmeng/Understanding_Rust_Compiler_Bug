{"sha": "e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "node_id": "C_kwDOAAsO6NoAKGU0YjlmODYwNTRjNTgxZDkzMWY4YmFkMGM4NzUyM2M1M2UxZThlM2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-15T11:44:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-15T11:44:12Z"}, "message": "Auto merge of #109035 - scottmcm:ptr-read-should-know-undef, r=WaffleLapkin,JakobDegen\n\nEnsure `ptr::read` gets all the same LLVM `load` metadata that dereferencing does\n\nI was looking into `array::IntoIter` optimization, and noticed that it wasn't annotating the loads with `noundef` for simple things like `array::IntoIter<i32, N>`.  Trying to narrow it down, it seems that was because `MaybeUninit::assume_init_read` isn't marking the load as initialized (<https://rust.godbolt.org/z/Mxd8TPTnv>), which is unfortunate since that's basically its reason to exist.\n\nThe root cause is that `ptr::read` is currently implemented via the *untyped* `copy_nonoverlapping`, and thus the `load` doesn't get any type-aware metadata: no `noundef`, no `!range`.  This PR solves that by lowering `ptr::read(p)` to `copy *p` in MIR, for which the backends already do the right thing.\n\nFortuitiously, this also improves the IR we give to LLVM for things like `mem::replace`, and fixes a couple of long-standing bugs where `ptr::read` on `Copy` types was worse than `*`ing them.\n\nZulip conversation: <https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/Move.20array.3A.3AIntoIter.20to.20ManuallyDrop/near/341189936>\n\ncc `@erikdesjardins` `@JakobDegen` `@workingjubilee` `@the8472`\n\nFixes #106369\nFixes #73258", "tree": {"sha": "0282c090692c6fd05dad0bfe0a6c0094344e267d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0282c090692c6fd05dad0bfe0a6c0094344e267d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "html_url": "https://github.com/rust-lang/rust/commit/e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "992d154f3a84cc8abcefcf6e6cf3698e4821b506", "url": "https://api.github.com/repos/rust-lang/rust/commits/992d154f3a84cc8abcefcf6e6cf3698e4821b506", "html_url": "https://github.com/rust-lang/rust/commit/992d154f3a84cc8abcefcf6e6cf3698e4821b506"}, {"sha": "dfc3377954f9e03172fed57ca890141006a0d82e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfc3377954f9e03172fed57ca890141006a0d82e", "html_url": "https://github.com/rust-lang/rust/commit/dfc3377954f9e03172fed57ca890141006a0d82e"}], "stats": {"total": 406, "additions": 358, "deletions": 48}, "files": [{"sha": "8c364a4f3b2b833cb83f93acf0bdbaae0ba949c6", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -363,6 +363,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::likely => (0, vec![tcx.types.bool], tcx.types.bool),\n             sym::unlikely => (0, vec![tcx.types.bool], tcx.types.bool),\n \n+            sym::read_via_copy => (1, vec![tcx.mk_imm_ptr(param(0))], param(0)),\n+\n             sym::discriminant_value => {\n                 let assoc_items = tcx.associated_item_def_ids(\n                     tcx.require_lang_item(hir::LangItem::DiscriminantKind, None),"}, {"sha": "91966e75b5fa2e05bd9e94ac32a7e0cb21532599", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -1026,12 +1026,13 @@ declare_lint! {\n     /// ### Example\n     ///\n     /// ```rust,compile_fail\n-    /// #![feature(const_ptr_read)]\n+    /// #![feature(const_mut_refs)]\n     /// const FOO: () = unsafe {\n     ///     let x = &[0_u8; 4];\n     ///     let y = x.as_ptr().cast::<u32>();\n-    ///     y.read(); // the address of a `u8` array is unknown and thus we don't know if\n-    ///     // it is aligned enough for reading a `u32`.\n+    ///     let mut z = 123;\n+    ///     y.copy_to_nonoverlapping(&mut z, 1); // the address of a `u8` array is unknown\n+    ///     // and thus we don't know if it is aligned enough for copying a `u32`.\n     /// };\n     /// ```\n     ///"}, {"sha": "5d7382305ae14e2bd0a5eb48d54e518351f2e786", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -149,6 +149,35 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                             terminator.kind = TerminatorKind::Goto { target };\n                         }\n                     }\n+                    sym::read_via_copy => {\n+                        let [arg] = args.as_slice() else {\n+                            span_bug!(terminator.source_info.span, \"Wrong number of arguments\");\n+                        };\n+                        let derefed_place =\n+                            if let Some(place) = arg.place() && let Some(local) = place.as_local() {\n+                                tcx.mk_place_deref(local.into())\n+                            } else {\n+                                span_bug!(terminator.source_info.span, \"Only passing a local is supported\");\n+                            };\n+                        terminator.kind = match *target {\n+                            None => {\n+                                // No target means this read something uninhabited,\n+                                // so it must be unreachable, and we don't need to\n+                                // preserve the assignment either.\n+                                TerminatorKind::Unreachable\n+                            }\n+                            Some(target) => {\n+                                block.statements.push(Statement {\n+                                    source_info: terminator.source_info,\n+                                    kind: StatementKind::Assign(Box::new((\n+                                        *destination,\n+                                        Rvalue::Use(Operand::Copy(derefed_place)),\n+                                    ))),\n+                                });\n+                                TerminatorKind::Goto { target }\n+                            }\n+                        }\n+                    }\n                     sym::discriminant_value => {\n                         if let (Some(target), Some(arg)) = (*target, args[0].place()) {\n                             let arg = tcx.mk_place_deref(arg);"}, {"sha": "0154c719ef6088c2a08e18d4a2421ff8f94e5766", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -1153,6 +1153,7 @@ symbols! {\n         read_enum_variant_arg,\n         read_struct,\n         read_struct_field,\n+        read_via_copy,\n         readonly,\n         realloc,\n         reason,"}, {"sha": "ee8846675ce25135403d8fff3fdbe92e3ec5d12b", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -2020,6 +2020,16 @@ extern \"rust-intrinsic\" {\n     #[rustc_safe_intrinsic]\n     pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n+    /// This is an implementation detail of [`crate::ptr::read`] and should\n+    /// not be used anywhere else.  See its comments for why this exists.\n+    ///\n+    /// This intrinsic can *only* be called where the argument is a local without\n+    /// projections (`read_via_copy(p)`, not `read_via_copy(*p)`) so that it\n+    /// trivially obeys runtime-MIR rules about derefs in operands.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+    pub fn read_via_copy<T>(p: *const T) -> T;\n+\n     /// Returns the value of the discriminant for the variant in 'v';\n     /// if `T` has no discriminant, returns `0`.\n     ///"}, {"sha": "5884a8ca308072bbf8dc5e008bba2723439119ac", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -1135,27 +1135,58 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn read<T>(src: *const T) -> T {\n-    // We are calling the intrinsics directly to avoid function calls in the generated code\n-    // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n-    extern \"rust-intrinsic\" {\n-        #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n-        fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n-    }\n+    // It would be semantically correct to implement this via `copy_nonoverlapping`\n+    // and `MaybeUninit`, as was done before PR #109035. Calling `assume_init`\n+    // provides enough information to know that this is a typed operation.\n \n-    let mut tmp = MaybeUninit::<T>::uninit();\n-    // SAFETY: the caller must guarantee that `src` is valid for reads.\n-    // `src` cannot overlap `tmp` because `tmp` was just allocated on\n-    // the stack as a separate allocated object.\n+    // However, as of March 2023 the compiler was not capable of taking advantage\n+    // of that information.  Thus the implementation here switched to an intrinsic,\n+    // which lowers to `_0 = *src` in MIR, to address a few issues:\n     //\n-    // Also, since we just wrote a valid value into `tmp`, it is guaranteed\n-    // to be properly initialized.\n+    // - Using `MaybeUninit::assume_init` after a `copy_nonoverlapping` was not\n+    //   turning the untyped copy into a typed load. As such, the generated\n+    //   `load` in LLVM didn't get various metadata, such as `!range` (#73258),\n+    //   `!nonnull`, and `!noundef`, resulting in poorer optimization.\n+    // - Going through the extra local resulted in multiple extra copies, even\n+    //   in optimized MIR.  (Ignoring StorageLive/Dead, the intrinsic is one\n+    //   MIR statement, while the previous implementation was eight.)  LLVM\n+    //   could sometimes optimize them away, but because `read` is at the core\n+    //   of so many things, not having them in the first place improves what we\n+    //   hand off to the backend.  For example, `mem::replace::<Big>` previously\n+    //   emitted 4 `alloca` and 6 `memcpy`s, but is now 1 `alloc` and 3 `memcpy`s.\n+    // - In general, this approach keeps us from getting any more bugs (like\n+    //   #106369) that boil down to \"`read(p)` is worse than `*p`\", as this\n+    //   makes them look identical to the backend (or other MIR consumers).\n+    //\n+    // Future enhancements to MIR optimizations might well allow this to return\n+    // to the previous implementation, rather than using an intrinsic.\n+\n+    // SAFETY: the caller must guarantee that `src` is valid for reads.\n     unsafe {\n         assert_unsafe_precondition!(\n             \"ptr::read requires that the pointer argument is aligned and non-null\",\n             [T](src: *const T) => is_aligned_and_not_null(src)\n         );\n-        copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-        tmp.assume_init()\n+\n+        #[cfg(bootstrap)]\n+        {\n+            // We are calling the intrinsics directly to avoid function calls in the\n+            // generated code as `intrinsics::copy_nonoverlapping` is a wrapper function.\n+            extern \"rust-intrinsic\" {\n+                #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+                fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+            }\n+\n+            // `src` cannot overlap `tmp` because `tmp` was just allocated on\n+            // the stack as a separate allocated object.\n+            let mut tmp = MaybeUninit::<T>::uninit();\n+            copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+            tmp.assume_init()\n+        }\n+        #[cfg(not(bootstrap))]\n+        {\n+            crate::intrinsics::read_via_copy(src)\n+        }\n     }\n }\n "}, {"sha": "3fe7be4f1442ef0feacc591d410d32b09500d899", "filename": "tests/codegen/issues/issue-106369.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fcodegen%2Fissues%2Fissue-106369.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fcodegen%2Fissues%2Fissue-106369.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-106369.rs?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -O\n+// ignore-debug (the extra assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+\n+// From <https://github.com/rust-lang/rust/issues/106369#issuecomment-1369095304>\n+\n+// CHECK-LABEL: @issue_106369(\n+#[no_mangle]\n+pub unsafe fn issue_106369(ptr: *const &i32) -> bool {\n+    // CHECK-NOT: icmp\n+    // CHECK: ret i1 true\n+    // CHECK-NOT: icmp\n+    Some(std::ptr::read(ptr)).is_some()\n+}"}, {"sha": "0134f929b296111e2491e5bcf540f69af0437bae", "filename": "tests/codegen/issues/issue-73258.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fcodegen%2Fissues%2Fissue-73258.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fcodegen%2Fissues%2Fissue-73258.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-73258.rs?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -0,0 +1,38 @@\n+// compile-flags: -O\n+// ignore-debug (the extra assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+\n+// Adapted from <https://github.com/rust-lang/rust/issues/73258#issue-637346014>\n+\n+#[derive(Clone, Copy)]\n+#[repr(u8)]\n+pub enum Foo {\n+    A, B, C, D,\n+}\n+\n+// CHECK-LABEL: @issue_73258(\n+#[no_mangle]\n+pub unsafe fn issue_73258(ptr: *const Foo) -> Foo {\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: call\n+    // CHECK-NOT: br\n+    // CHECK-NOT: select\n+\n+    // CHECK: %[[R:.+]] = load i8\n+    // CHECK-SAME: !range !\n+\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: call\n+    // CHECK-NOT: br\n+    // CHECK-NOT: select\n+\n+    // CHECK: ret i8 %[[R]]\n+\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: call\n+    // CHECK-NOT: br\n+    // CHECK-NOT: select\n+    let k: Option<Foo> = Some(ptr.read());\n+    return k.unwrap();\n+}"}, {"sha": "f6898e2f75814e87d1d91c094257601c78504566", "filename": "tests/codegen/mem-replace-big-type.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fcodegen%2Fmem-replace-big-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fcodegen%2Fmem-replace-big-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-big-type.rs?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -0,0 +1,36 @@\n+// This test ensures that `mem::replace::<T>` only ever calls `@llvm.memcpy`\n+// with `size_of::<T>()` as the size, and never goes through any wrapper that\n+// may e.g. multiply `size_of::<T>()` with a variable \"count\" (which is only\n+// known to be `1` after inlining).\n+\n+// compile-flags: -C no-prepopulate-passes -Zinline-mir=no\n+// ignore-debug: the debug assertions get in the way\n+\n+#![crate_type = \"lib\"]\n+\n+#[repr(C, align(8))]\n+pub struct Big([u64; 7]);\n+pub fn replace_big(dst: &mut Big, src: Big) -> Big {\n+    // Before the `read_via_copy` intrinsic, this emitted six `memcpy`s.\n+    std::mem::replace(dst, src)\n+}\n+\n+// NOTE(eddyb) the `CHECK-NOT`s ensure that the only calls of `@llvm.memcpy` in\n+// the entire output, are the direct calls we want, from `ptr::replace`.\n+\n+// CHECK-NOT: call void @llvm.memcpy\n+\n+// For a large type, we expect exactly three `memcpy`s\n+// CHECK-LABEL: define internal void @{{.+}}mem{{.+}}replace{{.+}}sret(%Big)\n+    // CHECK-NOT: alloca\n+    // CHECK: alloca %Big\n+    // CHECK-NOT: alloca\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK-NOT: call void @llvm.memcpy\n+\n+// CHECK-NOT: call void @llvm.memcpy"}, {"sha": "83babab4f847b150dc4d0e8301b13c7298e49e3a", "filename": "tests/codegen/mem-replace-direct-memcpy.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -13,12 +13,21 @@ pub fn replace_byte(dst: &mut u8, src: u8) -> u8 {\n }\n \n // NOTE(eddyb) the `CHECK-NOT`s ensure that the only calls of `@llvm.memcpy` in\n-// the entire output, are the two direct calls we want, from `ptr::replace`.\n+// the entire output, are the direct calls we want, from `ptr::replace`.\n \n // CHECK-NOT: call void @llvm.memcpy\n-// CHECK: ; core::mem::replace\n-// CHECK-NOT: call void @llvm.memcpy\n-// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{.*}} 1, i1 false)\n-// CHECK-NOT: call void @llvm.memcpy\n-// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{.*}} 1, i1 false)\n+\n+// For a small type, we expect one each of `load`/`store`/`memcpy` instead\n+// CHECK-LABEL: define internal noundef i8 @{{.+}}mem{{.+}}replace\n+    // CHECK-NOT: alloca\n+    // CHECK: alloca i8\n+    // CHECK-NOT: alloca\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: load i8\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: store i8\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{.*}} 1, i1 false)\n+    // CHECK-NOT: call void @llvm.memcpy\n+\n // CHECK-NOT: call void @llvm.memcpy"}, {"sha": "e1e3272662c4bbc0ea3c9a2c45ecd8719e2b510c", "filename": "tests/codegen/ptr-read-metadata.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fcodegen%2Fptr-read-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fcodegen%2Fptr-read-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fptr-read-metadata.rs?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -0,0 +1,96 @@\n+// compile-flags: -O -Z merge-functions=disabled\n+// no-system-llvm\n+// ignore-debug (the extra assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+\n+// Ensure that various forms of reading pointers correctly annotate the `load`s\n+// with `!noundef` and `!range` metadata to enable extra optimization.\n+\n+use std::mem::MaybeUninit;\n+\n+// CHECK-LABEL: define noundef i8 @copy_byte(\n+#[no_mangle]\n+pub unsafe fn copy_byte(p: *const u8) -> u8 {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    *p\n+}\n+\n+// CHECK-LABEL: define noundef i8 @read_byte(\n+#[no_mangle]\n+pub unsafe fn read_byte(p: *const u8) -> u8 {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define i8 @read_byte_maybe_uninit(\n+#[no_mangle]\n+pub unsafe fn read_byte_maybe_uninit(p: *const MaybeUninit<u8>) -> MaybeUninit<u8> {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-NOT: noundef\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define noundef i8 @read_byte_assume_init(\n+#[no_mangle]\n+pub unsafe fn read_byte_assume_init(p: &MaybeUninit<u8>) -> u8 {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    p.assume_init_read()\n+}\n+\n+// CHECK-LABEL: define noundef i32 @copy_char(\n+#[no_mangle]\n+pub unsafe fn copy_char(p: *const char) -> char {\n+    // CHECK-NOT: load\n+    // CHECK: load i32, ptr %p\n+    // CHECK-SAME: !range ![[RANGE:[0-9]+]]\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    *p\n+}\n+\n+// CHECK-LABEL: define noundef i32 @read_char(\n+#[no_mangle]\n+pub unsafe fn read_char(p: *const char) -> char {\n+    // CHECK-NOT: load\n+    // CHECK: load i32, ptr %p\n+    // CHECK-SAME: !range ![[RANGE]]\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define i32 @read_char_maybe_uninit(\n+#[no_mangle]\n+pub unsafe fn read_char_maybe_uninit(p: *const MaybeUninit<char>) -> MaybeUninit<char> {\n+    // CHECK-NOT: load\n+    // CHECK: load i32, ptr %p\n+    // CHECK-NOT: range\n+    // CHECK-NOT: noundef\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define noundef i32 @read_char_assume_init(\n+#[no_mangle]\n+pub unsafe fn read_char_assume_init(p: &MaybeUninit<char>) -> char {\n+    // CHECK-NOT: load\n+    // CHECK: load i32, ptr %p\n+    // CHECK-SAME: !range ![[RANGE]]\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    p.assume_init_read()\n+}\n+\n+// CHECK: ![[RANGE]] = !{i32 0, i32 1114112}"}, {"sha": "27fceeedf6e2c894054bd73de474d3721c2b6ec7", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -0,0 +1,27 @@\n+- // MIR for `read_via_copy_primitive` before LowerIntrinsics\n++ // MIR for `read_via_copy_primitive` after LowerIntrinsics\n+  \n+  fn read_via_copy_primitive(_1: &i32) -> i32 {\n+      debug r => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:32: +0:33\n+      let mut _0: i32;                     // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:44: +0:47\n+      let mut _2: *const i32;              // in scope 0 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+          _2 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+-         _0 = read_via_copy::<i32>(move _2) -> bb1; // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:85:14: 85:45\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const i32) -> i32 {read_via_copy::<i32>}, val: Value(<ZST>) }\n++         _0 = (*_2);                      // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n++         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n+      }\n+  \n+      bb1: {\n+          StorageDead(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:47: +1:48\n+          return;                          // scope 0 at $DIR/lower_intrinsics.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "610c67d2fecd67b45a5194059756bb2cb9594777", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -0,0 +1,21 @@\n+- // MIR for `read_via_copy_uninhabited` before LowerIntrinsics\n++ // MIR for `read_via_copy_uninhabited` after LowerIntrinsics\n+  \n+  fn read_via_copy_uninhabited(_1: &Never) -> Never {\n+      debug r => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:34: +0:35\n+      let mut _0: Never;                   // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:48: +0:53\n+      let mut _2: *const Never;            // in scope 0 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+          _2 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+-         _0 = read_via_copy::<Never>(move _2); // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:90:14: 90:45\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Never) -> Never {read_via_copy::<Never>}, val: Value(<ZST>) }\n++         unreachable;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n+      }\n+  }\n+  "}, {"sha": "a0a1df4e5ca86c5f203662727f3cd43de8db4b54", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -79,3 +79,15 @@ pub fn with_overflow(a: i32, b: i32) {\n     let _y = core::intrinsics::sub_with_overflow(a, b);\n     let _z = core::intrinsics::mul_with_overflow(a, b);\n }\n+\n+// EMIT_MIR lower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff\n+pub fn read_via_copy_primitive(r: &i32) -> i32 {\n+    unsafe { core::intrinsics::read_via_copy(r) }\n+}\n+\n+// EMIT_MIR lower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff\n+pub fn read_via_copy_uninhabited(r: &Never) -> Never {\n+    unsafe { core::intrinsics::read_via_copy(r) }\n+}\n+\n+pub enum Never {}"}, {"sha": "89536f53f08b0440377650eb32330efffeb3460b", "filename": "tests/ui/const-ptr/out_of_bounds_read.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -1,7 +1,7 @@\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   = note: dereferencing pointer failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n@@ -14,7 +14,7 @@ LL |     const _READ: u32 = unsafe { ptr::read(PAST_END_PTR) };\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   = note: dereferencing pointer failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n@@ -29,7 +29,7 @@ LL |     const _CONST_READ: u32 = unsafe { PAST_END_PTR.read() };\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   = note: dereferencing pointer failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL"}, {"sha": "080568b51ef715ec3644a33a5f52cef0368a12af", "filename": "tests/ui/consts/const-eval/ub-ref-ptr.stderr", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -148,11 +148,11 @@ LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n                HEX_DUMP\n            }\n \n-error: accessing memory with alignment 1, but alignment 4 is required\n+error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n+   = note: accessing memory with alignment 1, but alignment 4 is required\n+   |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n note: inside `ptr::const_ptr::<impl *const u32>::read`\n@@ -162,25 +162,7 @@ note: inside `UNALIGNED_READ`\n    |\n LL |     ptr.read();\n    |     ^^^^^^^^^^\n-   = note: `#[deny(invalid_alignment)]` on by default\n \n error: aborting due to 15 previous errors\n \n For more information about this error, try `rustc --explain E0080`.\n-Future incompatibility report: Future breakage diagnostic:\n-error: accessing memory with alignment 1, but alignment 4 is required\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n-note: inside `std::ptr::read::<u32>`\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u32>::read`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:67:5\n-   |\n-LL |     ptr.read();\n-   |     ^^^^^^^^^^\n-   = note: `#[deny(invalid_alignment)]` on by default\n-"}, {"sha": "a10eea9de114fb82c924bbe593bafa768664a8d8", "filename": "tests/ui/consts/issue-miri-1910.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e4b9f86054c581d931f8bad0c87523c53e1e8e3f/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr?ref=e4b9f86054c581d931f8bad0c87523c53e1e8e3f", "patch": "@@ -1,7 +1,7 @@\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: unable to copy parts of a pointer from memory at ALLOC\n+   = note: unable to turn pointer into raw bytes\n    |\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported"}]}