{"sha": "344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5", "node_id": "C_kwDOAAsO6NoAKDM0NDg4OGE1ODIwYzJhZTJkN2M4OGVjZjE0YmNhZmZiNjBjYTJiYzU", "commit": {"author": {"name": "yonip23", "email": "yoni@tabnine.com", "date": "2022-05-11T20:11:52Z"}, "committer": {"name": "yonip23", "email": "yoni@tabnine.com", "date": "2022-05-11T20:11:52Z"}, "message": "fix review comments", "tree": {"sha": "980e3484bcf6421218af64e05b0323e6bedd1853", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/980e3484bcf6421218af64e05b0323e6bedd1853"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5", "html_url": "https://github.com/rust-lang/rust/commit/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5/comments", "author": {"login": "yonip23", "id": 67855609, "node_id": "MDQ6VXNlcjY3ODU1NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/67855609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yonip23", "html_url": "https://github.com/yonip23", "followers_url": "https://api.github.com/users/yonip23/followers", "following_url": "https://api.github.com/users/yonip23/following{/other_user}", "gists_url": "https://api.github.com/users/yonip23/gists{/gist_id}", "starred_url": "https://api.github.com/users/yonip23/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yonip23/subscriptions", "organizations_url": "https://api.github.com/users/yonip23/orgs", "repos_url": "https://api.github.com/users/yonip23/repos", "events_url": "https://api.github.com/users/yonip23/events{/privacy}", "received_events_url": "https://api.github.com/users/yonip23/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yonip23", "id": 67855609, "node_id": "MDQ6VXNlcjY3ODU1NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/67855609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yonip23", "html_url": "https://github.com/yonip23", "followers_url": "https://api.github.com/users/yonip23/followers", "following_url": "https://api.github.com/users/yonip23/following{/other_user}", "gists_url": "https://api.github.com/users/yonip23/gists{/gist_id}", "starred_url": "https://api.github.com/users/yonip23/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yonip23/subscriptions", "organizations_url": "https://api.github.com/users/yonip23/orgs", "repos_url": "https://api.github.com/users/yonip23/repos", "events_url": "https://api.github.com/users/yonip23/events{/privacy}", "received_events_url": "https://api.github.com/users/yonip23/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3e01c4f6a12ad1bd70813875ed84dbe8c830df7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3e01c4f6a12ad1bd70813875ed84dbe8c830df7", "html_url": "https://github.com/rust-lang/rust/commit/f3e01c4f6a12ad1bd70813875ed84dbe8c830df7"}], "stats": {"total": 162, "additions": 115, "deletions": 47}, "files": [{"sha": "7a7a3f558ca0511db7993fc80d39e2fd941f1046", "filename": "clippy_lints/src/rc_clone_in_vec_init.rs", "status": "modified", "additions": 31, "deletions": 41, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5/clippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5/clippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs?ref=344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::higher::VecArgs;\n use clippy_utils::last_path_segment;\n use clippy_utils::macros::root_macro_call_first_node;\n use clippy_utils::source::{indent_of, snippet};\n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -51,70 +51,53 @@ impl LateLintPass<'_> for RcCloneInVecInit {\n         let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return; };\n         let Some(VecArgs::Repeat(elem, len)) = VecArgs::hir(cx, expr) else { return; };\n         let Some(symbol) = new_reference_call(cx, elem) else { return; };\n-        let lint_span = macro_call.span;\n-        let symbol_name = symbol.as_str();\n-        let len_snippet = snippet(cx, len.span, \"..\");\n-        let elem_snippet = elem_snippet(cx, elem, symbol_name);\n-        let indentation = indent_of(cx, lint_span).unwrap_or(0);\n-        let lint_suggestions =\n-            construct_lint_suggestions(lint_span, symbol_name, &elem_snippet, len_snippet.as_ref(), indentation);\n-\n-        emit_lint(cx, symbol, lint_span, &lint_suggestions);\n+\n+        emit_lint(cx, symbol, macro_call.span, elem, len);\n     }\n }\n \n struct LintSuggestion {\n-    span: Span,\n     message: String,\n-    suggestion: String,\n-    applicability: Applicability,\n-}\n-\n-impl LintSuggestion {\n-    fn span_suggestion(&self, diag: &mut Diagnostic) {\n-        diag.span_suggestion(self.span, &self.message, &self.suggestion, self.applicability);\n-    }\n+    snippet: String,\n }\n \n fn construct_lint_suggestions(\n+    cx: &LateContext<'_>,\n     span: Span,\n     symbol_name: &str,\n-    elem_snippet: &str,\n-    len_snippet: &str,\n-    indentation: usize,\n+    elem: &Expr<'_>,\n+    len: &Expr<'_>,\n ) -> Vec<LintSuggestion> {\n+    let len_snippet = snippet(cx, len.span, \"..\");\n+    let elem_snippet = elem_snippet(cx, elem, symbol_name);\n+    let indentation = indent_of(cx, span).unwrap_or(0);\n     let indentation = \" \".repeat(indentation);\n-    let loop_init_suggestion = loop_init_suggestion(elem_snippet, len_snippet, &indentation);\n-    let extract_suggestion = extract_suggestion(elem_snippet, len_snippet, &indentation);\n+    let loop_init_suggestion = loop_init_suggestion(&elem_snippet, len_snippet.as_ref(), &indentation);\n+    let extract_suggestion = extract_suggestion(&elem_snippet, len_snippet.as_ref(), &indentation);\n \n     vec![\n         LintSuggestion {\n-            span,\n             message: format!(\"consider initializing each `{symbol_name}` element individually\"),\n-            suggestion: loop_init_suggestion,\n-            applicability: Applicability::Unspecified,\n+            snippet: loop_init_suggestion,\n         },\n         LintSuggestion {\n-            span,\n             message: format!(\n                 \"or if this is intentional, consider extracting the `{symbol_name}` initialization to a variable\"\n             ),\n-            suggestion: extract_suggestion,\n-            applicability: Applicability::Unspecified,\n+            snippet: extract_suggestion,\n         },\n     ]\n }\n \n fn elem_snippet(cx: &LateContext<'_>, elem: &Expr<'_>, symbol_name: &str) -> String {\n-    let mut elem_snippet = snippet(cx, elem.span, \"..\").to_string();\n+    let elem_snippet = snippet(cx, elem.span, \"..\").to_string();\n     if elem_snippet.contains('\\n') {\n-        let reference_initialization = format!(\"{symbol_name}::new\");\n-        // This string must be found in `elem_snippet`, otherwise we won't be constructing the snippet in\n-        // the first place.\n-        let reference_initialization_end =\n-            elem_snippet.find(&reference_initialization).unwrap() + reference_initialization.len();\n-        elem_snippet.replace_range(reference_initialization_end.., \"..\");\n+        let reference_creation = format!(\"{symbol_name}::new\");\n+        let (code_until_reference_creation, _right) = elem_snippet.split_once(&reference_creation).unwrap();\n+\n+        return format!(\"{code_until_reference_creation}{reference_creation}(..)\");\n     }\n+\n     elem_snippet\n }\n \n@@ -137,7 +120,7 @@ fn extract_suggestion(elem: &str, len: &str, indent: &str) -> String {\n     )\n }\n \n-fn emit_lint(cx: &LateContext<'_>, symbol: Symbol, lint_span: Span, lint_suggestions: &[LintSuggestion]) {\n+fn emit_lint(cx: &LateContext<'_>, symbol: Symbol, lint_span: Span, elem: &Expr<'_>, len: &Expr<'_>) {\n     let symbol_name = symbol.as_str();\n \n     span_lint_and_then(\n@@ -146,10 +129,17 @@ fn emit_lint(cx: &LateContext<'_>, symbol: Symbol, lint_span: Span, lint_suggest\n         lint_span,\n         &format!(\"calling `{symbol_name}::new` in `vec![elem; len]`\"),\n         |diag| {\n+            let suggestions = construct_lint_suggestions(cx, lint_span, symbol_name, elem, len);\n+\n             diag.note(format!(\"each element will point to the same `{symbol_name}` instance\"));\n-            lint_suggestions\n-                .iter()\n-                .for_each(|suggestion| suggestion.span_suggestion(diag));\n+            suggestions.iter().for_each(|suggestion| {\n+                diag.span_suggestion(\n+                    lint_span,\n+                    &suggestion.message,\n+                    &suggestion.snippet,\n+                    Applicability::Unspecified,\n+                );\n+            });\n         },\n     );\n }"}, {"sha": "bef2c67a1a54cfc854875fa185653e685c638165", "filename": "tests/ui/rc_clone_in_vec_init/arc.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5/tests%2Fui%2Frc_clone_in_vec_init%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5/tests%2Fui%2Frc_clone_in_vec_init%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_clone_in_vec_init%2Farc.rs?ref=344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5", "patch": "@@ -16,6 +16,15 @@ fn should_warn_complex_case() {\n         }));\n         2\n     ];\n+\n+    let v1 = vec![\n+        Arc::new(Mutex::new({\n+            let x = 1;\n+            dbg!(x);\n+            x\n+        }));\n+        2\n+    ];\n }\n \n fn should_not_warn_custom_arc() {"}, {"sha": "387580c243106e801e1e080e86ae6f1bc126a924", "filename": "tests/ui/rc_clone_in_vec_init/arc.stderr", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5/tests%2Fui%2Frc_clone_in_vec_init%2Farc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5/tests%2Fui%2Frc_clone_in_vec_init%2Farc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_clone_in_vec_init%2Farc.stderr?ref=344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5", "patch": "@@ -40,17 +40,47 @@ help: consider initializing each `Arc` element individually\n    |\n LL ~     let v = {\n LL +         let mut v = Vec::with_capacity(2);\n-LL +         (0..2).for_each(|_| v.push(std::sync::Arc::new..));\n+LL +         (0..2).for_each(|_| v.push(std::sync::Arc::new(..)));\n LL +         v\n LL ~     };\n    |\n help: or if this is intentional, consider extracting the `Arc` initialization to a variable\n    |\n LL ~     let v = {\n-LL +         let data = std::sync::Arc::new..;\n+LL +         let data = std::sync::Arc::new(..);\n LL +         vec![data; 2]\n LL ~     };\n    |\n \n-error: aborting due to 2 previous errors\n+error: calling `Arc::new` in `vec![elem; len]`\n+  --> $DIR/arc.rs:20:14\n+   |\n+LL |       let v1 = vec![\n+   |  ______________^\n+LL | |         Arc::new(Mutex::new({\n+LL | |             let x = 1;\n+LL | |             dbg!(x);\n+...  |\n+LL | |         2\n+LL | |     ];\n+   | |_____^\n+   |\n+   = note: each element will point to the same `Arc` instance\n+help: consider initializing each `Arc` element individually\n+   |\n+LL ~     let v1 = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(Arc::new(..)));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Arc` initialization to a variable\n+   |\n+LL ~     let v1 = {\n+LL +         let data = Arc::new(..);\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "79c23cafa2c1ad8a5831ce935741154608603a1d", "filename": "tests/ui/rc_clone_in_vec_init/rc.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5/tests%2Fui%2Frc_clone_in_vec_init%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5/tests%2Fui%2Frc_clone_in_vec_init%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_clone_in_vec_init%2Frc.rs?ref=344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5", "patch": "@@ -17,6 +17,15 @@ fn should_warn_complex_case() {\n         }));\n         2\n     ];\n+\n+    let v1 = vec![\n+        Rc::new(Mutex::new({\n+            let x = 1;\n+            dbg!(x);\n+            x\n+        }));\n+        2\n+    ];\n }\n \n fn should_not_warn_custom_arc() {"}, {"sha": "4ce53eecbbd80ccb468f9df96c31b125177fb86f", "filename": "tests/ui/rc_clone_in_vec_init/rc.stderr", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5/tests%2Fui%2Frc_clone_in_vec_init%2Frc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5/tests%2Fui%2Frc_clone_in_vec_init%2Frc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_clone_in_vec_init%2Frc.stderr?ref=344888a5820c2ae2d7c88ecf14bcaffb60ca2bc5", "patch": "@@ -40,17 +40,47 @@ help: consider initializing each `Rc` element individually\n    |\n LL ~     let v = {\n LL +         let mut v = Vec::with_capacity(2);\n-LL +         (0..2).for_each(|_| v.push(std::rc::Rc::new..));\n+LL +         (0..2).for_each(|_| v.push(std::rc::Rc::new(..)));\n LL +         v\n LL ~     };\n    |\n help: or if this is intentional, consider extracting the `Rc` initialization to a variable\n    |\n LL ~     let v = {\n-LL +         let data = std::rc::Rc::new..;\n+LL +         let data = std::rc::Rc::new(..);\n LL +         vec![data; 2]\n LL ~     };\n    |\n \n-error: aborting due to 2 previous errors\n+error: calling `Rc::new` in `vec![elem; len]`\n+  --> $DIR/rc.rs:21:14\n+   |\n+LL |       let v1 = vec![\n+   |  ______________^\n+LL | |         Rc::new(Mutex::new({\n+LL | |             let x = 1;\n+LL | |             dbg!(x);\n+...  |\n+LL | |         2\n+LL | |     ];\n+   | |_____^\n+   |\n+   = note: each element will point to the same `Rc` instance\n+help: consider initializing each `Rc` element individually\n+   |\n+LL ~     let v1 = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(Rc::new(..)));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Rc` initialization to a variable\n+   |\n+LL ~     let v1 = {\n+LL +         let data = Rc::new(..);\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n+\n+error: aborting due to 3 previous errors\n "}]}