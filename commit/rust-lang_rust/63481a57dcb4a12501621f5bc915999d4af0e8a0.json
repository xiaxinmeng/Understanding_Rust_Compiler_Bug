{"sha": "63481a57dcb4a12501621f5bc915999d4af0e8a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNDgxYTU3ZGNiNGExMjUwMTYyMWY1YmM5MTU5OTlkNGFmMGU4YTA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-08T20:57:16Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-10T12:29:18Z"}, "message": "rustc: make InferCtxt optional in MemCategorizationContext.", "tree": {"sha": "58cd4ff93e09c6f2065ed4ae378040d23979287c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58cd4ff93e09c6f2065ed4ae378040d23979287c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63481a57dcb4a12501621f5bc915999d4af0e8a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63481a57dcb4a12501621f5bc915999d4af0e8a0", "html_url": "https://github.com/rust-lang/rust/commit/63481a57dcb4a12501621f5bc915999d4af0e8a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63481a57dcb4a12501621f5bc915999d4af0e8a0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f874ded52acaecd47b39e90e93d7d7a31c90dae", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f874ded52acaecd47b39e90e93d7d7a31c90dae", "html_url": "https://github.com/rust-lang/rust/commit/1f874ded52acaecd47b39e90e93d7d7a31c90dae"}], "stats": {"total": 196, "additions": 105, "deletions": 91}, "files": [{"sha": "b3e5f13de2c400b6b70336816cc07838e92f163d", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=63481a57dcb4a12501621f5bc915999d4af0e8a0", "patch": "@@ -393,27 +393,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             fresh_tables: env.fresh_tables().map(RefCell::new),\n         }\n     }\n-\n-    /// Fake InferCtxt with the global tcx. Used by pre-MIR borrowck\n-    /// for MemCategorizationContext/ExprUseVisitor.\n-    /// If any inference functionality is used, ICEs will occur.\n-    pub fn borrowck_fake_infer_ctxt(self) -> InferCtxt<'a, 'gcx, 'gcx> {\n-        InferCtxt {\n-            tcx: self,\n-            tables: InferTables::Missing,\n-            type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-            int_unification_table: RefCell::new(UnificationTable::new()),\n-            float_unification_table: RefCell::new(UnificationTable::new()),\n-            region_vars: RegionVarBindings::new(self),\n-            selection_cache: traits::SelectionCache::new(),\n-            evaluation_cache: traits::EvaluationCache::new(),\n-            projection_cache: RefCell::new(traits::ProjectionCache::new()),\n-            reported_trait_errors: RefCell::new(FxHashSet()),\n-            tainted_by_errors_flag: Cell::new(false),\n-            err_count_on_creation: self.sess.err_count(),\n-            in_snapshot: Cell::new(false),\n-        }\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {"}, {"sha": "58e77f40d981d4b692f5c16601e7c1bff13f719b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=63481a57dcb4a12501621f5bc915999d4af0e8a0", "patch": "@@ -261,16 +261,32 @@ macro_rules! return_if_err {\n     )\n }\n \n-impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n-               infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                param_env: ty::ParamEnv<'tcx>,\n                region_maps: &'a RegionMaps,\n                tables: &'a ty::TypeckTables<'tcx>)\n                -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::new(infcx, region_maps, tables),\n+            mc: mc::MemCategorizationContext::new(tcx, region_maps, tables),\n+            delegate,\n+            param_env,\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n+    pub fn with_infer(delegate: &'a mut (Delegate<'tcx>+'a),\n+                      infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                      param_env: ty::ParamEnv<'tcx>,\n+                      region_maps: &'a RegionMaps,\n+                      tables: &'a ty::TypeckTables<'tcx>)\n+                      -> Self\n+    {\n+        ExprUseVisitor {\n+            mc: mc::MemCategorizationContext::with_infer(infcx, region_maps, tables),\n             delegate,\n             param_env,\n         }\n@@ -296,7 +312,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n-        self.mc.infcx.tcx\n+        self.mc.tcx\n     }\n \n     fn delegate_consume(&mut self,\n@@ -306,7 +322,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n                consume_id, cmt);\n \n-        let mode = copy_or_move(self.mc.infcx, self.param_env, &cmt, DirectRefMove);\n+        let mode = copy_or_move(&self.mc, self.param_env, &cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n@@ -784,7 +800,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 PatKind::Binding(hir::BindByRef(..), ..) =>\n                     mode.lub(BorrowingMatch),\n                 PatKind::Binding(hir::BindByValue(..), ..) => {\n-                    match copy_or_move(self.mc.infcx, self.param_env, &cmt_pat, PatBindingMove) {\n+                    match copy_or_move(&self.mc, self.param_env, &cmt_pat, PatBindingMove) {\n                         Copy => mode.lub(CopyingMatch),\n                         Move(..) => mode.lub(MovingMatch),\n                     }\n@@ -801,7 +817,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n \n         let tcx = self.tcx();\n-        let infcx = self.mc.infcx;\n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(bmode, def_id, ..) = pat.node {\n@@ -826,7 +841,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     hir::BindByValue(..) => {\n-                        let mode = copy_or_move(infcx, param_env, &cmt_pat, PatBindingMove);\n+                        let mode = copy_or_move(mc, param_env, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);\n                     }\n@@ -885,7 +900,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                                                    freevar.def));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n-                        let mode = copy_or_move(self.mc.infcx,\n+                        let mode = copy_or_move(&self.mc,\n                                                 self.param_env,\n                                                 &cmt_var,\n                                                 CaptureMove);\n@@ -917,13 +932,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn copy_or_move<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+fn copy_or_move<'a, 'gcx, 'tcx>(mc: &mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n                                 param_env: ty::ParamEnv<'tcx>,\n                                 cmt: &mc::cmt<'tcx>,\n                                 move_reason: MoveReason)\n                                 -> ConsumeMode\n {\n-    if infcx.type_moves_by_default(param_env, cmt.ty, cmt.span) {\n+    if mc.type_moves_by_default(param_env, cmt.ty, cmt.span) {\n         Move(move_reason)\n     } else {\n         Copy"}, {"sha": "259079cf16048bbfa0b65f0282a57be72eb3bd65", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 53, "deletions": 28, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=63481a57dcb4a12501621f5bc915999d4af0e8a0", "patch": "@@ -282,9 +282,10 @@ impl ast_node for hir::Pat {\n \n #[derive(Clone)]\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub region_maps: &'a RegionMaps,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n+    infcx: Option<&'a InferCtxt<'a, 'gcx, 'tcx>>,\n }\n \n pub type McResult<T> = Result<T, ()>;\n@@ -385,27 +386,51 @@ impl MutabilityCategory {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-    /// Context should be the `DefId` we use to fetch region-maps.\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                region_maps: &'a RegionMaps,\n                tables: &'a ty::TypeckTables<'tcx>)\n-               -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-        MemCategorizationContext { infcx, region_maps, tables }\n+               -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n+        MemCategorizationContext { tcx, region_maps, tables, infcx: None }\n     }\n+}\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n-        self.infcx.tcx\n+impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+    pub fn with_infer(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                      region_maps: &'a RegionMaps,\n+                      tables: &'a ty::TypeckTables<'tcx>)\n+                      -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+        MemCategorizationContext {\n+            tcx: infcx.tcx,\n+            region_maps,\n+            tables,\n+            infcx: Some(infcx),\n+        }\n+    }\n+\n+    pub fn type_moves_by_default(&self,\n+                                 param_env: ty::ParamEnv<'tcx>,\n+                                 ty: Ty<'tcx>,\n+                                 span: Span)\n+                                 -> bool {\n+        self.infcx.map(|infcx| infcx.type_moves_by_default(param_env, ty, span))\n+            .or_else(|| {\n+                self.tcx.lift_to_global(&(param_env, ty)).map(|(param_env, ty)| {\n+                    ty.moves_by_default(self.tcx.global_tcx(), param_env, span)\n+                })\n+            })\n+            .unwrap_or(true)\n     }\n \n     fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n-        self.infcx.resolve_type_vars_if_possible(value)\n+        self.infcx.map(|infcx| infcx.resolve_type_vars_if_possible(value))\n+            .unwrap_or_else(|| value.clone())\n     }\n \n     fn is_tainted_by_errors(&self) -> bool {\n-        self.infcx.is_tainted_by_errors()\n+        self.infcx.map_or(false, |infcx| infcx.is_tainted_by_errors())\n     }\n \n     fn resolve_type_vars_or_error(&self,\n@@ -426,7 +451,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             None if self.is_tainted_by_errors() => Err(()),\n             None => {\n                 bug!(\"no type for node {}: {} in mem_categorization\",\n-                     id, self.tcx().hir.node_to_string(id));\n+                     id, self.tcx.hir.node_to_string(id));\n             }\n         }\n     }\n@@ -506,7 +531,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             adjustment::Adjust::Deref(overloaded) => {\n                 // Equivalent to *expr or something similar.\n                 let base = if let Some(deref) = overloaded {\n-                    let ref_ty = self.tcx().mk_ref(deref.region, ty::TypeAndMut {\n+                    let ref_ty = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n                         ty: target,\n                         mutbl: deref.mutbl,\n                     });\n@@ -624,17 +649,17 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           Def::Upvar(def_id, _, fn_node_id) => {\n-              let var_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n+              let var_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n               self.cat_upvar(id, span, var_id, fn_node_id)\n           }\n \n           Def::Local(def_id) => {\n-            let vid = self.tcx().hir.as_local_node_id(def_id).unwrap();\n+            let vid = self.tcx.hir.as_local_node_id(def_id).unwrap();\n             Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n                 cat: Categorization::Local(vid),\n-                mutbl: MutabilityCategory::from_local(self.tcx(), vid),\n+                mutbl: MutabilityCategory::from_local(self.tcx, vid),\n                 ty: expr_ty,\n                 note: NoteNone\n             }))\n@@ -686,7 +711,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let var_ty = self.node_ty(var_id)?;\n \n         // Mutability of original variable itself\n-        let var_mutbl = MutabilityCategory::from_local(self.tcx(), var_id);\n+        let var_mutbl = MutabilityCategory::from_local(self.tcx, var_id);\n \n         // Construct the upvar. This represents access to the field\n         // from the environment (perhaps we should eventually desugar\n@@ -753,11 +778,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                  -> cmt_<'tcx>\n     {\n         // Region of environment pointer\n-        let env_region = self.tcx().mk_region(ty::ReFree(ty::FreeRegion {\n+        let env_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: self.tcx().hir.local_def_id(upvar_id.closure_expr_id),\n+            scope: self.tcx.hir.local_def_id(upvar_id.closure_expr_id),\n             bound_region: ty::BrEnv\n         }));\n \n@@ -774,7 +799,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // one.\n         let cmt_result = cmt_ {\n             mutbl: McImmutable,\n-            ty: self.tcx().types.err,\n+            ty: self.tcx.types.err,\n             ..cmt_result\n         };\n \n@@ -806,7 +831,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn temporary_scope(&self, id: ast::NodeId) -> ty::Region<'tcx>\n     {\n         let scope = self.region_maps.temporary_scope(id);\n-        self.tcx().mk_region(match scope {\n+        self.tcx.mk_region(match scope {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic\n         })\n@@ -817,20 +842,20 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                            span: Span,\n                            expr_ty: Ty<'tcx>)\n                            -> cmt<'tcx> {\n-        let promotable = self.tcx().rvalue_promotable_to_static.borrow().get(&id).cloned()\n+        let promotable = self.tcx.rvalue_promotable_to_static.borrow().get(&id).cloned()\n                                    .unwrap_or(false);\n \n         // When the corresponding feature isn't toggled, only promote `[T; 0]`.\n         let promotable = match expr_ty.sty {\n             ty::TyArray(_, 0) => true,\n-            _ => promotable && self.tcx().sess.features.borrow().rvalue_static_promotion,\n+            _ => promotable && self.tcx.sess.features.borrow().rvalue_static_promotion,\n         };\n \n         // Compute maximum lifetime of this rvalue. This is 'static if\n         // we can promote to a constant, otherwise equal to enclosing temp\n         // lifetime.\n         let re = if promotable {\n-            self.tcx().types.re_static\n+            self.tcx.types.re_static\n         } else {\n             self.temporary_scope(id)\n         };\n@@ -911,7 +936,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 span_bug!(expr.span, \"cat_overloaded_lvalue: base is not a reference\")\n             }\n         };\n-        let ref_ty = self.tcx().mk_ref(region, ty::TypeAndMut {\n+        let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut {\n             ty: lvalue_ty,\n             mutbl,\n         });\n@@ -1098,8 +1123,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     Def::Variant(variant_did) |\n                     Def::VariantCtor(variant_did, ..) => {\n                         // univariant enums do not need downcasts\n-                        let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n-                        if !self.tcx().adt_def(enum_did).is_univariant() {\n+                        let enum_did = self.tcx.parent_def_id(variant_did).unwrap();\n+                        if !self.tcx.adt_def(enum_did).is_univariant() {\n                             self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n                         } else {\n                             cmt\n@@ -1116,8 +1141,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             let def = self.tables.qpath_def(qpath, pat.id);\n             let expected_len = match def {\n                 Def::VariantCtor(def_id, CtorKind::Fn) => {\n-                    let enum_def = self.tcx().parent_def_id(def_id).unwrap();\n-                    self.tcx().adt_def(enum_def).variant_with_id(def_id).fields.len()\n+                    let enum_def = self.tcx.parent_def_id(def_id).unwrap();\n+                    self.tcx.adt_def(enum_def).variant_with_id(def_id).fields.len()\n                 }\n                 Def::StructCtor(_, CtorKind::Fn) => {\n                     match self.pat_ty(&pat)?.sty {"}, {"sha": "ae2be28c198bffa0d02693145f0e2c28fbac598d", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=63481a57dcb4a12501621f5bc915999d4af0e8a0", "patch": "@@ -200,8 +200,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         all_loans: all_loans,\n         param_env,\n     };\n-    let infcx = bccx.tcx.borrowck_fake_infer_ctxt();\n-    euv::ExprUseVisitor::new(&mut clcx, &infcx, param_env, &bccx.region_maps, bccx.tables)\n+    euv::ExprUseVisitor::new(&mut clcx, bccx.tcx, param_env, &bccx.region_maps, bccx.tables)\n         .consume_body(body);\n }\n "}, {"sha": "7dcb6ce76a401618660faaf42f0841824b5f3d61", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=63481a57dcb4a12501621f5bc915999d4af0e8a0", "patch": "@@ -49,8 +49,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     let body = glcx.bccx.tcx.hir.body(body);\n-    let infcx = bccx.tcx.borrowck_fake_infer_ctxt();\n-    euv::ExprUseVisitor::new(&mut glcx, &infcx, param_env, &bccx.region_maps, bccx.tables)\n+    euv::ExprUseVisitor::new(&mut glcx, bccx.tcx, param_env, &bccx.region_maps, bccx.tables)\n         .consume_body(body);\n \n     glcx.report_potential_errors();"}, {"sha": "fcdabf89e3cdd2226e9631cdd457b31f66929f94", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=63481a57dcb4a12501621f5bc915999d4af0e8a0", "patch": "@@ -493,20 +493,18 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n ///\n /// FIXME: this should be done by borrowck.\n fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n-    cx.tcx.infer_ctxt(()).enter(|infcx| {\n-        let mut checker = MutationChecker {\n-            cx: cx,\n-        };\n-        ExprUseVisitor::new(&mut checker, &infcx, cx.param_env, cx.region_maps, cx.tables)\n-            .walk_expr(guard);\n-    });\n+    let mut checker = MutationChecker {\n+        cx: cx,\n+    };\n+    ExprUseVisitor::new(&mut checker, cx.tcx, cx.param_env, cx.region_maps, cx.tables)\n+        .walk_expr(guard);\n }\n \n-struct MutationChecker<'a, 'gcx: 'a> {\n-    cx: &'a MatchVisitor<'a, 'gcx>,\n+struct MutationChecker<'a, 'tcx: 'a> {\n+    cx: &'a MatchVisitor<'a, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n+impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n     fn matched_pat(&mut self, _: &Pat, _: cmt, _: euv::MatchMode) {}\n     fn consume(&mut self, _: ast::NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}"}, {"sha": "e539cc1ae8bf237f9ff503c742569938b03b2789", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=63481a57dcb4a12501621f5bc915999d4af0e8a0", "patch": "@@ -51,7 +51,6 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n use std::collections::hash_map::Entry;\n use std::cmp::Ordering;\n-use std::mem;\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -138,14 +137,14 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             self.check_const_eval(&body.value);\n         }\n \n-        let outer_penv = self.tcx.infer_ctxt(()).enter(|infcx| {\n-            let param_env = self.tcx.param_env(item_def_id);\n-            let outer_penv = mem::replace(&mut self.param_env, param_env);\n-            let region_maps = &self.tcx.region_maps(item_def_id);\n-            euv::ExprUseVisitor::new(self, &infcx, param_env, region_maps, self.tables)\n-                .consume_body(body);\n-            outer_penv\n-        });\n+        let outer_penv = self.param_env;\n+        self.param_env = self.tcx.param_env(item_def_id);\n+\n+        let tcx = self.tcx;\n+        let param_env = self.param_env;\n+        let region_maps = self.tcx.region_maps(item_def_id);\n+        euv::ExprUseVisitor::new(self, tcx, param_env, &region_maps, self.tables)\n+            .consume_body(body);\n \n         self.visit_body(body);\n "}, {"sha": "952321c946bf67475d4a606c5a97139468fa6477", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=63481a57dcb4a12501621f5bc915999d4af0e8a0", "patch": "@@ -828,9 +828,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn with_mc<F, R>(&self, f: F) -> R\n         where F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'gcx, 'tcx>) -> R\n     {\n-        f(mc::MemCategorizationContext::new(&self.infcx,\n-                                            &self.region_maps,\n-                                            &self.tables.borrow()))\n+        f(mc::MemCategorizationContext::with_infer(&self.infcx,\n+                                                   &self.region_maps,\n+                                                   &self.tables.borrow()))\n     }\n \n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being"}, {"sha": "59ca896b347f1fec8428be0758151c1c089a51c8", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63481a57dcb4a12501621f5bc915999d4af0e8a0/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=63481a57dcb4a12501621f5bc915999d4af0e8a0", "patch": "@@ -142,11 +142,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 adjust_closure_kinds: NodeMap(),\n                 adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n             };\n-            euv::ExprUseVisitor::new(&mut delegate,\n-                                     &self.infcx,\n-                                     self.param_env,\n-                                     region_maps,\n-                                     &self.tables.borrow())\n+            euv::ExprUseVisitor::with_infer(&mut delegate,\n+                                            &self.infcx,\n+                                            self.param_env,\n+                                            region_maps,\n+                                            &self.tables.borrow())\n                 .consume_body(body);\n \n             // Write the adjusted values back into the main tables."}]}