{"sha": "0e24ad537be4d47686f3b9e3e6623664bce7cbc2", "node_id": "C_kwDOAAsO6NoAKDBlMjRhZDUzN2JlNGQ0NzY4NmYzYjllM2U2NjIzNjY0YmNlN2NiYzI", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-01-04T13:51:39Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-01-04T13:51:39Z"}, "message": "Implement RFC 3151: Scoped threads.", "tree": {"sha": "aae619d18b17ff9d6867e9e584660fd92a70299c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aae619d18b17ff9d6867e9e584660fd92a70299c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e24ad537be4d47686f3b9e3e6623664bce7cbc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e24ad537be4d47686f3b9e3e6623664bce7cbc2", "html_url": "https://github.com/rust-lang/rust/commit/0e24ad537be4d47686f3b9e3e6623664bce7cbc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e24ad537be4d47686f3b9e3e6623664bce7cbc2/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a45b3ac1836b8d29a2a7b199aed169402aa01805", "url": "https://api.github.com/repos/rust-lang/rust/commits/a45b3ac1836b8d29a2a7b199aed169402aa01805", "html_url": "https://github.com/rust-lang/rust/commit/a45b3ac1836b8d29a2a7b199aed169402aa01805"}], "stats": {"total": 228, "additions": 202, "deletions": 26}, "files": [{"sha": "0125545a3dbd4b4b58af6b3457bea7aab4f5e8a9", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 70, "deletions": 26, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0e24ad537be4d47686f3b9e3e6623664bce7cbc2/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e24ad537be4d47686f3b9e3e6623664bce7cbc2/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=0e24ad537be4d47686f3b9e3e6623664bce7cbc2", "patch": "@@ -180,6 +180,12 @@ use crate::time::Duration;\n #[macro_use]\n mod local;\n \n+#[unstable(feature = \"scoped_threads\", issue = \"none\")]\n+mod scoped;\n+\n+#[unstable(feature = \"scoped_threads\", issue = \"none\")]\n+pub use scoped::{scope, Scope, ScopedJoinHandle};\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::local::{AccessError, LocalKey};\n \n@@ -446,6 +452,20 @@ impl Builder {\n         F: FnOnce() -> T,\n         F: Send + 'a,\n         T: Send + 'a,\n+    {\n+        Ok(JoinHandle(unsafe { self.spawn_unchecked_(f, None) }?))\n+    }\n+\n+    unsafe fn spawn_unchecked_<'a, 'scope, F, T>(\n+        self,\n+        f: F,\n+        scope_data: Option<&'scope scoped::ScopeData>,\n+    ) -> io::Result<JoinInner<'scope, T>>\n+    where\n+        F: FnOnce() -> T,\n+        F: Send + 'a,\n+        T: Send + 'a,\n+        'scope: 'a,\n     {\n         let Builder { name, stack_size } = self;\n \n@@ -456,7 +476,8 @@ impl Builder {\n         }));\n         let their_thread = my_thread.clone();\n \n-        let my_packet: Arc<UnsafeCell<Option<Result<T>>>> = Arc::new(UnsafeCell::new(None));\n+        let my_packet: Arc<Packet<'scope, T>> =\n+            Arc::new(Packet { scope: scope_data, result: UnsafeCell::new(None) });\n         let their_packet = my_packet.clone();\n \n         let output_capture = crate::io::set_output_capture(None);\n@@ -480,10 +501,14 @@ impl Builder {\n             // closure (it is an Arc<...>) and `my_packet` will be stored in the\n             // same `JoinInner` as this closure meaning the mutation will be\n             // safe (not modify it and affect a value far away).\n-            unsafe { *their_packet.get() = Some(try_result) };\n+            unsafe { *their_packet.result.get() = Some(try_result) };\n         };\n \n-        Ok(JoinHandle(JoinInner {\n+        if let Some(scope_data) = scope_data {\n+            scope_data.increment_n_running_threads();\n+        }\n+\n+        Ok(JoinInner {\n             // SAFETY:\n             //\n             // `imp::Thread::new` takes a closure with a `'static` lifetime, since it's passed\n@@ -506,8 +531,8 @@ impl Builder {\n                 )?\n             },\n             thread: my_thread,\n-            packet: Packet(my_packet),\n-        }))\n+            packet: my_packet,\n+        })\n     }\n }\n \n@@ -1239,34 +1264,53 @@ impl fmt::Debug for Thread {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type Result<T> = crate::result::Result<T, Box<dyn Any + Send + 'static>>;\n \n-// This packet is used to communicate the return value between the spawned thread\n-// and the rest of the program. Memory is shared through the `Arc` within and there's\n-// no need for a mutex here because synchronization happens with `join()` (the\n-// caller will never read this packet until the thread has exited).\n+// This packet is used to communicate the return value between the spawned\n+// thread and the rest of the program. It is shared through an `Arc` and\n+// there's no need for a mutex here because synchronization happens with `join()`\n+// (the caller will never read this packet until the thread has exited).\n //\n-// This packet itself is then stored into a `JoinInner` which in turns is placed\n-// in `JoinHandle` and `JoinGuard`. Due to the usage of `UnsafeCell` we need to\n-// manually worry about impls like Send and Sync. The type `T` should\n-// already always be Send (otherwise the thread could not have been created) and\n-// this type is inherently Sync because no methods take &self. Regardless,\n-// however, we add inheriting impls for Send/Sync to this type to ensure it's\n-// Send/Sync and that future modifications will still appropriately classify it.\n-struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n-\n-unsafe impl<T: Send> Send for Packet<T> {}\n-unsafe impl<T: Sync> Sync for Packet<T> {}\n+// An Arc to the packet is stored into a `JoinInner` which in turns is placed\n+// in `JoinHandle`. Due to the usage of `UnsafeCell` we need to manually worry\n+// about impls like Send and Sync. The type `T` should already always be Send\n+// (otherwise the thread could not have been created) and this type is\n+// inherently Sync because no methods take &self. Regardless, however, we add\n+// inheriting impls for Send/Sync to this type to ensure it's Send/Sync and\n+// that future modifications will still appropriately classify it.\n+struct Packet<'scope, T> {\n+    scope: Option<&'scope scoped::ScopeData>,\n+    result: UnsafeCell<Option<Result<T>>>,\n+}\n+\n+unsafe impl<'scope, T: Send> Send for Packet<'scope, T> {}\n+unsafe impl<'scope, T: Sync> Sync for Packet<'scope, T> {}\n+\n+impl<'scope, T> Drop for Packet<'scope, T> {\n+    fn drop(&mut self) {\n+        if let Some(scope) = self.scope {\n+            // If this packet was for a thread that ran in a scope, the thread\n+            // panicked, and nobody consumed the panic payload, we put the\n+            // panic payload in the scope so it can re-throw it, if it didn't\n+            // already capture any panic yet.\n+            if let Some(Err(e)) = self.result.get_mut().take() {\n+                scope.panic_payload.lock().unwrap().get_or_insert(e);\n+            }\n+            // Book-keeping so the scope knows when it's done.\n+            scope.decrement_n_running_threads();\n+        }\n+    }\n+}\n \n /// Inner representation for JoinHandle\n-struct JoinInner<T> {\n+struct JoinInner<'scope, T> {\n     native: imp::Thread,\n     thread: Thread,\n-    packet: Packet<T>,\n+    packet: Arc<Packet<'scope, T>>,\n }\n \n-impl<T> JoinInner<T> {\n+impl<'scope, T> JoinInner<'scope, T> {\n     fn join(mut self) -> Result<T> {\n         self.native.join();\n-        Arc::get_mut(&mut self.packet.0).unwrap().get_mut().take().unwrap()\n+        Arc::get_mut(&mut self.packet).unwrap().result.get_mut().take().unwrap()\n     }\n }\n \n@@ -1333,7 +1377,7 @@ impl<T> JoinInner<T> {\n /// [`thread::Builder::spawn`]: Builder::spawn\n /// [`thread::spawn`]: spawn\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct JoinHandle<T>(JoinInner<T>);\n+pub struct JoinHandle<T>(JoinInner<'static, T>);\n \n #[stable(feature = \"joinhandle_impl_send_sync\", since = \"1.29.0\")]\n unsafe impl<T> Send for JoinHandle<T> {}\n@@ -1407,7 +1451,7 @@ impl<T> JoinHandle<T> {\n     /// function has returned, but before the thread itself has stopped running.\n     #[unstable(feature = \"thread_is_running\", issue = \"90470\")]\n     pub fn is_running(&self) -> bool {\n-        Arc::strong_count(&self.0.packet.0) > 1\n+        Arc::strong_count(&self.0.packet) > 1\n     }\n }\n "}, {"sha": "8e9a43e05bef10abc3f89f8768f9efbe7fa2e95b", "filename": "library/std/src/thread/scoped.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/0e24ad537be4d47686f3b9e3e6623664bce7cbc2/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e24ad537be4d47686f3b9e3e6623664bce7cbc2/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs?ref=0e24ad537be4d47686f3b9e3e6623664bce7cbc2", "patch": "@@ -0,0 +1,132 @@\n+use super::{current, park, Builder, JoinInner, Result, Thread};\n+use crate::any::Any;\n+use crate::fmt;\n+use crate::io;\n+use crate::marker::PhantomData;\n+use crate::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sync::Mutex;\n+\n+/// TODO: documentation\n+pub struct Scope<'env> {\n+    data: ScopeData,\n+    env: PhantomData<&'env ()>,\n+}\n+\n+/// TODO: documentation\n+pub struct ScopedJoinHandle<'scope, T>(JoinInner<'scope, T>);\n+\n+pub(super) struct ScopeData {\n+    n_running_threads: AtomicUsize,\n+    main_thread: Thread,\n+    pub(super) panic_payload: Mutex<Option<Box<dyn Any + Send>>>,\n+}\n+\n+impl ScopeData {\n+    pub(super) fn increment_n_running_threads(&self) {\n+        // We check for 'overflow' with usize::MAX / 2, to make sure there's no\n+        // chance it overflows to 0, which would result in unsoundness.\n+        if self.n_running_threads.fetch_add(1, Ordering::Relaxed) == usize::MAX / 2 {\n+            // This can only reasonably happen by mem::forget()'ing many many ScopedJoinHandles.\n+            self.decrement_n_running_threads();\n+            panic!(\"too many running threads in thread scope\");\n+        }\n+    }\n+    pub(super) fn decrement_n_running_threads(&self) {\n+        if self.n_running_threads.fetch_sub(1, Ordering::Release) == 1 {\n+            self.main_thread.unpark();\n+        }\n+    }\n+}\n+\n+/// TODO: documentation\n+pub fn scope<'env, F, T>(f: F) -> T\n+where\n+    F: FnOnce(&Scope<'env>) -> T,\n+{\n+    let mut scope = Scope {\n+        data: ScopeData {\n+            n_running_threads: AtomicUsize::new(0),\n+            main_thread: current(),\n+            panic_payload: Mutex::new(None),\n+        },\n+        env: PhantomData,\n+    };\n+\n+    // Run `f`, but catch panics so we can make sure to wait for all the threads to join.\n+    let result = catch_unwind(AssertUnwindSafe(|| f(&scope)));\n+\n+    // Wait until all the threads are finished.\n+    while scope.data.n_running_threads.load(Ordering::Acquire) != 0 {\n+        park();\n+    }\n+\n+    // Throw any panic from `f` or from any panicked thread, or the return value of `f` otherwise.\n+    match result {\n+        Err(e) => {\n+            // `f` itself panicked.\n+            resume_unwind(e);\n+        }\n+        Ok(result) => {\n+            if let Some(panic_payload) = scope.data.panic_payload.get_mut().unwrap().take() {\n+                // A thread panicked.\n+                resume_unwind(panic_payload);\n+            } else {\n+                // Nothing panicked.\n+                result\n+            }\n+        }\n+    }\n+}\n+\n+impl<'env> Scope<'env> {\n+    /// TODO: documentation\n+    pub fn spawn<'scope, F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>\n+    where\n+        F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n+        T: Send + 'env,\n+    {\n+        Builder::new().spawn_scoped(self, f).expect(\"failed to spawn thread\")\n+    }\n+}\n+\n+impl Builder {\n+    fn spawn_scoped<'scope, 'env, F, T>(\n+        self,\n+        scope: &'scope Scope<'env>,\n+        f: F,\n+    ) -> io::Result<ScopedJoinHandle<'scope, T>>\n+    where\n+        F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n+        T: Send + 'env,\n+    {\n+        Ok(ScopedJoinHandle(unsafe { self.spawn_unchecked_(|| f(scope), Some(&scope.data)) }?))\n+    }\n+}\n+\n+impl<'scope, T> ScopedJoinHandle<'scope, T> {\n+    /// TODO\n+    pub fn join(self) -> Result<T> {\n+        self.0.join()\n+    }\n+\n+    /// TODO\n+    pub fn thread(&self) -> &Thread {\n+        &self.0.thread\n+    }\n+}\n+\n+impl<'env> fmt::Debug for Scope<'env> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Scope\")\n+            .field(\"n_running_threads\", &self.data.n_running_threads.load(Ordering::Relaxed))\n+            .field(\"panic_payload\", &self.data.panic_payload)\n+            .finish_non_exhaustive()\n+    }\n+}\n+\n+impl<'scope, T> fmt::Debug for ScopedJoinHandle<'scope, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"ScopedJoinHandle\").finish_non_exhaustive()\n+    }\n+}"}]}