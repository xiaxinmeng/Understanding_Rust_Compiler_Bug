{"sha": "a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYTM1NTc2ZWI3MDhlMGJjMDRhNDczMTNiZmRmM2ZmOGFlYzliYzk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-16T08:16:23Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-09-20T06:31:16Z"}, "message": "Make with_hir_id_owner responsible for registering the item.", "tree": {"sha": "5dcd090b7138ca94a27ac96c032ad615e8056837", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dcd090b7138ca94a27ac96c032ad615e8056837"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9", "html_url": "https://github.com/rust-lang/rust/commit/a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1bac9229ab93d1582b3974095e55fa56581b93b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1bac9229ab93d1582b3974095e55fa56581b93b", "html_url": "https://github.com/rust-lang/rust/commit/c1bac9229ab93d1582b3974095e55fa56581b93b"}], "stats": {"total": 231, "additions": 91, "deletions": 140}, "files": [{"sha": "a6ea4aa8923cfad252d7a96bdb11359f5c8256d3", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9", "patch": "@@ -327,7 +327,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let mut generic_args = vec![];\n         for (idx, arg) in args.into_iter().enumerate() {\n             if legacy_args_idx.contains(&idx) {\n-                let parent_def_id = self.current_hir_id_owner.0;\n+                let parent_def_id = self.current_hir_id_owner;\n                 let node_id = self.resolver.next_node_id();\n \n                 // Add a definition for the in-band const def."}, {"sha": "25e6fed68b566fcf5192cd88d81ea488d9a7fa5e", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9", "patch": "@@ -40,12 +40,9 @@ impl ItemLowerer<'_, '_, '_> {\n \n impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     fn visit_item(&mut self, item: &'a Item) {\n-        self.lctx.allocate_hir_id_counter(item.id);\n         let hir_id = self.lctx.with_hir_id_owner(item.id, |lctx| {\n-            lctx.without_in_scope_lifetime_defs(|lctx| {\n-                let hir_item = lctx.lower_item(item);\n-                lctx.insert_item(hir_item)\n-            })\n+            let node = lctx.without_in_scope_lifetime_defs(|lctx| lctx.lower_item(item));\n+            hir::OwnerNode::Item(node)\n         });\n \n         self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n@@ -72,26 +69,17 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n-        self.lctx.allocate_hir_id_counter(item.id);\n         self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n-            AssocCtxt::Trait => {\n-                let hir_item = lctx.lower_trait_item(item);\n-                lctx.insert_trait_item(hir_item);\n-            }\n-            AssocCtxt::Impl => {\n-                let hir_item = lctx.lower_impl_item(item);\n-                lctx.insert_impl_item(hir_item);\n-            }\n+            AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n+            AssocCtxt::Impl => hir::OwnerNode::ImplItem(lctx.lower_impl_item(item)),\n         });\n \n         visit::walk_assoc_item(self, item, ctxt);\n     }\n \n     fn visit_foreign_item(&mut self, item: &'a ForeignItem) {\n-        self.lctx.allocate_hir_id_counter(item.id);\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n-            let hir_item = lctx.lower_foreign_item(item);\n-            lctx.insert_foreign_item(hir_item);\n+            hir::OwnerNode::ForeignItem(lctx.lower_foreign_item(item))\n         });\n \n         visit::walk_foreign_item(self, item);\n@@ -106,12 +94,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     // only used when lowering a child item of a trait or impl.\n     fn with_parent_item_lifetime_defs<T>(\n         &mut self,\n-        parent_hir_id: hir::ItemId,\n+        parent_hir_id: LocalDefId,\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n \n-        let parent_generics = match self.owners[parent_hir_id.def_id].unwrap().expect_item().kind {\n+        let parent_generics = match self.owners[parent_hir_id].unwrap().expect_item().kind {\n             hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n             _ => &[],\n@@ -186,19 +174,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    pub fn lower_item(&mut self, i: &Item) -> hir::Item<'hir> {\n+    fn lower_item(&mut self, i: &Item) -> &'hir hir::Item<'hir> {\n         let mut ident = i.ident;\n         let mut vis = self.lower_visibility(&i.vis);\n         let hir_id = self.lower_node_id(i.id);\n         let attrs = self.lower_attrs(hir_id, &i.attrs);\n         let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, &mut vis, &i.kind);\n-        hir::Item {\n+        let item = hir::Item {\n             def_id: hir_id.expect_owner(),\n             ident: self.lower_ident(ident),\n             kind,\n             vis,\n             span: self.lower_span(i.span),\n-        }\n+        };\n+        self.arena.alloc(item)\n     }\n \n     fn lower_item_kind(\n@@ -480,10 +469,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Essentially a single `use` which imports two names is desugared into\n                 // two imports.\n                 for new_node_id in [id1, id2] {\n-                    // Associate an HirId to both ids even if there is no resolution.\n-                    let new_id = self.allocate_hir_id_counter(new_node_id);\n-\n-                    let res = if let Some(res) = resolutions.next() { res } else { continue };\n+                    let new_id = self.resolver.local_def_id(new_node_id);\n+                    let res = if let Some(res) = resolutions.next() {\n+                        res\n+                    } else {\n+                        // Associate an HirId to both ids even if there is no resolution.\n+                        self.node_id_to_hir_id.ensure_contains_elem(new_node_id, || None);\n+                        debug_assert!(self.node_id_to_hir_id[new_node_id].is_none());\n+                        self.node_id_to_hir_id[new_node_id] = Some(hir::HirId::make_owner(new_id));\n+                        continue;\n+                    };\n                     let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n@@ -500,13 +495,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             this.attrs.insert(hir::HirId::make_owner(new_id), attrs);\n                         }\n \n-                        this.insert_item(hir::Item {\n+                        let item = hir::Item {\n                             def_id: new_id,\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis,\n                             span: this.lower_span(span),\n-                        });\n+                        };\n+                        hir::OwnerNode::Item(this.arena.alloc(item))\n                     });\n                 }\n \n@@ -550,7 +546,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 // Add all the nested `PathListItem`s to the HIR.\n                 for &(ref use_tree, id) in trees {\n-                    let new_hir_id = self.allocate_hir_id_counter(id);\n+                    let new_hir_id = self.resolver.local_def_id(id);\n \n                     let mut prefix = prefix.clone();\n \n@@ -574,13 +570,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             this.attrs.insert(hir::HirId::make_owner(new_hir_id), attrs);\n                         }\n \n-                        this.insert_item(hir::Item {\n+                        let item = hir::Item {\n                             def_id: new_hir_id,\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis,\n                             span: this.lower_span(use_tree.span),\n-                        });\n+                        };\n+                        hir::OwnerNode::Item(this.arena.alloc(item))\n                     });\n                 }\n \n@@ -647,11 +644,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         respan(self.lower_span(vis.span), vis_kind)\n     }\n \n-    fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem<'hir> {\n+    fn lower_foreign_item(&mut self, i: &ForeignItem) -> &'hir hir::ForeignItem<'hir> {\n         let hir_id = self.lower_node_id(i.id);\n         let def_id = hir_id.expect_owner();\n         self.lower_attrs(hir_id, &i.attrs);\n-        hir::ForeignItem {\n+        let item = hir::ForeignItem {\n             def_id,\n             ident: self.lower_ident(i.ident),\n             kind: match i.kind {\n@@ -681,12 +678,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             },\n             vis: self.lower_visibility(&i.vis),\n             span: self.lower_span(i.span),\n-        }\n+        };\n+        self.arena.alloc(item)\n     }\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { def_id: self.allocate_hir_id_counter(i.id) },\n+            id: hir::ForeignItemId { def_id: self.resolver.local_def_id(i.id) },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n         }\n@@ -761,7 +759,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn lower_trait_item(&mut self, i: &AssocItem) -> hir::TraitItem<'hir> {\n+    fn lower_trait_item(&mut self, i: &AssocItem) -> &'hir hir::TraitItem<'hir> {\n         let hir_id = self.lower_node_id(i.id);\n         let trait_item_def_id = hir_id.expect_owner();\n \n@@ -804,13 +802,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         self.lower_attrs(hir_id, &i.attrs);\n-        hir::TraitItem {\n+        let item = hir::TraitItem {\n             def_id: trait_item_def_id,\n             ident: self.lower_ident(i.ident),\n             generics,\n             kind,\n             span: self.lower_span(i.span),\n-        }\n+        };\n+        self.arena.alloc(item)\n     }\n \n     fn lower_trait_item_ref(&mut self, i: &AssocItem) -> hir::TraitItemRef {\n@@ -840,7 +839,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.expr(span, hir::ExprKind::Err, AttrVec::new())\n     }\n \n-    fn lower_impl_item(&mut self, i: &AssocItem) -> hir::ImplItem<'hir> {\n+    fn lower_impl_item(&mut self, i: &AssocItem) -> &'hir hir::ImplItem<'hir> {\n         let impl_item_def_id = self.resolver.local_def_id(i.id);\n \n         let (generics, kind) = match &i.kind {\n@@ -894,23 +893,24 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n         let hir_id = self.lower_node_id(i.id);\n         self.lower_attrs(hir_id, &i.attrs);\n-        hir::ImplItem {\n+        let item = hir::ImplItem {\n             def_id: hir_id.expect_owner(),\n             ident: self.lower_ident(i.ident),\n             generics,\n             vis: self.lower_visibility(&i.vis),\n             defaultness,\n             kind,\n             span: self.lower_span(i.span),\n-        }\n+        };\n+        self.arena.alloc(item)\n     }\n \n     fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef {\n         // Since `default impl` is not yet implemented, this is always true in impls.\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { def_id: self.allocate_hir_id_counter(i.id) },\n+            id: hir::ImplItemId { def_id: self.resolver.local_def_id(i.id) },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n             defaultness,"}, {"sha": "5ec060f654090b5297dbafac9ae91fe14617acf7", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 48, "deletions": 97, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=a1a35576eb708e0bc04a47313bfdf3ff8aec9bc9", "patch": "@@ -148,8 +148,8 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// vector.\n     in_scope_lifetimes: Vec<ParamName>,\n \n-    current_hir_id_owner: (LocalDefId, u32),\n-    item_local_id_counters: IndexVec<LocalDefId, u32>,\n+    current_hir_id_owner: LocalDefId,\n+    item_local_id_counter: hir::ItemLocalId,\n     node_id_to_hir_id: IndexVec<NodeId, Option<hir::HirId>>,\n \n     allow_try_trait: Option<Lrc<[Symbol]>>,\n@@ -328,8 +328,8 @@ pub fn lower_crate<'a, 'hir>(\n         is_in_trait_impl: false,\n         is_in_dyn_type: false,\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n-        current_hir_id_owner: (CRATE_DEF_ID, 0),\n-        item_local_id_counters: Default::default(),\n+        current_hir_id_owner: CRATE_DEF_ID,\n+        item_local_id_counter: hir::ItemLocalId::new(0),\n         node_id_to_hir_id: IndexVec::new(),\n         generator_kind: None,\n         task_context: None,\n@@ -410,15 +410,15 @@ enum AnonymousLifetimeMode {\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_crate(mut self, c: &Crate) -> &'hir hir::Crate<'hir> {\n-        self.lower_node_id(CRATE_NODE_ID);\n-        debug_assert!(self.node_id_to_hir_id[CRATE_NODE_ID] == Some(hir::CRATE_HIR_ID));\n+        debug_assert_eq!(self.resolver.local_def_id(CRATE_NODE_ID), CRATE_DEF_ID);\n \n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n-        let module = self.arena.alloc(self.lower_mod(&c.items, c.span));\n-        self.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n-        self.owners.ensure_contains_elem(CRATE_DEF_ID, || None);\n-        self.owners[CRATE_DEF_ID] = Some(hir::OwnerNode::Crate(module));\n+        self.with_hir_id_owner(CRATE_NODE_ID, |lctx| {\n+            let module = lctx.lower_mod(&c.items, c.span);\n+            lctx.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n+            hir::OwnerNode::Crate(lctx.arena.alloc(module))\n+        });\n \n         let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n         for (k, v) in self.resolver.take_trait_map().into_iter() {\n@@ -454,83 +454,40 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.arena.alloc(krate)\n     }\n \n-    fn insert_item(&mut self, item: hir::Item<'hir>) -> hir::ItemId {\n-        let id = item.item_id();\n-        let item = self.arena.alloc(item);\n-        self.owners.ensure_contains_elem(id.def_id, || None);\n-        self.owners[id.def_id] = Some(hir::OwnerNode::Item(item));\n-        id\n-    }\n-\n-    fn insert_foreign_item(&mut self, item: hir::ForeignItem<'hir>) -> hir::ForeignItemId {\n-        let id = item.foreign_item_id();\n-        let item = self.arena.alloc(item);\n-        self.owners.ensure_contains_elem(id.def_id, || None);\n-        self.owners[id.def_id] = Some(hir::OwnerNode::ForeignItem(item));\n-        id\n-    }\n-\n-    fn insert_impl_item(&mut self, item: hir::ImplItem<'hir>) -> hir::ImplItemId {\n-        let id = item.impl_item_id();\n-        let item = self.arena.alloc(item);\n-        self.owners.ensure_contains_elem(id.def_id, || None);\n-        self.owners[id.def_id] = Some(hir::OwnerNode::ImplItem(item));\n-        id\n-    }\n-\n-    fn insert_trait_item(&mut self, item: hir::TraitItem<'hir>) -> hir::TraitItemId {\n-        let id = item.trait_item_id();\n-        let item = self.arena.alloc(item);\n-        self.owners.ensure_contains_elem(id.def_id, || None);\n-        self.owners[id.def_id] = Some(hir::OwnerNode::TraitItem(item));\n-        id\n-    }\n-\n     fn create_stable_hashing_context(&self) -> LoweringHasher<'_> {\n         LoweringHasher {\n             source_map: CachingSourceMapView::new(self.sess.source_map()),\n             resolver: self.resolver,\n         }\n     }\n \n-    fn allocate_hir_id_counter(&mut self, owner: NodeId) -> LocalDefId {\n-        // Set up the counter if needed.\n+    fn with_hir_id_owner(\n+        &mut self,\n+        owner: NodeId,\n+        f: impl FnOnce(&mut Self) -> hir::OwnerNode<'hir>,\n+    ) -> LocalDefId {\n         let def_id = self.resolver.local_def_id(owner);\n \n         // Always allocate the first `HirId` for the owner itself.\n         self.node_id_to_hir_id.ensure_contains_elem(owner, || None);\n         if let Some(_lowered) = self.node_id_to_hir_id[owner] {\n-            debug_assert_eq!(_lowered.owner, def_id);\n-            debug_assert_eq!(_lowered.local_id.as_u32(), 0);\n-        } else {\n-            self.item_local_id_counters.ensure_contains_elem(def_id, || 0);\n-            let local_id_counter = &mut self.item_local_id_counters[def_id];\n-            let local_id = *local_id_counter;\n+            panic!(\"with_hir_id_owner must not be called multiple times on owner {:?}\", def_id);\n+        }\n+        self.node_id_to_hir_id[owner] = Some(hir::HirId::make_owner(def_id));\n \n-            // We want to be sure not to modify the counter in the map while it\n-            // is also on the stack. Otherwise we'll get lost updates when writing\n-            // back from the stack to the map.\n-            debug_assert_eq!(local_id, 0);\n+        let current_owner = std::mem::replace(&mut self.current_hir_id_owner, def_id);\n+        let current_local_counter =\n+            std::mem::replace(&mut self.item_local_id_counter, hir::ItemLocalId::new(1));\n \n-            *local_id_counter += 1;\n-            self.node_id_to_hir_id[owner] = Some(hir::HirId::make_owner(def_id));\n-        }\n-        def_id\n-    }\n+        let item = f(self);\n \n-    fn with_hir_id_owner<T>(&mut self, owner: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let def_id = self.resolver.local_def_id(owner);\n-        let counter = self.item_local_id_counters[def_id];\n-        let old_owner = std::mem::replace(&mut self.current_hir_id_owner, (def_id, counter));\n-        let ret = f(self);\n-        let (new_def_id, new_counter) =\n-            std::mem::replace(&mut self.current_hir_id_owner, old_owner);\n+        self.current_hir_id_owner = current_owner;\n+        self.item_local_id_counter = current_local_counter;\n \n-        debug_assert!(def_id == new_def_id);\n-        debug_assert!(new_counter >= counter);\n+        self.owners.ensure_contains_elem(def_id, || None);\n+        self.owners[def_id] = Some(item);\n \n-        self.item_local_id_counters[def_id] = new_counter;\n-        ret\n+        def_id\n     }\n \n     /// This method allocates a new `HirId` for the given `NodeId` and stores it in\n@@ -547,10 +504,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             existing_hir_id\n         } else {\n             // Generate a new `HirId`.\n-            let &mut (owner, ref mut local_id_counter) = &mut self.current_hir_id_owner;\n-            let local_id = *local_id_counter;\n-            *local_id_counter += 1;\n-            let hir_id = hir::HirId { owner, local_id: hir::ItemLocalId::from_u32(local_id) };\n+            let owner = self.current_hir_id_owner;\n+            let local_id = self.item_local_id_counter;\n+            self.item_local_id_counter.increment_by(1);\n+            let hir_id = hir::HirId { owner, local_id };\n             self.node_id_to_hir_id[ast_node_id] = Some(hir_id);\n             hir_id\n         }\n@@ -626,7 +583,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Mark a span as relative to the current owning item.\n     fn lower_span(&self, span: Span) -> Span {\n         if self.sess.opts.debugging_opts.incremental_relative_spans {\n-            span.with_parent(Some(self.current_hir_id_owner.0))\n+            span.with_parent(Some(self.current_hir_id_owner))\n         } else {\n             // Do not make spans relative when not using incremental compilation.\n             span\n@@ -799,7 +756,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // wouldn't have been added yet.\n                     let generics = this.lower_generics_mut(\n                         generics,\n-                        ImplTraitContext::Universal(&mut params, this.current_hir_id_owner.0),\n+                        ImplTraitContext::Universal(&mut params, this.current_hir_id_owner),\n                     );\n                     let res = f(this, &mut params);\n                     (params, (generics, res))\n@@ -1005,7 +962,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             AssocTyConstraintKind::Bound { ref bounds } => {\n                 let mut capturable_lifetimes;\n-                let mut parent_def_id = self.current_hir_id_owner.0;\n+                let mut parent_def_id = self.current_hir_id_owner;\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n                     // We are in the return position:\n@@ -1133,7 +1090,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                                 // Construct an AnonConst where the expr is the \"ty\"'s path.\n \n-                                let parent_def_id = self.current_hir_id_owner.0;\n+                                let parent_def_id = self.current_hir_id_owner;\n                                 let node_id = self.resolver.next_node_id();\n \n                                 // Add a definition for the in-band const def.\n@@ -1399,12 +1356,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // frequently opened issues show.\n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n-        let opaque_ty_def_id = self.allocate_hir_id_counter(opaque_ty_node_id);\n+        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n \n-        let collected_lifetimes = self.with_hir_id_owner(opaque_ty_node_id, move |lctx| {\n+        let mut collected_lifetimes = Vec::new();\n+        self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n             let hir_bounds = lower_bounds(lctx);\n \n-            let collected_lifetimes = lifetimes_from_impl_trait_bounds(\n+            collected_lifetimes = lifetimes_from_impl_trait_bounds(\n                 opaque_ty_node_id,\n                 &hir_bounds,\n                 capturable_lifetimes,\n@@ -1457,9 +1415,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             };\n \n             trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_id);\n-            lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span);\n-\n-            collected_lifetimes\n+            lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n         });\n \n         let lifetimes =\n@@ -1481,7 +1437,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         opaque_ty_item: hir::OpaqueTy<'hir>,\n         span: Span,\n         opaque_ty_span: Span,\n-    ) {\n+    ) -> hir::OwnerNode<'hir> {\n         let opaque_ty_item_kind = hir::ItemKind::OpaqueTy(opaque_ty_item);\n         // Generate an `type Foo = impl Trait;` declaration.\n         trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n@@ -1492,11 +1448,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             vis: respan(self.lower_span(span.shrink_to_lo()), hir::VisibilityKind::Inherited),\n             span: self.lower_span(opaque_ty_span),\n         };\n-\n-        // Insert the item into the global item list. This usually happens\n-        // automatically for all AST items. But this opaque type item\n-        // does not actually exist in the AST.\n-        self.insert_item(opaque_ty_item);\n+        hir::OwnerNode::Item(self.arena.alloc(opaque_ty_item))\n     }\n \n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> &'hir [Ident] {\n@@ -1565,7 +1517,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 if let Some((_, ibty)) = &mut in_band_ty_params {\n                     this.lower_ty_direct(\n                         &param.ty,\n-                        ImplTraitContext::Universal(ibty, this.current_hir_id_owner.0),\n+                        ImplTraitContext::Universal(ibty, this.current_hir_id_owner),\n                     )\n                 } else {\n                     this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n@@ -1656,7 +1608,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-        let opaque_ty_def_id = self.allocate_hir_id_counter(opaque_ty_node_id);\n+        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n \n         // When we create the opaque type for this async fn, it is going to have\n         // to capture all the lifetimes involved in the signature (including in the\n@@ -1706,7 +1658,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // grow.\n         let input_lifetimes_count = self.in_scope_lifetimes.len() + self.lifetimes_to_define.len();\n \n-        let lifetime_params = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n+        let mut lifetime_params = Vec::new();\n+        self.with_hir_id_owner(opaque_ty_node_id, |this| {\n             // We have to be careful to get elision right here. The\n             // idea is that we create a lifetime parameter for each\n             // lifetime in the return type.  So, given a return type\n@@ -1728,7 +1681,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             //\n             // Note: this must be done after lowering the output type,\n             // as the output type may introduce new in-band lifetimes.\n-            let lifetime_params: Vec<(Span, ParamName)> = this\n+            lifetime_params = this\n                 .in_scope_lifetimes\n                 .iter()\n                 .cloned()\n@@ -1757,9 +1710,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             };\n \n             trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n-            this.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span);\n-\n-            lifetime_params\n+            this.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n         });\n \n         // As documented above on the variable"}]}