{"sha": "8c703643ad0bb1c70c249dc16b5a32e253815be1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNzAzNjQzYWQwYmIxYzcwYzI0OWRjMTZiNWEzMmUyNTM4MTViZTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-22T22:24:09Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T23:54:36Z"}, "message": "librustc: De-`@mut` the reachability worklist", "tree": {"sha": "52d10d7f8d4d18990da62e828b2cd22c8018471a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52d10d7f8d4d18990da62e828b2cd22c8018471a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c703643ad0bb1c70c249dc16b5a32e253815be1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c703643ad0bb1c70c249dc16b5a32e253815be1", "html_url": "https://github.com/rust-lang/rust/commit/8c703643ad0bb1c70c249dc16b5a32e253815be1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c703643ad0bb1c70c249dc16b5a32e253815be1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b4ff2cf8b5f888581d41b3b2f10dacf7d716478", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b4ff2cf8b5f888581d41b3b2f10dacf7d716478", "html_url": "https://github.com/rust-lang/rust/commit/4b4ff2cf8b5f888581d41b3b2f10dacf7d716478"}], "stats": {"total": 41, "additions": 29, "deletions": 12}, "files": [{"sha": "958fd20dfca3983971f70544afec09c049217262", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8c703643ad0bb1c70c249dc16b5a32e253815be1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c703643ad0bb1c70c249dc16b5a32e253815be1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=8c703643ad0bb1c70c249dc16b5a32e253815be1", "patch": "@@ -88,11 +88,11 @@ struct ReachableContext {\n     reachable_symbols: @RefCell<HashSet<ast::NodeId>>,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: @mut ~[ast::NodeId],\n+    worklist: @RefCell<~[ast::NodeId]>,\n }\n \n struct MarkSymbolVisitor {\n-    worklist: @mut ~[ast::NodeId],\n+    worklist: @RefCell<~[ast::NodeId]>,\n     method_map: typeck::method_map,\n     tcx: ty::ctxt,\n     reachable_symbols: @RefCell<HashSet<ast::NodeId>>,\n@@ -116,15 +116,19 @@ impl Visitor<()> for MarkSymbolVisitor {\n                 if is_local(def_id) {\n                     if ReachableContext::\n                         def_id_represents_local_inlined_item(self.tcx, def_id) {\n-                            self.worklist.push(def_id.node)\n+                            {\n+                                let mut worklist = self.worklist.borrow_mut();\n+                                worklist.get().push(def_id.node)\n+                            }\n                     } else {\n                         match def {\n                             // If this path leads to a static, then we may have\n                             // to do some work to figure out whether the static\n                             // is indeed reachable (address_insignificant\n                             // statics are *never* reachable).\n                             ast::DefStatic(..) => {\n-                                self.worklist.push(def_id.node);\n+                                let mut worklist = self.worklist.borrow_mut();\n+                                worklist.get().push(def_id.node);\n                             }\n \n                             // If this wasn't a static, then this destination is\n@@ -150,7 +154,11 @@ impl Visitor<()> for MarkSymbolVisitor {\n                                 def_id_represents_local_inlined_item(\n                                     self.tcx,\n                                     def_id) {\n-                                self.worklist.push(def_id.node)\n+                                {\n+                                    let mut worklist = self.worklist\n+                                                           .borrow_mut();\n+                                    worklist.get().push(def_id.node)\n+                                }\n                             }\n                             {\n                                 let mut reachable_symbols =\n@@ -186,7 +194,7 @@ impl ReachableContext {\n             tcx: tcx,\n             method_map: method_map,\n             reachable_symbols: @RefCell::new(HashSet::new()),\n-            worklist: @mut ~[],\n+            worklist: @RefCell::new(~[]),\n         }\n     }\n \n@@ -265,11 +273,19 @@ impl ReachableContext {\n     fn propagate(&self) {\n         let mut visitor = self.init_visitor();\n         let mut scanned = HashSet::new();\n-        while self.worklist.len() > 0 {\n-            let search_item = self.worklist.pop();\n-            if scanned.contains(&search_item) {\n-                continue\n-            }\n+        loop {\n+            let search_item = {\n+                let mut worklist = self.worklist.borrow_mut();\n+                if worklist.get().len() == 0 {\n+                    break\n+                }\n+                let search_item = worklist.get().pop();\n+                if scanned.contains(&search_item) {\n+                    continue\n+                }\n+                search_item\n+            };\n+\n             scanned.insert(search_item);\n             match self.tcx.items.find(&search_item) {\n                 Some(item) => self.propagate_node(item, search_item,\n@@ -407,7 +423,8 @@ pub fn find_reachable(tcx: ty::ctxt,\n     // Step 1: Seed the worklist with all nodes which were found to be public as\n     //         a result of the privacy pass\n     for &id in exported_items.iter() {\n-        reachable_context.worklist.push(id);\n+        let mut worklist = reachable_context.worklist.borrow_mut();\n+        worklist.get().push(id);\n     }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch."}]}