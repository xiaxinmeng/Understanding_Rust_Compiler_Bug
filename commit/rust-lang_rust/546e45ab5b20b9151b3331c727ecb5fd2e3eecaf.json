{"sha": "546e45ab5b20b9151b3331c727ecb5fd2e3eecaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NmU0NWFiNWIyMGI5MTUxYjMzMzFjNzI3ZWNiNWZkMmUzZWVjYWY=", "commit": {"author": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-08-19T13:51:35Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-29T07:50:51Z"}, "message": "add MaybeUninit", "tree": {"sha": "795f2a0619d0dc5fe1715d666a6fca935d852369", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/795f2a0619d0dc5fe1715d666a6fca935d852369"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/546e45ab5b20b9151b3331c727ecb5fd2e3eecaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/546e45ab5b20b9151b3331c727ecb5fd2e3eecaf", "html_url": "https://github.com/rust-lang/rust/commit/546e45ab5b20b9151b3331c727ecb5fd2e3eecaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/546e45ab5b20b9151b3331c727ecb5fd2e3eecaf/comments", "author": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e37d6d37e76a8b2f82eacc8c3f642c4d47093950", "url": "https://api.github.com/repos/rust-lang/rust/commits/e37d6d37e76a8b2f82eacc8c3f642c4d47093950", "html_url": "https://github.com/rust-lang/rust/commit/e37d6d37e76a8b2f82eacc8c3f642c4d47093950"}], "stats": {"total": 96, "additions": 96, "deletions": 0}, "files": [{"sha": "c99c9f96f12d67d712b0fef3a413440d57e67245", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/546e45ab5b20b9151b3331c727ecb5fd2e3eecaf/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/546e45ab5b20b9151b3331c727ecb5fd2e3eecaf/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=546e45ab5b20b9151b3331c727ecb5fd2e3eecaf", "patch": "@@ -514,6 +514,7 @@ pub fn needs_drop<T>() -> bool {\n /// assert_eq!(0, x);\n /// ```\n #[inline]\n+#[rustc_deprecated(since = \"2.0.0\", reason = \"use `mem::MaybeUninit::zeroed` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n@@ -608,6 +609,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n /// [`Drop`]: ../ops/trait.Drop.html\n #[inline]\n+#[rustc_deprecated(since = \"2.0.0\", reason = \"use `mem::MaybeUninit::uninitialized` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n@@ -1024,3 +1026,97 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n         &mut self.value\n     }\n }\n+\n+/// A newtype to construct uninitialized instances of `T`\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+// NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::{uninitialized,zeroed}`\n+pub union MaybeUninit<T> {\n+    uninit: (),\n+    value: ManuallyDrop<T>,\n+}\n+\n+impl<T> MaybeUninit<T> {\n+    /// Create a new `MaybeUninit` in an uninitialized state.\n+    ///\n+    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub const fn uninitialized() -> MaybeUninit<T> {\n+        MaybeUninit { uninit: () }\n+    }\n+\n+    /// Create a new `MaybeUninit` in an uninitialized state, with the memory being\n+    /// filled with `0` bytes.  It depends on `T` whether that already makes for\n+    /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n+    /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n+    /// be null.\n+    ///\n+    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub fn zeroed() -> MaybeUninit<T> {\n+        let mut u = MaybeUninit::<T>::uninitialized();\n+        unsafe {\n+            u.as_mut_ptr().write_bytes(0u8, 1);\n+        }\n+        u\n+    }\n+\n+    /// Set the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub fn set(&mut self, val: T) {\n+        unsafe {\n+            self.value = ManuallyDrop::new(val);\n+        }\n+    }\n+\n+    /// Extract the value from the `MaybeUninit` container.  This is a great way\n+    /// to ensure that the data will get dropped, because the resulting `T` is\n+    /// subject to the usual drop handling.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// state, otherwise this will immediately cause undefined behavior.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub unsafe fn into_inner(self) -> T {\n+        ManuallyDrop::into_inner(self.value)\n+    }\n+\n+    /// Get a reference to the contained value.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// state, otherwise this will immediately cause undefined behavior.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub unsafe fn get_ref(&self) -> &T {\n+        &*self.value\n+    }\n+\n+    /// Get a mutable reference to the contained value.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// state, otherwise this will immediately cause undefined behavior.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub unsafe fn get_mut(&mut self) -> &mut T {\n+        &mut *self.value\n+    }\n+\n+    /// Get a pointer to the contained value. Reading from this pointer will be undefined\n+    /// behavior unless the `MaybeUninit` is initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub fn as_ptr(&self) -> *const T {\n+        unsafe { &*self.value as *const T }\n+    }\n+\n+    /// Get a mutable pointer to the contained value. Reading from this pointer will be undefined\n+    /// behavior unless the `MaybeUninit` is initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        unsafe { &mut *self.value as *mut T }\n+    }\n+}"}]}