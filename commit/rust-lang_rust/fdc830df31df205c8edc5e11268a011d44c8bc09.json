{"sha": "fdc830df31df205c8edc5e11268a011d44c8bc09", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkYzgzMGRmMzFkZjIwNWM4ZWRjNWUxMTI2OGEwMTFkNDRjOGJjMDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-06T19:51:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-06T19:51:09Z"}, "message": "auto merge of #10289 : nikomatsakis/rust/issue-10157-TypeContents-refactor, r=pcwalton\n\nSee #10157. This compiles now.\r\n\r\nFixes #10278.", "tree": {"sha": "cb69b6802c38077ea53b53e03e62066738d94fc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb69b6802c38077ea53b53e03e62066738d94fc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdc830df31df205c8edc5e11268a011d44c8bc09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdc830df31df205c8edc5e11268a011d44c8bc09", "html_url": "https://github.com/rust-lang/rust/commit/fdc830df31df205c8edc5e11268a011d44c8bc09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdc830df31df205c8edc5e11268a011d44c8bc09/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dda67dfe27b261babd48a91b1eec1f5f32890d28", "url": "https://api.github.com/repos/rust-lang/rust/commits/dda67dfe27b261babd48a91b1eec1f5f32890d28", "html_url": "https://github.com/rust-lang/rust/commit/dda67dfe27b261babd48a91b1eec1f5f32890d28"}, {"sha": "71acc543ca0858a064c4bed848b507325c383939", "url": "https://api.github.com/repos/rust-lang/rust/commits/71acc543ca0858a064c4bed848b507325c383939", "html_url": "https://github.com/rust-lang/rust/commit/71acc543ca0858a064c4bed848b507325c383939"}], "stats": {"total": 684, "additions": 404, "deletions": 280}, "files": [{"sha": "9bafea6d861be50987060cdb11b15c6402fc7699", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -1600,7 +1600,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n         let pat_ty = node_id_type(bcx, pat_id);\n         let llbox = Load(bcx, val);\n         let unboxed = match ty::get(pat_ty).sty {\n-            ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).contains_managed() => llbox,\n+            ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).owns_managed() => llbox,\n             _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n         };\n         compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n@@ -2220,7 +2220,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n             let pat_ty = node_id_type(bcx, pat.id);\n             let llbox = Load(bcx, val);\n             let unboxed = match ty::get(pat_ty).sty {\n-                ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).contains_managed() => llbox,\n+                ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).owns_managed() => llbox,\n                     _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n             };\n             bcx = bind_irrefutable_pat(bcx, inner, unboxed, binding_mode);"}, {"sha": "37e4d4e82be51fde768c59cd7d311caa8a8a1117", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -409,7 +409,7 @@ pub fn malloc_general(bcx: @mut Block, t: ty::t, heap: heap) -> MallocResult {\n }\n \n pub fn heap_for_unique(bcx: @mut Block, t: ty::t) -> heap {\n-    if ty::type_contents(bcx.tcx(), t).contains_managed() {\n+    if ty::type_contents(bcx.tcx(), t).owns_managed() {\n         heap_managed_unique\n     } else {\n         heap_exchange"}, {"sha": "9629615c64dd9210c4678ae390e7b5620d7b4528", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -156,7 +156,7 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n }\n \n fn heap_for_unique_closure(bcx: @mut Block, t: ty::t) -> heap {\n-    if ty::type_contents(bcx.tcx(), t).contains_managed() {\n+    if ty::type_contents(bcx.tcx(), t).owns_managed() {\n         heap_managed_unique\n     } else {\n         heap_exchange_closure"}, {"sha": "1efa7f763d8f9a96a3240317947c53d3559ac589", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -566,7 +566,7 @@ impl Datum {\n             }\n         };\n \n-        if !header && !ty::type_contents(bcx.tcx(), content_ty).contains_managed() {\n+        if !header && !ty::type_contents(bcx.tcx(), content_ty).owns_managed() {\n             let ptr = self.to_value_llval(bcx);\n             let ty = type_of::type_of(bcx.ccx(), content_ty);\n             let body = PointerCast(bcx, ptr, ty.ptr_to());"}, {"sha": "c6a33864620ad3f0756e8d426fc44c577baa8232", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -2060,7 +2060,7 @@ fn type_metadata(cx: &mut CrateContext,\n                 ty::vstore_fixed(len) => {\n                     fixed_vec_metadata(cx, mt.ty, len, usage_site_span)\n                 }\n-                ty::vstore_uniq if ty::type_contents(cx.tcx, mt.ty).contains_managed() => {\n+                ty::vstore_uniq if ty::type_contents(cx.tcx, mt.ty).owns_managed() => {\n                     let boxed_vec_metadata = boxed_vec_metadata(cx, mt.ty, usage_site_span);\n                     pointer_type_metadata(cx, t, boxed_vec_metadata)\n                 }\n@@ -2077,7 +2077,7 @@ fn type_metadata(cx: &mut CrateContext,\n                 }\n             }\n         },\n-        ty::ty_uniq(ref mt) if ty::type_contents(cx.tcx, mt.ty).contains_managed() => {\n+        ty::ty_uniq(ref mt) if ty::type_contents(cx.tcx, mt.ty).owns_managed() => {\n             create_pointer_to_box_metadata(cx, t, mt.ty)\n         },\n         ty::ty_uniq(ref mt)    |"}, {"sha": "f461120e4c38aa8644e537e3d7c86a659fe1123d", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -603,7 +603,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n \n     let has_header = match ty::get(t).sty {\n         ty::ty_box(*) => true,\n-        ty::ty_uniq(*) => ty::type_contents(ccx.tcx, t).contains_managed(),\n+        ty::ty_uniq(*) => ty::type_contents(ccx.tcx, t).owns_managed(),\n         _ => false\n     };\n "}, {"sha": "a7af10b491ee6d9443035178f5996ec16572cb10", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -387,9 +387,9 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let tp_ty = substs.tys[0];\n             Ret(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)));\n         }\n-        \"contains_managed\" => {\n+        \"owns_managed\" => {\n             let tp_ty = substs.tys[0];\n-            Ret(bcx, C_bool(ty::type_contents(ccx.tcx, tp_ty).contains_managed()));\n+            Ret(bcx, C_bool(ty::type_contents(ccx.tcx, tp_ty).owns_managed()));\n         }\n         \"visit_tydesc\" => {\n             let td = get_param(decl, first_real_arg);"}, {"sha": "2f4fcfed20be9754c7302cd54186f20df087a9d1", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -183,7 +183,7 @@ impl Reflector {\n           ty::ty_evec(ref mt, vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n               let extra = extra + self.c_mt(mt);\n-              if \"uniq\" == name && ty::type_contents(bcx.tcx(), t).contains_managed() {\n+              if \"uniq\" == name && ty::type_contents(bcx.tcx(), t).owns_managed() {\n                   self.visit(\"evec_uniq_managed\", extra)\n               } else {\n                   self.visit(~\"evec_\" + name, extra)\n@@ -195,7 +195,7 @@ impl Reflector {\n           }\n           ty::ty_uniq(ref mt) => {\n               let extra = self.c_mt(mt);\n-              if ty::type_contents(bcx.tcx(), t).contains_managed() {\n+              if ty::type_contents(bcx.tcx(), t).owns_managed() {\n                   self.visit(\"uniq_managed\", extra)\n               } else {\n                   self.visit(\"uniq\", extra)"}, {"sha": "93718fc1a238292b2a1edd09d3da4ca9bb536f52", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -65,7 +65,7 @@ pub fn get_alloc(bcx: @mut Block, vptr: ValueRef) -> ValueRef {\n }\n \n pub fn get_bodyptr(bcx: @mut Block, vptr: ValueRef, t: ty::t) -> ValueRef {\n-    if ty::type_contents(bcx.tcx(), t).contains_managed() {\n+    if ty::type_contents(bcx.tcx(), t).owns_managed() {\n         GEPi(bcx, vptr, [0u, abi::box_field_body])\n     } else {\n         vptr"}, {"sha": "604321a0492a117728db3772764cd95152b20109", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -226,7 +226,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n       ty::ty_opaque_box => Type::opaque_box(cx).ptr_to(),\n       ty::ty_uniq(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          if ty::type_contents(cx.tcx, mt.ty).contains_managed() {\n+          if ty::type_contents(cx.tcx, mt.ty).owns_managed() {\n               Type::unique(cx, &ty).ptr_to()\n           } else {\n               ty.ptr_to()\n@@ -235,7 +235,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n       ty::ty_evec(ref mt, ty::vstore_uniq) => {\n           let ty = type_of(cx, mt.ty);\n           let ty = Type::vec(cx.sess.targ_cfg.arch, &ty);\n-          if ty::type_contents(cx.tcx, mt.ty).contains_managed() {\n+          if ty::type_contents(cx.tcx, mt.ty).owns_managed() {\n               Type::unique(cx, &ty).ptr_to()\n           } else {\n               ty.ptr_to()"}, {"sha": "8ff270e236fa5901c43678be67cde359a1fb765b", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -27,7 +27,7 @@ pub fn make_free_glue(bcx: @mut Block, vptrptr: ValueRef, box_ty: ty::t)\n         let body_datum = box_datum.box_body(bcx);\n         let bcx = glue::drop_ty(bcx, body_datum.to_ref_llval(bcx),\n                                 body_datum.ty);\n-        if ty::type_contents(bcx.tcx(), box_ty).contains_managed() {\n+        if ty::type_contents(bcx.tcx(), box_ty).owns_managed() {\n             glue::trans_free(bcx, box_datum.val)\n         } else {\n             glue::trans_exchange_free(bcx, box_datum.val)"}, {"sha": "96bb2897e0e2610b2b764c7e5bc80b50e39347bf", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 226, "deletions": 244, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -1854,9 +1854,76 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n  * a type than to think about what is *not* contained within a type.\n  */\n pub struct TypeContents {\n-    bits: u32\n+    bits: u64\n }\n \n+macro_rules! def_type_content_sets(\n+    (mod $mname:ident { $($name:ident = $bits:expr),+ }) => {\n+        mod $mname {\n+            use middle::ty::TypeContents;\n+            $(pub static $name: TypeContents = TypeContents { bits: $bits };)+\n+        }\n+    }\n+)\n+\n+def_type_content_sets!(\n+    mod TC {\n+        None                                = 0b0000__00000000__0000,\n+\n+        // Things that are interior to the value (first nibble):\n+        InteriorUnsized                     = 0b0000__00000000__0001,\n+        InteriorAll                         = 0b0000__00000000__1111,\n+\n+        // Things that are owned by the value (second and third nibbles):\n+        OwnsOwned                           = 0b0000__00000001__0000,\n+        OwnsDtor                            = 0b0000__00000010__0000,\n+        OwnsManaged /* see [1] below */     = 0b0000__00000100__0000,\n+        OwnsAffine                          = 0b0000__00001000__0000,\n+        OwnsAll                             = 0b0000__11111111__0000,\n+\n+        // Things that are reachable by the value in any way (fourth nibble):\n+        ReachesNonsendAnnot                 = 0b0001__00000000__0000,\n+        ReachesBorrowed                     = 0b0010__00000000__0000,\n+        ReachesManaged /* see [1] below */  = 0b0100__00000000__0000,\n+        ReachesMutable                      = 0b1000__00000000__0000,\n+        ReachesAll                          = 0b1111__00000000__0000,\n+\n+        // Things that cause values to *move* rather than *copy*\n+        Moves                               = 0b0000__00001011__0000,\n+\n+        // Things that mean drop glue is necessary\n+        NeedsDrop                           = 0b0000__00000111__0000,\n+\n+        // Things that prevent values from being sent\n+        //\n+        // Note: For checking whether something is sendable, it'd\n+        //       be sufficient to have ReachesManaged. However, we include\n+        //       both ReachesManaged and OwnsManaged so that when\n+        //       a parameter has a bound T:Send, we are able to deduce\n+        //       that it neither reaches nor owns a managed pointer.\n+        Nonsendable                         = 0b0111__00000100__0000,\n+\n+        // Things that prevent values from being considered freezable\n+        Nonfreezable                        = 0b1000__00000000__0000,\n+\n+        // Things that prevent values from being considered 'static\n+        Nonstatic                           = 0b0010__00000000__0000,\n+\n+        // Things that prevent values from being considered sized\n+        Nonsized                            = 0b0000__00000000__0001,\n+\n+        // Bits to set when a managed value is encountered\n+        //\n+        // [1] Do not set the bits TC::OwnsManaged or\n+        //     TC::ReachesManaged directly, instead reference\n+        //     TC::Managed to set them both at once.\n+        Managed                             = 0b0100__00000100__0000,\n+\n+        // All bits\n+        All                                 = 0b1111__11111111__1111\n+    }\n+)\n+\n impl TypeContents {\n     pub fn meets_bounds(&self, cx: ctxt, bbs: BuiltinBounds) -> bool {\n         bbs.iter().all(|bb| self.meets_bound(cx, bb))\n@@ -1871,81 +1938,78 @@ impl TypeContents {\n         }\n     }\n \n-    pub fn intersects(&self, tc: TypeContents) -> bool {\n-        (self.bits & tc.bits) != 0\n-    }\n-\n-    pub fn noncopyable(_cx: ctxt) -> TypeContents {\n-        TC_DTOR + TC_BORROWED_MUT + TC_ONCE_CLOSURE + TC_NONCOPY_TRAIT +\n-            TC_EMPTY_ENUM\n+    pub fn when(&self, cond: bool) -> TypeContents {\n+        if cond {*self} else {TC::None}\n     }\n \n-    pub fn is_static(&self, cx: ctxt) -> bool {\n-        !self.intersects(TypeContents::nonstatic(cx))\n+    pub fn intersects(&self, tc: TypeContents) -> bool {\n+        (self.bits & tc.bits) != 0\n     }\n \n-    pub fn nonstatic(_cx: ctxt) -> TypeContents {\n-        TC_BORROWED_POINTER\n+    pub fn is_static(&self, _: ctxt) -> bool {\n+        !self.intersects(TC::Nonstatic)\n     }\n \n-    pub fn is_sendable(&self, cx: ctxt) -> bool {\n-        !self.intersects(TypeContents::nonsendable(cx))\n+    pub fn is_sendable(&self, _: ctxt) -> bool {\n+        !self.intersects(TC::Nonsendable)\n     }\n \n-    pub fn nonsendable(_cx: ctxt) -> TypeContents {\n-        TC_MANAGED + TC_BORROWED_POINTER + TC_NON_SENDABLE\n+    pub fn owns_managed(&self) -> bool {\n+        self.intersects(TC::OwnsManaged)\n     }\n \n-    pub fn contains_managed(&self) -> bool {\n-        self.intersects(TC_MANAGED)\n+    pub fn is_freezable(&self, _: ctxt) -> bool {\n+        !self.intersects(TC::Nonfreezable)\n     }\n \n-    pub fn is_freezable(&self, cx: ctxt) -> bool {\n-        !self.intersects(TypeContents::nonfreezable(cx))\n+    pub fn is_sized(&self, _: ctxt) -> bool {\n+        !self.intersects(TC::Nonsized)\n     }\n \n-    pub fn nonfreezable(_cx: ctxt) -> TypeContents {\n-        TC_MUTABLE\n+    pub fn moves_by_default(&self, _: ctxt) -> bool {\n+        self.intersects(TC::Moves)\n     }\n \n-    pub fn is_sized(&self, cx: ctxt) -> bool {\n-        !self.intersects(TypeContents::dynamically_sized(cx))\n+    pub fn needs_drop(&self, _: ctxt) -> bool {\n+        self.intersects(TC::NeedsDrop)\n     }\n \n-    pub fn dynamically_sized(_cx: ctxt) -> TypeContents {\n-        TC_DYNAMIC_SIZE\n+    pub fn owned_pointer(&self) -> TypeContents {\n+        /*!\n+         * Includes only those bits that still apply\n+         * when indirected through a `~` pointer\n+         */\n+        TC::OwnsOwned | (\n+            *self & (TC::OwnsAll | TC::ReachesAll))\n     }\n \n-    pub fn moves_by_default(&self, cx: ctxt) -> bool {\n-        self.intersects(TypeContents::nonimplicitly_copyable(cx))\n+    pub fn other_pointer(&self, bits: TypeContents) -> TypeContents {\n+        /*!\n+         * Includes only those bits that still apply\n+         * when indirected through a non-owning pointer (`&`, `@`)\n+         */\n+        bits | (\n+            *self & TC::ReachesAll)\n     }\n \n-    pub fn nonimplicitly_copyable(cx: ctxt) -> TypeContents {\n-        TypeContents::noncopyable(cx) + TC_OWNED_POINTER + TC_OWNED_VEC\n+    pub fn union<T>(v: &[T], f: &fn(&T) -> TypeContents) -> TypeContents {\n+        v.iter().fold(TC::None, |tc, t| tc | f(t))\n     }\n \n-    pub fn needs_drop(&self, cx: ctxt) -> bool {\n-        if self.intersects(TC_NONCOPY_TRAIT) {\n-            // Currently all noncopyable existentials are 2nd-class types\n-            // behind owned pointers. With dynamically-sized types, remove\n-            // this assertion.\n-            assert!(self.intersects(TC_OWNED_POINTER) ||\n-                    // (...or stack closures without a copy bound.)\n-                    self.intersects(TC_BORROWED_POINTER));\n-        }\n-        let tc = TC_MANAGED + TC_DTOR + TypeContents::sendable(cx);\n-        self.intersects(tc)\n+    pub fn inverse(&self) -> TypeContents {\n+        TypeContents { bits: !self.bits }\n     }\n+}\n \n-    pub fn sendable(_cx: ctxt) -> TypeContents {\n-        //! Any kind of sendable contents.\n-        TC_OWNED_POINTER + TC_OWNED_VEC\n+impl ops::BitOr<TypeContents,TypeContents> for TypeContents {\n+    fn bitor(&self, other: &TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits | other.bits}\n     }\n }\n \n-impl ops::Add<TypeContents,TypeContents> for TypeContents {\n-    fn add(&self, other: &TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits | other.bits}\n+impl ops::BitAnd<TypeContents,TypeContents> for TypeContents {\n+    fn bitand(&self, other: &TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits & other.bits}\n     }\n }\n \n@@ -1961,48 +2025,6 @@ impl ToStr for TypeContents {\n     }\n }\n \n-/// Constant for a type containing nothing of interest.\n-static TC_NONE: TypeContents =             TypeContents{bits: 0b0000_0000_0000};\n-\n-/// Contains a borrowed value with a lifetime other than static\n-static TC_BORROWED_POINTER: TypeContents = TypeContents{bits: 0b0000_0000_0001};\n-\n-/// Contains an owned pointer (~T) but not slice of some kind\n-static TC_OWNED_POINTER: TypeContents =    TypeContents{bits: 0b0000_0000_0010};\n-\n-/// Contains an owned vector ~[] or owned string ~str\n-static TC_OWNED_VEC: TypeContents =        TypeContents{bits: 0b0000_0000_0100};\n-\n-/// Contains a non-copyable ~fn() or a ~Trait (NOT a ~fn:Copy() or ~Trait:Copy).\n-static TC_NONCOPY_TRAIT: TypeContents =    TypeContents{bits: 0b0000_0000_1000};\n-\n-/// Type with a destructor\n-static TC_DTOR: TypeContents =             TypeContents{bits: 0b0000_0001_0000};\n-\n-/// Contains a managed value\n-static TC_MANAGED: TypeContents =          TypeContents{bits: 0b0000_0010_0000};\n-\n-/// &mut with any region\n-static TC_BORROWED_MUT: TypeContents =     TypeContents{bits: 0b0000_0100_0000};\n-\n-/// Mutable content, whether owned or by ref\n-static TC_MUTABLE: TypeContents =          TypeContents{bits: 0b0000_1000_0000};\n-\n-/// One-shot closure\n-static TC_ONCE_CLOSURE: TypeContents =     TypeContents{bits: 0b0001_0000_0000};\n-\n-/// An enum with no variants.\n-static TC_EMPTY_ENUM: TypeContents =       TypeContents{bits: 0b0010_0000_0000};\n-\n-/// Contains a type marked with `#[no_send]`\n-static TC_NON_SENDABLE: TypeContents =     TypeContents{bits: 0b0100_0000_0000};\n-\n-/// Is a bare vector, str, function, trait, etc (only relevant at top level).\n-static TC_DYNAMIC_SIZE: TypeContents =     TypeContents{bits: 0b1000_0000_0000};\n-\n-/// All possible contents.\n-static TC_ALL: TypeContents =              TypeContents{bits: 0b1111_1111_1111};\n-\n pub fn type_is_static(cx: ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_static(cx)\n }\n@@ -2039,19 +2061,19 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         //\n         // When computing the type contents of such a type, we wind up deeply\n         // recursing as we go.  So when we encounter the recursive reference\n-        // to List, we temporarily use TC_NONE as its contents.  Later we'll\n+        // to List, we temporarily use TC::None as its contents.  Later we'll\n         // patch up the cache with the correct value, once we've computed it\n         // (this is basically a co-inductive process, if that helps).  So in\n-        // the end we'll compute TC_OWNED_POINTER, in this case.\n+        // the end we'll compute TC::OwnsOwned, in this case.\n         //\n         // The problem is, as we are doing the computation, we will also\n         // compute an *intermediate* contents for, e.g., Option<List> of\n-        // TC_NONE.  This is ok during the computation of List itself, but if\n+        // TC::None.  This is ok during the computation of List itself, but if\n         // we stored this intermediate value into cx.tc_cache, then later\n-        // requests for the contents of Option<List> would also yield TC_NONE\n+        // requests for the contents of Option<List> would also yield TC::None\n         // which is incorrect.  This value was computed based on the crutch\n         // value for the type contents of list.  The correct value is\n-        // TC_OWNED_POINTER.  This manifested as issue #4821.\n+        // TC::OwnsOwned.  This manifested as issue #4821.\n         let ty_id = type_id(ty);\n         match cache.find(&ty_id) {\n             Some(tc) => { return *tc; }\n@@ -2061,108 +2083,96 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             Some(tc) => { return *tc; }\n             None => {}\n         }\n-        cache.insert(ty_id, TC_NONE);\n-\n-        let _i = indenter();\n+        cache.insert(ty_id, TC::None);\n \n         let result = match get(ty).sty {\n             // Scalar and unique types are sendable, freezable, and durable\n-            ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-            ty_bare_fn(_) | ty_ptr(_) => {\n-                TC_NONE\n+            ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+            ty_bare_fn(_) | ty::ty_char => {\n+                TC::None\n             }\n \n             ty_estr(vstore_uniq) => {\n-                TC_OWNED_VEC\n+                TC::OwnsOwned\n             }\n \n             ty_closure(ref c) => {\n-                closure_contents(c)\n+                closure_contents(cx, c)\n             }\n \n             ty_box(mt) => {\n-                TC_MANAGED +\n-                    statically_sized(nonsendable(tc_mt(cx, mt, cache)))\n+                tc_mt(cx, mt, cache).other_pointer(TC::Managed)\n             }\n \n             ty_trait(_, _, store, mutbl, bounds) => {\n-                trait_contents(store, mutbl, bounds)\n+                object_contents(cx, store, mutbl, bounds)\n             }\n \n-            ty_rptr(r, mt) => {\n-                borrowed_contents(r, mt.mutbl) +\n-                    statically_sized(nonsendable(tc_mt(cx, mt, cache)))\n+            ty_ptr(ref mt) => {\n+                tc_ty(cx, mt.ty, cache).other_pointer(TC::None)\n+            }\n+\n+            ty_rptr(r, ref mt) => {\n+                tc_ty(cx, mt.ty, cache).other_pointer(\n+                    borrowed_contents(r, mt.mutbl))\n             }\n \n             ty_uniq(mt) => {\n-                TC_OWNED_POINTER + statically_sized(tc_mt(cx, mt, cache))\n+                tc_mt(cx, mt, cache).owned_pointer()\n             }\n \n             ty_evec(mt, vstore_uniq) => {\n-                TC_OWNED_VEC + statically_sized(tc_mt(cx, mt, cache))\n+                tc_mt(cx, mt, cache).owned_pointer()\n             }\n \n             ty_evec(mt, vstore_box) => {\n-                TC_MANAGED +\n-                    statically_sized(nonsendable(tc_mt(cx, mt, cache)))\n+                tc_mt(cx, mt, cache).other_pointer(TC::Managed)\n             }\n \n-            ty_evec(mt, vstore_slice(r)) => {\n-                borrowed_contents(r, mt.mutbl) +\n-                    statically_sized(nonsendable(tc_mt(cx, mt, cache)))\n+            ty_evec(ref mt, vstore_slice(r)) => {\n+                tc_ty(cx, mt.ty, cache).other_pointer(\n+                    borrowed_contents(r, mt.mutbl))\n             }\n \n             ty_evec(mt, vstore_fixed(_)) => {\n-                let contents = tc_mt(cx, mt, cache);\n-                // FIXME(#6308) Uncomment this when construction of such\n-                // vectors is prevented earlier in compilation.\n-                // if !contents.is_sized(cx) {\n-                //     cx.sess.bug(\"Fixed-length vector of unsized type \\\n-                //                  should be impossible\");\n-                // }\n-                contents\n+                tc_mt(cx, mt, cache)\n             }\n \n             ty_estr(vstore_box) => {\n-                TC_MANAGED\n+                TC::Managed\n             }\n \n             ty_estr(vstore_slice(r)) => {\n-                borrowed_contents(r, MutImmutable)\n+                borrowed_contents(r, ast::MutImmutable)\n             }\n \n             ty_estr(vstore_fixed(_)) => {\n-                TC_NONE\n+                TC::None\n             }\n \n             ty_struct(did, ref substs) => {\n                 let flds = struct_fields(cx, did, substs);\n-                let mut res = flds.iter().fold(\n-                    TC_NONE,\n-                    |tc, f| tc + tc_mt(cx, f.mt, cache));\n+                let mut res =\n+                    TypeContents::union(flds, |f| tc_mt(cx, f.mt, cache));\n                 if ty::has_dtor(cx, did) {\n-                    res = res + TC_DTOR;\n+                    res = res | TC::OwnsDtor;\n                 }\n-                apply_tc_attr(cx, did, res)\n+                apply_attributes(cx, did, res)\n             }\n \n             ty_tup(ref tys) => {\n-                tys.iter().fold(TC_NONE, |tc, ty| tc + tc_ty(cx, *ty, cache))\n+                TypeContents::union(*tys, |ty| tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, ref substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n-                let res = if variants.is_empty() {\n-                    // we somewhat arbitrary declare that empty enums\n-                    // are non-copyable\n-                    TC_EMPTY_ENUM\n-                } else {\n-                    variants.iter().fold(TC_NONE, |tc, variant| {\n-                        variant.args.iter().fold(tc,\n-                            |tc, arg_ty| tc + tc_ty(cx, *arg_ty, cache))\n-                    })\n-                };\n-                apply_tc_attr(cx, did, res)\n+                let res =\n+                    TypeContents::union(variants, |variant| {\n+                        TypeContents::union(variant.args, |arg_ty| {\n+                            tc_ty(cx, *arg_ty, cache)\n+                        })\n+                    });\n+                apply_attributes(cx, did, res)\n             }\n \n             ty_param(p) => {\n@@ -2175,7 +2185,8 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 assert_eq!(p.def_id.crate, ast::LOCAL_CRATE);\n \n                 let tp_def = cx.ty_param_defs.get(&p.def_id.node);\n-                kind_bounds_to_contents(cx, &tp_def.bounds.builtin_bounds,\n+                kind_bounds_to_contents(cx,\n+                                        tp_def.bounds.builtin_bounds,\n                                         tp_def.bounds.trait_bounds)\n             }\n \n@@ -2186,31 +2197,29 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // for supertraits. If so we can use those bounds.\n                 let trait_def = lookup_trait_def(cx, def_id);\n                 let traits = [trait_def.trait_ref];\n-                kind_bounds_to_contents(cx, &trait_def.bounds, traits)\n+                kind_bounds_to_contents(cx, trait_def.bounds, traits)\n             }\n \n             ty_infer(_) => {\n                 // This occurs during coherence, but shouldn't occur at other\n                 // times.\n-                TC_ALL\n+                TC::All\n             }\n \n-            ty_opaque_box => TC_MANAGED,\n-            ty_unboxed_vec(mt) => TC_DYNAMIC_SIZE + tc_mt(cx, mt, cache),\n+            ty_opaque_box => TC::Managed,\n+            ty_unboxed_vec(mt) => TC::InteriorUnsized | tc_mt(cx, mt, cache),\n             ty_opaque_closure_ptr(sigil) => {\n                 match sigil {\n-                    ast::BorrowedSigil => TC_BORROWED_POINTER,\n-                    ast::ManagedSigil => TC_MANAGED,\n-                    // FIXME(#3569): Looks like noncopyability should depend\n-                    // on the bounds, but I don't think this case ever comes up.\n-                    ast::OwnedSigil => TC_NONCOPY_TRAIT + TC_OWNED_POINTER,\n+                    ast::BorrowedSigil => TC::ReachesBorrowed,\n+                    ast::ManagedSigil => TC::Managed,\n+                    ast::OwnedSigil => TC::OwnsOwned,\n                 }\n             }\n \n-            ty_type => TC_NONE,\n+            ty_type => TC::None,\n \n             ty_err => {\n-                cx.sess.bug(\"Asked to compute contents of fictitious type\");\n+                cx.sess.bug(\"Asked to compute contents of error type\");\n             }\n         };\n \n@@ -2222,132 +2231,105 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n              mt: mt,\n              cache: &mut HashMap<uint, TypeContents>) -> TypeContents\n     {\n-        let mc = if mt.mutbl == MutMutable {TC_MUTABLE} else {TC_NONE};\n-        mc + tc_ty(cx, mt.ty, cache)\n+        let mc = TC::ReachesMutable.when(mt.mutbl == MutMutable);\n+        mc | tc_ty(cx, mt.ty, cache)\n     }\n \n-    fn apply_tc_attr(cx: ctxt, did: DefId, mut tc: TypeContents) -> TypeContents {\n-        if has_attr(cx, did, \"no_freeze\") {\n-            tc = tc + TC_MUTABLE;\n-        }\n-        if has_attr(cx, did, \"no_send\") {\n-            tc = tc + TC_NON_SENDABLE;\n-        }\n-        tc\n+    fn apply_attributes(cx: ctxt,\n+                        did: ast::DefId,\n+                        tc: TypeContents)\n+                        -> TypeContents {\n+        tc |\n+            TC::ReachesMutable.when(has_attr(cx, did, \"no_freeze\")) |\n+            TC::ReachesNonsendAnnot.when(has_attr(cx, did, \"no_send\"))\n     }\n \n     fn borrowed_contents(region: ty::Region,\n-                         mutbl: ast::Mutability) -> TypeContents\n-    {\n-        let mc = if mutbl == MutMutable {\n-            TC_MUTABLE + TC_BORROWED_MUT\n-        } else {\n-            TC_NONE\n-        };\n-        let rc = if region != ty::re_static {\n-            TC_BORROWED_POINTER\n-        } else {\n-            TC_NONE\n-        };\n-        mc + rc\n-    }\n-\n-    fn nonsendable(pointee: TypeContents) -> TypeContents {\n+                         mutbl: ast::Mutability)\n+                         -> TypeContents {\n         /*!\n-         *\n-         * Given a non-owning pointer to some type `T` with\n-         * contents `pointee` (like `@T` or\n-         * `&T`), returns the relevant bits that\n-         * apply to the owner of the pointer.\n+         * Type contents due to containing a borrowed pointer\n+         * with the region `region` and borrow kind `bk`\n          */\n \n-        let mask = TC_MUTABLE.bits | TC_BORROWED_POINTER.bits;\n-        TypeContents {bits: pointee.bits & mask}\n-    }\n-\n-    fn statically_sized(pointee: TypeContents) -> TypeContents {\n-        /*!\n-         * If a dynamically-sized type is found behind a pointer, we should\n-         * restore the 'Sized' kind to the pointer and things that contain it.\n-         */\n-        TypeContents {bits: pointee.bits & !TC_DYNAMIC_SIZE.bits}\n+        let b = match mutbl {\n+            ast::MutMutable => TC::ReachesMutable | TC::OwnsAffine,\n+            ast::MutImmutable => TC::None,\n+        };\n+        b | (TC::ReachesBorrowed).when(region != ty::re_static)\n     }\n \n-    fn closure_contents(cty: &ClosureTy) -> TypeContents {\n+    fn closure_contents(cx: ctxt, cty: &ClosureTy) -> TypeContents {\n         // Closure contents are just like trait contents, but with potentially\n         // even more stuff.\n         let st = match cty.sigil {\n             ast::BorrowedSigil =>\n-                trait_contents(RegionTraitStore(cty.region), MutImmutable, cty.bounds)\n-                    + TC_BORROWED_POINTER, // might be an env packet even if static\n+                object_contents(cx, RegionTraitStore(cty.region), MutMutable, cty.bounds),\n             ast::ManagedSigil =>\n-                trait_contents(BoxTraitStore, MutImmutable, cty.bounds),\n+                object_contents(cx, BoxTraitStore, MutImmutable, cty.bounds),\n             ast::OwnedSigil =>\n-                trait_contents(UniqTraitStore, MutImmutable, cty.bounds),\n+                object_contents(cx, UniqTraitStore, MutImmutable, cty.bounds),\n         };\n+\n         // FIXME(#3569): This borrowed_contents call should be taken care of in\n-        // trait_contents, after ~Traits and @Traits can have region bounds too.\n+        // object_contents, after ~Traits and @Traits can have region bounds too.\n         // This one here is redundant for &fns but important for ~fns and @fns.\n-        let rt = borrowed_contents(cty.region, MutImmutable);\n+        let rt = borrowed_contents(cty.region, ast::MutImmutable);\n+\n         // This also prohibits \"@once fn\" from being copied, which allows it to\n         // be called. Neither way really makes much sense.\n         let ot = match cty.onceness {\n-            ast::Once => TC_ONCE_CLOSURE,\n-            ast::Many => TC_NONE\n+            ast::Once => TC::OwnsAffine,\n+            ast::Many => TC::None,\n         };\n-        // Prevent noncopyable types captured in the environment from being copied.\n-        st + rt + ot + TC_NONCOPY_TRAIT\n+\n+        st | rt | ot\n     }\n \n-    fn trait_contents(store: TraitStore, mutbl: ast::Mutability,\n-                      bounds: BuiltinBounds) -> TypeContents {\n-        let st = match store {\n-            UniqTraitStore      => TC_OWNED_POINTER,\n-            BoxTraitStore       => TC_MANAGED,\n-            RegionTraitStore(r) => borrowed_contents(r, mutbl),\n-        };\n-        let mt = match mutbl { ast::MutMutable => TC_MUTABLE, _ => TC_NONE };\n-        // We get additional \"special type contents\" for each bound that *isn't*\n-        // on the trait. So iterate over the inverse of the bounds that are set.\n-        // This is like with typarams below, but less \"pessimistic\" and also\n-        // dependent on the trait store.\n-        let mut bt = TC_NONE;\n-        for bound in (AllBuiltinBounds() - bounds).iter() {\n-            bt = bt + match bound {\n-                BoundStatic if bounds.contains_elem(BoundSend)\n-                            => TC_NONE, // Send bound implies static bound.\n-                BoundStatic => TC_BORROWED_POINTER, // Useful for \"@Trait:'static\"\n-                BoundSend   => TC_NON_SENDABLE,\n-                BoundFreeze => TC_MUTABLE,\n-                BoundSized  => TC_NONE, // don't care if interior is sized\n-            };\n+    fn object_contents(cx: ctxt,\n+                       store: TraitStore,\n+                       mutbl: ast::Mutability,\n+                       bounds: BuiltinBounds)\n+                       -> TypeContents {\n+        // These are the type contents of the (opaque) interior\n+        let contents = (TC::ReachesMutable.when(mutbl == ast::MutMutable) |\n+                        kind_bounds_to_contents(cx, bounds, []));\n+\n+        match store {\n+            UniqTraitStore => {\n+                contents.owned_pointer()\n+            }\n+            BoxTraitStore => {\n+                contents.other_pointer(TC::Managed)\n+            }\n+            RegionTraitStore(r) => {\n+                contents.other_pointer(borrowed_contents(r, mutbl))\n+            }\n         }\n-        st + mt + bt\n     }\n \n-    fn kind_bounds_to_contents(cx: ctxt, bounds: &BuiltinBounds, traits: &[@TraitRef])\n-            -> TypeContents {\n+    fn kind_bounds_to_contents(cx: ctxt,\n+                               bounds: BuiltinBounds,\n+                               traits: &[@TraitRef])\n+                               -> TypeContents {\n         let _i = indenter();\n-\n-        let mut tc = TC_ALL;\n+        let mut tc = TC::All;\n         do each_inherited_builtin_bound(cx, bounds, traits) |bound| {\n-            debug!(\"tc = {}, bound = {:?}\", tc.to_str(), bound);\n             tc = tc - match bound {\n-                BoundStatic => TypeContents::nonstatic(cx),\n-                BoundSend => TypeContents::nonsendable(cx),\n-                BoundFreeze => TypeContents::nonfreezable(cx),\n-                // The dynamic-size bit can be removed at pointer-level, etc.\n-                BoundSized => TypeContents::dynamically_sized(cx),\n+                BoundStatic => TC::Nonstatic,\n+                BoundSend => TC::Nonsendable,\n+                BoundFreeze => TC::Nonfreezable,\n+                BoundSized => TC::Nonsized,\n             };\n         }\n-\n-        debug!(\"result = {}\", tc.to_str());\n         return tc;\n \n         // Iterates over all builtin bounds on the type parameter def, including\n         // those inherited from traits with builtin-kind-supertraits.\n-        fn each_inherited_builtin_bound(cx: ctxt, bounds: &BuiltinBounds,\n-                                        traits: &[@TraitRef], f: &fn(BuiltinBound)) {\n+        fn each_inherited_builtin_bound(cx: ctxt,\n+                                        bounds: BuiltinBounds,\n+                                        traits: &[@TraitRef],\n+                                        f: &fn(BuiltinBound)) {\n             for bound in bounds.iter() {\n                 f(bound);\n             }"}, {"sha": "32284584b65837e03a54da2710679401ae2eb0ff", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -3732,7 +3732,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                ty::mk_nil())\n             }\n             \"needs_drop\" => (1u, ~[], ty::mk_bool()),\n-            \"contains_managed\" => (1u, ~[], ty::mk_bool()),\n+            \"owns_managed\" => (1u, ~[], ty::mk_bool()),\n             \"atomic_xchg\"     | \"atomic_xadd\"     | \"atomic_xsub\"     |\n             \"atomic_xchg_acq\" | \"atomic_xadd_acq\" | \"atomic_xsub_acq\" |\n             \"atomic_xchg_rel\" | \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => {"}, {"sha": "3f119bc8ccbf002ff01695b24b0fb25dda48e2af", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -414,10 +414,10 @@ impl UvIoFactory {\n /// callback in a situation where the task wil be immediately blocked\n /// afterwards. The `FsCallback` yielded must be invoked to reschedule the task\n /// (once the result of the operation is known).\n-fn uv_fs_helper<T>(loop_: &mut Loop,\n-                   retfn: extern \"Rust\" fn(&mut FsRequest) -> T,\n-                   cb: &fn(&mut FsRequest, &mut Loop, FsCallback))\n-        -> Result<T, IoError> {\n+fn uv_fs_helper<T:Send>(loop_: &mut Loop,\n+                        retfn: extern \"Rust\" fn(&mut FsRequest) -> T,\n+                        cb: &fn(&mut FsRequest, &mut Loop, FsCallback))\n+                        -> Result<T, IoError> {\n     let result_cell = Cell::new_empty();\n     let result_cell_ptr: *Cell<Result<T, IoError>> = &result_cell;\n     do task::unkillable { // FIXME(#8674)\n@@ -1025,14 +1025,12 @@ fn read_stream(mut watcher: StreamWatcher,\n     let result_cell = Cell::new_empty();\n     let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n-    let buf_ptr: *&mut [u8] = &buf;\n+    let uv_buf = slice_to_uv_buf(buf);\n     do scheduler.deschedule_running_task_and_then |_sched, task| {\n         let task_cell = Cell::new(task);\n         // XXX: We shouldn't reallocate these callbacks every\n         // call to read\n-        let alloc: AllocCallback = |_| unsafe {\n-            slice_to_uv_buf(*buf_ptr)\n-        };\n+        let alloc: AllocCallback = |_| uv_buf;\n         do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n \n             // Stop reading so that no read callbacks are\n@@ -1280,11 +1278,10 @@ impl RtioUdpSocket for UvUdpSocket {\n         do self.home_for_io_with_sched |self_, scheduler| {\n             let result_cell = Cell::new_empty();\n             let result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n-\n-            let buf_ptr: *&mut [u8] = &buf;\n+            let uv_buf = slice_to_uv_buf(buf);\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n-                let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n+                let alloc: AllocCallback = |_| uv_buf;\n                 do self_.watcher.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n                     let _ = flags; // /XXX add handling for partials?\n "}, {"sha": "030364c75af4b36b4f3a1f78537f5765614aeacd", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -337,8 +337,13 @@ extern \"rust-intrinsic\" {\n     pub fn needs_drop<T>() -> bool;\n \n     /// Returns `true` if a type is managed (will be allocated on the local heap)\n+    #[cfg(stage0)]\n     pub fn contains_managed<T>() -> bool;\n \n+    /// Returns `true` if a type is managed (will be allocated on the local heap)\n+    #[cfg(not(stage0))]\n+    pub fn owns_managed<T>() -> bool;\n+\n     pub fn visit_tydesc(td: *TyDesc, tv: &mut TyVisitor);\n \n     /// Get the address of the `__morestack` stack growth function."}, {"sha": "c9d557350151eba2f95318da29924a0d63b98e8d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -121,11 +121,19 @@ use mem::size_of;\n use uint;\n use unstable::finally::Finally;\n use unstable::intrinsics;\n-use unstable::intrinsics::{get_tydesc, contains_managed};\n+use unstable::intrinsics::{get_tydesc};\n use unstable::raw::{Box, Repr, Slice, Vec};\n use vec;\n use util;\n \n+#[cfg(not(stage0))]\n+use unstable::intrinsics::owns_managed;\n+\n+#[cfg(stage0)]\n+unsafe fn owns_managed<T>() -> bool {\n+    intrinsics::contains_managed::<T>()\n+}\n+\n /**\n  * Creates and initializes an owned vector.\n  *\n@@ -180,7 +188,7 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n #[inline]\n pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     unsafe {\n-        if contains_managed::<T>() {\n+        if owns_managed::<T>() {\n             let mut vec = ~[];\n             vec.reserve(capacity);\n             vec\n@@ -1401,7 +1409,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         if self.capacity() < n {\n             unsafe {\n                 let td = get_tydesc::<T>();\n-                if contains_managed::<T>() {\n+                if owns_managed::<T>() {\n                     let ptr: *mut *mut Box<Vec<()>> = cast::transmute(self);\n                     ::at_vec::raw::reserve_raw(td, ptr, n);\n                 } else {\n@@ -1437,7 +1445,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     #[inline]\n     fn capacity(&self) -> uint {\n         unsafe {\n-            if contains_managed::<T>() {\n+            if owns_managed::<T>() {\n                 let repr: **Box<Vec<()>> = cast::transmute(self);\n                 (**repr).data.alloc / mem::nonzero_size_of::<T>()\n             } else {\n@@ -1460,7 +1468,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     #[inline]\n     fn push(&mut self, t: T) {\n         unsafe {\n-            if contains_managed::<T>() {\n+            if owns_managed::<T>() {\n                 let repr: **Box<Vec<()>> = cast::transmute(&mut *self);\n                 let fill = (**repr).data.fill;\n                 if (**repr).data.alloc <= fill {\n@@ -1482,7 +1490,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         // This doesn't bother to make sure we have space.\n         #[inline] // really pretty please\n         unsafe fn push_fast<T>(this: &mut ~[T], t: T) {\n-            if contains_managed::<T>() {\n+            if owns_managed::<T>() {\n                 let repr: **mut Box<Vec<u8>> = cast::transmute(this);\n                 let fill = (**repr).data.fill;\n                 (**repr).data.fill += mem::nonzero_size_of::<T>();\n@@ -2057,9 +2065,14 @@ pub mod raw {\n     use mem;\n     use unstable::intrinsics;\n     use vec::{with_capacity, ImmutableVector, MutableVector};\n-    use unstable::intrinsics::contains_managed;\n     use unstable::raw::{Box, Vec, Slice};\n \n+    #[cfg(not(stage0))]\n+    use unstable::intrinsics::owns_managed;\n+\n+    #[cfg(stage0)]\n+    use vec::owns_managed;\n+\n     /**\n      * Sets the length of a vector\n      *\n@@ -2069,7 +2082,7 @@ pub mod raw {\n      */\n     #[inline]\n     pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n-        if contains_managed::<T>() {\n+        if owns_managed::<T>() {\n             let repr: **mut Box<Vec<()>> = cast::transmute(v);\n             (**repr).data.fill = new_len * mem::nonzero_size_of::<T>();\n         } else {"}, {"sha": "c83892e2a3b31a0ffb5e720efb6b6ec4e6c4178b", "filename": "src/test/compile-fail/kindck-freeze.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Ftest%2Fcompile-fail%2Fkindck-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Ftest%2Fcompile-fail%2Fkindck-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-freeze.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test which of the builtin types are considered freezeable.\n+\n+fn assert_freeze<T:Freeze>() { }\n+trait Dummy { }\n+\n+fn test<'a,T,U:Freeze>(_: &'a int) {\n+    // lifetime pointers are ok...\n+    assert_freeze::<&'static int>();\n+    assert_freeze::<&'a int>();\n+    assert_freeze::<&'a str>();\n+    assert_freeze::<&'a [int]>();\n+\n+    // ...unless they are mutable\n+    assert_freeze::<&'static mut int>(); //~ ERROR does not fulfill `Freeze`\n+    assert_freeze::<&'a mut int>(); //~ ERROR does not fulfill `Freeze`\n+\n+    // ~ pointers are ok\n+    assert_freeze::<~int>();\n+    assert_freeze::<~str>();\n+    assert_freeze::<~[int]>();\n+\n+    // but not if they own a bad thing\n+    assert_freeze::<~&'a mut int>(); //~ ERROR does not fulfill `Freeze`\n+\n+    // careful with object types, who knows what they close over...\n+    assert_freeze::<&'a Dummy>(); //~ ERROR does not fulfill `Freeze`\n+    assert_freeze::<~Dummy>(); //~ ERROR does not fulfill `Freeze`\n+\n+    // ...unless they are properly bounded\n+    assert_freeze::<&'a Dummy:Freeze>();\n+    assert_freeze::<&'static Dummy:Freeze>();\n+    assert_freeze::<~Dummy:Freeze>();\n+\n+    // ...but even then the pointer overrides\n+    assert_freeze::<&'a mut Dummy:Freeze>(); //~ ERROR does not fulfill `Freeze`\n+\n+    // closures are like an `&mut` object\n+    assert_freeze::<&fn()>(); //~ ERROR does not fulfill `Freeze`\n+\n+    // unsafe ptrs are ok unless they point at unfreezeable things\n+    assert_freeze::<*int>();\n+    assert_freeze::<*&'a mut int>(); //~ ERROR does not fulfill `Freeze`\n+}\n+\n+fn main() {\n+}"}, {"sha": "bb5851ac5c8f1195a511d90159425136910eacd5", "filename": "src/test/compile-fail/kindck-send.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test which of the builtin types are considered sendable.\n+\n+fn assert_send<T:Send>() { }\n+trait Dummy { }\n+\n+fn test<'a,T,U:Send>(_: &'a int) {\n+    // lifetime pointers with 'static lifetime are ok\n+    assert_send::<&'static int>();\n+    assert_send::<&'static str>();\n+    assert_send::<&'static [int]>();\n+\n+    // whether or not they are mutable\n+    assert_send::<&'static mut int>();\n+\n+    // otherwise lifetime pointers are not ok\n+    assert_send::<&'a int>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<&'a str>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<&'a [int]>(); //~ ERROR does not fulfill `Send`\n+\n+    // ~ pointers are ok\n+    assert_send::<~int>();\n+    assert_send::<~str>();\n+    assert_send::<~[int]>();\n+\n+    // but not if they own a bad thing\n+    assert_send::<~&'a int>(); //~ ERROR does not fulfill `Send`\n+\n+    // careful with object types, who knows what they close over...\n+    assert_send::<&'static Dummy>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<&'a Dummy>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<&'a Dummy:Send>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<~Dummy:>(); //~ ERROR does not fulfill `Send`\n+\n+    // ...unless they are properly bounded\n+    assert_send::<&'static Dummy:Send>();\n+    assert_send::<~Dummy:Send>();\n+\n+    // but closure and object types can have lifetime bounds which make\n+    // them not ok (FIXME #5121)\n+    // assert_send::<~fn:'a()>(); // ERROR does not fulfill `Send`\n+    // assert_send::<~Dummy:'a>(); // ERROR does not fulfill `Send`\n+\n+    // unsafe ptrs are ok unless they point at unsendable things\n+    assert_send::<*int>();\n+    assert_send::<*&'a int>(); //~ ERROR does not fulfill `Send`\n+}\n+\n+fn main() {\n+}"}, {"sha": "9fad05387c6b45c0e857b545f08055c3ba1fde3c", "filename": "src/test/compile-fail/mutable-enum-indirect.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc830df31df205c8edc5e11268a011d44c8bc09/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs?ref=fdc830df31df205c8edc5e11268a011d44c8bc09", "patch": "@@ -0,0 +1,12 @@\n+// Tests that an `&` pointer to something inherently mutable is itself\n+// to be considered mutable.\n+\n+#[no_freeze]\n+enum Foo { A }\n+\n+fn bar<T: Freeze>(_: T) {}\n+\n+fn main() {\n+    let x = A;\n+    bar(&x); //~ ERROR type parameter with an incompatible type\n+}"}]}