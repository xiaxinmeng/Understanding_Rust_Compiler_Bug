{"sha": "9889678f56e61e158195d6097626adc0374db619", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ODk2NzhmNTZlNjFlMTU4MTk1ZDYwOTc2MjZhZGMwMzc0ZGI2MTk=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-08T03:56:28Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-08T03:56:28Z"}, "message": "Replace Option<Vec<&'a ast::pat>> with Vec<&'a ast::Pat>", "tree": {"sha": "4aa5c1144e320f21745cd5630664a8b52e1b5333", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4aa5c1144e320f21745cd5630664a8b52e1b5333"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9889678f56e61e158195d6097626adc0374db619", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9889678f56e61e158195d6097626adc0374db619", "html_url": "https://github.com/rust-lang/rust/commit/9889678f56e61e158195d6097626adc0374db619", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9889678f56e61e158195d6097626adc0374db619/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f0b630845b7d083db8a7a195f6aa019ab7bf51b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f0b630845b7d083db8a7a195f6aa019ab7bf51b", "html_url": "https://github.com/rust-lang/rust/commit/3f0b630845b7d083db8a7a195f6aa019ab7bf51b"}], "stats": {"total": 60, "additions": 34, "deletions": 26}, "files": [{"sha": "2945f03a535867174526117e0be8d57c6b3fd311", "filename": "src/expr.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9889678f56e61e158195d6097626adc0374db619/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9889678f56e61e158195d6097626adc0374db619/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=9889678f56e61e158195d6097626adc0374db619", "patch": "@@ -730,7 +730,7 @@ struct ControlFlow<'a> {\n     block: &'a ast::Block,\n     else_block: Option<&'a ast::Expr>,\n     label: Option<ast::Label>,\n-    pats: Option<Vec<&'a ast::Pat>>,\n+    pats: Vec<&'a ast::Pat>,\n     keyword: &'a str,\n     matcher: &'a str,\n     connector: &'a str,\n@@ -744,7 +744,7 @@ fn to_control_flow(expr: &ast::Expr, expr_type: ExprType) -> Option<ControlFlow>\n     match expr.node {\n         ast::ExprKind::If(ref cond, ref if_block, ref else_block) => Some(ControlFlow::new_if(\n             cond,\n-            None,\n+            vec![],\n             if_block,\n             else_block.as_ref().map(|e| &**e),\n             expr_type == ExprType::SubExpression,\n@@ -754,7 +754,7 @@ fn to_control_flow(expr: &ast::Expr, expr_type: ExprType) -> Option<ControlFlow>\n         ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n             Some(ControlFlow::new_if(\n                 cond,\n-                Some(ptr_vec_to_ref_vec(pat)),\n+                ptr_vec_to_ref_vec(pat),\n                 if_block,\n                 else_block.as_ref().map(|e| &**e),\n                 expr_type == ExprType::SubExpression,\n@@ -768,30 +768,39 @@ fn to_control_flow(expr: &ast::Expr, expr_type: ExprType) -> Option<ControlFlow>\n         ast::ExprKind::Loop(ref block, label) => {\n             Some(ControlFlow::new_loop(block, label, expr.span))\n         }\n-        ast::ExprKind::While(ref cond, ref block, label) => {\n-            Some(ControlFlow::new_while(None, cond, block, label, expr.span))\n-        }\n+        ast::ExprKind::While(ref cond, ref block, label) => Some(ControlFlow::new_while(\n+            vec![],\n+            cond,\n+            block,\n+            label,\n+            expr.span,\n+        )),\n         ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => Some(\n-            ControlFlow::new_while(Some(ptr_vec_to_ref_vec(pat)), cond, block, label, expr.span),\n+            ControlFlow::new_while(ptr_vec_to_ref_vec(pat), cond, block, label, expr.span),\n         ),\n         _ => None,\n     }\n }\n \n+fn choose_matcher(pats: &[&ast::Pat]) -> &'static str {\n+    if pats.is_empty() {\n+        \"\"\n+    } else {\n+        \"let\"\n+    }\n+}\n+\n impl<'a> ControlFlow<'a> {\n     fn new_if(\n         cond: &'a ast::Expr,\n-        pats: Option<Vec<&'a ast::Pat>>,\n+        pats: Vec<&'a ast::Pat>,\n         block: &'a ast::Block,\n         else_block: Option<&'a ast::Expr>,\n         allow_single_line: bool,\n         nested_if: bool,\n         span: Span,\n     ) -> ControlFlow<'a> {\n-        let matcher = match pats {\n-            Some(..) => \"let\",\n-            None => \"\",\n-        };\n+        let matcher = choose_matcher(&pats);\n         ControlFlow {\n             cond: Some(cond),\n             block,\n@@ -813,7 +822,7 @@ impl<'a> ControlFlow<'a> {\n             block,\n             else_block: None,\n             label,\n-            pats: None,\n+            pats: vec![],\n             keyword: \"loop\",\n             matcher: \"\",\n             connector: \"\",\n@@ -824,16 +833,13 @@ impl<'a> ControlFlow<'a> {\n     }\n \n     fn new_while(\n-        pats: Option<Vec<&'a ast::Pat>>,\n+        pats: Vec<&'a ast::Pat>,\n         cond: &'a ast::Expr,\n         block: &'a ast::Block,\n         label: Option<ast::Label>,\n         span: Span,\n     ) -> ControlFlow<'a> {\n-        let matcher = match pats {\n-            Some(..) => \"let\",\n-            None => \"\",\n-        };\n+        let matcher = choose_matcher(&pats);\n         ControlFlow {\n             cond: Some(cond),\n             block,\n@@ -861,7 +867,7 @@ impl<'a> ControlFlow<'a> {\n             block,\n             else_block: None,\n             label,\n-            pats: Some(vec![pat]),\n+            pats: vec![pat],\n             keyword: \"for\",\n             matcher: \"\",\n             connector: \" in\",\n@@ -926,7 +932,7 @@ impl<'a> ControlFlow<'a> {\n         debug!(\"rewrite_pat_expr {:?} {:?} {:?}\", shape, self.pats, expr);\n \n         let cond_shape = shape.offset_left(offset)?;\n-        if let Some(ref pat) = self.pats {\n+        if !self.pats.is_empty() {\n             let matcher = if self.matcher.is_empty() {\n                 self.matcher.to_owned()\n             } else {\n@@ -935,7 +941,7 @@ impl<'a> ControlFlow<'a> {\n             let pat_shape = cond_shape\n                 .offset_left(matcher.len())?\n                 .sub_width(self.connector.len())?;\n-            let pat_string = rewrite_multiple_patterns(context, pat, pat_shape)?;\n+            let pat_string = rewrite_multiple_patterns(context, &self.pats, pat_shape)?;\n             let result = format!(\"{}{}{}\", matcher, pat_string, self.connector);\n             return rewrite_assign_rhs(context, result, expr, cond_shape);\n         }\n@@ -1036,15 +1042,17 @@ impl<'a> ControlFlow<'a> {\n             context\n                 .snippet_provider\n                 .span_after(mk_sp(lo, self.span.hi()), self.keyword.trim()),\n-            self.pats.as_ref().map_or(cond_span.lo(), |p| {\n+            if self.pats.is_empty() {\n+                cond_span.lo()\n+            } else {\n                 if self.matcher.is_empty() {\n-                    p[0].span.lo()\n+                    self.pats[0].span.lo()\n                 } else {\n                     context\n                         .snippet_provider\n                         .span_before(self.span, self.matcher.trim())\n                 }\n-            }),\n+            },\n         );\n \n         let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, shape);\n@@ -1131,7 +1139,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                 ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref next_else_block) => {\n                     ControlFlow::new_if(\n                         cond,\n-                        Some(ptr_vec_to_ref_vec(pat)),\n+                        ptr_vec_to_ref_vec(pat),\n                         if_block,\n                         next_else_block.as_ref().map(|e| &**e),\n                         false,\n@@ -1142,7 +1150,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                 ast::ExprKind::If(ref cond, ref if_block, ref next_else_block) => {\n                     ControlFlow::new_if(\n                         cond,\n-                        None,\n+                        vec![],\n                         if_block,\n                         next_else_block.as_ref().map(|e| &**e),\n                         false,"}]}