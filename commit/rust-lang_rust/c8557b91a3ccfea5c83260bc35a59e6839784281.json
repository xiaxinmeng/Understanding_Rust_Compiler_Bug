{"sha": "c8557b91a3ccfea5c83260bc35a59e6839784281", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NTU3YjkxYTNjY2ZlYTVjODMyNjBiYzM1YTU5ZTY4Mzk3ODQyODE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-20T15:10:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-20T15:10:35Z"}, "message": "Merge #4958\n\n4958: Infer FnSig via Fn traits r=flodiebold a=adamrk\n\nAddresses https://github.com/rust-analyzer/rust-analyzer/issues/4481.\r\nWhen inferring types check if the callee implements one of the builtin `Fn` traits. Also autoderef the callee before trying to figure out it's `FnSig`. \n\nCo-authored-by: adamrk <ark.email@gmail.com>", "tree": {"sha": "995472970b95ec9da7980588fb85372764afca04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/995472970b95ec9da7980588fb85372764afca04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8557b91a3ccfea5c83260bc35a59e6839784281", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7ibrCRBK7hj4Ov3rIwAAdHIIAGu2AGImdnBWUm2NCjuX5q3F\nzGKTh5yqhpbbGqfsfpVwXJc52piPWC3yq1+lgMKU6lYoKDCrroW8pgdStBGCAJv8\nywvNVcyEdRXjH0ibfUzn6qmtalyMWgut4n2Hds9xm62hohbAFp6U4kcW+vb1AQCy\nHYMfXy9bXOEBT54p+DmUhYs/E4xWj6Ro1Cu3zYdCuYO/WxSgKOriKlMHvW9nUYYj\nQadEsbcMfEJeE500yiodLpGcmSWSOaIq4DTSmi8nlXBCQ0DSWYh3qJ6MtLFEb4MU\nujF9Nh78T9CzdIxh6GRabkCIMh7q9mtRGu0POpgafAFYrR2YOQ8OQs7mv35eUZ4=\n=kQEK\n-----END PGP SIGNATURE-----\n", "payload": "tree 995472970b95ec9da7980588fb85372764afca04\nparent 0f7961d5570f17d6c2098ab11d2a3bcbbfb84ff6\nparent 1629fb770e21c7e7fd4c478f5074590d5c9e6829\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1592665835 +0000\ncommitter GitHub <noreply@github.com> 1592665835 +0000\n\nMerge #4958\n\n4958: Infer FnSig via Fn traits r=flodiebold a=adamrk\n\nAddresses https://github.com/rust-analyzer/rust-analyzer/issues/4481.\r\nWhen inferring types check if the callee implements one of the builtin `Fn` traits. Also autoderef the callee before trying to figure out it's `FnSig`. \n\nCo-authored-by: adamrk <ark.email@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8557b91a3ccfea5c83260bc35a59e6839784281", "html_url": "https://github.com/rust-lang/rust/commit/c8557b91a3ccfea5c83260bc35a59e6839784281", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8557b91a3ccfea5c83260bc35a59e6839784281/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f7961d5570f17d6c2098ab11d2a3bcbbfb84ff6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f7961d5570f17d6c2098ab11d2a3bcbbfb84ff6", "html_url": "https://github.com/rust-lang/rust/commit/0f7961d5570f17d6c2098ab11d2a3bcbbfb84ff6"}, {"sha": "1629fb770e21c7e7fd4c478f5074590d5c9e6829", "url": "https://api.github.com/repos/rust-lang/rust/commits/1629fb770e21c7e7fd4c478f5074590d5c9e6829", "html_url": "https://github.com/rust-lang/rust/commit/1629fb770e21c7e7fd4c478f5074590d5c9e6829"}], "stats": {"total": 336, "additions": 312, "deletions": 24}, "files": [{"sha": "a9565a58d1cbdd92764661faa48bac09cc23444d", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 71, "deletions": 10, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c8557b91a3ccfea5c83260bc35a59e6839784281/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8557b91a3ccfea5c83260bc35a59e6839784281/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=c8557b91a3ccfea5c83260bc35a59e6839784281", "patch": "@@ -10,12 +10,12 @@ use hir_def::{\n     resolver::resolver_for_expr,\n     AdtId, AssocContainerId, FieldId, Lookup,\n };\n-use hir_expand::name::Name;\n+use hir_expand::name::{name, Name};\n use ra_syntax::ast::RangeOp;\n \n use crate::{\n     autoderef, method_resolution, op,\n-    traits::InEnvironment,\n+    traits::{FnTrait, InEnvironment},\n     utils::{generics, variant_data, Generics},\n     ApplicationTy, Binders, CallableDef, InferTy, IntTy, Mutability, Obligation, Rawness, Substs,\n     TraitRef, Ty, TypeCtor,\n@@ -63,6 +63,58 @@ impl<'a> InferenceContext<'a> {\n         self.resolve_ty_as_possible(ty)\n     }\n \n+    fn callable_sig_from_fn_trait(&mut self, ty: &Ty, num_args: usize) -> Option<(Vec<Ty>, Ty)> {\n+        let krate = self.resolver.krate()?;\n+        let fn_once_trait = FnTrait::FnOnce.get_id(self.db, krate)?;\n+        let output_assoc_type =\n+            self.db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n+        let generic_params = generics(self.db.upcast(), fn_once_trait.into());\n+        if generic_params.len() != 2 {\n+            return None;\n+        }\n+\n+        let mut param_builder = Substs::builder(num_args);\n+        let mut arg_tys = vec![];\n+        for _ in 0..num_args {\n+            let arg = self.table.new_type_var();\n+            param_builder = param_builder.push(arg.clone());\n+            arg_tys.push(arg);\n+        }\n+        let parameters = param_builder.build();\n+        let arg_ty = Ty::Apply(ApplicationTy {\n+            ctor: TypeCtor::Tuple { cardinality: num_args as u16 },\n+            parameters,\n+        });\n+        let substs = Substs::build_for_generics(&generic_params)\n+            .push(ty.clone())\n+            .push(arg_ty.clone())\n+            .build();\n+\n+        let trait_env = Arc::clone(&self.trait_env);\n+        let implements_fn_trait =\n+            Obligation::Trait(TraitRef { trait_: fn_once_trait, substs: substs.clone() });\n+        let goal = self.canonicalizer().canonicalize_obligation(InEnvironment {\n+            value: implements_fn_trait.clone(),\n+            environment: trait_env,\n+        });\n+        if self.db.trait_solve(krate, goal.value).is_some() {\n+            self.obligations.push(implements_fn_trait);\n+            let output_proj_ty =\n+                crate::ProjectionTy { associated_ty: output_assoc_type, parameters: substs };\n+            let return_ty = self.normalize_projection_ty(output_proj_ty);\n+            Some((arg_tys, return_ty))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn callable_sig(&mut self, ty: &Ty, num_args: usize) -> Option<(Vec<Ty>, Ty)> {\n+        match ty.callable_sig(self.db) {\n+            Some(sig) => Some((sig.params().to_vec(), sig.ret().clone())),\n+            None => self.callable_sig_from_fn_trait(ty, num_args),\n+        }\n+    }\n+\n     fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ty = match &body[tgt_expr] {\n@@ -198,14 +250,23 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n-                let (param_tys, ret_ty) = match callee_ty.callable_sig(self.db) {\n-                    Some(sig) => (sig.params().to_vec(), sig.ret().clone()),\n-                    None => {\n-                        // Not callable\n-                        // FIXME: report an error\n-                        (Vec::new(), Ty::Unknown)\n-                    }\n-                };\n+                let canonicalized = self.canonicalizer().canonicalize_ty(callee_ty.clone());\n+                let mut derefs = autoderef(\n+                    self.db,\n+                    self.resolver.krate(),\n+                    InEnvironment {\n+                        value: canonicalized.value.clone(),\n+                        environment: self.trait_env.clone(),\n+                    },\n+                );\n+                let (param_tys, ret_ty): (Vec<Ty>, Ty) = derefs\n+                    .find_map(|callee_deref_ty| {\n+                        self.callable_sig(\n+                            &canonicalized.decanonicalize_ty(callee_deref_ty.value),\n+                            args.len(),\n+                        )\n+                    })\n+                    .unwrap_or((Vec::new(), Ty::Unknown));\n                 self.register_obligations_for_call(&callee_ty);\n                 self.check_call_arguments(args, &param_tys);\n                 self.normalize_associated_types_in(ret_ty)"}, {"sha": "961be4abdff6b40c855f420498af08abb8f385b2", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/c8557b91a3ccfea5c83260bc35a59e6839784281/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8557b91a3ccfea5c83260bc35a59e6839784281/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=c8557b91a3ccfea5c83260bc35a59e6839784281", "patch": "@@ -2888,3 +2888,226 @@ impl<A: Step> iter::Iterator for ops::Range<A> {\n     );\n     assert_eq!(t, \"i32\");\n }\n+\n+#[test]\n+fn infer_closure_arg() {\n+    assert_snapshot!(\n+        infer(\n+            r#\"\n+            //- /lib.rs\n+\n+            enum Option<T> {\n+                None,\n+                Some(T)\n+            }\n+\n+            fn foo() {\n+                let s = Option::None;\n+                let f = |x: Option<i32>| {};\n+                (&f)(s)\n+            }\n+        \"#\n+        ),\n+        @r###\"\n+    137..259 '{     ...     }': ()\n+    159..160 's': Option<i32>\n+    163..175 'Option::None': Option<i32>\n+    197..198 'f': |Option<i32>| -> ()\n+    201..220 '|x: Op...2>| {}': |Option<i32>| -> ()\n+    202..203 'x': Option<i32>\n+    218..220 '{}': ()\n+    238..245 '(&f)(s)': ()\n+    239..241 '&f': &|Option<i32>| -> ()\n+    240..241 'f': |Option<i32>| -> ()\n+    243..244 's': Option<i32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_fn_trait_arg() {\n+    assert_snapshot!(\n+        infer(\n+            r#\"\n+            //- /lib.rs deps:std\n+\n+            #[lang = \"fn_once\"]\n+            pub trait FnOnce<Args> {\n+                type Output;\n+\n+                extern \"rust-call\" fn call_once(&self, args: Args) -> Self::Output;\n+            }\n+\n+            #[lang = \"fn\"]\n+            pub trait Fn<Args>:FnOnce<Args> {\n+                extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+            }\n+\n+            enum Option<T> {\n+                None,\n+                Some(T)\n+            }\n+\n+            fn foo<F, T>(f: F) -> T\n+            where\n+                F: Fn(Option<i32>) -> T,\n+            {\n+                let s = None;\n+                f(s)\n+            }\n+        \"#\n+        ),\n+        @r###\"\n+    183..187 'self': &Self\n+    189..193 'args': Args\n+    350..354 'self': &Self\n+    356..360 'args': Args\n+    515..516 'f': F\n+    597..663 '{     ...     }': T\n+    619..620 's': Option<i32>\n+    623..627 'None': Option<i32>\n+    645..646 'f': F\n+    645..649 'f(s)': T\n+    647..648 's': Option<i32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_box_fn_arg() {\n+    assert_snapshot!(\n+        infer(\n+            r#\"\n+            //- /lib.rs deps:std\n+\n+            #[lang = \"fn_once\"]\n+            pub trait FnOnce<Args> {\n+                type Output;\n+\n+                extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+            }\n+\n+            #[lang = \"deref\"]\n+            pub trait Deref {\n+                type Target: ?Sized;\n+\n+                fn deref(&self) -> &Self::Target;\n+            }\n+\n+            #[lang = \"owned_box\"]\n+            pub struct Box<T: ?Sized> {\n+                inner: *mut T,\n+            }\n+\n+            impl<T: ?Sized> Deref for Box<T> {\n+                type Target = T;\n+\n+                fn deref(&self) -> &T {\n+                    &self.inner\n+                }\n+            }\n+\n+            enum Option<T> {\n+                None,\n+                Some(T)\n+            }\n+\n+            fn foo() {\n+                let s = Option::None;\n+                let f: Box<dyn FnOnce(&Option<i32>)> = box (|ps| {});\n+                f(&s)\n+            }\n+        \"#\n+        ),\n+        @r###\"\n+    182..186 'self': Self\n+    188..192 'args': Args\n+    356..360 'self': &Self\n+    622..626 'self': &Box<T>\n+    634..685 '{     ...     }': &T\n+    656..667 '&self.inner': &*mut T\n+    657..661 'self': &Box<T>\n+    657..667 'self.inner': *mut T\n+    812..957 '{     ...     }': FnOnce::Output<dyn FnOnce<(&Option<i32>,)>, (&Option<i32>,)>\n+    834..835 's': Option<i32>\n+    838..850 'Option::None': Option<i32>\n+    872..873 'f': Box<dyn FnOnce<(&Option<i32>,)>>\n+    907..920 'box (|ps| {})': Box<|{unknown}| -> ()>\n+    912..919 '|ps| {}': |{unknown}| -> ()\n+    913..915 'ps': {unknown}\n+    917..919 '{}': ()\n+    938..939 'f': Box<dyn FnOnce<(&Option<i32>,)>>\n+    938..943 'f(&s)': FnOnce::Output<dyn FnOnce<(&Option<i32>,)>, (&Option<i32>,)>\n+    940..942 '&s': &Option<i32>\n+    941..942 's': Option<i32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_dyn_fn_output() {\n+    assert_snapshot!(\n+        infer(\n+            r#\"\n+            //- /lib.rs deps:std\n+\n+            #[lang = \"fn_once\"]\n+            pub trait FnOnce<Args> {\n+                type Output;\n+\n+                extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+            }\n+\n+            #[lang = \"fn\"]\n+            pub trait Fn<Args>:FnOnce<Args> {\n+                extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+            }\n+\n+            #[lang = \"deref\"]\n+            pub trait Deref {\n+                type Target: ?Sized;\n+\n+                fn deref(&self) -> &Self::Target;\n+            }\n+\n+            #[lang = \"owned_box\"]\n+            pub struct Box<T: ?Sized> {\n+                inner: *mut T,\n+            }\n+\n+            impl<T: ?Sized> Deref for Box<T> {\n+                type Target = T;\n+\n+                fn deref(&self) -> &T {\n+                    &self.inner\n+                }\n+            }\n+\n+            fn foo() {\n+                let f: Box<dyn Fn() -> i32> = box(|| 5);\n+                let x = f();\n+            }\n+        \"#\n+        ),\n+        @r###\"\n+    182..186 'self': Self\n+    188..192 'args': Args\n+    349..353 'self': &Self\n+    355..359 'args': Args\n+    523..527 'self': &Self\n+    789..793 'self': &Box<T>\n+    801..852 '{     ...     }': &T\n+    823..834 '&self.inner': &*mut T\n+    824..828 'self': &Box<T>\n+    824..834 'self.inner': *mut T\n+    889..990 '{     ...     }': ()\n+    911..912 'f': Box<dyn Fn<(), Output = i32>>\n+    937..946 'box(|| 5)': Box<|| -> i32>\n+    941..945 '|| 5': || -> i32\n+    944..945 '5': i32\n+    968..969 'x': FnOnce::Output<dyn Fn<(), Output = i32>, ()>\n+    972..973 'f': Box<dyn Fn<(), Output = i32>>\n+    972..975 'f()': FnOnce::Output<dyn Fn<(), Output = i32>, ()>\n+    \"###\n+    );\n+}"}, {"sha": "892fbd6d123338fdc319205863752876a704725a", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8557b91a3ccfea5c83260bc35a59e6839784281/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8557b91a3ccfea5c83260bc35a59e6839784281/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=c8557b91a3ccfea5c83260bc35a59e6839784281", "patch": "@@ -2,7 +2,9 @@\n use std::{panic, sync::Arc};\n \n use chalk_ir::cast::Cast;\n-use hir_def::{expr::ExprId, DefWithBodyId, ImplId, TraitId, TypeAliasId};\n+use hir_def::{\n+    expr::ExprId, lang_item::LangItemTarget, DefWithBodyId, ImplId, TraitId, TypeAliasId,\n+};\n use ra_db::{impl_intern_key, salsa, CrateId};\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n@@ -298,6 +300,14 @@ impl FnTrait {\n             FnTrait::Fn => \"fn\",\n         }\n     }\n+\n+    pub fn get_id(&self, db: &dyn HirDatabase, krate: CrateId) -> Option<TraitId> {\n+        let target = db.lang_item(krate, self.lang_item_name().into())?;\n+        match target {\n+            LangItemTarget::TraitId(t) => Some(t),\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "6d5f2d46a72cc56ba4382fe10b07c170586bd419", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c8557b91a3ccfea5c83260bc35a59e6839784281/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8557b91a3ccfea5c83260bc35a59e6839784281/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=c8557b91a3ccfea5c83260bc35a59e6839784281", "patch": "@@ -40,7 +40,7 @@ pub(super) fn get_builtin_impls(\n     if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Closure { def, expr }, .. }) = ty {\n         for &fn_trait in [super::FnTrait::FnOnce, super::FnTrait::FnMut, super::FnTrait::Fn].iter()\n         {\n-            if let Some(actual_trait) = get_fn_trait(db, krate, fn_trait) {\n+            if let Some(actual_trait) = fn_trait.get_id(db, krate) {\n                 if trait_ == actual_trait {\n                     let impl_ = super::ClosureFnTraitImplData { def: *def, expr: *expr, fn_trait };\n                     if check_closure_fn_trait_impl_prerequisites(db, krate, impl_) {\n@@ -128,15 +128,15 @@ fn check_closure_fn_trait_impl_prerequisites(\n     data: super::ClosureFnTraitImplData,\n ) -> bool {\n     // the respective Fn/FnOnce/FnMut trait needs to exist\n-    if get_fn_trait(db, krate, data.fn_trait).is_none() {\n+    if data.fn_trait.get_id(db, krate).is_none() {\n         return false;\n     }\n \n     // FIXME: there are more assumptions that we should probably check here:\n     // the traits having no type params, FnOnce being a supertrait\n \n     // the FnOnce trait needs to exist and have an assoc type named Output\n-    let fn_once_trait = match get_fn_trait(db, krate, super::FnTrait::FnOnce) {\n+    let fn_once_trait = match (super::FnTrait::FnOnce).get_id(db, krate) {\n         Some(t) => t,\n         None => return false,\n     };\n@@ -151,7 +151,9 @@ fn closure_fn_trait_impl_datum(\n     // for some closure |X, Y| -> Z:\n     // impl<T, U, V> Fn<(T, U)> for closure<fn(T, U) -> V> { Output = V }\n \n-    let trait_ = get_fn_trait(db, krate, data.fn_trait) // get corresponding fn trait\n+    let trait_ = data\n+        .fn_trait\n+        .get_id(db, krate) // get corresponding fn trait\n         // the existence of the Fn trait has been checked before\n         .expect(\"fn trait for closure impl missing\");\n \n@@ -211,7 +213,7 @@ fn closure_fn_trait_output_assoc_ty_value(\n     let output_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, num_args.into()));\n \n     let fn_once_trait =\n-        get_fn_trait(db, krate, super::FnTrait::FnOnce).expect(\"assoc ty value should not exist\");\n+        (super::FnTrait::FnOnce).get_id(db, krate).expect(\"assoc ty value should not exist\");\n \n     let output_ty_id = db\n         .trait_data(fn_once_trait)\n@@ -360,14 +362,6 @@ fn super_trait_object_unsize_impl_datum(\n     BuiltinImplData { num_vars, trait_ref, where_clauses: Vec::new(), assoc_ty_values: Vec::new() }\n }\n \n-fn get_fn_trait(db: &dyn HirDatabase, krate: CrateId, fn_trait: super::FnTrait) -> Option<TraitId> {\n-    let target = db.lang_item(krate, fn_trait.lang_item_name().into())?;\n-    match target {\n-        LangItemTarget::TraitId(t) => Some(t),\n-        _ => None,\n-    }\n-}\n-\n fn get_unsize_trait(db: &dyn HirDatabase, krate: CrateId) -> Option<TraitId> {\n     let target = db.lang_item(krate, \"unsize\".into())?;\n     match target {"}]}