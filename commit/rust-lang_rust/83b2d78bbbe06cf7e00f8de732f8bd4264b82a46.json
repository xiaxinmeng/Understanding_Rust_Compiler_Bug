{"sha": "83b2d78bbbe06cf7e00f8de732f8bd4264b82a46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYjJkNzhiYmJlMDZjZjdlMDBmOGRlNzMyZjhiZDQyNjRiODJhNDY=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-12-31T18:19:59Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-01-12T12:25:58Z"}, "message": "Supporting extend selection inside macro calls", "tree": {"sha": "d3b54332d18b389ec8d54cb66166a42c9d8f8906", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3b54332d18b389ec8d54cb66166a42c9d8f8906"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83b2d78bbbe06cf7e00f8de732f8bd4264b82a46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83b2d78bbbe06cf7e00f8de732f8bd4264b82a46", "html_url": "https://github.com/rust-lang/rust/commit/83b2d78bbbe06cf7e00f8de732f8bd4264b82a46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83b2d78bbbe06cf7e00f8de732f8bd4264b82a46/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bb2a50ce6adda4d3d8dfb66cd67d302ec108d45", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb2a50ce6adda4d3d8dfb66cd67d302ec108d45", "html_url": "https://github.com/rust-lang/rust/commit/8bb2a50ce6adda4d3d8dfb66cd67d302ec108d45"}], "stats": {"total": 123, "additions": 109, "deletions": 14}, "files": [{"sha": "c6f5580219d8fb8b677ff5b7501c67f53e62a0fe", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "modified", "additions": 109, "deletions": 14, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/83b2d78bbbe06cf7e00f8de732f8bd4264b82a46/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b2d78bbbe06cf7e00f8de732f8bd4264b82a46/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=83b2d78bbbe06cf7e00f8de732f8bd4264b82a46", "patch": "@@ -4,20 +4,27 @@ use ra_db::SourceDatabase;\n use ra_syntax::{\n     algo::find_covering_element,\n     ast::{self, AstNode, AstToken},\n-    Direction, NodeOrToken,\n+    Direction, NodeOrToken, SyntaxElement,\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, TextRange, TextUnit, TokenAtOffset, T,\n };\n \n use crate::{db::RootDatabase, FileRange};\n+use hir::{db::AstDatabase, InFile};\n+use itertools::Itertools;\n \n // FIXME: restore macro support\n pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRange {\n-    let parse = db.parse(frange.file_id);\n-    try_extend_selection(parse.tree().syntax(), frange.range).unwrap_or(frange.range)\n+    let src = db.parse(frange.file_id).tree();\n+    let root = InFile::new(frange.file_id.into(), src.syntax());\n+    try_extend_selection(db, root, frange.range).unwrap_or(frange.range)\n }\n \n-fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange> {\n+fn try_extend_selection(\n+    db: &RootDatabase,\n+    root: InFile<&SyntaxNode>,\n+    range: TextRange,\n+) -> Option<TextRange> {\n     let string_kinds = [COMMENT, STRING, RAW_STRING, BYTE_STRING, RAW_BYTE_STRING];\n     let list_kinds = [\n         RECORD_FIELD_PAT_LIST,\n@@ -40,9 +47,9 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n \n     if range.is_empty() {\n         let offset = range.start();\n-        let mut leaves = root.token_at_offset(offset);\n+        let mut leaves = root.value.token_at_offset(offset);\n         if leaves.clone().all(|it| it.kind() == WHITESPACE) {\n-            return Some(extend_ws(root, leaves.next()?, offset));\n+            return Some(extend_ws(root.value, leaves.next()?, offset));\n         }\n         let leaf_range = match leaves {\n             TokenAtOffset::None => return None,\n@@ -58,7 +65,7 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n         };\n         return Some(leaf_range);\n     };\n-    let node = match find_covering_element(root, range) {\n+    let node = match find_covering_element(root.value, range) {\n         NodeOrToken::Token(token) => {\n             if token.text_range() != range {\n                 return Some(token.text_range());\n@@ -72,6 +79,16 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n         }\n         NodeOrToken::Node(node) => node,\n     };\n+\n+    // if we are in single token_tree, we maybe live in macro or attr\n+    if node.kind() == TOKEN_TREE {\n+        if let Some(macro_call) = node.ancestors().find_map(ast::MacroCall::cast) {\n+            if let Some(range) = extend_tokens_from_range(db, &root, macro_call, range) {\n+                return Some(range);\n+            }\n+        }\n+    }\n+\n     if node.text_range() != range {\n         return Some(node.text_range());\n     }\n@@ -88,6 +105,67 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n     node.parent().map(|it| it.text_range())\n }\n \n+fn extend_tokens_from_range(\n+    db: &RootDatabase,\n+    root: &InFile<&SyntaxNode>,\n+    macro_call: ast::MacroCall,\n+    original_range: TextRange,\n+) -> Option<TextRange> {\n+    let analyzer = hir::SourceAnalyzer::new(db, root.clone(), None);\n+    let expansion = analyzer.expand(db, root.with_value(&macro_call))?;\n+    \n+    // compute original mapped token range\n+    let range = macro_call\n+        .syntax()\n+        .descendants_with_tokens()\n+        .filter_map(|n| match n {\n+            NodeOrToken::Token(token) if token.text_range().is_subrange(&original_range) => {\n+                expansion\n+                    .map_token_down(db, root.with_value(&token))\n+                    .map(|node| node.value.text_range())\n+            }\n+            _ => None,\n+        })\n+        .fold1(|x, y| union_range(x, y))?;\n+\n+    let src = db.parse_or_expand(expansion.file_id())?;\n+    let parent = shallow_node(&find_covering_element(&src, range))?.parent()?;\n+\n+    // compute parent mapped token range\n+    let range = macro_call\n+        .syntax()\n+        .descendants_with_tokens()\n+        .filter_map(|n| match n {\n+            NodeOrToken::Token(token) => {\n+                expansion.map_token_down(db, root.with_value(&token)).and_then(|node| {\n+                    if node.value.text_range().is_subrange(&parent.text_range()) {\n+                        Some(token.text_range())\n+                    } else {\n+                        None\n+                    }\n+                })\n+            }\n+            _ => None,\n+        })\n+        .fold1(|x, y| union_range(x, y))?;\n+\n+    if original_range.is_subrange(&range) && original_range != range {\n+        Some(range)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn union_range(range: TextRange, r: TextRange) -> TextRange {\n+    let start = range.start().min(r.start());\n+    let end = range.end().max(r.end());\n+    TextRange::from_to(start, end)\n+}\n+\n+fn shallow_node(node: &SyntaxElement) -> Option<SyntaxNode> {\n+    node.ancestors().take_while(|n| n.text_range() == node.text_range()).last()\n+}\n+\n fn extend_single_word_in_comment_or_string(\n     leaf: &SyntaxToken,\n     offset: TextUnit,\n@@ -227,18 +305,19 @@ fn adj_comments(comment: &ast::Comment, dir: Direction) -> ast::Comment {\n \n #[cfg(test)]\n mod tests {\n-    use ra_syntax::{AstNode, SourceFile};\n-    use test_utils::extract_offset;\n-\n     use super::*;\n+    use crate::mock_analysis::single_file;\n+    use test_utils::extract_offset;\n \n     fn do_check(before: &str, afters: &[&str]) {\n         let (cursor, before) = extract_offset(before);\n-        let parse = SourceFile::parse(&before);\n-        let mut range = TextRange::offset_len(cursor, 0.into());\n+        let (analysis, file_id) = single_file(&before);\n+        let range = TextRange::offset_len(cursor, 0.into());\n+        let mut frange = FileRange { file_id: file_id, range };\n+\n         for &after in afters {\n-            range = try_extend_selection(parse.tree().syntax(), range).unwrap();\n-            let actual = &before[range];\n+            frange.range = analysis.extend_selection(frange).unwrap();\n+            let actual = &before[frange.range];\n             assert_eq!(after, actual);\n         }\n     }\n@@ -503,4 +582,20 @@ fn main() { let var = (\n             ],\n         );\n     }\n+\n+    #[test]\n+    fn extend_selection_inside_macros() {\n+        do_check(\n+            r#\"macro_rules! foo { ($item:item) => {$item} }\n+                foo!{fn hello(na<|>me:usize){}}\"#,\n+            &[\n+                \"name\",\n+                \"name:usize\",\n+                \"(name:usize)\",\n+                \"fn hello(name:usize){}\",\n+                \"{fn hello(name:usize){}}\",\n+                \"foo!{fn hello(name:usize){}}\",\n+            ],\n+        );\n+    }\n }"}]}