{"sha": "d2f8d4c5050be01923f28308b71ad14a2776b30e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZjhkNGM1MDUwYmUwMTkyM2YyODMwOGI3MWFkMTRhMjc3NmIzMGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-30T06:47:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-30T06:47:25Z"}, "message": "auto merge of #17563 : brson/rust/wintcbfix, r=thestinger\n\nThis is the bare minimum to stop using split stacks on Windows, fixing https://github.com/rust-lang/rust/issues/13259 and #14742, by turning on stack probes for all functions and disabling compiler and runtime support for split stacks on Windows.\r\n\r\nIt does not restore the out-of-stack error message, which requires more runtime work.\r\n\r\nThis includes a test that the Windows TCB is no longer being clobbered, but the out-of-stack test itself is pretty weak, only testing that the program exits abnormally, not that it isn't writing to bogus memory, so I haven't truly verified that this is providing the safety we claim.\r\n\r\nA more complete solution is in https://github.com/rust-lang/rust/pull/16388, which has some unresolved issues yet.\r\n\r\ncc @Zoxc @klutzy @vadimcn", "tree": {"sha": "4d2241526a33c79c12cfdf9905cd6d304286c086", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d2241526a33c79c12cfdf9905cd6d304286c086"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2f8d4c5050be01923f28308b71ad14a2776b30e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2f8d4c5050be01923f28308b71ad14a2776b30e", "html_url": "https://github.com/rust-lang/rust/commit/d2f8d4c5050be01923f28308b71ad14a2776b30e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2f8d4c5050be01923f28308b71ad14a2776b30e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74090504219e4e37c1a6d9fdd8600f44b51c7b04", "url": "https://api.github.com/repos/rust-lang/rust/commits/74090504219e4e37c1a6d9fdd8600f44b51c7b04", "html_url": "https://github.com/rust-lang/rust/commit/74090504219e4e37c1a6d9fdd8600f44b51c7b04"}, {"sha": "bdeb1d738676d671b92a7057e3ba1791fa012351", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdeb1d738676d671b92a7057e3ba1791fa012351", "html_url": "https://github.com/rust-lang/rust/commit/bdeb1d738676d671b92a7057e3ba1791fa012351"}], "stats": {"total": 161, "additions": 63, "deletions": 98}, "files": [{"sha": "5c8c6a24b4fa53032052a86150b76ed976b27b60", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8d4c5050be01923f28308b71ad14a2776b30e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8d4c5050be01923f28308b71ad14a2776b30e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=d2f8d4c5050be01923f28308b71ad14a2776b30e", "patch": "@@ -546,7 +546,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     // but it could be enabled (with patched LLVM)\n     pub fn is_split_stack_supported(&self) -> bool {\n         let ref cfg = self.sess().targ_cfg;\n-        cfg.os != abi::OsiOS || cfg.arch != abi::Arm\n+        (cfg.os != abi::OsiOS || cfg.arch != abi::Arm) && cfg.os != abi::OsWindows\n     }\n \n "}, {"sha": "71d00e50af83d20ab900305b78741fb5955c8988", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8d4c5050be01923f28308b71ad14a2776b30e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8d4c5050be01923f28308b71ad14a2776b30e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=d2f8d4c5050be01923f28308b71ad14a2776b30e", "patch": "@@ -89,47 +89,7 @@ local_data_key!(pub analysiskey: core::CrateAnalysis)\n type Output = (clean::Crate, Vec<plugins::PluginJson> );\n \n pub fn main() {\n-    // Why run rustdoc in a separate task? That's a good question!\n-    //\n-    // We first begin our adventure at the ancient commit of e7c4fb69. In this\n-    // commit it was discovered that the stack limit frobbing on windows ended\n-    // up causing some syscalls to fail. This was worked around manually in the\n-    // relevant location.\n-    //\n-    // Our journey now continues with #13259 where it was discovered that this\n-    // stack limit frobbing has the ability to affect nearly any syscall. Note\n-    // that the key idea here is that there is currently no knowledge as to why\n-    // this is happening or how to preserve it, fun times!\n-    //\n-    // Now we continue along to #16275 where it was discovered that --test on\n-    // windows didn't work at all! Yet curiously rustdoc worked without --test.\n-    // The exact reason that #16275 cropped up is that during the expansion\n-    // phase the compiler attempted to open libstd to read out its macros. This\n-    // invoked the LLVMRustOpenArchive shim which in turned went to LLVM to go\n-    // open a file and read it. Lo and behold this function returned an error!\n-    // It was then discovered that when the same fix mentioned in #13259 was\n-    // applied, the error went away. The plot thickens!\n-    //\n-    // Remember that rustdoc works without --test, which raises the question of\n-    // how because the --test and non --test paths are almost identical. The\n-    // first thing both paths do is parse and expand a crate! It turns out that\n-    // the difference is that --test runs on the *main task* while the normal\n-    // path runs in subtask. It turns out that running --test in a sub task also\n-    // fixes the problem!\n-    //\n-    // So, in summary, it is unknown why this is necessary, what it is\n-    // preventing, or what the actual bug is. In the meantime, this allows\n-    // --test to work on windows, which seems good, right? Fun times.\n-    let (tx, rx) = channel();\n-    spawn(proc() {\n-        std::os::set_exit_status(main_args(std::os::args().as_slice()));\n-        tx.send(());\n-    });\n-\n-    // If the task failed, set an error'd exit status\n-    if rx.recv_opt().is_err() {\n-        std::os::set_exit_status(std::rt::DEFAULT_ERROR_CODE);\n-    }\n+    std::os::set_exit_status(main_args(std::os::args().as_slice()));\n }\n \n pub fn opts() -> Vec<getopts::OptGroup> {"}, {"sha": "a4cbbf248113f89a4979f96732bd786d175e0ab0", "filename": "src/librustrt/stack.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8d4c5050be01923f28308b71ad14a2776b30e/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8d4c5050be01923f28308b71ad14a2776b30e/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=d2f8d4c5050be01923f28308b71ad14a2776b30e", "patch": "@@ -200,11 +200,7 @@ pub unsafe fn record_sp_limit(limit: uint) {\n         asm!(\"movq $0, %fs:112\" :: \"r\"(limit) :: \"volatile\")\n     }\n     #[cfg(target_arch = \"x86_64\", target_os = \"windows\")] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n-        // see: http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n-        // store this inside of the \"arbitrary data slot\", but double the size\n-        // because this is 64 bit instead of 32 bit\n-        asm!(\"movq $0, %gs:0x28\" :: \"r\"(limit) :: \"volatile\")\n+    unsafe fn target_record_sp_limit(_: uint) {\n     }\n     #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n@@ -228,10 +224,7 @@ pub unsafe fn record_sp_limit(limit: uint) {\n         asm!(\"movl $0, %gs:48\" :: \"r\"(limit) :: \"volatile\")\n     }\n     #[cfg(target_arch = \"x86\", target_os = \"windows\")] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n-        // see: http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n-        // store this inside of the \"arbitrary data slot\"\n-        asm!(\"movl $0, %fs:0x14\" :: \"r\"(limit) :: \"volatile\")\n+    unsafe fn target_record_sp_limit(_: uint) {\n     }\n \n     // mips, arm - Some brave soul can port these to inline asm, but it's over\n@@ -282,9 +275,7 @@ pub unsafe fn get_sp_limit() -> uint {\n     }\n     #[cfg(target_arch = \"x86_64\", target_os = \"windows\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n-        let limit;\n-        asm!(\"movq %gs:0x28, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n+        return 1024;\n     }\n     #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n@@ -318,9 +309,7 @@ pub unsafe fn get_sp_limit() -> uint {\n     }\n     #[cfg(target_arch = \"x86\", target_os = \"windows\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n-        let limit;\n-        asm!(\"movl %fs:0x14, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n+        return 1024;\n     }\n \n     // mips, arm - Some brave soul can port these to inline asm, but it's over"}, {"sha": "120ace1c36a5f99bdb00dbbffd8c44f250760174", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8d4c5050be01923f28308b71ad14a2776b30e/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8d4c5050be01923f28308b71ad14a2776b30e/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=d2f8d4c5050be01923f28308b71ad14a2776b30e", "patch": "@@ -136,7 +136,6 @@ mod imp {\n     use os;\n     use rand::Rng;\n     use result::{Ok, Err};\n-    use rt::stack;\n     use self::libc::{DWORD, BYTE, LPCSTR, BOOL};\n     use self::libc::types::os::arch::extra::{LONG_PTR};\n     use slice::MutableSlice;\n@@ -159,7 +158,6 @@ mod imp {\n     static PROV_RSA_FULL: DWORD = 1;\n     static CRYPT_SILENT: DWORD = 64;\n     static CRYPT_VERIFYCONTEXT: DWORD = 0xF0000000;\n-    static NTE_BAD_SIGNATURE: DWORD = 0x80090006;\n \n     #[allow(non_snake_case)]\n     extern \"system\" {\n@@ -178,48 +176,12 @@ mod imp {\n         /// Create a new `OsRng`.\n         pub fn new() -> IoResult<OsRng> {\n             let mut hcp = 0;\n-            let mut ret = unsafe {\n+            let ret = unsafe {\n                 CryptAcquireContextA(&mut hcp, 0 as LPCSTR, 0 as LPCSTR,\n                                      PROV_RSA_FULL,\n                                      CRYPT_VERIFYCONTEXT | CRYPT_SILENT)\n             };\n \n-            // FIXME #13259:\n-            // It turns out that if we can't acquire a context with the\n-            // NTE_BAD_SIGNATURE error code, the documentation states:\n-            //\n-            //     The provider DLL signature could not be verified. Either the\n-            //     DLL or the digital signature has been tampered with.\n-            //\n-            // Sounds fishy, no? As it turns out, our signature can be bad\n-            // because our Thread Information Block (TIB) isn't exactly what it\n-            // expects. As to why, I have no idea. The only data we store in the\n-            // TIB is the stack limit for each thread, but apparently that's\n-            // enough to make the signature valid.\n-            //\n-            // Furthermore, this error only happens the *first* time we call\n-            // CryptAcquireContext, so we don't have to worry about future\n-            // calls.\n-            //\n-            // Anyway, the fix employed here is that if we see this error, we\n-            // pray that we're not close to the end of the stack, temporarily\n-            // set the stack limit to 0 (what the TIB originally was), acquire a\n-            // context, and then reset the stack limit.\n-            //\n-            // Again, I'm not sure why this is the fix, nor why we're getting\n-            // this error. All I can say is that this seems to allow libnative\n-            // to progress where it otherwise would be hindered. Who knew?\n-            if ret == 0 && os::errno() as DWORD == NTE_BAD_SIGNATURE {\n-                unsafe {\n-                    let limit = stack::get_sp_limit();\n-                    stack::record_sp_limit(0);\n-                    ret = CryptAcquireContextA(&mut hcp, 0 as LPCSTR, 0 as LPCSTR,\n-                                               PROV_RSA_FULL,\n-                                               CRYPT_VERIFYCONTEXT | CRYPT_SILENT);\n-                    stack::record_sp_limit(limit);\n-                }\n-            }\n-\n             if ret == 0 {\n                 Err(IoError::last_error())\n             } else {"}, {"sha": "1a909db92e3283711fc00a60061fd0b116065d43", "filename": "src/test/run-pass/issue-13259-windows-tcb-trash.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8d4c5050be01923f28308b71ad14a2776b30e/src%2Ftest%2Frun-pass%2Fissue-13259-windows-tcb-trash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8d4c5050be01923f28308b71ad14a2776b30e/src%2Ftest%2Frun-pass%2Fissue-13259-windows-tcb-trash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13259-windows-tcb-trash.rs?ref=d2f8d4c5050be01923f28308b71ad14a2776b30e", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate libc;\n+\n+#[cfg(windows)]\n+mod imp {\n+    use libc::{c_void, LPVOID, DWORD};\n+    use libc::types::os::arch::extra::LPWSTR;\n+\n+    extern \"system\" {\n+        fn FormatMessageW(flags: DWORD,\n+                          lpSrc: LPVOID,\n+                          msgId: DWORD,\n+                          langId: DWORD,\n+                          buf: LPWSTR,\n+                          nsize: DWORD,\n+                          args: *const c_void)\n+                          -> DWORD;\n+    }\n+\n+    pub fn test() {\n+        let mut buf: [u16, ..50] = [0, ..50];\n+        let ret = unsafe {\n+            FormatMessageW(0x1000, 0 as *mut c_void, 1, 0x400,\n+                           buf.as_mut_ptr(), buf.len() as u32, 0 as *const c_void)\n+        };\n+        // On some 32-bit Windowses (Win7-8 at least) this will fail with segmented\n+        // stacks taking control of pvArbitrary\n+        assert!(ret != 0);\n+    }\n+}\n+\n+#[cfg(not(windows))]\n+mod imp {\n+    pub fn test() { }\n+}\n+\n+fn main() {\n+    imp::test()\n+}"}, {"sha": "bbaa09bfac3100d5a4f110f7c73395d2522a99f4", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8d4c5050be01923f28308b71ad14a2776b30e/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8d4c5050be01923f28308b71ad14a2776b30e/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=d2f8d4c5050be01923f28308b71ad14a2776b30e", "patch": "@@ -42,11 +42,17 @@ fn main() {\n         let silent = Command::new(args[0].as_slice()).arg(\"silent\").output().unwrap();\n         assert!(!silent.status.success());\n         let error = String::from_utf8_lossy(silent.error.as_slice());\n-        assert!(error.as_slice().contains(\"has overflowed its stack\"));\n+        // FIXME #17562: Windows is using stack probes and isn't wired up to print an error\n+        if !cfg!(windows) {\n+            assert!(error.as_slice().contains(\"has overflowed its stack\"));\n+        }\n \n         let loud = Command::new(args[0].as_slice()).arg(\"loud\").output().unwrap();\n         assert!(!loud.status.success());\n         let error = String::from_utf8_lossy(silent.error.as_slice());\n-        assert!(error.as_slice().contains(\"has overflowed its stack\"));\n+        // FIXME #17562: Windows is using stack probes and isn't wired up to print an error\n+        if !cfg!(windows) {\n+            assert!(error.as_slice().contains(\"has overflowed its stack\"));\n+        }\n     }\n }"}]}