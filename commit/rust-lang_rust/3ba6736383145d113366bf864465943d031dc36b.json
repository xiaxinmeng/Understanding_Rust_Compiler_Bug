{"sha": "3ba6736383145d113366bf864465943d031dc36b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYTY3MzYzODMxNDVkMTEzMzY2YmY4NjQ0NjU5NDNkMDMxZGMzNmI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-21T20:06:09Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-21T20:06:09Z"}, "message": "More typeck hacking, check if and call exprs, enable fact and deep tests.", "tree": {"sha": "faa346a9dd6741f93801516cf894d75f1ae3670a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faa346a9dd6741f93801516cf894d75f1ae3670a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ba6736383145d113366bf864465943d031dc36b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba6736383145d113366bf864465943d031dc36b", "html_url": "https://github.com/rust-lang/rust/commit/3ba6736383145d113366bf864465943d031dc36b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ba6736383145d113366bf864465943d031dc36b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5955e23343e606daf0341cb7ea66b8b436868ba6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5955e23343e606daf0341cb7ea66b8b436868ba6", "html_url": "https://github.com/rust-lang/rust/commit/5955e23343e606daf0341cb7ea66b8b436868ba6"}], "stats": {"total": 386, "additions": 240, "deletions": 146}, "files": [{"sha": "0b1f95a4d0cae0c39adc9e28805ca9b894a2da1d", "filename": "src/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ba6736383145d113366bf864465943d031dc36b/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3ba6736383145d113366bf864465943d031dc36b/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=3ba6736383145d113366bf864465943d031dc36b", "patch": "@@ -522,6 +522,8 @@ TEST_XFAILS_SELF := $(filter-out \\\n                         bool-not.rs \\\n                         char.rs \\\n                         dead-code-one-arm-if.rs \\\n+                        deep.rs \\\n+                        fact.rs \\\n                         hello.rs \\\n                         int.rs \\\n                         item-name-overload.rs \\"}, {"sha": "5255379d84f2f5d4345fa6d229053f310a57491d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3ba6736383145d113366bf864465943d031dc36b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba6736383145d113366bf864465943d031dc36b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3ba6736383145d113366bf864465943d031dc36b", "patch": "@@ -41,7 +41,7 @@ type glue_fns = rec(ValueRef activate_glue,\n                     ValueRef exit_task_glue,\n                     vec[ValueRef] upcall_glues);\n \n-state type trans_ctxt = rec(session.session sess,\n+state type crate_ctxt = rec(session.session sess,\n                             ModuleRef llmod,\n                             hashmap[str, ValueRef] upcalls,\n                             hashmap[str, ValueRef] fn_names,\n@@ -55,7 +55,7 @@ state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef lltaskptr,\n                          hashmap[ast.def_id, ValueRef] llargs,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n-                         @trans_ctxt tcx);\n+                         @crate_ctxt ccx);\n \n tag cleanup {\n     clean(fn(@block_ctxt cx) -> result);\n@@ -238,13 +238,13 @@ fn T_taskptr() -> TypeRef {\n     ret T_ptr(T_task());\n }\n \n-fn type_of(@trans_ctxt cx, @typeck.ty t) -> TypeRef {\n+fn type_of(@crate_ctxt cx, @typeck.ty t) -> TypeRef {\n     let TypeRef llty = type_of_inner(cx, t);\n     check (llty as int != 0);\n     ret llty;\n }\n \n-fn type_of_inner(@trans_ctxt cx, @typeck.ty t) -> TypeRef {\n+fn type_of_inner(@crate_ctxt cx, @typeck.ty t) -> TypeRef {\n     alt (t.struct) {\n         case (typeck.ty_nil) { ret T_nil(); }\n         case (typeck.ty_bool) { ret T_bool(); }\n@@ -334,7 +334,7 @@ fn C_int(int i) -> ValueRef {\n     ret C_integral(i, T_int());\n }\n \n-fn C_str(@trans_ctxt cx, str s) -> ValueRef {\n+fn C_str(@crate_ctxt cx, str s) -> ValueRef {\n     auto sc = llvm.LLVMConstString(_str.buf(s), _str.byte_len(s), False);\n     auto g = llvm.LLVMAddGlobal(cx.llmod, val_ty(sc),\n                                 _str.buf(cx.names.next(\"str\")));\n@@ -395,7 +395,7 @@ fn decl_upcall(ModuleRef llmod, uint _n) -> ValueRef {\n     ret decl_fastcall_fn(llmod, s, T_fn(args, T_int()));\n }\n \n-fn get_upcall(@trans_ctxt cx, str name, int n_args) -> ValueRef {\n+fn get_upcall(@crate_ctxt cx, str name, int n_args) -> ValueRef {\n     if (cx.upcalls.contains_key(name)) {\n         ret cx.upcalls.get(name);\n     }\n@@ -409,10 +409,10 @@ fn get_upcall(@trans_ctxt cx, str name, int n_args) -> ValueRef {\n \n fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> result {\n     let int n = _vec.len[ValueRef](args) as int;\n-    let ValueRef llupcall = get_upcall(cx.fcx.tcx, name, n);\n+    let ValueRef llupcall = get_upcall(cx.fcx.ccx, name, n);\n     llupcall = llvm.LLVMConstPointerCast(llupcall, T_int());\n \n-    let ValueRef llglue = cx.fcx.tcx.glues.upcall_glues.(n);\n+    let ValueRef llglue = cx.fcx.ccx.glues.upcall_glues.(n);\n     let vec[ValueRef] call_args = vec(cx.fcx.lltaskptr, llupcall);\n     for (ValueRef a in args) {\n         call_args += cx.build.ZExtOrBitCast(a, T_int());\n@@ -510,7 +510,7 @@ fn trans_copy_ty(@block_ctxt cx,\n             ret res(r.bcx, r.bcx.build.Store(src, dst));\n         }\n     }\n-    cx.fcx.tcx.sess.unimpl(\"ty variant in trans_copy_ty\");\n+    cx.fcx.ccx.sess.unimpl(\"ty variant in trans_copy_ty\");\n     fail;\n }\n \n@@ -541,7 +541,7 @@ impure fn trans_lit(@block_ctxt cx, &ast.lit lit) -> result {\n         case (ast.lit_str(?s)) {\n             auto len = (_str.byte_len(s) as int) + 1;\n             auto sub = trans_upcall(cx, \"upcall_new_str\",\n-                                    vec(p2i(C_str(cx.fcx.tcx, s)),\n+                                    vec(p2i(C_str(cx.fcx.ccx, s)),\n                                         C_int(len)));\n             sub.val = sub.bcx.build.IntToPtr(sub.val,\n                                              T_ptr(T_str(len as uint)));\n@@ -551,7 +551,7 @@ impure fn trans_lit(@block_ctxt cx, &ast.lit lit) -> result {\n     }\n }\n \n-fn node_type(@trans_ctxt cx, &ast.ann a) -> TypeRef {\n+fn node_type(@crate_ctxt cx, &ast.ann a) -> TypeRef {\n     alt (a) {\n         case (ast.ann_none) {\n             log \"missing type annotation\";\n@@ -583,7 +583,7 @@ impure fn trans_unary(@block_ctxt cx, ast.unop op,\n             ret sub;\n         }\n         case (ast.box) {\n-            auto e_ty = node_type(cx.fcx.tcx, a);\n+            auto e_ty = node_type(cx.fcx.ccx, a);\n             auto box_ty = T_box(e_ty);\n             sub.val = cx.build.Malloc(box_ty);\n             auto rc = sub.bcx.build.GEP(sub.val,\n@@ -592,7 +592,7 @@ impure fn trans_unary(@block_ctxt cx, ast.unop op,\n             ret res(sub.bcx, cx.build.Store(C_int(1), rc));\n         }\n     }\n-    cx.fcx.tcx.sess.unimpl(\"expr variant in trans_unary\");\n+    cx.fcx.ccx.sess.unimpl(\"expr variant in trans_unary\");\n     fail;\n }\n \n@@ -737,7 +737,7 @@ impure fn trans_binary(@block_ctxt cx, ast.binop op,\n             ret sub;\n         }\n     }\n-    cx.fcx.tcx.sess.unimpl(\"expr variant in trans_binary\");\n+    cx.fcx.ccx.sess.unimpl(\"expr variant in trans_binary\");\n     fail;\n }\n \n@@ -864,21 +864,21 @@ fn trans_lval(@block_ctxt cx, &ast.expr e)\n                                     true, did);\n                         }\n                         case (ast.def_fn(?did)) {\n-                            ret tup(res(cx, cx.fcx.tcx.fn_ids.get(did)),\n+                            ret tup(res(cx, cx.fcx.ccx.fn_ids.get(did)),\n                                     false, did);\n                         }\n                         case (_) {\n-                            cx.fcx.tcx.sess.unimpl(\"def variant in trans\");\n+                            cx.fcx.ccx.sess.unimpl(\"def variant in trans\");\n                         }\n                     }\n                 }\n                 case (none[ast.def]) {\n-                    cx.fcx.tcx.sess.err(\"unresolved expr_name in trans\");\n+                    cx.fcx.ccx.sess.err(\"unresolved expr_name in trans\");\n                 }\n             }\n         }\n     }\n-    cx.fcx.tcx.sess.unimpl(\"expr variant in trans_lval\");\n+    cx.fcx.ccx.sess.unimpl(\"expr variant in trans_lval\");\n     fail;\n }\n \n@@ -963,7 +963,7 @@ impure fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n         }\n \n     }\n-    cx.fcx.tcx.sess.unimpl(\"expr variant in trans_expr\");\n+    cx.fcx.ccx.sess.unimpl(\"expr variant in trans_expr\");\n     fail;\n }\n \n@@ -999,8 +999,8 @@ impure fn trans_check_expr(@block_ctxt cx, &ast.expr e) -> result {\n     auto cond_res = trans_expr(cx, e);\n \n     // FIXME: need pretty-printer.\n-    auto V_expr_str = p2i(C_str(cx.fcx.tcx, \"<expr>\"));\n-    auto V_filename = p2i(C_str(cx.fcx.tcx, e.span.filename));\n+    auto V_expr_str = p2i(C_str(cx.fcx.ccx, \"<expr>\"));\n+    auto V_filename = p2i(C_str(cx.fcx.ccx, e.span.filename));\n     auto V_line = e.span.lo.line as int;\n     auto args = vec(V_expr_str, V_filename, C_int(V_line));\n \n@@ -1084,7 +1084,7 @@ impure fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n             }\n         }\n         case (_) {\n-            cx.fcx.tcx.sess.unimpl(\"stmt variant\");\n+            cx.fcx.ccx.sess.unimpl(\"stmt variant\");\n         }\n     }\n     ret sub;\n@@ -1103,7 +1103,7 @@ fn new_block_ctxt(@fn_ctxt cx, block_parent parent,\n                   str name) -> @block_ctxt {\n     let BasicBlockRef llbb =\n         llvm.LLVMAppendBasicBlock(cx.llfn,\n-                                  _str.buf(cx.tcx.names.next(name)));\n+                                  _str.buf(cx.ccx.names.next(name)));\n \n     ret @rec(llbb=llbb,\n              build=new_builder(llbb, name),\n@@ -1159,7 +1159,7 @@ impure fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n     auto bcx = cx;\n \n     for each (@ast.local local in block_locals(b)) {\n-        auto ty = node_type(cx.fcx.tcx, local.ann);\n+        auto ty = node_type(cx.fcx.ccx, local.ann);\n         auto val = bcx.build.Alloca(ty);\n         cx.fcx.lllocals.insert(local.id, val);\n     }\n@@ -1179,7 +1179,7 @@ impure fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n     ret res(bcx, r.val);\n }\n \n-fn new_fn_ctxt(@trans_ctxt cx,\n+fn new_fn_ctxt(@crate_ctxt cx,\n                str name,\n                &ast._fn f,\n                ast.def_id fid) -> @fn_ctxt {\n@@ -1204,15 +1204,15 @@ fn new_fn_ctxt(@trans_ctxt cx,\n              lltaskptr=lltaskptr,\n              llargs=llargs,\n              lllocals=lllocals,\n-             tcx=cx);\n+             ccx=cx);\n }\n \n fn is_terminated(@block_ctxt cx) -> bool {\n     auto inst = llvm.LLVMGetLastInstruction(cx.llbb);\n     ret llvm.LLVMIsATerminatorInst(inst) as int != 0;\n }\n \n-impure fn trans_fn(@trans_ctxt cx, &ast._fn f, ast.def_id fid) {\n+impure fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid) {\n \n     auto fcx = new_fn_ctxt(cx, cx.path, f, fid);\n     auto bcx = new_top_block_ctxt(fcx);\n@@ -1224,7 +1224,7 @@ impure fn trans_fn(@trans_ctxt cx, &ast._fn f, ast.def_id fid) {\n     }\n }\n \n-impure fn trans_item(@trans_ctxt cx, &ast.item item) {\n+impure fn trans_item(@crate_ctxt cx, &ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(?name, ?f, ?fid, _)) {\n             auto sub_cx = @rec(path=cx.path + \".\" + name with *cx);\n@@ -1237,14 +1237,14 @@ impure fn trans_item(@trans_ctxt cx, &ast.item item) {\n     }\n }\n \n-impure fn trans_mod(@trans_ctxt cx, &ast._mod m) {\n+impure fn trans_mod(@crate_ctxt cx, &ast._mod m) {\n     for (@ast.item item in m.items) {\n         trans_item(cx, *item);\n     }\n }\n \n \n-fn collect_item(&@trans_ctxt cx, @ast.item i) -> @trans_ctxt {\n+fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n     alt (i.node) {\n         case (ast.item_fn(?name, ?f, ?fid, ?ann)) {\n             cx.items.insert(fid, i);\n@@ -1262,22 +1262,22 @@ fn collect_item(&@trans_ctxt cx, @ast.item i) -> @trans_ctxt {\n }\n \n \n-fn collect_items(@trans_ctxt cx, @ast.crate crate) {\n+fn collect_items(@crate_ctxt cx, @ast.crate crate) {\n \n-    let fold.ast_fold[@trans_ctxt] fld =\n-        fold.new_identity_fold[@trans_ctxt]();\n+    let fold.ast_fold[@crate_ctxt] fld =\n+        fold.new_identity_fold[@crate_ctxt]();\n \n     fld = @rec( update_env_for_item = bind collect_item(_,_)\n                 with *fld );\n \n-    fold.fold_crate[@trans_ctxt](cx, fld, crate);\n+    fold.fold_crate[@crate_ctxt](cx, fld, crate);\n }\n \n fn p2i(ValueRef v) -> ValueRef {\n     ret llvm.LLVMConstPtrToInt(v, T_int());\n }\n \n-fn trans_exit_task_glue(@trans_ctxt cx) {\n+fn trans_exit_task_glue(@crate_ctxt cx) {\n     let vec[TypeRef] T_args = vec();\n     let vec[ValueRef] V_args = vec();\n \n@@ -1287,14 +1287,14 @@ fn trans_exit_task_glue(@trans_ctxt cx) {\n                     lltaskptr=lltaskptr,\n                     llargs=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),\n-                    tcx=cx);\n+                    ccx=cx);\n \n     auto bcx = new_top_block_ctxt(fcx);\n     trans_upcall(bcx, \"upcall_exit\", V_args);\n     bcx.build.RetVoid();\n }\n \n-fn crate_constant(@trans_ctxt cx) -> ValueRef {\n+fn crate_constant(@crate_ctxt cx) -> ValueRef {\n \n     let ValueRef crate_ptr =\n         llvm.LLVMAddGlobal(cx.llmod, T_crate(),\n@@ -1332,7 +1332,7 @@ fn crate_constant(@trans_ctxt cx) -> ValueRef {\n     ret crate_ptr;\n }\n \n-fn trans_main_fn(@trans_ctxt cx, ValueRef llcrate) {\n+fn trans_main_fn(@crate_ctxt cx, ValueRef llcrate) {\n     auto T_main_args = vec(T_int(), T_int());\n     auto T_rust_start_args = vec(T_int(), T_int(), T_int(), T_int());\n "}, {"sha": "55a43acb9074cf936adbb3a4de82990dacd9267b", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 200, "deletions": 108, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/3ba6736383145d113366bf864465943d031dc36b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba6736383145d113366bf864465943d031dc36b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=3ba6736383145d113366bf864465943d031dc36b", "patch": "@@ -3,6 +3,7 @@ import front.ast.ann;\n import middle.fold;\n import driver.session;\n import util.common;\n+import util.common.append;\n import util.common.span;\n \n import std._str;\n@@ -15,10 +16,14 @@ import std.option.none;\n import std.option.some;\n \n type ty_table = hashmap[ast.def_id, @ty];\n-type env = rec(session.session sess,\n-               @ty_table item_types,\n-               hashmap[int,@ty] bindings,\n-               mutable int next_var_id);\n+type crate_ctxt = rec(session.session sess,\n+                      @ty_table item_types,\n+                      hashmap[int,@ty] bindings,\n+                      mutable int next_var_id);\n+\n+type fn_ctxt = rec(@ty ret_ty,\n+                   @ty_table locals,\n+                   @crate_ctxt ccx);\n \n type arg = rec(ast.mode mode, @ty ty);\n \n@@ -242,14 +247,14 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n     ret @rec(struct=sty, cname=cname);\n }\n \n-// A convenience function to use an environment to resolve names for\n+// A convenience function to use a crate_ctxt to resolve names for\n // ast_ty_to_ty.\n-fn ast_ty_to_ty_env(@env e, &@ast.ty ast_ty) -> @ty {\n-    fn getter(@env e, ast.def_id id) -> @ty {\n-        check (e.item_types.contains_key(id));\n-        ret e.item_types.get(id);\n+fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty {\n+    fn getter(@crate_ctxt ccx, ast.def_id id) -> @ty {\n+        check (ccx.item_types.contains_key(id));\n+        ret ccx.item_types.get(id);\n     }\n-    auto f = bind getter(e, _);\n+    auto f = bind getter(ccx, _);\n     ret ast_ty_to_ty(f, ast_ty);\n }\n \n@@ -402,7 +407,28 @@ fn ann_to_type(&ast.ann ann) -> @ty {\n     }\n }\n \n-fn type_of(@ast.expr expr) -> @ty {\n+fn stmt_ty(@ast.stmt s) -> @ty {\n+    alt (s.node) {\n+        case (ast.stmt_expr(?e)) {\n+            ret expr_ty(e);\n+        }\n+        case (_) {\n+            ret plain_ty(ty_nil);\n+        }\n+    }\n+}\n+\n+fn block_ty(&ast.block b) -> @ty {\n+    auto len = _vec.len[@ast.stmt](b.node.stmts);\n+    if (len == 0u) {\n+        ret plain_ty(ty_nil);\n+    }\n+    // FIXME: should rewind to last non-dead stmt? Or perhaps\n+    // we prohibit all dead stmts?\n+    ret stmt_ty(b.node.stmts.(len - 1u));\n+}\n+\n+fn expr_ty(@ast.expr expr) -> @ty {\n     alt (expr.node) {\n         case (ast.expr_vec(_, ?ann))          { ret ann_to_type(ann); }\n         case (ast.expr_tup(_, ?ann))          { ret ann_to_type(ann); }\n@@ -427,7 +453,7 @@ fn type_of(@ast.expr expr) -> @ty {\n \n // Type unification\n \n-fn unify(&@env e, @ty expected, @ty actual) -> unify_result {\n+fn unify(&@crate_ctxt ccx, @ty expected, @ty actual) -> unify_result {\n     // Wraps the given type in an appropriate cname.\n     //\n     // TODO: This doesn't do anything yet. We should carry the cname up from\n@@ -444,7 +470,7 @@ fn unify(&@env e, @ty expected, @ty actual) -> unify_result {\n         ret ures_err(terr_mismatch, expected, actual);\n     }\n \n-    fn unify_step(&@env e, @ty expected, @ty actual)\n+    fn unify_step(&@crate_ctxt ccx, @ty expected, @ty actual)\n             -> unify_result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n@@ -460,7 +486,9 @@ fn unify(&@env e, @ty expected, @ty actual) -> unify_result {\n             case (ty_box(?expected_sub)) {\n                 alt (actual.struct) {\n                     case (ty_box(?actual_sub)) {\n-                        auto result = unify_step(e, expected_sub, actual_sub);\n+                        auto result = unify_step(ccx,\n+                                                 expected_sub,\n+                                                 actual_sub);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 ret ures_ok(plain_ty(ty_box(result_sub)));\n@@ -482,7 +510,9 @@ fn unify(&@env e, @ty expected, @ty actual) -> unify_result {\n             case (ty_vec(?expected_sub)) {\n                 alt (actual.struct) {\n                     case (ty_vec(?actual_sub)) {\n-                        auto result = unify_step(e, expected_sub, actual_sub);\n+                        auto result = unify_step(ccx,\n+                                                 expected_sub,\n+                                                 actual_sub);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 ret ures_ok(plain_ty(ty_vec(result_sub)));\n@@ -526,7 +556,8 @@ fn unify(&@env e, @ty expected, @ty actual) -> unify_result {\n                                 ret ures_err(err, expected, actual);\n                             }\n \n-                            auto result = unify_step(e, expected_elem._1,\n+                            auto result = unify_step(ccx,\n+                                                     expected_elem._1,\n                                                      actual_elem._1);\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n@@ -577,7 +608,8 @@ fn unify(&@env e, @ty expected, @ty actual) -> unify_result {\n                                 result_mode = ast.val;\n                             }\n \n-                            auto result = unify_step(e, expected_input.ty,\n+                            auto result = unify_step(ccx,\n+                                                     expected_input.ty,\n                                                      actual_input.ty);\n \n                             alt (result) {\n@@ -596,7 +628,8 @@ fn unify(&@env e, @ty expected, @ty actual) -> unify_result {\n \n                         // Check the output.\n                         auto result_out;\n-                        auto result = unify_step(e, expected_output,\n+                        auto result = unify_step(ccx,\n+                                                 expected_output,\n                                                  actual_output);\n                         alt (result) {\n                             case (ures_ok(?rty)) {\n@@ -618,13 +651,13 @@ fn unify(&@env e, @ty expected, @ty actual) -> unify_result {\n             }\n \n             case (ty_var(?expected_id)) {\n-                if (e.bindings.contains_key(expected_id)) {\n-                    check (e.bindings.contains_key(expected_id));\n-                    auto binding = e.bindings.get(expected_id);\n-                    ret unify_step(e, binding, actual);\n+                if (ccx.bindings.contains_key(expected_id)) {\n+                    check (ccx.bindings.contains_key(expected_id));\n+                    auto binding = ccx.bindings.get(expected_id);\n+                    ret unify_step(ccx, binding, actual);\n                 }\n \n-                e.bindings.insert(expected_id, actual);\n+                ccx.bindings.insert(expected_id, actual);\n                 ret ures_ok(actual);\n             }\n         }\n@@ -633,21 +666,22 @@ fn unify(&@env e, @ty expected, @ty actual) -> unify_result {\n         fail;\n     }\n \n-    ret unify_step(e, expected, actual);\n+    ret unify_step(ccx, expected, actual);\n }\n \n // Requires that the two types unify, and prints an error message if they\n // don't. Returns the unified type.\n-fn demand(&@env e, &span sp, @ty expected, @ty actual) -> @ty {\n-    alt (unify(e, expected, actual)) {\n+fn demand(&@crate_ctxt ccx, &span sp, @ty expected, @ty actual) -> @ty {\n+    alt (unify(ccx, expected, actual)) {\n         case (ures_ok(?ty)) {\n             ret ty;\n         }\n \n         case (ures_err(?err, ?expected, ?actual)) {\n-            e.sess.err(\"mismatched types: expected \" + ty_to_str(expected) +\n-                       \" but found \" + ty_to_str(actual) + \" (\" +\n-                       type_err_to_str(err) + \")\");\n+            ccx.sess.span_err(sp, \"mismatched types: expected \"\n+                              + ty_to_str(expected) + \" but found \"\n+                              + ty_to_str(actual) + \" (\" +\n+                              type_err_to_str(err) + \")\");\n \n             // TODO: In the future, try returning \"expected\", reporting the\n             // error, and continue.\n@@ -656,57 +690,47 @@ fn demand(&@env e, &span sp, @ty expected, @ty actual) -> @ty {\n     }\n }\n \n-// Unifies the supplied type with the type of the local `id`, and stores the\n-// unified type in the local table. Emits an error if the type is incompatible\n-// with the previously-stored type for this local.\n-fn demand_local(&@env e, &span sp, &@ty_table locals, ast.def_id local_id,\n-                @ty t) {\n-    check (locals.contains_key(local_id));\n-    auto prev_ty = locals.get(local_id);\n-    auto unified_ty = demand(e, sp, prev_ty, t);\n-    locals.insert(local_id, unified_ty);\n-}\n-\n // Returns true if the two types unify and false if they don't.\n-fn are_compatible(&@env e, @ty expected, @ty actual) -> bool {\n-    alt (unify(e, expected, actual)) {\n+fn are_compatible(&@crate_ctxt ccx, @ty expected, @ty actual) -> bool {\n+    alt (unify(ccx, expected, actual)) {\n         case (ures_ok(_))        { ret true;  }\n         case (ures_err(_, _, _)) { ret false; }\n     }\n }\n \n // Writeback: the phase that writes inferred types back into the AST.\n \n-fn resolve_vars(@env e, @ty t) -> @ty {\n+fn resolve_vars(@crate_ctxt ccx, @ty t) -> @ty {\n     alt (t.struct) {\n         case (ty_var(?v)) {\n-            check (e.bindings.contains_key(v));\n-            ret resolve_vars(e, e.bindings.get(v));\n+            check (ccx.bindings.contains_key(v));\n+            ret resolve_vars(ccx, ccx.bindings.get(v));\n         }\n     }\n     ret t;\n }\n \n-fn writeback_local(@env e, &@ty_table locals, &span sp, @ast.local local)\n+fn writeback_local(&fn_ctxt fcx, &span sp, @ast.local local)\n         -> @ast.decl {\n-    if (!locals.contains_key(local.id)) {\n-        e.sess.err(\"unable to determine type of local: \" + local.ident);\n+    if (!fcx.locals.contains_key(local.id)) {\n+        fcx.ccx.sess.span_err(sp, \"unable to determine type of local: \"\n+                              + local.ident);\n     }\n-    auto local_ty = resolve_vars(e, locals.get(local.id));\n+    auto local_ty = resolve_vars(fcx.ccx, fcx.locals.get(local.id));\n     auto local_wb = @rec(ann=ast.ann_type(local_ty) with *local);\n     ret @fold.respan[ast.decl_](sp, ast.decl_local(local_wb));\n }\n \n-fn writeback(&@env e, &@ty_table locals, &ast.block block) -> ast.block {\n-    auto fld = fold.new_identity_fold[@ty_table]();\n-    auto f = bind writeback_local(e, _, _, _);\n+fn writeback(&fn_ctxt fcx, &ast.block block) -> ast.block {\n+    auto fld = fold.new_identity_fold[fn_ctxt]();\n+    auto f = writeback_local;\n     fld = @rec(fold_decl_local = f with *fld);\n-    ret fold.fold_block[@ty_table](locals, fld, block);\n+    ret fold.fold_block[fn_ctxt](fcx, fld, block);\n }\n \n // AST fragment checking\n \n-fn check_lit(&@env e, @ast.lit lit) -> @ty {\n+fn check_lit(@ast.lit lit) -> @ty {\n     auto sty;\n     alt (lit.node) {\n         case (ast.lit_str(_))   { sty = ty_str;  }\n@@ -720,22 +744,22 @@ fn check_lit(&@env e, @ast.lit lit) -> @ty {\n     ret plain_ty(sty);\n }\n \n-fn check_expr(&@env e, &@ty_table locals, @ast.expr expr) -> @ast.expr {\n+fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     alt (expr.node) {\n         case (ast.expr_lit(?lit, _)) {\n-            auto ty = check_lit(e, lit);\n+            auto ty = check_lit(lit);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_lit(lit, ast.ann_type(ty)));\n         }\n \n \n         case (ast.expr_binary(?binop, ?lhs, ?rhs, _)) {\n-            auto lhs_1 = check_expr(e, locals, lhs);\n-            auto rhs_1 = check_expr(e, locals, rhs);\n-            auto lhs_t = type_of(lhs_1);\n-            auto rhs_t = type_of(rhs_1);\n+            auto lhs_1 = check_expr(fcx, lhs);\n+            auto rhs_1 = check_expr(fcx, rhs);\n+            auto lhs_t = expr_ty(lhs_1);\n+            auto rhs_t = expr_ty(rhs_1);\n             // FIXME: Binops have a bit more subtlety than this.\n-            demand(e, expr.span, lhs_t, rhs_t);\n+            demand(fcx.ccx, expr.span, lhs_t, rhs_t);\n             auto t = lhs_t;\n             alt (binop) {\n                 case (ast.eq) { t = plain_ty(ty_bool); }\n@@ -752,8 +776,8 @@ fn check_expr(&@env e, &@ty_table locals, @ast.expr expr) -> @ast.expr {\n \n \n         case (ast.expr_unary(?unop, ?oper, _)) {\n-            auto oper_1 = check_expr(e, locals, oper);\n-            auto oper_t = type_of(oper_1);\n+            auto oper_1 = check_expr(fcx, oper);\n+            auto oper_t = expr_ty(oper_1);\n             // FIXME: Unops have a bit more subtlety than this.\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_unary(unop, oper_1,\n@@ -764,17 +788,25 @@ fn check_expr(&@env e, &@ty_table locals, @ast.expr expr) -> @ast.expr {\n             auto ty = @rec(struct=ty_nil, cname=none[str]);\n             alt (option.get[ast.def](defopt)) {\n                 case (ast.def_arg(?id)) {\n-                    check (locals.contains_key(id));\n-                    ty = locals.get(id);\n+                    check (fcx.locals.contains_key(id));\n+                    ty = fcx.locals.get(id);\n                 }\n                 case (ast.def_local(?id)) {\n-                    check (locals.contains_key(id));\n-                    ty = locals.get(id);\n+                    check (fcx.locals.contains_key(id));\n+                    ty = fcx.locals.get(id);\n+                }\n+                case (ast.def_fn(?id)) {\n+                    check (fcx.ccx.item_types.contains_key(id));\n+                    ty = fcx.ccx.item_types.get(id);\n+                }\n+                case (ast.def_const(?id)) {\n+                    check (fcx.ccx.item_types.contains_key(id));\n+                    ty = fcx.ccx.item_types.get(id);\n                 }\n                 case (_) {\n                     // FIXME: handle other names.\n-                    e.sess.unimpl(\"definition variant for: \"\n-                                  + name.node.ident);\n+                    fcx.ccx.sess.unimpl(\"definition variant for: \"\n+                                        + name.node.ident);\n                     fail;\n                 }\n             }\n@@ -784,24 +816,77 @@ fn check_expr(&@env e, &@ty_table locals, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_assign(?lhs, ?rhs, _)) {\n-            auto lhs_1 = check_expr(e, locals, lhs);\n-            auto rhs_1 = check_expr(e, locals, rhs);\n-            auto lhs_t = type_of(lhs_1);\n-            auto rhs_t = type_of(rhs_1);\n-            demand(e, expr.span, lhs_t, rhs_t);\n+            auto lhs_1 = check_expr(fcx, lhs);\n+            auto rhs_1 = check_expr(fcx, rhs);\n+            auto lhs_t = expr_ty(lhs_1);\n+            auto rhs_t = expr_ty(rhs_1);\n+            demand(fcx.ccx, expr.span, lhs_t, rhs_t);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_assign(lhs_1, rhs_1,\n                                                         ast.ann_type(rhs_t)));\n         }\n \n+        case (ast.expr_if(?cond, ?thn, ?elsopt, _)) {\n+            auto cond_1 = check_expr(fcx, cond);\n+            auto thn_1 = check_block(fcx, thn);\n+            demand(fcx.ccx, cond.span, plain_ty(ty_bool), expr_ty(cond_1));\n+            auto thn_t = block_ty(thn_1);\n+            auto elsopt_1 = none[ast.block];\n+            auto elsopt_t = plain_ty(ty_nil);\n+            alt (elsopt) {\n+                case (some[ast.block](?els)) {\n+                    auto els_1 = check_block(fcx, els);\n+                    elsopt_1 = some[ast.block](els_1);\n+                    elsopt_t = block_ty(els_1);\n+                }\n+            }\n+            demand(fcx.ccx, expr.span, thn_t, elsopt_t);\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_if(cond_1, thn_1, elsopt_1,\n+                                                    ast.ann_type(thn_t)));\n+        }\n+\n+        case (ast.expr_call(?f, ?args, _)) {\n+            auto f_1 = check_expr(fcx, f);\n+            let @ty ret_t = plain_ty(ty_nil);\n+            alt (expr_ty(f_1).struct) {\n+                case (ty_fn(_, ?r)) {\n+                    ret_t = r;\n+                }\n+                case (_) {\n+                    fcx.ccx.sess.span_err(f_1.span,\n+                                          \"callee has non-function type: \"\n+                                          + ty_to_str(expr_ty(f_1)));\n+                }\n+            }\n+            let vec[@ast.expr] args_1 = vec();\n+            let vec[arg] args_t = vec();\n+            for (@ast.expr a in args) {\n+                auto a_1 = check_expr(fcx, a);\n+                append[@ast.expr](args_1, a_1);\n+                append[arg](args_t, rec(mode=ast.val, ty=expr_ty(a_1)));\n+            }\n+            demand(fcx.ccx, expr.span, expr_ty(f_1),\n+                   plain_ty(ty_fn(args_t, ret_t)));\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_call(f_1, args_1,\n+                                                      ast.ann_type(ret_t)));\n+        }\n+\n         case (_) {\n             // TODO\n             ret expr;\n         }\n     }\n }\n \n-fn check_stmt(@env e, @ty_table locals, @ty ret_ty, &@ast.stmt stmt)\n+fn next_ty_var(&fn_ctxt fcx) -> @ty {\n+    auto t = plain_ty(ty_var(fcx.ccx.next_var_id));\n+    fcx.ccx.next_var_id += 1;\n+    ret t;\n+}\n+\n+fn check_stmt(&fn_ctxt fcx, &@ast.stmt stmt)\n         -> @ast.stmt {\n     alt (stmt.node) {\n         case (ast.stmt_decl(?decl)) {\n@@ -812,26 +897,25 @@ fn check_stmt(@env e, @ty_table locals, @ty ret_ty, &@ast.stmt stmt)\n                     alt (local.ty) {\n                         case (none[@ast.ty]) {\n                             // Auto slot. Assign a ty_var.\n-                            local_ty = plain_ty(ty_var(e.next_var_id));\n-                            e.next_var_id += 1;\n+                            local_ty = next_ty_var(fcx);\n                         }\n \n                         case (some[@ast.ty](?ast_ty)) {\n-                            local_ty = ast_ty_to_ty_env(e, ast_ty);\n+                            local_ty = ast_ty_to_ty_crate(fcx.ccx, ast_ty);\n                         }\n                     }\n-                    locals.insert(local.id, local_ty);\n+                    fcx.locals.insert(local.id, local_ty);\n \n                     auto rhs_ty = local_ty;\n                     auto init = local.init;\n                     alt (local.init) {\n                         case (some[@ast.expr](?expr)) {\n-                            auto expr_t = check_expr(e, locals, expr);\n-                            rhs_ty = type_of(expr_t);\n+                            auto expr_t = check_expr(fcx, expr);\n+                            rhs_ty = expr_ty(expr_t);\n                             init = some[@ast.expr](expr_t);\n                         }\n                     }\n-                    demand(e, decl.span, local_ty, rhs_ty);\n+                    demand(fcx.ccx, decl.span, local_ty, rhs_ty);\n                     auto local_1 = @rec(init = init with *local);\n                     auto decl_1 = @rec(node=ast.decl_local(local_1)\n                                        with *decl);\n@@ -850,37 +934,40 @@ fn check_stmt(@env e, @ty_table locals, @ty ret_ty, &@ast.stmt stmt)\n         case (ast.stmt_ret(?expr_opt)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n-                    if (!are_compatible(e, ret_ty, plain_ty(ty_nil))) {\n-                        e.sess.err(\"ret; in function returning non-void\");\n+                    if (!are_compatible(fcx.ccx, fcx.ret_ty,\n+                                        plain_ty(ty_nil))) {\n+                        fcx.ccx.sess.err(\"ret; in function \"\n+                                         + \"returning non-nil\");\n                     }\n \n                     ret stmt;\n                 }\n \n                 case (some[@ast.expr](?expr)) {\n-                    auto expr_t = check_expr(e, locals, expr);\n-                    demand(e, expr.span, ret_ty, type_of(expr_t));\n+                    auto expr_t = check_expr(fcx, expr);\n+                    demand(fcx.ccx, expr.span, fcx.ret_ty, expr_ty(expr_t));\n                     ret @fold.respan[ast.stmt_](stmt.span,\n                                                 ast.stmt_ret(some(expr_t)));\n                 }\n             }\n         }\n \n         case (ast.stmt_log(?expr)) {\n-            auto expr_t = check_expr(e, locals, expr);\n+            auto expr_t = check_expr(fcx, expr);\n             ret @fold.respan[ast.stmt_](stmt.span, ast.stmt_log(expr_t));\n         }\n \n         case (ast.stmt_check_expr(?expr)) {\n-            auto expr_t = check_expr(e, locals, expr);\n-            demand(e, expr.span, plain_ty(ty_bool), type_of(expr_t));\n+            auto expr_t = check_expr(fcx, expr);\n+            demand(fcx.ccx, expr.span, plain_ty(ty_bool), expr_ty(expr_t));\n             ret @fold.respan[ast.stmt_](stmt.span,\n                                         ast.stmt_check_expr(expr_t));\n         }\n \n         case (ast.stmt_expr(?expr)) {\n-            auto expr_t = check_expr(e, locals, expr);\n-            if (!are_compatible(e, type_of(expr_t), plain_ty(ty_nil))) {\n+            auto expr_t = check_expr(fcx, expr);\n+            if (!are_compatible(fcx.ccx, expr_ty(expr_t),\n+                                plain_ty(ty_nil))) {\n                 // TODO: real warning function\n                 log \"warning: expression used as statement should have \" +\n                     \"void type\";\n@@ -893,32 +980,37 @@ fn check_stmt(@env e, @ty_table locals, @ty ret_ty, &@ast.stmt stmt)\n     fail;\n }\n \n-fn check_block(&@env e, &@ty_table locals, @ty ret_ty, &ast.block block)\n-        -> ast.block {\n-    auto f = bind check_stmt(e, locals, ret_ty, _);\n-    auto stmts_t = _vec.map[@ast.stmt,@ast.stmt](f, block.node.stmts);\n+fn check_block(&fn_ctxt fcx, &ast.block block) -> ast.block {\n+    let vec[@ast.stmt] stmts = vec();\n+    for (@ast.stmt s in block.node.stmts) {\n+        append[@ast.stmt](stmts, check_stmt(fcx, s));\n+    }\n     ret fold.respan[ast.block_](block.span,\n-                                rec(stmts=stmts_t, index=block.node.index));\n+                                rec(stmts=stmts, index=block.node.index));\n }\n \n-fn check_fn(&@env e, &span sp, ast.ident ident, &ast._fn f, ast.def_id id,\n-            ast.ann ann) -> @ast.item {\n+fn check_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n+            ast.def_id id, ast.ann ann) -> @ast.item {\n     auto local_ty_table = @common.new_def_hash[@ty]();\n \n     // Store the type of each argument in the table.\n     let vec[arg] inputs = vec();\n     for (ast.arg arg in f.inputs) {\n-        auto input_ty = ast_ty_to_ty_env(e, arg.ty);\n+        auto input_ty = ast_ty_to_ty_crate(ccx, arg.ty);\n         inputs += vec(rec(mode=arg.mode, ty=input_ty));\n         local_ty_table.insert(arg.id, input_ty);\n     }\n \n-    auto output_ty = ast_ty_to_ty_env(e, f.output);\n+    auto output_ty = ast_ty_to_ty_crate(ccx, f.output);\n     auto fn_sty = ty_fn(inputs, output_ty);\n     auto fn_ann = ast.ann_type(plain_ty(fn_sty));\n \n-    auto block_t = check_block(e, local_ty_table, output_ty, f.body);\n-    auto block_wb = writeback(e, local_ty_table, block_t);\n+    let fn_ctxt fcx = rec(ret_ty = output_ty,\n+                          locals = local_ty_table,\n+                          ccx = ccx);\n+\n+    auto block_t = check_block(fcx, f.body);\n+    auto block_wb = writeback(fcx, block_t);\n     auto fn_t = rec(inputs=f.inputs, output=f.output, body=block_wb);\n     ret @fold.respan[ast.item_](sp, ast.item_fn(ident, fn_t, id, fn_ann));\n }\n@@ -931,15 +1023,15 @@ fn check_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n     auto hasher = hash_int;\n     auto eqer = eq_int;\n \n-    auto e = @rec(sess=sess,\n-                  item_types=result._1,\n-                  bindings = map.mk_hashmap[int,@ty](hasher, eqer),\n-                  mutable next_var_id=0);\n+    auto ccx = @rec(sess=sess,\n+                    item_types=result._1,\n+                    bindings = map.mk_hashmap[int,@ty](hasher, eqer),\n+                    mutable next_var_id=0);\n \n-    auto fld = fold.new_identity_fold[@env]();\n+    auto fld = fold.new_identity_fold[@crate_ctxt]();\n     auto f = check_fn;  // FIXME: trans_const_lval bug\n     fld = @rec(fold_item_fn = f with *fld);\n-    ret fold.fold_crate[@env](e, fld, result._0);\n+    ret fold.fold_crate[@crate_ctxt](ccx, fld, result._0);\n }\n \n //"}]}