{"sha": "f07feca40c3eed82592b1e4862f9e67f57a880d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwN2ZlY2E0MGMzZWVkODI1OTJiMWU0ODYyZjllNjdmNTdhODgwZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-14T10:10:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-14T10:10:14Z"}, "message": "Auto merge of #7346 - lengyijun:redundant_clone_5707, r=oli-obk\n\nfix 5707\n\nchangelog: ``[`redundant_clone`]``, fix #5707\n\n# Root problem of #5707 :\n```\n&2:&mut HashMap = &mut _4;\n&3:&str = & _5;\n_1 = HashMap::insert(move _2,move _3, _);\n```\n\ngenerate PossibleBorrower(_2,_1) and PossibleBorrower(_3,_1).\n\nHowever, it misses PossibleBorrower(_3,_2).\n\n# My solution to #5707 :\n\nWhen meet a function call, we should:\n1. build PossibleBorrower between borrow parameters and return value (currently)\n2. build PossibleBorrower between immutable borrow parameters and mutable borrow parameters (*add*)\n3. build PossibleBorrower inside mutable borrow parameters (*add*)\n\nFor example:\n```\n_2: &mut _22;\n_3: &mut _;\n_4: & _;\n_5: & _;\n_1 = call(move _2, move _3, move _4, move _5);\n```\nwe need to build\n1. return value with parameter(current implementataion)\n PossibleBorrower(_2,_1)\n PossibleBorrower(_3,_1)\n PossibleBorrower(_4,_1)\n PossibleBorrower(_5,_1)\n\n2. between mutable borrow and immutable borrow\nPossibleBorrower(_4,_2)\nPossibleBorrower(_5,_2)\nPossibleBorrower(_4,_3)\nPossibleBorrower(_5,_3)\n\n3. between mutable borrow and mutable borrow\nPossibleBorrower(_3,_2)\nPossibleBorrower(_2,_3)\n\n  But that's not enough.\n Modification to _2 actually apply to _22.\n  So I write a `PossibleBorrowed` visitor, which tracks (borrower => possible borrowed) relation.\n  For example (_2 => _22).\n  However, a lot of problems exist here.\n\n## Known Problems:\n  1. not sure all `&mut`'s origin are collected.\n  I'm not sure how to deal with `&mut` when meet a function call, so I didn't do it currently.\n  Also, my implement is not flow sensitive, so it's not accurate.\n\n```\nfoo(_2:&mut _, _3: &_)\n```\nThis pr doesn't count _3 as origin of _2.\n\n 2. introduce false negative\n`foo(_2, _3)` will  emit PossibleBorrower(_3,_2) in this pr, but _3 and _2 may not have relation.\nClippy may feel that _3 is still in use because of _2, but actually, _3 is on longer needed and can be moved.\n\n## Insight\n  The key problem is determine where every `&mut` come from accurately.\n  I think Polonius is an elegant solution to it. Polonius is flow sensitive and accurate.\n  But I'm uncertain about whether we can import Polonius in rust-clippy currently.\n  This pr actually is part of Polonius' functionality, I think.\n\n# TODO\n1. `cargo test` can't pass yet due to similar variable name", "tree": {"sha": "6ac8856bfcea4a8689b6a50fb1b9cff1091d5e65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ac8856bfcea4a8689b6a50fb1b9cff1091d5e65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f07feca40c3eed82592b1e4862f9e67f57a880d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f07feca40c3eed82592b1e4862f9e67f57a880d1", "html_url": "https://github.com/rust-lang/rust/commit/f07feca40c3eed82592b1e4862f9e67f57a880d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f07feca40c3eed82592b1e4862f9e67f57a880d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8131445e536869b4b73b07d1be1b2e03f7493898", "url": "https://api.github.com/repos/rust-lang/rust/commits/8131445e536869b4b73b07d1be1b2e03f7493898", "html_url": "https://github.com/rust-lang/rust/commit/8131445e536869b4b73b07d1be1b2e03f7493898"}, {"sha": "10910020ecc56373336f294c827e6f1f62616d03", "url": "https://api.github.com/repos/rust-lang/rust/commits/10910020ecc56373336f294c827e6f1f62616d03", "html_url": "https://github.com/rust-lang/rust/commit/10910020ecc56373336f294c827e6f1f62616d03"}], "stats": {"total": 184, "additions": 168, "deletions": 16}, "files": [{"sha": "56ef95a88c88081da4b83fbc44da66b8759df5cf", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 102, "deletions": 6, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f07feca40c3eed82592b1e4862f9e67f57a880d1/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07feca40c3eed82592b1e4862f9e67f57a880d1/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=f07feca40c3eed82592b1e4862f9e67f57a880d1", "patch": "@@ -12,6 +12,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::{\n     self, traversal,\n     visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor as _},\n+    Mutability,\n };\n use rustc_middle::ty::{self, fold::TypeVisitor, Ty};\n use rustc_mir::dataflow::{Analysis, AnalysisDomain, GenKill, GenKillAnalysis, ResultsCursor};\n@@ -87,13 +88,18 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n \n         let mir = cx.tcx.optimized_mir(def_id.to_def_id());\n \n+        let possible_origin = {\n+            let mut vis = PossibleOriginVisitor::new(mir);\n+            vis.visit_body(mir);\n+            vis.into_map(cx)\n+        };\n         let maybe_storage_live_result = MaybeStorageLive\n             .into_engine(cx.tcx, mir)\n             .pass_name(\"redundant_clone\")\n             .iterate_to_fixpoint()\n             .into_results_cursor(mir);\n         let mut possible_borrower = {\n-            let mut vis = PossibleBorrowerVisitor::new(cx, mir);\n+            let mut vis = PossibleBorrowerVisitor::new(cx, mir, possible_origin);\n             vis.visit_body(mir);\n             vis.into_map(cx, maybe_storage_live_result)\n         };\n@@ -509,14 +515,20 @@ struct PossibleBorrowerVisitor<'a, 'tcx> {\n     possible_borrower: TransitiveRelation<mir::Local>,\n     body: &'a mir::Body<'tcx>,\n     cx: &'a LateContext<'tcx>,\n+    possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n }\n \n impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>, body: &'a mir::Body<'tcx>) -> Self {\n+    fn new(\n+        cx: &'a LateContext<'tcx>,\n+        body: &'a mir::Body<'tcx>,\n+        possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+    ) -> Self {\n         Self {\n             possible_borrower: TransitiveRelation::default(),\n             cx,\n             body,\n+            possible_origin,\n         }\n     }\n \n@@ -585,21 +597,105 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n             ..\n         } = &terminator.kind\n         {\n+            // TODO add doc\n             // If the call returns something with lifetimes,\n             // let's conservatively assume the returned value contains lifetime of all the arguments.\n             // For example, given `let y: Foo<'a> = foo(x)`, `y` is considered to be a possible borrower of `x`.\n-            if ContainsRegion.visit_ty(self.body.local_decls[*dest].ty).is_continue() {\n-                return;\n-            }\n+\n+            let mut immutable_borrowers = vec![];\n+            let mut mutable_borrowers = vec![];\n \n             for op in args {\n                 match op {\n                     mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n-                        self.possible_borrower.add(p.local, *dest);\n+                        if let ty::Ref(_, _, Mutability::Mut) = self.body.local_decls[p.local].ty.kind() {\n+                            mutable_borrowers.push(p.local);\n+                        } else {\n+                            immutable_borrowers.push(p.local);\n+                        }\n                     },\n                     mir::Operand::Constant(..) => (),\n                 }\n             }\n+\n+            let mut mutable_variables: Vec<mir::Local> = mutable_borrowers\n+                .iter()\n+                .filter_map(|r| self.possible_origin.get(r))\n+                .flat_map(HybridBitSet::iter)\n+                .collect();\n+\n+            if ContainsRegion.visit_ty(self.body.local_decls[*dest].ty).is_break() {\n+                mutable_variables.push(*dest);\n+            }\n+\n+            for y in mutable_variables {\n+                for x in &immutable_borrowers {\n+                    self.possible_borrower.add(*x, y);\n+                }\n+                for x in &mutable_borrowers {\n+                    self.possible_borrower.add(*x, y);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Collect possible borrowed for every `&mut` local.\n+/// For exampel, `_1 = &mut _2` generate _1: {_2,...}\n+/// Known Problems: not sure all borrowed are tracked\n+struct PossibleOriginVisitor<'a, 'tcx> {\n+    possible_origin: TransitiveRelation<mir::Local>,\n+    body: &'a mir::Body<'tcx>,\n+}\n+\n+impl<'a, 'tcx> PossibleOriginVisitor<'a, 'tcx> {\n+    fn new(body: &'a mir::Body<'tcx>) -> Self {\n+        Self {\n+            possible_origin: TransitiveRelation::default(),\n+            body,\n+        }\n+    }\n+\n+    fn into_map(self, cx: &LateContext<'tcx>) -> FxHashMap<mir::Local, HybridBitSet<mir::Local>> {\n+        let mut map = FxHashMap::default();\n+        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n+            if is_copy(cx, self.body.local_decls[row].ty) {\n+                continue;\n+            }\n+\n+            let borrowers = self.possible_origin.reachable_from(&row);\n+            if !borrowers.is_empty() {\n+                let mut bs = HybridBitSet::new_empty(self.body.local_decls.len());\n+                for &c in borrowers {\n+                    if c != mir::Local::from_usize(0) {\n+                        bs.insert(c);\n+                    }\n+                }\n+\n+                if !bs.is_empty() {\n+                    map.insert(row, bs);\n+                }\n+            }\n+        }\n+        map\n+    }\n+}\n+\n+impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleOriginVisitor<'a, 'tcx> {\n+    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n+        let lhs = place.local;\n+        match rvalue {\n+            // Only consider `&mut`, which can modify origin place\n+            mir::Rvalue::Ref(_, rustc_middle::mir::BorrowKind::Mut { .. }, borrowed) |\n+            // _2: &mut _;\n+            // _3 = move _2\n+            mir::Rvalue::Use(mir::Operand::Move(borrowed))  |\n+            // _3 = move _2 as &mut _;\n+            mir::Rvalue::Cast(_, mir::Operand::Move(borrowed), _)\n+                => {\n+                self.possible_origin.add(lhs, borrowed.local);\n+            },\n+            _ => {},\n         }\n     }\n }"}, {"sha": "2d711082746e73aab40867f0bcc2285137e5aca2", "filename": "tests/ui/redundant_clone.fixed", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f07feca40c3eed82592b1e4862f9e67f57a880d1/tests%2Fui%2Fredundant_clone.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f07feca40c3eed82592b1e4862f9e67f57a880d1/tests%2Fui%2Fredundant_clone.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.fixed?ref=f07feca40c3eed82592b1e4862f9e67f57a880d1", "patch": "@@ -55,6 +55,8 @@ fn main() {\n     issue_5405();\n     manually_drop();\n     clone_then_move_cloned();\n+    hashmap_neg();\n+    false_negative_5707();\n }\n \n #[derive(Clone)]\n@@ -206,3 +208,29 @@ fn clone_then_move_cloned() {\n     let mut x = S(String::new());\n     x.0.clone().chars().for_each(|_| x.m());\n }\n+\n+fn hashmap_neg() {\n+    // issue 5707\n+    use std::collections::HashMap;\n+    use std::path::PathBuf;\n+\n+    let p = PathBuf::from(\"/\");\n+\n+    let mut h: HashMap<&str, &str> = HashMap::new();\n+    h.insert(\"orig-p\", p.to_str().unwrap());\n+\n+    let mut q = p.clone();\n+    q.push(\"foo\");\n+\n+    println!(\"{:?} {}\", h, q.display());\n+}\n+\n+fn false_negative_5707() {\n+    fn foo(_x: &Alpha, _y: &mut Alpha) {}\n+\n+    let x = Alpha;\n+    let mut y = Alpha;\n+    foo(&x, &mut y);\n+    let _z = x.clone(); // pr 7346 can't lint on `x`\n+    drop(y);\n+}"}, {"sha": "bd3d7365229fb83ccd13ca555e53d9941f867c43", "filename": "tests/ui/redundant_clone.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f07feca40c3eed82592b1e4862f9e67f57a880d1/tests%2Fui%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07feca40c3eed82592b1e4862f9e67f57a880d1/tests%2Fui%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.rs?ref=f07feca40c3eed82592b1e4862f9e67f57a880d1", "patch": "@@ -55,6 +55,8 @@ fn main() {\n     issue_5405();\n     manually_drop();\n     clone_then_move_cloned();\n+    hashmap_neg();\n+    false_negative_5707();\n }\n \n #[derive(Clone)]\n@@ -206,3 +208,29 @@ fn clone_then_move_cloned() {\n     let mut x = S(String::new());\n     x.0.clone().chars().for_each(|_| x.m());\n }\n+\n+fn hashmap_neg() {\n+    // issue 5707\n+    use std::collections::HashMap;\n+    use std::path::PathBuf;\n+\n+    let p = PathBuf::from(\"/\");\n+\n+    let mut h: HashMap<&str, &str> = HashMap::new();\n+    h.insert(\"orig-p\", p.to_str().unwrap());\n+\n+    let mut q = p.clone();\n+    q.push(\"foo\");\n+\n+    println!(\"{:?} {}\", h, q.display());\n+}\n+\n+fn false_negative_5707() {\n+    fn foo(_x: &Alpha, _y: &mut Alpha) {}\n+\n+    let x = Alpha;\n+    let mut y = Alpha;\n+    foo(&x, &mut y);\n+    let _z = x.clone(); // pr 7346 can't lint on `x`\n+    drop(y);\n+}"}, {"sha": "fbc90493ae94b85986e8381ef82e395fbc202e9e", "filename": "tests/ui/redundant_clone.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f07feca40c3eed82592b1e4862f9e67f57a880d1/tests%2Fui%2Fredundant_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f07feca40c3eed82592b1e4862f9e67f57a880d1/tests%2Fui%2Fredundant_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.stderr?ref=f07feca40c3eed82592b1e4862f9e67f57a880d1", "patch": "@@ -108,61 +108,61 @@ LL |     let _t = tup.0.clone();\n    |              ^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:63:25\n+  --> $DIR/redundant_clone.rs:65:25\n    |\n LL |     if b { (a.clone(), a.clone()) } else { (Alpha, a) }\n    |                         ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:63:24\n+  --> $DIR/redundant_clone.rs:65:24\n    |\n LL |     if b { (a.clone(), a.clone()) } else { (Alpha, a) }\n    |                        ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:120:15\n+  --> $DIR/redundant_clone.rs:122:15\n    |\n LL |     let _s = s.clone();\n    |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:120:14\n+  --> $DIR/redundant_clone.rs:122:14\n    |\n LL |     let _s = s.clone();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:121:15\n+  --> $DIR/redundant_clone.rs:123:15\n    |\n LL |     let _t = t.clone();\n    |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:121:14\n+  --> $DIR/redundant_clone.rs:123:14\n    |\n LL |     let _t = t.clone();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:131:19\n+  --> $DIR/redundant_clone.rs:133:19\n    |\n LL |         let _f = f.clone();\n    |                   ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:131:18\n+  --> $DIR/redundant_clone.rs:133:18\n    |\n LL |         let _f = f.clone();\n    |                  ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:143:14\n+  --> $DIR/redundant_clone.rs:145:14\n    |\n LL |     let y = x.clone().join(\"matthias\");\n    |              ^^^^^^^^ help: remove this\n    |\n note: cloned value is neither consumed nor mutated\n-  --> $DIR/redundant_clone.rs:143:13\n+  --> $DIR/redundant_clone.rs:145:13\n    |\n LL |     let y = x.clone().join(\"matthias\");\n    |             ^^^^^^^^^"}]}