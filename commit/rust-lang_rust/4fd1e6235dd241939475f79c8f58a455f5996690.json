{"sha": "4fd1e6235dd241939475f79c8f58a455f5996690", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZDFlNjIzNWRkMjQxOTM5NDc1Zjc5YzhmNThhNDU1ZjU5OTY2OTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-13T19:11:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-13T19:11:47Z"}, "message": "auto merge of #20367 : retep998/rust/master, r=alexcrichton\n\nAlso adjusted some of the FFI definitions because apparently they don't use the long pointer prefix.\r\nGives a free performance boost because `SRWLock` is several times faster than `CriticalRegion` on every Windows system tested.\r\nFixes #19962", "tree": {"sha": "4cd6af2940b0242cf26865b3ea7d4a4ded315e50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cd6af2940b0242cf26865b3ea7d4a4ded315e50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fd1e6235dd241939475f79c8f58a455f5996690", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fd1e6235dd241939475f79c8f58a455f5996690", "html_url": "https://github.com/rust-lang/rust/commit/4fd1e6235dd241939475f79c8f58a455f5996690", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fd1e6235dd241939475f79c8f58a455f5996690/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e94a9f033eb79b3b4fb037722366644650e8e16c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e94a9f033eb79b3b4fb037722366644650e8e16c", "html_url": "https://github.com/rust-lang/rust/commit/e94a9f033eb79b3b4fb037722366644650e8e16c"}, {"sha": "ee1ca88213133a58f0a9d234f03babbebeb7c5d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee1ca88213133a58f0a9d234f03babbebeb7c5d8", "html_url": "https://github.com/rust-lang/rust/commit/ee1ca88213133a58f0a9d234f03babbebeb7c5d8"}], "stats": {"total": 132, "additions": 49, "deletions": 83}, "files": [{"sha": "db8038006fd6a81451a3783951609bddb7f8719f", "filename": "src/libstd/sys/windows/condvar.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4fd1e6235dd241939475f79c8f58a455f5996690/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd1e6235dd241939475f79c8f58a455f5996690/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs?ref=4fd1e6235dd241939475f79c8f58a455f5996690", "patch": "@@ -27,16 +27,18 @@ impl Condvar {\n \n     #[inline]\n     pub unsafe fn wait(&self, mutex: &Mutex) {\n-        let r = ffi::SleepConditionVariableCS(self.inner.get(),\n-                                              mutex::raw(mutex),\n-                                              libc::INFINITE);\n+        let r = ffi::SleepConditionVariableSRW(self.inner.get(),\n+                                               mutex::raw(mutex),\n+                                               libc::INFINITE,\n+                                               0);\n         debug_assert!(r != 0);\n     }\n \n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        let r = ffi::SleepConditionVariableCS(self.inner.get(),\n-                                              mutex::raw(mutex),\n-                                              dur.num_milliseconds() as DWORD);\n+        let r = ffi::SleepConditionVariableSRW(self.inner.get(),\n+                                               mutex::raw(mutex),\n+                                               dur.num_milliseconds() as DWORD,\n+                                               0);\n         if r == 0 {\n             const ERROR_TIMEOUT: DWORD = 0x5B4;\n             debug_assert_eq!(os::errno() as uint, ERROR_TIMEOUT as uint);"}, {"sha": "828ad795ed3b4eaa3871fb0d4c415fa79e714cab", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 25, "deletions": 47, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4fd1e6235dd241939475f79c8f58a455f5996690/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd1e6235dd241939475f79c8f58a455f5996690/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=4fd1e6235dd241939475f79c8f58a455f5996690", "patch": "@@ -8,73 +8,51 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::v1::*;\n-\n-use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n-use alloc::{self, heap};\n-\n-use libc::DWORD;\n+use marker::Sync;\n+use cell::UnsafeCell;\n use sys::sync as ffi;\n \n-const SPIN_COUNT: DWORD = 4000;\n+pub struct Mutex { inner: UnsafeCell<ffi::SRWLOCK> }\n \n-pub struct Mutex { inner: AtomicUsize }\n-\n-pub const MUTEX_INIT: Mutex = Mutex { inner: ATOMIC_USIZE_INIT };\n+pub const MUTEX_INIT: Mutex = Mutex {\n+    inner: UnsafeCell { value: ffi::SRWLOCK_INIT }\n+};\n \n unsafe impl Sync for Mutex {}\n \n #[inline]\n-pub unsafe fn raw(m: &Mutex) -> ffi::LPCRITICAL_SECTION {\n-    m.get()\n+pub unsafe fn raw(m: &Mutex) -> ffi::PSRWLOCK {\n+    m.inner.get()\n }\n \n+// So you might be asking why we're using SRWLock instead of CriticalSection?\n+//\n+// 1. SRWLock is several times faster than CriticalSection according to benchmarks performed on both\n+// Windows 8 and Windows 7.\n+//\n+// 2. CriticalSection allows recursive locking while SRWLock deadlocks. The Unix implementation\n+// deadlocks so consistency is preferred. See #19962 for more details.\n+//\n+// 3. While CriticalSection is fair and SRWLock is not, the current Rust policy is there there are\n+// no guarantees of fairness.\n+\n impl Mutex {\n     #[inline]\n-    pub unsafe fn new() -> Mutex {\n-        Mutex { inner: AtomicUsize::new(init_lock() as uint) }\n-    }\n+    pub unsafe fn new() -> Mutex { MUTEX_INIT }\n     #[inline]\n     pub unsafe fn lock(&self) {\n-        ffi::EnterCriticalSection(self.get())\n+        ffi::AcquireSRWLockExclusive(self.inner.get())\n     }\n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        ffi::TryEnterCriticalSection(self.get()) != 0\n+        ffi::TryAcquireSRWLockExclusive(self.inner.get()) != 0\n     }\n     #[inline]\n     pub unsafe fn unlock(&self) {\n-        ffi::LeaveCriticalSection(self.get())\n+        ffi::ReleaseSRWLockExclusive(self.inner.get())\n     }\n+    #[inline]\n     pub unsafe fn destroy(&self) {\n-        let lock = self.inner.swap(0, Ordering::SeqCst);\n-        if lock != 0 { free_lock(lock as ffi::LPCRITICAL_SECTION) }\n-    }\n-\n-    unsafe fn get(&self) -> ffi::LPCRITICAL_SECTION {\n-        match self.inner.load(Ordering::SeqCst) {\n-            0 => {}\n-            n => return n as ffi::LPCRITICAL_SECTION\n-        }\n-        let lock = init_lock();\n-        match self.inner.compare_and_swap(0, lock as uint, Ordering::SeqCst) {\n-            0 => return lock as ffi::LPCRITICAL_SECTION,\n-            _ => {}\n-        }\n-        free_lock(lock);\n-        return self.inner.load(Ordering::SeqCst) as ffi::LPCRITICAL_SECTION;\n+        // ...\n     }\n }\n-\n-unsafe fn init_lock() -> ffi::LPCRITICAL_SECTION {\n-    let block = heap::allocate(ffi::CRITICAL_SECTION_SIZE, 8)\n-                        as ffi::LPCRITICAL_SECTION;\n-    if block.is_null() { alloc::oom() }\n-    ffi::InitializeCriticalSectionAndSpinCount(block, SPIN_COUNT);\n-    return block;\n-}\n-\n-unsafe fn free_lock(h: ffi::LPCRITICAL_SECTION) {\n-    ffi::DeleteCriticalSection(h);\n-    heap::deallocate(h as *mut _, ffi::CRITICAL_SECTION_SIZE, 8);\n-}"}, {"sha": "d60646b7db915cdd9e568619adf8d017b598bc6e", "filename": "src/libstd/sys/windows/sync.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4fd1e6235dd241939475f79c8f58a455f5996690/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd1e6235dd241939475f79c8f58a455f5996690/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs?ref=4fd1e6235dd241939475f79c8f58a455f5996690", "patch": "@@ -8,17 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::{BOOL, DWORD, c_void, LPVOID};\n+use libc::{BOOL, DWORD, c_void, LPVOID, c_ulong};\n use libc::types::os::arch::extra::BOOLEAN;\n \n-pub type LPCRITICAL_SECTION = *mut c_void;\n-pub type LPCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n-pub type LPSRWLOCK = *mut SRWLOCK;\n-\n-#[cfg(target_arch = \"x86\")]\n-pub const CRITICAL_SECTION_SIZE: uint = 24;\n-#[cfg(target_arch = \"x86_64\")]\n-pub const CRITICAL_SECTION_SIZE: uint = 40;\n+pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n+pub type PSRWLOCK = *mut SRWLOCK;\n+pub type ULONG = c_ulong;\n \n #[repr(C)]\n pub struct CONDITION_VARIABLE { pub ptr: LPVOID }\n@@ -31,28 +26,19 @@ pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {\n pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: 0 as *mut _ };\n \n extern \"system\" {\n-    // critical sections\n-    pub fn InitializeCriticalSectionAndSpinCount(\n-                    lpCriticalSection: LPCRITICAL_SECTION,\n-                    dwSpinCount: DWORD) -> BOOL;\n-    pub fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n-    pub fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n-    pub fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n-    pub fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;\n-\n     // condition variables\n-    pub fn SleepConditionVariableCS(ConditionVariable: LPCONDITION_VARIABLE,\n-                                    CriticalSection: LPCRITICAL_SECTION,\n-                                    dwMilliseconds: DWORD) -> BOOL;\n-    pub fn WakeConditionVariable(ConditionVariable: LPCONDITION_VARIABLE);\n-    pub fn WakeAllConditionVariable(ConditionVariable: LPCONDITION_VARIABLE);\n+    pub fn SleepConditionVariableSRW(ConditionVariable: PCONDITION_VARIABLE,\n+                                     SRWLock: PSRWLOCK,\n+                                     dwMilliseconds: DWORD,\n+                                     Flags: ULONG) -> BOOL;\n+    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n+    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n \n     // slim rwlocks\n-    pub fn AcquireSRWLockExclusive(SRWLock: LPSRWLOCK);\n-    pub fn AcquireSRWLockShared(SRWLock: LPSRWLOCK);\n-    pub fn ReleaseSRWLockExclusive(SRWLock: LPSRWLOCK);\n-    pub fn ReleaseSRWLockShared(SRWLock: LPSRWLOCK);\n-    pub fn TryAcquireSRWLockExclusive(SRWLock: LPSRWLOCK) -> BOOLEAN;\n-    pub fn TryAcquireSRWLockShared(SRWLock: LPSRWLOCK) -> BOOLEAN;\n+    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);\n+    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);\n+    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);\n+    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK);\n+    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;\n+    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;\n }\n-"}]}