{"sha": "f52727b8e65ab15a8e12a3927ff3855e2922eda7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MjcyN2I4ZTY1YWIxNWE4ZTEyYTM5MjdmZjM4NTVlMjkyMmVkYTc=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-18T13:17:22Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-18T13:17:22Z"}, "message": "Implement some binops for TyRawPtr", "tree": {"sha": "7d773926035f2961d53a372915072dc1dbc2b7f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d773926035f2961d53a372915072dc1dbc2b7f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f52727b8e65ab15a8e12a3927ff3855e2922eda7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f52727b8e65ab15a8e12a3927ff3855e2922eda7", "html_url": "https://github.com/rust-lang/rust/commit/f52727b8e65ab15a8e12a3927ff3855e2922eda7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f52727b8e65ab15a8e12a3927ff3855e2922eda7/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdc625e18a38c3853218c096a632a6841b0d579f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdc625e18a38c3853218c096a632a6841b0d579f", "html_url": "https://github.com/rust-lang/rust/commit/fdc625e18a38c3853218c096a632a6841b0d579f"}], "stats": {"total": 141, "additions": 111, "deletions": 30}, "files": [{"sha": "9f9d518f3907f0c0ab89f946eb9500e8c5b1c0d2", "filename": "example.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f52727b8e65ab15a8e12a3927ff3855e2922eda7/example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52727b8e65ab15a8e12a3927ff3855e2922eda7/example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example.rs?ref=f52727b8e65ab15a8e12a3927ff3855e2922eda7", "patch": "@@ -6,7 +6,11 @@\n trait Sized {}\n \n #[lang=\"copy\"]\n-trait Copy {}\n+unsafe trait Copy {}\n+\n+unsafe impl Copy for u8 {}\n+unsafe impl<'a, T: ?Sized> Copy for &'a T {}\n+unsafe impl<T: ?Sized> Copy for *const T {}\n \n #[lang=\"freeze\"]\n trait Freeze {}\n@@ -27,6 +31,22 @@ impl Mul for u8 {\n     }\n }\n \n+#[lang = \"eq\"]\n+pub trait PartialEq<Rhs: ?Sized = Self> {\n+    fn eq(&self, other: &Rhs) -> bool;\n+    fn ne(&self, other: &Rhs) -> bool;\n+}\n+\n+impl PartialEq for u8 {\n+    fn eq(&self, other: &u8) -> bool { (*self) == (*other) }\n+    fn ne(&self, other: &u8) -> bool { (*self) != (*other) }\n+}\n+\n+impl<T: ?Sized> PartialEq for *const T {\n+    fn eq(&self, other: &*const T) -> bool { *self == *other }\n+    fn ne(&self, other: &*const T) -> bool { *self != *other }\n+}\n+\n #[lang=\"panic\"]\n fn panic(_expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n     loop {}\n@@ -89,3 +109,7 @@ fn promoted_val() -> &'static u8 {\n fn cast_ref_to_raw_ptr(abc: &u8) -> *const u8 {\n     abc as *const u8\n }\n+\n+fn cmp_raw_ptr(a: *const u8, b: *const u8) -> bool {\n+    a == b\n+}"}, {"sha": "37f350b6500aeee5c788aae0b637b9cba3358baa", "filename": "src/base.rs", "status": "modified", "additions": 85, "deletions": 28, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/f52727b8e65ab15a8e12a3927ff3855e2922eda7/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52727b8e65ab15a8e12a3927ff3855e2922eda7/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=f52727b8e65ab15a8e12a3927ff3855e2922eda7", "patch": "@@ -327,6 +327,9 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                         TypeVariants::TyInt(_) => {\n                             trans_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, true, false)\n                         }\n+                        TypeVariants::TyRawPtr(..) => {\n+                            trans_ptr_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, false)\n+                        }\n                         _ => unimplemented!(\"bin op {:?} for {:?}\", bin_op, ty),\n                     };\n                     lval.write_cvalue(fx, res);\n@@ -467,36 +470,90 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n     Ok(())\n }\n \n+macro_rules! binop_match {\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, bug) => {\n+        bug!(\"bin op {} on {} lhs: {:?} rhs: {:?}\", stringify!($var), $bug_fmt, $lhs, $rhs)\n+    };\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, icmp($cc:ident)) => {{\n+        let b = $fx.bcx.ins().icmp(IntCC::$cc, $lhs, $rhs);\n+        $fx.bcx.ins().bint(types::I8, b)\n+    }};\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, $name:ident) => {\n+        $fx.bcx.ins().$name($lhs, $rhs)\n+    };\n+    (\n+        $fx:expr, $bin_op:expr, $signed:expr, $lhs:expr, $rhs:expr, $bug_fmt:expr;\n+        $(\n+            $var:ident ($sign:pat) $name:tt $( ( $next:tt ) )? ;\n+        )*\n+    ) => {\n+        match ($bin_op, $signed) {\n+            $(\n+                (BinOp::$var, $sign) => binop_match!(@single $fx, $bug_fmt, $var, $lhs, $rhs, $name $( ( $next ) )?),\n+            )*\n+        }\n+    }\n+}\n+\n fn trans_int_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: Value, rhs: Value, ty: Ty<'tcx>, signed: bool, _checked: bool) -> CValue<'tcx> {\n-    let res = match (bin_op, signed) {\n-        (BinOp::Add, _) => fx.bcx.ins().iadd(lhs, rhs),\n-        (BinOp::Sub, _) => fx.bcx.ins().isub(lhs, rhs),\n-        (BinOp::Mul, _) => fx.bcx.ins().imul(lhs, rhs),\n-        (BinOp::Div, false) => fx.bcx.ins().udiv(lhs, rhs),\n-        (BinOp::Div, true) => fx.bcx.ins().sdiv(lhs, rhs),\n-        (BinOp::Rem, false) => fx.bcx.ins().urem(lhs, rhs),\n-        (BinOp::Rem, true) => fx.bcx.ins().srem(lhs, rhs),\n-        (BinOp::BitXor, _) => fx.bcx.ins().bxor(lhs, rhs),\n-        (BinOp::BitAnd, _) => fx.bcx.ins().band(lhs, rhs),\n-        (BinOp::BitOr, _) => fx.bcx.ins().bor(lhs, rhs),\n-        (BinOp::Shl, _) => fx.bcx.ins().ishl(lhs, rhs),\n-        (BinOp::Shr, false) => fx.bcx.ins().ushr(lhs, rhs),\n-        (BinOp::Shr, true) => fx.bcx.ins().sshr(lhs, rhs),\n-\n-        // TODO: cast b1 to u8\n-        (BinOp::Eq, _) => fx.bcx.ins().icmp(IntCC::Equal , lhs, rhs),\n-        (BinOp::Lt, false) => fx.bcx.ins().icmp(IntCC::UnsignedLessThan , lhs, rhs),\n-        (BinOp::Lt, true) => fx.bcx.ins().icmp(IntCC::SignedLessThan , lhs, rhs),\n-        (BinOp::Le, false) => fx.bcx.ins().icmp(IntCC::UnsignedLessThanOrEqual , lhs, rhs),\n-        (BinOp::Le, true) => fx.bcx.ins().icmp(IntCC::SignedLessThanOrEqual , lhs, rhs),\n-        (BinOp::Ne, _) => fx.bcx.ins().icmp(IntCC::NotEqual , lhs, rhs),\n-        (BinOp::Ge, false) => fx.bcx.ins().icmp(IntCC::UnsignedGreaterThanOrEqual , lhs, rhs),\n-        (BinOp::Ge, true) => fx.bcx.ins().icmp(IntCC::SignedGreaterThanOrEqual , lhs, rhs),\n-        (BinOp::Gt, false) => fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan , lhs, rhs),\n-        (BinOp::Gt, true) => fx.bcx.ins().icmp(IntCC::SignedGreaterThan , lhs, rhs),\n-\n-        (BinOp::Offset, _) => bug!(\"bin op Offset on non ptr lhs: {:?} rhs: {:?}\", lhs, rhs),\n+    let res = binop_match! {\n+        fx, bin_op, signed, lhs, rhs, \"non ptr\";\n+        Add (_) iadd;\n+        Sub (_) isub;\n+        Mul (_) imul;\n+        Div (false) udiv;\n+        Div (true) sdiv;\n+        Rem (false) urem;\n+        Rem (true) srem;\n+        BitXor (_) bxor;\n+        BitAnd (_) band;\n+        BitOr (_) bor;\n+        Shl (_) ishl;\n+        Shr (false) ushr;\n+        Shr (true) sshr;\n+\n+        Eq (_) icmp(Equal);\n+        Lt (false) icmp(UnsignedLessThan);\n+        Lt (true) icmp(SignedLessThan);\n+        Le (false) icmp(UnsignedLessThanOrEqual);\n+        Le (true) icmp(SignedLessThanOrEqual);\n+        Ne (_) icmp(NotEqual);\n+        Ge (false) icmp(UnsignedGreaterThanOrEqual);\n+        Ge (true) icmp(SignedGreaterThanOrEqual);\n+        Gt (false) icmp(UnsignedGreaterThan);\n+        Gt (true) icmp(SignedGreaterThan);\n+\n+        Offset (_) bug;\n     };\n+\n+    // TODO: return correct value for checked binops\n+    CValue::ByVal(res, fx.layout_of(ty))\n+}\n+\n+fn trans_ptr_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: Value, rhs: Value, ty: Ty<'tcx>, _checked: bool) -> CValue<'tcx> {\n+    let res = binop_match! {\n+        fx, bin_op, false, lhs, rhs, \"ptr\";\n+        Add (_) bug;\n+        Sub (_) bug;\n+        Mul (_) bug;\n+        Div (_) bug;\n+        Rem (_) bug;\n+        BitXor (_) bug;\n+        BitAnd (_) bug;\n+        BitOr (_) bug;\n+        Shl (_) bug;\n+        Shr (_) bug;\n+\n+        Eq (_) icmp(Equal);\n+        Lt (_) icmp(UnsignedLessThan);\n+        Le (_) icmp(UnsignedLessThanOrEqual);\n+        Ne (_) icmp(NotEqual);\n+        Ge (_) icmp(UnsignedGreaterThanOrEqual);\n+        Gt (_) icmp(UnsignedGreaterThan);\n+\n+        Offset (_) iadd;\n+    };\n+\n     // TODO: return correct value for checked binops\n     CValue::ByVal(res, fx.layout_of(ty))\n }"}, {"sha": "68d807d2b98ed1c8de0fe8976cbb7ac3cad6202d", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f52727b8e65ab15a8e12a3927ff3855e2922eda7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52727b8e65ab15a8e12a3927ff3855e2922eda7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f52727b8e65ab15a8e12a3927ff3855e2922eda7", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private)]\n+#![feature(rustc_private, macro_at_most_once_rep)]\n #![allow(intra_doc_link_resolution_failure)]\n \n extern crate syntax;"}]}