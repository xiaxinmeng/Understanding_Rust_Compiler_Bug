{"sha": "cf0654c47c0d47478cdafec89ae250a86b4f2c17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMDY1NGM0N2MwZDQ3NDc4Y2RhZmVjODlhZTI1MGE4NmI0ZjJjMTc=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-02-16T11:19:41Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-02-16T13:57:56Z"}, "message": "Improve naming of tuple getters, and add mutable tuple getter\n\nRenames the `n*` and `n*_ref` tuple getters to `val*` and `ref*` respectively, and adds `mut*` getters.", "tree": {"sha": "07b6f961a89d4835b195797ecb64f9fe344d7f96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07b6f961a89d4835b195797ecb64f9fe344d7f96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf0654c47c0d47478cdafec89ae250a86b4f2c17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf0654c47c0d47478cdafec89ae250a86b4f2c17", "html_url": "https://github.com/rust-lang/rust/commit/cf0654c47c0d47478cdafec89ae250a86b4f2c17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf0654c47c0d47478cdafec89ae250a86b4f2c17/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cd7a290133f2ec7941215539dfc549f778f7be5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cd7a290133f2ec7941215539dfc549f778f7be5", "html_url": "https://github.com/rust-lang/rust/commit/2cd7a290133f2ec7941215539dfc549f778f7be5"}], "stats": {"total": 269, "additions": 136, "deletions": 133}, "files": [{"sha": "13b39da0756e0db46e42ab9d52e451375d7137e1", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf0654c47c0d47478cdafec89ae250a86b4f2c17/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0654c47c0d47478cdafec89ae250a86b4f2c17/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=cf0654c47c0d47478cdafec89ae250a86b4f2c17", "patch": "@@ -500,15 +500,15 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n                     let new_outcome = self.clone().rightmost_child.insert(k.clone(),\n                                                                        v.clone(),\n                                                                        ub.clone());\n-                    new_branch = new_outcome.clone().n0();\n-                    outcome = new_outcome.n1();\n+                    new_branch = new_outcome.clone().val0();\n+                    outcome = new_outcome.val1();\n                 }\n                 else {\n                     let new_outcome = self.clone().elts[index.unwrap()].left.insert(k.clone(),\n                                                                                  v.clone(),\n                                                                                  ub.clone());\n-                    new_branch = new_outcome.clone().n0();\n-                    outcome = new_outcome.n1();\n+                    new_branch = new_outcome.clone().val0();\n+                    outcome = new_outcome.val1();\n                 }\n                 //Check to see whether a branch or a leaf was returned from the\n                 //tree traversal."}, {"sha": "11f801550856b019ee98b2d7b09b1ae4432726ff", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf0654c47c0d47478cdafec89ae250a86b4f2c17/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0654c47c0d47478cdafec89ae250a86b4f2c17/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cf0654c47c0d47478cdafec89ae250a86b4f2c17", "patch": "@@ -1379,11 +1379,11 @@ fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n         match c.impls.find(&it.id) {\n             Some(v) => {\n                 let mut non_trait = v.iter().filter(|p| {\n-                    p.n0_ref().trait_.is_none()\n+                    p.ref0().trait_.is_none()\n                 });\n                 let non_trait = non_trait.to_owned_vec();\n                 let mut traits = v.iter().filter(|p| {\n-                    p.n0_ref().trait_.is_some()\n+                    p.ref0().trait_.is_some()\n                 });\n                 let traits = traits.to_owned_vec();\n "}, {"sha": "24c9d81e5308d2bf7ecb5d90941a22ae6155df1c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf0654c47c0d47478cdafec89ae250a86b4f2c17/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0654c47c0d47478cdafec89ae250a86b4f2c17/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=cf0654c47c0d47478cdafec89ae250a86b4f2c17", "patch": "@@ -262,7 +262,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let mut pm = plugins::PluginManager::new(Path::new(path));\n     for pass in passes.iter() {\n         let plugin = match PASSES.iter().position(|&(p, _, _)| p == *pass) {\n-            Some(i) => PASSES[i].n1(),\n+            Some(i) => PASSES[i].val1(),\n             None => {\n                 error!(\"unknown pass {}, skipping\", *pass);\n                 continue"}, {"sha": "91625a53c943892337e5969f99679dd2d0a16e8b", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 128, "deletions": 125, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/cf0654c47c0d47478cdafec89ae250a86b4f2c17/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0654c47c0d47478cdafec89ae250a86b4f2c17/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=cf0654c47c0d47478cdafec89ae250a86b4f2c17", "patch": "@@ -83,84 +83,91 @@ impl<T, U> ImmutableTuple<T, U> for (T, U) {\n macro_rules! tuple_impls {\n     ($(\n         $Tuple:ident {\n-            $(($get_fn:ident, $get_ref_fn:ident) -> $T:ident {\n-                $move_pattern:pat, $ref_pattern:pat => $ret:expr\n+            $(($valN:ident, $refN:ident, $mutN:ident) -> $T:ident {\n+                ($($x:ident),+) => $ret:expr\n             })+\n         }\n     )+) => {\n         $(\n             pub trait $Tuple<$($T),+> {\n-                $(fn $get_fn(self) -> $T;)+\n-                $(fn $get_ref_fn<'a>(&'a self) -> &'a $T;)+\n+                $(fn $valN(self) -> $T;)+\n+                $(fn $refN<'a>(&'a self) -> &'a $T;)+\n+                $(fn $mutN<'a>(&'a mut self) -> &'a mut $T;)+\n             }\n \n             impl<$($T),+> $Tuple<$($T),+> for ($($T,)+) {\n                 $(\n                     #[inline]\n-                    fn $get_fn(self) -> $T {\n-                        let $move_pattern = self;\n-                        $ret\n+                    #[allow(unused_variable)]\n+                    fn $valN(self) -> $T {\n+                        let ($($x,)+) = self; $ret\n                     }\n \n                     #[inline]\n-                    fn $get_ref_fn<'a>(&'a self) -> &'a $T {\n-                        let $ref_pattern = *self;\n-                        $ret\n+                    #[allow(unused_variable)]\n+                    fn $refN<'a>(&'a self) -> &'a $T {\n+                        let ($(ref $x,)+) = *self; $ret\n+                    }\n+\n+                    #[inline]\n+                    #[allow(unused_variable)]\n+                    fn $mutN<'a>(&'a mut self) -> &'a mut $T {\n+                        let ($(ref mut $x,)+) = *self; $ret\n                     }\n                 )+\n             }\n \n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n-                    ($(self.$get_ref_fn().clone(),)+)\n+                    ($(self.$refN().clone(),)+)\n                 }\n             }\n \n             #[cfg(not(test))]\n             impl<$($T:Eq),+> Eq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n-                    $(*self.$get_ref_fn() == *other.$get_ref_fn())&&+\n+                    $(*self.$refN() == *other.$refN())&&+\n                 }\n                 #[inline]\n                 fn ne(&self, other: &($($T,)+)) -> bool {\n-                    $(*self.$get_ref_fn() != *other.$get_ref_fn())||+\n+                    $(*self.$refN() != *other.$refN())||+\n                 }\n             }\n \n             #[cfg(not(test))]\n             impl<$($T:TotalEq),+> TotalEq for ($($T,)+) {\n                 #[inline]\n                 fn equals(&self, other: &($($T,)+)) -> bool {\n-                    $(self.$get_ref_fn().equals(other.$get_ref_fn()))&&+\n+                    $(self.$refN().equals(other.$refN()))&&+\n                 }\n             }\n \n             #[cfg(not(test))]\n             impl<$($T:Ord + Eq),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn lt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(lt, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    lexical_ord!(lt, $(self.$refN(), other.$refN()),+)\n                 }\n                 #[inline]\n                 fn le(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(le, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    lexical_ord!(le, $(self.$refN(), other.$refN()),+)\n                 }\n                 #[inline]\n                 fn ge(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(ge, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    lexical_ord!(ge, $(self.$refN(), other.$refN()),+)\n                 }\n                 #[inline]\n                 fn gt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(gt, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    lexical_ord!(gt, $(self.$refN(), other.$refN()),+)\n                 }\n             }\n \n             #[cfg(not(test))]\n             impl<$($T:TotalOrd),+> TotalOrd for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {\n-                    lexical_cmp!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    lexical_cmp!($(self.$refN(), other.$refN()),+)\n                 }\n             }\n \n@@ -180,7 +187,7 @@ macro_rules! tuple_impls {\n \n             impl<$($T: fmt::Show),+> fmt::Show for ($($T,)+) {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                    write_tuple!(f.buf, $(self.$get_ref_fn()),+)\n+                    write_tuple!(f.buf, $(self.$refN()),+)\n                 }\n             }\n         )+\n@@ -223,106 +230,106 @@ macro_rules! write_tuple {\n \n tuple_impls! {\n     Tuple1 {\n-        (n0, n0_ref) -> A { (a,), (ref a,) => a }\n+        (val0, ref0, mut0) -> A { (a) => a }\n     }\n     Tuple2 {\n-        (n0, n0_ref) -> A { (a,_), (ref a,_) => a }\n-        (n1, n1_ref) -> B { (_,b), (_,ref b) => b }\n+        (val0, ref0, mut0) -> A { (a, b) => a }\n+        (val1, ref1, mut1) -> B { (a, b) => b }\n     }\n     Tuple3 {\n-        (n0, n0_ref) -> A { (a,_,_), (ref a,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_), (_,ref b,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c), (_,_,ref c) => c }\n+        (val0, ref0, mut0) -> A { (a, b, c) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c) => c }\n     }\n     Tuple4 {\n-        (n0, n0_ref) -> A { (a,_,_,_), (ref a,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_), (_,ref b,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_), (_,_,ref c,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d), (_,_,_,ref d) => d }\n+        (val0, ref0, mut0) -> A { (a, b, c, d) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d) => d }\n     }\n     Tuple5 {\n-        (n0, n0_ref) -> A { (a,_,_,_,_), (ref a,_,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_,_), (_,ref b,_,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_,_), (_,_,ref c,_,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d,_), (_,_,_,ref d,_) => d }\n-        (n4, n4_ref) -> E { (_,_,_,_,e), (_,_,_,_,ref e) => e }\n+        (val0, ref0, mut0) -> A { (a, b, c, d, e) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d, e) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d, e) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d, e) => d }\n+        (val4, ref4, mut4) -> E { (a, b, c, d, e) => e }\n     }\n     Tuple6 {\n-        (n0, n0_ref) -> A { (a,_,_,_,_,_), (ref a,_,_,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_,_,_), (_,ref b,_,_,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_,_,_), (_,_,ref c,_,_,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d,_,_), (_,_,_,ref d,_,_) => d }\n-        (n4, n4_ref) -> E { (_,_,_,_,e,_), (_,_,_,_,ref e,_) => e }\n-        (n5, n5_ref) -> F { (_,_,_,_,_,f), (_,_,_,_,_,ref f) => f }\n+        (val0, ref0, mut0) -> A { (a, b, c, d, e, f) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d, e, f) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d, e, f) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d, e, f) => d }\n+        (val4, ref4, mut4) -> E { (a, b, c, d, e, f) => e }\n+        (val5, ref5, mut5) -> F { (a, b, c, d, e, f) => f }\n     }\n     Tuple7 {\n-        (n0, n0_ref) -> A { (a,_,_,_,_,_,_), (ref a,_,_,_,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_,_,_,_), (_,ref b,_,_,_,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_,_,_,_), (_,_,ref c,_,_,_,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d,_,_,_), (_,_,_,ref d,_,_,_) => d }\n-        (n4, n4_ref) -> E { (_,_,_,_,e,_,_), (_,_,_,_,ref e,_,_) => e }\n-        (n5, n5_ref) -> F { (_,_,_,_,_,f,_), (_,_,_,_,_,ref f,_) => f }\n-        (n6, n6_ref) -> G { (_,_,_,_,_,_,g), (_,_,_,_,_,_,ref g) => g }\n+        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g) => d }\n+        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g) => e }\n+        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g) => f }\n+        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g) => g }\n     }\n     Tuple8 {\n-        (n0, n0_ref) -> A { (a,_,_,_,_,_,_,_), (ref a,_,_,_,_,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_,_,_,_,_), (_,ref b,_,_,_,_,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_,_,_,_,_), (_,_,ref c,_,_,_,_,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d,_,_,_,_), (_,_,_,ref d,_,_,_,_) => d }\n-        (n4, n4_ref) -> E { (_,_,_,_,e,_,_,_), (_,_,_,_,ref e,_,_,_) => e }\n-        (n5, n5_ref) -> F { (_,_,_,_,_,f,_,_), (_,_,_,_,_,ref f,_,_) => f }\n-        (n6, n6_ref) -> G { (_,_,_,_,_,_,g,_), (_,_,_,_,_,_,ref g,_) => g }\n-        (n7, n7_ref) -> H { (_,_,_,_,_,_,_,h), (_,_,_,_,_,_,_,ref h) => h }\n+        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g, h) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g, h) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g, h) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g, h) => d }\n+        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g, h) => e }\n+        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g, h) => f }\n+        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g, h) => g }\n+        (val7, ref7, mut7) -> H { (a, b, c, d, e, f, g, h) => h }\n     }\n     Tuple9 {\n-        (n0, n0_ref) -> A { (a,_,_,_,_,_,_,_,_), (ref a,_,_,_,_,_,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_,_,_,_,_,_), (_,ref b,_,_,_,_,_,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_,_,_,_,_,_), (_,_,ref c,_,_,_,_,_,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d,_,_,_,_,_), (_,_,_,ref d,_,_,_,_,_) => d }\n-        (n4, n4_ref) -> E { (_,_,_,_,e,_,_,_,_), (_,_,_,_,ref e,_,_,_,_) => e }\n-        (n5, n5_ref) -> F { (_,_,_,_,_,f,_,_,_), (_,_,_,_,_,ref f,_,_,_) => f }\n-        (n6, n6_ref) -> G { (_,_,_,_,_,_,g,_,_), (_,_,_,_,_,_,ref g,_,_) => g }\n-        (n7, n7_ref) -> H { (_,_,_,_,_,_,_,h,_), (_,_,_,_,_,_,_,ref h,_) => h }\n-        (n8, n8_ref) -> I { (_,_,_,_,_,_,_,_,i), (_,_,_,_,_,_,_,_,ref i) => i }\n+        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g, h, i) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g, h, i) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g, h, i) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g, h, i) => d }\n+        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g, h, i) => e }\n+        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g, h, i) => f }\n+        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g, h, i) => g }\n+        (val7, ref7, mut7) -> H { (a, b, c, d, e, f, g, h, i) => h }\n+        (val8, ref8, mut8) -> I { (a, b, c, d, e, f, g, h, i) => i }\n     }\n     Tuple10 {\n-        (n0, n0_ref) -> A { (a,_,_,_,_,_,_,_,_,_), (ref a,_,_,_,_,_,_,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_,_,_,_,_,_,_), (_,ref b,_,_,_,_,_,_,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_,_,_,_,_,_,_), (_,_,ref c,_,_,_,_,_,_,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d,_,_,_,_,_,_), (_,_,_,ref d,_,_,_,_,_,_) => d }\n-        (n4, n4_ref) -> E { (_,_,_,_,e,_,_,_,_,_), (_,_,_,_,ref e,_,_,_,_,_) => e }\n-        (n5, n5_ref) -> F { (_,_,_,_,_,f,_,_,_,_), (_,_,_,_,_,ref f,_,_,_,_) => f }\n-        (n6, n6_ref) -> G { (_,_,_,_,_,_,g,_,_,_), (_,_,_,_,_,_,ref g,_,_,_) => g }\n-        (n7, n7_ref) -> H { (_,_,_,_,_,_,_,h,_,_), (_,_,_,_,_,_,_,ref h,_,_) => h }\n-        (n8, n8_ref) -> I { (_,_,_,_,_,_,_,_,i,_), (_,_,_,_,_,_,_,_,ref i,_) => i }\n-        (n9, n9_ref) -> J { (_,_,_,_,_,_,_,_,_,j), (_,_,_,_,_,_,_,_,_,ref j) => j }\n+        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g, h, i, j) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g, h, i, j) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g, h, i, j) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g, h, i, j) => d }\n+        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g, h, i, j) => e }\n+        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g, h, i, j) => f }\n+        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g, h, i, j) => g }\n+        (val7, ref7, mut7) -> H { (a, b, c, d, e, f, g, h, i, j) => h }\n+        (val8, ref8, mut8) -> I { (a, b, c, d, e, f, g, h, i, j) => i }\n+        (val9, ref9, mut9) -> J { (a, b, c, d, e, f, g, h, i, j) => j }\n     }\n     Tuple11 {\n-        (n0,  n0_ref)  -> A { (a,_,_,_,_,_,_,_,_,_,_), (ref a,_,_,_,_,_,_,_,_,_,_) => a }\n-        (n1,  n1_ref)  -> B { (_,b,_,_,_,_,_,_,_,_,_), (_,ref b,_,_,_,_,_,_,_,_,_) => b }\n-        (n2,  n2_ref)  -> C { (_,_,c,_,_,_,_,_,_,_,_), (_,_,ref c,_,_,_,_,_,_,_,_) => c }\n-        (n3,  n3_ref)  -> D { (_,_,_,d,_,_,_,_,_,_,_), (_,_,_,ref d,_,_,_,_,_,_,_) => d }\n-        (n4,  n4_ref)  -> E { (_,_,_,_,e,_,_,_,_,_,_), (_,_,_,_,ref e,_,_,_,_,_,_) => e }\n-        (n5,  n5_ref)  -> F { (_,_,_,_,_,f,_,_,_,_,_), (_,_,_,_,_,ref f,_,_,_,_,_) => f }\n-        (n6,  n6_ref)  -> G { (_,_,_,_,_,_,g,_,_,_,_), (_,_,_,_,_,_,ref g,_,_,_,_) => g }\n-        (n7,  n7_ref)  -> H { (_,_,_,_,_,_,_,h,_,_,_), (_,_,_,_,_,_,_,ref h,_,_,_) => h }\n-        (n8,  n8_ref)  -> I { (_,_,_,_,_,_,_,_,i,_,_), (_,_,_,_,_,_,_,_,ref i,_,_) => i }\n-        (n9,  n9_ref)  -> J { (_,_,_,_,_,_,_,_,_,j,_), (_,_,_,_,_,_,_,_,_,ref j,_) => j }\n-        (n10, n10_ref) -> K { (_,_,_,_,_,_,_,_,_,_,k), (_,_,_,_,_,_,_,_,_,_,ref k) => k }\n+        (val0,  ref0,  mut0)  -> A { (a, b, c, d, e, f, g, h, i, j, k) => a }\n+        (val1,  ref1,  mut1)  -> B { (a, b, c, d, e, f, g, h, i, j, k) => b }\n+        (val2,  ref2,  mut2)  -> C { (a, b, c, d, e, f, g, h, i, j, k) => c }\n+        (val3,  ref3,  mut3)  -> D { (a, b, c, d, e, f, g, h, i, j, k) => d }\n+        (val4,  ref4,  mut4)  -> E { (a, b, c, d, e, f, g, h, i, j, k) => e }\n+        (val5,  ref5,  mut5)  -> F { (a, b, c, d, e, f, g, h, i, j, k) => f }\n+        (val6,  ref6,  mut6)  -> G { (a, b, c, d, e, f, g, h, i, j, k) => g }\n+        (val7,  ref7,  mut7)  -> H { (a, b, c, d, e, f, g, h, i, j, k) => h }\n+        (val8,  ref8,  mut8)  -> I { (a, b, c, d, e, f, g, h, i, j, k) => i }\n+        (val9,  ref9,  mut9)  -> J { (a, b, c, d, e, f, g, h, i, j, k) => j }\n+        (val10, ref10, mut10) -> K { (a, b, c, d, e, f, g, h, i, j, k) => k }\n     }\n     Tuple12 {\n-        (n0,  n0_ref)  -> A { (a,_,_,_,_,_,_,_,_,_,_,_), (ref a,_,_,_,_,_,_,_,_,_,_,_) => a }\n-        (n1,  n1_ref)  -> B { (_,b,_,_,_,_,_,_,_,_,_,_), (_,ref b,_,_,_,_,_,_,_,_,_,_) => b }\n-        (n2,  n2_ref)  -> C { (_,_,c,_,_,_,_,_,_,_,_,_), (_,_,ref c,_,_,_,_,_,_,_,_,_) => c }\n-        (n3,  n3_ref)  -> D { (_,_,_,d,_,_,_,_,_,_,_,_), (_,_,_,ref d,_,_,_,_,_,_,_,_) => d }\n-        (n4,  n4_ref)  -> E { (_,_,_,_,e,_,_,_,_,_,_,_), (_,_,_,_,ref e,_,_,_,_,_,_,_) => e }\n-        (n5,  n5_ref)  -> F { (_,_,_,_,_,f,_,_,_,_,_,_), (_,_,_,_,_,ref f,_,_,_,_,_,_) => f }\n-        (n6,  n6_ref)  -> G { (_,_,_,_,_,_,g,_,_,_,_,_), (_,_,_,_,_,_,ref g,_,_,_,_,_) => g }\n-        (n7,  n7_ref)  -> H { (_,_,_,_,_,_,_,h,_,_,_,_), (_,_,_,_,_,_,_,ref h,_,_,_,_) => h }\n-        (n8,  n8_ref)  -> I { (_,_,_,_,_,_,_,_,i,_,_,_), (_,_,_,_,_,_,_,_,ref i,_,_,_) => i }\n-        (n9,  n9_ref)  -> J { (_,_,_,_,_,_,_,_,_,j,_,_), (_,_,_,_,_,_,_,_,_,ref j,_,_) => j }\n-        (n10, n10_ref) -> K { (_,_,_,_,_,_,_,_,_,_,k,_), (_,_,_,_,_,_,_,_,_,_,ref k,_) => k }\n-        (n11, n11_ref) -> L { (_,_,_,_,_,_,_,_,_,_,_,l), (_,_,_,_,_,_,_,_,_,_,_,ref l) => l }\n+        (val0,  ref0,  mut0)  -> A { (a, b, c, d, e, f, g, h, i, j, k, l) => a }\n+        (val1,  ref1,  mut1)  -> B { (a, b, c, d, e, f, g, h, i, j, k, l) => b }\n+        (val2,  ref2,  mut2)  -> C { (a, b, c, d, e, f, g, h, i, j, k, l) => c }\n+        (val3,  ref3,  mut3)  -> D { (a, b, c, d, e, f, g, h, i, j, k, l) => d }\n+        (val4,  ref4,  mut4)  -> E { (a, b, c, d, e, f, g, h, i, j, k, l) => e }\n+        (val5,  ref5,  mut5)  -> F { (a, b, c, d, e, f, g, h, i, j, k, l) => f }\n+        (val6,  ref6,  mut6)  -> G { (a, b, c, d, e, f, g, h, i, j, k, l) => g }\n+        (val7,  ref7,  mut7)  -> H { (a, b, c, d, e, f, g, h, i, j, k, l) => h }\n+        (val8,  ref8,  mut8)  -> I { (a, b, c, d, e, f, g, h, i, j, k, l) => i }\n+        (val9,  ref9,  mut9)  -> J { (a, b, c, d, e, f, g, h, i, j, k, l) => j }\n+        (val10, ref10, mut10) -> K { (a, b, c, d, e, f, g, h, i, j, k, l) => k }\n+        (val11, ref11, mut11) -> L { (a, b, c, d, e, f, g, h, i, j, k, l) => l }\n     }\n }\n \n@@ -355,33 +362,29 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_n_tuple() {\n-        let t = (0u8, 1u16, 2u32, 3u64, 4u, 5i8, 6i16, 7i32, 8i64, 9i, 10f32, 11f64);\n-        assert_eq!(t.n0(), 0u8);\n-        assert_eq!(t.n1(), 1u16);\n-        assert_eq!(t.n2(), 2u32);\n-        assert_eq!(t.n3(), 3u64);\n-        assert_eq!(t.n4(), 4u);\n-        assert_eq!(t.n5(), 5i8);\n-        assert_eq!(t.n6(), 6i16);\n-        assert_eq!(t.n7(), 7i32);\n-        assert_eq!(t.n8(), 8i64);\n-        assert_eq!(t.n9(), 9i);\n-        assert_eq!(t.n10(), 10f32);\n-        assert_eq!(t.n11(), 11f64);\n-\n-        assert_eq!(t.n0_ref(), &0u8);\n-        assert_eq!(t.n1_ref(), &1u16);\n-        assert_eq!(t.n2_ref(), &2u32);\n-        assert_eq!(t.n3_ref(), &3u64);\n-        assert_eq!(t.n4_ref(), &4u);\n-        assert_eq!(t.n5_ref(), &5i8);\n-        assert_eq!(t.n6_ref(), &6i16);\n-        assert_eq!(t.n7_ref(), &7i32);\n-        assert_eq!(t.n8_ref(), &8i64);\n-        assert_eq!(t.n9_ref(), &9i);\n-        assert_eq!(t.n10_ref(), &10f32);\n-        assert_eq!(t.n11_ref(), &11f64);\n+    fn test_getters() {\n+        macro_rules! test_getter(\n+            ($x:expr, $valN:ident, $refN:ident, $mutN:ident,\n+             $init:expr, $incr:expr, $result:expr) => ({\n+                assert_eq!($x.$valN(), $init);\n+                assert_eq!(*$x.$refN(), $init);\n+                *$x.$mutN() += $incr;\n+                assert_eq!(*$x.$refN(), $result);\n+            })\n+        )\n+        let mut x = (0u8, 1u16, 2u32, 3u64, 4u, 5i8, 6i16, 7i32, 8i64, 9i, 10f32, 11f64);\n+        test_getter!(x, val0,  ref0,  mut0,  0,    1,   1);\n+        test_getter!(x, val1,  ref1,  mut1,  1,    1,   2);\n+        test_getter!(x, val2,  ref2,  mut2,  2,    1,   3);\n+        test_getter!(x, val3,  ref3,  mut3,  3,    1,   4);\n+        test_getter!(x, val4,  ref4,  mut4,  4,    1,   5);\n+        test_getter!(x, val5,  ref5,  mut5,  5,    1,   6);\n+        test_getter!(x, val6,  ref6,  mut6,  6,    1,   7);\n+        test_getter!(x, val7,  ref7,  mut7,  7,    1,   8);\n+        test_getter!(x, val8,  ref8,  mut8,  8,    1,   9);\n+        test_getter!(x, val9,  ref9,  mut9,  9,    1,   10);\n+        test_getter!(x, val10, ref10, mut10, 10.0, 1.0, 11.0);\n+        test_getter!(x, val11, ref11, mut11, 11.0, 1.0, 12.0);\n     }\n \n     #[test]"}, {"sha": "f0c3517a0b88e79f4a27a81348d94dcdc2b85b32", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf0654c47c0d47478cdafec89ae250a86b4f2c17/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0654c47c0d47478cdafec89ae250a86b4f2c17/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=cf0654c47c0d47478cdafec89ae250a86b4f2c17", "patch": "@@ -51,7 +51,7 @@ impl<'a> Iterator<u8> for AAGen<'a> {\n     fn next(&mut self) -> Option<u8> {\n         let r = self.rng.gen();\n         self.data.iter()\n-            .skip_while(|pc| pc.n0() < r)\n+            .skip_while(|pc| pc.val0() < r)\n             .map(|&(_, c)| c)\n             .next()\n     }"}]}