{"sha": "30dcc8285bf64e50e7b1b51b351465d99fb5c8a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZGNjODI4NWJmNjRlNTBlN2IxYjUxYjM1MTQ2NWQ5OWZiNWM4YTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-02-08T08:38:00Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-02-08T08:38:00Z"}, "message": "doc: Modernize FAQs just slightly", "tree": {"sha": "335e494f60e7cff96e6dbe642b7f348a07d65ffb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/335e494f60e7cff96e6dbe642b7f348a07d65ffb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30dcc8285bf64e50e7b1b51b351465d99fb5c8a7", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30dcc8285bf64e50e7b1b51b351465d99fb5c8a7", "html_url": "https://github.com/rust-lang/rust/commit/30dcc8285bf64e50e7b1b51b351465d99fb5c8a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30dcc8285bf64e50e7b1b51b351465d99fb5c8a7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6aad3bf944da209d1852c51144ba584de400a10c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6aad3bf944da209d1852c51144ba584de400a10c", "html_url": "https://github.com/rust-lang/rust/commit/6aad3bf944da209d1852c51144ba584de400a10c"}], "stats": {"total": 213, "additions": 25, "deletions": 188}, "files": [{"sha": "2099954dd0db2f08e19cbbae528dfd0e4447c713", "filename": "mk/docs.mk", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30dcc8285bf64e50e7b1b51b351465d99fb5c8a7/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/30dcc8285bf64e50e7b1b51b351465d99fb5c8a7/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=30dcc8285bf64e50e7b1b51b351465d99fb5c8a7", "patch": "@@ -149,12 +149,6 @@ doc/complement-project-faq.html: $(D)/complement-project-faq.md $(HTML_DEPS)\n \t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n \t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n \n-DOCS += doc/complement-usage-faq.html\n-doc/complement-usage-faq.html: $(D)/complement-usage-faq.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n DOCS += doc/complement-cheatsheet.html\n doc/complement-cheatsheet.html: $(D)/complement-cheatsheet.md doc/full-toc.inc $(HTML_DEPS)\n \t@$(call E, pandoc: $@)"}, {"sha": "bd0a47de44c5dd402be9d4fb0321b38f91a7a256", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 18, "deletions": 117, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/30dcc8285bf64e50e7b1b51b351465d99fb5c8a7/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/30dcc8285bf64e50e7b1b51b351465d99fb5c8a7/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=30dcc8285bf64e50e7b1b51b351465d99fb5c8a7", "patch": "@@ -1,77 +1,5 @@\n % Language FAQ\n \n-# General language issues\n-\n-## Safety oriented\n-\n-* Memory safe: no null pointers, dangling pointers, use-before-initialize or use-after-move\n-* Expressive mutability control. Immutable by default, statically verified freezing for Owned types\n-* No shared mutable state across tasks\n-* Dynamic execution safety: task failure / unwinding, trapping, RAII / dtors\n-* Safe interior pointer types with lifetime analysis\n-\n-## Concurrency and efficiency oriented\n-\n-* Lightweight tasks (coroutines) with expanding stacks\n-* Fast asynchronous, copyless message passing\n-* Optional garbage collected pointers\n-* All types may be explicitly allocated on the stack or interior to other types\n-* Static, native compilation using LLVM\n-* Direct and simple interface to C code\n-\n-## Practicality oriented\n-\n-* Multi-paradigm: pure-functional, concurrent-actor, imperative-procedural, OO\n- * First-class functions, cheap non-escaping closures\n- * Algebraic data types (called enums) with pattern matching\n- * Method implementations on any type\n- * Traits, which share aspects of type classes and interfaces\n-* Multi-platform. Developed on Windows, Linux, OS X\n-* UTF-8 strings, assortment of machine-level types\n-* Works with existing native toolchains, GDB, Valgrind, Instruments, etc\n-* Rule-breaking is allowed if explicit about where and how\n-\n-## What does it look like?\n-\n-The syntax is still evolving, but here's a snippet from the hash map in core::hashmap.\n-\n-~~~\n-struct LinearMap<K,V> {\n-    k0: u64,\n-    k1: u64,\n-    resize_at: uint,\n-    size: uint,\n-    buckets: ~[Option<Bucket<K,V>>],\n-}\n-\n-enum SearchResult {\n-    FoundEntry(uint), FoundHole(uint), TableFull\n-}\n-\n-fn linear_map_with_capacity<K:Eq + Hash,V>(capacity: uint) -> LinearMap<K,V> {\n-    let r = rand::Rng();\n-    linear_map_with_capacity_and_keys(r.gen_u64(), r.gen_u64(), capacity)\n-}\n-\n-impl<K:Hash + IterBytes + Eq, V> LinearMap<K,V> {\n-\n-    fn contains_key(&self, k: &K) -> bool {\n-        match self.bucket_for_key(self.buckets, k) {\n-            FoundEntry(_) => true,\n-            TableFull | FoundHole(_) => false\n-        }\n-    }\n-\n-    fn clear(&mut self) {\n-        for bkt in self.buckets.mut_iter() {\n-            *bkt = None;\n-        }\n-        self.size = 0;\n-    }\n-\n-...\n-}\n-~~~\n \n ## Are there any big programs written in it yet? I want to read big samples.\n \n@@ -108,27 +36,6 @@ Yes. All development happens in lock-step on all 3 target platforms. Using MinGW\n [unwind]: https://github.com/mozilla/rust/issues/908\n [libgcc]: https://github.com/mozilla/rust/issues/1603\n \n-## Have you seen this Google language, Go? How does Rust compare?\n-\n-Rust and Go have similar syntax and task models, but they have very different type systems. Rust is distinguished by greater type safety and memory safety guarantees, more control over memory layout, and robust generics.\n-\n-Rust has several key features that aren't shared by Go:\n-\n-* No shared mutable state - Shared mutable state allows data races, a large class of bad bugs. In Rust there is no sharing of mutable data, but ownership of data can be efficiently transferred between tasks.\n-* Minimal GC impact - By not having shared mutable data, Rust can avoid global GC, hence Rust never stops the world to collect garbage. With multiple allocation options, individual tasks can completely avoid GC.\n-* No null pointers - Accidentally dereferencing null pointers is a big bummer, so Rust doesn't have them.\n-* Type parametric code - Generics prove useful time and again, though they are inevitably complex to greater or lesser degrees.\n-\n-Some of Rust's advantages come at the cost of a more intricate type system than Go's.\n-\n-Go has its own strengths and in particular has a great user experience that Rust still lacks.\n-\n-## I like the language but it really needs _$somefeature_.\n-\n-At this point we are focusing on removing and stabilizing features rather than adding them. File a bug if you think it's important in terms of meeting the existing goals or making the language passably usable. Reductions are more interesting than additions, though.\n-\n-# Specific language issues\n-\n ## Is it OO? How do I do this thing I normally do in an OO language?\n \n It is multi-paradigm. Not everything is shoe-horned into a single abstraction. Many things you can do in OO languages you can do in Rust, but not everything, and not always using the same abstraction you're accustomed to.\n@@ -199,38 +106,16 @@ In each case there is one or more operator, literal constructor, overloaded use\n \n ## Can Rust code call C code?\n \n-Yes. Since C code typically expects a larger stack than Rust code does, the stack may grow before the call. The Rust domain owning the task that makes the call will block for the duration of the call, so if the call is likely to be long-lasting, you should consider putting the task in its own domain (thread or process).\n+Yes. Calling C code from Rust is simple and exactly as efficient as calling C code from C.\n \n ## Can C code call Rust code?\n \n-Yes. The Rust code has to be exposed via an `extern` declaration, which makes it C-ABI compatible. Its address can then be taken and passed to C code. When C calls Rust back, the callback occurs in very restricted circumstances.\n-\n-## How do Rust's task stacks work?\n-\n-They start small (ideally in the hundreds of bytes) and expand dynamically by calling through special frames that allocate new stack segments. This is known as the \"spaghetti stack\" approach.\n-\n-## What is the difference between a managed box pointer (`@`) and an owned box pointer (`~`)?\n-\n-* Managed boxes live in the garbage collected task-local heap\n-* Owned boxes live in the global exchange heap\n-* Managed boxes may be referred to by multiple managed box references\n-* Owned boxes have unique ownership and there may only be a single unique pointer to a unique box at a time\n-* Managed boxes may not be shared between tasks\n-* Owned boxes may be transferred (moved) between tasks\n-\n-## What is the difference between a reference (`&`) and managed and owned boxes?\n-\n-* References point to the interior of a stack _or_ heap allocation\n-* References can only be formed when it will provably be outlived by the referent\n-* References to managed box pointers keep the managed boxes alive\n-* References to owned boxes prevent their ownership from being transferred\n-* References employ region-based alias analysis to ensure correctness\n+Yes. The Rust code has to be exposed via an `extern` declaration, which makes it C-ABI compatible. Such a function can be passed to C code as a function pointer or, if given the `#[no_mangle]` attribute to disable symbol mangling, can be called directly from C code.\n \n ## Why aren't function signatures inferred? Why only local slots?\n \n * Mechanically, it simplifies the inference algorithm; inference only requires looking at one function at a time.\n * The same simplification goes double for human readers. A reader does not need an IDE running an inference algorithm across an entire crate to be able to guess at a function's argument types; it's always explicit and nearby.\n-* Parameters in Rust can be passed by reference or by value. We can't automatically infer which one the programmer means.\n \n ## Why does a type parameter need explicit trait bounds to invoke methods on it, when C++ templates do not?\n \n@@ -245,3 +130,19 @@ They start small (ideally in the hundreds of bytes) and expand dynamically by ca\n ## Will Rust implement automatic semicolon insertion, like in Go?\n \n For simplicity, we do not plan to do so. Implementing automatic semicolon insertion for Rust would be tricky because the absence of a trailing semicolon means \"return a value\".\n+\n+## How do I get my program to display the output of logging macros?\n+\n+**Short answer** set the RUST_LOG environment variable to the name of your source file, sans extension.\n+\n+```sh\n+rustc hello.rs\n+export RUST_LOG=hello\n+./hello\n+```\n+\n+**Long answer** RUST_LOG takes a 'logging spec' that consists of a comma-separated list of paths, where a path consists of the crate name and sequence of module names, each separated by double-colons. For standalone .rs files the crate is implicitly named after the source file, so in the above example we were setting RUST_LOG to the name of the hello crate. Multiple paths can be combined to control the exact logging you want to see. For example, when debugging linking in the compiler you might set `RUST_LOG=rustc::metadata::creader,rustc::util::filesearch,rustc::back::rpath`\n+\n+If you aren't sure which paths you need, try setting RUST_LOG to `::help` and running your program. This will print a list of paths available for logging. For a full description see [the language reference][1].\n+\n+[1]:http://doc.rust-lang.org/doc/master/rust.html#logging-system"}, {"sha": "60aced3fc2f0e2ba24c67cd7c252c827d455fc5a", "filename": "src/doc/complement-project-faq.md", "status": "modified", "additions": 7, "deletions": 33, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/30dcc8285bf64e50e7b1b51b351465d99fb5c8a7/src%2Fdoc%2Fcomplement-project-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/30dcc8285bf64e50e7b1b51b351465d99fb5c8a7/src%2Fdoc%2Fcomplement-project-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-project-faq.md?ref=30dcc8285bf64e50e7b1b51b351465d99fb5c8a7", "patch": "@@ -16,7 +16,6 @@ Existing languages at this level of abstraction and efficiency are unsatisfactor\n \n * To employ any particularly cutting-edge technologies. Old, established techniques are better.\n * To prize expressiveness, minimalism or elegance above other goals. These are desirable but subordinate goals.\n-* To cover the \"systems language\" part all the way down to \"writing an OS kernel\".\n * To cover the complete feature-set of C++, or any other language. It should provide majority-case features.\n * To be 100% static, 100% safe, 100% reflective, or too dogmatic in any other sense. Trade-offs exist.\n * To run on \"every possible platform\". It must eventually work without unnecessary compromises on widely-used hardware and software platforms.\n@@ -25,44 +24,19 @@ Existing languages at this level of abstraction and efficiency are unsatisfactor\n \n No. Feel free to play around, but don't expect completeness or stability yet. Expect incompleteness and breakage.\n \n-What exists presently is:\n-\n-* A self-hosted (written in Rust) compiler, which uses LLVM as a backend.\n-* A runtime library.\n-* An evolving standard library.\n-* Documentation for the language and libraries.\n-* Incomplete tools for packaging and documentation.\n-* A test suite covering the compiler and libraries.\n-\n # Is this a completely Mozilla-planned and orchestrated thing?\n \n-No. It started as a part-time side project in 2006 and remained so for over 3 years. Mozilla got involved in 2009 once the language was mature enough to run some basic tests and demonstrate the idea.\n-\n-# Why did you do so much work in private?\n-\n-* A certain amount of shyness. Language work is somewhat political and flame-inducing.\n-* Languages designed by committee have a poor track record. Design coherence is important. There were a lot of details to work out and the initial developer (Graydon) had this full time job thing eating up most days.\n-\n-# Why publish it now?\n-\n-* The design is stable enough. All the major pieces have reached non-imaginary, initial implementation status. It seems to hold together ok.\n-* Languages solely implemented and supported by one person _also_ have a poor track record. To survive it'll need help.\n+No. It started as a Graydon Hoare's part-time side project in 2006 and remained so for over 3 years. Mozilla got involved in 2009 once the language was mature enough to run some basic tests and demonstrate the idea. Though it is sponsored by Mozilla, Rust is developed by a diverse community of enthusiasts.\n \n # What will Mozilla use Rust for?\n \n-Mozilla intends to use Rust as a platform for prototyping experimental browser architectures. Specifically, the hope is to develop a browser that is more amenable to parallelization than existing ones, while also being less prone to common C++ coding errors. The name of that project is _[Servo](http://github.com/mozilla/servo)_.\n+Mozilla intends to use Rust as a platform for prototyping experimental browser architectures. Specifically, the hope is to develop a browser that is more amenable to parallelization than existing ones, while also being less prone to common C++ coding errors that result in security exploits. The name of that project is _[Servo](http://github.com/mozilla/servo)_.\n \n-# Are you going to use this to suddenly rewrite the browser and change everything? Is the Mozilla Corporation trying to force the community to use a new language?\n-\n-No. This is a research project. The point is to explore ideas. There is no plan to incorporate any Rust-based technology into Firefox.\n-\n-# Why GitHub rather than the normal Mozilla setup (Mercurial / Bugzilla / Tinderbox)?\n-\n-* This is a fresh codebase and has no existing ties to Mozilla infrastructure; there is no particular advantage to (re)using any of the above infrastructure, it would all have to be upgraded and adapted to our needs.\n-* Git has been progressing rapidly in the years since Mozilla picked Mercurial for its main development needs, and appears to be both more widely known and more accessible at this point.\n-* This reduces the administrative requirements for contributing to merely establishing a paper trail via a contributor agreement. There is no need for vouching, granting commit access to Mozilla facilities, or setting up Mozilla user accounts.\n-\n-# Why a BSD-style license rather than MPL or tri-license?\n+# Why a BSD-style permissive license rather than MPL or tri-license?\n \n * Partly due to preference of the original developer (Graydon).\n * Partly due to the fact that languages tend to have a wider audience and more diverse set of possible embeddings and end-uses than focused, coherent products such as web browsers. We'd like to appeal to as many of those potential contributors as possible.\n+\n+# Why dual MIT/ASL2 license?\n+\n+The Apache license includes important protection against patent aggression, but it is not compatible with the GPL, version 2. To avoid problems using Rust with GPL2, it is alternately MIT licensed."}, {"sha": "aca7d833849db27b1a0c545765152a8bbf64d68f", "filename": "src/doc/complement-usage-faq.md", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Fdoc%2Fcomplement-usage-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Fdoc%2Fcomplement-usage-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-usage-faq.md?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -1,31 +0,0 @@\n-% Usage FAQ\n-\n-# How do I get my program to display the output of `log` statements?\n-\n-**Short answer** set the RUST_LOG environment variable to the name of your source file, sans extension.\n-\n-```sh\n-rustc hello.rs\n-export RUST_LOG=hello\n-./hello\n-```\n-\n-**Long answer** RUST_LOG takes a 'logging spec' that consists of a comma-separated list of paths, where a path consists of the crate name and sequence of module names, each separated by double-colons. For standalone .rs files the crate is implicitly named after the source file, so in the above example we were setting RUST_LOG to the name of the hello crate. Multiple paths can be combined to control the exact logging you want to see. For example, when debugging linking in the compiler you might set `RUST_LOG=rustc::metadata::creader,rustc::util::filesearch,rustc::back::rpath`\n-\n-If you aren't sure which paths you need, try setting RUST_LOG to `::help` and running your program. This will print a list of paths available for logging. For a full description see [the language reference][1].\n-\n-[1]:http://doc.rust-lang.org/doc/master/rust.html#logging-system\n-\n-# How do I get my program to display the output of `debug!` statements?\n-\n-This is much like the answer for `log` statements, except that you also need to compile your program in debug mode (that is, pass `--cfg debug` to `rustc`).  Note that if you want to see the instrumentation of the `debug!` statements within `rustc` itself, you need a debug version of `rustc`; you can get one by invoking `configure` with the `--enable-debug` option.\n-\n-# What does it mean when a program exits with `leaked memory`?\n-\n-The error looks like this: `leaked memory in rust main loop (2 objects)' failed, rt/memory_region.cpp:99 2 objects`.\n-\n-This message indicates a memory leak, and is mostly likely to happen on rarely exercised failure paths. Note that failure unwinding is not yet implemented on windows so this is expected. If you see this on Linux or Mac it's a compiler bug; please report it.\n-\n-# Why did my build create a bunch of zero-length files in my lib directory?\n-\n-This is a normal part of the Rust build process. The build system uses these zero-length files for dependency tracking, as the actual names of the Rust libraries contain hashes that can't be guessed easily by the Makefiles."}, {"sha": "1d99a461161d2b920761a39b6bcbc67f2f6e5acc", "filename": "src/doc/index.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30dcc8285bf64e50e7b1b51b351465d99fb5c8a7/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/30dcc8285bf64e50e7b1b51b351465d99fb5c8a7/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=30dcc8285bf64e50e7b1b51b351465d99fb5c8a7", "patch": "@@ -55,7 +55,6 @@ li {list-style-type: none; }\n \n * [Language FAQ](complement-lang-faq.html)\n * [Project FAQ](complement-project-faq.html)\n-* [Usage FAQ](complement-usage-faq.html)\n * [Code cheatsheet](complement-cheatsheet.html) - \"How do I do X?\"\n * [How to submit a bug report](complement-bugreport.html)\n "}]}