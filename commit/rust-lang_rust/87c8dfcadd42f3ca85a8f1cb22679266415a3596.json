{"sha": "87c8dfcadd42f3ca85a8f1cb22679266415a3596", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YzhkZmNhZGQ0MmYzY2E4NWE4ZjFjYjIyNjc5MjY2NDE1YTM1OTY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-11T13:41:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-11T13:41:15Z"}, "message": "Merge #5970\n\n5970: Use better heuristics for replacement text when removing dbg! r=jonas-schievink a=SomeoneToIgnore\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/5911\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "ef464426799fe6adb2d38270f7f3a8062aa81c34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef464426799fe6adb2d38270f7f3a8062aa81c34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87c8dfcadd42f3ca85a8f1cb22679266415a3596", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfW357CRBK7hj4Ov3rIwAAdHIIAAwk4YhrC3NxLLUX7PdZH3Pb\nE9LQA3I9m3aRBUWvP6LrYgl9tkgFjiHPXNKZnM/1Qzbl6LerNo4EuLdPMvtkIxER\nLMQDtoKNCGcSIAuoXJ0BomAxqDjix9m28Pm2G3O8Mn/CsC+Yy11qTBdk85pz0Bl9\nR9V8xz2A6/lA0HDXEE43yMP4TnRWe2RcEGin8lHP6sw5w4YWiEdK1ufwGuxwBZwB\n1T5gdPu76juUoiZ6jQxsssxMbcGSWdQzlmjehBr2GLJOwvE1CXdlk+CUkAuVSeV+\ne7rkFTznA7wr1lgiu1+aiaMjmw/zZDUyso2x2q517/wLx9rCLFxSIUVaKfqR/3k=\n=cyVS\n-----END PGP SIGNATURE-----\n", "payload": "tree ef464426799fe6adb2d38270f7f3a8062aa81c34\nparent 4f1167d8ddac9d392f034341e6bc032b51014918\nparent b477f99bd9d6ae81001451cc310efe0ac950eb61\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1599831675 +0000\ncommitter GitHub <noreply@github.com> 1599831675 +0000\n\nMerge #5970\n\n5970: Use better heuristics for replacement text when removing dbg! r=jonas-schievink a=SomeoneToIgnore\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/5911\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87c8dfcadd42f3ca85a8f1cb22679266415a3596", "html_url": "https://github.com/rust-lang/rust/commit/87c8dfcadd42f3ca85a8f1cb22679266415a3596", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87c8dfcadd42f3ca85a8f1cb22679266415a3596/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f1167d8ddac9d392f034341e6bc032b51014918", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f1167d8ddac9d392f034341e6bc032b51014918", "html_url": "https://github.com/rust-lang/rust/commit/4f1167d8ddac9d392f034341e6bc032b51014918"}, {"sha": "b477f99bd9d6ae81001451cc310efe0ac950eb61", "url": "https://api.github.com/repos/rust-lang/rust/commits/b477f99bd9d6ae81001451cc310efe0ac950eb61", "html_url": "https://github.com/rust-lang/rust/commit/b477f99bd9d6ae81001451cc310efe0ac950eb61"}], "stats": {"total": 155, "additions": 118, "deletions": 37}, "files": [{"sha": "0b581dc22a27163427d15f50290c2a585c264e2f", "filename": "crates/assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 118, "deletions": 37, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/87c8dfcadd42f3ca85a8f1cb22679266415a3596/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c8dfcadd42f3ca85a8f1cb22679266415a3596/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=87c8dfcadd42f3ca85a8f1cb22679266415a3596", "patch": "@@ -1,6 +1,6 @@\n use syntax::{\n     ast::{self, AstNode},\n-    TextRange, TextSize, T,\n+    SyntaxElement, TextRange, TextSize, T,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -22,62 +22,118 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let macro_call = ctx.find_node_at_offset::<ast::MacroCall>()?;\n+    let new_contents = adjusted_macro_contents(&macro_call)?;\n \n-    if !is_valid_macrocall(&macro_call, \"dbg\")? {\n-        return None;\n-    }\n-\n-    let is_leaf = macro_call.syntax().next_sibling().is_none();\n-\n+    let macro_text_range = macro_call.syntax().text_range();\n     let macro_end = if macro_call.semicolon_token().is_some() {\n-        macro_call.syntax().text_range().end() - TextSize::of(';')\n+        macro_text_range.end() - TextSize::of(';')\n     } else {\n-        macro_call.syntax().text_range().end()\n+        macro_text_range.end()\n     };\n \n-    // macro_range determines what will be deleted and replaced with macro_content\n-    let macro_range = TextRange::new(macro_call.syntax().text_range().start(), macro_end);\n-    let paste_instead_of_dbg = {\n-        let text = macro_call.token_tree()?.syntax().text();\n-\n-        // leafiness determines if we should include the parenthesis or not\n-        let slice_index: TextRange = if is_leaf {\n-            // leaf means - we can extract the contents of the dbg! in text\n-            TextRange::new(TextSize::of('('), text.len() - TextSize::of(')'))\n-        } else {\n-            // not leaf - means we should keep the parens\n-            TextRange::up_to(text.len())\n-        };\n-        text.slice(slice_index).to_string()\n-    };\n+    acc.add(\n+        AssistId(\"remove_dbg\", AssistKind::Refactor),\n+        \"Remove dbg!()\",\n+        macro_text_range,\n+        |builder| {\n+            builder.replace(TextRange::new(macro_text_range.start(), macro_end), new_contents);\n+        },\n+    )\n+}\n \n-    let target = macro_call.syntax().text_range();\n-    acc.add(AssistId(\"remove_dbg\", AssistKind::Refactor), \"Remove dbg!()\", target, |builder| {\n-        builder.replace(macro_range, paste_instead_of_dbg);\n-    })\n+fn adjusted_macro_contents(macro_call: &ast::MacroCall) -> Option<String> {\n+    let contents = get_valid_macrocall_contents(&macro_call, \"dbg\")?;\n+    let is_leaf = macro_call.syntax().next_sibling().is_none();\n+    let macro_text_with_brackets = macro_call.token_tree()?.syntax().text();\n+    let slice_index = if is_leaf || !needs_parentheses_around_macro_contents(contents) {\n+        TextRange::new(TextSize::of('('), macro_text_with_brackets.len() - TextSize::of(')'))\n+    } else {\n+        // leave parenthesis around macro contents to preserve the semantics\n+        TextRange::up_to(macro_text_with_brackets.len())\n+    };\n+    Some(macro_text_with_brackets.slice(slice_index).to_string())\n }\n \n /// Verifies that the given macro_call actually matches the given name\n-/// and contains proper ending tokens\n-fn is_valid_macrocall(macro_call: &ast::MacroCall, macro_name: &str) -> Option<bool> {\n+/// and contains proper ending tokens, then returns the contents between the ending tokens\n+fn get_valid_macrocall_contents(\n+    macro_call: &ast::MacroCall,\n+    macro_name: &str,\n+) -> Option<Vec<SyntaxElement>> {\n     let path = macro_call.path()?;\n     let name_ref = path.segment()?.name_ref()?;\n \n     // Make sure it is actually a dbg-macro call, dbg followed by !\n     let excl = path.syntax().next_sibling_or_token()?;\n-\n     if name_ref.text() != macro_name || excl.kind() != T![!] {\n         return None;\n     }\n \n-    let node = macro_call.token_tree()?.syntax().clone();\n-    let first_child = node.first_child_or_token()?;\n-    let last_child = node.last_child_or_token()?;\n+    let mut children_with_tokens = macro_call.token_tree()?.syntax().children_with_tokens();\n+    let first_child = children_with_tokens.next()?;\n+    let mut contents_between_brackets = children_with_tokens.collect::<Vec<_>>();\n+    let last_child = contents_between_brackets.pop()?;\n+\n+    if contents_between_brackets.is_empty() {\n+        None\n+    } else {\n+        match (first_child.kind(), last_child.kind()) {\n+            (T!['('], T![')']) | (T!['['], T![']']) | (T!['{'], T!['}']) => {\n+                Some(contents_between_brackets)\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n+fn needs_parentheses_around_macro_contents(macro_contents: Vec<SyntaxElement>) -> bool {\n+    if macro_contents.len() < 2 {\n+        return false;\n+    }\n+\n+    let mut macro_contents_kind_not_in_brackets = Vec::with_capacity(macro_contents.len());\n \n-    match (first_child.kind(), last_child.kind()) {\n-        (T!['('], T![')']) | (T!['['], T![']']) | (T!['{'], T!['}']) => Some(true),\n-        _ => Some(false),\n+    let mut first_bracket_in_macro = None;\n+    let mut unpaired_brackets_in_contents = Vec::new();\n+    for element in macro_contents {\n+        match element.kind() {\n+            T!['('] | T!['['] | T!['{'] => {\n+                if let None = first_bracket_in_macro {\n+                    first_bracket_in_macro = Some(element.clone())\n+                }\n+                unpaired_brackets_in_contents.push(element);\n+            }\n+            T![')'] => {\n+                if !matches!(unpaired_brackets_in_contents.pop(), Some(correct_bracket) if correct_bracket.kind() == T!['('])\n+                {\n+                    return true;\n+                }\n+            }\n+            T![']'] => {\n+                if !matches!(unpaired_brackets_in_contents.pop(), Some(correct_bracket) if correct_bracket.kind() == T!['['])\n+                {\n+                    return true;\n+                }\n+            }\n+            T!['}'] => {\n+                if !matches!(unpaired_brackets_in_contents.pop(), Some(correct_bracket) if correct_bracket.kind() == T!['{'])\n+                {\n+                    return true;\n+                }\n+            }\n+            other_kind => {\n+                if unpaired_brackets_in_contents.is_empty() {\n+                    macro_contents_kind_not_in_brackets.push(other_kind);\n+                }\n+            }\n+        }\n     }\n+\n+    !unpaired_brackets_in_contents.is_empty()\n+        || matches!(first_bracket_in_macro, Some(bracket) if bracket.kind() != T!['('])\n+        || macro_contents_kind_not_in_brackets\n+            .into_iter()\n+            .any(|macro_contents_kind| macro_contents_kind.is_punct())\n }\n \n #[cfg(test)]\n@@ -156,13 +212,38 @@ fn foo(n: usize) {\n         );\n     }\n \n+    #[test]\n+    fn remove_dbg_from_non_leaf_simple_expression() {\n+        check_assist(\n+            remove_dbg,\n+            \"\n+fn main() {\n+    let mut a = 1;\n+    while dbg!<|>(a) < 10000 {\n+        a += 1;\n+    }\n+}\n+\",\n+            \"\n+fn main() {\n+    let mut a = 1;\n+    while a < 10000 {\n+        a += 1;\n+    }\n+}\n+\",\n+        );\n+    }\n+\n     #[test]\n     fn test_remove_dbg_keep_expression() {\n         check_assist(\n             remove_dbg,\n             r#\"let res = <|>dbg!(a + b).foo();\"#,\n             r#\"let res = (a + b).foo();\"#,\n         );\n+\n+        check_assist(remove_dbg, r#\"let res = <|>dbg!(2 + 2) * 5\"#, r#\"let res = (2 + 2) * 5\"#);\n     }\n \n     #[test]"}]}