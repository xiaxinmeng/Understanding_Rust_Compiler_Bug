{"sha": "f3f7e083dc92aba7a4c1818e56464fcb79f22f19", "node_id": "C_kwDOAAsO6NoAKGYzZjdlMDgzZGM5MmFiYTdhNGMxODE4ZTU2NDY0ZmNiNzlmMjJmMTk", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-03-12T22:23:22Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-04-30T14:25:51Z"}, "message": "Print spans where tags are created and invalidated", "tree": {"sha": "ce9c892d0207814fce2c0b67db42cebf727e7a26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce9c892d0207814fce2c0b67db42cebf727e7a26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3f7e083dc92aba7a4c1818e56464fcb79f22f19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f7e083dc92aba7a4c1818e56464fcb79f22f19", "html_url": "https://github.com/rust-lang/rust/commit/f3f7e083dc92aba7a4c1818e56464fcb79f22f19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3f7e083dc92aba7a4c1818e56464fcb79f22f19/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf5e75389dd0c67ffe8e1169cbbae7a1d0abe05e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf5e75389dd0c67ffe8e1169cbbae7a1d0abe05e", "html_url": "https://github.com/rust-lang/rust/commit/cf5e75389dd0c67ffe8e1169cbbae7a1d0abe05e"}], "stats": {"total": 393, "additions": 341, "deletions": 52}, "files": [{"sha": "c6b6c3388cab9b374c6519683fea4701eee0df9d", "filename": "src/diagnostics.rs", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f3f7e083dc92aba7a4c1818e56464fcb79f22f19/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f7e083dc92aba7a4c1818e56464fcb79f22f19/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=f3f7e083dc92aba7a4c1818e56464fcb79f22f19", "patch": "@@ -7,7 +7,8 @@ use log::trace;\n use rustc_middle::ty;\n use rustc_span::{source_map::DUMMY_SP, Span, SpanData, Symbol};\n \n-use crate::stacked_borrows::{AccessKind, SbTag};\n+use crate::helpers::HexRange;\n+use crate::stacked_borrows::{AccessKind, SbTag, TagHistory};\n use crate::*;\n \n /// Details of premature program termination.\n@@ -19,6 +20,7 @@ pub enum TerminationInfo {\n         msg: String,\n         help: Option<String>,\n         url: String,\n+        history: Option<TagHistory>,\n     },\n     Deadlock,\n     MultipleSymbolDefinitions {\n@@ -155,12 +157,46 @@ pub fn report_error<'tcx, 'mir>(\n                         (None, format!(\"pass the flag `-Zmiri-disable-isolation` to disable isolation;\")),\n                         (None, format!(\"or pass `-Zmiri-isolation-error=warn` to configure Miri to return an error code from isolated operations (if supported for that operation) and continue with a warning\")),\n                     ],\n-                ExperimentalUb { url, help, .. } => {\n+                ExperimentalUb { url, help, history, .. } => {\n                     msg.extend(help.clone());\n-                    vec![\n+                    let mut helps = vec![\n                         (None, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\")),\n-                        (None, format!(\"see {} for further information\", url))\n-                    ]\n+                        (None, format!(\"see {} for further information\", url)),\n+                    ];\n+                    match history {\n+                        Some(TagHistory::Tagged {tag, created: (created_range, created_span), invalidated, protected }) => {\n+                            let msg = format!(\"{:?} was created due to a retag at offsets {}\", tag, HexRange(*created_range));\n+                            helps.push((Some(created_span.clone()), msg));\n+                            if let Some((invalidated_range, invalidated_span)) = invalidated {\n+                                let msg = format!(\"{:?} was later invalidated due to a retag at offsets {}\", tag, HexRange(*invalidated_range));\n+                                helps.push((Some(invalidated_span.clone()), msg));\n+                            }\n+                            if let Some((protecting_tag, protecting_tag_span, protection_span)) = protected {\n+                                helps.push((Some(protecting_tag_span.clone()), format!(\"{:?} was protected due to {:?} which was created here\", tag, protecting_tag)));\n+                                helps.push((Some(protection_span.clone()), \"this protector is live for this call\".to_string()));\n+                            }\n+                        }\n+                        Some(TagHistory::Untagged{ recently_created, recently_invalidated, matching_created, protected }) => {\n+                            if let Some((range, span)) = recently_created {\n+                                let msg = format!(\"tag was most recently created at offsets {}\", HexRange(*range));\n+                                helps.push((Some(span.clone()), msg));\n+                            }\n+                            if let Some((range, span)) = recently_invalidated {\n+                                let msg = format!(\"tag was later invalidated at offsets {}\", HexRange(*range));\n+                                helps.push((Some(span.clone()), msg));\n+                            }\n+                            if let Some((range, span)) = matching_created {\n+                                let msg = format!(\"this tag was also created here at offsets {}\", HexRange(*range));\n+                                helps.push((Some(span.clone()), msg));\n+                            }\n+                            if let Some((protecting_tag, protecting_tag_span, protection_span)) = protected {\n+                                helps.push((Some(protecting_tag_span.clone()), format!(\"{:?} was protected due to a tag which was created here\", protecting_tag)));\n+                                helps.push((Some(protection_span.clone()), \"this protector is live for this call\".to_string()));\n+                            }\n+                        }\n+                        None => {}\n+                    }\n+                    helps\n                 }\n                 MultipleSymbolDefinitions { first, first_crate, second, second_crate, .. } =>\n                     vec!["}, {"sha": "8b964ba90f046aa89ae6bf74ece9549ed13238ca", "filename": "src/eval.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f3f7e083dc92aba7a4c1818e56464fcb79f22f19/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f7e083dc92aba7a4c1818e56464fcb79f22f19/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=f3f7e083dc92aba7a4c1818e56464fcb79f22f19", "patch": "@@ -283,6 +283,24 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     Ok((ecx, ret_place))\n }\n \n+// This is potentially a performance hazard.\n+// Factoring it into its own function lets us keep an eye on how much it shows up in a profile.\n+fn set_current_span<'mir, 'tcx: 'mir>(ecx: &mut MiriEvalContext<'mir, 'tcx>) {\n+    let current_span = Machine::stack(&ecx)\n+        .into_iter()\n+        .rev()\n+        .find(|frame| {\n+            let info =\n+                FrameInfo { instance: frame.instance, span: frame.current_span(), lint_root: None };\n+            ecx.machine.is_local(&info)\n+        })\n+        .map(|frame| frame.current_span())\n+        .unwrap_or(rustc_span::DUMMY_SP);\n+    if let Some(sb) = ecx.machine.stacked_borrows.as_mut() {\n+        sb.get_mut().current_span = current_span;\n+    }\n+}\n+\n /// Evaluates the entry function specified by `entry_id`.\n /// Returns `Some(return_code)` if program executed completed.\n /// Returns `None` if an evaluation error occured.\n@@ -310,6 +328,9 @@ pub fn eval_entry<'tcx>(\n             let info = ecx.preprocess_diagnostics();\n             match ecx.schedule()? {\n                 SchedulingAction::ExecuteStep => {\n+                    if ecx.machine.stacked_borrows.is_some() {\n+                        set_current_span(&mut ecx);\n+                    }\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n                 }\n                 SchedulingAction::ExecuteTimeoutCallback => {"}, {"sha": "8d7147fff7a4b4ca00d2ea7cf27daaa62edb3e4e", "filename": "src/helpers.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3f7e083dc92aba7a4c1818e56464fcb79f22f19/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f7e083dc92aba7a4c1818e56464fcb79f22f19/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=f3f7e083dc92aba7a4c1818e56464fcb79f22f19", "patch": "@@ -813,3 +813,12 @@ pub fn get_local_crates(tcx: &TyCtxt<'_>) -> Vec<CrateNum> {\n     }\n     local_crates\n }\n+\n+/// Formats an AllocRange like [0x1..0x3], for use in diagnostics.\n+pub struct HexRange(pub AllocRange);\n+\n+impl std::fmt::Display for HexRange {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"[{:#x}..{:#x}]\", self.0.start.bytes(), self.0.end().bytes())\n+    }\n+}"}, {"sha": "5f25fd298865289e0e1c4dd41abd8f818fee63a1", "filename": "src/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3f7e083dc92aba7a4c1818e56464fcb79f22f19/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f7e083dc92aba7a4c1818e56464fcb79f22f19/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=f3f7e083dc92aba7a4c1818e56464fcb79f22f19", "patch": "@@ -632,7 +632,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 alloc_id,\n                 tag,\n                 range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n+                 machine.stacked_borrows.as_ref().unwrap(),\n             )\n         } else {\n             Ok(())\n@@ -655,7 +655,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 alloc_id,\n                 tag,\n                 range,\n-                machine.stacked_borrows.as_mut().unwrap(),\n+                machine.stacked_borrows.as_ref().unwrap(),\n             )\n         } else {\n             Ok(())\n@@ -681,7 +681,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 alloc_id,\n                 tag,\n                 range,\n-                machine.stacked_borrows.as_mut().unwrap(),\n+                machine.stacked_borrows.as_ref().unwrap(),\n             )\n         } else {\n             Ok(())"}, {"sha": "225407a7bbfa4f6f7ac60a98ba81cc5befd598fe", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 267, "deletions": 44, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/f3f7e083dc92aba7a4c1818e56464fcb79f22f19/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f7e083dc92aba7a4c1818e56464fcb79f22f19/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=f3f7e083dc92aba7a4c1818e56464fcb79f22f19", "patch": "@@ -3,6 +3,7 @@\n \n use log::trace;\n use std::cell::RefCell;\n+use std::collections::HashMap;\n use std::fmt;\n use std::num::NonZeroU64;\n \n@@ -14,9 +15,11 @@ use rustc_middle::ty::{\n     layout::{HasParamEnv, LayoutOf},\n };\n use rustc_span::DUMMY_SP;\n+use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n use std::collections::HashSet;\n \n+use crate::helpers::HexRange;\n use crate::*;\n \n pub type PtrId = NonZeroU64;\n@@ -111,7 +114,53 @@ pub struct GlobalStateInner {\n     tracked_call_ids: HashSet<CallId>,\n     /// Whether to track raw pointers.\n     tag_raw: bool,\n+    /// Extra per-allocation information\n+    extras: HashMap<AllocId, AllocHistory>,\n+    /// Current span\n+    pub(crate) current_span: Span,\n }\n+\n+#[derive(Debug, Default)]\n+struct AllocHistory {\n+    // The time tags can be compressed down to one bit per event, by just storing a Vec<u8>\n+    // where each bit is set to indicate if the event was a creation or a retag\n+    current_time: usize,\n+    creations: Vec<Event>,\n+    invalidations: Vec<Event>,\n+    protectors: Vec<Protection>,\n+}\n+\n+#[derive(Debug)]\n+struct Protection {\n+    orig_tag: SbTag,\n+    tag: SbTag,\n+    span: Span,\n+}\n+\n+#[derive(Debug)]\n+struct Event {\n+    time: usize,\n+    parent: Option<SbTag>,\n+    tag: SbTag,\n+    range: AllocRange,\n+    span: Span,\n+}\n+\n+pub enum TagHistory {\n+    Tagged {\n+        tag: SbTag,\n+        created: (AllocRange, SpanData),\n+        invalidated: Option<(AllocRange, SpanData)>,\n+        protected: Option<(SbTag, SpanData, SpanData)>,\n+    },\n+    Untagged {\n+        recently_created: Option<(AllocRange, SpanData)>,\n+        recently_invalidated: Option<(AllocRange, SpanData)>,\n+        matching_created: Option<(AllocRange, SpanData)>,\n+        protected: Option<(SbTag, SpanData, SpanData)>,\n+    },\n+}\n+\n /// We need interior mutable access to the global state.\n pub type GlobalState = RefCell<GlobalStateInner>;\n \n@@ -171,6 +220,8 @@ impl GlobalStateInner {\n             tracked_pointer_tags,\n             tracked_call_ids,\n             tag_raw,\n+            extras: HashMap::new(),\n+            current_span: DUMMY_SP,\n         }\n     }\n \n@@ -218,16 +269,155 @@ impl GlobalStateInner {\n         self.base_ptr_ids.try_insert(id, tag).unwrap();\n         tag\n     }\n+\n+    fn add_creation(\n+        &mut self,\n+        parent: Option<SbTag>,\n+        tag: SbTag,\n+        alloc: AllocId,\n+        range: AllocRange,\n+    ) {\n+        let extras = self.extras.entry(alloc).or_default();\n+        extras.creations.push(Event {\n+            parent,\n+            tag,\n+            range,\n+            span: self.current_span,\n+            time: extras.current_time,\n+        });\n+        extras.current_time += 1;\n+    }\n+\n+    fn add_invalidation(&mut self, tag: SbTag, alloc: AllocId, range: AllocRange) {\n+        let extras = self.extras.entry(alloc).or_default();\n+        extras.invalidations.push(Event {\n+            parent: None,\n+            tag,\n+            range,\n+            span: self.current_span,\n+            time: extras.current_time,\n+        });\n+        extras.current_time += 1;\n+    }\n+\n+    fn add_protector(&mut self, orig_tag: SbTag, tag: SbTag, alloc: AllocId) {\n+        let extras = self.extras.entry(alloc).or_default();\n+        extras.protectors.push(Protection { orig_tag, tag, span: self.current_span });\n+        extras.current_time += 1;\n+    }\n+\n+    fn get_stack_history(\n+        &self,\n+        tag: SbTag,\n+        alloc: AllocId,\n+        alloc_range: AllocRange,\n+        offset: Size,\n+        protector_tag: Option<SbTag>,\n+    ) -> Option<TagHistory> {\n+        let extras = self.extras.get(&alloc)?;\n+        let protected = protector_tag\n+            .and_then(|protector| {\n+                extras.protectors.iter().find_map(|protection| {\n+                    if protection.tag == protector {\n+                        Some((protection.orig_tag, protection.span.data()))\n+                    } else {\n+                        None\n+                    }\n+                })\n+            })\n+            .and_then(|(tag, call_span)| {\n+                extras.creations.iter().rev().find_map(|event| {\n+                    if event.tag == tag {\n+                        Some((event.parent?, event.span.data(), call_span))\n+                    } else {\n+                        None\n+                    }\n+                })\n+            });\n+        if let SbTag::Tagged(_) = tag {\n+            let get_matching = |events: &[Event]| {\n+                events.iter().rev().find_map(|event| {\n+                    if event.tag == tag { Some((event.range, event.span.data())) } else { None }\n+                })\n+            };\n+            Some(TagHistory::Tagged {\n+                tag,\n+                created: get_matching(&extras.creations)?,\n+                invalidated: get_matching(&extras.invalidations),\n+                protected,\n+            })\n+        } else {\n+            let mut created_time = 0;\n+            // Find the most recently created tag that satsfies this offset\n+            let recently_created = extras.creations.iter().rev().find_map(|event| {\n+                if event.tag == tag && offset >= event.range.start && offset < event.range.end() {\n+                    created_time = event.time;\n+                    Some((event.range, event.span.data()))\n+                } else {\n+                    None\n+                }\n+            });\n+\n+            // Find a different recently created tag that satisfies this whole operation, predates\n+            // the recently created tag, and has a different span.\n+            // We're trying to make a guess at which span the user wanted to provide the tag that\n+            // they're using.\n+            let matching_created = if let Some((_created_range, created_span)) = recently_created {\n+                extras.creations.iter().rev().find_map(|event| {\n+                    if event.tag == tag\n+                        && alloc_range.start >= event.range.start\n+                        && alloc_range.end() <= event.range.end()\n+                        && event.span.data() != created_span\n+                        && event.time != created_time\n+                    {\n+                        Some((event.range, event.span.data()))\n+                    } else {\n+                        None\n+                    }\n+                })\n+            } else {\n+                None\n+            };\n+\n+            let recently_invalidated = if recently_created.is_some() {\n+                // Find the most recent invalidation of this tag which post-dates the creation\n+                let mut found = None;\n+                for event in extras.invalidations.iter().rev() {\n+                    if event.time < created_time {\n+                        break;\n+                    }\n+                    if event.tag == tag && offset >= event.range.start && offset < event.range.end()\n+                    {\n+                        found = Some((event.range, event.span.data()))\n+                    }\n+                }\n+                found\n+            } else {\n+                None\n+            };\n+            Some(TagHistory::Untagged {\n+                recently_created,\n+                matching_created,\n+                recently_invalidated,\n+                protected,\n+            })\n+        }\n+    }\n }\n \n /// Error reporting\n-fn err_sb_ub(msg: String, help: Option<String>) -> InterpError<'static> {\n+fn err_sb_ub(\n+    msg: String,\n+    help: Option<String>,\n+    history: Option<TagHistory>,\n+) -> InterpError<'static> {\n     err_machine_stop!(TerminationInfo::ExperimentalUb {\n         msg,\n         help,\n         url: format!(\n             \"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\"\n         ),\n+        history\n     })\n }\n \n@@ -308,31 +498,39 @@ impl<'tcx> Stack {\n     /// `None` during a deallocation.\n     fn check_protector(\n         item: &Item,\n-        provoking_access: Option<(SbTag, AccessKind)>,\n+        provoking_access: Option<(SbTag, AllocId, AllocRange, Size)>, // just for debug printing amd error messages\n         global: &GlobalStateInner,\n     ) -> InterpResult<'tcx> {\n         if let SbTag::Tagged(id) = item.tag {\n             if global.tracked_pointer_tags.contains(&id) {\n                 register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n                     *item,\n-                    provoking_access,\n+                    None,\n                 ));\n             }\n         }\n         if let Some(call) = item.protector {\n             if global.is_active(call) {\n-                if let Some((tag, _)) = provoking_access {\n+                if let Some((tag, alloc_id, alloc_range, offset)) = provoking_access {\n                     Err(err_sb_ub(\n                         format!(\n                             \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n                             tag, item\n                         ),\n                         None,\n+                        global.get_stack_history(\n+                            tag,\n+                            alloc_id,\n+                            alloc_range,\n+                            offset,\n+                            Some(item.tag),\n+                        ),\n                     ))?\n                 } else {\n                     Err(err_sb_ub(\n                         format!(\"deallocating while item is protected: {:?}\", item),\n                         None,\n+                        None,\n                     ))?\n                 }\n             }\n@@ -348,15 +546,15 @@ impl<'tcx> Stack {\n         &mut self,\n         access: AccessKind,\n         tag: SbTag,\n-        (alloc_id, range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n-        global: &GlobalStateInner,\n+        (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n+        global: &mut GlobalStateInner,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self\n-            .find_granting(access, tag)\n-            .ok_or_else(|| self.access_error(access, tag, alloc_id, range, offset))?;\n+        let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n+            self.access_error(access, tag, alloc_id, alloc_range, offset, global)\n+        })?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -366,7 +564,8 @@ impl<'tcx> Stack {\n             let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n                 trace!(\"access: popping item {:?}\", item);\n-                Stack::check_protector(&item, Some((tag, access)), global)?;\n+                Stack::check_protector(&item, Some((tag, alloc_id, alloc_range, offset)), global)?;\n+                global.add_invalidation(item.tag, alloc_id, alloc_range);\n             }\n         } else {\n             // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n@@ -381,8 +580,13 @@ impl<'tcx> Stack {\n                 let item = &mut self.borrows[idx];\n                 if item.perm == Permission::Unique {\n                     trace!(\"access: disabling item {:?}\", item);\n-                    Stack::check_protector(item, Some((tag, access)), global)?;\n+                    Stack::check_protector(\n+                        item,\n+                        Some((tag, alloc_id, alloc_range, offset)),\n+                        global,\n+                    )?;\n                     item.perm = Permission::Disabled;\n+                    global.add_invalidation(item.tag, alloc_id, alloc_range);\n                 }\n             }\n         }\n@@ -396,15 +600,18 @@ impl<'tcx> Stack {\n     fn dealloc(\n         &mut self,\n         tag: SbTag,\n-        dbg_ptr: Pointer<AllocId>, // just for debug printing and error messages\n+        (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing amd error messages\n         global: &GlobalStateInner,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n         self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n             err_sb_ub(format!(\n                 \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n-                tag, dbg_ptr,\n-            ), None)\n+                tag, alloc_id,\n+                ),\n+                None,\n+                global.get_stack_history(tag, alloc_id, alloc_range, offset, None),\n+            )\n         })?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n@@ -426,16 +633,16 @@ impl<'tcx> Stack {\n         derived_from: SbTag,\n         new: Item,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n-        global: &GlobalStateInner,\n+        global: &mut GlobalStateInner,\n     ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n             if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n-        let granting_idx = self\n-            .find_granting(access, derived_from)\n-            .ok_or_else(|| self.grant_error(derived_from, new, alloc_id, alloc_range, offset))?;\n+        let granting_idx = self.find_granting(access, derived_from).ok_or_else(|| {\n+            self.grant_error(derived_from, new, alloc_id, alloc_range, offset, global)\n+        })?;\n \n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n@@ -483,6 +690,7 @@ impl<'tcx> Stack {\n         alloc_id: AllocId,\n         alloc_range: AllocRange,\n         error_offset: Size,\n+        global: &GlobalStateInner,\n     ) -> InterpError<'static> {\n         let action = format!(\n             \"trying to reborrow {:?} for {:?} permission at {}[{:#x}]\",\n@@ -494,6 +702,7 @@ impl<'tcx> Stack {\n         err_sb_ub(\n             format!(\"{}{}\", action, self.error_cause(derived_from)),\n             Some(Self::operation_summary(\"a reborrow\", alloc_id, alloc_range)),\n+            global.get_stack_history(derived_from, alloc_id, alloc_range, error_offset, None),\n         )\n     }\n \n@@ -505,6 +714,7 @@ impl<'tcx> Stack {\n         alloc_id: AllocId,\n         alloc_range: AllocRange,\n         error_offset: Size,\n+        global: &GlobalStateInner,\n     ) -> InterpError<'static> {\n         let action = format!(\n             \"attempting a {} using {:?} at {}[{:#x}]\",\n@@ -516,6 +726,7 @@ impl<'tcx> Stack {\n         err_sb_ub(\n             format!(\"{}{}\", action, self.error_cause(tag)),\n             Some(Self::operation_summary(\"an access\", alloc_id, alloc_range)),\n+            global.get_stack_history(tag, alloc_id, alloc_range, error_offset, None),\n         )\n     }\n \n@@ -525,11 +736,10 @@ impl<'tcx> Stack {\n         alloc_range: AllocRange,\n     ) -> String {\n         format!(\n-            \"this error occurs as part of {} at {:?}[{:#x}..{:#x}]\",\n+            \"this error occurs as part of {} at {:?}{}\",\n             operation,\n             alloc_id,\n-            alloc_range.start.bytes(),\n-            alloc_range.end().bytes()\n+            HexRange(alloc_range)\n         )\n     }\n \n@@ -620,6 +830,7 @@ impl Stacks {\n                 (tag, Permission::SharedReadWrite)\n             }\n         };\n+        extra.add_creation(None, base_tag, id, alloc_range(Size::ZERO, size));\n         Stacks::new(size, perm, base_tag)\n     }\n \n@@ -637,29 +848,29 @@ impl Stacks {\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let global = &*state.borrow();\n         self.for_each(range, move |offset, stack| {\n-            stack.access(AccessKind::Read, tag, (alloc_id, range, offset), global)\n+            let mut state = state.borrow_mut();\n+            stack.access(AccessKind::Read, tag, (alloc_id, range, offset), &mut state)\n         })\n-    }\n+   }\n \n     #[inline(always)]\n     pub fn memory_written<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n         tag: SbTag,\n         range: AllocRange,\n-        state: &mut GlobalState,\n+        state: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let global = state.get_mut();\n         self.for_each_mut(range, move |offset, stack| {\n-            stack.access(AccessKind::Write, tag, (alloc_id, range, offset), global)\n+            let mut state = state.borrow_mut();\n+            stack.access(AccessKind::Write, tag, (alloc_id, range, offset), &mut state)\n         })\n     }\n \n@@ -669,13 +880,15 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: SbTag,\n         range: AllocRange,\n-        state: &mut GlobalState,\n+        state: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n-        let global = state.get_mut();\n         self.for_each_mut(range, move |offset, stack| {\n-            stack.dealloc(tag, Pointer::new(alloc_id, offset), global)\n-        })\n+            let mut state = state.borrow_mut();\n+            stack.dealloc(tag, (alloc_id, range, offset), &mut state)\n+        })?;\n+        state.borrow_mut().extras.remove(&alloc_id);\n+        Ok(())\n     }\n }\n \n@@ -705,6 +918,17 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         let (alloc_id, base_offset, orig_tag) = this.ptr_get_alloc_id(place.ptr)?;\n \n+        let mem_extra = this.machine.stacked_borrows.as_mut().unwrap().get_mut();\n+        mem_extra.add_creation(\n+            Some(orig_tag),\n+            new_tag,\n+            alloc_id,\n+            alloc_range(base_offset, base_offset + size),\n+        );\n+        if protect {\n+            mem_extra.add_protector(orig_tag, new_tag, alloc_id);\n+        }\n+\n         // Ensure we bail out if the pointer goes out-of-bounds (see miri#1050).\n         let (alloc_size, _) =\n             this.get_alloc_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n@@ -753,7 +977,6 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let extra = this.get_alloc_extra(alloc_id)?;\n                 let stacked_borrows =\n                     extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n-                let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -765,7 +988,9 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n                     stacked_borrows.for_each(range, |offset, stack| {\n-                        stack.grant(orig_tag, item, (alloc_id, range, offset), &*global)\n+                        let mut global =\n+                            this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n+                        stack.grant(orig_tag, item, (alloc_id, range, offset), &mut *global)\n                     })\n                 })?;\n                 return Ok(());\n@@ -777,11 +1002,11 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let (alloc_extra, memory_extra) = this.get_alloc_extra_mut(alloc_id)?;\n         let stacked_borrows =\n             alloc_extra.stacked_borrows.as_mut().expect(\"we should have Stacked Borrows data\");\n-        let global = memory_extra.stacked_borrows.as_mut().unwrap().get_mut();\n         let item = Item { perm, tag: new_tag, protector };\n         let range = alloc_range(base_offset, size);\n-        stacked_borrows.for_each_mut(alloc_range(base_offset, size), |offset, stack| {\n-            stack.grant(orig_tag, item, (alloc_id, range, offset), global)\n+        stacked_borrows.for_each_mut(range, |offset, stack| {\n+            let mut global = memory_extra.stacked_borrows.as_ref().unwrap().borrow_mut();\n+            stack.grant(orig_tag, item, (alloc_id, range, offset), &mut *global)\n         })?;\n         Ok(())\n     }\n@@ -807,14 +1032,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n \n         // Compute new borrow.\n-        let new_tag = {\n-            let mem_extra = this.machine.stacked_borrows.as_mut().unwrap().get_mut();\n-            match kind {\n-                // Give up tracking for raw pointers.\n-                RefKind::Raw { .. } if !mem_extra.tag_raw => SbTag::Untagged,\n-                // All other pointers are properly tracked.\n-                _ => SbTag::Tagged(mem_extra.new_ptr()),\n-            }\n+        let mem_extra = this.machine.stacked_borrows.as_mut().unwrap().get_mut();\n+        let new_tag = match kind {\n+            // Give up tracking for raw pointers.\n+            RefKind::Raw { .. } if !mem_extra.tag_raw => SbTag::Untagged,\n+            // All other pointers are properly tracked.\n+            _ => SbTag::Tagged(mem_extra.new_ptr()),\n         };\n \n         // Reborrow."}]}