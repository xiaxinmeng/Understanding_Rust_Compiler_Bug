{"sha": "e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "node_id": "C_kwDOAAsO6NoAKGU3ZThiOTFiNzQxZWE3MGNkODBmMWNmMjgxMDg0ZjZiODAwNTFiYTA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-03T22:15:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-03T22:15:21Z"}, "message": "Rollup merge of #106887 - compiler-errors:suggest-types-more, r=oli-obk\n\nMake const/fn return params more suggestable\n\nBumps const item type suggestions to MachineApplicable (fixes #106843), also replaces FnDef with FnPtr items in return type suggestions to make more things suggestable.\n\nr? diagnostics", "tree": {"sha": "719d4e79abe7c49fc4a49af71bc57f6cfb582bfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/719d4e79abe7c49fc4a49af71bc57f6cfb582bfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj3Yd5CRBK7hj4Ov3rIwAAfiQIAAq+3W9R1grrrNLhYHMWmBgn\nLkhGcM4/X7o7cmlhuV+O+s9y2Bmjg8xi4D4WBEpQzYsPENuJLhPkQEHUrv702cge\nlGNiRIw9aPQdGcahcXi5LauYF/tKa58uvi6CkWZFkGVkIKF1hJr8+sxLwlOq+6LV\n4TceleQb1FaJGuc1XtMQ2OCxAZbe+O9QLxCTP+5dJccqz8tJgzMeBCLIq5InN0F4\n7EY9V8/8Krr8y22WFZSVb8ro42qrRNcgSQTWm5TiXi2KDLLJ3gSqf5cyOHJk974E\nD/Z0Vub0sB7B9hgVIBNzfcGQnxUH4LLiij3GeadIk/57Ph0NVCUNtf5Gwr+xDF8=\n=BFOr\n-----END PGP SIGNATURE-----\n", "payload": "tree 719d4e79abe7c49fc4a49af71bc57f6cfb582bfb\nparent 658fad6c5506f41c35b64fb1a22ceb0992697ff3\nparent 0b5941aa1117b6054a6e991787e8075adf392b11\nauthor Michael Goulet <michael@errs.io> 1675462521 -0800\ncommitter GitHub <noreply@github.com> 1675462521 -0800\n\nRollup merge of #106887 - compiler-errors:suggest-types-more, r=oli-obk\n\nMake const/fn return params more suggestable\n\nBumps const item type suggestions to MachineApplicable (fixes #106843), also replaces FnDef with FnPtr items in return type suggestions to make more things suggestable.\n\nr? diagnostics\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "html_url": "https://github.com/rust-lang/rust/commit/e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "658fad6c5506f41c35b64fb1a22ceb0992697ff3", "url": "https://api.github.com/repos/rust-lang/rust/commits/658fad6c5506f41c35b64fb1a22ceb0992697ff3", "html_url": "https://github.com/rust-lang/rust/commit/658fad6c5506f41c35b64fb1a22ceb0992697ff3"}, {"sha": "0b5941aa1117b6054a6e991787e8075adf392b11", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5941aa1117b6054a6e991787e8075adf392b11", "html_url": "https://github.com/rust-lang/rust/commit/0b5941aa1117b6054a6e991787e8075adf392b11"}], "stats": {"total": 230, "additions": 163, "deletions": 67}, "files": [{"sha": "3d5f189e233bb5f8f87753898f1bd89ba3f4c8cd", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "patch": "@@ -2945,12 +2945,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     if r.is_erased() { tcx.lifetimes.re_static } else { r }\n                 });\n                 let span = ast_ty.span;\n-                tcx.sess.emit_err(TypeofReservedKeywordUsed {\n-                    span,\n-                    ty,\n-                    opt_sugg: Some((span, Applicability::MachineApplicable))\n-                        .filter(|_| ty.is_suggestable(tcx, false)),\n-                });\n+                let (ty, opt_sugg) = if let Some(ty) = ty.make_suggestable(tcx, false) {\n+                    (ty, Some((span, Applicability::MachineApplicable)))\n+                } else {\n+                    (ty, None)\n+                };\n+                tcx.sess.emit_err(TypeofReservedKeywordUsed { span, ty, opt_sugg });\n \n                 ty\n             }"}, {"sha": "80426c239ac8b8f9ab6506324aa685e10583197c", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "patch": "@@ -1199,28 +1199,22 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n             visitor.visit_ty(ty);\n             let mut diag = bad_placeholder(tcx, visitor.0, \"return type\");\n             let ret_ty = fn_sig.output();\n-            if ret_ty.is_suggestable(tcx, false) {\n+            if let Some(ret_ty) = ret_ty.make_suggestable(tcx, false) {\n                 diag.span_suggestion(\n                     ty.span,\n                     \"replace with the correct return type\",\n                     ret_ty,\n                     Applicability::MachineApplicable,\n                 );\n-            } else if matches!(ret_ty.kind(), ty::FnDef(..)) {\n-                let fn_sig = ret_ty.fn_sig(tcx);\n-                if fn_sig\n-                    .skip_binder()\n-                    .inputs_and_output\n-                    .iter()\n-                    .all(|t| t.is_suggestable(tcx, false))\n-                {\n-                    diag.span_suggestion(\n-                        ty.span,\n-                        \"replace with the correct return type\",\n-                        fn_sig,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n+            } else if matches!(ret_ty.kind(), ty::FnDef(..))\n+                && let Some(fn_sig) = ret_ty.fn_sig(tcx).make_suggestable(tcx, false)\n+            {\n+                diag.span_suggestion(\n+                    ty.span,\n+                    \"replace with the correct return type\",\n+                    fn_sig,\n+                    Applicability::MachineApplicable,\n+                );\n             } else if let Some(sugg) = suggest_impl_trait(tcx, ret_ty, ty.span, hir_id, def_id) {\n                 diag.span_suggestion(\n                     ty.span,\n@@ -1280,9 +1274,7 @@ fn suggest_impl_trait<'tcx>(\n             let trait_name = tcx.item_name(trait_def_id);\n             let args_tuple = substs.type_at(1);\n             let ty::Tuple(types) = *args_tuple.kind() else { return None; };\n-            if !types.is_suggestable(tcx, false) {\n-                return None;\n-            }\n+            let types = types.make_suggestable(tcx, false)?;\n             let maybe_ret =\n                 if item_ty.is_unit() { String::new() } else { format!(\" -> {item_ty}\") };\n             Some(format!(\n@@ -1337,7 +1329,7 @@ fn suggest_impl_trait<'tcx>(\n         // FIXME(compiler-errors): We may benefit from resolving regions here.\n         if ocx.select_where_possible().is_empty()\n             && let item_ty = infcx.resolve_vars_if_possible(item_ty)\n-            && item_ty.is_suggestable(tcx, false)\n+            && let Some(item_ty) = item_ty.make_suggestable(tcx, false)\n             && let Some(sugg) = formatter(tcx, infcx.resolve_vars_if_possible(substs), trait_def_id, assoc_item_def_id, item_ty)\n         {\n             return Some(sugg);"}, {"sha": "c5522c94874dd3c3421e3a20e6f71f67be3d7780", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "patch": "@@ -8,7 +8,9 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -845,37 +847,23 @@ fn infer_placeholder_type<'a>(\n ) -> Ty<'a> {\n     // Attempts to make the type nameable by turning FnDefs into FnPtrs.\n     struct MakeNameable<'tcx> {\n-        success: bool,\n         tcx: TyCtxt<'tcx>,\n     }\n \n-    impl<'tcx> MakeNameable<'tcx> {\n-        fn new(tcx: TyCtxt<'tcx>) -> Self {\n-            MakeNameable { success: true, tcx }\n-        }\n-    }\n-\n     impl<'tcx> TypeFolder<'tcx> for MakeNameable<'tcx> {\n         fn tcx(&self) -> TyCtxt<'tcx> {\n             self.tcx\n         }\n \n         fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            if !self.success {\n-                return ty;\n-            }\n-\n-            match ty.kind() {\n+            let ty = match *ty.kind() {\n                 ty::FnDef(def_id, substs) => {\n-                    self.tcx.mk_fn_ptr(self.tcx.fn_sig(*def_id).subst(self.tcx, substs))\n+                    self.tcx.mk_fn_ptr(self.tcx.fn_sig(def_id).subst(self.tcx, substs))\n                 }\n-                // FIXME: non-capturing closures should also suggest a function pointer\n-                ty::Closure(..) | ty::Generator(..) => {\n-                    self.success = false;\n-                    ty\n-                }\n-                _ => ty.super_fold_with(self),\n-            }\n+                _ => ty,\n+            };\n+\n+            ty.super_fold_with(self)\n         }\n     }\n \n@@ -898,15 +886,11 @@ fn infer_placeholder_type<'a>(\n                     suggestions.clear();\n                 }\n \n-                // Suggesting unnameable types won't help.\n-                let mut mk_nameable = MakeNameable::new(tcx);\n-                let ty = mk_nameable.fold_ty(ty);\n-                let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n-                if let Some(sugg_ty) = sugg_ty {\n+                if let Some(ty) = ty.make_suggestable(tcx, false) {\n                     err.span_suggestion(\n                         span,\n                         &format!(\"provide a type for the {item}\", item = kind),\n-                        format!(\"{colon} {sugg_ty}\"),\n+                        format!(\"{colon} {ty}\"),\n                         Applicability::MachineApplicable,\n                     );\n                 } else {\n@@ -923,15 +907,12 @@ fn infer_placeholder_type<'a>(\n             let mut diag = bad_placeholder(tcx, vec![span], kind);\n \n             if !ty.references_error() {\n-                let mut mk_nameable = MakeNameable::new(tcx);\n-                let ty = mk_nameable.fold_ty(ty);\n-                let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n-                if let Some(sugg_ty) = sugg_ty {\n+                if let Some(ty) = ty.make_suggestable(tcx, false) {\n                     diag.span_suggestion(\n                         span,\n                         \"replace with the correct type\",\n-                        sugg_ty,\n-                        Applicability::MaybeIncorrect,\n+                        ty,\n+                        Applicability::MachineApplicable,\n                     );\n                 } else {\n                     with_forced_trimmed_paths!(diag.span_note("}, {"sha": "11d47053ade798276348c8517953493e27d18cc6", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "patch": "@@ -687,7 +687,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return true;\n             }\n             &hir::FnRetTy::DefaultReturn(span) if expected.is_unit() => {\n-                if found.is_suggestable(self.tcx, false) {\n+                if let Some(found) = found.make_suggestable(self.tcx, false) {\n                     err.subdiagnostic(AddReturnTypeSuggestion::Add { span, found: found.to_string() });\n                     return true;\n                 } else if let ty::Closure(_, substs) = found.kind()"}, {"sha": "ba72aefe39c169f7472b3860dca791fe644b5e5d", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "patch": "@@ -490,9 +490,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             if let Some(output_def_id) = output_def_id\n                                                 && let Some(trait_def_id) = trait_def_id\n                                                 && self.tcx.parent(output_def_id) == trait_def_id\n-                                                && output_ty.is_suggestable(self.tcx, false)\n+                                                && let Some(output_ty) = output_ty.make_suggestable(self.tcx, false)\n                                             {\n-                                                Some((\"Output\", *output_ty))\n+                                                Some((\"Output\", output_ty))\n                                             } else {\n                                                 None\n                                             }"}, {"sha": "cd9b927014077190b973197824728c565181329c", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 91, "deletions": 4, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "patch": "@@ -3,8 +3,9 @@\n use std::ops::ControlFlow;\n \n use crate::ty::{\n-    visit::TypeVisitable, AliasTy, Const, ConstKind, DefIdTree, InferConst, InferTy, Opaque,\n-    PolyTraitPredicate, Projection, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor,\n+    visit::TypeVisitable, AliasTy, Const, ConstKind, DefIdTree, FallibleTypeFolder, InferConst,\n+    InferTy, Opaque, PolyTraitPredicate, Projection, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable,\n+    TypeSuperVisitable, TypeVisitor,\n };\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -76,7 +77,7 @@ impl<'tcx> Ty<'tcx> {\n     }\n }\n \n-pub trait IsSuggestable<'tcx> {\n+pub trait IsSuggestable<'tcx>: Sized {\n     /// Whether this makes sense to suggest in a diagnostic.\n     ///\n     /// We filter out certain types and constants since they don't provide\n@@ -87,15 +88,21 @@ pub trait IsSuggestable<'tcx> {\n     /// Only if `infer_suggestable` is true, we consider type and const\n     /// inference variables to be suggestable.\n     fn is_suggestable(self, tcx: TyCtxt<'tcx>, infer_suggestable: bool) -> bool;\n+\n+    fn make_suggestable(self, tcx: TyCtxt<'tcx>, infer_suggestable: bool) -> Option<Self>;\n }\n \n impl<'tcx, T> IsSuggestable<'tcx> for T\n where\n-    T: TypeVisitable<'tcx>,\n+    T: TypeVisitable<'tcx> + TypeFoldable<'tcx>,\n {\n     fn is_suggestable(self, tcx: TyCtxt<'tcx>, infer_suggestable: bool) -> bool {\n         self.visit_with(&mut IsSuggestableVisitor { tcx, infer_suggestable }).is_continue()\n     }\n+\n+    fn make_suggestable(self, tcx: TyCtxt<'tcx>, infer_suggestable: bool) -> Option<T> {\n+        self.try_fold_with(&mut MakeSuggestableFolder { tcx, infer_suggestable }).ok()\n+    }\n }\n \n pub fn suggest_arbitrary_trait_bound<'tcx>(\n@@ -509,3 +516,83 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n         c.super_visit_with(self)\n     }\n }\n+\n+pub struct MakeSuggestableFolder<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    infer_suggestable: bool,\n+}\n+\n+impl<'tcx> FallibleTypeFolder<'tcx> for MakeSuggestableFolder<'tcx> {\n+    type Error = ();\n+\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        let t = match *t.kind() {\n+            Infer(InferTy::TyVar(_)) if self.infer_suggestable => t,\n+\n+            FnDef(def_id, substs) => {\n+                self.tcx.mk_fn_ptr(self.tcx.fn_sig(def_id).subst(self.tcx, substs))\n+            }\n+\n+            // FIXME(compiler-errors): We could replace these with infer, I guess.\n+            Closure(..)\n+            | Infer(..)\n+            | Generator(..)\n+            | GeneratorWitness(..)\n+            | Bound(_, _)\n+            | Placeholder(_)\n+            | Error(_) => {\n+                return Err(());\n+            }\n+\n+            Alias(Opaque, AliasTy { def_id, .. }) => {\n+                let parent = self.tcx.parent(def_id);\n+                if let hir::def::DefKind::TyAlias | hir::def::DefKind::AssocTy = self.tcx.def_kind(parent)\n+                    && let Alias(Opaque, AliasTy { def_id: parent_opaque_def_id, .. }) = *self.tcx.type_of(parent).kind()\n+                    && parent_opaque_def_id == def_id\n+                {\n+                    t\n+                } else {\n+                    return Err(());\n+                }\n+            }\n+\n+            Param(param) => {\n+                // FIXME: It would be nice to make this not use string manipulation,\n+                // but it's pretty hard to do this, since `ty::ParamTy` is missing\n+                // sufficient info to determine if it is synthetic, and we don't\n+                // always have a convenient way of getting `ty::Generics` at the call\n+                // sites we invoke `IsSuggestable::is_suggestable`.\n+                if param.name.as_str().starts_with(\"impl \") {\n+                    return Err(());\n+                }\n+\n+                t\n+            }\n+\n+            _ => t,\n+        };\n+\n+        t.try_super_fold_with(self)\n+    }\n+\n+    fn try_fold_const(&mut self, c: Const<'tcx>) -> Result<Const<'tcx>, ()> {\n+        let c = match c.kind() {\n+            ConstKind::Infer(InferConst::Var(_)) if self.infer_suggestable => c,\n+\n+            ConstKind::Infer(..)\n+            | ConstKind::Bound(..)\n+            | ConstKind::Placeholder(..)\n+            | ConstKind::Error(..) => {\n+                return Err(());\n+            }\n+\n+            _ => c,\n+        };\n+\n+        c.try_super_fold_with(self)\n+    }\n+}"}, {"sha": "8a0019bc0127c9df4ee2e224d30567bf194d4992", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "patch": "@@ -105,7 +105,7 @@ pub trait TypeSuperFoldable<'tcx>: TypeFoldable<'tcx> {\n /// the infallible methods of this trait to ensure that the two APIs\n /// are coherent.\n pub trait TypeFolder<'tcx>: FallibleTypeFolder<'tcx, Error = !> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n \n     fn fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T>\n     where"}, {"sha": "abb9ef9177432ad3954b2b1620ff34abfa4d281e", "filename": "tests/ui/suggestions/suggest-fn-ptr-for-fn-item-in-fn-ret.fixed", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/tests%2Fui%2Fsuggestions%2Fsuggest-fn-ptr-for-fn-item-in-fn-ret.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/tests%2Fui%2Fsuggestions%2Fsuggest-fn-ptr-for-fn-item-in-fn-ret.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-fn-ptr-for-fn-item-in-fn-ret.fixed?ref=e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "patch": "@@ -0,0 +1,12 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+struct Wrapper<T>(T);\n+\n+fn bar() -> Wrapper<fn()> { Wrapper(foo) }\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n+\n+fn foo() {}\n+\n+fn main() {}"}, {"sha": "d2a79c3869418369482c59790875c4b84e0a68c1", "filename": "tests/ui/suggestions/suggest-fn-ptr-for-fn-item-in-fn-ret.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/tests%2Fui%2Fsuggestions%2Fsuggest-fn-ptr-for-fn-item-in-fn-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/tests%2Fui%2Fsuggestions%2Fsuggest-fn-ptr-for-fn-item-in-fn-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-fn-ptr-for-fn-item-in-fn-ret.rs?ref=e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "patch": "@@ -0,0 +1,12 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+struct Wrapper<T>(T);\n+\n+fn bar() -> _ { Wrapper(foo) }\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n+\n+fn foo() {}\n+\n+fn main() {}"}, {"sha": "347a038525b60bf281ddd473605c9c421436f09e", "filename": "tests/ui/suggestions/suggest-fn-ptr-for-fn-item-in-fn-ret.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/tests%2Fui%2Fsuggestions%2Fsuggest-fn-ptr-for-fn-item-in-fn-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8b91b741ea70cd80f1cf281084f6b80051ba0/tests%2Fui%2Fsuggestions%2Fsuggest-fn-ptr-for-fn-item-in-fn-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-fn-ptr-for-fn-item-in-fn-ret.stderr?ref=e7e8b91b741ea70cd80f1cf281084f6b80051ba0", "patch": "@@ -0,0 +1,12 @@\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n+  --> $DIR/suggest-fn-ptr-for-fn-item-in-fn-ret.rs:7:13\n+   |\n+LL | fn bar() -> _ { Wrapper(foo) }\n+   |             ^\n+   |             |\n+   |             not allowed in type signatures\n+   |             help: replace with the correct return type: `Wrapper<fn()>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0121`."}]}