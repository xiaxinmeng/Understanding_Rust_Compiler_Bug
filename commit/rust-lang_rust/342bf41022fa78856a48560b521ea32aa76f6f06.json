{"sha": "342bf41022fa78856a48560b521ea32aa76f6f06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MmJmNDEwMjJmYTc4ODU2YTQ4NTYwYjUyMWVhMzJhYTc2ZjZmMDY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-18T19:40:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-18T19:40:11Z"}, "message": "Merge #7297 #7338\n\n7297: Propose trait associated items and autoimport traits on completion r=matklad a=SomeoneToIgnore\n\n![trait_imports](https://user-images.githubusercontent.com/2690773/104819998-6faeb480-583a-11eb-8b45-b7351b51b90e.gif)\r\n\r\nCloses #7248\n\n7338: Parse `impl const Trait` r=Veykril a=Veykril\n\nCloses #7313\r\n\r\nbors r+\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "733a17f4ffc78490928717433c8434545afd157c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/733a17f4ffc78490928717433c8434545afd157c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/342bf41022fa78856a48560b521ea32aa76f6f06", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgBeQbCRBK7hj4Ov3rIwAAdHIIAAGKCpDAL4JVEOP4Dd/V4eGu\nSkQuXPEoPfcQcbkMv/7BvzHRvQOnx+UzFv1CsjlhDNsO3ZKwmBsYrbe/gKLq4ekU\nFgo3NCVyPHT1tdlldbFE+sgLx2Rl/doQB1e6h7GXGVN59SHZxFOgW68TqvCqUhDC\nnyPJA6JAKr0Gsx9rPmmk5h227/I8ARDhbaxAp0XegWwn3Xg3A61MZ96HbIJDPwnh\nTfK4KHQXjFxivVBMvhzG35U1fkNqJxYAzjJQhXrFWMv+FpMAalyMOE9YloGuYo3F\nz9IsHB/mHdIDvpXgyzbKna3ixnX0A7uC3ug0QqpiyYRtM8iD/e6XA9oJvKLOpUg=\n=w97a\n-----END PGP SIGNATURE-----\n", "payload": "tree 733a17f4ffc78490928717433c8434545afd157c\nparent cb0d77ab3cbed674fdab9baf5c834f89b67a628d\nparent f01cfe911410a2f35f95ec1e7befb51d51a5343e\nparent b26002410b5acda8d0e1322071881cdb8a2b6724\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1610998811 +0000\ncommitter GitHub <noreply@github.com> 1610998811 +0000\n\nMerge #7297 #7338\n\n7297: Propose trait associated items and autoimport traits on completion r=matklad a=SomeoneToIgnore\n\n![trait_imports](https://user-images.githubusercontent.com/2690773/104819998-6faeb480-583a-11eb-8b45-b7351b51b90e.gif)\r\n\r\nCloses #7248\n\n7338: Parse `impl const Trait` r=Veykril a=Veykril\n\nCloses #7313\r\n\r\nbors r+\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/342bf41022fa78856a48560b521ea32aa76f6f06", "html_url": "https://github.com/rust-lang/rust/commit/342bf41022fa78856a48560b521ea32aa76f6f06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/342bf41022fa78856a48560b521ea32aa76f6f06/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb0d77ab3cbed674fdab9baf5c834f89b67a628d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb0d77ab3cbed674fdab9baf5c834f89b67a628d", "html_url": "https://github.com/rust-lang/rust/commit/cb0d77ab3cbed674fdab9baf5c834f89b67a628d"}, {"sha": "f01cfe911410a2f35f95ec1e7befb51d51a5343e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f01cfe911410a2f35f95ec1e7befb51d51a5343e", "html_url": "https://github.com/rust-lang/rust/commit/f01cfe911410a2f35f95ec1e7befb51d51a5343e"}, {"sha": "b26002410b5acda8d0e1322071881cdb8a2b6724", "url": "https://api.github.com/repos/rust-lang/rust/commits/b26002410b5acda8d0e1322071881cdb8a2b6724", "html_url": "https://github.com/rust-lang/rust/commit/b26002410b5acda8d0e1322071881cdb8a2b6724"}], "stats": {"total": 1171, "additions": 884, "deletions": 287}, "files": [{"sha": "f0154432410e4f1f56f070fae2ec3ff36d706fc9", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -1904,9 +1904,9 @@ checksum = \"56dee185309b50d1f11bfedef0fe6d036842e3fb77413abef29f8f8d1c5d4c1c\"\n \n [[package]]\n name = \"ungrammar\"\n-version = \"1.9.2\"\n+version = \"1.9.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"58a02e2041a872d56354e843e8e86e6b946fc8e7dc32982fcdc335e29eb4cc8b\"\n+checksum = \"f5901372c0f3a6a1a9d880aef134c8eaf5e54409343637508c0a344270b42d7b\"\n \n [[package]]\n name = \"unicase\""}, {"sha": "e93901cb3101f2b8f294e564fcb301913e5a176e", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -3,7 +3,7 @@ use ide_db::helpers::{\n     insert_use::{insert_use, ImportScope},\n     mod_path_to_ast,\n };\n-use syntax::ast;\n+use syntax::{ast, AstNode, SyntaxNode};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n \n@@ -82,25 +82,16 @@ use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let import_assets =\n-        if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n-            ImportAssets::for_regular_path(path_under_caret, &ctx.sema)\n-        } else if let Some(method_under_caret) =\n-            ctx.find_node_at_offset_with_descend::<ast::MethodCallExpr>()\n-        {\n-            ImportAssets::for_method_call(method_under_caret, &ctx.sema)\n-        } else {\n-            None\n-        }?;\n-    let proposed_imports = import_assets.search_for_imports(&ctx.sema, &ctx.config.insert_use);\n+    let (import_assets, syntax_under_caret) = find_importable_node(ctx)?;\n+    let proposed_imports =\n+        import_assets.search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n \n-    let range = ctx.sema.original_range(import_assets.syntax_under_caret()).range;\n+    let range = ctx.sema.original_range(&syntax_under_caret).range;\n     let group = import_group_message(import_assets.import_candidate());\n-    let scope =\n-        ImportScope::find_insert_use_container(import_assets.syntax_under_caret(), &ctx.sema)?;\n+    let scope = ImportScope::find_insert_use_container(&syntax_under_caret, &ctx.sema)?;\n     for (import, _) in proposed_imports {\n         acc.add_group(\n             &group,\n@@ -117,14 +108,28 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     Some(())\n }\n \n+pub(super) fn find_importable_node(ctx: &AssistContext) -> Option<(ImportAssets, SyntaxNode)> {\n+    if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n+        ImportAssets::for_exact_path(&path_under_caret, &ctx.sema)\n+            .zip(Some(path_under_caret.syntax().clone()))\n+    } else if let Some(method_under_caret) =\n+        ctx.find_node_at_offset_with_descend::<ast::MethodCallExpr>()\n+    {\n+        ImportAssets::for_method_call(&method_under_caret, &ctx.sema)\n+            .zip(Some(method_under_caret.syntax().clone()))\n+    } else {\n+        None\n+    }\n+}\n+\n fn import_group_message(import_candidate: &ImportCandidate) -> GroupLabel {\n     let name = match import_candidate {\n-        ImportCandidate::Path(candidate) => format!(\"Import {}\", &candidate.name),\n+        ImportCandidate::Path(candidate) => format!(\"Import {}\", candidate.name.text()),\n         ImportCandidate::TraitAssocItem(candidate) => {\n-            format!(\"Import a trait for item {}\", &candidate.name)\n+            format!(\"Import a trait for item {}\", candidate.name.text())\n         }\n         ImportCandidate::TraitMethod(candidate) => {\n-            format!(\"Import a trait for method {}\", &candidate.name)\n+            format!(\"Import a trait for method {}\", candidate.name.text())\n         }\n     };\n     GroupLabel(name)"}, {"sha": "af8a11d03556cfed271a1d66d548d2c4a11fbbf3", "filename": "crates/assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -1,10 +1,7 @@\n use std::iter;\n \n use hir::AsName;\n-use ide_db::helpers::{\n-    import_assets::{ImportAssets, ImportCandidate},\n-    mod_path_to_ast,\n-};\n+use ide_db::helpers::{import_assets::ImportCandidate, mod_path_to_ast};\n use ide_db::RootDatabase;\n use syntax::{\n     ast,\n@@ -18,6 +15,8 @@ use crate::{\n     AssistId, AssistKind, GroupLabel,\n };\n \n+use super::auto_import::find_importable_node;\n+\n // Assist: qualify_path\n //\n // If the name is unresolved, provides all possible qualified paths for it.\n@@ -36,47 +35,38 @@ use crate::{\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let import_assets =\n-        if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n-            ImportAssets::for_regular_path(path_under_caret, &ctx.sema)\n-        } else if let Some(method_under_caret) =\n-            ctx.find_node_at_offset_with_descend::<ast::MethodCallExpr>()\n-        {\n-            ImportAssets::for_method_call(method_under_caret, &ctx.sema)\n-        } else {\n-            None\n-        }?;\n+    let (import_assets, syntax_under_caret) = find_importable_node(ctx)?;\n     let proposed_imports = import_assets.search_for_relative_paths(&ctx.sema);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n \n     let candidate = import_assets.import_candidate();\n-    let range = ctx.sema.original_range(import_assets.syntax_under_caret()).range;\n+    let range = ctx.sema.original_range(&syntax_under_caret).range;\n \n     let qualify_candidate = match candidate {\n         ImportCandidate::Path(candidate) => {\n             if candidate.qualifier.is_some() {\n                 mark::hit!(qualify_path_qualifier_start);\n-                let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+                let path = ast::Path::cast(syntax_under_caret)?;\n                 let (prev_segment, segment) = (path.qualifier()?.segment()?, path.segment()?);\n                 QualifyCandidate::QualifierStart(segment, prev_segment.generic_arg_list())\n             } else {\n                 mark::hit!(qualify_path_unqualified_name);\n-                let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+                let path = ast::Path::cast(syntax_under_caret)?;\n                 let generics = path.segment()?.generic_arg_list();\n                 QualifyCandidate::UnqualifiedName(generics)\n             }\n         }\n         ImportCandidate::TraitAssocItem(_) => {\n             mark::hit!(qualify_path_trait_assoc_item);\n-            let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+            let path = ast::Path::cast(syntax_under_caret)?;\n             let (qualifier, segment) = (path.qualifier()?, path.segment()?);\n             QualifyCandidate::TraitAssocItem(qualifier, segment)\n         }\n         ImportCandidate::TraitMethod(_) => {\n             mark::hit!(qualify_path_trait_method);\n-            let mcall_expr = ast::MethodCallExpr::cast(import_assets.syntax_under_caret().clone())?;\n+            let mcall_expr = ast::MethodCallExpr::cast(syntax_under_caret)?;\n             QualifyCandidate::TraitMethod(ctx.sema.db, mcall_expr)\n         }\n     };\n@@ -140,7 +130,7 @@ impl QualifyCandidate<'_> {\n         let generics =\n             mcall_expr.generic_arg_list().as_ref().map_or_else(String::new, ToString::to_string);\n         let arg_list = mcall_expr.arg_list().map(|arg_list| arg_list.args());\n-        let trait_ = item_as_trait(item)?;\n+        let trait_ = item_as_trait(db, item)?;\n         let method = find_trait_method(db, trait_, &trait_method_name)?;\n         if let Some(self_access) = method.self_param(db).map(|sp| sp.access(db)) {\n             let receiver = match self_access {\n@@ -179,19 +169,22 @@ fn find_trait_method(\n     }\n }\n \n-fn item_as_trait(item: hir::ItemInNs) -> Option<hir::Trait> {\n-    if let hir::ModuleDef::Trait(trait_) = hir::ModuleDef::from(item.as_module_def_id()?) {\n+fn item_as_trait(db: &RootDatabase, item: hir::ItemInNs) -> Option<hir::Trait> {\n+    let item_module_def = hir::ModuleDef::from(item.as_module_def_id()?);\n+\n+    if let hir::ModuleDef::Trait(trait_) = item_module_def {\n         Some(trait_)\n     } else {\n-        None\n+        item_module_def.as_assoc_item(db)?.containing_trait(db)\n     }\n }\n \n fn group_label(candidate: &ImportCandidate) -> GroupLabel {\n     let name = match candidate {\n         ImportCandidate::Path(it) => &it.name,\n         ImportCandidate::TraitAssocItem(it) | ImportCandidate::TraitMethod(it) => &it.name,\n-    };\n+    }\n+    .text();\n     GroupLabel(format!(\"Qualify {}\", name))\n }\n "}, {"sha": "47e797ac8bf34f9489a88545735e868808ce0186", "filename": "crates/completion/src/completions/flyimport.rs", "status": "modified", "additions": 411, "deletions": 37, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -20,11 +20,14 @@\n //! # pub mod std { pub mod marker { pub struct PhantomData { } } }\n //! ```\n //!\n+//! Also completes associated items, that require trait imports.\n+//!\n //! .Fuzzy search details\n //!\n //! To avoid an excessive amount of the results returned, completion input is checked for inclusion in the names only\n //! (i.e. in `HashMap` in the `std::collections::HashMap` path).\n-//! For the same reasons, avoids searching for any imports for inputs with their length less that 2 symbols.\n+//! For the same reasons, avoids searching for any path imports for inputs with their length less that 2 symbols\n+//! (but shows all associated items for any input length).\n //!\n //! .Import configuration\n //!\n@@ -45,10 +48,12 @@\n //! Note that having this flag set to `true` does not guarantee that the feature is enabled: your client needs to have the corredponding\n //! capability enabled.\n \n-use either::Either;\n use hir::{ModPath, ScopeDef};\n-use ide_db::{helpers::insert_use::ImportScope, imports_locator};\n-use syntax::AstNode;\n+use ide_db::helpers::{\n+    import_assets::{ImportAssets, ImportCandidate},\n+    insert_use::ImportScope,\n+};\n+use syntax::{AstNode, SyntaxNode, T};\n use test_utils::mark;\n \n use crate::{\n@@ -60,58 +65,108 @@ use crate::{\n use super::Completions;\n \n pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    if !ctx.config.enable_autoimport_completions {\n+    if !ctx.config.enable_imports_on_the_fly {\n         return None;\n     }\n     if ctx.attribute_under_caret.is_some() || ctx.mod_declaration_under_caret.is_some() {\n         return None;\n     }\n-    let potential_import_name = ctx.token.to_string();\n-    if potential_import_name.len() < 2 {\n-        return None;\n-    }\n-    let _p = profile::span(\"import_on_the_fly\").detail(|| potential_import_name.to_string());\n+    let potential_import_name = {\n+        let token_kind = ctx.token.kind();\n+        if matches!(token_kind, T![.] | T![::]) {\n+            String::new()\n+        } else {\n+            ctx.token.to_string()\n+        }\n+    };\n \n-    let current_module = ctx.scope.module()?;\n-    let anchor = ctx.name_ref_syntax.as_ref()?;\n-    let import_scope = ImportScope::find_insert_use_container(anchor.syntax(), &ctx.sema)?;\n+    let _p = profile::span(\"import_on_the_fly\").detail(|| potential_import_name.to_string());\n \n     let user_input_lowercased = potential_import_name.to_lowercase();\n-    let mut all_mod_paths = imports_locator::find_similar_imports(\n+    let import_assets = import_assets(ctx, potential_import_name)?;\n+    let import_scope = ImportScope::find_insert_use_container(\n+        position_for_import(ctx, Some(import_assets.import_candidate()))?,\n         &ctx.sema,\n-        ctx.krate?,\n-        Some(40),\n-        potential_import_name,\n-        true,\n-        true,\n-    )\n-    .filter_map(|import_candidate| {\n-        Some(match import_candidate {\n-            Either::Left(module_def) => {\n-                (current_module.find_use_path(ctx.db, module_def)?, ScopeDef::ModuleDef(module_def))\n-            }\n-            Either::Right(macro_def) => {\n-                (current_module.find_use_path(ctx.db, macro_def)?, ScopeDef::MacroDef(macro_def))\n-            }\n+    )?;\n+    let mut all_mod_paths = import_assets\n+        .search_for_relative_paths(&ctx.sema)\n+        .into_iter()\n+        .map(|(mod_path, item_in_ns)| {\n+            let scope_item = match item_in_ns {\n+                hir::ItemInNs::Types(id) => ScopeDef::ModuleDef(id.into()),\n+                hir::ItemInNs::Values(id) => ScopeDef::ModuleDef(id.into()),\n+                hir::ItemInNs::Macros(id) => ScopeDef::MacroDef(id.into()),\n+            };\n+            (mod_path, scope_item)\n         })\n-    })\n-    .filter(|(mod_path, _)| mod_path.len() > 1)\n-    .collect::<Vec<_>>();\n-\n+        .collect::<Vec<_>>();\n     all_mod_paths.sort_by_cached_key(|(mod_path, _)| {\n         compute_fuzzy_completion_order_key(mod_path, &user_input_lowercased)\n     });\n \n     acc.add_all(all_mod_paths.into_iter().filter_map(|(import_path, definition)| {\n-        render_resolution_with_import(\n-            RenderContext::new(ctx),\n-            ImportEdit { import_path, import_scope: import_scope.clone() },\n-            &definition,\n-        )\n+        let import_for_trait_assoc_item = match definition {\n+            ScopeDef::ModuleDef(module_def) => module_def\n+                .as_assoc_item(ctx.db)\n+                .and_then(|assoc| assoc.containing_trait(ctx.db))\n+                .is_some(),\n+            _ => false,\n+        };\n+        let import_edit = ImportEdit {\n+            import_path,\n+            import_scope: import_scope.clone(),\n+            import_for_trait_assoc_item,\n+        };\n+        render_resolution_with_import(RenderContext::new(ctx), import_edit, &definition)\n     }));\n     Some(())\n }\n \n+pub(crate) fn position_for_import<'a>(\n+    ctx: &'a CompletionContext,\n+    import_candidate: Option<&ImportCandidate>,\n+) -> Option<&'a SyntaxNode> {\n+    Some(match import_candidate {\n+        Some(ImportCandidate::Path(_)) => ctx.name_ref_syntax.as_ref()?.syntax(),\n+        Some(ImportCandidate::TraitAssocItem(_)) => ctx.path_qual.as_ref()?.syntax(),\n+        Some(ImportCandidate::TraitMethod(_)) => ctx.dot_receiver.as_ref()?.syntax(),\n+        None => ctx\n+            .name_ref_syntax\n+            .as_ref()\n+            .map(|name_ref| name_ref.syntax())\n+            .or_else(|| ctx.path_qual.as_ref().map(|path| path.syntax()))\n+            .or_else(|| ctx.dot_receiver.as_ref().map(|expr| expr.syntax()))?,\n+    })\n+}\n+\n+fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAssets> {\n+    let current_module = ctx.scope.module()?;\n+    if let Some(dot_receiver) = &ctx.dot_receiver {\n+        ImportAssets::for_fuzzy_method_call(\n+            current_module,\n+            ctx.sema.type_of_expr(dot_receiver)?,\n+            fuzzy_name,\n+        )\n+    } else {\n+        let fuzzy_name_length = fuzzy_name.len();\n+        let assets_for_path = ImportAssets::for_fuzzy_path(\n+            current_module,\n+            ctx.path_qual.clone(),\n+            fuzzy_name,\n+            &ctx.sema,\n+        );\n+\n+        if matches!(assets_for_path.as_ref()?.import_candidate(), ImportCandidate::Path(_))\n+            && fuzzy_name_length < 2\n+        {\n+            mark::hit!(ignore_short_input_for_path);\n+            None\n+        } else {\n+            assets_for_path\n+        }\n+    }\n+}\n+\n fn compute_fuzzy_completion_order_key(\n     proposed_mod_path: &ModPath,\n     user_input_lowercased: &str,\n@@ -223,6 +278,30 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn short_paths_are_ignored() {\n+        mark::check!(ignore_short_input_for_path);\n+\n+        check(\n+            r#\"\n+//- /lib.rs crate:dep\n+pub struct FirstStruct;\n+pub mod some_module {\n+    pub struct SecondStruct;\n+    pub struct ThirdStruct;\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::{FirstStruct, some_module::SecondStruct};\n+\n+fn main() {\n+    t$0\n+}\n+\"#,\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+\n     #[test]\n     fn fuzzy_completions_come_in_specific_order() {\n         mark::check!(certain_fuzzy_order_test);\n@@ -258,6 +337,176 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn trait_function_fuzzy_completion() {\n+        let fixture = r#\"\n+        //- /lib.rs crate:dep\n+        pub mod test_mod {\n+            pub trait TestTrait {\n+                const SPECIAL_CONST: u8;\n+                type HumbleType;\n+                fn weird_function();\n+                fn random_method(&self);\n+            }\n+            pub struct TestStruct {}\n+            impl TestTrait for TestStruct {\n+                const SPECIAL_CONST: u8 = 42;\n+                type HumbleType = ();\n+                fn weird_function() {}\n+                fn random_method(&self) {}\n+            }\n+        }\n+\n+        //- /main.rs crate:main deps:dep\n+        fn main() {\n+            dep::test_mod::TestStruct::wei$0\n+        }\n+        \"#;\n+\n+        check(\n+            fixture,\n+            expect![[r#\"\n+            fn weird_function() (dep::test_mod::TestTrait) fn weird_function()\n+        \"#]],\n+        );\n+\n+        check_edit(\n+            \"weird_function\",\n+            fixture,\n+            r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    dep::test_mod::TestStruct::weird_function()$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_const_fuzzy_completion() {\n+        let fixture = r#\"\n+        //- /lib.rs crate:dep\n+        pub mod test_mod {\n+            pub trait TestTrait {\n+                const SPECIAL_CONST: u8;\n+                type HumbleType;\n+                fn weird_function();\n+                fn random_method(&self);\n+            }\n+            pub struct TestStruct {}\n+            impl TestTrait for TestStruct {\n+                const SPECIAL_CONST: u8 = 42;\n+                type HumbleType = ();\n+                fn weird_function() {}\n+                fn random_method(&self) {}\n+            }\n+        }\n+\n+        //- /main.rs crate:main deps:dep\n+        fn main() {\n+            dep::test_mod::TestStruct::spe$0\n+        }\n+        \"#;\n+\n+        check(\n+            fixture,\n+            expect![[r#\"\n+            ct SPECIAL_CONST (dep::test_mod::TestTrait)\n+        \"#]],\n+        );\n+\n+        check_edit(\n+            \"SPECIAL_CONST\",\n+            fixture,\n+            r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    dep::test_mod::TestStruct::SPECIAL_CONST\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_fuzzy_completion() {\n+        let fixture = r#\"\n+        //- /lib.rs crate:dep\n+        pub mod test_mod {\n+            pub trait TestTrait {\n+                const SPECIAL_CONST: u8;\n+                type HumbleType;\n+                fn weird_function();\n+                fn random_method(&self);\n+            }\n+            pub struct TestStruct {}\n+            impl TestTrait for TestStruct {\n+                const SPECIAL_CONST: u8 = 42;\n+                type HumbleType = ();\n+                fn weird_function() {}\n+                fn random_method(&self) {}\n+            }\n+        }\n+\n+        //- /main.rs crate:main deps:dep\n+        fn main() {\n+            let test_struct = dep::test_mod::TestStruct {};\n+            test_struct.ran$0\n+        }\n+        \"#;\n+\n+        check(\n+            fixture,\n+            expect![[r#\"\n+            me random_method() (dep::test_mod::TestTrait) fn random_method(&self)\n+        \"#]],\n+        );\n+\n+        check_edit(\n+            \"random_method\",\n+            fixture,\n+            r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    let test_struct = dep::test_mod::TestStruct {};\n+    test_struct.random_method()$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_trait_type_fuzzy_completion() {\n+        check(\n+            r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::hum$0\n+}\n+\"#,\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+\n     #[test]\n     fn does_not_propose_names_in_scope() {\n         check(\n@@ -288,4 +537,129 @@ fn main() {\n             expect![[r#\"\"#]],\n         );\n     }\n+\n+    #[test]\n+    fn does_not_propose_traits_in_scope() {\n+        check(\n+            r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::test_mod::{TestStruct, TestTrait};\n+fn main() {\n+    dep::test_mod::TestStruct::hum$0\n+}\n+\"#,\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn blanket_trait_impl_import() {\n+        check_edit(\n+            \"another_function\",\n+            r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub struct TestStruct {}\n+    pub trait TestTrait {\n+        fn another_function();\n+    }\n+    impl<T> TestTrait for T {\n+        fn another_function() {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::ano$0\n+}\n+\"#,\n+            r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    dep::test_mod::TestStruct::another_function()$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn zero_input_assoc_item_completion() {\n+        check(\n+            r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    let test_struct = dep::test_mod::TestStruct {};\n+    test_struct.$0\n+}\n+        \"#,\n+            expect![[r#\"\n+                        me random_method() (dep::test_mod::TestTrait) fn random_method(&self)\n+                \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::$0\n+}\n+\"#,\n+            expect![[r#\"\n+                ct SPECIAL_CONST (dep::test_mod::TestTrait)\n+                fn weird_function() (dep::test_mod::TestTrait) fn weird_function()\n+        \"#]],\n+        );\n+    }\n }"}, {"sha": "d70ed6c1cde518b06424e335715e3e80111508a9", "filename": "crates/completion/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fcompletion%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fcompletion%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fconfig.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -9,7 +9,7 @@ use ide_db::helpers::{insert_use::InsertUseConfig, SnippetCap};\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct CompletionConfig {\n     pub enable_postfix_completions: bool,\n-    pub enable_autoimport_completions: bool,\n+    pub enable_imports_on_the_fly: bool,\n     pub add_call_parenthesis: bool,\n     pub add_call_argument_snippets: bool,\n     pub snippet_cap: Option<SnippetCap>,"}, {"sha": "4147853e7f0305615da448cac9565af40f831084", "filename": "crates/completion/src/item.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fcompletion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fcompletion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fitem.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -270,6 +270,7 @@ impl CompletionItem {\n pub struct ImportEdit {\n     pub import_path: ModPath,\n     pub import_scope: ImportScope,\n+    pub import_for_trait_assoc_item: bool,\n }\n \n impl ImportEdit {\n@@ -321,17 +322,19 @@ impl Builder {\n         let mut insert_text = self.insert_text;\n \n         if let Some(import_to_add) = self.import_to_add.as_ref() {\n-            let mut import_path_without_last_segment = import_to_add.import_path.to_owned();\n-            let _ = import_path_without_last_segment.segments.pop();\n-\n-            if !import_path_without_last_segment.segments.is_empty() {\n-                if lookup.is_none() {\n-                    lookup = Some(label.clone());\n-                }\n-                if insert_text.is_none() {\n-                    insert_text = Some(label.clone());\n+            if import_to_add.import_for_trait_assoc_item {\n+                lookup = lookup.or_else(|| Some(label.clone()));\n+                insert_text = insert_text.or_else(|| Some(label.clone()));\n+                label = format!(\"{} ({})\", label, import_to_add.import_path);\n+            } else {\n+                let mut import_path_without_last_segment = import_to_add.import_path.to_owned();\n+                let _ = import_path_without_last_segment.segments.pop();\n+\n+                if !import_path_without_last_segment.segments.is_empty() {\n+                    lookup = lookup.or_else(|| Some(label.clone()));\n+                    insert_text = insert_text.or_else(|| Some(label.clone()));\n+                    label = format!(\"{}::{}\", import_path_without_last_segment, label);\n                 }\n-                label = format!(\"{}::{}\", import_path_without_last_segment, label);\n             }\n         }\n "}, {"sha": "2c4e5452497f25fc8ecf6e017071f423ff9cd7c4", "filename": "crates/completion/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fcompletion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fcompletion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Flib.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -11,10 +11,10 @@ mod render;\n \n mod completions;\n \n+use completions::flyimport::position_for_import;\n use ide_db::{\n     base_db::FilePosition, helpers::insert_use::ImportScope, imports_locator, RootDatabase,\n };\n-use syntax::AstNode;\n use text_edit::TextEdit;\n \n use crate::{completions::Completions, context::CompletionContext, item::CompletionKind};\n@@ -139,12 +139,13 @@ pub fn resolve_completion_edits(\n     position: FilePosition,\n     full_import_path: &str,\n     imported_name: String,\n+    import_for_trait_assoc_item: bool,\n ) -> Option<Vec<TextEdit>> {\n     let ctx = CompletionContext::new(db, position, config)?;\n-    let anchor = ctx.name_ref_syntax.as_ref()?;\n-    let import_scope = ImportScope::find_insert_use_container(anchor.syntax(), &ctx.sema)?;\n+    let position_for_import = position_for_import(&ctx, None)?;\n+    let import_scope = ImportScope::find_insert_use_container(position_for_import, &ctx.sema)?;\n \n-    let current_module = ctx.sema.scope(anchor.syntax()).module()?;\n+    let current_module = ctx.sema.scope(position_for_import).module()?;\n     let current_crate = current_module.krate();\n \n     let import_path = imports_locator::find_exact_imports(&ctx.sema, current_crate, imported_name)\n@@ -154,7 +155,7 @@ pub fn resolve_completion_edits(\n         })\n         .find(|mod_path| mod_path.to_string() == full_import_path)?;\n \n-    ImportEdit { import_path, import_scope }\n+    ImportEdit { import_path, import_scope, import_for_trait_assoc_item }\n         .to_text_edit(config.insert_use.merge)\n         .map(|edit| vec![edit])\n }"}, {"sha": "4b3c9702a4440e5e232b194cd7583c9e04bcdc1e", "filename": "crates/completion/src/render.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fcompletion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fcompletion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -10,7 +10,7 @@ pub(crate) mod type_alias;\n \n mod builder_ext;\n \n-use hir::{Documentation, HasAttrs, HirDisplay, Mutability, ScopeDef, Type};\n+use hir::{Documentation, HasAttrs, HirDisplay, ModuleDef, Mutability, ScopeDef, Type};\n use ide_db::{helpers::SnippetCap, RootDatabase};\n use syntax::TextRange;\n use test_utils::mark;\n@@ -51,16 +51,16 @@ pub(crate) fn render_resolution_with_import<'a>(\n     import_edit: ImportEdit,\n     resolution: &ScopeDef,\n ) -> Option<CompletionItem> {\n-    Render::new(ctx)\n-        .render_resolution(\n-            import_edit.import_path.segments.last()?.to_string(),\n-            Some(import_edit),\n-            resolution,\n-        )\n-        .map(|mut item| {\n-            item.completion_kind = CompletionKind::Magic;\n-            item\n-        })\n+    let local_name = match resolution {\n+        ScopeDef::ModuleDef(ModuleDef::Function(f)) => f.name(ctx.completion.db).to_string(),\n+        ScopeDef::ModuleDef(ModuleDef::Const(c)) => c.name(ctx.completion.db)?.to_string(),\n+        ScopeDef::ModuleDef(ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db).to_string(),\n+        _ => import_edit.import_path.segments.last()?.to_string(),\n+    };\n+    Render::new(ctx).render_resolution(local_name, Some(import_edit), resolution).map(|mut item| {\n+        item.completion_kind = CompletionKind::Magic;\n+        item\n+    })\n }\n \n /// Interface for data and methods required for items rendering."}, {"sha": "3faf861b9af024844ffb4ffceeb218f371ec57a4", "filename": "crates/completion/src/test_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -18,7 +18,7 @@ use crate::{item::CompletionKind, CompletionConfig, CompletionItem};\n \n pub(crate) const TEST_CONFIG: CompletionConfig = CompletionConfig {\n     enable_postfix_completions: true,\n-    enable_autoimport_completions: true,\n+    enable_imports_on_the_fly: true,\n     add_call_parenthesis: true,\n     add_call_argument_snippets: true,\n     snippet_cap: SnippetCap::new(true),"}, {"sha": "2950f08b8f0077e21034fa3b0eb204ef5b8a74f2", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -272,6 +272,15 @@ impl ModuleDef {\n \n         hir_ty::diagnostics::validate_module_item(db, module.id.krate, id, sink)\n     }\n+\n+    pub fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n+        match self {\n+            ModuleDef::Function(f) => f.as_assoc_item(db),\n+            ModuleDef::Const(c) => c.as_assoc_item(db),\n+            ModuleDef::TypeAlias(t) => t.as_assoc_item(db),\n+            _ => None,\n+        }\n+    }\n }\n \n impl Module {\n@@ -1091,6 +1100,13 @@ impl AssocItem {\n             AssocContainerId::ContainerId(_) => panic!(\"invalid AssocItem\"),\n         }\n     }\n+\n+    pub fn containing_trait(self, db: &dyn HirDatabase) -> Option<Trait> {\n+        match self.container(db) {\n+            AssocItemContainer::Trait(t) => Some(t),\n+            _ => None,\n+        }\n+    }\n }\n \n impl HasVisibility for AssocItem {"}, {"sha": "fac0de90cd67ad604738a8334abee64f39a5b569", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -263,6 +263,7 @@ pub enum ImportKind {\n     Trait,\n     TypeAlias,\n     BuiltinType,\n+    AssociatedItem,\n }\n \n /// A way to match import map contents against the search query.\n@@ -282,6 +283,7 @@ pub struct Query {\n     query: String,\n     lowercased: String,\n     name_only: bool,\n+    assoc_items_only: bool,\n     search_mode: SearchMode,\n     case_sensitive: bool,\n     limit: usize,\n@@ -295,6 +297,7 @@ impl Query {\n             query,\n             lowercased,\n             name_only: false,\n+            assoc_items_only: false,\n             search_mode: SearchMode::Contains,\n             case_sensitive: false,\n             limit: usize::max_value(),\n@@ -309,6 +312,11 @@ impl Query {\n         Self { name_only: true, ..self }\n     }\n \n+    /// Matches only the entries that are associated items, ignoring the rest.\n+    pub fn assoc_items_only(self) -> Self {\n+        Self { assoc_items_only: true, ..self }\n+    }\n+\n     /// Specifies the way to search for the entries using the query.\n     pub fn search_mode(self, search_mode: SearchMode) -> Self {\n         Self { search_mode, ..self }\n@@ -331,6 +339,14 @@ impl Query {\n     }\n \n     fn import_matches(&self, import: &ImportInfo, enforce_lowercase: bool) -> bool {\n+        if import.is_trait_assoc_item {\n+            if self.exclude_import_kinds.contains(&ImportKind::AssociatedItem) {\n+                return false;\n+            }\n+        } else if self.assoc_items_only {\n+            return false;\n+        }\n+\n         let mut input = if import.is_trait_assoc_item || self.name_only {\n             import.path.segments.last().unwrap().to_string()\n         } else {\n@@ -813,6 +829,56 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn assoc_items_filtering() {\n+        let ra_fixture = r#\"\n+        //- /main.rs crate:main deps:dep\n+        //- /dep.rs crate:dep\n+        pub mod fmt {\n+            pub trait Display {\n+                type FmtTypeAlias;\n+                const FMT_CONST: bool;\n+\n+                fn format_function();\n+                fn format_method(&self);\n+            }\n+        }\n+    \"#;\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string()).search_mode(SearchMode::Fuzzy).assoc_items_only(),\n+            expect![[r#\"\n+            dep::fmt::Display::FMT_CONST (a)\n+            dep::fmt::Display::format_function (a)\n+            dep::fmt::Display::format_method (a)\n+        \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string())\n+                .search_mode(SearchMode::Fuzzy)\n+                .exclude_import_kind(ImportKind::AssociatedItem),\n+            expect![[r#\"\n+            dep::fmt (t)\n+            dep::fmt::Display (t)\n+        \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string())\n+                .search_mode(SearchMode::Fuzzy)\n+                .assoc_items_only()\n+                .exclude_import_kind(ImportKind::AssociatedItem),\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+\n     #[test]\n     fn search_mode() {\n         let ra_fixture = r#\""}, {"sha": "1f08d7810388c80517c3ecf52b33305422140f01", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -438,10 +438,10 @@ fn get_symbol_fragment(db: &dyn HirDatabase, field_or_assoc: &FieldOrAssocItem)\n         FieldOrAssocItem::Field(field) => format!(\"#structfield.{}\", field.name(db)),\n         FieldOrAssocItem::AssocItem(assoc) => match assoc {\n             AssocItem::Function(function) => {\n-                let is_trait_method = matches!(\n-                    function.as_assoc_item(db).map(|assoc| assoc.container(db)),\n-                    Some(AssocItemContainer::Trait(..))\n-                );\n+                let is_trait_method = function\n+                    .as_assoc_item(db)\n+                    .and_then(|assoc| assoc.containing_trait(db))\n+                    .is_some();\n                 // This distinction may get more complicated when specialization is available.\n                 // Rustdoc makes this decision based on whether a method 'has defaultness'.\n                 // Currently this is only the case for provided trait methods."}, {"sha": "3abbb14c64842c45fc2e8312c4c8da0f7009b3e0", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -478,6 +478,7 @@ impl Analysis {\n         position: FilePosition,\n         full_import_path: &str,\n         imported_name: String,\n+        import_for_trait_assoc_item: bool,\n     ) -> Cancelable<Vec<TextEdit>> {\n         Ok(self\n             .with_db(|db| {\n@@ -487,6 +488,7 @@ impl Analysis {\n                     position,\n                     full_import_path,\n                     imported_name,\n+                    import_for_trait_assoc_item,\n                 )\n             })?\n             .unwrap_or_default())"}, {"sha": "517abbb4bc0eb41178a5b0fa95d07bf6d4d69e86", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 227, "deletions": 129, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -1,12 +1,13 @@\n //! Look up accessible paths for items.\n use either::Either;\n-use hir::{AsAssocItem, AssocItemContainer, ModuleDef, Semantics};\n+use hir::{AsAssocItem, AssocItem, Crate, MacroDef, Module, ModuleDef, PrefixKind, Semantics};\n use rustc_hash::FxHashSet;\n-use syntax::{ast, AstNode, SyntaxNode};\n+use syntax::{ast, AstNode};\n \n-use crate::{imports_locator, RootDatabase};\n-\n-use super::insert_use::InsertUseConfig;\n+use crate::{\n+    imports_locator::{self, AssocItemSearch, DEFAULT_QUERY_SEARCH_LIMIT},\n+    RootDatabase,\n+};\n \n #[derive(Debug)]\n pub enum ImportCandidate {\n@@ -24,86 +25,141 @@ pub enum ImportCandidate {\n \n #[derive(Debug)]\n pub struct TraitImportCandidate {\n-    pub ty: hir::Type,\n-    pub name: ast::NameRef,\n+    pub receiver_ty: hir::Type,\n+    pub name: NameToImport,\n }\n \n #[derive(Debug)]\n pub struct PathImportCandidate {\n     pub qualifier: Option<ast::Path>,\n-    pub name: ast::NameRef,\n+    pub name: NameToImport,\n+}\n+\n+#[derive(Debug)]\n+pub enum NameToImport {\n+    Exact(String),\n+    Fuzzy(String),\n+}\n+\n+impl NameToImport {\n+    pub fn text(&self) -> &str {\n+        match self {\n+            NameToImport::Exact(text) => text.as_str(),\n+            NameToImport::Fuzzy(text) => text.as_str(),\n+        }\n+    }\n }\n \n #[derive(Debug)]\n pub struct ImportAssets {\n     import_candidate: ImportCandidate,\n-    module_with_name_to_import: hir::Module,\n-    syntax_under_caret: SyntaxNode,\n+    module_with_candidate: hir::Module,\n }\n \n impl ImportAssets {\n     pub fn for_method_call(\n-        method_call: ast::MethodCallExpr,\n+        method_call: &ast::MethodCallExpr,\n         sema: &Semantics<RootDatabase>,\n     ) -> Option<Self> {\n-        let syntax_under_caret = method_call.syntax().to_owned();\n-        let module_with_name_to_import = sema.scope(&syntax_under_caret).module()?;\n         Some(Self {\n-            import_candidate: ImportCandidate::for_method_call(sema, &method_call)?,\n-            module_with_name_to_import,\n-            syntax_under_caret,\n+            import_candidate: ImportCandidate::for_method_call(sema, method_call)?,\n+            module_with_candidate: sema.scope(method_call.syntax()).module()?,\n         })\n     }\n \n-    pub fn for_regular_path(\n-        path_under_caret: ast::Path,\n+    pub fn for_exact_path(\n+        fully_qualified_path: &ast::Path,\n         sema: &Semantics<RootDatabase>,\n     ) -> Option<Self> {\n-        let syntax_under_caret = path_under_caret.syntax().to_owned();\n+        let syntax_under_caret = fully_qualified_path.syntax();\n         if syntax_under_caret.ancestors().find_map(ast::Use::cast).is_some() {\n             return None;\n         }\n-\n-        let module_with_name_to_import = sema.scope(&syntax_under_caret).module()?;\n         Some(Self {\n-            import_candidate: ImportCandidate::for_regular_path(sema, &path_under_caret)?,\n-            module_with_name_to_import,\n-            syntax_under_caret,\n+            import_candidate: ImportCandidate::for_regular_path(sema, fully_qualified_path)?,\n+            module_with_candidate: sema.scope(syntax_under_caret).module()?,\n         })\n     }\n \n-    pub fn syntax_under_caret(&self) -> &SyntaxNode {\n-        &self.syntax_under_caret\n+    pub fn for_fuzzy_path(\n+        module_with_path: Module,\n+        qualifier: Option<ast::Path>,\n+        fuzzy_name: String,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> Option<Self> {\n+        Some(match qualifier {\n+            Some(qualifier) => {\n+                let qualifier_resolution = sema.resolve_path(&qualifier)?;\n+                match qualifier_resolution {\n+                    hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) => Self {\n+                        import_candidate: ImportCandidate::TraitAssocItem(TraitImportCandidate {\n+                            receiver_ty: assoc_item_path.ty(sema.db),\n+                            name: NameToImport::Fuzzy(fuzzy_name),\n+                        }),\n+                        module_with_candidate: module_with_path,\n+                    },\n+                    _ => Self {\n+                        import_candidate: ImportCandidate::Path(PathImportCandidate {\n+                            qualifier: Some(qualifier),\n+                            name: NameToImport::Fuzzy(fuzzy_name),\n+                        }),\n+                        module_with_candidate: module_with_path,\n+                    },\n+                }\n+            }\n+            None => Self {\n+                import_candidate: ImportCandidate::Path(PathImportCandidate {\n+                    qualifier: None,\n+                    name: NameToImport::Fuzzy(fuzzy_name),\n+                }),\n+                module_with_candidate: module_with_path,\n+            },\n+        })\n     }\n \n+    pub fn for_fuzzy_method_call(\n+        module_with_method_call: Module,\n+        receiver_ty: hir::Type,\n+        fuzzy_method_name: String,\n+    ) -> Option<Self> {\n+        Some(Self {\n+            import_candidate: ImportCandidate::TraitMethod(TraitImportCandidate {\n+                receiver_ty,\n+                name: NameToImport::Fuzzy(fuzzy_method_name),\n+            }),\n+            module_with_candidate: module_with_method_call,\n+        })\n+    }\n+}\n+\n+impl ImportAssets {\n     pub fn import_candidate(&self) -> &ImportCandidate {\n         &self.import_candidate\n     }\n \n-    fn get_search_query(&self) -> &str {\n+    fn name_to_import(&self) -> &NameToImport {\n         match &self.import_candidate {\n-            ImportCandidate::Path(candidate) => candidate.name.text(),\n+            ImportCandidate::Path(candidate) => &candidate.name,\n             ImportCandidate::TraitAssocItem(candidate)\n-            | ImportCandidate::TraitMethod(candidate) => candidate.name.text(),\n+            | ImportCandidate::TraitMethod(candidate) => &candidate.name,\n         }\n     }\n \n     pub fn search_for_imports(\n         &self,\n         sema: &Semantics<RootDatabase>,\n-        config: &InsertUseConfig,\n+        prefix_kind: PrefixKind,\n     ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n-        let _p = profile::span(\"import_assists::search_for_imports\");\n-        self.search_for(sema, Some(config.prefix_kind))\n+        let _p = profile::span(\"import_assets::search_for_imports\");\n+        self.search_for(sema, Some(prefix_kind))\n     }\n \n     /// This may return non-absolute paths if a part of the returned path is already imported into scope.\n-    #[allow(dead_code)]\n     pub fn search_for_relative_paths(\n         &self,\n         sema: &Semantics<RootDatabase>,\n     ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n-        let _p = profile::span(\"import_assists::search_for_relative_paths\");\n+        let _p = profile::span(\"import_assets::search_for_relative_paths\");\n         self.search_for(sema, None)\n     }\n \n@@ -112,99 +168,142 @@ impl ImportAssets {\n         sema: &Semantics<RootDatabase>,\n         prefixed: Option<hir::PrefixKind>,\n     ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n-        let db = sema.db;\n-        let mut trait_candidates = FxHashSet::default();\n-        let current_crate = self.module_with_name_to_import.krate();\n+        let current_crate = self.module_with_candidate.krate();\n \n-        let filter = |candidate: Either<hir::ModuleDef, hir::MacroDef>| {\n-            trait_candidates.clear();\n-            match &self.import_candidate {\n-                ImportCandidate::TraitAssocItem(trait_candidate) => {\n-                    let located_assoc_item = match candidate {\n-                        Either::Left(ModuleDef::Function(located_function)) => {\n-                            located_function.as_assoc_item(db)\n-                        }\n-                        Either::Left(ModuleDef::Const(located_const)) => {\n-                            located_const.as_assoc_item(db)\n-                        }\n-                        _ => None,\n+        let unfiltered_imports = match self.name_to_import() {\n+            NameToImport::Exact(exact_name) => {\n+                imports_locator::find_exact_imports(sema, current_crate, exact_name.clone())\n+            }\n+            // FIXME: ideally, we should avoid using `fst` for seacrhing trait imports for assoc items:\n+            // instead, we need to look up all trait impls for a certain struct and search through them only\n+            // see https://github.com/rust-analyzer/rust-analyzer/pull/7293#issuecomment-761585032\n+            // and https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Blanket.20trait.20impls.20lookup\n+            // for the details\n+            NameToImport::Fuzzy(fuzzy_name) => {\n+                let (assoc_item_search, limit) = match self.import_candidate {\n+                    ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_) => {\n+                        (AssocItemSearch::AssocItemsOnly, None)\n                     }\n-                    .map(|assoc| assoc.container(db))\n-                    .and_then(Self::assoc_to_trait)?;\n-\n-                    trait_candidates.insert(located_assoc_item.into());\n+                    _ => (AssocItemSearch::Exclude, Some(DEFAULT_QUERY_SEARCH_LIMIT)),\n+                };\n+                imports_locator::find_similar_imports(\n+                    sema,\n+                    current_crate,\n+                    fuzzy_name.clone(),\n+                    assoc_item_search,\n+                    limit,\n+                )\n+            }\n+        };\n \n-                    trait_candidate\n-                        .ty\n-                        .iterate_path_candidates(\n-                            db,\n-                            current_crate,\n-                            &trait_candidates,\n-                            None,\n-                            |_, assoc| Self::assoc_to_trait(assoc.container(db)),\n-                        )\n-                        .map(ModuleDef::from)\n-                        .map(Either::Left)\n-                }\n-                ImportCandidate::TraitMethod(trait_candidate) => {\n-                    let located_assoc_item =\n-                        if let Either::Left(ModuleDef::Function(located_function)) = candidate {\n-                            located_function\n-                                .as_assoc_item(db)\n-                                .map(|assoc| assoc.container(db))\n-                                .and_then(Self::assoc_to_trait)\n-                        } else {\n-                            None\n-                        }?;\n+        let db = sema.db;\n+        let mut res =\n+            applicable_defs(self.import_candidate(), current_crate, db, unfiltered_imports)\n+                .filter_map(|candidate| {\n+                    let item: hir::ItemInNs = candidate.clone().either(Into::into, Into::into);\n \n-                    trait_candidates.insert(located_assoc_item.into());\n+                    let item_to_search = match self.import_candidate {\n+                        ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_) => {\n+                            let canidate_trait = match candidate {\n+                                Either::Left(module_def) => {\n+                                    module_def.as_assoc_item(db)?.containing_trait(db)\n+                                }\n+                                _ => None,\n+                            }?;\n+                            ModuleDef::from(canidate_trait).into()\n+                        }\n+                        _ => item,\n+                    };\n \n-                    trait_candidate\n-                        .ty\n-                        .iterate_method_candidates(\n+                    if let Some(prefix_kind) = prefixed {\n+                        self.module_with_candidate.find_use_path_prefixed(\n                             db,\n-                            current_crate,\n-                            &trait_candidates,\n-                            None,\n-                            |_, function| {\n-                                Self::assoc_to_trait(function.as_assoc_item(db)?.container(db))\n-                            },\n+                            item_to_search,\n+                            prefix_kind,\n                         )\n-                        .map(ModuleDef::from)\n-                        .map(Either::Left)\n-                }\n-                _ => Some(candidate),\n-            }\n-        };\n-\n-        let mut res = imports_locator::find_exact_imports(\n-            sema,\n-            current_crate,\n-            self.get_search_query().to_string(),\n-        )\n-        .filter_map(filter)\n-        .filter_map(|candidate| {\n-            let item: hir::ItemInNs = candidate.either(Into::into, Into::into);\n-            if let Some(prefix_kind) = prefixed {\n-                self.module_with_name_to_import.find_use_path_prefixed(db, item, prefix_kind)\n-            } else {\n-                self.module_with_name_to_import.find_use_path(db, item)\n-            }\n-            .map(|path| (path, item))\n-        })\n-        .filter(|(use_path, _)| use_path.len() > 1)\n-        .take(20)\n-        .collect::<Vec<_>>();\n-        res.sort_by_key(|(path, _)| path.clone());\n+                    } else {\n+                        self.module_with_candidate.find_use_path(db, item_to_search)\n+                    }\n+                    .map(|path| (path, item))\n+                })\n+                .filter(|(use_path, _)| use_path.len() > 1)\n+                .collect::<Vec<_>>();\n+        res.sort_by_cached_key(|(path, _)| path.clone());\n         res\n     }\n+}\n \n-    fn assoc_to_trait(assoc: AssocItemContainer) -> Option<hir::Trait> {\n-        if let AssocItemContainer::Trait(extracted_trait) = assoc {\n-            Some(extracted_trait)\n-        } else {\n-            None\n+fn applicable_defs<'a>(\n+    import_candidate: &ImportCandidate,\n+    current_crate: Crate,\n+    db: &RootDatabase,\n+    unfiltered_imports: Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a>,\n+) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a> {\n+    let receiver_ty = match import_candidate {\n+        ImportCandidate::Path(_) => return unfiltered_imports,\n+        ImportCandidate::TraitAssocItem(candidate) | ImportCandidate::TraitMethod(candidate) => {\n+            &candidate.receiver_ty\n         }\n+    };\n+\n+    let mut required_assoc_items = FxHashSet::default();\n+\n+    let trait_candidates = unfiltered_imports\n+        .filter_map(|input| match input {\n+            Either::Left(module_def) => module_def.as_assoc_item(db),\n+            _ => None,\n+        })\n+        .filter_map(|assoc| {\n+            let assoc_item_trait = assoc.containing_trait(db)?;\n+            required_assoc_items.insert(assoc);\n+            Some(assoc_item_trait.into())\n+        })\n+        .collect();\n+\n+    let mut applicable_defs = FxHashSet::default();\n+\n+    match import_candidate {\n+        ImportCandidate::Path(_) => unreachable!(),\n+        ImportCandidate::TraitAssocItem(_) => receiver_ty.iterate_path_candidates(\n+            db,\n+            current_crate,\n+            &trait_candidates,\n+            None,\n+            |_, assoc| {\n+                if required_assoc_items.contains(&assoc) {\n+                    if let AssocItem::Function(f) = assoc {\n+                        if f.self_param(db).is_some() {\n+                            return None;\n+                        }\n+                    }\n+                    applicable_defs.insert(Either::Left(assoc_to_module_def(assoc)));\n+                }\n+                None::<()>\n+            },\n+        ),\n+        ImportCandidate::TraitMethod(_) => receiver_ty.iterate_method_candidates(\n+            db,\n+            current_crate,\n+            &trait_candidates,\n+            None,\n+            |_, function| {\n+                let assoc = function.as_assoc_item(db)?;\n+                if required_assoc_items.contains(&assoc) {\n+                    applicable_defs.insert(Either::Left(assoc_to_module_def(assoc)));\n+                }\n+                None::<()>\n+            },\n+        ),\n+    };\n+\n+    Box::new(applicable_defs.into_iter())\n+}\n+\n+fn assoc_to_module_def(assoc: AssocItem) -> ModuleDef {\n+    match assoc {\n+        AssocItem::Function(f) => f.into(),\n+        AssocItem::Const(c) => c.into(),\n+        AssocItem::TypeAlias(t) => t.into(),\n     }\n }\n \n@@ -216,22 +315,19 @@ impl ImportCandidate {\n         match sema.resolve_method_call(method_call) {\n             Some(_) => None,\n             None => Some(Self::TraitMethod(TraitImportCandidate {\n-                ty: sema.type_of_expr(&method_call.receiver()?)?,\n-                name: method_call.name_ref()?,\n+                receiver_ty: sema.type_of_expr(&method_call.receiver()?)?,\n+                name: NameToImport::Exact(method_call.name_ref()?.to_string()),\n             })),\n         }\n     }\n \n-    fn for_regular_path(\n-        sema: &Semantics<RootDatabase>,\n-        path_under_caret: &ast::Path,\n-    ) -> Option<Self> {\n-        if sema.resolve_path(path_under_caret).is_some() {\n+    fn for_regular_path(sema: &Semantics<RootDatabase>, path: &ast::Path) -> Option<Self> {\n+        if sema.resolve_path(path).is_some() {\n             return None;\n         }\n \n-        let segment = path_under_caret.segment()?;\n-        let candidate = if let Some(qualifier) = path_under_caret.qualifier() {\n+        let segment = path.segment()?;\n+        let candidate = if let Some(qualifier) = path.qualifier() {\n             let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n             let qualifier_start_path =\n                 qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n@@ -244,22 +340,24 @@ impl ImportCandidate {\n                 match qualifier_resolution {\n                     hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) => {\n                         ImportCandidate::TraitAssocItem(TraitImportCandidate {\n-                            ty: assoc_item_path.ty(sema.db),\n-                            name: segment.name_ref()?,\n+                            receiver_ty: assoc_item_path.ty(sema.db),\n+                            name: NameToImport::Exact(segment.name_ref()?.to_string()),\n                         })\n                     }\n                     _ => return None,\n                 }\n             } else {\n                 ImportCandidate::Path(PathImportCandidate {\n                     qualifier: Some(qualifier),\n-                    name: qualifier_start,\n+                    name: NameToImport::Exact(qualifier_start.to_string()),\n                 })\n             }\n         } else {\n             ImportCandidate::Path(PathImportCandidate {\n                 qualifier: None,\n-                name: segment.syntax().descendants().find_map(ast::NameRef::cast)?,\n+                name: NameToImport::Exact(\n+                    segment.syntax().descendants().find_map(ast::NameRef::cast)?.to_string(),\n+                ),\n             })\n         };\n         Some(candidate)"}, {"sha": "502e8281a3cd79d30cb0b2404a8219b7ba63ff13", "filename": "crates/ide_db/src/imports_locator.rs", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -1,7 +1,10 @@\n //! This module contains an import search functionality that is provided to the assists module.\n //! Later, this should be moved away to a separate crate that is accessible from the assists module.\n \n-use hir::{import_map, AsAssocItem, Crate, MacroDef, ModuleDef, Semantics};\n+use hir::{\n+    import_map::{self, ImportKind},\n+    AsAssocItem, Crate, MacroDef, ModuleDef, Semantics,\n+};\n use syntax::{ast, AstNode, SyntaxKind::NAME};\n \n use crate::{\n@@ -12,69 +15,84 @@ use crate::{\n use either::Either;\n use rustc_hash::FxHashSet;\n \n-const QUERY_SEARCH_LIMIT: usize = 40;\n+pub(crate) const DEFAULT_QUERY_SEARCH_LIMIT: usize = 40;\n \n pub fn find_exact_imports<'a>(\n     sema: &Semantics<'a, RootDatabase>,\n     krate: Crate,\n     name_to_import: String,\n-) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n+) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>>> {\n     let _p = profile::span(\"find_exact_imports\");\n-    find_imports(\n+    Box::new(find_imports(\n         sema,\n         krate,\n         {\n             let mut local_query = symbol_index::Query::new(name_to_import.clone());\n             local_query.exact();\n-            local_query.limit(QUERY_SEARCH_LIMIT);\n+            local_query.limit(DEFAULT_QUERY_SEARCH_LIMIT);\n             local_query\n         },\n         import_map::Query::new(name_to_import)\n-            .limit(QUERY_SEARCH_LIMIT)\n+            .limit(DEFAULT_QUERY_SEARCH_LIMIT)\n             .name_only()\n             .search_mode(import_map::SearchMode::Equals)\n             .case_sensitive(),\n-    )\n+    ))\n+}\n+\n+pub enum AssocItemSearch {\n+    Include,\n+    Exclude,\n+    AssocItemsOnly,\n }\n \n pub fn find_similar_imports<'a>(\n     sema: &Semantics<'a, RootDatabase>,\n     krate: Crate,\n-    limit: Option<usize>,\n     fuzzy_search_string: String,\n-    ignore_assoc_items: bool,\n-    name_only: bool,\n-) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> + 'a {\n+    assoc_item_search: AssocItemSearch,\n+    limit: Option<usize>,\n+) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a> {\n     let _p = profile::span(\"find_similar_imports\");\n \n     let mut external_query = import_map::Query::new(fuzzy_search_string.clone())\n-        .search_mode(import_map::SearchMode::Fuzzy);\n-    if name_only {\n-        external_query = external_query.name_only();\n+        .search_mode(import_map::SearchMode::Fuzzy)\n+        .name_only();\n+\n+    match assoc_item_search {\n+        AssocItemSearch::Include => {}\n+        AssocItemSearch::Exclude => {\n+            external_query = external_query.exclude_import_kind(ImportKind::AssociatedItem);\n+        }\n+        AssocItemSearch::AssocItemsOnly => {\n+            external_query = external_query.assoc_items_only();\n+        }\n     }\n \n     let mut local_query = symbol_index::Query::new(fuzzy_search_string);\n \n     if let Some(limit) = limit {\n-        local_query.limit(limit);\n         external_query = external_query.limit(limit);\n+        local_query.limit(limit);\n     }\n \n     let db = sema.db;\n-    find_imports(sema, krate, local_query, external_query).filter(move |import_candidate| {\n-        if ignore_assoc_items {\n-            match import_candidate {\n-                Either::Left(ModuleDef::Function(function)) => function.as_assoc_item(db).is_none(),\n-                Either::Left(ModuleDef::Const(const_)) => const_.as_assoc_item(db).is_none(),\n-                Either::Left(ModuleDef::TypeAlias(type_alias)) => {\n-                    type_alias.as_assoc_item(db).is_none()\n-                }\n-                _ => true,\n-            }\n-        } else {\n-            true\n-        }\n-    })\n+    Box::new(find_imports(sema, krate, local_query, external_query).filter(\n+        move |import_candidate| match assoc_item_search {\n+            AssocItemSearch::Include => true,\n+            AssocItemSearch::Exclude => !is_assoc_item(import_candidate, db),\n+            AssocItemSearch::AssocItemsOnly => is_assoc_item(import_candidate, db),\n+        },\n+    ))\n+}\n+\n+fn is_assoc_item(import_candidate: &Either<ModuleDef, MacroDef>, db: &RootDatabase) -> bool {\n+    match import_candidate {\n+        Either::Left(ModuleDef::Function(function)) => function.as_assoc_item(db).is_some(),\n+        Either::Left(ModuleDef::Const(const_)) => const_.as_assoc_item(db).is_some(),\n+        Either::Left(ModuleDef::TypeAlias(type_alias)) => type_alias.as_assoc_item(db).is_some(),\n+        _ => false,\n+    }\n }\n \n fn find_imports<'a>("}, {"sha": "d3327271cc16be1667754275cf778a207c376e56", "filename": "crates/parser/src/grammar/items/traits.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -40,6 +40,10 @@ pub(super) fn impl_(p: &mut Parser) {\n         type_params::opt_generic_param_list(p);\n     }\n \n+    // test impl_def_const\n+    // impl const Send for X {}\n+    p.eat(T![const]);\n+\n     // FIXME: never type\n     // impl ! {}\n "}, {"sha": "a01b49822922a91ade53c08072366b6e3308e1b2", "filename": "crates/rust-analyzer/src/cli/analysis_bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -93,7 +93,7 @@ impl BenchCmd {\n                 if is_completion {\n                     let options = CompletionConfig {\n                         enable_postfix_completions: true,\n-                        enable_autoimport_completions: true,\n+                        enable_imports_on_the_fly: true,\n                         add_call_parenthesis: true,\n                         add_call_argument_snippets: true,\n                         snippet_cap: SnippetCap::new(true),"}, {"sha": "3ddb9e19afcd83302dceb2dca03d7d9c3601e088", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -559,7 +559,7 @@ impl Config {\n     pub fn completion(&self) -> CompletionConfig {\n         CompletionConfig {\n             enable_postfix_completions: self.data.completion_postfix_enable,\n-            enable_autoimport_completions: self.data.completion_autoimport_enable\n+            enable_imports_on_the_fly: self.data.completion_autoimport_enable\n                 && completion_item_edit_resolve(&self.caps),\n             add_call_parenthesis: self.data.completion_addCallParenthesis,\n             add_call_argument_snippets: self.data.completion_addCallArgumentSnippets,\n@@ -581,18 +581,7 @@ impl Config {\n         AssistConfig {\n             snippet_cap: SnippetCap::new(self.experimental(\"snippetTextEdit\")),\n             allowed: None,\n-            insert_use: InsertUseConfig {\n-                merge: match self.data.assist_importMergeBehavior {\n-                    MergeBehaviorDef::None => None,\n-                    MergeBehaviorDef::Full => Some(MergeBehavior::Full),\n-                    MergeBehaviorDef::Last => Some(MergeBehavior::Last),\n-                },\n-                prefix_kind: match self.data.assist_importPrefix {\n-                    ImportPrefixDef::Plain => PrefixKind::Plain,\n-                    ImportPrefixDef::ByCrate => PrefixKind::ByCrate,\n-                    ImportPrefixDef::BySelf => PrefixKind::BySelf,\n-                },\n-            },\n+            insert_use: self.insert_use_config(),\n         }\n     }\n     pub fn call_info_full(&self) -> bool {"}, {"sha": "001f3a37de3562f9a5131e74483c8cbb7955dbc4", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -653,7 +653,7 @@ pub(crate) fn handle_completion(\n             let mut new_completion_items =\n                 to_proto::completion_item(&line_index, line_endings, item.clone());\n \n-            if completion_config.enable_autoimport_completions {\n+            if completion_config.enable_imports_on_the_fly {\n                 for new_item in &mut new_completion_items {\n                     fill_resolve_data(&mut new_item.data, &item, &text_document_position);\n                 }\n@@ -703,6 +703,7 @@ pub(crate) fn handle_completion_resolve(\n             FilePosition { file_id, offset },\n             &resolve_data.full_import_path,\n             resolve_data.imported_name,\n+            resolve_data.import_for_trait_assoc_item,\n         )?\n         .into_iter()\n         .flat_map(|edit| {\n@@ -1694,6 +1695,7 @@ struct CompletionResolveData {\n     position: lsp_types::TextDocumentPositionParams,\n     full_import_path: String,\n     imported_name: String,\n+    import_for_trait_assoc_item: bool,\n }\n \n fn fill_resolve_data(\n@@ -1710,6 +1712,7 @@ fn fill_resolve_data(\n             position: position.to_owned(),\n             full_import_path,\n             imported_name,\n+            import_for_trait_assoc_item: import_edit.import_for_trait_assoc_item,\n         })\n         .unwrap(),\n     );"}, {"sha": "0e35500027ccd9baa06a0f4154fc5a8dae225912", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -884,7 +884,7 @@ mod tests {\n             .completions(\n                 &ide::CompletionConfig {\n                     enable_postfix_completions: true,\n-                    enable_autoimport_completions: true,\n+                    enable_imports_on_the_fly: true,\n                     add_call_parenthesis: true,\n                     add_call_argument_snippets: true,\n                     snippet_cap: SnippetCap::new(true),"}, {"sha": "dcd39535b4c3ff5843fc7fcb18a13bd0a74770d2", "filename": "crates/syntax/test_data/parser/inline/ok/0161_impl_def_const.rast", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0161_impl_def_const.rast", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0161_impl_def_const.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0161_impl_def_const.rast?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -0,0 +1,24 @@\n+SOURCE_FILE@0..25\n+  IMPL@0..24\n+    IMPL_KW@0..4 \"impl\"\n+    WHITESPACE@4..5 \" \"\n+    CONST_KW@5..10 \"const\"\n+    WHITESPACE@10..11 \" \"\n+    PATH_TYPE@11..15\n+      PATH@11..15\n+        PATH_SEGMENT@11..15\n+          NAME_REF@11..15\n+            IDENT@11..15 \"Send\"\n+    WHITESPACE@15..16 \" \"\n+    FOR_KW@16..19 \"for\"\n+    WHITESPACE@19..20 \" \"\n+    PATH_TYPE@20..21\n+      PATH@20..21\n+        PATH_SEGMENT@20..21\n+          NAME_REF@20..21\n+            IDENT@20..21 \"X\"\n+    WHITESPACE@21..22 \" \"\n+    ASSOC_ITEM_LIST@22..24\n+      L_CURLY@22..23 \"{\"\n+      R_CURLY@23..24 \"}\"\n+  WHITESPACE@24..25 \"\\n\""}, {"sha": "8d68864693b7811fffb9cfb39ec30caa24f94fc5", "filename": "crates/syntax/test_data/parser/inline/ok/0161_impl_def_const.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0161_impl_def_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342bf41022fa78856a48560b521ea32aa76f6f06/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0161_impl_def_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0161_impl_def_const.rs?ref=342bf41022fa78856a48560b521ea32aa76f6f06", "patch": "@@ -0,0 +1 @@\n+impl const Send for X {}"}]}