{"sha": "7d78436359da05a256107a179c7098fef465dd7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNzg0MzYzNTlkYTA1YTI1NjEwN2ExNzljNzA5OGZlZjQ2NWRkN2M=", "commit": {"author": {"name": "Nick Hamann", "email": "nick@wabbo.org", "date": "2016-05-17T07:59:18Z"}, "committer": {"name": "Nick Hamann", "email": "nick@wabbo.org", "date": "2016-05-23T18:18:28Z"}, "message": "Improve the long explanation of E0207.\n\nThe previous explanation does not seem to explain what it means for an\nimplementation parameter to be used or unused. The new explanation lists\nthe three ways specific ways by which an impl parameter becomes constrained\n(taken from RFC 447).\n\nThis also adds a link to RFC 447.\n\nThe explanation has two different examples. The first is adapted from RFC 447,\nand shows an instance of E0207 on a impl for a type. The second one is a trait\nimpl example adapted from issue #22834.\n\nCloses #33650", "tree": {"sha": "76d9d5f45d604303ff3243b0da2360b77ee382bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76d9d5f45d604303ff3243b0da2360b77ee382bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d78436359da05a256107a179c7098fef465dd7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d78436359da05a256107a179c7098fef465dd7c", "html_url": "https://github.com/rust-lang/rust/commit/7d78436359da05a256107a179c7098fef465dd7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d78436359da05a256107a179c7098fef465dd7c/comments", "author": null, "committer": null, "parents": [{"sha": "cde0fa5f673c99e8d534123187ee554452513dc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde0fa5f673c99e8d534123187ee554452513dc3", "html_url": "https://github.com/rust-lang/rust/commit/cde0fa5f673c99e8d534123187ee554452513dc3"}], "stats": {"total": 126, "additions": 111, "deletions": 15}, "files": [{"sha": "251a92b9ef113fd536535ae9349467fdab93ede9", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 111, "deletions": 15, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/7d78436359da05a256107a179c7098fef465dd7c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d78436359da05a256107a179c7098fef465dd7c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=7d78436359da05a256107a179c7098fef465dd7c", "patch": "@@ -2387,39 +2387,135 @@ impl Copy for &'static Bar { } // error\n \"##,\n \n E0207: r##\"\n-You declared an unused type parameter when implementing a trait on an object.\n-Erroneous code example:\n+Any type parameter or lifetime parameter of an `impl` must meet at least one of\n+the following criteria:\n+\n+ - it appears in the self type of the impl\n+ - for a trait impl, it appears in the trait reference\n+ - it is bound as an associated type\n+\n+### Error example 1\n+\n+Suppose we have a struct `Foo` and we would like to define some methods for it.\n+The following definition leads to a compiler error:\n \n ```compile_fail\n-trait MyTrait {\n-    fn get(&self) -> usize;\n+struct Foo;\n+\n+impl<T: Default> Foo {\n+// error: the type parameter `T` is not constrained by the impl trait, self\n+// type, or predicates [E0207]\n+    fn get(&self) -> T {\n+        <T as Default>::default()\n+    }\n }\n+```\n+\n+The problem is that the parameter `T` does not appear in the self type (`Foo`)\n+of the impl. In this case, we can fix the error by moving the type parameter\n+from the `impl` to the method `get`:\n+\n \n+```\n struct Foo;\n \n-impl<T> MyTrait for Foo {\n-    fn get(&self) -> usize {\n-        0\n+// Move the type parameter from the impl to the method\n+impl Foo {\n+    fn get<T: Default>(&self) -> T {\n+        <T as Default>::default()\n     }\n }\n ```\n \n-Please check your object definition and remove unused type\n-parameter(s). Example:\n+### Error example 2\n \n+As another example, suppose we have a `Maker` trait and want to establish a\n+type `FooMaker` that makes `Foo`s:\n+\n+```compile_fail\n+trait Maker {\n+    type Item;\n+    fn make(&mut self) -> Self::Item;\n+}\n+\n+struct Foo<T> {\n+    foo: T\n+}\n+\n+struct FooMaker;\n+\n+impl<T: Default> Maker for FooMaker {\n+// error: the type parameter `T` is not constrained by the impl trait, self\n+// type, or predicates [E0207]\n+    type Item = Foo<T>;\n+\n+    fn make(&mut self) -> Foo<T> {\n+        Foo { foo: <T as Default>::default() }\n+    }\n+}\n ```\n-trait MyTrait {\n-    fn get(&self) -> usize;\n+\n+This fails to compile because `T` does not appear in the trait or in the\n+implementing type.\n+\n+One way to work around this is to introduce a phantom type parameter into\n+`FooMaker`, like so:\n+\n+```\n+use std::marker::PhantomData;\n+\n+trait Maker {\n+    type Item;\n+    fn make(&mut self) -> Self::Item;\n }\n \n-struct Foo;\n+struct Foo<T> {\n+    foo: T\n+}\n \n-impl MyTrait for Foo {\n-    fn get(&self) -> usize {\n-        0\n+// Add a type parameter to `FooMaker`\n+struct FooMaker<T> {\n+    phantom: PhantomData<T>,\n+}\n+\n+impl<T: Default> Maker for FooMaker<T> {\n+    type Item = Foo<T>;\n+\n+    fn make(&mut self) -> Foo<T> {\n+        Foo {\n+            foo: <T as Default>::default(),\n+        }\n+    }\n+}\n+```\n+\n+Another way is to do away with the associated type in `Maker` and use an input\n+type parameter instead:\n+\n+```\n+// Use a type parameter instead of an associated type here\n+trait Maker<Item> {\n+    fn make(&mut self) -> Item;\n+}\n+\n+struct Foo<T> {\n+    foo: T\n+}\n+\n+struct FooMaker;\n+\n+impl<T: Default> Maker<Foo<T>> for FooMaker {\n+    fn make(&mut self) -> Foo<T> {\n+        Foo { foo: <T as Default>::default() }\n     }\n }\n ```\n+\n+### Additional information\n+\n+For more information, please see [RFC 447].\n+\n+[RFC 447]: https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md\n \"##,\n \n E0210: r##\""}]}