{"sha": "8ee8d2b4b9c1805aef1407d7b8ca476d1490ffa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZThkMmI0YjljMTgwNWFlZjE0MDdkN2I4Y2E0NzZkMTQ5MGZmYTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-21T22:44:18Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T23:54:31Z"}, "message": "librustc: De-`@mut` arrays of `entry` used in the encoder", "tree": {"sha": "483bd90fde31226ae20b53fec37a2720942850a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/483bd90fde31226ae20b53fec37a2720942850a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ee8d2b4b9c1805aef1407d7b8ca476d1490ffa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ee8d2b4b9c1805aef1407d7b8ca476d1490ffa1", "html_url": "https://github.com/rust-lang/rust/commit/8ee8d2b4b9c1805aef1407d7b8ca476d1490ffa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ee8d2b4b9c1805aef1407d7b8ca476d1490ffa1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02d31b7d1aa147c1b54c891c94bb977cc679b2c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/02d31b7d1aa147c1b54c891c94bb977cc679b2c8", "html_url": "https://github.com/rust-lang/rust/commit/02d31b7d1aa147c1b54c891c94bb977cc679b2c8"}], "stats": {"total": 98, "additions": 72, "deletions": 26}, "files": [{"sha": "59f4db7f7f98d1996f30696e73ca09b73c623771", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 72, "deletions": 26, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/8ee8d2b4b9c1805aef1407d7b8ca476d1490ffa1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee8d2b4b9c1805aef1407d7b8ca476d1490ffa1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8ee8d2b4b9c1805aef1407d7b8ca476d1490ffa1", "patch": "@@ -339,7 +339,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             id: NodeId,\n                             variants: &[P<variant>],\n                             path: &[ast_map::path_elt],\n-                            index: @mut ~[entry<i64>],\n+                            index: @RefCell<~[entry<i64>]>,\n                             generics: &ast::Generics) {\n     debug!(\"encode_enum_variant_info(id={:?})\", id);\n \n@@ -349,8 +349,13 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                                ast::DefId { crate: LOCAL_CRATE, node: id });\n     for variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n-        index.push(entry {val: variant.node.id as i64,\n-                          pos: ebml_w.writer.tell()});\n+        {\n+            let mut index = index.borrow_mut();\n+            index.get().push(entry {\n+                val: variant.node.id as i64,\n+                pos: ebml_w.writer.tell(),\n+            });\n+        }\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         match variant.node.kind {\n@@ -719,7 +724,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           path: &[ast_map::path_elt],\n                           fields: &[struct_field],\n-                          global_index: @mut ~[entry<i64>])\n+                          global_index: @RefCell<~[entry<i64>]>)\n                           -> ~[entry<i64>] {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n@@ -735,7 +740,13 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n \n         let id = field.node.id;\n         index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n-        global_index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n+        {\n+            let mut global_index = global_index.borrow_mut();\n+            global_index.get().push(entry {\n+                val: id as i64,\n+                pos: ebml_w.writer.tell(),\n+            });\n+        }\n         ebml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing {} {}\",\n                tcx.sess.str_of(nm), id);\n@@ -754,9 +765,15 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                path: &[ast_map::path_elt],\n                                name: ast::Ident,\n                                ctor_id: NodeId,\n-                               index: @mut ~[entry<i64>],\n+                               index: @RefCell<~[entry<i64>]>,\n                                struct_id: NodeId) {\n-    index.push(entry { val: ctor_id as i64, pos: ebml_w.writer.tell() });\n+    {\n+        let mut index = index.borrow_mut();\n+        index.get().push(entry {\n+            val: ctor_id as i64,\n+            pos: ebml_w.writer.tell(),\n+        });\n+    }\n \n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(ctor_id));\n@@ -898,14 +915,18 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: @item,\n-                        index: @mut ~[entry<i64>],\n+                        index: @RefCell<~[entry<i64>]>,\n                         path: &[ast_map::path_elt],\n                         vis: ast::visibility) {\n     let tcx = ecx.tcx;\n \n     fn add_to_index(item: @item, ebml_w: &writer::Encoder,\n-                     index: @mut ~[entry<i64>]) {\n-        index.push(entry { val: item.id as i64, pos: ebml_w.writer.tell() });\n+                     index: @RefCell<~[entry<i64>]>) {\n+        let mut index = index.borrow_mut();\n+        index.get().push(entry {\n+            val: item.id as i64,\n+            pos: ebml_w.writer.tell(),\n+        });\n     }\n     let add_to_index: || = || add_to_index(item, ebml_w, index);\n \n@@ -1136,8 +1157,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 Some(ast_methods[i])\n             } else { None };\n \n-            index.push(entry {val: m.def_id.node as i64,\n-                              pos: ebml_w.writer.tell()});\n+            {\n+                let mut index = index.borrow_mut();\n+                index.get().push(entry {\n+                    val: m.def_id.node as i64,\n+                    pos: ebml_w.writer.tell(),\n+                });\n+            }\n             encode_info_for_method(ecx,\n                                    ebml_w,\n                                    *m,\n@@ -1192,8 +1218,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             let method_ty = ty::method(tcx, method_def_id);\n \n-            index.push(entry {val: method_def_id.node as i64,\n-                              pos: ebml_w.writer.tell()});\n+            {\n+                let mut index = index.borrow_mut();\n+                index.get().push(entry {\n+                    val: method_def_id.node as i64,\n+                    pos: ebml_w.writer.tell(),\n+                });\n+            }\n \n             ebml_w.start_tag(tag_items_data_item);\n \n@@ -1257,10 +1288,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n                                 nitem: @foreign_item,\n-                                index: @mut ~[entry<i64>],\n+                                index: @RefCell<~[entry<i64>]>,\n                                 path: &ast_map::path,\n                                 abi: AbiSet) {\n-    index.push(entry { val: nitem.id as i64, pos: ebml_w.writer.tell() });\n+    {\n+        let mut index = index.borrow_mut();\n+        index.get().push(entry {\n+            val: nitem.id as i64,\n+            pos: ebml_w.writer.tell(),\n+        });\n+    }\n \n     ebml_w.start_tag(tag_items_data_item);\n     match nitem.node {\n@@ -1299,7 +1336,7 @@ fn my_visit_item(i: @item,\n                  items: ast_map::map,\n                  ebml_w: &mut writer::Encoder,\n                  ecx_ptr: *int,\n-                 index: @mut ~[entry<i64>]) {\n+                 index: @RefCell<~[entry<i64>]>) {\n     match items.get_copy(&i.id) {\n         ast_map::node_item(_, pt) => {\n             let mut ebml_w = unsafe {\n@@ -1317,7 +1354,7 @@ fn my_visit_foreign_item(ni: @foreign_item,\n                          items: ast_map::map,\n                          ebml_w: &mut writer::Encoder,\n                          ecx_ptr:*int,\n-                         index: @mut ~[entry<i64>]) {\n+                         index: @RefCell<~[entry<i64>]>) {\n     match items.get_copy(&ni.id) {\n         ast_map::node_foreign_item(_, abi, _, pt) => {\n             debug!(\"writing foreign item {}::{}\",\n@@ -1347,7 +1384,7 @@ struct EncodeVisitor<'a,'b> {\n     ebml_w_for_visit_item: &'a mut writer::Encoder<'b>,\n     ecx_ptr:*int,\n     items: ast_map::map,\n-    index: @mut ~[entry<i64>],\n+    index: @RefCell<~[entry<i64>]>,\n }\n \n impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n@@ -1377,9 +1414,15 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                          ebml_w: &mut writer::Encoder,\n                          crate: &Crate)\n                          -> ~[entry<i64>] {\n-    let index = @mut ~[];\n+    let index = @RefCell::new(~[]);\n     ebml_w.start_tag(tag_items_data);\n-    index.push(entry { val: CRATE_NODE_ID as i64, pos: ebml_w.writer.tell() });\n+    {\n+        let mut index = index.borrow_mut();\n+        index.get().push(entry {\n+            val: CRATE_NODE_ID as i64,\n+            pos: ebml_w.writer.tell(),\n+        });\n+    }\n     encode_info_for_mod(ecx,\n                         ebml_w,\n                         &crate.module,\n@@ -1403,7 +1446,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     }\n \n     ebml_w.end_tag();\n-    return /*bad*/(*index).clone();\n+    return /*bad*/(*index).get();\n }\n \n \n@@ -1412,16 +1455,19 @@ fn encode_info_for_items(ecx: &EncodeContext,\n fn create_index<T:Clone + Hash + IterBytes + 'static>(\n                 index: ~[entry<T>])\n                 -> ~[@~[entry<T>]] {\n-    let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n-    for _ in range(0u, 256u) { buckets.push(@mut ~[]); };\n+    let mut buckets: ~[@RefCell<~[entry<T>]>] = ~[];\n+    for _ in range(0u, 256u) {\n+        buckets.push(@RefCell::new(~[]));\n+    }\n     for elt in index.iter() {\n         let h = elt.val.hash() as uint;\n-        buckets[h % 256].push((*elt).clone());\n+        let mut bucket = buckets[h % 256].borrow_mut();\n+        bucket.get().push((*elt).clone());\n     }\n \n     let mut buckets_frozen = ~[];\n     for bucket in buckets.iter() {\n-        buckets_frozen.push(@/*bad*/(**bucket).clone());\n+        buckets_frozen.push(@/*bad*/(**bucket).get());\n     }\n     return buckets_frozen;\n }"}]}