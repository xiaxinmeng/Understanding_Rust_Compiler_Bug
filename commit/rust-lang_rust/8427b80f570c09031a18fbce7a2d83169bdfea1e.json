{"sha": "8427b80f570c09031a18fbce7a2d83169bdfea1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MjdiODBmNTcwYzA5MDMxYTE4ZmJjZTdhMmQ4MzE2OWJkZmVhMWU=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-02-17T16:21:58Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-02-17T16:38:31Z"}, "message": "Move reorder-related stuffs in visitor mod to reorder mod", "tree": {"sha": "e52f4fbace40cc2367dd292a910bb29d74c77678", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e52f4fbace40cc2367dd292a910bb29d74c77678"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8427b80f570c09031a18fbce7a2d83169bdfea1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8427b80f570c09031a18fbce7a2d83169bdfea1e", "html_url": "https://github.com/rust-lang/rust/commit/8427b80f570c09031a18fbce7a2d83169bdfea1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8427b80f570c09031a18fbce7a2d83169bdfea1e/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb9cafb4400430d40bef0096623641587a350c9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb9cafb4400430d40bef0096623641587a350c9c", "html_url": "https://github.com/rust-lang/rust/commit/eb9cafb4400430d40bef0096623641587a350c9c"}], "stats": {"total": 197, "additions": 103, "deletions": 94}, "files": [{"sha": "609f8ebf369355547cf17a2f4ee1d846532afa50", "filename": "rustfmt-core/src/reorder.rs", "status": "modified", "additions": 99, "deletions": 2, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8427b80f570c09031a18fbce7a2d83169bdfea1e/rustfmt-core%2Fsrc%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8427b80f570c09031a18fbce7a2d83169bdfea1e/rustfmt-core%2Fsrc%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Freorder.rs?ref=8427b80f570c09031a18fbce7a2d83169bdfea1e", "patch": "@@ -15,8 +15,9 @@\n //! and constatns comes before methods).\n \n use config::lists::*;\n-use syntax::{ast, codemap::Span};\n+use syntax::{ast, attr, codemap::Span};\n \n+use codemap::LineRangeUtils;\n use comment::combine_strs_with_missing_comments;\n use imports::{path_to_imported_ident, rewrite_import};\n use items::rewrite_mod;\n@@ -25,7 +26,8 @@ use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n use utils::mk_sp;\n-use visitor::{filter_inline_attrs, rewrite_extern_crate};\n+use visitor::{filter_inline_attrs, is_extern_crate, is_mod_decl, is_use_item,\n+              rewrite_extern_crate, FmtVisitor};\n \n use std::cmp::Ordering;\n \n@@ -209,3 +211,98 @@ pub fn rewrite_reorderable_items(\n \n     write_list(&item_vec, &fmt)\n }\n+\n+fn contains_macro_use_attr(attrs: &[ast::Attribute], span: Span) -> bool {\n+    attr::contains_name(&filter_inline_attrs(attrs, span), \"macro_use\")\n+}\n+\n+/// Returns true for `mod foo;` without any inline attributes.\n+/// We cannot reorder modules with attributes because doing so can break the code.\n+/// e.g. `#[macro_use]`.\n+fn is_mod_decl_without_attr(item: &ast::Item) -> bool {\n+    is_mod_decl(item) && !contains_macro_use_attr(&item.attrs, item.span())\n+}\n+\n+fn is_use_item_without_attr(item: &ast::Item) -> bool {\n+    is_use_item(item) && !contains_macro_use_attr(&item.attrs, item.span())\n+}\n+\n+fn is_extern_crate_without_attr(item: &ast::Item) -> bool {\n+    is_extern_crate(item) && !contains_macro_use_attr(&item.attrs, item.span())\n+}\n+\n+impl<'b, 'a: 'b> FmtVisitor<'a> {\n+    pub fn reorder_items<F>(\n+        &mut self,\n+        items_left: &[&ast::Item],\n+        is_item: &F,\n+        in_group: bool,\n+    ) -> usize\n+    where\n+        F: Fn(&ast::Item) -> bool,\n+    {\n+        let mut last = self.codemap.lookup_line_range(items_left[0].span());\n+        let item_length = items_left\n+            .iter()\n+            .take_while(|ppi| {\n+                is_item(&***ppi) && (!in_group || {\n+                    let current = self.codemap.lookup_line_range(ppi.span());\n+                    let in_same_group = current.lo < last.hi + 2;\n+                    last = current;\n+                    in_same_group\n+                })\n+            })\n+            .count();\n+        let items = &items_left[..item_length];\n+\n+        let at_least_one_in_file_lines = items\n+            .iter()\n+            .any(|item| !out_of_file_lines_range!(self, item.span));\n+\n+        if at_least_one_in_file_lines {\n+            self.format_imports(items);\n+        } else {\n+            for item in items {\n+                self.push_rewrite(item.span, None);\n+            }\n+        }\n+\n+        item_length\n+    }\n+\n+    pub fn walk_items(&mut self, mut items_left: &[&ast::Item]) {\n+        macro try_reorder_items_with($reorder: ident, $in_group: ident, $pred: ident) {\n+            if self.config.$reorder() && $pred(&*items_left[0]) {\n+                let used_items_len =\n+                    self.reorder_items(items_left, &$pred, self.config.$in_group());\n+                let (_, rest) = items_left.split_at(used_items_len);\n+                items_left = rest;\n+                continue;\n+            }\n+        }\n+\n+        while !items_left.is_empty() {\n+            // If the next item is a `use`, `extern crate` or `mod`, then extract it and any\n+            // subsequent items that have the same item kind to be reordered within\n+            // `format_imports`. Otherwise, just format the next item for output.\n+            {\n+                try_reorder_items_with!(\n+                    reorder_imports,\n+                    reorder_imports_in_group,\n+                    is_use_item_without_attr\n+                );\n+                try_reorder_items_with!(\n+                    reorder_extern_crates,\n+                    reorder_extern_crates_in_group,\n+                    is_extern_crate_without_attr\n+                );\n+                try_reorder_items_with!(reorder_modules, reorder_modules, is_mod_decl_without_attr);\n+            }\n+            // Reaching here means items were not reordered. There must be at least\n+            // one item left in `items_left`, so calling `unwrap()` here is safe.\n+            let (item, rest) = items_left.split_first().unwrap();\n+            self.visit_item(item);\n+            items_left = rest;\n+        }\n+    }\n+}"}, {"sha": "2a35b41cab86f77eba0a54650c17043393c0e156", "filename": "rustfmt-core/src/visitor.rs", "status": "modified", "additions": 4, "deletions": 92, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8427b80f570c09031a18fbce7a2d83169bdfea1e/rustfmt-core%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8427b80f570c09031a18fbce7a2d83169bdfea1e/rustfmt-core%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fvisitor.rs?ref=8427b80f570c09031a18fbce7a2d83169bdfea1e", "patch": "@@ -12,7 +12,7 @@ use std::cmp;\n \n use config::lists::*;\n use syntax::{ast, visit};\n-use syntax::attr::{self, HasAttrs};\n+use syntax::attr::HasAttrs;\n use syntax::codemap::{self, BytePos, CodeMap, Pos, Span};\n use syntax::parse::ParseSess;\n \n@@ -42,46 +42,27 @@ pub fn filter_inline_attrs(attrs: &[ast::Attribute], outer_span: Span) -> Vec<as\n }\n \n /// Returns true for `mod foo;`, false for `mod foo { .. }`.\n-fn is_mod_decl(item: &ast::Item) -> bool {\n+pub fn is_mod_decl(item: &ast::Item) -> bool {\n     match item.node {\n         ast::ItemKind::Mod(ref m) => m.inner.hi() != item.span.hi(),\n         _ => false,\n     }\n }\n \n-fn contains_macro_use_attr(attrs: &[ast::Attribute], span: Span) -> bool {\n-    attr::contains_name(&filter_inline_attrs(attrs, span), \"macro_use\")\n-}\n-\n-/// Returns true for `mod foo;` without any inline attributes.\n-/// We cannot reorder modules with attributes because doing so can break the code.\n-/// e.g. `#[macro_use]`.\n-fn is_mod_decl_without_attr(item: &ast::Item) -> bool {\n-    is_mod_decl(item) && !contains_macro_use_attr(&item.attrs, item.span())\n-}\n-\n-fn is_use_item(item: &ast::Item) -> bool {\n+pub fn is_use_item(item: &ast::Item) -> bool {\n     match item.node {\n         ast::ItemKind::Use(_) => true,\n         _ => false,\n     }\n }\n \n-fn is_use_item_without_attr(item: &ast::Item) -> bool {\n-    is_use_item(item) && !contains_macro_use_attr(&item.attrs, item.span())\n-}\n-\n-fn is_extern_crate(item: &ast::Item) -> bool {\n+pub fn is_extern_crate(item: &ast::Item) -> bool {\n     match item.node {\n         ast::ItemKind::ExternCrate(..) => true,\n         _ => false,\n     }\n }\n \n-fn is_extern_crate_without_attr(item: &ast::Item) -> bool {\n-    is_extern_crate(item) && !contains_macro_use_attr(&item.attrs, item.span())\n-}\n-\n /// Creates a string slice corresponding to the specified span.\n pub struct SnippetProvider<'a> {\n     /// A pointer to the content of the file we are formatting.\n@@ -641,75 +622,6 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         false\n     }\n \n-    fn reorder_items<F>(&mut self, items_left: &[&ast::Item], is_item: &F, in_group: bool) -> usize\n-    where\n-        F: Fn(&ast::Item) -> bool,\n-    {\n-        let mut last = self.codemap.lookup_line_range(items_left[0].span());\n-        let item_length = items_left\n-            .iter()\n-            .take_while(|ppi| {\n-                is_item(&***ppi) && (!in_group || {\n-                    let current = self.codemap.lookup_line_range(ppi.span());\n-                    let in_same_group = current.lo < last.hi + 2;\n-                    last = current;\n-                    in_same_group\n-                })\n-            })\n-            .count();\n-        let items = &items_left[..item_length];\n-\n-        let at_least_one_in_file_lines = items\n-            .iter()\n-            .any(|item| !out_of_file_lines_range!(self, item.span));\n-\n-        if at_least_one_in_file_lines {\n-            self.format_imports(items);\n-        } else {\n-            for item in items {\n-                self.push_rewrite(item.span, None);\n-            }\n-        }\n-\n-        item_length\n-    }\n-\n-    fn walk_items(&mut self, mut items_left: &[&ast::Item]) {\n-        macro try_reorder_items_with($reorder: ident, $in_group: ident, $pred: ident) {\n-            if self.config.$reorder() && $pred(&*items_left[0]) {\n-                let used_items_len =\n-                    self.reorder_items(items_left, &$pred, self.config.$in_group());\n-                let (_, rest) = items_left.split_at(used_items_len);\n-                items_left = rest;\n-                continue;\n-            }\n-        }\n-\n-        while !items_left.is_empty() {\n-            // If the next item is a `use`, `extern crate` or `mod`, then extract it and any\n-            // subsequent items that have the same item kind to be reordered within\n-            // `format_imports`. Otherwise, just format the next item for output.\n-            {\n-                try_reorder_items_with!(\n-                    reorder_imports,\n-                    reorder_imports_in_group,\n-                    is_use_item_without_attr\n-                );\n-                try_reorder_items_with!(\n-                    reorder_extern_crates,\n-                    reorder_extern_crates_in_group,\n-                    is_extern_crate_without_attr\n-                );\n-                try_reorder_items_with!(reorder_modules, reorder_modules, is_mod_decl_without_attr);\n-            }\n-            // Reaching here means items were not reordered. There must be at least\n-            // one item left in `items_left`, so calling `unwrap()` here is safe.\n-            let (item, rest) = items_left.split_first().unwrap();\n-            self.visit_item(item);\n-            items_left = rest;\n-        }\n-    }\n-\n     fn walk_mod_items(&mut self, m: &ast::Mod) {\n         self.walk_items(&ptr_vec_to_ref_vec(&m.items));\n     }"}]}