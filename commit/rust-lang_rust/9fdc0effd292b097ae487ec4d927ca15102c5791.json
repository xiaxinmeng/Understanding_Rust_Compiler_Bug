{"sha": "9fdc0effd292b097ae487ec4d927ca15102c5791", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZGMwZWZmZDI5MmIwOTdhZTQ4N2VjNGQ5MjdjYTE1MTAyYzU3OTE=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-08T23:04:26Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-30T15:36:31Z"}, "message": "implement for loop desugaring", "tree": {"sha": "c6f0cc475b0fe7cee697fdda83714965e33bed01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6f0cc475b0fe7cee697fdda83714965e33bed01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fdc0effd292b097ae487ec4d927ca15102c5791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fdc0effd292b097ae487ec4d927ca15102c5791", "html_url": "https://github.com/rust-lang/rust/commit/9fdc0effd292b097ae487ec4d927ca15102c5791", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fdc0effd292b097ae487ec4d927ca15102c5791/comments", "author": null, "committer": null, "parents": [{"sha": "a65d3f5b98cc94f0a759fbf1a08be9aee0f97883", "url": "https://api.github.com/repos/rust-lang/rust/commits/a65d3f5b98cc94f0a759fbf1a08be9aee0f97883", "html_url": "https://github.com/rust-lang/rust/commit/a65d3f5b98cc94f0a759fbf1a08be9aee0f97883"}], "stats": {"total": 230, "additions": 115, "deletions": 115}, "files": [{"sha": "3f6c19680e77424d12985545d6686ce839270b31", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=9fdc0effd292b097ae487ec4d927ca15102c5791", "patch": "@@ -264,42 +264,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n-                //\n-                //          [pred]\n-                //            |\n-                //            v 1\n-                //          [head]\n-                //            |\n-                //            v 2\n-                //        [loopback] <--+ 7\n-                //            |         |\n-                //            v 3       |\n-                //   +------[cond]      |\n-                //   |        |         |\n-                //   |        v 5       |\n-                //   |       [pat]      |\n-                //   |        |         |\n-                //   |        v 6       |\n-                //   v 4    [body] -----+\n-                // [expr]\n-                //\n-                // Note that `break` and `continue` statements\n-                // may cause additional edges.\n-\n-                let head = self.expr(&**head, pred);             // 1\n-                let loopback = self.add_dummy_node(&[head]);     // 2\n-                let cond = self.add_dummy_node(&[loopback]);     // 3\n-                let expr_exit = self.add_node(expr.id, &[cond]); // 4\n-                self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n-                    continue_index: loopback,\n-                    break_index: expr_exit,\n-                });\n-                let pat = self.pat(&**pat, cond);               // 5\n-                let body = self.block(&**body, pat);            // 6\n-                self.add_contained_edge(body, loopback);        // 7\n-                self.loop_scopes.pop();\n-                expr_exit\n+                self.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n             }\n \n             ast::ExprLoop(ref body, _) => {"}, {"sha": "b09dac6b1dcc65c8006a1063c82b9dcb37510645", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9fdc0effd292b097ae487ec4d927ca15102c5791", "patch": "@@ -538,21 +538,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprForLoop(ref pat, ref head, ref blk, _) => {\n-                // The pattern lives as long as the block.\n-                debug!(\"walk_expr for loop case: blk id={}\", blk.id);\n-                self.consume_expr(&**head);\n-\n-                // Fetch the type of the value that the iteration yields to\n-                // produce the pattern's categorized mutable type.\n-                let pattern_type = return_if_err!(self.typer.node_ty(pat.id));\n-                let blk_scope = region::CodeExtent::from_node_id(blk.id);\n-                let pat_cmt = self.mc.cat_rvalue(pat.id,\n-                                                 pat.span,\n-                                                 ty::ReScope(blk_scope),\n-                                                 pattern_type);\n-                self.walk_irrefutable_pat(pat_cmt, &**pat);\n-\n-                self.walk_block(&**blk);\n+                self.tcx().sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n             }\n \n             ast::ExprUnary(op, ref lhs) => {"}, {"sha": "d91816d1c14b8740bdacb6bcc61aee9733c4154a", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9fdc0effd292b097ae487ec4d927ca15102c5791", "patch": "@@ -491,18 +491,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n           ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n       ast::ExprForLoop(ref pat, _, _, _) => {\n-        pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n-            debug!(\"adding local variable {} from for loop with bm {:?}\",\n-                   p_id, bm);\n-            let name = path1.node;\n-            ir.add_live_node_for_node(p_id, VarDefNode(sp));\n-            ir.add_variable(Local(LocalInfo {\n-                id: p_id,\n-                ident: name\n-            }));\n-        });\n-        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::walk_expr(ir, expr);\n+          ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n       }\n       ast::ExprBinary(op, _, _) if ast_util::lazy_binop(op.node) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -1035,8 +1024,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           ast::ExprForLoop(ref pat, ref head, ref blk, _) => {\n-            let ln = self.propagate_through_loop(expr, ForLoop(&**pat), &**blk, succ);\n-            self.propagate_through_expr(&**head, ln)\n+              self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n@@ -1476,14 +1464,6 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n         visit::walk_expr(this, expr);\n       }\n \n-      ast::ExprForLoop(ref pat, _, _, _) => {\n-        this.pat_bindings(&**pat, |this, ln, var, sp, id| {\n-            this.warn_about_unused(sp, id, ln, var);\n-        });\n-\n-        visit::walk_expr(this, expr);\n-      }\n-\n       // no correctness conditions related to liveness\n       ast::ExprCall(..) | ast::ExprMethodCall(..) | ast::ExprIf(..) |\n       ast::ExprMatch(..) | ast::ExprWhile(..) | ast::ExprLoop(..) |\n@@ -1503,6 +1483,9 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ast::ExprWhileLet(..) => {\n         this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n+      ast::ExprForLoop(..) => {\n+        this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n+      }\n     }\n }\n "}, {"sha": "7de6b70b15955767b8b1cec3fc1328476dd3d98c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9fdc0effd292b097ae487ec4d927ca15102c5791", "patch": "@@ -536,8 +536,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprBlock(..) | ast::ExprLoop(..) | ast::ExprMatch(..) |\n           ast::ExprLit(..) | ast::ExprBreak(..) | ast::ExprMac(..) |\n           ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n-          ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n-          ast::ExprForLoop(..) => {\n+          ast::ExprInlineAsm(..) | ast::ExprBox(..) => {\n             Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n           }\n \n@@ -547,6 +546,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprWhileLet(..) => {\n             self.tcx().sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n           }\n+          ast::ExprForLoop(..) => {\n+            self.tcx().sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n+          }\n         }\n     }\n "}, {"sha": "55cf5835bd744ebb2287827e2789532180f5c91f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9fdc0effd292b097ae487ec4d927ca15102c5791", "patch": "@@ -4582,6 +4582,10 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n         }\n \n+        ast::ExprForLoop(..) => {\n+            tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n+        }\n+\n         ast::ExprLit(ref lit) if lit_is_str(&**lit) => {\n             RvalueDpsExpr\n         }\n@@ -4619,8 +4623,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprLoop(..) |\n         ast::ExprAssign(..) |\n         ast::ExprInlineAsm(..) |\n-        ast::ExprAssignOp(..) |\n-        ast::ExprForLoop(..) => {\n+        ast::ExprAssignOp(..) => {\n             RvalueStmtExpr\n         }\n "}, {"sha": "aefed4b87b460542dcdc83c7f089626bef4493b0", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=9fdc0effd292b097ae487ec4d927ca15102c5791", "patch": "@@ -288,9 +288,9 @@ mod svh_visitor {\n             ExprStruct(..)           => SawExprStruct,\n             ExprRepeat(..)           => SawExprRepeat,\n             ExprParen(..)            => SawExprParen,\n-            ExprForLoop(..)          => SawExprForLoop,\n \n             // just syntactic artifacts, expanded away by time of SVH.\n+            ExprForLoop(..)          => unreachable!(),\n             ExprIfLet(..)            => unreachable!(),\n             ExprWhileLet(..)         => unreachable!(),\n             ExprMac(..)              => unreachable!(),"}, {"sha": "7aa0a30b4557050a7114a626ec0a878aa7bccf8c", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=9fdc0effd292b097ae487ec4d927ca15102c5791", "patch": "@@ -3627,24 +3627,9 @@ fn create_scope_map(cx: &CrateContext,\n                                               Found unexpanded while-let.\");\n             }\n \n-            ast::ExprForLoop(ref pattern, ref head, ref body, _) => {\n-                walk_expr(cx, &**head, scope_stack, scope_map);\n-\n-                with_new_scope(cx,\n-                               exp.span,\n-                               scope_stack,\n-                               scope_map,\n-                               |cx, scope_stack, scope_map| {\n-                    scope_map.insert(exp.id,\n-                                     scope_stack.last()\n-                                                .unwrap()\n-                                                .scope_metadata);\n-                    walk_pattern(cx,\n-                                 &**pattern,\n-                                 scope_stack,\n-                                 scope_map);\n-                    walk_block(cx, &**body, scope_stack, scope_map);\n-                })\n+            ast::ExprForLoop(..) => {\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                              Found unexpanded for loop.\");\n             }\n \n             ast::ExprMac(_) => {"}, {"sha": "14c976c6ae8af86da4a91b941296cb8277cab59d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9fdc0effd292b097ae487ec4d927ca15102c5791", "patch": "@@ -3762,22 +3762,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprWhileLet(..) => {\n         tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n-      ast::ExprForLoop(ref pat, ref head, ref block, _) => {\n-        check_expr(fcx, &**head);\n-        let typ = lookup_method_for_for_loop(fcx, &**head, expr.id);\n-        vtable::select_new_fcx_obligations(fcx);\n-\n-        debug!(\"ExprForLoop each item has type {}\",\n-               fcx.infcx().resolve_type_vars_if_possible(&typ).repr(fcx.tcx()));\n-\n-        let pcx = pat_ctxt {\n-            fcx: fcx,\n-            map: pat_id_map(&tcx.def_map, &**pat),\n-        };\n-        _match::check_pat(&pcx, &**pat, typ);\n-\n-        check_block_no_value(fcx, &**block);\n-        fcx.write_nil(id);\n+      ast::ExprForLoop(..) => {\n+        tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n       }\n       ast::ExprLoop(ref body, _) => {\n         check_block_no_value(fcx, &**body);"}, {"sha": "357bd2c17abd061b5a991b4b5d8d7915b02ca20f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 93, "deletions": 3, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdc0effd292b097ae487ec4d927ca15102c5791/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9fdc0effd292b097ae487ec4d927ca15102c5791", "patch": "@@ -225,11 +225,101 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n         }\n \n+        // Desugar ExprForLoop\n+        // From: `[opt_ident]: for <pat> in <head> <body>`\n         ast::ExprForLoop(pat, head, body, opt_ident) => {\n-            let pat = fld.fold_pat(pat);\n+            // to:\n+            //\n+            //   match ::std::iter::IntoIterator::into_iter(<head>) {\n+            //     mut iter => {\n+            //       [opt_ident]: loop {\n+            //         match ::std::iter::Iterator::next(&mut iter) {\n+            //           ::std::option::Option::Some(<pat>) => <body>,\n+            //           ::std::option::Option::None => break\n+            //         }\n+            //       }\n+            //     }\n+            //   }\n+\n+            // expand <head>\n             let head = fld.fold_expr(head);\n-            let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(span, ast::ExprForLoop(pat, head, body, opt_ident))\n+\n+            // create an hygienic ident\n+            let iter = {\n+                let ident = fld.cx.ident_of(\"iter\");\n+                let new_ident = fresh_name(&ident);\n+                let rename = (ident, new_ident);\n+                let mut rename_list = vec![rename];\n+                let mut rename_fld = IdentRenamer{ renames: &mut rename_list };\n+\n+                rename_fld.fold_ident(ident)\n+            };\n+\n+            let pat_span = pat.span;\n+            // `:;std::option::Option::Some(<pat>) => <body>`\n+            let pat_arm = {\n+                let body_expr = fld.cx.expr_block(body);\n+                let some_pat = fld.cx.pat_some(pat_span, pat);\n+\n+                fld.cx.arm(pat_span, vec![some_pat], body_expr)\n+            };\n+\n+            // `::std::option::Option::None => break`\n+            let break_arm = {\n+                let break_expr = fld.cx.expr_break(span);\n+\n+                fld.cx.arm(span, vec![fld.cx.pat_none(span)], break_expr)\n+            };\n+\n+            // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+            let match_expr = {\n+                let next_path = {\n+                    let strs = vec![\n+                        fld.cx.ident_of(\"std\"),\n+                        fld.cx.ident_of(\"iter\"),\n+                        fld.cx.ident_of(\"Iterator\"),\n+                        fld.cx.ident_of(\"next\"),\n+                    ];\n+\n+                    fld.cx.path_global(span, strs)\n+                };\n+                let ref_mut_iter = fld.cx.expr_mut_addr_of(span, fld.cx.expr_ident(span, iter));\n+                let next_expr =\n+                    fld.cx.expr_call(span, fld.cx.expr_path(next_path), vec![ref_mut_iter]);\n+                let arms = vec![pat_arm, break_arm];\n+\n+                // FIXME(japaric) This should use `ForLoopDesugar` as MatchSource\n+                fld.cx.expr_match(pat_span, next_expr, arms)\n+            };\n+\n+            // `[opt_ident]: loop { ... }`\n+            let loop_block = fld.cx.block_expr(match_expr);\n+            let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n+            let loop_expr = fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident));\n+\n+            // `mut iter => { ... }`\n+            let iter_arm = {\n+                let iter_pat =\n+                    fld.cx.pat_ident_binding_mode(span, iter, ast::BindByValue(ast::MutMutable));\n+                fld.cx.arm(span, vec![iter_pat], loop_expr)\n+            };\n+\n+            // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+            let into_iter_expr = {\n+                let into_iter_path = {\n+                    let strs = vec![\n+                        fld.cx.ident_of(\"std\"),\n+                        fld.cx.ident_of(\"iter\"),\n+                        fld.cx.ident_of(\"IntoIterator\"),\n+                        fld.cx.ident_of(\"into_iter\"),\n+                    ];\n+\n+                    fld.cx.path_global(span, strs)\n+                };\n+\n+                fld.cx.expr_call(span, fld.cx.expr_path(into_iter_path), vec![head])\n+            };\n+            fld.cx.expr_match(span, into_iter_expr, vec![iter_arm])\n         }\n \n         ast::ExprClosure(capture_clause, opt_kind, fn_decl, block) => {"}]}