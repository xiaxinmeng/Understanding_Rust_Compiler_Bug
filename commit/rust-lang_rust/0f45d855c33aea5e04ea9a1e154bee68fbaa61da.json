{"sha": "0f45d855c33aea5e04ea9a1e154bee68fbaa61da", "node_id": "C_kwDOAAsO6NoAKDBmNDVkODU1YzMzYWVhNWUwNGVhOWExZTE1NGJlZTY4ZmJhYTYxZGE", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-03-21T13:37:37Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-03-21T13:37:37Z"}, "message": "rustdoc: Factor out some doc link resolution code into a separate function", "tree": {"sha": "ecad583627f83186b7182ac1c25becd057823ca1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecad583627f83186b7182ac1c25becd057823ca1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f45d855c33aea5e04ea9a1e154bee68fbaa61da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f45d855c33aea5e04ea9a1e154bee68fbaa61da", "html_url": "https://github.com/rust-lang/rust/commit/0f45d855c33aea5e04ea9a1e154bee68fbaa61da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f45d855c33aea5e04ea9a1e154bee68fbaa61da/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3a55419391ab2d5b75b8c8107b37459ca9b2b83", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3a55419391ab2d5b75b8c8107b37459ca9b2b83", "html_url": "https://github.com/rust-lang/rust/commit/d3a55419391ab2d5b75b8c8107b37459ca9b2b83"}], "stats": {"total": 51, "additions": 27, "deletions": 24}, "files": [{"sha": "789523c561e57533783113e37ce5ea41ebe72140", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0f45d855c33aea5e04ea9a1e154bee68fbaa61da/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f45d855c33aea5e04ea9a1e154bee68fbaa61da/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=0f45d855c33aea5e04ea9a1e154bee68fbaa61da", "patch": "@@ -771,30 +771,7 @@ fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_\n \n impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n-        // We want to resolve in the lexical scope of the documentation.\n-        // In the presence of re-exports, this is not the same as the module of the item.\n-        // Rather than merging all documentation into one, resolve it one attribute at a time\n-        // so we know which module it came from.\n-        for (item_id, doc) in prepare_to_doc_link_resolution(&item.attrs.doc_strings) {\n-            if !may_have_doc_links(&doc) {\n-                continue;\n-            }\n-            debug!(\"combined_docs={}\", doc);\n-            // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n-            // This is a degenerate case and it's not supported by rustdoc.\n-            let item_id = item_id.unwrap_or_else(|| item.item_id.expect_def_id());\n-            let module_id = match self.cx.tcx.def_kind(item_id) {\n-                DefKind::Mod if item.inner_docs(self.cx.tcx) => item_id,\n-                _ => find_nearest_parent_module(self.cx.tcx, item_id).unwrap(),\n-            };\n-            for md_link in preprocessed_markdown_links(&doc) {\n-                let link = self.resolve_link(item, item_id, module_id, &doc, &md_link);\n-                if let Some(link) = link {\n-                    self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n-                }\n-            }\n-        }\n-\n+        self.resolve_links(item);\n         self.visit_item_recur(item)\n     }\n }\n@@ -921,6 +898,32 @@ fn preprocessed_markdown_links(s: &str) -> Vec<PreprocessedMarkdownLink> {\n }\n \n impl LinkCollector<'_, '_> {\n+    fn resolve_links(&mut self, item: &Item) {\n+        // We want to resolve in the lexical scope of the documentation.\n+        // In the presence of re-exports, this is not the same as the module of the item.\n+        // Rather than merging all documentation into one, resolve it one attribute at a time\n+        // so we know which module it came from.\n+        for (item_id, doc) in prepare_to_doc_link_resolution(&item.attrs.doc_strings) {\n+            if !may_have_doc_links(&doc) {\n+                continue;\n+            }\n+            debug!(\"combined_docs={}\", doc);\n+            // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n+            // This is a degenerate case and it's not supported by rustdoc.\n+            let item_id = item_id.unwrap_or_else(|| item.item_id.expect_def_id());\n+            let module_id = match self.cx.tcx.def_kind(item_id) {\n+                DefKind::Mod if item.inner_docs(self.cx.tcx) => item_id,\n+                _ => find_nearest_parent_module(self.cx.tcx, item_id).unwrap(),\n+            };\n+            for md_link in preprocessed_markdown_links(&doc) {\n+                let link = self.resolve_link(item, item_id, module_id, &doc, &md_link);\n+                if let Some(link) = link {\n+                    self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n+                }\n+            }\n+        }\n+    }\n+\n     /// This is the entry point for resolving an intra-doc link.\n     ///\n     /// FIXME(jynelson): this is way too many arguments"}]}