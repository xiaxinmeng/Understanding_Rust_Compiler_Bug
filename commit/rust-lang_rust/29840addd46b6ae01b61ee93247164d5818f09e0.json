{"sha": "29840addd46b6ae01b61ee93247164d5818f09e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ODQwYWRkZDQ2YjZhZTAxYjYxZWU5MzI0NzE2NGQ1ODE4ZjA5ZTA=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-15T12:47:37Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-15T13:22:59Z"}, "message": "remove the concept of managed-unique from libstd\n\nCloses #11545", "tree": {"sha": "2dbf462276fb745a0790ba733f13bdef806b0585", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dbf462276fb745a0790ba733f13bdef806b0585"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29840addd46b6ae01b61ee93247164d5818f09e0", "comment_count": 11, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29840addd46b6ae01b61ee93247164d5818f09e0", "html_url": "https://github.com/rust-lang/rust/commit/29840addd46b6ae01b61ee93247164d5818f09e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29840addd46b6ae01b61ee93247164d5818f09e0/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "197fe67e11af002033bb2dc7b5a48ef433a7b103", "url": "https://api.github.com/repos/rust-lang/rust/commits/197fe67e11af002033bb2dc7b5a48ef433a7b103", "html_url": "https://github.com/rust-lang/rust/commit/197fe67e11af002033bb2dc7b5a48ef433a7b103"}], "stats": {"total": 47, "additions": 16, "deletions": 31}, "files": [{"sha": "ab374ebccfeccb25f9ff43e65c9a1d49a02a8ad3", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/29840addd46b6ae01b61ee93247164d5818f09e0/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29840addd46b6ae01b61ee93247164d5818f09e0/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=29840addd46b6ae01b61ee93247164d5818f09e0", "patch": "@@ -17,6 +17,8 @@ use unstable::raw;\n \n type DropGlue<'a> = 'a |**TyDesc, *c_void|;\n \n+static RC_IMMORTAL : uint = 0x77777777;\n+\n /*\n  * Box annihilation\n  *\n@@ -25,24 +27,21 @@ type DropGlue<'a> = 'a |**TyDesc, *c_void|;\n \n struct AnnihilateStats {\n     n_total_boxes: uint,\n-    n_unique_boxes: uint,\n     n_bytes_freed: uint\n }\n \n unsafe fn each_live_alloc(read_next_before: bool,\n-                          f: |alloc: *mut raw::Box<()>, uniq: bool| -> bool)\n+                          f: |alloc: *mut raw::Box<()>| -> bool)\n                           -> bool {\n     //! Walks the internal list of allocations\n \n-    use managed;\n     use rt::local_heap;\n \n     let mut alloc = local_heap::live_allocs();\n     while alloc != ptr::mut_null() {\n         let next_before = (*alloc).next;\n-        let uniq = (*alloc).ref_count == managed::RC_MANAGED_UNIQUE;\n \n-        if !f(alloc, uniq) {\n+        if !f(alloc) {\n             return false;\n         }\n \n@@ -70,25 +69,19 @@ fn debug_mem() -> bool {\n pub unsafe fn annihilate() {\n     use rt::local_heap::local_free;\n     use mem;\n-    use managed;\n \n     let mut stats = AnnihilateStats {\n         n_total_boxes: 0,\n-        n_unique_boxes: 0,\n         n_bytes_freed: 0\n     };\n \n     // Pass 1: Make all boxes immortal.\n     //\n     // In this pass, nothing gets freed, so it does not matter whether\n     // we read the next field before or after the callback.\n-    each_live_alloc(true, |alloc, uniq| {\n+    each_live_alloc(true, |alloc| {\n         stats.n_total_boxes += 1;\n-        if uniq {\n-            stats.n_unique_boxes += 1;\n-        } else {\n-            (*alloc).ref_count = managed::RC_IMMORTAL;\n-        }\n+        (*alloc).ref_count = RC_IMMORTAL;\n         true\n     });\n \n@@ -97,12 +90,10 @@ pub unsafe fn annihilate() {\n     // In this pass, unique-managed boxes may get freed, but not\n     // managed boxes, so we must read the `next` field *after* the\n     // callback, as the original value may have been freed.\n-    each_live_alloc(false, |alloc, uniq| {\n-        if !uniq {\n-            let tydesc = (*alloc).type_desc;\n-            let data = &(*alloc).data as *();\n-            ((*tydesc).drop_glue)(data as *i8);\n-        }\n+    each_live_alloc(false, |alloc| {\n+        let tydesc = (*alloc).type_desc;\n+        let data = &(*alloc).data as *();\n+        ((*tydesc).drop_glue)(data as *i8);\n         true\n     });\n \n@@ -112,22 +103,19 @@ pub unsafe fn annihilate() {\n     // unique-managed boxes, though I think that none of those are\n     // left), so we must read the `next` field before, since it will\n     // not be valid after.\n-    each_live_alloc(true, |alloc, uniq| {\n-        if !uniq {\n-            stats.n_bytes_freed +=\n-                (*((*alloc).type_desc)).size\n-                + mem::size_of::<raw::Box<()>>();\n-            local_free(alloc as *i8);\n-        }\n+    each_live_alloc(true, |alloc| {\n+        stats.n_bytes_freed +=\n+            (*((*alloc).type_desc)).size\n+            + mem::size_of::<raw::Box<()>>();\n+        local_free(alloc as *i8);\n         true\n     });\n \n     if debug_mem() {\n         // We do logging here w/o allocation.\n         debug!(\"annihilator stats:\\n  \\\n                        total boxes: {}\\n  \\\n-                      unique boxes: {}\\n  \\\n                        bytes freed: {}\",\n-                stats.n_total_boxes, stats.n_unique_boxes, stats.n_bytes_freed);\n+                stats.n_total_boxes, stats.n_bytes_freed);\n     }\n }"}, {"sha": "914cc25250c7f6a5ab087b7d53ce8c430a738541", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29840addd46b6ae01b61ee93247164d5818f09e0/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29840addd46b6ae01b61ee93247164d5818f09e0/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=29840addd46b6ae01b61ee93247164d5818f09e0", "patch": "@@ -14,9 +14,6 @@ use ptr::to_unsafe_ptr;\n \n #[cfg(not(test))] use cmp::*;\n \n-pub static RC_MANAGED_UNIQUE : uint = (-2) as uint;\n-pub static RC_IMMORTAL : uint = 0x77777777;\n-\n /// Returns the refcount of a shared box (as just before calling this)\n #[inline]\n pub fn refcount<T>(t: @T) -> uint {"}]}