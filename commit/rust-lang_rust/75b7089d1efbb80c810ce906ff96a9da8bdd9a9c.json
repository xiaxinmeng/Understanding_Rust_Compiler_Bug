{"sha": "75b7089d1efbb80c810ce906ff96a9da8bdd9a9c", "node_id": "C_kwDOAAsO6NoAKDc1YjcwODlkMWVmYmI4MGM4MTBjZTkwNmZmOTZhOWRhOGJkZDlhOWM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-22T15:04:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-22T15:04:14Z"}, "message": "Rollup merge of #100713 - Xiretza:parser-expr-session-diagnostics, r=estebank\n\nConvert diagnostics in parser/expr to SessionDiagnostic\n\nThis migrates all the easy cases in `rustc_parse::parser::expr` to `SessionDiagnostic`s, I've left things such as `multipart_suggestion`s out for now in the hopes of a derive API being developed soon.", "tree": {"sha": "fbe35f9d2dd20ab744c858c5975f8cd61230dab0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbe35f9d2dd20ab744c858c5975f8cd61230dab0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75b7089d1efbb80c810ce906ff96a9da8bdd9a9c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjA5ruCRBK7hj4Ov3rIwAA3/UIAD35h5l6umbKyycwCFhat11d\ntYyUo21R/255pRzQKuYAtqRcBwg7Plgxt7RNmGiFMF/MXiJf/7sCpSS9DiOChP5S\nWLnpKgqbaZHrNs0gRjfO9SSoxA2+KztzTBTbPVOmmLyXXZ/sngaOFrPoDwA0Y2a1\nFm37PloCDwth6R3KHj/TKDlKH6r8L1bEps8+U+RhYOFeeOUL1HHuM+TJrvflL44V\nO8ldRYq5ZT6Icv9PNFQ03jNyufJlQtmEg6TOcDBpm6HlvqXXjNpRfxuH33ZEloLm\nrNQxwm7QVV5CnrrUN3s/CdNGHfS7t3cGHOxBgt6E3uRDIeaCaNOMoe6gWq9GBiE=\n=+9MT\n-----END PGP SIGNATURE-----\n", "payload": "tree fbe35f9d2dd20ab744c858c5975f8cd61230dab0\nparent 14c8a68e49aee6aaa095f0bfdbe441c20c1a3dd8\nparent ffcaa0dee23f60637b74d389470a1d39cfda28ac\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1661180654 +0530\ncommitter GitHub <noreply@github.com> 1661180654 +0530\n\nRollup merge of #100713 - Xiretza:parser-expr-session-diagnostics, r=estebank\n\nConvert diagnostics in parser/expr to SessionDiagnostic\n\nThis migrates all the easy cases in `rustc_parse::parser::expr` to `SessionDiagnostic`s, I've left things such as `multipart_suggestion`s out for now in the hopes of a derive API being developed soon.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75b7089d1efbb80c810ce906ff96a9da8bdd9a9c", "html_url": "https://github.com/rust-lang/rust/commit/75b7089d1efbb80c810ce906ff96a9da8bdd9a9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75b7089d1efbb80c810ce906ff96a9da8bdd9a9c/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14c8a68e49aee6aaa095f0bfdbe441c20c1a3dd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/14c8a68e49aee6aaa095f0bfdbe441c20c1a3dd8", "html_url": "https://github.com/rust-lang/rust/commit/14c8a68e49aee6aaa095f0bfdbe441c20c1a3dd8"}, {"sha": "ffcaa0dee23f60637b74d389470a1d39cfda28ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffcaa0dee23f60637b74d389470a1d39cfda28ac", "html_url": "https://github.com/rust-lang/rust/commit/ffcaa0dee23f60637b74d389470a1d39cfda28ac"}], "stats": {"total": 878, "additions": 596, "deletions": 282}, "files": [{"sha": "3b37a393846b2abfe58bea09d5d6c719a41f7481", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/75b7089d1efbb80c810ce906ff96a9da8bdd9a9c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/75b7089d1efbb80c810ce906ff96a9da8bdd9a9c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=75b7089d1efbb80c810ce906ff96a9da8bdd9a9c", "patch": "@@ -41,3 +41,112 @@ parser_switch_mut_let_order =\n parser_missing_let_before_mut = missing keyword\n parser_use_let_not_auto = write `let` instead of `auto` to introduce a new variable\n parser_use_let_not_var = write `let` instead of `var` to introduce a new variable\n+\n+parser_invalid_comparison_operator = invalid comparison operator `{$invalid}`\n+    .use_instead = `{$invalid}` is not a valid comparison operator, use `{$correct}`\n+    .spaceship_operator_invalid = `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n+\n+parser_invalid_logical_operator = `{$incorrect}` is not a logical operator\n+    .note = unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n+    .use_amp_amp_for_conjunction = use `&&` to perform logical conjunction\n+    .use_pipe_pipe_for_disjunction = use `||` to perform logical disjunction\n+\n+parser_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n+    .suggestion = use `!` to perform bitwise not\n+\n+parser_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n+    .suggestion = use `!` to perform logical negation\n+\n+parser_malformed_loop_label = malformed loop label\n+    .suggestion = use the correct loop label format\n+\n+parser_lifetime_in_borrow_expression = borrow expressions cannot be annotated with lifetimes\n+    .suggestion = remove the lifetime annotation\n+    .label = annotated with lifetime here\n+\n+parser_field_expression_with_generic = field expressions cannot have generic arguments\n+\n+parser_macro_invocation_with_qualified_path = macros cannot use qualified paths\n+\n+parser_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n+\n+parser_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n+    .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+    .label = the label\n+    .suggestion = add `:` after the label\n+\n+parser_do_catch_syntax_removed = found removed `do catch` syntax\n+    .note = following RFC #2388, the new non-placeholder syntax is `try`\n+    .suggestion = replace with the new syntax\n+\n+parser_float_literal_requires_integer_part = float literals must have an integer part\n+    .suggestion = must have an integer part\n+\n+parser_invalid_int_literal_width = invalid width `{$width}` for integer literal\n+    .help = valid widths are 8, 16, 32, 64 and 128\n+\n+parser_invalid_num_literal_base_prefix = invalid base prefix for number literal\n+    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n+    .suggestion = try making the prefix lowercase\n+\n+parser_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+parser_invalid_float_literal_width = invalid width `{$width}` for float literal\n+    .help = valid widths are 32 and 64\n+\n+parser_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = valid suffixes are `f32` and `f64`\n+\n+parser_int_literal_too_large = integer literal is too large\n+\n+parser_missing_semicolon_before_array = expected `;`, found `[`\n+    .suggestion = consider adding `;` here\n+\n+parser_invalid_block_macro_segment = cannot use a `block` macro fragment here\n+    .label = the `block` fragment is within this context\n+\n+parser_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n+    .add_then_block = add a block here\n+    .condition_possibly_unfinished = this binary operation is possibly unfinished\n+\n+parser_if_expression_missing_condition = missing condition for `if` expression\n+    .condition_label = expected condition here\n+    .block_label = if this block is the condition of the `if` expression, then it must be followed by another block\n+\n+parser_expected_expression_found_let = expected expression, found `let` statement\n+\n+parser_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n+    .label = expected an `if` or a block after this `else`\n+    .suggestion = add an `if` if this is the condition of a chained `else if` statement\n+\n+parser_outer_attribute_not_allowed_on_if_else = outer attributes are not allowed on `if` and `else` branches\n+    .branch_label = the attributes are attached to this branch\n+    .ctx_label = the branch belongs to this `{$ctx}`\n+    .suggestion = remove the attributes\n+\n+parser_missing_in_in_for_loop = missing `in` in `for` loop\n+    .use_in_not_of = try using `in` here instead\n+    .add_in = try adding `in` here\n+\n+parser_missing_comma_after_match_arm = expected `,` following `match` arm\n+    .suggestion = missing a comma here to end this `match` arm\n+\n+parser_catch_after_try = keyword `catch` cannot follow a `try` block\n+    .help = try using `match` on the result of the `try` block instead\n+\n+parser_comma_after_base_struct = cannot use a comma after the base struct\n+    .note = the base struct must always be the last field\n+    .suggestion = remove this comma\n+\n+parser_eq_field_init = expected `:`, found `=`\n+    .suggestion = replace equals symbol with a colon\n+\n+parser_dotdotdot = unexpected token: `...`\n+    .suggest_exclusive_range = use `..` for an exclusive range\n+    .suggest_inclusive_range = or `..=` for an inclusive range\n+\n+parser_left_arrow_operator = unexpected token: `<-`\n+    .suggestion = if you meant to write a comparison against a negative value, add a space in between `<` and `-`"}, {"sha": "2c9f9a2c2c2006f8cb6f03d645e7e2cbe6ebcfc7", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/75b7089d1efbb80c810ce906ff96a9da8bdd9a9c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b7089d1efbb80c810ce906ff96a9da8bdd9a9c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=75b7089d1efbb80c810ce906ff96a9da8bdd9a9c", "patch": "@@ -363,6 +363,349 @@ pub enum InvalidVariableDeclarationSub {\n     UseLetNotVar(#[primary_span] Span),\n }\n \n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_comparison_operator)]\n+pub(crate) struct InvalidComparisonOperator {\n+    #[primary_span]\n+    pub span: Span,\n+    pub invalid: String,\n+    #[subdiagnostic]\n+    pub sub: InvalidComparisonOperatorSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum InvalidComparisonOperatorSub {\n+    #[suggestion_short(\n+        parser::use_instead,\n+        applicability = \"machine-applicable\",\n+        code = \"{correct}\"\n+    )]\n+    Correctable {\n+        #[primary_span]\n+        span: Span,\n+        invalid: String,\n+        correct: String,\n+    },\n+    #[label(parser::spaceship_operator_invalid)]\n+    Spaceship(#[primary_span] Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_logical_operator)]\n+#[note]\n+pub(crate) struct InvalidLogicalOperator {\n+    #[primary_span]\n+    pub span: Span,\n+    pub incorrect: String,\n+    #[subdiagnostic]\n+    pub sub: InvalidLogicalOperatorSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum InvalidLogicalOperatorSub {\n+    #[suggestion_short(\n+        parser::use_amp_amp_for_conjunction,\n+        applicability = \"machine-applicable\",\n+        code = \"&&\"\n+    )]\n+    Conjunction(#[primary_span] Span),\n+    #[suggestion_short(\n+        parser::use_pipe_pipe_for_disjunction,\n+        applicability = \"machine-applicable\",\n+        code = \"||\"\n+    )]\n+    Disjunction(#[primary_span] Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::tilde_is_not_unary_operator)]\n+pub(crate) struct TildeAsUnaryOperator(\n+    #[primary_span]\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"!\")]\n+    pub Span,\n+);\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::unexpected_token_after_not)]\n+pub(crate) struct NotAsNegationOperator {\n+    #[primary_span]\n+    pub negated: Span,\n+    pub negated_desc: String,\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"!\")]\n+    pub not: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::malformed_loop_label)]\n+pub(crate) struct MalformedLoopLabel {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"{correct_label}\")]\n+    pub span: Span,\n+    pub correct_label: Ident,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::lifetime_in_borrow_expression)]\n+pub(crate) struct LifetimeInBorrowExpression {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n+    #[label]\n+    pub lifetime_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::field_expression_with_generic)]\n+pub(crate) struct FieldExpressionWithGeneric(#[primary_span] pub Span);\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::macro_invocation_with_qualified_path)]\n+pub(crate) struct MacroInvocationWithQualifiedPath(#[primary_span] pub Span);\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::unexpected_token_after_label)]\n+pub(crate) struct UnexpectedTokenAfterLabel(\n+    #[primary_span]\n+    #[label(parser::unexpected_token_after_label)]\n+    pub Span,\n+);\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::require_colon_after_labeled_expression)]\n+#[note]\n+pub(crate) struct RequireColonAfterLabeledExpression {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub label: Span,\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \": \")]\n+    pub label_end: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::do_catch_syntax_removed)]\n+#[note]\n+pub(crate) struct DoCatchSyntaxRemoved {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"try\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::float_literal_requires_integer_part)]\n+pub(crate) struct FloatLiteralRequiresIntegerPart {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"{correct}\")]\n+    pub span: Span,\n+    pub correct: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_int_literal_width)]\n+#[help]\n+pub(crate) struct InvalidIntLiteralWidth {\n+    #[primary_span]\n+    pub span: Span,\n+    pub width: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_num_literal_base_prefix)]\n+#[note]\n+pub(crate) struct InvalidNumLiteralBasePrefix {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"{fixed}\")]\n+    pub span: Span,\n+    pub fixed: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_num_literal_suffix)]\n+#[help]\n+pub(crate) struct InvalidNumLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub suffix: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_float_literal_width)]\n+#[help]\n+pub(crate) struct InvalidFloatLiteralWidth {\n+    #[primary_span]\n+    pub span: Span,\n+    pub width: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_float_literal_suffix)]\n+#[help]\n+pub(crate) struct InvalidFloatLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub suffix: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::int_literal_too_large)]\n+pub(crate) struct IntLiteralTooLarge {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::missing_semicolon_before_array)]\n+pub(crate) struct MissingSemicolonBeforeArray {\n+    #[primary_span]\n+    pub open_delim: Span,\n+    #[suggestion_verbose(applicability = \"maybe-incorrect\", code = \";\")]\n+    pub semicolon: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_block_macro_segment)]\n+pub(crate) struct InvalidBlockMacroSegment {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub context: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::if_expression_missing_then_block)]\n+pub(crate) struct IfExpressionMissingThenBlock {\n+    #[primary_span]\n+    pub if_span: Span,\n+    #[subdiagnostic]\n+    pub sub: IfExpressionMissingThenBlockSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum IfExpressionMissingThenBlockSub {\n+    #[help(parser::condition_possibly_unfinished)]\n+    UnfinishedCondition(#[primary_span] Span),\n+    #[help(parser::add_then_block)]\n+    AddThenBlock(#[primary_span] Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::if_expression_missing_condition)]\n+pub(crate) struct IfExpressionMissingCondition {\n+    #[primary_span]\n+    #[label(parser::condition_label)]\n+    pub if_span: Span,\n+    #[label(parser::block_label)]\n+    pub block_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::expected_expression_found_let)]\n+pub(crate) struct ExpectedExpressionFoundLet {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::expected_else_block)]\n+pub(crate) struct ExpectedElseBlock {\n+    #[primary_span]\n+    pub first_tok_span: Span,\n+    pub first_tok: String,\n+    #[label]\n+    pub else_span: Span,\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"if \")]\n+    pub condition_start: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::outer_attribute_not_allowed_on_if_else)]\n+pub(crate) struct OuterAttributeNotAllowedOnIfElse {\n+    #[primary_span]\n+    pub last: Span,\n+\n+    #[label(parser::branch_label)]\n+    pub branch_span: Span,\n+\n+    #[label(parser::ctx_label)]\n+    pub ctx_span: Span,\n+    pub ctx: String,\n+\n+    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n+    pub attributes: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::missing_in_in_for_loop)]\n+pub(crate) struct MissingInInForLoop {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: MissingInInForLoopSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum MissingInInForLoopSub {\n+    // Has been misleading, at least in the past (closed Issue #48492), thus maybe-incorrect\n+    #[suggestion_short(parser::use_in_not_of, applicability = \"maybe-incorrect\", code = \"in\")]\n+    InNotOf(#[primary_span] Span),\n+    #[suggestion_short(parser::add_in, applicability = \"maybe-incorrect\", code = \" in \")]\n+    AddIn(#[primary_span] Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::missing_comma_after_match_arm)]\n+pub(crate) struct MissingCommaAfterMatchArm {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \",\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::catch_after_try)]\n+#[help]\n+pub(crate) struct CatchAfterTry {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::comma_after_base_struct)]\n+#[note]\n+pub(crate) struct CommaAfterBaseStruct {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n+    pub comma: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::eq_field_init)]\n+pub(crate) struct EqFieldInit {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(applicability = \"machine-applicable\", code = \":\")]\n+    pub eq: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::dotdotdot)]\n+pub(crate) struct DotDotDot {\n+    #[primary_span]\n+    #[suggestion(parser::suggest_exclusive_range, applicability = \"maybe-incorrect\", code = \"..\")]\n+    #[suggestion(parser::suggest_inclusive_range, applicability = \"maybe-incorrect\", code = \"..=\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::left_arrow_operator)]\n+pub(crate) struct LeftArrowOperator {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"< -\")]\n+    pub span: Span,\n+}\n+\n // SnapshotParser is used to create a snapshot of the parser\n // without causing duplicate errors being emitted when the `Parser`\n // is dropped."}, {"sha": "17117cbc8fbe6682e71b47a2274ce0cf1588db14", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 144, "deletions": 282, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/75b7089d1efbb80c810ce906ff96a9da8bdd9a9c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b7089d1efbb80c810ce906ff96a9da8bdd9a9c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=75b7089d1efbb80c810ce906ff96a9da8bdd9a9c", "patch": "@@ -1,11 +1,26 @@\n-use super::diagnostics::SnapshotParser;\n+use super::diagnostics::{\n+    CatchAfterTry, CommaAfterBaseStruct, DoCatchSyntaxRemoved, DotDotDot, EqFieldInit,\n+    ExpectedElseBlock, ExpectedExpressionFoundLet, FieldExpressionWithGeneric,\n+    FloatLiteralRequiresIntegerPart, IfExpressionMissingCondition, IfExpressionMissingThenBlock,\n+    IfExpressionMissingThenBlockSub, InvalidBlockMacroSegment, InvalidComparisonOperator,\n+    InvalidComparisonOperatorSub, InvalidLogicalOperator, InvalidLogicalOperatorSub,\n+    LeftArrowOperator, LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath,\n+    MalformedLoopLabel, MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray,\n+    NotAsNegationOperator, OuterAttributeNotAllowedOnIfElse, RequireColonAfterLabeledExpression,\n+    SnapshotParser, TildeAsUnaryOperator, UnexpectedTokenAfterLabel,\n+};\n use super::pat::{CommaRecoveryMode, RecoverColon, RecoverComma, PARAM_EXPECTED};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{\n     AttrWrapper, BlockMode, ClosureSpans, ForceCollect, Parser, PathStyle, Restrictions,\n     SemiColonMode, SeqSep, TokenExpectType, TokenType, TrailingToken,\n };\n use crate::maybe_recover_from_interpolated_ty_qpath;\n+use crate::parser::diagnostics::{\n+    IntLiteralTooLarge, InvalidFloatLiteralSuffix, InvalidFloatLiteralWidth,\n+    InvalidIntLiteralWidth, InvalidNumLiteralBasePrefix, InvalidNumLiteralSuffix,\n+    MissingCommaAfterMatchArm,\n+};\n \n use core::mem;\n use rustc_ast::ptr::P;\n@@ -20,9 +35,10 @@ use rustc_ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty\n use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n use rustc_ast::{ClosureBinder, StmtKind};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, PResult};\n+use rustc_errors::{Applicability, Diagnostic, PResult};\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_session::SessionDiagnostic;\n use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Pos};\n@@ -216,15 +232,18 @@ impl<'a> Parser<'a> {\n                     AssocOp::Equal => \"==\",\n                     AssocOp::NotEqual => \"!=\",\n                     _ => unreachable!(),\n-                };\n-                self.struct_span_err(sp, &format!(\"invalid comparison operator `{sugg}=`\"))\n-                    .span_suggestion_short(\n-                        sp,\n-                        &format!(\"`{s}=` is not a valid comparison operator, use `{s}`\", s = sugg),\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                }\n+                .into();\n+                let invalid = format!(\"{}=\", &sugg);\n+                self.sess.emit_err(InvalidComparisonOperator {\n+                    span: sp,\n+                    invalid: invalid.clone(),\n+                    sub: InvalidComparisonOperatorSub::Correctable {\n+                        span: sp,\n+                        invalid,\n+                        correct: sugg,\n+                    },\n+                });\n                 self.bump();\n             }\n \n@@ -234,14 +253,15 @@ impl<'a> Parser<'a> {\n                 && self.prev_token.span.hi() == self.token.span.lo()\n             {\n                 let sp = op.span.to(self.token.span);\n-                self.struct_span_err(sp, \"invalid comparison operator `<>`\")\n-                    .span_suggestion_short(\n-                        sp,\n-                        \"`<>` is not a valid comparison operator, use `!=`\",\n-                        \"!=\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.sess.emit_err(InvalidComparisonOperator {\n+                    span: sp,\n+                    invalid: \"<>\".into(),\n+                    sub: InvalidComparisonOperatorSub::Correctable {\n+                        span: sp,\n+                        invalid: \"<>\".into(),\n+                        correct: \"!=\".into(),\n+                    },\n+                });\n                 self.bump();\n             }\n \n@@ -251,12 +271,11 @@ impl<'a> Parser<'a> {\n                 && self.prev_token.span.hi() == self.token.span.lo()\n             {\n                 let sp = op.span.to(self.token.span);\n-                self.struct_span_err(sp, \"invalid comparison operator `<=>`\")\n-                    .span_label(\n-                        sp,\n-                        \"`<=>` is not a valid comparison operator, use `std::cmp::Ordering`\",\n-                    )\n-                    .emit();\n+                self.sess.emit_err(InvalidComparisonOperator {\n+                    span: sp,\n+                    invalid: \"<=>\".into(),\n+                    sub: InvalidComparisonOperatorSub::Spaceship(sp),\n+                });\n                 self.bump();\n             }\n \n@@ -430,31 +449,26 @@ impl<'a> Parser<'a> {\n             }\n             (Some(op), _) => (op, self.token.span),\n             (None, Some((Ident { name: sym::and, span }, false))) => {\n-                self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n+                self.sess.emit_err(InvalidLogicalOperator {\n+                    span: self.token.span,\n+                    incorrect: \"and\".into(),\n+                    sub: InvalidLogicalOperatorSub::Conjunction(self.token.span),\n+                });\n                 (AssocOp::LAnd, span)\n             }\n             (None, Some((Ident { name: sym::or, span }, false))) => {\n-                self.error_bad_logical_op(\"or\", \"||\", \"disjunction\");\n+                self.sess.emit_err(InvalidLogicalOperator {\n+                    span: self.token.span,\n+                    incorrect: \"or\".into(),\n+                    sub: InvalidLogicalOperatorSub::Disjunction(self.token.span),\n+                });\n                 (AssocOp::LOr, span)\n             }\n             _ => return None,\n         };\n         Some(source_map::respan(span, op))\n     }\n \n-    /// Error on `and` and `or` suggesting `&&` and `||` respectively.\n-    fn error_bad_logical_op(&self, bad: &str, good: &str, english: &str) {\n-        self.struct_span_err(self.token.span, &format!(\"`{bad}` is not a logical operator\"))\n-            .span_suggestion_short(\n-                self.token.span,\n-                &format!(\"use `{good}` to perform logical {english}\"),\n-                good,\n-                Applicability::MachineApplicable,\n-            )\n-            .note(\"unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\")\n-            .emit();\n-    }\n-\n     /// Checks if this expression is a successfully parsed statement.\n     fn expr_is_complete(&self, e: &Expr) -> bool {\n         self.restrictions.contains(Restrictions::STMT_EXPR)\n@@ -619,14 +633,7 @@ impl<'a> Parser<'a> {\n \n     // Recover on `!` suggesting for bitwise negation instead.\n     fn recover_tilde_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n-        self.struct_span_err(lo, \"`~` cannot be used as a unary operator\")\n-            .span_suggestion_short(\n-                lo,\n-                \"use `!` to perform bitwise not\",\n-                \"!\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(TildeAsUnaryOperator(lo));\n \n         self.parse_unary_expr(lo, UnOp::Not)\n     }\n@@ -652,20 +659,14 @@ impl<'a> Parser<'a> {\n     /// Recover on `not expr` in favor of `!expr`.\n     fn recover_not_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         // Emit the error...\n-        let not_token = self.look_ahead(1, |t| t.clone());\n-        self.struct_span_err(\n-            not_token.span,\n-            &format!(\"unexpected {} after identifier\", super::token_descr(&not_token)),\n-        )\n-        .span_suggestion_short(\n+        let negated_token = self.look_ahead(1, |t| t.clone());\n+        self.sess.emit_err(NotAsNegationOperator {\n+            negated: negated_token.span,\n+            negated_desc: super::token_descr(&negated_token),\n             // Span the `not` plus trailing whitespace to avoid\n             // trailing whitespace after the `!` in our suggestion\n-            self.sess.source_map().span_until_non_whitespace(lo.to(not_token.span)),\n-            \"use `!` to perform logical negation\",\n-            \"!\",\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+            not: self.sess.source_map().span_until_non_whitespace(lo.to(negated_token.span)),\n+        });\n \n         // ...and recover!\n         self.parse_unary_expr(lo, UnOp::Not)\n@@ -725,14 +726,10 @@ impl<'a> Parser<'a> {\n                         match self.parse_labeled_expr(label, false) {\n                             Ok(expr) => {\n                                 type_err.cancel();\n-                                self.struct_span_err(label.ident.span, \"malformed loop label\")\n-                                    .span_suggestion(\n-                                        label.ident.span,\n-                                        \"use the correct loop label format\",\n-                                        label.ident,\n-                                        Applicability::MachineApplicable,\n-                                    )\n-                                    .emit();\n+                                self.sess.emit_err(MalformedLoopLabel {\n+                                    span: label.ident.span,\n+                                    correct_label: label.ident,\n+                                });\n                                 return Ok(expr);\n                             }\n                             Err(err) => {\n@@ -910,15 +907,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_remove_borrow_lifetime(&self, span: Span, lt_span: Span) {\n-        self.struct_span_err(span, \"borrow expressions cannot be annotated with lifetimes\")\n-            .span_label(lt_span, \"annotated with lifetime here\")\n-            .span_suggestion(\n-                lt_span,\n-                \"remove the lifetime annotation\",\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(LifetimeInBorrowExpression { span, lifetime_span: lt_span });\n     }\n \n     /// Parse `mut?` or `raw [ const | mut ]`.\n@@ -1272,11 +1261,7 @@ impl<'a> Parser<'a> {\n         } else {\n             // Field access `expr.f`\n             if let Some(args) = segment.args {\n-                self.struct_span_err(\n-                    args.span(),\n-                    \"field expressions cannot have generic arguments\",\n-                )\n-                .emit();\n+                self.sess.emit_err(FieldExpressionWithGeneric(args.span()));\n             }\n \n             let span = lo.to(self.prev_token.span);\n@@ -1489,7 +1474,7 @@ impl<'a> Parser<'a> {\n         let (span, kind) = if self.eat(&token::Not) {\n             // MACRO INVOCATION expression\n             if qself.is_some() {\n-                self.struct_span_err(path.span, \"macros cannot use qualified paths\").emit();\n+                self.sess.emit_err(MacroInvocationWithQualifiedPath(path.span));\n             }\n             let lo = path.span;\n             let mac = P(MacCall {\n@@ -1535,11 +1520,11 @@ impl<'a> Parser<'a> {\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n             // We're probably inside of a `Path<'a>` that needs a turbofish\n-            let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n-            self.struct_span_err(self.token.span, msg).span_label(self.token.span, msg).emit();\n+            self.sess.emit_err(UnexpectedTokenAfterLabel(self.token.span));\n             consume_colon = false;\n             Ok(self.mk_expr_err(lo))\n         } else {\n+            // FIXME: use UnexpectedTokenAfterLabel, needs multipart suggestions\n             let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n \n             let mut err = self.struct_span_err(self.token.span, msg);\n@@ -1604,42 +1589,25 @@ impl<'a> Parser<'a> {\n         }?;\n \n         if !ate_colon && consume_colon {\n-            self.error_labeled_expr_must_be_followed_by_colon(lo, expr.span);\n+            self.sess.emit_err(RequireColonAfterLabeledExpression {\n+                span: expr.span,\n+                label: lo,\n+                label_end: lo.shrink_to_hi(),\n+            });\n         }\n \n         Ok(expr)\n     }\n \n-    fn error_labeled_expr_must_be_followed_by_colon(&self, lo: Span, span: Span) {\n-        self.struct_span_err(span, \"labeled expression must be followed by `:`\")\n-            .span_label(lo, \"the label\")\n-            .span_suggestion_short(\n-                lo.shrink_to_hi(),\n-                \"add `:` after the label\",\n-                \": \",\n-                Applicability::MachineApplicable,\n-            )\n-            .note(\"labels are used before loops and blocks, allowing e.g., `break 'label` to them\")\n-            .emit();\n-    }\n-\n     /// Recover on the syntax `do catch { ... }` suggesting `try { ... }` instead.\n     fn recover_do_catch(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         self.bump(); // `do`\n         self.bump(); // `catch`\n \n-        let span_dc = lo.to(self.prev_token.span);\n-        self.struct_span_err(span_dc, \"found removed `do catch` syntax\")\n-            .span_suggestion(\n-                span_dc,\n-                \"replace with the new syntax\",\n-                \"try\",\n-                Applicability::MachineApplicable,\n-            )\n-            .note(\"following RFC #2388, the new non-placeholder syntax is `try`\")\n-            .emit();\n+        let span = lo.to(self.prev_token.span);\n+        self.sess.emit_err(DoCatchSyntaxRemoved { span });\n \n         self.parse_try_block(lo)\n     }\n@@ -1834,14 +1802,10 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_float_lits_must_have_int_part(&self, token: &Token) {\n-        self.struct_span_err(token.span, \"float literals must have an integer part\")\n-            .span_suggestion(\n-                token.span,\n-                \"must have an integer part\",\n-                pprust::token_to_string(token),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(FloatLiteralRequiresIntegerPart {\n+            span: token.span,\n+            correct: pprust::token_to_string(token).into_owned(),\n+        });\n     }\n \n     fn report_lit_error(&self, err: LitError, lit: token::Lit, span: Span) {\n@@ -1883,43 +1847,22 @@ impl<'a> Parser<'a> {\n                 let suf = suf.as_str();\n                 if looks_like_width_suffix(&['i', 'u'], &suf) {\n                     // If it looks like a width, try to be helpful.\n-                    let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n-                    self.struct_span_err(span, &msg)\n-                        .help(\"valid widths are 8, 16, 32, 64 and 128\")\n-                        .emit();\n+                    self.sess.emit_err(InvalidIntLiteralWidth { span, width: suf[1..].into() });\n                 } else if let Some(fixed) = fix_base_capitalisation(suf) {\n-                    let msg = \"invalid base prefix for number literal\";\n-\n-                    self.struct_span_err(span, msg)\n-                        .note(\"base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\")\n-                        .span_suggestion(\n-                            span,\n-                            \"try making the prefix lowercase\",\n-                            fixed,\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    self.sess.emit_err(InvalidNumLiteralBasePrefix { span, fixed });\n                 } else {\n-                    let msg = format!(\"invalid suffix `{suf}` for number literal\");\n-                    self.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{suf}`\"))\n-                        .help(\"the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\")\n-                        .emit();\n+                    self.sess.emit_err(InvalidNumLiteralSuffix { span, suffix: suf.to_string() });\n                 }\n             }\n             LitError::InvalidFloatSuffix => {\n                 let suf = suffix.expect(\"suffix error with no suffix\");\n                 let suf = suf.as_str();\n                 if looks_like_width_suffix(&['f'], suf) {\n                     // If it looks like a width, try to be helpful.\n-                    let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n-                    self.struct_span_err(span, &msg).help(\"valid widths are 32 and 64\").emit();\n+                    self.sess\n+                        .emit_err(InvalidFloatLiteralWidth { span, width: suf[1..].to_string() });\n                 } else {\n-                    let msg = format!(\"invalid suffix `{suf}` for float literal\");\n-                    self.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{suf}`\"))\n-                        .help(\"valid suffixes are `f32` and `f64`\")\n-                        .emit();\n+                    self.sess.emit_err(InvalidFloatLiteralSuffix { span, suffix: suf.to_string() });\n                 }\n             }\n             LitError::NonDecimalFloat(base) => {\n@@ -1934,7 +1877,7 @@ impl<'a> Parser<'a> {\n                     .emit();\n             }\n             LitError::IntTooLarge => {\n-                self.struct_span_err(span, \"integer literal is too large\").emit();\n+                self.sess.emit_err(IntLiteralTooLarge { span });\n             }\n         }\n     }\n@@ -2046,14 +1989,10 @@ impl<'a> Parser<'a> {\n                         .span_to_snippet(snapshot.token.span)\n                         .map_or(false, |snippet| snippet == \"]\") =>\n                 {\n-                    let mut err = self.struct_span_err(open_delim_span, \"expected `;`, found `[`\");\n-                    err.span_suggestion_verbose(\n-                        prev_span.shrink_to_hi(),\n-                        \"consider adding `;` here\",\n-                        ';',\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    return Err(err);\n+                    return Err(MissingSemicolonBeforeArray {\n+                        open_delim: open_delim_span,\n+                        semicolon: prev_span.shrink_to_hi(),\n+                    }.into_diagnostic(self.sess));\n                 }\n                 Ok(_) => (),\n                 Err(err) => err.cancel(),\n@@ -2080,9 +2019,10 @@ impl<'a> Parser<'a> {\n         }\n \n         if self.token.is_whole_block() {\n-            self.struct_span_err(self.token.span, \"cannot use a `block` macro fragment here\")\n-                .span_label(lo.to(self.token.span), \"the `block` fragment is within this context\")\n-                .emit();\n+            self.sess.emit_err(InvalidBlockMacroSegment {\n+                span: self.token.span,\n+                context: lo.to(self.token.span),\n+            });\n         }\n \n         let (attrs, blk) = self.parse_block_common(lo, blk_mode)?;\n@@ -2252,11 +2192,19 @@ impl<'a> Parser<'a> {\n             let block = match &mut cond.kind {\n                 ExprKind::Binary(Spanned { span: binop_span, .. }, _, right)\n                     if let ExprKind::Block(_, None) = right.kind => {\n-                        this.error_missing_if_then_block(lo, cond_span.shrink_to_lo().to(*binop_span), true).emit();\n+                        self.sess.emit_err(IfExpressionMissingThenBlock {\n+                            if_span: lo,\n+                            sub: IfExpressionMissingThenBlockSub::UnfinishedCondition(\n+                                cond_span.shrink_to_lo().to(*binop_span)\n+                            ),\n+                        });\n                         std::mem::replace(right, this.mk_expr_err(binop_span.shrink_to_hi()))\n                     },\n                 ExprKind::Block(_, None) => {\n-                    this.error_missing_if_cond(lo, cond_span).emit();\n+                    self.sess.emit_err(IfExpressionMissingCondition {\n+                        if_span: self.sess.source_map().next_point(lo),\n+                        block_span: self.sess.source_map().start_point(cond_span),\n+                    });\n                     std::mem::replace(&mut cond, this.mk_expr_err(cond_span.shrink_to_hi()))\n                 }\n                 _ => {\n@@ -2274,7 +2222,10 @@ impl<'a> Parser<'a> {\n             if let Some(block) = recover_block_from_condition(self) {\n                 block\n             } else {\n-                self.error_missing_if_then_block(lo, cond_span, false).emit();\n+                self.sess.emit_err(IfExpressionMissingThenBlock {\n+                    if_span: lo,\n+                    sub: IfExpressionMissingThenBlockSub::AddThenBlock(cond_span.shrink_to_hi()),\n+                });\n                 self.mk_block_err(cond_span.shrink_to_hi())\n             }\n         } else {\n@@ -2302,39 +2253,6 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els)))\n     }\n \n-    fn error_missing_if_then_block(\n-        &self,\n-        if_span: Span,\n-        cond_span: Span,\n-        is_unfinished: bool,\n-    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let mut err = self.struct_span_err(\n-            if_span,\n-            \"this `if` expression is missing a block after the condition\",\n-        );\n-        if is_unfinished {\n-            err.span_help(cond_span, \"this binary operation is possibly unfinished\");\n-        } else {\n-            err.span_help(cond_span.shrink_to_hi(), \"add a block here\");\n-        }\n-        err\n-    }\n-\n-    fn error_missing_if_cond(\n-        &self,\n-        lo: Span,\n-        span: Span,\n-    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let next_span = self.sess.source_map().next_point(lo);\n-        let mut err = self.struct_span_err(next_span, \"missing condition for `if` expression\");\n-        err.span_label(next_span, \"expected condition here\");\n-        err.span_label(\n-            self.sess.source_map().start_point(span),\n-            \"if this block is the condition of the `if` expression, then it must be followed by another block\"\n-        );\n-        err\n-    }\n-\n     /// Parses the condition of a `if` or `while` expression.\n     fn parse_cond_expr(&mut self) -> PResult<'a, P<Expr>> {\n         self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL | Restrictions::ALLOW_LET, None)\n@@ -2350,8 +2268,7 @@ impl<'a> Parser<'a> {\n             TokenKind::AndAnd | TokenKind::Ident(kw::If, _) | TokenKind::Ident(kw::While, _)\n         );\n         if !self.restrictions.contains(Restrictions::ALLOW_LET) || not_in_chain {\n-            self.struct_span_err(self.token.span, \"expected expression, found `let` statement\")\n-                .emit();\n+            self.sess.emit_err(ExpectedExpressionFoundLet { span: self.token.span });\n         }\n \n         self.bump(); // Eat `let` token\n@@ -2389,15 +2306,12 @@ impl<'a> Parser<'a> {\n                     if self.check(&TokenKind::OpenDelim(Delimiter::Brace))\n                         && classify::expr_requires_semi_to_be_stmt(&cond) =>\n                 {\n-                    self.struct_span_err(first_tok_span, format!(\"expected `{{`, found {first_tok}\"))\n-                        .span_label(else_span, \"expected an `if` or a block after this `else`\")\n-                        .span_suggestion(\n-                            cond.span.shrink_to_lo(),\n-                            \"add an `if` if this is the condition of a chained `else if` statement\",\n-                            \"if \",\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    self.sess.emit_err(ExpectedElseBlock {\n+                        first_tok_span,\n+                        first_tok,\n+                        else_span,\n+                        condition_start: cond.span.shrink_to_lo(),\n+                    });\n                     self.parse_if_after_cond(cond.span.shrink_to_lo(), cond)?\n                 }\n                 Err(e) => {\n@@ -2422,16 +2336,18 @@ impl<'a> Parser<'a> {\n         branch_span: Span,\n         attrs: &[ast::Attribute],\n     ) {\n-        let (span, last) = match attrs {\n+        let (attributes, last) = match attrs {\n             [] => return,\n             [x0 @ xn] | [x0, .., xn] => (x0.span.to(xn.span), xn.span),\n         };\n         let ctx = if is_ctx_else { \"else\" } else { \"if\" };\n-        self.struct_span_err(last, \"outer attributes are not allowed on `if` and `else` branches\")\n-            .span_label(branch_span, \"the attributes are attached to this branch\")\n-            .span_label(ctx_span, format!(\"the branch belongs to this `{ctx}`\"))\n-            .span_suggestion(span, \"remove the attributes\", \"\", Applicability::MachineApplicable)\n-            .emit();\n+        self.sess.emit_err(OuterAttributeNotAllowedOnIfElse {\n+            last,\n+            branch_span,\n+            ctx_span,\n+            ctx: ctx.to_string(),\n+            attributes,\n+        });\n     }\n \n     /// Parses `for <src_pat> in <src_expr> <src_loop_block>` (`for` token already eaten).\n@@ -2465,23 +2381,16 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_missing_in_for_loop(&mut self) {\n-        let (span, msg, sugg) = if self.token.is_ident_named(sym::of) {\n+        let (span, sub): (_, fn(_) -> _) = if self.token.is_ident_named(sym::of) {\n             // Possibly using JS syntax (#75311).\n             let span = self.token.span;\n             self.bump();\n-            (span, \"try using `in` here instead\", \"in\")\n+            (span, MissingInInForLoopSub::InNotOf)\n         } else {\n-            (self.prev_token.span.between(self.token.span), \"try adding `in` here\", \" in \")\n+            (self.prev_token.span.between(self.token.span), MissingInInForLoopSub::AddIn)\n         };\n-        self.struct_span_err(span, \"missing `in` in `for` loop\")\n-            .span_suggestion_short(\n-                span,\n-                msg,\n-                sugg,\n-                // Has been misleading, at least in the past (closed Issue #48492).\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+\n+        self.sess.emit_err(MissingInInForLoop { span, sub: sub(span) });\n     }\n \n     /// Parses a `while` or `while let` expression (`while` token already eaten).\n@@ -2787,17 +2696,9 @@ impl<'a> Parser<'a> {\n                                 .is_ok();\n                             if pattern_follows && snapshot.check(&TokenKind::FatArrow) {\n                                 err.cancel();\n-                                this.struct_span_err(\n-                                    hi.shrink_to_hi(),\n-                                    \"expected `,` following `match` arm\",\n-                                )\n-                                .span_suggestion(\n-                                    hi.shrink_to_hi(),\n-                                    \"missing a comma here to end this `match` arm\",\n-                                    \",\",\n-                                    Applicability::MachineApplicable,\n-                                )\n-                                .emit();\n+                                this.sess.emit_err(MissingCommaAfterMatchArm {\n+                                    span: hi.shrink_to_hi(),\n+                                });\n                                 return Ok(true);\n                             }\n                         }\n@@ -2827,13 +2728,7 @@ impl<'a> Parser<'a> {\n     fn parse_try_block(&mut self, span_lo: Span) -> PResult<'a, P<Expr>> {\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         if self.eat_keyword(kw::Catch) {\n-            let mut error = self.struct_span_err(\n-                self.prev_token.span,\n-                \"keyword `catch` cannot follow a `try` block\",\n-            );\n-            error.help(\"try using `match` on the result of the `try` block instead\");\n-            error.emit();\n-            Err(error)\n+            Err(CatchAfterTry { span: self.prev_token.span }.into_diagnostic(self.sess))\n         } else {\n             let span = span_lo.to(body.span);\n             self.sess.gated_spans.gate(sym::try_blocks, span);\n@@ -3082,18 +2977,10 @@ impl<'a> Parser<'a> {\n         if self.token != token::Comma {\n             return;\n         }\n-        self.struct_span_err(\n-            span.to(self.prev_token.span),\n-            \"cannot use a comma after the base struct\",\n-        )\n-        .span_suggestion_short(\n-            self.token.span,\n-            \"remove this comma\",\n-            \"\",\n-            Applicability::MachineApplicable,\n-        )\n-        .note(\"the base struct must always be the last field\")\n-        .emit();\n+        self.sess.emit_err(CommaAfterBaseStruct {\n+            span: span.to(self.prev_token.span),\n+            comma: self.token.span,\n+        });\n         self.recover_stmt();\n     }\n \n@@ -3139,43 +3026,18 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        self.struct_span_err(self.token.span, \"expected `:`, found `=`\")\n-            .span_suggestion(\n-                field_name.span.shrink_to_hi().to(self.token.span),\n-                \"replace equals symbol with a colon\",\n-                \":\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(EqFieldInit {\n+            span: self.token.span,\n+            eq: field_name.span.shrink_to_hi().to(self.token.span),\n+        });\n     }\n \n     fn err_dotdotdot_syntax(&self, span: Span) {\n-        self.struct_span_err(span, \"unexpected token: `...`\")\n-            .span_suggestion(\n-                span,\n-                \"use `..` for an exclusive range\",\n-                \"..\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .span_suggestion(\n-                span,\n-                \"or `..=` for an inclusive range\",\n-                \"..=\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+        self.sess.emit_err(DotDotDot { span });\n     }\n \n     fn err_larrow_operator(&self, span: Span) {\n-        self.struct_span_err(span, \"unexpected token: `<-`\")\n-            .span_suggestion(\n-                span,\n-                \"if you meant to write a comparison against a negative value, add a \\\n-             space in between `<` and `-`\",\n-                \"< -\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+        self.sess.emit_err(LeftArrowOperator { span });\n     }\n \n     fn mk_assign_op(&self, binop: BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ExprKind {"}]}