{"sha": "f97a8f017d5ccb6ec73e4450bce35f82e03b1b41", "node_id": "C_kwDOAAsO6NoAKGY5N2E4ZjAxN2Q1Y2NiNmVjNzNlNDQ1MGJjZTM1ZjgyZTAzYjFiNDE", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-02-20T16:48:59Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-02-20T17:00:57Z"}, "message": "small `opaque_type_origin` cleanup", "tree": {"sha": "9af71355eb05f419f8746c7e887b63400aa7634b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9af71355eb05f419f8746c7e887b63400aa7634b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f97a8f017d5ccb6ec73e4450bce35f82e03b1b41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f97a8f017d5ccb6ec73e4450bce35f82e03b1b41", "html_url": "https://github.com/rust-lang/rust/commit/f97a8f017d5ccb6ec73e4450bce35f82e03b1b41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f97a8f017d5ccb6ec73e4450bce35f82e03b1b41/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "267cd1d2c5abf5f0d825822a4179ba807b69ffb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/267cd1d2c5abf5f0d825822a4179ba807b69ffb4", "html_url": "https://github.com/rust-lang/rust/commit/267cd1d2c5abf5f0d825822a4179ba807b69ffb4"}], "stats": {"total": 44, "additions": 18, "deletions": 26}, "files": [{"sha": "b2f3a3abb4c50ca76bfa6abbf1916a3e8fececd5", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f97a8f017d5ccb6ec73e4450bce35f82e03b1b41/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97a8f017d5ccb6ec73e4450bce35f82e03b1b41/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=f97a8f017d5ccb6ec73e4450bce35f82e03b1b41", "patch": "@@ -32,7 +32,7 @@ use rustc_session::lint;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, NormalizeExt, ObligationCauseCode, ObligationCtxt};\n \n@@ -737,7 +737,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let ty::subst::GenericArgKind::Type(ty) = ty.unpack()\n                     && let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *ty.kind()\n                     && let Some(def_id) = def_id.as_local()\n-                    && self.opaque_type_origin(def_id, DUMMY_SP).is_some() {\n+                    && self.opaque_type_origin(def_id).is_some() {\n                     return None;\n                 }\n             }"}, {"sha": "e783443502b865357a8007730bbf82ae8366c095", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f97a8f017d5ccb6ec73e4450bce35f82e03b1b41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97a8f017d5ccb6ec73e4450bce35f82e03b1b41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=f97a8f017d5ccb6ec73e4450bce35f82e03b1b41", "patch": "@@ -57,9 +57,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n         let mut obligations = vec![];\n         let replace_opaque_type = |def_id: DefId| {\n-            def_id\n-                .as_local()\n-                .map_or(false, |def_id| self.opaque_type_origin(def_id, span).is_some())\n+            def_id.as_local().map_or(false, |def_id| self.opaque_type_origin(def_id).is_some())\n         };\n         let value = value.fold_with(&mut BottomUpFolder {\n             tcx: self.tcx,\n@@ -144,9 +142,9 @@ impl<'tcx> InferCtxt<'tcx> {\n                         //     let x = || foo(); // returns the Opaque assoc with `foo`\n                         // }\n                         // ```\n-                        self.opaque_type_origin(def_id, cause.span)?\n+                        self.opaque_type_origin(def_id)?\n                     }\n-                    DefiningAnchor::Bubble => self.opaque_ty_origin_unchecked(def_id, cause.span),\n+                    DefiningAnchor::Bubble => self.opaque_type_origin_unchecked(def_id),\n                     DefiningAnchor::Error => return None,\n                 };\n                 if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }) = *b.kind() {\n@@ -155,9 +153,8 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // no one encounters it in practice.\n                     // It does occur however in `fn fut() -> impl Future<Output = i32> { async { 42 } }`,\n                     // where it is of no concern, so we only check for TAITs.\n-                    if let Some(OpaqueTyOrigin::TyAlias) = b_def_id\n-                        .as_local()\n-                        .and_then(|b_def_id| self.opaque_type_origin(b_def_id, cause.span))\n+                    if let Some(OpaqueTyOrigin::TyAlias) =\n+                        b_def_id.as_local().and_then(|b_def_id| self.opaque_type_origin(b_def_id))\n                     {\n                         self.tcx.sess.emit_err(OpaqueHiddenTypeDiag {\n                             span: cause.span,\n@@ -371,24 +368,18 @@ impl<'tcx> InferCtxt<'tcx> {\n         });\n     }\n \n+    /// Returns the origin of the opaque type `def_id` if we're currently\n+    /// in its defining scope.\n     #[instrument(skip(self), level = \"trace\", ret)]\n-    pub fn opaque_type_origin(&self, def_id: LocalDefId, span: Span) -> Option<OpaqueTyOrigin> {\n+    pub fn opaque_type_origin(&self, def_id: LocalDefId) -> Option<OpaqueTyOrigin> {\n         let opaque_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let parent_def_id = match self.defining_use_anchor {\n             DefiningAnchor::Bubble | DefiningAnchor::Error => return None,\n             DefiningAnchor::Bind(bind) => bind,\n         };\n-        let item_kind = &self.tcx.hir().expect_item(def_id).kind;\n-\n-        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item_kind else {\n-            span_bug!(\n-                span,\n-                \"weird opaque type: {:#?}, {:#?}\",\n-                def_id,\n-                item_kind\n-            )\n-        };\n-        let in_definition_scope = match *origin {\n+\n+        let origin = self.opaque_type_origin_unchecked(def_id);\n+        let in_definition_scope = match origin {\n             // Async `impl Trait`\n             hir::OpaqueTyOrigin::AsyncFn(parent) => parent == parent_def_id,\n             // Anonymous `impl Trait`\n@@ -398,16 +389,17 @@ impl<'tcx> InferCtxt<'tcx> {\n                 may_define_opaque_type(self.tcx, parent_def_id, opaque_hir_id)\n             }\n         };\n-        trace!(?origin);\n-        in_definition_scope.then_some(*origin)\n+        in_definition_scope.then_some(origin)\n     }\n \n+    /// Returns the origin of the opaque type `def_id` even if we are not in its\n+    /// defining scope.\n     #[instrument(skip(self), level = \"trace\", ret)]\n-    fn opaque_ty_origin_unchecked(&self, def_id: LocalDefId, span: Span) -> OpaqueTyOrigin {\n+    fn opaque_type_origin_unchecked(&self, def_id: LocalDefId) -> OpaqueTyOrigin {\n         match self.tcx.hir().expect_item(def_id).kind {\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => origin,\n             ref itemkind => {\n-                span_bug!(span, \"weird opaque type: {:?}, {:#?}\", def_id, itemkind)\n+                bug!(\"weird opaque type: {:?}, {:#?}\", def_id, itemkind)\n             }\n         }\n     }"}]}