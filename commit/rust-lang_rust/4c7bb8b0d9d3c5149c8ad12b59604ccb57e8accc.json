{"sha": "4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjN2JiOGIwZDlkM2M1MTQ5YzhhZDEyYjU5NjA0Y2NiNTdlOGFjY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-02T11:46:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-02T11:46:13Z"}, "message": "Auto merge of #61276 - eddyb:kill-res-upvar, r=petrochenkov\n\nrustc: remove Res::Upvar.\n\nBy keeping track of the current \"`body_owner`\" (the `DefId` of the current fn/closure/const/etc.) in several passes, `Res::Upvar` and `hir::Upvar` don't need to contain contextual information about the closure.\n\nBy leveraging [`indexmap`](https://docs.rs/indexmap), the list of upvars for a given closure can now also be queried, to check whether a local variable is a closure capture, and so `Res::Upvar` can be merged with `Res::Local`.\n\nAnd finally, the `tcx.upvars(...)` query now collects upvars from HIR, without relying on `rustc_resolve`.\n\nr? @petrochenkov cc @varkor @davidtwco", "tree": {"sha": "890c2d00449ffc87659a07f6f8ea4eb9cf64275e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/890c2d00449ffc87659a07f6f8ea4eb9cf64275e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "html_url": "https://github.com/rust-lang/rust/commit/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "538e17a3fdb517e0cd63f7c16d3292e7d710f7c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/538e17a3fdb517e0cd63f7c16d3292e7d710f7c7", "html_url": "https://github.com/rust-lang/rust/commit/538e17a3fdb517e0cd63f7c16d3292e7d710f7c7"}, {"sha": "f7a4c9d7b55950c6b8451b42f203df2c009fc653", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7a4c9d7b55950c6b8451b42f203df2c009fc653", "html_url": "https://github.com/rust-lang/rust/commit/f7a4c9d7b55950c6b8451b42f203df2c009fc653"}], "stats": {"total": 750, "additions": 458, "deletions": 292}, "files": [{"sha": "0eee3461ed6a245758e7bddf1fd90b95a79c1c4e", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -1183,6 +1183,11 @@ dependencies = [\n  \"typenum 1.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"indexmap\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"installer\"\n version = \"0.0.0\"\n@@ -2719,6 +2724,7 @@ dependencies = [\n  \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n+ \"indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2970,6 +2976,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -3236,6 +3243,7 @@ dependencies = [\n name = \"serialize\"\n version = \"0.0.0\"\n dependencies = [\n+ \"indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -4199,6 +4207,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum if_chain 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c3360c7b59e5ffa2653671fb74b4741a5d343c03f331c0a4aeda42b5c2b0ec7d\"\n \"checksum ignore 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8dc57fa12805f367736a38541ac1a9fc6a52812a0ca959b1d4d4b640a89eb002\"\n \"checksum im-rc 13.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a0197597d095c0d11107975d3175173f810ee572c2501ff4de64f4f3f119806\"\n+\"checksum indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e81a7c05f79578dbc15793d8b619db9ba32b4577003ef3af1a91c416798c58d\"\n \"checksum iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbe6e417e7d0975db6512b90796e8ce223145ac4e33c377e4a42882a0e88bb08\"\n \"checksum is-match 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e5b386aef33a1c677be65237cb9d32c3f3ef56bd035949710c4bb13083eb053\"\n \"checksum itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f58856976b776fedd95533137617a02fb25719f40e7d9b01c7043cd65474f450\""}, {"sha": "e8c3914e695ad1c71c214cbf240625e758382fbf", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -109,6 +109,7 @@ macro_rules! arena_types {\n             >,\n             [few] crate_variances: rustc::ty::CrateVariancesMap<'tcx>,\n             [few] inferred_outlives_crate: rustc::ty::CratePredicatesMap<'tcx>,\n+            [] upvars: rustc_data_structures::fx::FxIndexMap<rustc::hir::HirId, rustc::hir::Upvar>,\n         ], $tcx);\n     )\n }"}, {"sha": "131a910bebb1aac2832ceb02cda38540e6c85225", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -139,9 +139,6 @@ pub enum Res<Id = hir::HirId> {\n     // Value namespace\n     SelfCtor(DefId /* impl */),  // `DefId` refers to the impl\n     Local(Id),\n-    Upvar(Id,           // `HirId` of closed over local\n-          usize,        // index in the `upvars` list of the closure\n-          ast::NodeId), // expr node that creates the closure\n \n     // Macro namespace\n     NonMacroAttr(NonMacroAttrKind), // e.g., `#[inline]` or `#[rustfmt::skip]`\n@@ -347,7 +344,6 @@ impl<Id> Res<Id> {\n             Res::Def(_, id) => Some(id),\n \n             Res::Local(..) |\n-            Res::Upvar(..) |\n             Res::PrimTy(..) |\n             Res::SelfTy(..) |\n             Res::SelfCtor(..) |\n@@ -374,7 +370,6 @@ impl<Id> Res<Id> {\n             Res::SelfCtor(..) => \"self constructor\",\n             Res::PrimTy(..) => \"builtin type\",\n             Res::Local(..) => \"local variable\",\n-            Res::Upvar(..) => \"closure capture\",\n             Res::SelfTy(..) => \"self type\",\n             Res::ToolMod => \"tool module\",\n             Res::NonMacroAttr(attr_kind) => attr_kind.descr(),\n@@ -397,11 +392,6 @@ impl<Id> Res<Id> {\n             Res::SelfCtor(id) => Res::SelfCtor(id),\n             Res::PrimTy(id) => Res::PrimTy(id),\n             Res::Local(id) => Res::Local(map(id)),\n-            Res::Upvar(id, index, closure) => Res::Upvar(\n-                map(id),\n-                index,\n-                closure\n-            ),\n             Res::SelfTy(a, b) => Res::SelfTy(a, b),\n             Res::ToolMod => Res::ToolMod,\n             Res::NonMacroAttr(attr_kind) => Res::NonMacroAttr(attr_kind),"}, {"sha": "c84c18ce8a7e37bb9aa702c124da211efaba5167", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -26,7 +26,7 @@ use crate::util::common::time;\n \n use std::io;\n use std::result::Result::Err;\n-use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n \n pub mod blocks;\n mod collector;\n@@ -1450,11 +1450,13 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n     }\n }\n \n-pub fn def_kind(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefKind> {\n-    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n-        tcx.hir().def_kind(node_id)\n-    } else {\n-        bug!(\"Calling local def_kind query provider for upstream DefId: {:?}\",\n-             def_id)\n-    }\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.def_kind = |tcx, def_id| {\n+        if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+            tcx.hir().def_kind(node_id)\n+        } else {\n+            bug!(\"Calling local def_kind query provider for upstream DefId: {:?}\",\n+                def_id)\n+        }\n+    };\n }"}, {"sha": "f7daa7a94551f3e578927fd9db6a2dfdf0c7d358", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -63,6 +63,7 @@ pub mod lowering;\n pub mod map;\n pub mod pat_util;\n pub mod print;\n+pub mod upvars;\n \n /// Uniquely identifies a node in the HIR of the current crate. It is\n /// composed of the `owner`, which is the `DefIndex` of the directly enclosing\n@@ -1408,7 +1409,6 @@ impl Expr {\n             ExprKind::Path(QPath::Resolved(_, ref path)) => {\n                 match path.res {\n                     Res::Local(..)\n-                    | Res::Upvar(..)\n                     | Res::Def(DefKind::Static, _)\n                     | Res::Err => true,\n                     _ => false,\n@@ -2493,32 +2493,11 @@ impl ForeignItemKind {\n \n /// A variable captured by a closure.\n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Upvar<Id = HirId> {\n-    /// The variable being captured.\n-    pub res: Res<Id>,\n-\n+pub struct Upvar {\n     // First span where it is accessed (there can be multiple).\n     pub span: Span\n }\n \n-impl<Id: fmt::Debug + Copy> Upvar<Id> {\n-    pub fn map_id<R>(self, map: impl FnMut(Id) -> R) -> Upvar<R> {\n-        Upvar {\n-            res: self.res.map_id(map),\n-            span: self.span,\n-        }\n-    }\n-\n-    pub fn var_id(&self) -> Id {\n-        match self.res {\n-            Res::Local(id) | Res::Upvar(id, ..) => id,\n-            _ => bug!(\"Upvar::var_id: bad res ({:?})\", self.res)\n-        }\n-    }\n-}\n-\n-pub type UpvarMap = NodeMap<Vec<Upvar<ast::NodeId>>>;\n-\n pub type CaptureModeMap = NodeMap<CaptureClause>;\n \n  // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n@@ -2537,10 +2516,10 @@ pub type TraitMap = NodeMap<Vec<TraitCandidate>>;\n // imported.\n pub type GlobMap = NodeMap<FxHashSet<Name>>;\n \n-\n pub fn provide(providers: &mut Providers<'_>) {\n     check_attr::provide(providers);\n-    providers.def_kind = map::def_kind;\n+    map::provide(providers);\n+    upvars::provide(providers);\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]"}, {"sha": "a053deb558464b4a849ff7077786fb4944129928", "filename": "src/librustc/hir/upvars.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -0,0 +1,104 @@\n+//! Upvar (closure capture) collection from cross-body HIR uses of `Res::Local`s.\n+\n+use crate::hir::{self, HirId};\n+use crate::hir::def::Res;\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n+use syntax_pos::Span;\n+use rustc_data_structures::fx::{FxIndexMap, FxHashSet};\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.upvars = |tcx, def_id| {\n+        if !tcx.is_closure(def_id) {\n+            return None;\n+        }\n+\n+        let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let body = tcx.hir().body(tcx.hir().maybe_body_owned_by(node_id)?);\n+\n+        let mut local_collector = LocalCollector::default();\n+        local_collector.visit_body(body);\n+\n+        let mut capture_collector = CaptureCollector {\n+            tcx,\n+            locals: &local_collector.locals,\n+            upvars: FxIndexMap::default(),\n+        };\n+        capture_collector.visit_body(body);\n+\n+        if !capture_collector.upvars.is_empty() {\n+            Some(tcx.arena.alloc(capture_collector.upvars))\n+        } else {\n+            None\n+        }\n+    };\n+}\n+\n+#[derive(Default)]\n+struct LocalCollector {\n+    // FIXME(eddyb) perhaps use `ItemLocalId` instead?\n+    locals: FxHashSet<HirId>,\n+}\n+\n+impl Visitor<'tcx> for LocalCollector {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n+        if let hir::PatKind::Binding(_, hir_id, ..) = pat.node {\n+            self.locals.insert(hir_id);\n+        }\n+        intravisit::walk_pat(self, pat);\n+    }\n+}\n+\n+struct CaptureCollector<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    locals: &'a FxHashSet<HirId>,\n+    upvars: FxIndexMap<HirId, hir::Upvar>,\n+}\n+\n+impl CaptureCollector<'_, '_> {\n+    fn visit_local_use(&mut self, var_id: HirId, span: Span) {\n+        if !self.locals.contains(&var_id) {\n+            self.upvars.entry(var_id).or_insert(hir::Upvar { span });\n+        }\n+    }\n+}\n+\n+impl Visitor<'tcx> for CaptureCollector<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx hir::Path, _: hir::HirId) {\n+        if let Res::Local(var_id) = path.res {\n+            self.visit_local_use(var_id, path.span);\n+        }\n+\n+        intravisit::walk_path(self, path);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        if let hir::ExprKind::Closure(..) = expr.node {\n+            let closure_def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n+            if let Some(upvars) = self.tcx.upvars(closure_def_id) {\n+                // Every capture of a closure expression is a local in scope,\n+                // that is moved/copied/borrowed into the closure value, and\n+                // for this analysis they are like any other access to a local.\n+                //\n+                // E.g. in `|b| |c| (a, b, c)`, the upvars of the inner closure\n+                // are `a` and `b`, and while `a` is not directly used in the\n+                // outer closure, it needs to be an upvar there too, so that\n+                // the inner closure can take it (from the outer closure's env).\n+                for (&var_id, upvar) in upvars {\n+                    self.visit_local_use(var_id, upvar.span);\n+                }\n+            }\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+}"}, {"sha": "04f5b35a0061aa4141ca4dca059fe84ce205cec4", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             }\n             _ if self.in_pat => {},\n             Res::PrimTy(..) | Res::SelfTy(..) | Res::SelfCtor(..) |\n-            Res::Local(..) | Res::Upvar(..) => {}\n+            Res::Local(..) => {}\n             Res::Def(DefKind::Ctor(CtorOf::Variant, ..), ctor_def_id) => {\n                 let variant_id = self.tcx.parent(ctor_def_id).unwrap();\n                 let enum_id = self.tcx.parent(variant_id).unwrap();"}, {"sha": "34cea2d75eaa81e556725834d5931aa8820f166a", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -268,6 +268,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n     /// See also `with_infer`, which is used *during* typeck.\n     pub fn new(delegate: &'a mut (dyn Delegate<'tcx>+'a),\n                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               body_owner: DefId,\n                param_env: ty::ParamEnv<'tcx>,\n                region_scope_tree: &'a region::ScopeTree,\n                tables: &'a ty::TypeckTables<'tcx>,\n@@ -276,6 +277,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n     {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::new(tcx,\n+                                                  body_owner,\n                                                   region_scope_tree,\n                                                   tables,\n                                                   rvalue_promotable_map),\n@@ -288,13 +290,19 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn with_infer(delegate: &'a mut (dyn Delegate<'tcx>+'a),\n                       infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                      body_owner: DefId,\n                       param_env: ty::ParamEnv<'tcx>,\n                       region_scope_tree: &'a region::ScopeTree,\n                       tables: &'a ty::TypeckTables<'tcx>)\n                       -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::with_infer(infcx, region_scope_tree, tables),\n+            mc: mc::MemCategorizationContext::with_infer(\n+                infcx,\n+                body_owner,\n+                region_scope_tree,\n+                tables,\n+            ),\n             delegate,\n             param_env,\n         }\n@@ -924,16 +932,15 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         let closure_def_id = self.tcx().hir().local_def_id_from_hir_id(closure_expr.hir_id);\n         if let Some(upvars) = self.tcx().upvars(closure_def_id) {\n-            for upvar in upvars.iter() {\n-                let var_hir_id = upvar.var_id();\n+            for (&var_id, upvar) in upvars.iter() {\n                 let upvar_id = ty::UpvarId {\n-                    var_path: ty::UpvarPath { hir_id: var_hir_id },\n+                    var_path: ty::UpvarPath { hir_id: var_id },\n                     closure_expr_id: closure_def_id.to_local(),\n                 };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.hir_id,\n                                                                    fn_decl_span,\n-                                                                   upvar));\n+                                                                   var_id));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n                         let mode = copy_or_move(&self.mc,\n@@ -958,13 +965,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn cat_captured_var(&mut self,\n                         closure_hir_id: hir::HirId,\n                         closure_span: Span,\n-                        upvar: &hir::Upvar)\n+                        var_id: hir::HirId)\n                         -> mc::McResult<mc::cmt_<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n-        // caller's perspective\n-        let var_hir_id = upvar.var_id();\n-        let var_ty = self.mc.node_ty(var_hir_id)?;\n-        self.mc.cat_res(closure_hir_id, closure_span, var_ty, upvar.res)\n+        // perspective of the creator (parent) of the closure.\n+        let var_ty = self.mc.node_ty(var_id)?;\n+        self.mc.cat_res(closure_hir_id, closure_span, var_ty, Res::Local(var_id))\n     }\n }\n "}, {"sha": "45b4fb56056954ca1fc4fe790ab72f0a074c7882", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -182,7 +182,10 @@ impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n }\n \n fn check_mod_liveness<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut IrMaps::new(tcx).as_deep_visitor());\n+    tcx.hir().visit_item_likes_in_module(\n+        module_def_id,\n+        &mut IrMaps::new(tcx, module_def_id).as_deep_visitor(),\n+    );\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n@@ -255,6 +258,7 @@ enum VarKind {\n \n struct IrMaps<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    body_owner: DefId,\n     num_live_nodes: usize,\n     num_vars: usize,\n     live_node_map: HirIdMap<LiveNode>,\n@@ -265,9 +269,10 @@ struct IrMaps<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> IrMaps<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, body_owner: DefId) -> IrMaps<'a, 'tcx> {\n         IrMaps {\n             tcx,\n+            body_owner,\n             num_live_nodes: 0,\n             num_vars: 0,\n             live_node_map: HirIdMap::default(),\n@@ -356,7 +361,8 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     debug!(\"visit_fn\");\n \n     // swap in a new set of IR maps for this function body:\n-    let mut fn_maps = IrMaps::new(ir.tcx);\n+    let def_id = ir.tcx.hir().local_def_id_from_hir_id(id);\n+    let mut fn_maps = IrMaps::new(ir.tcx, def_id);\n \n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n@@ -468,8 +474,11 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n         debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n-        if let Res::Local(..) = path.res {\n-            ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+        if let Res::Local(var_hir_id) = path.res {\n+            let upvars = ir.tcx.upvars(ir.body_owner);\n+            if !upvars.map_or(false, |upvars| upvars.contains_key(&var_hir_id)) {\n+                ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+            }\n         }\n         intravisit::walk_expr(ir, expr);\n       }\n@@ -485,18 +494,23 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         let mut call_caps = Vec::new();\n         let closure_def_id = ir.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n         if let Some(upvars) = ir.tcx.upvars(closure_def_id) {\n-            call_caps.extend(upvars.iter().filter_map(|upvar| {\n-                if let Res::Local(rv) = upvar.res {\n+            let parent_upvars = ir.tcx.upvars(ir.body_owner);\n+            call_caps.extend(upvars.iter().filter_map(|(&var_id, upvar)| {\n+                let has_parent = parent_upvars\n+                    .map_or(false, |upvars| upvars.contains_key(&var_id));\n+                if !has_parent {\n                     let upvar_ln = ir.add_live_node(UpvarNode(upvar.span));\n-                    Some(CaptureInfo { ln: upvar_ln, var_hid: rv })\n+                    Some(CaptureInfo { ln: upvar_ln, var_hid: var_id })\n                 } else {\n                     None\n                 }\n             }));\n         }\n         ir.set_captures(expr.hir_id, call_caps);\n-\n+        let old_body_owner = ir.body_owner;\n+        ir.body_owner = closure_def_id;\n         intravisit::walk_expr(ir, expr);\n+        ir.body_owner = old_body_owner;\n       }\n \n       // live nodes required for interesting control flow:\n@@ -1327,8 +1341,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                    -> LiveNode {\n         match path.res {\n             Res::Local(hid) => {\n-              let nid = self.ir.tcx.hir().hir_to_node_id(hid);\n-              self.access_var(hir_id, nid, succ, acc, path.span)\n+                let upvars = self.ir.tcx.upvars(self.ir.body_owner);\n+                if !upvars.map_or(false, |upvars| upvars.contains_key(&hid)) {\n+                    let nid = self.ir.tcx.hir().hir_to_node_id(hid);\n+                    self.access_var(hir_id, nid, succ, acc, path.span)\n+                } else {\n+                    succ\n+                }\n             }\n             _ => succ\n         }\n@@ -1520,13 +1539,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 if let Res::Local(var_hid) = path.res {\n-                    // Assignment to an immutable variable or argument: only legal\n-                    // if there is no later assignment. If this local is actually\n-                    // mutable, then check for a reassignment to flag the mutability\n-                    // as being used.\n-                    let ln = self.live_node(expr.hir_id, expr.span);\n-                    let var = self.variable(var_hid, expr.span);\n-                    self.warn_about_dead_assign(expr.span, expr.hir_id, ln, var);\n+                    let upvars = self.ir.tcx.upvars(self.ir.body_owner);\n+                    if !upvars.map_or(false, |upvars| upvars.contains_key(&var_hid)) {\n+                        // Assignment to an immutable variable or argument: only legal\n+                        // if there is no later assignment. If this local is actually\n+                        // mutable, then check for a reassignment to flag the mutability\n+                        // as being used.\n+                        let ln = self.live_node(expr.hir_id, expr.span);\n+                        let var = self.variable(var_hid, expr.span);\n+                        self.warn_about_dead_assign(expr.span, expr.hir_id, ln, var);\n+                    }\n                 }\n             }\n             _ => {"}, {"sha": "7011948148d84789a03d58ea8ba7f3f21f508a13", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -78,6 +78,7 @@ use syntax_pos::Span;\n use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::rc::Rc;\n use crate::util::nodemap::ItemLocalSet;\n@@ -288,6 +289,8 @@ impl HirNode for hir::Pat {\n #[derive(Clone)]\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub body_owner: DefId,\n+    pub upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n     pub region_scope_tree: &'a region::ScopeTree,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n     rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n@@ -398,12 +401,15 @@ impl MutabilityCategory {\n \n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               body_owner: DefId,\n                region_scope_tree: &'a region::ScopeTree,\n                tables: &'a ty::TypeckTables<'tcx>,\n                rvalue_promotable_map: Option<&'tcx ItemLocalSet>)\n                -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n         MemCategorizationContext {\n             tcx,\n+            body_owner,\n+            upvars: tcx.upvars(body_owner),\n             region_scope_tree,\n             tables,\n             rvalue_promotable_map,\n@@ -423,6 +429,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     /// - similarly, as the results of upvar analysis are not yet\n     ///   known, the results around upvar accesses may be incorrect.\n     pub fn with_infer(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                      body_owner: DefId,\n                       region_scope_tree: &'a region::ScopeTree,\n                       tables: &'a ty::TypeckTables<'tcx>)\n                       -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n@@ -436,6 +443,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         MemCategorizationContext {\n             tcx,\n+            body_owner,\n+            upvars: tcx.upvars(body_owner),\n             region_scope_tree,\n             tables,\n             rvalue_promotable_map,\n@@ -737,21 +746,20 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 })\n             }\n \n-            Res::Upvar(var_id, _, fn_node_id) => {\n+            Res::Local(var_id) => {\n                 let var_nid = self.tcx.hir().hir_to_node_id(var_id);\n-                self.cat_upvar(hir_id, span, var_nid, fn_node_id)\n-            }\n-\n-            Res::Local(vid) => {\n-                let vnid = self.tcx.hir().hir_to_node_id(vid);\n-                Ok(cmt_ {\n-                    hir_id,\n-                    span,\n-                    cat: Categorization::Local(vid),\n-                    mutbl: MutabilityCategory::from_local(self.tcx, self.tables, vnid),\n-                    ty: expr_ty,\n-                    note: NoteNone\n-                })\n+                if self.upvars.map_or(false, |upvars| upvars.contains_key(&var_id)) {\n+                    self.cat_upvar(hir_id, span, var_nid)\n+                } else {\n+                    Ok(cmt_ {\n+                        hir_id,\n+                        span,\n+                        cat: Categorization::Local(var_id),\n+                        mutbl: MutabilityCategory::from_local(self.tcx, self.tables, var_nid),\n+                        ty: expr_ty,\n+                        note: NoteNone\n+                    })\n+                }\n             }\n \n             def => span_bug!(span, \"unexpected definition in memory categorization: {:?}\", def)\n@@ -760,15 +768,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n     // Categorize an upvar, complete with invisible derefs of closure\n     // environment and upvar reference as appropriate.\n-    fn cat_upvar(&self,\n-                 hir_id: hir::HirId,\n-                 span: Span,\n-                 var_id: ast::NodeId,\n-                 fn_node_id: ast::NodeId)\n-                 -> McResult<cmt_<'tcx>>\n-    {\n-        let fn_hir_id = self.tcx.hir().node_to_hir_id(fn_node_id);\n-\n+    fn cat_upvar(\n+        &self,\n+        hir_id: hir::HirId,\n+        span: Span,\n+        var_id: ast::NodeId,\n+    ) -> McResult<cmt_<'tcx>> {\n         // An upvar can have up to 3 components. We translate first to a\n         // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n         // field from the environment.\n@@ -792,6 +797,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n \n+        let closure_expr_def_id = self.body_owner;\n+        let fn_hir_id = self.tcx.hir().local_def_id_to_hir_id(\n+            LocalDefId::from_def_id(closure_expr_def_id),\n+        );\n         let ty = self.node_ty(fn_hir_id)?;\n         let kind = match ty.sty {\n             ty::Generator(..) => ty::ClosureKind::FnOnce,\n@@ -813,7 +822,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),\n         };\n \n-        let closure_expr_def_id = self.tcx.hir().local_def_id(fn_node_id);\n         let var_hir_id = self.tcx.hir().node_to_hir_id(var_id);\n         let upvar_id = ty::UpvarId {\n             var_path: ty::UpvarPath { hir_id: var_hir_id },"}, {"sha": "45e1d983511c0d151c6b4bcf1b7e51ca55348101", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n         };\n \n         match res {\n-            Some(Res::Local(hir_id)) | Some(Res::Upvar(hir_id, ..)) => {\n+            Some(Res::Local(hir_id)) => {\n                 self.reachable_symbols.insert(hir_id);\n             }\n             Some(res) => {"}, {"sha": "6213eda651486424587aaedbf9d22d0555488b3f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -2562,8 +2562,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             if let Some(upvars) = tcx.upvars(def_id) {\n-                                for (upvar, place) in upvars.iter().zip(places) {\n-                                    let var_name = tcx.hir().name_by_hir_id(upvar.var_id());\n+                                for (&var_id, place) in upvars.keys().zip(places) {\n+                                    let var_name = tcx.hir().name_by_hir_id(var_id);\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n                             }\n@@ -2581,8 +2581,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             if let Some(upvars) = tcx.upvars(def_id) {\n-                                for (upvar, place) in upvars.iter().zip(places) {\n-                                    let var_name = tcx.hir().name_by_hir_id(upvar.var_id());\n+                                for (&var_id, place) in upvars.keys().zip(places) {\n+                                    let var_name = tcx.hir().name_by_hir_id(var_id);\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n                             }"}, {"sha": "18308f54442210d8aa3ad25106591a4afa4ebc20", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -826,7 +826,7 @@ rustc_queries! {\n             desc { \"generating a postorder list of CrateNums\" }\n         }\n \n-        query upvars(_: DefId) -> Option<&'tcx [hir::Upvar]> {\n+        query upvars(_: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n             eval_always\n         }\n         query maybe_unused_trait_import(_: DefId) -> bool {"}, {"sha": "d271e2591fb49791c5e6feed63c2a43f654e2a49", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -1062,11 +1062,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub queries: query::Queries<'tcx>,\n \n-    // Records the captured variables referenced by every closure\n-    // expression. Do not track deps for this, just recompute it from\n-    // scratch every time.\n-    upvars: FxHashMap<DefId, Vec<hir::Upvar>>,\n-\n     maybe_unused_trait_imports: FxHashSet<DefId>,\n     maybe_unused_extern_crates: Vec<(DefId, Span)>,\n     /// A map of glob use to a set of names it actually imports. Currently only\n@@ -1297,12 +1292,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }).collect();\n                 (k, exports)\n             }).collect(),\n-            upvars: resolutions.upvars.into_iter().map(|(k, v)| {\n-                let vars: Vec<_> = v.into_iter().map(|e| {\n-                    e.map_id(|id| hir.node_to_hir_id(id))\n-                }).collect();\n-                (hir.local_def_id(k), vars)\n-            }).collect(),\n             maybe_unused_trait_imports:\n                 resolutions.maybe_unused_trait_imports\n                     .into_iter()\n@@ -3023,7 +3012,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.arena.alloc(middle::lang_items::collect(tcx))\n     };\n-    providers.upvars = |tcx, id| tcx.gcx.upvars.get(&id).map(|v| &v[..]);\n     providers.maybe_unused_trait_import = |tcx, id| {\n         tcx.maybe_unused_trait_imports.contains(&id)\n     };"}, {"sha": "e89fb53c236194ec230fef70d6d35708d1f1d6eb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -8,7 +8,7 @@ pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::fold::TypeFoldable;\n \n-use crate::hir::{map as hir_map, UpvarMap, GlobMap, TraitMap};\n+use crate::hir::{map as hir_map, GlobMap, TraitMap};\n use crate::hir::Node;\n use crate::hir::def::{Res, DefKind, CtorOf, CtorKind, ExportMap};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -51,6 +51,7 @@ use syntax::symbol::{kw, sym, Symbol, LocalInternedString, InternedString};\n use syntax_pos::Span;\n \n use smallvec;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n@@ -122,7 +123,6 @@ mod sty;\n \n #[derive(Clone)]\n pub struct Resolutions {\n-    pub upvars: UpvarMap,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n     pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n@@ -808,7 +808,7 @@ pub struct UpvarBorrow<'tcx> {\n     pub region: ty::Region<'tcx>,\n }\n \n-pub type UpvarListMap = FxHashMap<DefId, Vec<UpvarId>>;\n+pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n #[derive(Copy, Clone)]"}, {"sha": "a8a6bca4fd434f8e7c838550b050bf8ac43988c7", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -585,16 +585,16 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n                 if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n                     p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n                     let mut sep = \" \";\n-                    for (upvar, upvar_ty) in self.tcx().upvars(did)\n+                    for (&var_id, upvar_ty) in self.tcx().upvars(did)\n                         .as_ref()\n-                        .map_or(&[][..], |v| &v[..])\n                         .iter()\n+                        .flat_map(|v| v.keys())\n                         .zip(upvar_tys)\n                     {\n                         p!(\n                             write(\"{}{}:\",\n                                     sep,\n-                                    self.tcx().hir().name_by_hir_id(upvar.var_id())),\n+                                    self.tcx().hir().name_by_hir_id(var_id)),\n                             print(upvar_ty));\n                         sep = \", \";\n                     }\n@@ -628,16 +628,16 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n                         p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n                     }\n                     let mut sep = \" \";\n-                    for (upvar, upvar_ty) in self.tcx().upvars(did)\n+                    for (&var_id, upvar_ty) in self.tcx().upvars(did)\n                         .as_ref()\n-                        .map_or(&[][..], |v| &v[..])\n                         .iter()\n+                        .flat_map(|v| v.keys())\n                         .zip(upvar_tys)\n                     {\n                         p!(\n                             write(\"{}{}:\",\n                                     sep,\n-                                    self.tcx().hir().name_by_hir_id(upvar.var_id())),\n+                                    self.tcx().hir().name_by_hir_id(var_id)),\n                             print(upvar_ty));\n                         sep = \", \";\n                     }"}, {"sha": "e595b52876f4c831a08a18df15249b5cedc098de", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -45,7 +45,7 @@ use crate::util::profiling::ProfileCategory::*;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::StableVec;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fingerprint::Fingerprint;"}, {"sha": "35e6c1c5bf5a762cddda221c937dc23519b2ca7b", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -208,6 +208,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let rvalue_promotable_map = bccx.tcx.rvalue_promotable_map(def_id);\n     euv::ExprUseVisitor::new(&mut clcx,\n                              bccx.tcx,\n+                             def_id,\n                              param_env,\n                              &bccx.region_scope_tree,\n                              bccx.tables,"}, {"sha": "e437c08c956ec73123764af4e3880236df599ead", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -44,6 +44,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let rvalue_promotable_map = bccx.tcx.rvalue_promotable_map(def_id);\n     euv::ExprUseVisitor::new(&mut glcx,\n                              bccx.tcx,\n+                             def_id,\n                              param_env,\n                              &bccx.region_scope_tree,\n                              bccx.tables,"}, {"sha": "cd792d31187bd865d4b4257482890d3b7d1ec760", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -11,6 +11,7 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n ena = \"0.13\"\n+indexmap = \"1\"\n log = \"0.4\"\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n lazy_static = \"1\""}, {"sha": "cf73fe8cf85ceeac553ff1db97a0b43fb2f3077a", "filename": "src/librustc_data_structures/fx.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_data_structures%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_data_structures%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffx.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -1 +1,6 @@\n+use std::hash::BuildHasherDefault;\n+\n pub use rustc_hash::{FxHasher, FxHashMap, FxHashSet};\n+\n+pub type FxIndexMap<K, V> = indexmap::IndexMap<K, V, BuildHasherDefault<FxHasher>>;\n+pub type FxIndexSet<V> = indexmap::IndexSet<V, BuildHasherDefault<FxHasher>>;"}, {"sha": "270d9520627646e23d919014943b01677ebd477b", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -323,6 +323,37 @@ impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Vec<T> {\n     }\n }\n \n+impl<K, V, R, CTX> HashStable<CTX> for indexmap::IndexMap<K, V, R>\n+    where K: HashStable<CTX> + Eq + Hash,\n+          V: HashStable<CTX>,\n+          R: BuildHasher,\n+{\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for kv in self {\n+            kv.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<K, R, CTX> HashStable<CTX> for indexmap::IndexSet<K, R>\n+    where K: HashStable<CTX> + Eq + Hash,\n+          R: BuildHasher,\n+{\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for key in self {\n+            key.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n impl<A, CTX> HashStable<CTX> for SmallVec<[A; 1]> where A: HashStable<CTX> {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "9691d0337d7d20091f59e602544aff2dab92b174", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -178,7 +178,6 @@ impl ExpansionResult {\n         ExpansionResult {\n             defs: Steal::new(resolver.definitions),\n             resolutions: Steal::new(Resolutions {\n-                upvars: resolver.upvars,\n                 export_map: resolver.export_map,\n                 trait_map: resolver.trait_map,\n                 glob_map: resolver.glob_map,\n@@ -197,7 +196,6 @@ impl ExpansionResult {\n         ExpansionResult {\n             defs: Steal::new(resolver.definitions.clone()),\n             resolutions: Steal::new(Resolutions {\n-                upvars: resolver.upvars.clone(),\n                 export_map: resolver.export_map.clone(),\n                 trait_map: resolver.trait_map.clone(),\n                 glob_map: resolver.glob_map.clone(),"}, {"sha": "31af20fdb77eb2ef88974e1252cd597a7f61c49f", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -348,9 +348,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // `tcx.upvars(def_id)` returns an `Option`, which is `None` in case\n                     // the closure comes from another crate. But in that case we wouldn't\n                     // be borrowck'ing it, so we can just unwrap:\n-                    let upvar = self.infcx.tcx.upvars(def_id).unwrap()[field.index()];\n+                    let (&var_id, _) = self.infcx.tcx.upvars(def_id).unwrap()\n+                        .get_index(field.index()).unwrap();\n \n-                    self.infcx.tcx.hir().name_by_hir_id(upvar.var_id()).to_string()\n+                    self.infcx.tcx.hir().name_by_hir_id(var_id).to_string()\n                 }\n                 _ => {\n                     // Might need a revision when the fields in trait RFC is implemented\n@@ -645,12 +646,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let hir::ExprKind::Closure(\n             .., args_span, _\n         ) = expr {\n-            for (v, place) in self.infcx.tcx.upvars(def_id)?.iter().zip(places) {\n+            for (upvar, place) in self.infcx.tcx.upvars(def_id)?.values().zip(places) {\n                 match place {\n                     Operand::Copy(place) |\n                     Operand::Move(place) if target_place == place => {\n                         debug!(\"closure_span: found captured local {:?}\", place);\n-                        return Some((*args_span, v.span));\n+                        return Some((*args_span, upvar.span));\n                     },\n                     _ => {}\n                 }"}, {"sha": "4ae4d039d60340e53a00b625c302898c78c0edef", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -149,7 +149,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         .upvar_list\n         .get(&def_id)\n         .into_iter()\n-        .flatten()\n+        .flat_map(|v| v.values())\n         .map(|upvar_id| {\n             let var_hir_id = upvar_id.var_path.hir_id;\n             let var_node_id = tcx.hir().hir_to_node_id(var_hir_id);"}, {"sha": "123b46cb04820dec34d5b106896f6eaab4ac0c7a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -651,10 +651,9 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         .get(&fn_def_id)\n         .into_iter()\n         .flatten()\n-        .map(|upvar_id| {\n-            let var_hir_id = upvar_id.var_path.hir_id;\n+        .map(|(&var_hir_id, &upvar_id)| {\n             let var_node_id = tcx_hir.hir_to_node_id(var_hir_id);\n-            let capture = hir_tables.upvar_capture(*upvar_id);\n+            let capture = hir_tables.upvar_capture(upvar_id);\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,\n                 ty::UpvarCapture::ByRef(..) => true,"}, {"sha": "5a6b6a74830521a18aaba758b6485451962667b7", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -515,7 +515,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let upvars = cx.tcx.upvars(def_id).iter()\n                 .flat_map(|upvars| upvars.iter())\n                 .zip(substs.upvar_tys(def_id, cx.tcx))\n-                .map(|(upvar, ty)| capture_upvar(cx, expr, upvar, ty))\n+                .map(|((&var_hir_id, _), ty)| capture_upvar(cx, expr, var_hir_id, ty))\n                 .collect();\n             ExprKind::Closure {\n                 closure_id: def_id,\n@@ -960,36 +960,44 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         Res::Def(DefKind::Static, id) => ExprKind::StaticRef { id },\n \n-        Res::Local(..) | Res::Upvar(..) => convert_var(cx, expr, res),\n+        Res::Local(var_hir_id) => convert_var(cx, expr, var_hir_id),\n \n         _ => span_bug!(expr.span, \"res `{:?}` not yet implemented\", res),\n     }\n }\n \n-fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                               expr: &'tcx hir::Expr,\n-                               res: Res)\n-                               -> ExprKind<'tcx> {\n+fn convert_var(\n+    cx: &mut Cx<'_, '_, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    var_hir_id: hir::HirId,\n+) -> ExprKind<'tcx> {\n+    let upvar_index = cx.tables().upvar_list.get(&cx.body_owner)\n+        .and_then(|upvars| upvars.get_full(&var_hir_id).map(|(i, _, _)| i));\n+\n+    debug!(\"convert_var({:?}): upvar_index={:?}, body_owner={:?}\",\n+           var_hir_id, upvar_index, cx.body_owner);\n+\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n-    match res {\n-        Res::Local(id) => ExprKind::VarRef { id },\n+    match upvar_index {\n+        None => ExprKind::VarRef { id: var_hir_id },\n \n-        Res::Upvar(var_hir_id, index, closure_expr_id) => {\n-            debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\",\n-                   var_hir_id,\n-                   index,\n-                   closure_expr_id);\n+        Some(upvar_index) => {\n+            let closure_def_id = cx.body_owner;\n+            let upvar_id = ty::UpvarId {\n+                var_path: ty::UpvarPath {hir_id: var_hir_id},\n+                closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n+            };\n             let var_ty = cx.tables().node_type(var_hir_id);\n \n             // FIXME free regions in closures are not right\n-            let closure_ty = cx.tables()\n-                               .node_type(cx.tcx.hir().node_to_hir_id(closure_expr_id));\n+            let closure_ty = cx.tables().node_type(\n+                cx.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id),\n+            );\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n             // have a bound region with number 0\n-            let closure_def_id = cx.tcx.hir().local_def_id(closure_expr_id);\n             let region = ty::ReFree(ty::FreeRegion {\n                 scope: closure_def_id,\n                 bound_region: ty::BoundRegion::BrAnon(0),\n@@ -1060,15 +1068,11 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // at this point we have `self.n`, which loads up the upvar\n             let field_kind = ExprKind::Field {\n                 lhs: self_expr.to_ref(),\n-                name: Field::new(index),\n+                name: Field::new(upvar_index),\n             };\n \n             // ...but the upvar might be an `&T` or `&mut T` capture, at which\n             // point we need an implicit deref\n-            let upvar_id = ty::UpvarId {\n-                var_path: ty::UpvarPath {hir_id: var_hir_id},\n-                closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n-            };\n             match cx.tables().upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue => field_kind,\n                 ty::UpvarCapture::ByRef(borrow) => {\n@@ -1087,8 +1091,6 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 }\n             }\n         }\n-\n-        _ => span_bug!(expr.span, \"type of & not region\"),\n     }\n }\n \n@@ -1178,10 +1180,9 @@ fn overloaded_place<'a, 'gcx, 'tcx>(\n \n fn capture_upvar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    closure_expr: &'tcx hir::Expr,\n-                                   upvar: &hir::Upvar,\n+                                   var_hir_id: hir::HirId,\n                                    upvar_ty: Ty<'tcx>)\n                                    -> ExprRef<'tcx> {\n-    let var_hir_id = upvar.var_id();\n     let upvar_id = ty::UpvarId {\n         var_path: ty::UpvarPath { hir_id: var_hir_id },\n         closure_expr_id: cx.tcx.hir().local_def_id_from_hir_id(closure_expr.hir_id).to_local(),\n@@ -1193,7 +1194,7 @@ fn capture_upvar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         temp_lifetime,\n         ty: var_ty,\n         span: closure_expr.span,\n-        kind: convert_var(cx, closure_expr, upvar.res),\n+        kind: convert_var(cx, closure_expr, var_hir_id),\n     };\n     match upvar_capture {\n         ty::UpvarCapture::ByValue => captured_var.to_ref(),"}, {"sha": "f4a23a90dee925b6a6b9ac126d8afa7989ffa587", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -38,6 +38,9 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// `const`, or the body of a `const fn`.\n     constness: hir::Constness,\n \n+    /// The `DefId` of the owner of this body.\n+    body_owner: DefId,\n+\n     /// What kind of body is being compiled.\n     pub body_owner_kind: hir::BodyOwnerKind,\n \n@@ -53,6 +56,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                src_id: hir::HirId) -> Cx<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n         let src_def_id = tcx.hir().local_def_id_from_hir_id(src_id);\n+        let tables = tcx.typeck_tables_of(src_def_id);\n         let body_owner_kind = tcx.hir().body_owner_kind_by_hir_id(src_id);\n \n         let constness = match body_owner_kind {\n@@ -82,8 +86,9 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             param_env: tcx.param_env(src_def_id),\n             identity_substs: InternalSubsts::identity_for_item(tcx.global_tcx(), src_def_id),\n             region_scope_tree: tcx.region_scope_tree(src_def_id),\n-            tables: tcx.typeck_tables_of(src_def_id),\n+            tables,\n             constness,\n+            body_owner: src_def_id,\n             body_owner_kind,\n             check_overflow,\n             control_flow_destroyed: Vec::new(),"}, {"sha": "215faee953230913674a78fc4d2a60bfa69d0f21", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -35,6 +35,7 @@ pub(crate) fn check_match<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n \n     MatchVisitor {\n         tcx,\n+        body_owner: def_id,\n         tables: tcx.body_tables(body_id),\n         region_scope_tree: &tcx.region_scope_tree(def_id),\n         param_env: tcx.param_env(def_id),\n@@ -48,6 +49,7 @@ fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> Diagn\n \n struct MatchVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    body_owner: DefId,\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     identity_substs: SubstsRef<'tcx>,\n@@ -632,6 +634,7 @@ fn check_for_mutation_in_guard(cx: &MatchVisitor<'_, '_>, guard: &hir::Guard) {\n         hir::Guard::If(expr) =>\n             ExprUseVisitor::new(&mut checker,\n                                 cx.tcx,\n+                                cx.body_owner,\n                                 cx.param_env,\n                                 cx.region_scope_tree,\n                                 cx.tables,"}, {"sha": "967496e59645a857a549d0b83fc82e4c3d72ab1a", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -174,8 +174,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, '\n                     if let Some(upvars) = tables.upvar_list.get(&def_id) {\n                         // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator).\n-                        if let Some(upvar_id) = upvars.get(field) {\n-                            let var_hir_id = upvar_id.var_path.hir_id;\n+                        if let Some((&var_hir_id, _)) = upvars.get_index(field) {\n                             let var_node_id = self.ecx.tcx.hir().hir_to_node_id(var_hir_id);\n                             if let hir::Node::Binding(pat) = self.ecx.tcx.hir().get(var_node_id) {\n                                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {"}, {"sha": "869cae3d3a8e4711b3af973df84c58e53ae4f848", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -199,8 +199,15 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         let param_env = self.param_env;\n         let region_scope_tree = self.tcx.region_scope_tree(item_def_id);\n         let tables = self.tables;\n-        euv::ExprUseVisitor::new(self, tcx, param_env, &region_scope_tree, tables, None)\n-            .consume_body(body);\n+        euv::ExprUseVisitor::new(\n+            self,\n+            tcx,\n+            item_def_id,\n+            param_env,\n+            &region_scope_tree,\n+            tables,\n+            None,\n+        ).consume_body(body);\n \n         let body_promotable = self.check_expr(&body.value);\n         self.in_fn = outer_in_fn;"}, {"sha": "8e3359c775288f77e237b77e6904ef8dbc0d66e9", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -12,6 +12,7 @@ test = false\n \n [dependencies]\n bitflags = \"1.0\"\n+indexmap = \"1\"\n log = \"0.4\"\n syntax = { path = \"../libsyntax\" }\n rustc = { path = \"../librustc\" }"}, {"sha": "21e759ccc650e79b470e2d21118c25ed8580b151", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 21, "deletions": 83, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -29,7 +29,7 @@ use rustc::hir::def::{\n };\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n-use rustc::hir::{Upvar, UpvarMap, TraitCandidate, TraitMap, GlobMap};\n+use rustc::hir::{TraitCandidate, TraitMap, GlobMap};\n use rustc::ty::{self, DefIdTree};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::{bug, span_bug};\n@@ -612,7 +612,6 @@ impl<'a> PathSource<'a> {\n                 | Res::Def(DefKind::Const, _)\n                 | Res::Def(DefKind::Static, _)\n                 | Res::Local(..)\n-                | Res::Upvar(..)\n                 | Res::Def(DefKind::Fn, _)\n                 | Res::Def(DefKind::Method, _)\n                 | Res::Def(DefKind::AssocConst, _)\n@@ -853,7 +852,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 function_kind: FnKind<'tcx>,\n                 declaration: &'tcx FnDecl,\n                 _: Span,\n-                node_id: NodeId)\n+                _: NodeId)\n     {\n         debug!(\"(resolving function) entering function\");\n         let (rib_kind, asyncness) = match function_kind {\n@@ -864,7 +863,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             FnKind::Closure(_) =>\n                 // Async closures aren't resolved through `visit_fn`-- they're\n                 // processed separately\n-                (ClosureRibKind(node_id), &IsAsync::NotAsync),\n+                (NormalRibKind, &IsAsync::NotAsync),\n         };\n \n         // Create a value rib for the function.\n@@ -898,12 +897,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         visit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body, potentially inside the body of an async closure\n-        if let IsAsync::Async { closure_id, .. } = asyncness {\n-            let rib_kind = ClosureRibKind(*closure_id);\n-            self.ribs[ValueNS].push(Rib::new(rib_kind));\n-            self.label_ribs.push(Rib::new(rib_kind));\n-        }\n-\n         match function_kind {\n             FnKind::ItemFn(.., body) | FnKind::Method(.., body) => {\n                 if let IsAsync::Async { ref arguments, .. } = asyncness {\n@@ -926,12 +919,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             }\n         };\n \n-        // Leave the body of the async closure\n-        if asyncness.is_async() {\n-            self.label_ribs.pop();\n-            self.ribs[ValueNS].pop();\n-        }\n-\n         debug!(\"(resolving function) leaving function\");\n \n         self.label_ribs.pop();\n@@ -1018,17 +1005,13 @@ enum GenericParameters<'a, 'b> {\n                       RibKind<'a>),\n }\n \n-/// The rib kind controls the translation of local\n-/// definitions (`Res::Local`) to upvars (`Res::Upvar`).\n+/// The rib kind restricts certain accesses,\n+/// e.g. to a `Res::Local` of an outer item.\n #[derive(Copy, Clone, Debug)]\n enum RibKind<'a> {\n-    /// No translation needs to be applied.\n+    /// No restriction needs to be applied.\n     NormalRibKind,\n \n-    /// We passed through a closure scope at the given `NodeId`.\n-    /// Translate upvars as appropriate.\n-    ClosureRibKind(NodeId /* func id */),\n-\n     /// We passed through an impl or trait and are now in one of its\n     /// methods or associated types. Allow references to ty params that impl or trait\n     /// binds. Disallow any other upvars (including other ty params that are\n@@ -1668,8 +1651,6 @@ pub struct Resolver<'a> {\n     /// Resolutions for labels (node IDs of their corresponding blocks or loops).\n     label_res_map: NodeMap<NodeId>,\n \n-    pub upvars: UpvarMap,\n-    upvars_seen: NodeMap<NodeMap<usize>>,\n     pub export_map: ExportMap<NodeId>,\n     pub trait_map: TraitMap,\n \n@@ -2032,8 +2013,6 @@ impl<'a> Resolver<'a> {\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n-            upvars: Default::default(),\n-            upvars_seen: Default::default(),\n             export_map: FxHashMap::default(),\n             trait_map: Default::default(),\n             module_map,\n@@ -2206,7 +2185,7 @@ impl<'a> Resolver<'a> {\n             if let Some(res) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::Res(\n-                    self.adjust_local_res(ns, i, res, record_used, path_span)\n+                    self.validate_res_from_ribs(ns, i, res, record_used, path_span),\n                 ));\n             }\n \n@@ -4008,14 +3987,16 @@ impl<'a> Resolver<'a> {\n             diag);\n     }\n \n-    // Resolve a local definition, potentially adjusting for closures.\n-    fn adjust_local_res(&mut self,\n-                        ns: Namespace,\n-                        rib_index: usize,\n-                        mut res: Res,\n-                        record_used: bool,\n-                        span: Span) -> Res {\n-        debug!(\"adjust_local_res\");\n+    // Validate a local resolution (from ribs).\n+    fn validate_res_from_ribs(\n+        &mut self,\n+        ns: Namespace,\n+        rib_index: usize,\n+        res: Res,\n+        record_used: bool,\n+        span: Span,\n+    ) -> Res {\n+        debug!(\"validate_res_from_ribs({:?})\", res);\n         let ribs = &self.ribs[ns][rib_index + 1..];\n \n         // An invalid forward use of a type parameter from a previous default.\n@@ -4037,10 +4018,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         match res {\n-            Res::Upvar(..) => {\n-                span_bug!(span, \"unexpected {:?} in bindings\", res)\n-            }\n-            Res::Local(node_id) => {\n+            Res::Local(_) => {\n                 use ResolutionError::*;\n                 let mut res_err = None;\n \n@@ -4050,30 +4028,6 @@ impl<'a> Resolver<'a> {\n                         ForwardTyParamBanRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue.\n                         }\n-                        ClosureRibKind(function_id) => {\n-                            let prev_res = res;\n-\n-                            let seen = self.upvars_seen\n-                                           .entry(function_id)\n-                                           .or_default();\n-                            if let Some(&index) = seen.get(&node_id) {\n-                                res = Res::Upvar(node_id, index, function_id);\n-                                continue;\n-                            }\n-                            let vec = self.upvars\n-                                          .entry(function_id)\n-                                          .or_default();\n-                            let depth = vec.len();\n-                            res = Res::Upvar(node_id, depth, function_id);\n-\n-                            if record_used {\n-                                vec.push(Upvar {\n-                                    res: prev_res,\n-                                    span,\n-                                });\n-                                seen.insert(node_id, depth);\n-                            }\n-                        }\n                         ItemRibKind | FnItemRibKind | AssocItemRibKind => {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n@@ -4103,7 +4057,7 @@ impl<'a> Resolver<'a> {\n             Res::Def(DefKind::TyParam, _) | Res::SelfTy(..) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind | AssocItemRibKind | ClosureRibKind(..) |\n+                        NormalRibKind | AssocItemRibKind |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n                         ConstantItemRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue.\n@@ -4483,25 +4437,15 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n                 self.current_type_ascription.pop();\n             }\n-            // Resolve the body of async exprs inside the async closure to which they desugar\n-            ExprKind::Async(_, async_closure_id, ref block) => {\n-                let rib_kind = ClosureRibKind(async_closure_id);\n-                self.ribs[ValueNS].push(Rib::new(rib_kind));\n-                self.label_ribs.push(Rib::new(rib_kind));\n-                self.visit_block(&block);\n-                self.label_ribs.pop();\n-                self.ribs[ValueNS].pop();\n-            }\n             // `async |x| ...` gets desugared to `|x| future_from_generator(|| ...)`, so we need to\n             // resolve the arguments within the proper scopes so that usages of them inside the\n             // closure are detected as upvars rather than normal closure arg usages.\n             ExprKind::Closure(\n-                _, IsAsync::Async { closure_id: inner_closure_id, .. }, _,\n+                _, IsAsync::Async { .. }, _,\n                 ref fn_decl, ref body, _span,\n             ) => {\n-                let rib_kind = ClosureRibKind(expr.id);\n+                let rib_kind = NormalRibKind;\n                 self.ribs[ValueNS].push(Rib::new(rib_kind));\n-                self.label_ribs.push(Rib::new(rib_kind));\n                 // Resolve arguments:\n                 let mut bindings_list = FxHashMap::default();\n                 for argument in &fn_decl.inputs {\n@@ -4513,18 +4457,12 @@ impl<'a> Resolver<'a> {\n \n                 // Now resolve the inner closure\n                 {\n-                    let rib_kind = ClosureRibKind(inner_closure_id);\n-                    self.ribs[ValueNS].push(Rib::new(rib_kind));\n-                    self.label_ribs.push(Rib::new(rib_kind));\n                     // No need to resolve arguments: the inner closure has none.\n                     // Resolve the return type:\n                     visit::walk_fn_ret_ty(self, &fn_decl.output);\n                     // Resolve the body\n                     self.visit_expr(body);\n-                    self.label_ribs.pop();\n-                    self.ribs[ValueNS].pop();\n                 }\n-                self.label_ribs.pop();\n                 self.ribs[ValueNS].pop();\n             }\n             _ => {"}, {"sha": "cca5682d90a9bc6abe35e059048d8b33070293d4", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -702,7 +702,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let span = self.span_from_span(span);\n \n         match res {\n-            Res::Upvar(id, ..) | Res::Local(id) => {\n+            Res::Local(id) => {\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,"}, {"sha": "a6cd157dc03de0f967c484e496d762bbef9e12a7", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -350,7 +350,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                     let def_span = match def {\n                         Res::Err => None,\n-                        Res::Local(id) | Res::Upvar(id, ..) => {\n+                        Res::Local(id) => {\n                             Some(self.tcx.hir().span_by_hir_id(id))\n                         },\n                         _ => def"}, {"sha": "82d198f0b78f78cc7c0b91b357456b563a3d8c1d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -5264,7 +5264,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Err(ErrorReported) => return (tcx.types.err, res),\n         };\n         let path_segs = match res {\n-            Res::Local(_) | Res::Upvar(..) => Vec::new(),\n+            Res::Local(_) => vec![],\n             Res::Def(kind, def_id) =>\n                 AstConv::def_ids_for_value_path_segments(self, segments, self_ty, kind, def_id),\n             _ => bug!(\"instantiate_value_path on {:?}\", res),\n@@ -5325,14 +5325,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }));\n \n-        match res {\n-            Res::Local(hid) | Res::Upvar(hid, ..) => {\n-                let ty = self.local_ty(span, hid).decl_ty;\n-                let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(hir_id, ty);\n-                return (ty, res);\n-            }\n-            _ => {}\n+        if let Res::Local(hid) = res {\n+            let ty = self.local_ty(span, hid).decl_ty;\n+            let ty = self.normalize_associated_types_in(span, &ty);\n+            self.write_ty(hir_id, ty);\n+            return (ty, res);\n         }\n \n         if generics_has_err {"}, {"sha": "21d7e483e9d15fd12a24deebaa35657f321d961b", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -200,6 +200,7 @@ pub struct RegionCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n     // id of innermost fn body id\n     body_id: hir::HirId,\n+    body_owner: DefId,\n \n     // call_site scope of innermost fn\n     call_site_scope: Option<region::Scope>,\n@@ -236,6 +237,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             region_scope_tree,\n             repeating_scope: initial_repeating_scope,\n             body_id: initial_body_id,\n+            body_owner: subject,\n             call_site_scope: None,\n             subject_def_id: subject,\n             outlives_environment,\n@@ -308,6 +310,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let body_id = body.id();\n         self.body_id = body_id.hir_id;\n+        self.body_owner = self.tcx.hir().body_owner_def_id(body_id);\n \n         let call_site = region::Scope {\n             id: body.value.hir_id.local_id,\n@@ -466,6 +469,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // Save state of current function before invoking\n         // `visit_fn_body`.  We will restore afterwards.\n         let old_body_id = self.body_id;\n+        let old_body_owner = self.body_owner;\n         let old_call_site_scope = self.call_site_scope;\n         let env_snapshot = self.outlives_environment.push_snapshot_pre_closure();\n \n@@ -477,6 +481,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             .pop_snapshot_post_closure(env_snapshot);\n         self.call_site_scope = old_call_site_scope;\n         self.body_id = old_body_id;\n+        self.body_owner = old_body_owner;\n     }\n \n     //visit_pat: visit_pat, // (..) see above\n@@ -829,6 +834,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     {\n         f(mc::MemCategorizationContext::with_infer(\n             &self.infcx,\n+            self.body_owner,\n             &self.region_scope_tree,\n             &self.tables.borrow(),\n         ))"}, {"sha": "82c173a6f7a57e90b7abd44ee4a6e6353aaf6fb2", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -41,6 +41,7 @@ use rustc::hir::def_id::LocalDefId;\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::infer::UpvarRegion;\n use rustc::ty::{self, Ty, TyCtxt, UpvarSubsts};\n+use rustc_data_structures::fx::FxIndexMap;\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -122,18 +123,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if let Some(upvars) = self.tcx.upvars(closure_def_id) {\n-            let mut upvar_list: Vec<ty::UpvarId> = Vec::with_capacity(upvars.len());\n-            for upvar in upvars.iter() {\n+            let mut upvar_list: FxIndexMap<hir::HirId, ty::UpvarId> =\n+                FxIndexMap::with_capacity_and_hasher(upvars.len(), Default::default());\n+            for (&var_hir_id, _) in upvars.iter() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath {\n-                        hir_id: upvar.var_id(),\n+                        hir_id: var_hir_id,\n                     },\n                     closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n                 };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n                 // Adding the upvar Id to the list of Upvars, which will be added\n                 // to the map for the closure at the end of the for loop.\n-                upvar_list.push(upvar_id);\n+                upvar_list.insert(var_hir_id, upvar_id);\n \n                 let capture_kind = match capture_clause {\n                     hir::CaptureByValue => ty::UpvarCapture::ByValue,\n@@ -165,6 +167,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let body_owner_def_id = self.tcx.hir().body_owner_def_id(body.id());\n+        assert_eq!(body_owner_def_id, closure_def_id);\n         let region_scope_tree = &self.tcx.region_scope_tree(body_owner_def_id);\n         let mut delegate = InferBorrowKind {\n             fcx: self,\n@@ -176,6 +179,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         euv::ExprUseVisitor::with_infer(\n             &mut delegate,\n             &self.infcx,\n+            body_owner_def_id,\n             self.param_env,\n             region_scope_tree,\n             &self.tables.borrow(),\n@@ -249,8 +253,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         tcx.upvars(closure_def_id).iter().flat_map(|upvars| {\n             upvars\n                 .iter()\n-                .map(|upvar| {\n-                    let var_hir_id = upvar.var_id();\n+                .map(|(&var_hir_id, _)| {\n                     let upvar_ty = self.node_ty(var_hir_id);\n                     let upvar_id = ty::UpvarId {\n                         var_path: ty::UpvarPath { hir_id: var_hir_id },"}, {"sha": "a535f776dfe602c336e9b7a3b85792a637821795", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -54,7 +54,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n         wbcx.visit_body(body);\n         wbcx.visit_upvar_capture_map();\n-        wbcx.visit_upvar_list_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n@@ -74,6 +73,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n         wbcx.tables.used_trait_imports = used_trait_imports;\n \n+        wbcx.tables.upvar_list = mem::replace(\n+            &mut self.tables.borrow_mut().upvar_list,\n+            Default::default(),\n+        );\n+\n         wbcx.tables.tainted_by_errors = self.is_tainted_by_errors();\n \n         debug!(\n@@ -343,21 +347,6 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Runs through the function context's upvar list map and adds the same to\n-    /// the TypeckTables. upvarlist is a hashmap of the list of upvars referred\n-    /// to in a closure..\n-    fn visit_upvar_list_map(&mut self) {\n-        for (closure_def_id, upvar_list) in self.fcx.tables.borrow().upvar_list.iter() {\n-            debug!(\n-                \"UpvarIDs captured by closure {:?} are: {:?}\",\n-                closure_def_id, upvar_list\n-            );\n-            self.tables\n-                .upvar_list\n-                .insert(*closure_def_id, upvar_list.to_vec());\n-        }\n-    }\n-\n     fn visit_closures(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);"}, {"sha": "fa31a68a75b720b0e320f4320e6465316b645661", "filename": "src/libserialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibserialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibserialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2FCargo.toml?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -10,4 +10,5 @@ path = \"lib.rs\"\n crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n+indexmap = \"1\"\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "80aeecb84d72bb8720d74a89c00a8c06b0036f30", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -217,6 +217,75 @@ impl<T, S> Decodable for HashSet<T, S>\n     }\n }\n \n+impl<K, V, S> Encodable for indexmap::IndexMap<K, V, S>\n+    where K: Encodable + Hash + Eq,\n+          V: Encodable,\n+          S: BuildHasher,\n+{\n+    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+        e.emit_map(self.len(), |e| {\n+            let mut i = 0;\n+            for (key, val) in self {\n+                e.emit_map_elt_key(i, |e| key.encode(e))?;\n+                e.emit_map_elt_val(i, |e| val.encode(e))?;\n+                i += 1;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<K, V, S> Decodable for indexmap::IndexMap<K, V, S>\n+    where K: Decodable + Hash + Eq,\n+          V: Decodable,\n+          S: BuildHasher + Default,\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<indexmap::IndexMap<K, V, S>, D::Error> {\n+        d.read_map(|d, len| {\n+            let state = Default::default();\n+            let mut map = indexmap::IndexMap::with_capacity_and_hasher(len, state);\n+            for i in 0..len {\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d))?;\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d))?;\n+                map.insert(key, val);\n+            }\n+            Ok(map)\n+        })\n+    }\n+}\n+\n+impl<T, S> Encodable for indexmap::IndexSet<T, S>\n+    where T: Encodable + Hash + Eq,\n+          S: BuildHasher,\n+{\n+    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n+        s.emit_seq(self.len(), |s| {\n+            let mut i = 0;\n+            for e in self {\n+                s.emit_seq_elt(i, |s| e.encode(s))?;\n+                i += 1;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<T, S> Decodable for indexmap::IndexSet<T, S>\n+    where T: Decodable + Hash + Eq,\n+          S: BuildHasher + Default,\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<indexmap::IndexSet<T, S>, D::Error> {\n+        d.read_seq(|d, len| {\n+            let state = Default::default();\n+            let mut set = indexmap::IndexSet::with_capacity_and_hasher(len, state);\n+            for i in 0..len {\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            }\n+            Ok(set)\n+        })\n+    }\n+}\n+\n impl<T: Encodable> Encodable for Rc<[T]> {\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {"}, {"sha": "f22b7da811949293aaea9b318b6dbdede47f29a0", "filename": "src/test/ui/borrowck/borrowck-closures-use-after-free.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-use-after-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-use-after-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-use-after-free.stderr?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -4,7 +4,7 @@ error[E0502]: cannot borrow `*ptr` as immutable because it is also borrowed as m\n LL |   let mut test = |foo: &Foo| {\n    |                  ----------- mutable borrow occurs here\n LL |     ptr = box Foo { x: ptr.x + 1 };\n-   |     --- first borrow occurs due to use of `ptr` in closure\n+   |                        --- first borrow occurs due to use of `ptr` in closure\n LL |   };\n LL |   test(&*ptr);\n    |   ---- ^^^^^ immutable borrow occurs here"}, {"sha": "dfe7b3f6b5f9c74262ad17deb52589e915479832", "filename": "src/test/ui/issues/issue-11192.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Ftest%2Fui%2Fissues%2Fissue-11192.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Ftest%2Fui%2Fissues%2Fissue-11192.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11192.stderr?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -5,7 +5,7 @@ LL |     let mut test = |foo: &Foo| {\n    |                    ----------- mutable borrow occurs here\n LL |         println!(\"access {}\", foo.x);\n LL |         ptr = box Foo { x: ptr.x + 1 };\n-   |         --- first borrow occurs due to use of `ptr` in closure\n+   |                            --- first borrow occurs due to use of `ptr` in closure\n ...\n LL |     test(&*ptr);\n    |     ---- ^^^^^ immutable borrow occurs here"}, {"sha": "186f25a3c89db100d25a30b842221820b31d436f", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -7,11 +7,11 @@ LL |             let mut closure1 = || p = &y;\n    = note: defining type: DefId(0:14 ~ escape_upvar_nested[317d]::test[0]::{{closure}}[0]::{{closure}}[0]) with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               &'_#1r mut &'_#2r i32,\n-               &'_#3r i32,\n+               &'_#1r i32,\n+               &'_#2r mut &'_#3r i32,\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#3r: '_#2r\n+   = note: where '_#1r: '_#3r\n \n note: External requirements\n   --> $DIR/escape-upvar-nested.rs:20:27\n@@ -26,11 +26,11 @@ LL | |         };\n    = note: defining type: DefId(0:13 ~ escape_upvar_nested[317d]::test[0]::{{closure}}[0]) with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               &'_#1r mut &'_#2r i32,\n-               &'_#3r i32,\n+               &'_#1r i32,\n+               &'_#2r mut &'_#3r i32,\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#3r: '_#2r\n+   = note: where '_#1r: '_#3r\n \n note: No external requirements\n   --> $DIR/escape-upvar-nested.rs:13:1"}, {"sha": "0df2c0f69a71b32757f0718c038bb5cf594eb566", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -7,11 +7,11 @@ LL |         let mut closure = || p = &y;\n    = note: defining type: DefId(0:13 ~ escape_upvar_ref[317d]::test[0]::{{closure}}[0]) with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               &'_#1r mut &'_#2r i32,\n-               &'_#3r i32,\n+               &'_#1r i32,\n+               &'_#2r mut &'_#3r i32,\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#3r: '_#2r\n+   = note: where '_#1r: '_#3r\n \n note: No external requirements\n   --> $DIR/escape-upvar-ref.rs:17:1"}, {"sha": "7922cb14eeca8c12c980d30676fccbd1661a8157", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=4c7bb8b0d9d3c5149c8ad12b59604ccb57e8accc", "patch": "@@ -92,6 +92,7 @@ const WHITELIST: &[Crate<'_>] = &[\n     Crate(\"fuchsia-zircon-sys\"),\n     Crate(\"getopts\"),\n     Crate(\"humantime\"),\n+    Crate(\"indexmap\"),\n     Crate(\"itertools\"),\n     Crate(\"jobserver\"),\n     Crate(\"kernel32-sys\"),"}]}