{"sha": "8a374f2827a222322a631e313cd8fd8d9ba34932", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMzc0ZjI4MjdhMjIyMzIyYTYzMWUzMTNjZDhmZDhkOWJhMzQ5MzI=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-08T08:09:52Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-21T07:47:37Z"}, "message": "Add some f32 and f64 inherent methods in libcore\n\n\u2026 previously in the unstable core::num::Float trait.\n\nPer https://github.com/rust-lang/rust/issues/32110#issuecomment-379503183,\nthe `abs`, `signum`, and `powi` methods are *not* included for now\nsince they rely on LLVM intrinsics and we haven\u2019t determined yet whether\nthose instrinsics lower to calls to libm functions on any platform.", "tree": {"sha": "c1f1b8351580fe7a4d20dabc321f299fa01c54c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1f1b8351580fe7a4d20dabc321f299fa01c54c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a374f2827a222322a631e313cd8fd8d9ba34932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a374f2827a222322a631e313cd8fd8d9ba34932", "html_url": "https://github.com/rust-lang/rust/commit/8a374f2827a222322a631e313cd8fd8d9ba34932", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a374f2827a222322a631e313cd8fd8d9ba34932/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0705bf033363757a8a2901cd1a7bd76f0fea820", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0705bf033363757a8a2901cd1a7bd76f0fea820", "html_url": "https://github.com/rust-lang/rust/commit/f0705bf033363757a8a2901cd1a7bd76f0fea820"}], "stats": {"total": 1170, "additions": 611, "deletions": 559}, "files": [{"sha": "b184404c15bfd6c050b99252db3c15e41b2d00a2", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=8a374f2827a222322a631e313cd8fd8d9ba34932", "patch": "@@ -74,6 +74,7 @@ use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::marker::PhantomData;\n use core::mem;\n #[cfg(not(test))]\n+#[cfg(stage0)]\n use core::num::Float;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds};"}, {"sha": "215886069f537d60ce65ff069392b26ea33174a9", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=8a374f2827a222322a631e313cd8fd8d9ba34932", "patch": "@@ -71,6 +71,7 @@\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n #![feature(const_fn)]\n+#![feature(core_float)]\n #![feature(custom_attribute)]\n #![feature(doc_cfg)]\n #![feature(doc_spotlight)]"}, {"sha": "0edf63bce1239a0c899f3f0d8ee1931ab0ec0aff", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=8a374f2827a222322a631e313cd8fd8d9ba34932", "patch": "@@ -20,6 +20,7 @@\n use intrinsics;\n use mem;\n use num::Float;\n+#[cfg(not(stage0))] use num::FpCategory;\n use num::FpCategory as Fp;\n \n /// The radix or base of the internal representation of `f32`.\n@@ -292,3 +293,286 @@ impl Float for f32 {\n         unsafe { mem::transmute(v) }\n     }\n }\n+\n+// FIXME: remove (inline) this macro and the Float trait\n+// when updating to a bootstrap compiler that has the new lang items.\n+#[cfg_attr(stage0, macro_export)]\n+#[unstable(feature = \"core_float\", issue = \"32110\")]\n+macro_rules! f32_core_methods { () => {\n+    /// Returns `true` if this value is `NaN` and false otherwise.\n+    ///\n+    /// ```\n+    /// use std::f32;\n+    ///\n+    /// let nan = f32::NAN;\n+    /// let f = 7.0_f32;\n+    ///\n+    /// assert!(nan.is_nan());\n+    /// assert!(!f.is_nan());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_nan(self) -> bool { Float::is_nan(self) }\n+\n+    /// Returns `true` if this value is positive infinity or negative infinity and\n+    /// false otherwise.\n+    ///\n+    /// ```\n+    /// use std::f32;\n+    ///\n+    /// let f = 7.0f32;\n+    /// let inf = f32::INFINITY;\n+    /// let neg_inf = f32::NEG_INFINITY;\n+    /// let nan = f32::NAN;\n+    ///\n+    /// assert!(!f.is_infinite());\n+    /// assert!(!nan.is_infinite());\n+    ///\n+    /// assert!(inf.is_infinite());\n+    /// assert!(neg_inf.is_infinite());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_infinite(self) -> bool { Float::is_infinite(self) }\n+\n+    /// Returns `true` if this number is neither infinite nor `NaN`.\n+    ///\n+    /// ```\n+    /// use std::f32;\n+    ///\n+    /// let f = 7.0f32;\n+    /// let inf = f32::INFINITY;\n+    /// let neg_inf = f32::NEG_INFINITY;\n+    /// let nan = f32::NAN;\n+    ///\n+    /// assert!(f.is_finite());\n+    ///\n+    /// assert!(!nan.is_finite());\n+    /// assert!(!inf.is_finite());\n+    /// assert!(!neg_inf.is_finite());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_finite(self) -> bool { Float::is_finite(self) }\n+\n+    /// Returns `true` if the number is neither zero, infinite,\n+    /// [subnormal][subnormal], or `NaN`.\n+    ///\n+    /// ```\n+    /// use std::f32;\n+    ///\n+    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n+    /// let max = f32::MAX;\n+    /// let lower_than_min = 1.0e-40_f32;\n+    /// let zero = 0.0_f32;\n+    ///\n+    /// assert!(min.is_normal());\n+    /// assert!(max.is_normal());\n+    ///\n+    /// assert!(!zero.is_normal());\n+    /// assert!(!f32::NAN.is_normal());\n+    /// assert!(!f32::INFINITY.is_normal());\n+    /// // Values between `0` and `min` are Subnormal.\n+    /// assert!(!lower_than_min.is_normal());\n+    /// ```\n+    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_normal(self) -> bool { Float::is_normal(self) }\n+\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n+    ///\n+    /// ```\n+    /// use std::num::FpCategory;\n+    /// use std::f32;\n+    ///\n+    /// let num = 12.4_f32;\n+    /// let inf = f32::INFINITY;\n+    ///\n+    /// assert_eq!(num.classify(), FpCategory::Normal);\n+    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn classify(self) -> FpCategory { Float::classify(self) }\n+\n+    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// positive sign bit and positive infinity.\n+    ///\n+    /// ```\n+    /// let f = 7.0_f32;\n+    /// let g = -7.0_f32;\n+    ///\n+    /// assert!(f.is_sign_positive());\n+    /// assert!(!g.is_sign_positive());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_sign_positive(self) -> bool { Float::is_sign_positive(self) }\n+\n+    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// negative sign bit and negative infinity.\n+    ///\n+    /// ```\n+    /// let f = 7.0f32;\n+    /// let g = -7.0f32;\n+    ///\n+    /// assert!(!f.is_sign_negative());\n+    /// assert!(g.is_sign_negative());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_sign_negative(self) -> bool { Float::is_sign_negative(self) }\n+\n+    /// Takes the reciprocal (inverse) of a number, `1/x`.\n+    ///\n+    /// ```\n+    /// use std::f32;\n+    ///\n+    /// let x = 2.0_f32;\n+    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    ///\n+    /// assert!(abs_difference <= f32::EPSILON);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn recip(self) -> f32 { Float::recip(self) }\n+\n+    /// Converts radians to degrees.\n+    ///\n+    /// ```\n+    /// use std::f32::{self, consts};\n+    ///\n+    /// let angle = consts::PI;\n+    ///\n+    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n+    ///\n+    /// assert!(abs_difference <= f32::EPSILON);\n+    /// ```\n+    #[stable(feature = \"f32_deg_rad_conversions\", since=\"1.7.0\")]\n+    #[inline]\n+    pub fn to_degrees(self) -> f32 { Float::to_degrees(self) }\n+\n+    /// Converts degrees to radians.\n+    ///\n+    /// ```\n+    /// use std::f32::{self, consts};\n+    ///\n+    /// let angle = 180.0f32;\n+    ///\n+    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n+    ///\n+    /// assert!(abs_difference <= f32::EPSILON);\n+    /// ```\n+    #[stable(feature = \"f32_deg_rad_conversions\", since=\"1.7.0\")]\n+    #[inline]\n+    pub fn to_radians(self) -> f32 { Float::to_radians(self) }\n+\n+    /// Returns the maximum of the two numbers.\n+    ///\n+    /// ```\n+    /// let x = 1.0f32;\n+    /// let y = 2.0f32;\n+    ///\n+    /// assert_eq!(x.max(y), y);\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn max(self, other: f32) -> f32 {\n+        Float::max(self, other)\n+    }\n+\n+    /// Returns the minimum of the two numbers.\n+    ///\n+    /// ```\n+    /// let x = 1.0f32;\n+    /// let y = 2.0f32;\n+    ///\n+    /// assert_eq!(x.min(y), x);\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn min(self, other: f32) -> f32 {\n+        Float::min(self, other)\n+    }\n+\n+    /// Raw transmutation to `u32`.\n+    ///\n+    /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms.\n+    ///\n+    /// See `from_bits` for some discussion of the portability of this operation\n+    /// (there are almost no issues).\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_ne!((1f32).to_bits(), 1f32 as u32); // to_bits() is not casting!\n+    /// assert_eq!((12.5f32).to_bits(), 0x41480000);\n+    ///\n+    /// ```\n+    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn to_bits(self) -> u32 {\n+        Float::to_bits(self)\n+    }\n+\n+    /// Raw transmutation from `u32`.\n+    ///\n+    /// This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n+    /// It turns out this is incredibly portable, for two reasons:\n+    ///\n+    /// * Floats and Ints have the same endianness on all supported platforms.\n+    /// * IEEE-754 very precisely specifies the bit layout of floats.\n+    ///\n+    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n+    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n+    /// (notably x86 and ARM) picked the interpretation that was ultimately\n+    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n+    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n+    ///\n+    /// Rather than trying to preserve signaling-ness cross-platform, this\n+    /// implementation favours preserving the exact bits. This means that\n+    /// any payloads encoded in NaNs will be preserved even if the result of\n+    /// this method is sent over the network from an x86 machine to a MIPS one.\n+    ///\n+    /// If the results of this method are only manipulated by the same\n+    /// architecture that produced them, then there is no portability concern.\n+    ///\n+    /// If the input isn't NaN, then there is no portability concern.\n+    ///\n+    /// If you don't care about signalingness (very likely), then there is no\n+    /// portability concern.\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::f32;\n+    /// let v = f32::from_bits(0x41480000);\n+    /// let difference = (v - 12.5).abs();\n+    /// assert!(difference <= 1e-5);\n+    /// ```\n+    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn from_bits(v: u32) -> Self {\n+        Float::from_bits(v)\n+    }\n+}}\n+\n+#[lang = \"f32\"]\n+#[cfg(not(test))]\n+#[cfg(not(stage0))]\n+impl f32 {\n+    f32_core_methods!();\n+}"}, {"sha": "38f3d63ea8d5a1376b98c5c0c3ae4896a591262b", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 295, "deletions": 1, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=8a374f2827a222322a631e313cd8fd8d9ba34932", "patch": "@@ -19,8 +19,9 @@\n \n use intrinsics;\n use mem;\n-use num::FpCategory as Fp;\n use num::Float;\n+#[cfg(not(stage0))] use num::FpCategory;\n+use num::FpCategory as Fp;\n \n /// The radix or base of the internal representation of `f64`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -291,3 +292,296 @@ impl Float for f64 {\n         unsafe { mem::transmute(v) }\n     }\n }\n+\n+// FIXME: remove (inline) this macro and the Float trait\n+// when updating to a bootstrap compiler that has the new lang items.\n+#[cfg_attr(stage0, macro_export)]\n+#[unstable(feature = \"core_float\", issue = \"32110\")]\n+macro_rules! f64_core_methods { () => {\n+    /// Returns `true` if this value is `NaN` and false otherwise.\n+    ///\n+    /// ```\n+    /// use std::f64;\n+    ///\n+    /// let nan = f64::NAN;\n+    /// let f = 7.0_f64;\n+    ///\n+    /// assert!(nan.is_nan());\n+    /// assert!(!f.is_nan());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_nan(self) -> bool { Float::is_nan(self) }\n+\n+    /// Returns `true` if this value is positive infinity or negative infinity and\n+    /// false otherwise.\n+    ///\n+    /// ```\n+    /// use std::f64;\n+    ///\n+    /// let f = 7.0f64;\n+    /// let inf = f64::INFINITY;\n+    /// let neg_inf = f64::NEG_INFINITY;\n+    /// let nan = f64::NAN;\n+    ///\n+    /// assert!(!f.is_infinite());\n+    /// assert!(!nan.is_infinite());\n+    ///\n+    /// assert!(inf.is_infinite());\n+    /// assert!(neg_inf.is_infinite());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_infinite(self) -> bool { Float::is_infinite(self) }\n+\n+    /// Returns `true` if this number is neither infinite nor `NaN`.\n+    ///\n+    /// ```\n+    /// use std::f64;\n+    ///\n+    /// let f = 7.0f64;\n+    /// let inf: f64 = f64::INFINITY;\n+    /// let neg_inf: f64 = f64::NEG_INFINITY;\n+    /// let nan: f64 = f64::NAN;\n+    ///\n+    /// assert!(f.is_finite());\n+    ///\n+    /// assert!(!nan.is_finite());\n+    /// assert!(!inf.is_finite());\n+    /// assert!(!neg_inf.is_finite());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_finite(self) -> bool { Float::is_finite(self) }\n+\n+    /// Returns `true` if the number is neither zero, infinite,\n+    /// [subnormal][subnormal], or `NaN`.\n+    ///\n+    /// ```\n+    /// use std::f64;\n+    ///\n+    /// let min = f64::MIN_POSITIVE; // 2.2250738585072014e-308f64\n+    /// let max = f64::MAX;\n+    /// let lower_than_min = 1.0e-308_f64;\n+    /// let zero = 0.0f64;\n+    ///\n+    /// assert!(min.is_normal());\n+    /// assert!(max.is_normal());\n+    ///\n+    /// assert!(!zero.is_normal());\n+    /// assert!(!f64::NAN.is_normal());\n+    /// assert!(!f64::INFINITY.is_normal());\n+    /// // Values between `0` and `min` are Subnormal.\n+    /// assert!(!lower_than_min.is_normal());\n+    /// ```\n+    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_normal(self) -> bool { Float::is_normal(self) }\n+\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n+    ///\n+    /// ```\n+    /// use std::num::FpCategory;\n+    /// use std::f64;\n+    ///\n+    /// let num = 12.4_f64;\n+    /// let inf = f64::INFINITY;\n+    ///\n+    /// assert_eq!(num.classify(), FpCategory::Normal);\n+    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn classify(self) -> FpCategory { Float::classify(self) }\n+\n+    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// positive sign bit and positive infinity.\n+    ///\n+    /// ```\n+    /// let f = 7.0_f64;\n+    /// let g = -7.0_f64;\n+    ///\n+    /// assert!(f.is_sign_positive());\n+    /// assert!(!g.is_sign_positive());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_sign_positive(self) -> bool { Float::is_sign_positive(self) }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")]\n+    #[inline]\n+    #[doc(hidden)]\n+    pub fn is_positive(self) -> bool { Float::is_sign_positive(self) }\n+\n+    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// negative sign bit and negative infinity.\n+    ///\n+    /// ```\n+    /// let f = 7.0_f64;\n+    /// let g = -7.0_f64;\n+    ///\n+    /// assert!(!f.is_sign_negative());\n+    /// assert!(g.is_sign_negative());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_sign_negative(self) -> bool { Float::is_sign_negative(self) }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")]\n+    #[inline]\n+    #[doc(hidden)]\n+    pub fn is_negative(self) -> bool { Float::is_sign_negative(self) }\n+\n+    /// Takes the reciprocal (inverse) of a number, `1/x`.\n+    ///\n+    /// ```\n+    /// let x = 2.0_f64;\n+    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn recip(self) -> f64 { Float::recip(self) }\n+\n+    /// Converts radians to degrees.\n+    ///\n+    /// ```\n+    /// use std::f64::consts;\n+    ///\n+    /// let angle = consts::PI;\n+    ///\n+    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn to_degrees(self) -> f64 { Float::to_degrees(self) }\n+\n+    /// Converts degrees to radians.\n+    ///\n+    /// ```\n+    /// use std::f64::consts;\n+    ///\n+    /// let angle = 180.0_f64;\n+    ///\n+    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn to_radians(self) -> f64 { Float::to_radians(self) }\n+\n+    /// Returns the maximum of the two numbers.\n+    ///\n+    /// ```\n+    /// let x = 1.0_f64;\n+    /// let y = 2.0_f64;\n+    ///\n+    /// assert_eq!(x.max(y), y);\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn max(self, other: f64) -> f64 {\n+        Float::max(self, other)\n+    }\n+\n+    /// Returns the minimum of the two numbers.\n+    ///\n+    /// ```\n+    /// let x = 1.0_f64;\n+    /// let y = 2.0_f64;\n+    ///\n+    /// assert_eq!(x.min(y), x);\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn min(self, other: f64) -> f64 {\n+        Float::min(self, other)\n+    }\n+\n+    /// Raw transmutation to `u64`.\n+    ///\n+    /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms.\n+    ///\n+    /// See `from_bits` for some discussion of the portability of this operation\n+    /// (there are almost no issues).\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert!((1f64).to_bits() != 1f64 as u64); // to_bits() is not casting!\n+    /// assert_eq!((12.5f64).to_bits(), 0x4029000000000000);\n+    ///\n+    /// ```\n+    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn to_bits(self) -> u64 {\n+        Float::to_bits(self)\n+    }\n+\n+    /// Raw transmutation from `u64`.\n+    ///\n+    /// This is currently identical to `transmute::<u64, f64>(v)` on all platforms.\n+    /// It turns out this is incredibly portable, for two reasons:\n+    ///\n+    /// * Floats and Ints have the same endianness on all supported platforms.\n+    /// * IEEE-754 very precisely specifies the bit layout of floats.\n+    ///\n+    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n+    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n+    /// (notably x86 and ARM) picked the interpretation that was ultimately\n+    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n+    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n+    ///\n+    /// Rather than trying to preserve signaling-ness cross-platform, this\n+    /// implementation favours preserving the exact bits. This means that\n+    /// any payloads encoded in NaNs will be preserved even if the result of\n+    /// this method is sent over the network from an x86 machine to a MIPS one.\n+    ///\n+    /// If the results of this method are only manipulated by the same\n+    /// architecture that produced them, then there is no portability concern.\n+    ///\n+    /// If the input isn't NaN, then there is no portability concern.\n+    ///\n+    /// If you don't care about signalingness (very likely), then there is no\n+    /// portability concern.\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::f64;\n+    /// let v = f64::from_bits(0x4029000000000000);\n+    /// let difference = (v - 12.5).abs();\n+    /// assert!(difference <= 1e-5);\n+    /// ```\n+    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn from_bits(v: u64) -> Self {\n+        Float::from_bits(v)\n+    }\n+}}\n+\n+#[lang = \"f64\"]\n+#[cfg(not(test))]\n+#[cfg(not(stage0))]\n+impl f64 {\n+    f64_core_methods!();\n+}"}, {"sha": "c7412dbeeb368d75bd3d3a692c2a8ef806109971", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8a374f2827a222322a631e313cd8fd8d9ba34932", "patch": "@@ -233,6 +233,8 @@ language_item_table! {\n     UsizeImplItem,                   \"usize\",                   usize_impl;\n     F32ImplItem,                     \"f32\",                     f32_impl;\n     F64ImplItem,                     \"f64\",                     f64_impl;\n+    F32RuntimeImplItem,              \"f32_runtime\",             f32_runtime_impl;\n+    F64RuntimeImplItem,              \"f64_runtime\",             f64_runtime_impl;\n \n     SizedTraitLangItem,              \"sized\",                   sized_trait;\n     UnsizeTraitLangItem,             \"unsize\",                  unsize_trait;"}, {"sha": "073f36b9f3c505b2000ad42f152211d33d602ce9", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=8a374f2827a222322a631e313cd8fd8d9ba34932", "patch": "@@ -547,10 +547,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             ty::TyFloat(ast::FloatTy::F32) => {\n                 let lang_def_id = lang_items.f32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n+\n+                let lang_def_id = lang_items.f32_runtime_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyFloat(ast::FloatTy::F64) => {\n                 let lang_def_id = lang_items.f64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n+\n+                let lang_def_id = lang_items.f64_runtime_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             _ => {}\n         }"}, {"sha": "532f1da4f301b4201ed6aa7b9b010baa59144631", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=8a374f2827a222322a631e313cd8fd8d9ba34932", "patch": "@@ -258,15 +258,15 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n             ty::TyFloat(ast::FloatTy::F32) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.f32_impl(),\n-                                          None,\n+                                          lang_items.f32_runtime_impl(),\n                                           \"f32\",\n                                           \"f32\",\n                                           item.span);\n             }\n             ty::TyFloat(ast::FloatTy::F64) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.f64_impl(),\n-                                          None,\n+                                          lang_items.f64_runtime_impl(),\n                                           \"f64\",\n                                           \"f64\",\n                                           item.span);"}, {"sha": "23e0c2625eeeb6b0607d2d7fa8d63cdc1211e251", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=8a374f2827a222322a631e313cd8fd8d9ba34932", "patch": "@@ -286,6 +286,8 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n         lang_items.u128_impl(),\n         lang_items.f32_impl(),\n         lang_items.f64_impl(),\n+        lang_items.f32_runtime_impl(),\n+        lang_items.f64_runtime_impl(),\n         lang_items.char_impl(),\n         lang_items.str_impl(),\n         lang_items.slice_impl(),"}, {"sha": "82f4192de1938952bfd39261ba4dac7a70070813", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 9, "deletions": 274, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=8a374f2827a222322a631e313cd8fd8d9ba34932", "patch": "@@ -19,10 +19,11 @@\n #![allow(missing_docs)]\n \n #[cfg(not(test))]\n-use core::num;\n+use core::num::Float;\n #[cfg(not(test))]\n use intrinsics;\n #[cfg(not(test))]\n+#[cfg(stage0)]\n use num::FpCategory;\n #[cfg(not(test))]\n use sys::cmath;\n@@ -39,106 +40,11 @@ pub use core::f32::{MIN, MIN_POSITIVE, MAX};\n pub use core::f32::consts;\n \n #[cfg(not(test))]\n-#[lang = \"f32\"]\n+#[cfg_attr(stage0, lang = \"f32\")]\n+#[cfg_attr(not(stage0), lang = \"f32_runtime\")]\n impl f32 {\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n-    ///\n-    /// ```\n-    /// use std::f32;\n-    ///\n-    /// let nan = f32::NAN;\n-    /// let f = 7.0_f32;\n-    ///\n-    /// assert!(nan.is_nan());\n-    /// assert!(!f.is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_nan(self) -> bool { num::Float::is_nan(self) }\n-\n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n-    ///\n-    /// ```\n-    /// use std::f32;\n-    ///\n-    /// let f = 7.0f32;\n-    /// let inf = f32::INFINITY;\n-    /// let neg_inf = f32::NEG_INFINITY;\n-    /// let nan = f32::NAN;\n-    ///\n-    /// assert!(!f.is_infinite());\n-    /// assert!(!nan.is_infinite());\n-    ///\n-    /// assert!(inf.is_infinite());\n-    /// assert!(neg_inf.is_infinite());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n-\n-    /// Returns `true` if this number is neither infinite nor `NaN`.\n-    ///\n-    /// ```\n-    /// use std::f32;\n-    ///\n-    /// let f = 7.0f32;\n-    /// let inf = f32::INFINITY;\n-    /// let neg_inf = f32::NEG_INFINITY;\n-    /// let nan = f32::NAN;\n-    ///\n-    /// assert!(f.is_finite());\n-    ///\n-    /// assert!(!nan.is_finite());\n-    /// assert!(!inf.is_finite());\n-    /// assert!(!neg_inf.is_finite());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_finite(self) -> bool { num::Float::is_finite(self) }\n-\n-    /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal][subnormal], or `NaN`.\n-    ///\n-    /// ```\n-    /// use std::f32;\n-    ///\n-    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n-    /// let max = f32::MAX;\n-    /// let lower_than_min = 1.0e-40_f32;\n-    /// let zero = 0.0_f32;\n-    ///\n-    /// assert!(min.is_normal());\n-    /// assert!(max.is_normal());\n-    ///\n-    /// assert!(!zero.is_normal());\n-    /// assert!(!f32::NAN.is_normal());\n-    /// assert!(!f32::INFINITY.is_normal());\n-    /// // Values between `0` and `min` are Subnormal.\n-    /// assert!(!lower_than_min.is_normal());\n-    /// ```\n-    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_normal(self) -> bool { num::Float::is_normal(self) }\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    ///\n-    /// ```\n-    /// use std::num::FpCategory;\n-    /// use std::f32;\n-    ///\n-    /// let num = 12.4_f32;\n-    /// let inf = f32::INFINITY;\n-    ///\n-    /// assert_eq!(num.classify(), FpCategory::Normal);\n-    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn classify(self) -> FpCategory { num::Float::classify(self) }\n+    #[cfg(stage0)]\n+    f32_core_methods!();\n \n     /// Returns the largest integer less than or equal to a number.\n     ///\n@@ -257,7 +163,7 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn abs(self) -> f32 { num::Float::abs(self) }\n+    pub fn abs(self) -> f32 { Float::abs(self) }\n \n     /// Returns a number that represents the sign of `self`.\n     ///\n@@ -277,35 +183,7 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn signum(self) -> f32 { num::Float::signum(self) }\n-\n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n-    /// positive sign bit and positive infinity.\n-    ///\n-    /// ```\n-    /// let f = 7.0_f32;\n-    /// let g = -7.0_f32;\n-    ///\n-    /// assert!(f.is_sign_positive());\n-    /// assert!(!g.is_sign_positive());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_sign_positive(self) -> bool { num::Float::is_sign_positive(self) }\n-\n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n-    /// negative sign bit and negative infinity.\n-    ///\n-    /// ```\n-    /// let f = 7.0f32;\n-    /// let g = -7.0f32;\n-    ///\n-    /// assert!(!f.is_sign_negative());\n-    /// assert!(g.is_sign_negative());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_sign_negative(self) -> bool { num::Float::is_sign_negative(self) }\n+    pub fn signum(self) -> f32 { Float::signum(self) }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n@@ -380,20 +258,6 @@ impl f32 {\n     }\n \n \n-    /// Takes the reciprocal (inverse) of a number, `1/x`.\n-    ///\n-    /// ```\n-    /// use std::f32;\n-    ///\n-    /// let x = 2.0_f32;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn recip(self) -> f32 { num::Float::recip(self) }\n-\n     /// Raises a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n@@ -408,7 +272,7 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn powi(self, n: i32) -> f32 { num::Float::powi(self, n) }\n+    pub fn powi(self, n: i32) -> f32 { Float::powi(self, n) }\n \n     /// Raises a number to a floating point power.\n     ///\n@@ -584,68 +448,6 @@ impl f32 {\n         return unsafe { intrinsics::log10f32(self) };\n     }\n \n-    /// Converts radians to degrees.\n-    ///\n-    /// ```\n-    /// use std::f32::{self, consts};\n-    ///\n-    /// let angle = consts::PI;\n-    ///\n-    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    #[stable(feature = \"f32_deg_rad_conversions\", since=\"1.7.0\")]\n-    #[inline]\n-    pub fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }\n-\n-    /// Converts degrees to radians.\n-    ///\n-    /// ```\n-    /// use std::f32::{self, consts};\n-    ///\n-    /// let angle = 180.0f32;\n-    ///\n-    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    #[stable(feature = \"f32_deg_rad_conversions\", since=\"1.7.0\")]\n-    #[inline]\n-    pub fn to_radians(self) -> f32 { num::Float::to_radians(self) }\n-\n-    /// Returns the maximum of the two numbers.\n-    ///\n-    /// ```\n-    /// let x = 1.0f32;\n-    /// let y = 2.0f32;\n-    ///\n-    /// assert_eq!(x.max(y), y);\n-    /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn max(self, other: f32) -> f32 {\n-        num::Float::max(self, other)\n-    }\n-\n-    /// Returns the minimum of the two numbers.\n-    ///\n-    /// ```\n-    /// let x = 1.0f32;\n-    /// let y = 2.0f32;\n-    ///\n-    /// assert_eq!(x.min(y), x);\n-    /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn min(self, other: f32) -> f32 {\n-        num::Float::min(self, other)\n-    }\n-\n     /// The positive difference of two numbers.\n     ///\n     /// * If `self <= other`: `0:0`\n@@ -1046,73 +848,6 @@ impl f32 {\n     pub fn atanh(self) -> f32 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n-\n-    /// Raw transmutation to `u32`.\n-    ///\n-    /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms.\n-    ///\n-    /// See `from_bits` for some discussion of the portability of this operation\n-    /// (there are almost no issues).\n-    ///\n-    /// Note that this function is distinct from `as` casting, which attempts to\n-    /// preserve the *numeric* value, and not the bitwise value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_ne!((1f32).to_bits(), 1f32 as u32); // to_bits() is not casting!\n-    /// assert_eq!((12.5f32).to_bits(), 0x41480000);\n-    ///\n-    /// ```\n-    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn to_bits(self) -> u32 {\n-        num::Float::to_bits(self)\n-    }\n-\n-    /// Raw transmutation from `u32`.\n-    ///\n-    /// This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n-    /// It turns out this is incredibly portable, for two reasons:\n-    ///\n-    /// * Floats and Ints have the same endianness on all supported platforms.\n-    /// * IEEE-754 very precisely specifies the bit layout of floats.\n-    ///\n-    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n-    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n-    /// (notably x86 and ARM) picked the interpretation that was ultimately\n-    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n-    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n-    ///\n-    /// Rather than trying to preserve signaling-ness cross-platform, this\n-    /// implementation favours preserving the exact bits. This means that\n-    /// any payloads encoded in NaNs will be preserved even if the result of\n-    /// this method is sent over the network from an x86 machine to a MIPS one.\n-    ///\n-    /// If the results of this method are only manipulated by the same\n-    /// architecture that produced them, then there is no portability concern.\n-    ///\n-    /// If the input isn't NaN, then there is no portability concern.\n-    ///\n-    /// If you don't care about signalingness (very likely), then there is no\n-    /// portability concern.\n-    ///\n-    /// Note that this function is distinct from `as` casting, which attempts to\n-    /// preserve the *numeric* value, and not the bitwise value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::f32;\n-    /// let v = f32::from_bits(0x41480000);\n-    /// let difference = (v - 12.5).abs();\n-    /// assert!(difference <= 1e-5);\n-    /// ```\n-    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn from_bits(v: u32) -> Self {\n-        num::Float::from_bits(v)\n-    }\n }\n \n #[cfg(test)]"}, {"sha": "d4a8f700a902d2acfbbce55771551d8cd1c85a09", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 9, "deletions": 282, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a374f2827a222322a631e313cd8fd8d9ba34932/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=8a374f2827a222322a631e313cd8fd8d9ba34932", "patch": "@@ -19,10 +19,11 @@\n #![allow(missing_docs)]\n \n #[cfg(not(test))]\n-use core::num;\n+use core::num::Float;\n #[cfg(not(test))]\n use intrinsics;\n #[cfg(not(test))]\n+#[cfg(stage0)]\n use num::FpCategory;\n #[cfg(not(test))]\n use sys::cmath;\n@@ -39,106 +40,11 @@ pub use core::f64::{MIN, MIN_POSITIVE, MAX};\n pub use core::f64::consts;\n \n #[cfg(not(test))]\n-#[lang = \"f64\"]\n+#[cfg_attr(stage0, lang = \"f64\")]\n+#[cfg_attr(not(stage0), lang = \"f64_runtime\")]\n impl f64 {\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n-    ///\n-    /// ```\n-    /// use std::f64;\n-    ///\n-    /// let nan = f64::NAN;\n-    /// let f = 7.0_f64;\n-    ///\n-    /// assert!(nan.is_nan());\n-    /// assert!(!f.is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_nan(self) -> bool { num::Float::is_nan(self) }\n-\n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n-    ///\n-    /// ```\n-    /// use std::f64;\n-    ///\n-    /// let f = 7.0f64;\n-    /// let inf = f64::INFINITY;\n-    /// let neg_inf = f64::NEG_INFINITY;\n-    /// let nan = f64::NAN;\n-    ///\n-    /// assert!(!f.is_infinite());\n-    /// assert!(!nan.is_infinite());\n-    ///\n-    /// assert!(inf.is_infinite());\n-    /// assert!(neg_inf.is_infinite());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n-\n-    /// Returns `true` if this number is neither infinite nor `NaN`.\n-    ///\n-    /// ```\n-    /// use std::f64;\n-    ///\n-    /// let f = 7.0f64;\n-    /// let inf: f64 = f64::INFINITY;\n-    /// let neg_inf: f64 = f64::NEG_INFINITY;\n-    /// let nan: f64 = f64::NAN;\n-    ///\n-    /// assert!(f.is_finite());\n-    ///\n-    /// assert!(!nan.is_finite());\n-    /// assert!(!inf.is_finite());\n-    /// assert!(!neg_inf.is_finite());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_finite(self) -> bool { num::Float::is_finite(self) }\n-\n-    /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal][subnormal], or `NaN`.\n-    ///\n-    /// ```\n-    /// use std::f64;\n-    ///\n-    /// let min = f64::MIN_POSITIVE; // 2.2250738585072014e-308f64\n-    /// let max = f64::MAX;\n-    /// let lower_than_min = 1.0e-308_f64;\n-    /// let zero = 0.0f64;\n-    ///\n-    /// assert!(min.is_normal());\n-    /// assert!(max.is_normal());\n-    ///\n-    /// assert!(!zero.is_normal());\n-    /// assert!(!f64::NAN.is_normal());\n-    /// assert!(!f64::INFINITY.is_normal());\n-    /// // Values between `0` and `min` are Subnormal.\n-    /// assert!(!lower_than_min.is_normal());\n-    /// ```\n-    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_normal(self) -> bool { num::Float::is_normal(self) }\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    ///\n-    /// ```\n-    /// use std::num::FpCategory;\n-    /// use std::f64;\n-    ///\n-    /// let num = 12.4_f64;\n-    /// let inf = f64::INFINITY;\n-    ///\n-    /// assert_eq!(num.classify(), FpCategory::Normal);\n-    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn classify(self) -> FpCategory { num::Float::classify(self) }\n+    #[cfg(stage0)]\n+    f64_core_methods!();\n \n     /// Returns the largest integer less than or equal to a number.\n     ///\n@@ -235,7 +141,7 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn abs(self) -> f64 { num::Float::abs(self) }\n+    pub fn abs(self) -> f64 { Float::abs(self) }\n \n     /// Returns a number that represents the sign of `self`.\n     ///\n@@ -255,45 +161,7 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn signum(self) -> f64 { num::Float::signum(self) }\n-\n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n-    /// positive sign bit and positive infinity.\n-    ///\n-    /// ```\n-    /// let f = 7.0_f64;\n-    /// let g = -7.0_f64;\n-    ///\n-    /// assert!(f.is_sign_positive());\n-    /// assert!(!g.is_sign_positive());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_sign_positive(self) -> bool { num::Float::is_sign_positive(self) }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")]\n-    #[inline]\n-    pub fn is_positive(self) -> bool { num::Float::is_sign_positive(self) }\n-\n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n-    /// negative sign bit and negative infinity.\n-    ///\n-    /// ```\n-    /// let f = 7.0_f64;\n-    /// let g = -7.0_f64;\n-    ///\n-    /// assert!(!f.is_sign_negative());\n-    /// assert!(g.is_sign_negative());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_sign_negative(self) -> bool { num::Float::is_sign_negative(self) }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")]\n-    #[inline]\n-    pub fn is_negative(self) -> bool { num::Float::is_sign_negative(self) }\n+    pub fn signum(self) -> f64 { Float::signum(self) }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n@@ -365,18 +233,6 @@ impl f64 {\n         }\n     }\n \n-    /// Takes the reciprocal (inverse) of a number, `1/x`.\n-    ///\n-    /// ```\n-    /// let x = 2.0_f64;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn recip(self) -> f64 { num::Float::recip(self) }\n-\n     /// Raises a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n@@ -389,7 +245,7 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn powi(self, n: i32) -> f64 { num::Float::powi(self, n) }\n+    pub fn powi(self, n: i32) -> f64 { Float::powi(self, n) }\n \n     /// Raises a number to a floating point power.\n     ///\n@@ -535,68 +391,6 @@ impl f64 {\n         self.log_wrapper(|n| { unsafe { intrinsics::log10f64(n) } })\n     }\n \n-    /// Converts radians to degrees.\n-    ///\n-    /// ```\n-    /// use std::f64::consts;\n-    ///\n-    /// let angle = consts::PI;\n-    ///\n-    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }\n-\n-    /// Converts degrees to radians.\n-    ///\n-    /// ```\n-    /// use std::f64::consts;\n-    ///\n-    /// let angle = 180.0_f64;\n-    ///\n-    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn to_radians(self) -> f64 { num::Float::to_radians(self) }\n-\n-    /// Returns the maximum of the two numbers.\n-    ///\n-    /// ```\n-    /// let x = 1.0_f64;\n-    /// let y = 2.0_f64;\n-    ///\n-    /// assert_eq!(x.max(y), y);\n-    /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn max(self, other: f64) -> f64 {\n-        num::Float::max(self, other)\n-    }\n-\n-    /// Returns the minimum of the two numbers.\n-    ///\n-    /// ```\n-    /// let x = 1.0_f64;\n-    /// let y = 2.0_f64;\n-    ///\n-    /// assert_eq!(x.min(y), x);\n-    /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn min(self, other: f64) -> f64 {\n-        num::Float::min(self, other)\n-    }\n-\n     /// The positive difference of two numbers.\n     ///\n     /// * If `self <= other`: `0:0`\n@@ -1000,73 +794,6 @@ impl f64 {\n             }\n         }\n     }\n-\n-    /// Raw transmutation to `u64`.\n-    ///\n-    /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms.\n-    ///\n-    /// See `from_bits` for some discussion of the portability of this operation\n-    /// (there are almost no issues).\n-    ///\n-    /// Note that this function is distinct from `as` casting, which attempts to\n-    /// preserve the *numeric* value, and not the bitwise value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert!((1f64).to_bits() != 1f64 as u64); // to_bits() is not casting!\n-    /// assert_eq!((12.5f64).to_bits(), 0x4029000000000000);\n-    ///\n-    /// ```\n-    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn to_bits(self) -> u64 {\n-        num::Float::to_bits(self)\n-    }\n-\n-    /// Raw transmutation from `u64`.\n-    ///\n-    /// This is currently identical to `transmute::<u64, f64>(v)` on all platforms.\n-    /// It turns out this is incredibly portable, for two reasons:\n-    ///\n-    /// * Floats and Ints have the same endianness on all supported platforms.\n-    /// * IEEE-754 very precisely specifies the bit layout of floats.\n-    ///\n-    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n-    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n-    /// (notably x86 and ARM) picked the interpretation that was ultimately\n-    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n-    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n-    ///\n-    /// Rather than trying to preserve signaling-ness cross-platform, this\n-    /// implementation favours preserving the exact bits. This means that\n-    /// any payloads encoded in NaNs will be preserved even if the result of\n-    /// this method is sent over the network from an x86 machine to a MIPS one.\n-    ///\n-    /// If the results of this method are only manipulated by the same\n-    /// architecture that produced them, then there is no portability concern.\n-    ///\n-    /// If the input isn't NaN, then there is no portability concern.\n-    ///\n-    /// If you don't care about signalingness (very likely), then there is no\n-    /// portability concern.\n-    ///\n-    /// Note that this function is distinct from `as` casting, which attempts to\n-    /// preserve the *numeric* value, and not the bitwise value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::f64;\n-    /// let v = f64::from_bits(0x4029000000000000);\n-    /// let difference = (v - 12.5).abs();\n-    /// assert!(difference <= 1e-5);\n-    /// ```\n-    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn from_bits(v: u64) -> Self {\n-        num::Float::from_bits(v)\n-    }\n }\n \n #[cfg(test)]"}]}