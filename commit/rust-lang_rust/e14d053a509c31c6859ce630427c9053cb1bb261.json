{"sha": "e14d053a509c31c6859ce630427c9053cb1bb261", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNGQwNTNhNTA5YzMxYzY4NTljZTYzMDQyN2M5MDUzY2IxYmIyNjE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2015-01-14T05:16:56Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2015-01-14T05:16:56Z"}, "message": "syntax: factor out print_expr arms to reduce non-optimized stack usage", "tree": {"sha": "2760f54ad0c433b1aad22354f0c011319737c551", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2760f54ad0c433b1aad22354f0c011319737c551"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e14d053a509c31c6859ce630427c9053cb1bb261", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e14d053a509c31c6859ce630427c9053cb1bb261", "html_url": "https://github.com/rust-lang/rust/commit/e14d053a509c31c6859ce630427c9053cb1bb261", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e14d053a509c31c6859ce630427c9053cb1bb261/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caf4a90c66b838883b58ff9d51b3b0a3f968f23f", "url": "https://api.github.com/repos/rust-lang/rust/commits/caf4a90c66b838883b58ff9d51b3b0a3f968f23f", "html_url": "https://github.com/rust-lang/rust/commit/caf4a90c66b838883b58ff9d51b3b0a3f968f23f"}], "stats": {"total": 216, "additions": 138, "deletions": 78}, "files": [{"sha": "17f6e36603fc2edbca732dfb0417de8c6e2e26d9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 138, "deletions": 78, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/e14d053a509c31c6859ce630427c9053cb1bb261/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e14d053a509c31c6859ce630427c9053cb1bb261/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e14d053a509c31c6859ce630427c9053cb1bb261", "patch": "@@ -1511,108 +1511,168 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n+    fn print_expr_box(&mut self,\n+                      place: &Option<P<ast::Expr>>,\n+                      expr: &ast::Expr) -> IoResult<()> {\n+        try!(word(&mut self.s, \"box\"));\n+        try!(word(&mut self.s, \"(\"));\n+        try!(place.as_ref().map_or(Ok(()), |e|self.print_expr(&**e)));\n+        try!(self.word_space(\")\"));\n+        self.print_expr(expr)\n+    }\n+\n+    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) -> IoResult<()> {\n+        try!(self.ibox(indent_unit));\n+        try!(word(&mut self.s, \"[\"));\n+        try!(self.commasep_exprs(Inconsistent, &exprs[]));\n+        try!(word(&mut self.s, \"]\"));\n+        self.end()\n+    }\n+\n+    fn print_expr_repeat(&mut self,\n+                         element: &ast::Expr,\n+                         count: &ast::Expr) -> IoResult<()> {\n+        try!(self.ibox(indent_unit));\n+        try!(word(&mut self.s, \"[\"));\n+        try!(self.print_expr(element));\n+        try!(self.word_space(\";\"));\n+        try!(self.print_expr(count));\n+        try!(word(&mut self.s, \"]\"));\n+        self.end()\n+    }\n+\n+    fn print_expr_struct(&mut self,\n+                         path: &ast::Path,\n+                         fields: &[ast::Field],\n+                         wth: &Option<P<ast::Expr>>) -> IoResult<()> {\n+        try!(self.print_path(path, true));\n+        if !(fields.is_empty() && wth.is_none()) {\n+            try!(word(&mut self.s, \"{\"));\n+            try!(self.commasep_cmnt(\n+                Consistent,\n+                &fields[],\n+                |s, field| {\n+                    try!(s.ibox(indent_unit));\n+                    try!(s.print_ident(field.ident.node));\n+                    try!(s.word_space(\":\"));\n+                    try!(s.print_expr(&*field.expr));\n+                    s.end()\n+                },\n+                |f| f.span));\n+            match *wth {\n+                Some(ref expr) => {\n+                    try!(self.ibox(indent_unit));\n+                    if !fields.is_empty() {\n+                        try!(word(&mut self.s, \",\"));\n+                        try!(space(&mut self.s));\n+                    }\n+                    try!(word(&mut self.s, \"..\"));\n+                    try!(self.print_expr(&**expr));\n+                    try!(self.end());\n+                }\n+                _ => try!(word(&mut self.s, \",\")),\n+            }\n+            try!(word(&mut self.s, \"}\"));\n+        }\n+        Ok(())\n+    }\n+\n+    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) -> IoResult<()> {\n+        try!(self.popen());\n+        try!(self.commasep_exprs(Inconsistent, &exprs[]));\n+        if exprs.len() == 1 {\n+            try!(word(&mut self.s, \",\"));\n+        }\n+        self.pclose()\n+    }\n+\n+    fn print_expr_call(&mut self,\n+                       func: &ast::Expr,\n+                       args: &[P<ast::Expr>]) -> IoResult<()> {\n+        try!(self.print_expr_maybe_paren(func));\n+        self.print_call_post(args)\n+    }\n+\n+    fn print_expr_method_call(&mut self,\n+                              ident: ast::SpannedIdent,\n+                              tys: &[P<ast::Ty>],\n+                              args: &[P<ast::Expr>]) -> IoResult<()> {\n+        let base_args = args.slice_from(1);\n+        try!(self.print_expr(&*args[0]));\n+        try!(word(&mut self.s, \".\"));\n+        try!(self.print_ident(ident.node));\n+        if tys.len() > 0u {\n+            try!(word(&mut self.s, \"::<\"));\n+            try!(self.commasep(Inconsistent, tys,\n+                               |s, ty| s.print_type(&**ty)));\n+            try!(word(&mut self.s, \">\"));\n+        }\n+        self.print_call_post(base_args)\n+    }\n+\n+    fn print_expr_binary(&mut self,\n+                         op: ast::BinOp,\n+                         lhs: &ast::Expr,\n+                         rhs: &ast::Expr) -> IoResult<()> {\n+        try!(self.print_expr(lhs));\n+        try!(space(&mut self.s));\n+        try!(self.word_space(ast_util::binop_to_string(op)));\n+        self.print_expr(rhs)\n+    }\n+\n+    fn print_expr_unary(&mut self,\n+                        op: ast::UnOp,\n+                        expr: &ast::Expr) -> IoResult<()> {\n+        try!(word(&mut self.s, ast_util::unop_to_string(op)));\n+        self.print_expr_maybe_paren(expr)\n+    }\n+\n+    fn print_expr_addr_of(&mut self,\n+                          mutability: ast::Mutability,\n+                          expr: &ast::Expr) -> IoResult<()> {\n+        try!(word(&mut self.s, \"&\"));\n+        try!(self.print_mutability(mutability));\n+        self.print_expr_maybe_paren(expr)\n+    }\n+\n     pub fn print_expr(&mut self, expr: &ast::Expr) -> IoResult<()> {\n         try!(self.maybe_print_comment(expr.span.lo));\n         try!(self.ibox(indent_unit));\n         try!(self.ann.pre(self, NodeExpr(expr)));\n         match expr.node {\n-            ast::ExprBox(ref p, ref e) => {\n-                try!(word(&mut self.s, \"box\"));\n-                try!(word(&mut self.s, \"(\"));\n-                try!(p.as_ref().map_or(Ok(()), |e|self.print_expr(&**e)));\n-                try!(self.word_space(\")\"));\n-                try!(self.print_expr(&**e));\n+            ast::ExprBox(ref place, ref expr) => {\n+                try!(self.print_expr_box(place, &**expr));\n             }\n             ast::ExprVec(ref exprs) => {\n-                try!(self.ibox(indent_unit));\n-                try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep_exprs(Inconsistent, &exprs[]));\n-                try!(word(&mut self.s, \"]\"));\n-                try!(self.end());\n+                try!(self.print_expr_vec(&exprs[]));\n             }\n-\n             ast::ExprRepeat(ref element, ref count) => {\n-                try!(self.ibox(indent_unit));\n-                try!(word(&mut self.s, \"[\"));\n-                try!(self.print_expr(&**element));\n-                try!(self.word_space(\";\"));\n-                try!(self.print_expr(&**count));\n-                try!(word(&mut self.s, \"]\"));\n-                try!(self.end());\n+                try!(self.print_expr_repeat(&**element, &**count));\n             }\n-\n             ast::ExprStruct(ref path, ref fields, ref wth) => {\n-                try!(self.print_path(path, true));\n-                if !(fields.is_empty() && wth.is_none()) {\n-                    try!(word(&mut self.s, \"{\"));\n-                    try!(self.commasep_cmnt(\n-                        Consistent,\n-                        &fields[],\n-                        |s, field| {\n-                            try!(s.ibox(indent_unit));\n-                            try!(s.print_ident(field.ident.node));\n-                            try!(s.word_space(\":\"));\n-                            try!(s.print_expr(&*field.expr));\n-                            s.end()\n-                        },\n-                        |f| f.span));\n-                    match *wth {\n-                        Some(ref expr) => {\n-                            try!(self.ibox(indent_unit));\n-                            if !fields.is_empty() {\n-                                try!(word(&mut self.s, \",\"));\n-                                try!(space(&mut self.s));\n-                            }\n-                            try!(word(&mut self.s, \"..\"));\n-                            try!(self.print_expr(&**expr));\n-                            try!(self.end());\n-                        }\n-                        _ => try!(word(&mut self.s, \",\")),\n-                    }\n-                    try!(word(&mut self.s, \"}\"));\n-                }\n+                try!(self.print_expr_struct(path, &fields[], wth));\n             }\n             ast::ExprTup(ref exprs) => {\n-                try!(self.popen());\n-                try!(self.commasep_exprs(Inconsistent, &exprs[]));\n-                if exprs.len() == 1 {\n-                    try!(word(&mut self.s, \",\"));\n-                }\n-                try!(self.pclose());\n+                try!(self.print_expr_tup(&exprs[]));\n             }\n             ast::ExprCall(ref func, ref args) => {\n-                try!(self.print_expr_maybe_paren(&**func));\n-                try!(self.print_call_post(&args[]));\n+                try!(self.print_expr_call(&**func, &args[]));\n             }\n             ast::ExprMethodCall(ident, ref tys, ref args) => {\n-                let base_args = args.slice_from(1);\n-                try!(self.print_expr(&*args[0]));\n-                try!(word(&mut self.s, \".\"));\n-                try!(self.print_ident(ident.node));\n-                if tys.len() > 0u {\n-                    try!(word(&mut self.s, \"::<\"));\n-                    try!(self.commasep(Inconsistent, &tys[],\n-                                       |s, ty| s.print_type(&**ty)));\n-                    try!(word(&mut self.s, \">\"));\n-                }\n-                try!(self.print_call_post(base_args));\n+                try!(self.print_expr_method_call(ident, &tys[], &args[]));\n             }\n             ast::ExprBinary(op, ref lhs, ref rhs) => {\n-                try!(self.print_expr(&**lhs));\n-                try!(space(&mut self.s));\n-                try!(self.word_space(ast_util::binop_to_string(op)));\n-                try!(self.print_expr(&**rhs));\n+                try!(self.print_expr_binary(op, &**lhs, &**rhs));\n             }\n             ast::ExprUnary(op, ref expr) => {\n-                try!(word(&mut self.s, ast_util::unop_to_string(op)));\n-                try!(self.print_expr_maybe_paren(&**expr));\n+                try!(self.print_expr_unary(op, &**expr));\n             }\n             ast::ExprAddrOf(m, ref expr) => {\n-                try!(word(&mut self.s, \"&\"));\n-                try!(self.print_mutability(m));\n-                try!(self.print_expr_maybe_paren(&**expr));\n+                try!(self.print_expr_addr_of(m, &**expr));\n+            }\n+            ast::ExprLit(ref lit) => {\n+                try!(self.print_literal(&**lit));\n             }\n-            ast::ExprLit(ref lit) => try!(self.print_literal(&**lit)),\n             ast::ExprCast(ref expr, ref ty) => {\n                 try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));"}]}