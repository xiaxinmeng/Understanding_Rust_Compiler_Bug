{"sha": "63bb0847bdf58d7d021735184a9dfd48138ad8ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzYmIwODQ3YmRmNThkN2QwMjE3MzUxODRhOWRmZDQ4MTM4YWQ4YWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-26T10:11:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-31T23:59:57Z"}, "message": "expand `DepNode::TraitSelect` to include type ids\n\nTo handle the general case, we include a vector of def-ids, so that we\ncan account for things like `(Foo, Bar)` which references both `Foo` and\n`Bar`. This means it is not Copy, so re-jigger some APIs to use\nborrowing more intelligently.", "tree": {"sha": "b45a0c617888f4119737c87c0e1c826a9ee23b9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b45a0c617888f4119737c87c0e1c826a9ee23b9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63bb0847bdf58d7d021735184a9dfd48138ad8ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63bb0847bdf58d7d021735184a9dfd48138ad8ab", "html_url": "https://github.com/rust-lang/rust/commit/63bb0847bdf58d7d021735184a9dfd48138ad8ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63bb0847bdf58d7d021735184a9dfd48138ad8ab/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dc6a058b2ec05a18447308b224669c4a9726f3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dc6a058b2ec05a18447308b224669c4a9726f3c", "html_url": "https://github.com/rust-lang/rust/commit/5dc6a058b2ec05a18447308b224669c4a9726f3c"}], "stats": {"total": 170, "additions": 91, "deletions": 79}, "files": [{"sha": "73b96651b05e27826c031d55267cff16415a7bf1", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=63bb0847bdf58d7d021735184a9dfd48138ad8ab", "patch": "@@ -10,7 +10,16 @@\n \n use std::fmt::Debug;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+macro_rules! try_opt {\n+    ($e:expr) => (\n+        match $e {\n+            Some(r) => r,\n+            None => return None,\n+        }\n+    )\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum DepNode<D: Clone + Debug> {\n     // The `D` type is \"how definitions are identified\".\n     // During compilation, it is always `DefId`, but when serializing\n@@ -116,7 +125,7 @@ pub enum DepNode<D: Clone + Debug> {\n     // which would yield an overly conservative dep-graph.\n     TraitItems(D),\n     ReprHints(D),\n-    TraitSelect(D),\n+    TraitSelect(D, Vec<D>),\n }\n \n impl<D: Clone + Debug> DepNode<D> {\n@@ -212,7 +221,11 @@ impl<D: Clone + Debug> DepNode<D> {\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),\n-            TraitSelect(ref d) => op(d).map(TraitSelect),\n+            TraitSelect(ref d, ref type_ds) => {\n+                let d = try_opt!(op(d));\n+                let type_ds = try_opt!(type_ds.iter().map(|d| op(d)).collect());\n+                Some(TraitSelect(d, type_ds))\n+            }\n         }\n     }\n }"}, {"sha": "7a780c1d4ae2478bc6d80d2e9c932bb0063e4b1e", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=63bb0847bdf58d7d021735184a9dfd48138ad8ab", "patch": "@@ -47,26 +47,26 @@ impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n         self.indices.contains_key(&node)\n     }\n \n-    pub fn nodes(&self) -> Vec<DepNode<D>> {\n+    pub fn nodes(&self) -> Vec<&DepNode<D>> {\n         self.graph.all_nodes()\n                   .iter()\n-                  .map(|n| n.data.clone())\n+                  .map(|n| &n.data)\n                   .collect()\n     }\n \n-    pub fn edges(&self) -> Vec<(DepNode<D>,DepNode<D>)> {\n+    pub fn edges(&self) -> Vec<(&DepNode<D>,&DepNode<D>)> {\n         self.graph.all_edges()\n                   .iter()\n                   .map(|edge| (edge.source(), edge.target()))\n-                  .map(|(s, t)| (self.graph.node_data(s).clone(),\n-                                 self.graph.node_data(t).clone()))\n+                  .map(|(s, t)| (self.graph.node_data(s),\n+                                 self.graph.node_data(t)))\n                   .collect()\n     }\n \n-    fn reachable_nodes(&self, node: DepNode<D>, direction: Direction) -> Vec<DepNode<D>> {\n-        if let Some(&index) = self.indices.get(&node) {\n+    fn reachable_nodes(&self, node: &DepNode<D>, direction: Direction) -> Vec<&DepNode<D>> {\n+        if let Some(&index) = self.indices.get(node) {\n             self.graph.depth_traverse(index, direction)\n-                      .map(|s| self.graph.node_data(s).clone())\n+                      .map(|s| self.graph.node_data(s))\n                       .collect()\n         } else {\n             vec![]\n@@ -75,20 +75,20 @@ impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n \n     /// All nodes reachable from `node`. In other words, things that\n     /// will have to be recomputed if `node` changes.\n-    pub fn transitive_successors(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+    pub fn transitive_successors(&self, node: &DepNode<D>) -> Vec<&DepNode<D>> {\n         self.reachable_nodes(node, OUTGOING)\n     }\n \n     /// All nodes that can reach `node`.\n-    pub fn transitive_predecessors(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+    pub fn transitive_predecessors(&self, node: &DepNode<D>) -> Vec<&DepNode<D>> {\n         self.reachable_nodes(node, INCOMING)\n     }\n \n     /// Just the outgoing edges from `node`.\n-    pub fn immediate_successors(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+    pub fn immediate_successors(&self, node: &DepNode<D>) -> Vec<&DepNode<D>> {\n         if let Some(&index) = self.indices.get(&node) {\n             self.graph.successor_nodes(index)\n-                      .map(|s| self.graph.node_data(s).clone())\n+                      .map(|s| self.graph.node_data(s))\n                       .collect()\n         } else {\n             vec![]"}, {"sha": "92cecabaa182f86cadf45b1488504d9ea5245f86", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=63bb0847bdf58d7d021735184a9dfd48138ad8ab", "patch": "@@ -20,14 +20,14 @@ pub struct DepTask<'graph> {\n impl<'graph> DepTask<'graph> {\n     pub fn new(data: &'graph DepGraphThreadData, key: DepNode<DefId>)\n                -> DepTask<'graph> {\n-        data.enqueue(DepMessage::PushTask(key));\n+        data.enqueue(DepMessage::PushTask(key.clone()));\n         DepTask { data: data, key: key }\n     }\n }\n \n impl<'graph> Drop for DepTask<'graph> {\n     fn drop(&mut self) {\n-        self.data.enqueue(DepMessage::PopTask(self.key));\n+        self.data.enqueue(DepMessage::PopTask(self.key.clone()));\n     }\n }\n "}, {"sha": "5dd71db2f1832870b8e87171499b772c32acf02e", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=63bb0847bdf58d7d021735184a9dfd48138ad8ab", "patch": "@@ -39,7 +39,7 @@ pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         fn visit_item(&mut self, i: &'tcx hir::Item) {\n             let item_def_id = self.tcx.map.local_def_id(i.id);\n             let task_id = (self.dep_node_fn)(item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id);\n+            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n             self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n             self.visitor.visit_item(i);"}, {"sha": "423d57cfb328d4c110a2ffabb72e1f3c4c7197df", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=63bb0847bdf58d7d021735184a9dfd48138ad8ab", "patch": "@@ -946,7 +946,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n \n     /// Creates the dep-node for selecting/evaluating this trait reference.\n     fn dep_node(&self) -> DepNode<DefId> {\n-        DepNode::TraitSelect(self.def_id())\n+        DepNode::TraitSelect(self.def_id(), vec![])\n     }\n \n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n@@ -1768,9 +1768,8 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                                         stack: &mut Vec<AdtDefMaster<'tcx>>)\n     {\n \n-        let dep_node = DepNode::SizedConstraint(self.did);\n-\n-        if self.sized_constraint.get(dep_node).is_some() {\n+        let dep_node = || DepNode::SizedConstraint(self.did);\n+        if self.sized_constraint.get(dep_node()).is_some() {\n             return;\n         }\n \n@@ -1780,7 +1779,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n             //\n             // Consider the type as Sized in the meanwhile to avoid\n             // further errors.\n-            self.sized_constraint.fulfill(dep_node, tcx.types.err);\n+            self.sized_constraint.fulfill(dep_node(), tcx.types.err);\n             return;\n         }\n \n@@ -1803,14 +1802,14 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n             _ => tcx.mk_tup(tys)\n         };\n \n-        match self.sized_constraint.get(dep_node) {\n+        match self.sized_constraint.get(dep_node()) {\n             Some(old_ty) => {\n                 debug!(\"calculate_sized_constraint: {:?} recurred\", self);\n                 assert_eq!(old_ty, tcx.types.err)\n             }\n             None => {\n                 debug!(\"calculate_sized_constraint: {:?} => {:?}\", self, ty);\n-                self.sized_constraint.fulfill(dep_node, ty)\n+                self.sized_constraint.fulfill(dep_node(), ty)\n             }\n         }\n     }"}, {"sha": "1c0274cdcca9a68bf19d5cf8c431b8e0a64fca4e", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=63bb0847bdf58d7d021735184a9dfd48138ad8ab", "patch": "@@ -195,7 +195,7 @@ fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         };\n \n-        for &(_, source_def_id, source_dep_node) in sources {\n+        for &(_, source_def_id, ref source_dep_node) in sources {\n             let dependents = query.transitive_successors(source_dep_node);\n             for &(target_span, ref target_pass, _, ref target_dep_node) in targets {\n                 if !dependents.contains(&target_dep_node) {\n@@ -239,7 +239,7 @@ fn dump_graph(tcx: TyCtxt) {\n     { // dump a .txt file with just the edges:\n         let txt_path = format!(\"{}.txt\", path);\n         let mut file = File::create(&txt_path).unwrap();\n-        for &(source, target) in &edges {\n+        for &(ref source, ref target) in &edges {\n             write!(file, \"{:?} -> {:?}\\n\", source, target).unwrap();\n         }\n     }\n@@ -252,51 +252,51 @@ fn dump_graph(tcx: TyCtxt) {\n     }\n }\n \n-pub struct GraphvizDepGraph(FnvHashSet<DepNode<DefId>>,\n-                            Vec<(DepNode<DefId>, DepNode<DefId>)>);\n+pub struct GraphvizDepGraph<'q>(FnvHashSet<&'q DepNode<DefId>>,\n+                                Vec<(&'q DepNode<DefId>, &'q DepNode<DefId>)>);\n \n-impl<'a, 'tcx> dot::GraphWalk<'a> for GraphvizDepGraph {\n-    type Node = DepNode<DefId>;\n-    type Edge = (DepNode<DefId>, DepNode<DefId>);\n-    fn nodes(&self) -> dot::Nodes<DepNode<DefId>> {\n+impl<'a, 'tcx, 'q> dot::GraphWalk<'a> for GraphvizDepGraph<'q> {\n+    type Node = &'q DepNode<DefId>;\n+    type Edge = (&'q DepNode<DefId>, &'q DepNode<DefId>);\n+    fn nodes(&self) -> dot::Nodes<&'q DepNode<DefId>> {\n         let nodes: Vec<_> = self.0.iter().cloned().collect();\n         nodes.into_cow()\n     }\n-    fn edges(&self) -> dot::Edges<(DepNode<DefId>, DepNode<DefId>)> {\n+    fn edges(&self) -> dot::Edges<(&'q DepNode<DefId>, &'q DepNode<DefId>)> {\n         self.1[..].into_cow()\n     }\n-    fn source(&self, edge: &(DepNode<DefId>, DepNode<DefId>)) -> DepNode<DefId> {\n+    fn source(&self, edge: &(&'q DepNode<DefId>, &'q DepNode<DefId>)) -> &'q DepNode<DefId> {\n         edge.0\n     }\n-    fn target(&self, edge: &(DepNode<DefId>, DepNode<DefId>)) -> DepNode<DefId> {\n+    fn target(&self, edge: &(&'q DepNode<DefId>, &'q DepNode<DefId>)) -> &'q DepNode<DefId> {\n         edge.1\n     }\n }\n \n-impl<'a, 'tcx> dot::Labeller<'a> for GraphvizDepGraph {\n-    type Node = DepNode<DefId>;\n-    type Edge = (DepNode<DefId>, DepNode<DefId>);\n+impl<'a, 'tcx, 'q> dot::Labeller<'a> for GraphvizDepGraph<'q> {\n+    type Node = &'q DepNode<DefId>;\n+    type Edge = (&'q DepNode<DefId>, &'q DepNode<DefId>);\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(\"DependencyGraph\").unwrap()\n     }\n-    fn node_id(&self, n: &DepNode<DefId>) -> dot::Id {\n+    fn node_id(&self, n: &&'q DepNode<DefId>) -> dot::Id {\n         let s: String =\n             format!(\"{:?}\", n).chars()\n                               .map(|c| if c == '_' || c.is_alphanumeric() { c } else { '_' })\n                               .collect();\n         debug!(\"n={:?} s={:?}\", n, s);\n         dot::Id::new(s).unwrap()\n     }\n-    fn node_label(&self, n: &DepNode<DefId>) -> dot::LabelText {\n+    fn node_label(&self, n: &&'q DepNode<DefId>) -> dot::LabelText {\n         dot::LabelText::label(format!(\"{:?}\", n))\n     }\n }\n \n // Given an optional filter like `\"x,y,z\"`, returns either `None` (no\n // filter) or the set of nodes whose labels contain all of those\n // substrings.\n-fn node_set(query: &DepGraphQuery<DefId>, filter: &DepNodeFilter)\n-            -> Option<FnvHashSet<DepNode<DefId>>>\n+fn node_set<'q>(query: &'q DepGraphQuery<DefId>, filter: &DepNodeFilter)\n+                -> Option<FnvHashSet<&'q DepNode<DefId>>>\n {\n     debug!(\"node_set(filter={:?})\", filter);\n \n@@ -307,10 +307,10 @@ fn node_set(query: &DepGraphQuery<DefId>, filter: &DepNodeFilter)\n     Some(query.nodes().into_iter().filter(|n| filter.test(n)).collect())\n }\n \n-fn filter_nodes(query: &DepGraphQuery<DefId>,\n-                sources: &Option<FnvHashSet<DepNode<DefId>>>,\n-                targets: &Option<FnvHashSet<DepNode<DefId>>>)\n-                -> FnvHashSet<DepNode<DefId>>\n+fn filter_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n+                    sources: &Option<FnvHashSet<&'q DepNode<DefId>>>,\n+                    targets: &Option<FnvHashSet<&'q DepNode<DefId>>>)\n+                    -> FnvHashSet<&'q DepNode<DefId>>\n {\n     if let &Some(ref sources) = sources {\n         if let &Some(ref targets) = targets {\n@@ -325,21 +325,21 @@ fn filter_nodes(query: &DepGraphQuery<DefId>,\n     }\n }\n \n-fn walk_nodes(query: &DepGraphQuery<DefId>,\n-              starts: &FnvHashSet<DepNode<DefId>>,\n-              direction: Direction)\n-              -> FnvHashSet<DepNode<DefId>>\n+fn walk_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n+                  starts: &FnvHashSet<&'q DepNode<DefId>>,\n+                  direction: Direction)\n+                  -> FnvHashSet<&'q DepNode<DefId>>\n {\n     let mut set = FnvHashSet();\n-    for start in starts {\n+    for &start in starts {\n         debug!(\"walk_nodes: start={:?} outgoing?={:?}\", start, direction == OUTGOING);\n-        if set.insert(*start) {\n+        if set.insert(start) {\n             let mut stack = vec![query.indices[start]];\n             while let Some(index) = stack.pop() {\n                 for (_, edge) in query.graph.adjacent_edges(index, direction) {\n                     let neighbor_index = edge.source_or_target(direction);\n                     let neighbor = query.graph.node_data(neighbor_index);\n-                    if set.insert(*neighbor) {\n+                    if set.insert(neighbor) {\n                         stack.push(neighbor_index);\n                     }\n                 }\n@@ -349,10 +349,10 @@ fn walk_nodes(query: &DepGraphQuery<DefId>,\n     set\n }\n \n-fn walk_between(query: &DepGraphQuery<DefId>,\n-                sources: &FnvHashSet<DepNode<DefId>>,\n-                targets: &FnvHashSet<DepNode<DefId>>)\n-                -> FnvHashSet<DepNode<DefId>>\n+fn walk_between<'q>(query: &'q DepGraphQuery<DefId>,\n+                    sources: &FnvHashSet<&'q DepNode<DefId>>,\n+                    targets: &FnvHashSet<&'q DepNode<DefId>>)\n+                    -> FnvHashSet<&'q DepNode<DefId>>\n {\n     // This is a bit tricky. We want to include a node only if it is:\n     // (a) reachable from a source and (b) will reach a target. And we\n@@ -365,16 +365,16 @@ fn walk_between(query: &DepGraphQuery<DefId>,\n     let mut node_states = vec![State::Undecided; query.graph.len_nodes()];\n \n     for &target in targets {\n-        node_states[query.indices[&target].0] = State::Included;\n+        node_states[query.indices[target].0] = State::Included;\n     }\n \n-    for source in sources.iter().map(|n| query.indices[n]) {\n+    for source in sources.iter().map(|&n| query.indices[n]) {\n         recurse(query, &mut node_states, source);\n     }\n \n     return query.nodes()\n                 .into_iter()\n-                .filter(|n| {\n+                .filter(|&n| {\n                     let index = query.indices[n];\n                     node_states[index.0] == State::Included\n                 })\n@@ -417,12 +417,12 @@ fn walk_between(query: &DepGraphQuery<DefId>,\n     }\n }\n \n-fn filter_edges(query: &DepGraphQuery<DefId>,\n-                nodes: &FnvHashSet<DepNode<DefId>>)\n-                -> Vec<(DepNode<DefId>, DepNode<DefId>)>\n+fn filter_edges<'q>(query: &'q DepGraphQuery<DefId>,\n+                    nodes: &FnvHashSet<&'q DepNode<DefId>>)\n+                    -> Vec<(&'q DepNode<DefId>, &'q DepNode<DefId>)>\n {\n     query.edges()\n          .into_iter()\n-         .filter(|&(source, target)| nodes.contains(&source) && nodes.contains(&target))\n+         .filter(|&(source, target)| nodes.contains(source) && nodes.contains(target))\n          .collect()\n }"}, {"sha": "2fd6973909a8ec59c33a146658b60913049be8a2", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=63bb0847bdf58d7d021735184a9dfd48138ad8ab", "patch": "@@ -57,7 +57,7 @@ impl RetracedDefIdDirectory {\n         self.ids[index.index as usize]\n     }\n \n-    pub fn map(&self, node: DepNode<DefPathIndex>) -> Option<DepNode<DefId>> {\n+    pub fn map(&self, node: &DepNode<DefPathIndex>) -> Option<DepNode<DefId>> {\n         node.map_def(|&index| self.def_id(index))\n     }\n }\n@@ -91,7 +91,7 @@ impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n                  .clone()\n     }\n \n-    pub fn map(&mut self, node: DepNode<DefId>) -> DepNode<DefPathIndex> {\n+    pub fn map(&mut self, node: &DepNode<DefId>) -> DepNode<DefPathIndex> {\n         node.map_def(|&def_id| Some(self.add(def_id))).unwrap()\n     }\n "}, {"sha": "99119dd184c8b3929045d5e75afa08134e3a776a", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=63bb0847bdf58d7d021735184a9dfd48138ad8ab", "patch": "@@ -39,8 +39,8 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash(&mut self, dep_node: DepNode<DefId>) -> Option<u64> {\n-        match dep_node {\n+    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<u64> {\n+        match *dep_node {\n             // HIR nodes (which always come from our crate) are an input:\n             DepNode::Hir(def_id) => {\n                 assert!(def_id.is_local());"}, {"sha": "0ac1018462ee7a7eb06a2e6cc2b75a01eacda4db", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=63bb0847bdf58d7d021735184a9dfd48138ad8ab", "patch": "@@ -114,15 +114,15 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let clean_nodes =\n         serialized_dep_graph.nodes\n                             .iter()\n-                            .filter_map(|&node| retraced.map(node))\n+                            .filter_map(|node| retraced.map(node))\n                             .filter(|node| !dirty_nodes.contains(node))\n-                            .map(|node| (node, node));\n+                            .map(|node| (node.clone(), node));\n \n     // Add nodes and edges that are not dirty into our main graph.\n     let dep_graph = tcx.dep_graph.clone();\n     for (source, target) in clean_edges.into_iter().chain(clean_nodes) {\n-        let _task = dep_graph.in_task(target);\n-        dep_graph.read(source);\n+        let _task = dep_graph.in_task(target.clone());\n+        dep_graph.read(source.clone());\n \n         debug!(\"decode_dep_graph: clean edge: {:?} -> {:?}\", source, target);\n     }\n@@ -140,7 +140,7 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for hash in hashes {\n         match hash.node.map_def(|&i| retraced.def_id(i)) {\n             Some(dep_node) => {\n-                let current_hash = hcx.hash(dep_node).unwrap();\n+                let current_hash = hcx.hash(&dep_node).unwrap();\n                 debug!(\"initial_dirty_nodes: hash of {:?} is {:?}, was {:?}\",\n                        dep_node, current_hash, hash.hash);\n                 if current_hash != hash.hash {\n@@ -171,7 +171,7 @@ fn compute_clean_edges(serialized_edges: &[(SerializedEdge)],\n     // target) if neither node has been removed. If the source has\n     // been removed, add target to the list of dirty nodes.\n     let mut clean_edges = Vec::with_capacity(serialized_edges.len());\n-    for &(serialized_source, serialized_target) in serialized_edges {\n+    for &(ref serialized_source, ref serialized_target) in serialized_edges {\n         if let Some(target) = retraced.map(serialized_target) {\n             if let Some(source) = retraced.map(serialized_source) {\n                 clean_edges.push((source, target))"}, {"sha": "99f4d4f3072989b6b74a4c561bd9f32f086a0871", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63bb0847bdf58d7d021735184a9dfd48138ad8ab/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=63bb0847bdf58d7d021735184a9dfd48138ad8ab", "patch": "@@ -99,7 +99,7 @@ pub fn encode_dep_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n         query.nodes()\n              .into_iter()\n              .filter_map(|dep_node| {\n-                 hcx.hash(dep_node)\n+                 hcx.hash(&dep_node)\n                     .map(|hash| {\n                         let node = builder.map(dep_node);\n                         SerializedHash { node: node, hash: hash }\n@@ -147,7 +147,7 @@ pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n         let meta_data_def_ids =\n             query.nodes()\n                  .into_iter()\n-                 .filter_map(|dep_node| match dep_node {\n+                 .filter_map(|dep_node| match *dep_node {\n                      DepNode::MetaData(def_id) if def_id.is_local() => Some(def_id),\n                      _ => None,\n                  });\n@@ -165,8 +165,8 @@ pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n                 let dep_node = DepNode::MetaData(def_id);\n                 let mut state = SipHasher::new();\n                 debug!(\"save: computing metadata hash for {:?}\", dep_node);\n-                for node in query.transitive_predecessors(dep_node) {\n-                    if let Some(hash) = hcx.hash(node) {\n+                for node in query.transitive_predecessors(&dep_node) {\n+                    if let Some(hash) = hcx.hash(&node) {\n                         debug!(\"save: predecessor {:?} has hash {}\", node, hash);\n                         state.write_u64(hash.to_le());\n                     } else {"}]}