{"sha": "32ea4bb9e3785ae76660b1303e821255c02aad1a", "node_id": "C_kwDOAAsO6NoAKDMyZWE0YmI5ZTM3ODVhZTc2NjYwYjEzMDNlODIxMjU1YzAyYWFkMWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-07T03:37:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-07T03:37:21Z"}, "message": "Auto merge of #109663 - fee1-dead-contrib:rustc_macros-syn-2.0, r=Nilstrieb\n\nmigrate rustc_macros to syn 2.0\n\nWIP at this point since I need to work on migrating the code that heavily uses `NestedMeta` for parsing. Perhaps a full refactor would be nice..", "tree": {"sha": "1469982b3aa0521a073e0fd8399553bd7bb8852a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1469982b3aa0521a073e0fd8399553bd7bb8852a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32ea4bb9e3785ae76660b1303e821255c02aad1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32ea4bb9e3785ae76660b1303e821255c02aad1a", "html_url": "https://github.com/rust-lang/rust/commit/32ea4bb9e3785ae76660b1303e821255c02aad1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32ea4bb9e3785ae76660b1303e821255c02aad1a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c934ce9e0a267340920a8bef96d7c59a46910c55", "url": "https://api.github.com/repos/rust-lang/rust/commits/c934ce9e0a267340920a8bef96d7c59a46910c55", "html_url": "https://github.com/rust-lang/rust/commit/c934ce9e0a267340920a8bef96d7c59a46910c55"}, {"sha": "d764c2da99fb20032e4dc41c1c23bb90aabd39ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/d764c2da99fb20032e4dc41c1c23bb90aabd39ad", "html_url": "https://github.com/rust-lang/rust/commit/d764c2da99fb20032e4dc41c1c23bb90aabd39ad"}], "stats": {"total": 1349, "additions": 655, "deletions": 694}, "files": [{"sha": "d4fca32d750f6f440f7d42ced99beb35ecb9ca5d", "filename": "Cargo.lock", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -632,7 +632,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.102\",\n- \"synstructure\",\n+ \"synstructure 0.12.6\",\n ]\n \n [[package]]\n@@ -4994,8 +4994,8 @@ dependencies = [\n  \"fluent-syntax\",\n  \"proc-macro2\",\n  \"quote\",\n- \"syn 1.0.102\",\n- \"synstructure\",\n+ \"syn 2.0.8\",\n+ \"synstructure 0.13.0\",\n  \"unic-langid\",\n ]\n \n@@ -6131,6 +6131,18 @@ dependencies = [\n  \"unicode-xid\",\n ]\n \n+[[package]]\n+name = \"synstructure\"\n+version = \"0.13.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"285ba80e733fac80aa4270fbcdf83772a79b80aa35c97075320abfee4a915b06\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 2.0.8\",\n+ \"unicode-xid\",\n+]\n+\n [[package]]\n name = \"tar\"\n version = \"0.4.38\"\n@@ -7154,7 +7166,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.102\",\n- \"synstructure\",\n+ \"synstructure 0.12.6\",\n ]\n \n [[package]]\n@@ -7175,7 +7187,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.102\",\n- \"synstructure\",\n+ \"synstructure 0.12.6\",\n ]\n \n [[package]]\n@@ -7204,5 +7216,5 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.102\",\n- \"synstructure\",\n+ \"synstructure 0.12.6\",\n ]"}, {"sha": "745983e7e869aed7e1f42167b26bcc41baa7e3b3", "filename": "compiler/rustc_macros/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2FCargo.toml?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -10,8 +10,8 @@ proc-macro = true\n annotate-snippets = \"0.9\"\n fluent-bundle = \"0.15.2\"\n fluent-syntax = \"0.11\"\n-synstructure = \"0.12.1\"\n-syn = { version = \"1\", features = [\"full\"] }\n+synstructure = \"0.13.0\"\n+syn = { version = \"2\", features = [\"full\"] }\n proc-macro2 = \"1\"\n quote = \"1\"\n unic-langid = { version = \"0.9.0\", features = [\"macros\"] }"}, {"sha": "9b91627883a8ddf3ae5fec1f2c3148d2289e22b1", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 67, "deletions": 90, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -1,8 +1,7 @@\n #![deny(unused_must_use)]\n \n use crate::diagnostics::error::{\n-    invalid_nested_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n-    DiagnosticDeriveError,\n+    span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n     build_field_mapping, is_doc_comment, report_error_if_not_applied_to_span, report_type_error,\n@@ -11,9 +10,8 @@ use crate::diagnostics::utils::{\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote};\n-use syn::{\n-    parse_quote, spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path, Type,\n-};\n+use syn::Token;\n+use syn::{parse_quote, spanned::Spanned, Attribute, Meta, Path, Type};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// What kind of diagnostic is being derived - a fatal/error/warning or a lint?\n@@ -77,7 +75,7 @@ impl DiagnosticDeriveBuilder {\n         match ast.data {\n             syn::Data::Struct(..) | syn::Data::Enum(..) => (),\n             syn::Data::Union(..) => {\n-                span_err(span, \"diagnostic derives can only be used on structs and enums\");\n+                span_err(span, \"diagnostic derives can only be used on structs and enums\").emit();\n             }\n         }\n \n@@ -160,8 +158,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         };\n \n         if let SubdiagnosticKind::MultipartSuggestion { .. } = subdiag {\n-            let meta = attr.parse_meta()?;\n-            throw_invalid_attr!(attr, &meta, |diag| diag\n+            throw_invalid_attr!(attr, |diag| diag\n                 .help(\"consider creating a `Subdiagnostic` instead\"));\n         }\n \n@@ -191,71 +188,44 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             return Ok(quote! {});\n         }\n \n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = attr.path().segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n-        let meta = attr.parse_meta()?;\n \n-        if name == \"diag\" {\n-            let Meta::List(MetaList { ref nested, .. }) = meta else {\n-                throw_invalid_attr!(\n-                    attr,\n-                    &meta\n-                );\n-            };\n+        let mut first = true;\n \n-            let mut nested_iter = nested.into_iter().peekable();\n+        if name == \"diag\" {\n+            let mut tokens = TokenStream::new();\n+            attr.parse_nested_meta(|nested| {\n+                let path = &nested.path;\n \n-            match nested_iter.peek() {\n-                Some(NestedMeta::Meta(Meta::Path(slug))) => {\n-                    self.slug.set_once(slug.clone(), slug.span().unwrap());\n-                    nested_iter.next();\n+                if first && (nested.input.is_empty() || nested.input.peek(Token![,])) {\n+                    self.slug.set_once(path.clone(), path.span().unwrap());\n+                    first = false;\n+                    return Ok(())\n                 }\n-                Some(NestedMeta::Meta(Meta::NameValue { .. })) => {}\n-                Some(nested_attr) => throw_invalid_nested_attr!(attr, nested_attr, |diag| diag\n-                    .help(\"a diagnostic slug is required as the first argument\")),\n-                None => throw_invalid_attr!(attr, &meta, |diag| diag\n-                    .help(\"a diagnostic slug is required as the first argument\")),\n-            };\n \n-            // Remaining attributes are optional, only `code = \"..\"` at the moment.\n-            let mut tokens = TokenStream::new();\n-            for nested_attr in nested_iter {\n-                let (value, path) = match nested_attr {\n-                    NestedMeta::Meta(Meta::NameValue(MetaNameValue {\n-                        lit: syn::Lit::Str(value),\n-                        path,\n-                        ..\n-                    })) => (value, path),\n-                    NestedMeta::Meta(Meta::Path(_)) => {\n-                        invalid_nested_attr(attr, nested_attr)\n-                            .help(\"diagnostic slug must be the first argument\")\n-                            .emit();\n-                        continue;\n-                    }\n-                    _ => {\n-                        invalid_nested_attr(attr, nested_attr).emit();\n-                        continue;\n-                    }\n+                first = false;\n+\n+                let Ok(nested) = nested.value() else {\n+                    span_err(nested.input.span().unwrap(), \"diagnostic slug must be the first argument\").emit();\n+                    return Ok(())\n                 };\n \n-                let nested_name = path.segments.last().unwrap().ident.to_string();\n-                // Struct attributes are only allowed to be applied once, and the diagnostic\n-                // changes will be set in the initialisation code.\n-                let span = value.span().unwrap();\n-                match nested_name.as_str() {\n-                    \"code\" => {\n-                        self.code.set_once((), span);\n-\n-                        let code = value.value();\n-                        tokens.extend(quote! {\n-                            #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n-                        });\n-                    }\n-                    _ => invalid_nested_attr(attr, nested_attr)\n-                        .help(\"only `code` is a valid nested attributes following the slug\")\n-                        .emit(),\n+                if path.is_ident(\"code\") {\n+                    self.code.set_once((), path.span().unwrap());\n+\n+                    let code = nested.parse::<syn::LitStr>()?;\n+                    tokens.extend(quote! {\n+                        #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n+                    });\n+                } else {\n+                    span_err(path.span().unwrap(), \"unknown argument\").note(\"only the `code` parameter is valid after the slug\").emit();\n+\n+                    // consume the buffer so we don't have syntax errors from syn\n+                    let _ = nested.parse::<TokenStream>();\n                 }\n-            }\n+                Ok(())\n+            })?;\n             return Ok(tokens);\n         }\n \n@@ -270,7 +240,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 Ok(self.add_subdiagnostic(&fn_ident, slug))\n             }\n             SubdiagnosticKind::Label | SubdiagnosticKind::Suggestion { .. } => {\n-                throw_invalid_attr!(attr, &meta, |diag| diag\n+                throw_invalid_attr!(attr, |diag| diag\n                     .help(\"`#[label]` and `#[suggestion]` can only be applied to fields\"));\n             }\n             SubdiagnosticKind::MultipartSuggestion { .. } => unreachable!(),\n@@ -309,7 +279,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     return quote! {};\n                 }\n \n-                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let name = attr.path().segments.last().unwrap().ident.to_string();\n                 let needs_clone =\n                     name == \"primary_span\" && matches!(inner_ty, FieldInnerTy::Vec(_));\n                 let (binding, needs_destructure) = if needs_clone {\n@@ -343,11 +313,10 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         binding: TokenStream,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let diag = &self.parent.diag;\n-        let meta = attr.parse_meta()?;\n \n-        let ident = &attr.path.segments.last().unwrap().ident;\n+        let ident = &attr.path().segments.last().unwrap().ident;\n         let name = ident.to_string();\n-        match (&meta, name.as_str()) {\n+        match (&attr.meta, name.as_str()) {\n             // Don't need to do anything - by virtue of the attribute existing, the\n             // `set_arg` call will not be generated.\n             (Meta::Path(_), \"skip_arg\") => return Ok(quote! {}),\n@@ -361,7 +330,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                         });\n                     }\n                     DiagnosticDeriveKind::LintDiagnostic => {\n-                        throw_invalid_attr!(attr, &meta, |diag| {\n+                        throw_invalid_attr!(attr, |diag| {\n                             diag.help(\"the `primary_span` field attribute is not valid for lint diagnostics\")\n                         })\n                     }\n@@ -378,26 +347,34 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     return Ok(quote! { #diag.subdiagnostic(#binding); });\n                 }\n             }\n-            (Meta::List(MetaList { ref nested, .. }), \"subdiagnostic\") => {\n-                if nested.len() == 1\n-                    && let Some(NestedMeta::Meta(Meta::Path(path))) = nested.first()\n-                    && path.is_ident(\"eager\") {\n-                        let handler = match &self.parent.kind {\n-                            DiagnosticDeriveKind::Diagnostic { handler } => handler,\n-                            DiagnosticDeriveKind::LintDiagnostic => {\n-                                throw_invalid_attr!(attr, &meta, |diag| {\n-                                    diag.help(\"eager subdiagnostics are not supported on lints\")\n-                                })\n-                            }\n-                        };\n-                        return Ok(quote! { #diag.eager_subdiagnostic(#handler, #binding); });\n-                } else {\n-                    throw_invalid_attr!(attr, &meta, |diag| {\n-                        diag.help(\n-                            \"`eager` is the only supported nested attribute for `subdiagnostic`\",\n-                        )\n-                    })\n+            (Meta::List(meta_list), \"subdiagnostic\") => {\n+                let err = || {\n+                    span_err(\n+                        meta_list.span().unwrap(),\n+                        \"`eager` is the only supported nested attribute for `subdiagnostic`\",\n+                    )\n+                    .emit();\n+                };\n+\n+                let Ok(p): Result<Path, _> = meta_list.parse_args() else {\n+                    err();\n+                    return Ok(quote! {});\n+                };\n+\n+                if !p.is_ident(\"eager\") {\n+                    err();\n+                    return Ok(quote! {});\n                 }\n+\n+                let handler = match &self.parent.kind {\n+                    DiagnosticDeriveKind::Diagnostic { handler } => handler,\n+                    DiagnosticDeriveKind::LintDiagnostic => {\n+                        throw_invalid_attr!(attr, |diag| {\n+                            diag.help(\"eager subdiagnostics are not supported on lints\")\n+                        })\n+                    }\n+                };\n+                return Ok(quote! { #diag.eager_subdiagnostic(#handler, #binding); });\n             }\n             _ => (),\n         }\n@@ -432,7 +409,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 code_init,\n             } => {\n                 if let FieldInnerTy::Vec(_) = info.ty {\n-                    throw_invalid_attr!(attr, &meta, |diag| {\n+                    throw_invalid_attr!(attr, |diag| {\n                         diag\n                         .note(\"`#[suggestion(...)]` applied to `Vec` field is ambiguous\")\n                         .help(\"to show a suggestion consisting of multiple parts, use a `Subdiagnostic` annotated with `#[multipart_suggestion(...)]`\")"}, {"sha": "b37dc826d28865d5cc44e237f7499571e50ac453", "filename": "compiler/rustc_macros/src/diagnostics/error.rs", "status": "modified", "additions": 8, "deletions": 47, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -1,7 +1,7 @@\n use proc_macro::{Diagnostic, Level, MultiSpan};\n use proc_macro2::TokenStream;\n use quote::quote;\n-use syn::{spanned::Spanned, Attribute, Error as SynError, Meta, NestedMeta};\n+use syn::{spanned::Spanned, Attribute, Error as SynError, Meta};\n \n #[derive(Debug)]\n pub(crate) enum DiagnosticDeriveError {\n@@ -53,6 +53,7 @@ fn path_to_string(path: &syn::Path) -> String {\n }\n \n /// Returns an error diagnostic on span `span` with msg `msg`.\n+#[must_use]\n pub(crate) fn span_err(span: impl MultiSpan, msg: &str) -> Diagnostic {\n     Diagnostic::spanned(span, Level::Error, msg)\n }\n@@ -72,10 +73,10 @@ macro_rules! throw_span_err {\n pub(crate) use throw_span_err;\n \n /// Returns an error diagnostic for an invalid attribute.\n-pub(crate) fn invalid_attr(attr: &Attribute, meta: &Meta) -> Diagnostic {\n+pub(crate) fn invalid_attr(attr: &Attribute) -> Diagnostic {\n     let span = attr.span().unwrap();\n-    let path = path_to_string(&attr.path);\n-    match meta {\n+    let path = path_to_string(attr.path());\n+    match attr.meta {\n         Meta::Path(_) => span_err(span, &format!(\"`#[{path}]` is not a valid attribute\")),\n         Meta::NameValue(_) => {\n             span_err(span, &format!(\"`#[{path} = ...]` is not a valid attribute\"))\n@@ -89,51 +90,11 @@ pub(crate) fn invalid_attr(attr: &Attribute, meta: &Meta) -> Diagnostic {\n ///\n /// For methods that return a `Result<_, DiagnosticDeriveError>`:\n macro_rules! throw_invalid_attr {\n-    ($attr:expr, $meta:expr) => {{ throw_invalid_attr!($attr, $meta, |diag| diag) }};\n-    ($attr:expr, $meta:expr, $f:expr) => {{\n-        let diag = crate::diagnostics::error::invalid_attr($attr, $meta);\n+    ($attr:expr) => {{ throw_invalid_attr!($attr, |diag| diag) }};\n+    ($attr:expr, $f:expr) => {{\n+        let diag = crate::diagnostics::error::invalid_attr($attr);\n         return Err(crate::diagnostics::error::_throw_err(diag, $f));\n     }};\n }\n \n pub(crate) use throw_invalid_attr;\n-\n-/// Returns an error diagnostic for an invalid nested attribute.\n-pub(crate) fn invalid_nested_attr(attr: &Attribute, nested: &NestedMeta) -> Diagnostic {\n-    let name = attr.path.segments.last().unwrap().ident.to_string();\n-    let name = name.as_str();\n-\n-    let span = nested.span().unwrap();\n-    let meta = match nested {\n-        syn::NestedMeta::Meta(meta) => meta,\n-        syn::NestedMeta::Lit(_) => {\n-            return span_err(span, &format!(\"`#[{name}(\\\"...\\\")]` is not a valid attribute\"));\n-        }\n-    };\n-\n-    let span = meta.span().unwrap();\n-    let path = path_to_string(meta.path());\n-    match meta {\n-        Meta::NameValue(..) => {\n-            span_err(span, &format!(\"`#[{name}({path} = ...)]` is not a valid attribute\"))\n-        }\n-        Meta::Path(..) => span_err(span, &format!(\"`#[{name}({path})]` is not a valid attribute\")),\n-        Meta::List(..) => {\n-            span_err(span, &format!(\"`#[{name}({path}(...))]` is not a valid attribute\"))\n-        }\n-    }\n-}\n-\n-/// Emit an error diagnostic for an invalid nested attribute (optionally performing additional\n-/// decoration using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n-///\n-/// For methods that return a `Result<_, DiagnosticDeriveError>`:\n-macro_rules! throw_invalid_nested_attr {\n-    ($attr:expr, $nested_attr:expr) => {{ throw_invalid_nested_attr!($attr, $nested_attr, |diag| diag) }};\n-    ($attr:expr, $nested_attr:expr, $f:expr) => {{\n-        let diag = crate::diagnostics::error::invalid_nested_attr($attr, $nested_attr);\n-        return Err(crate::diagnostics::error::_throw_err(diag, $f));\n-    }};\n-}\n-\n-pub(crate) use throw_invalid_nested_attr;"}, {"sha": "62d49c1c64e27f3787dfca6ea5a03d47557af7d8", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -1,8 +1,7 @@\n #![deny(unused_must_use)]\n \n use crate::diagnostics::error::{\n-    invalid_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n-    DiagnosticDeriveError,\n+    invalid_attr, span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n     build_field_mapping, is_doc_comment, new_code_ident,\n@@ -11,7 +10,7 @@ use crate::diagnostics::utils::{\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n-use syn::{spanned::Spanned, Attribute, Meta, MetaList, NestedMeta, Path};\n+use syn::{spanned::Spanned, Attribute, Meta, MetaList, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n use super::utils::{build_suggestion_code, AllowMultipleAlternatives};\n@@ -39,7 +38,8 @@ impl SubdiagnosticDeriveBuilder {\n                     span_err(\n                         span,\n                         \"`#[derive(Subdiagnostic)]` can only be used on structs and enums\",\n-                    );\n+                    )\n+                    .emit();\n                 }\n             }\n \n@@ -192,7 +192,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             };\n \n             let Some(slug) = slug else {\n-                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let name = attr.path().segments.last().unwrap().ident.to_string();\n                 let name = name.as_str();\n \n                 throw_span_err!(\n@@ -265,17 +265,18 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         info: FieldInfo<'_>,\n         clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let meta = attr.parse_meta()?;\n-        match meta {\n-            Meta::Path(path) => self.generate_field_code_inner_path(kind_stats, attr, info, path),\n-            Meta::List(list @ MetaList { .. }) => self.generate_field_code_inner_list(\n+        match &attr.meta {\n+            Meta::Path(path) => {\n+                self.generate_field_code_inner_path(kind_stats, attr, info, path.clone())\n+            }\n+            Meta::List(list) => self.generate_field_code_inner_list(\n                 kind_stats,\n                 attr,\n                 info,\n                 list,\n                 clone_suggestion_code,\n             ),\n-            _ => throw_invalid_attr!(attr, &meta),\n+            _ => throw_invalid_attr!(attr),\n         }\n     }\n \n@@ -296,7 +297,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             \"skip_arg\" => Ok(quote! {}),\n             \"primary_span\" => {\n                 if kind_stats.has_multipart_suggestion {\n-                    invalid_attr(attr, &Meta::Path(path))\n+                    invalid_attr(attr)\n                         .help(\n                             \"multipart suggestions use one or more `#[suggestion_part]`s rather \\\n                             than one `#[primary_span]`\",\n@@ -309,7 +310,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     // FIXME(#100717): support `Option<Span>` on `primary_span` like in the\n                     // diagnostic derive\n                     if !matches!(info.ty, FieldInnerTy::Plain(_)) {\n-                        throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n+                        throw_invalid_attr!(attr, |diag| {\n                             let diag = diag.note(\"there must be exactly one primary span\");\n \n                             if kind_stats.has_normal_suggestion {\n@@ -335,7 +336,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n                         .emit();\n                 } else {\n-                    invalid_attr(attr, &Meta::Path(path))\n+                    invalid_attr(attr)\n                         .help(\n                             \"`#[suggestion_part(...)]` is only valid in multipart suggestions, \\\n                              use `#[primary_span]` instead\",\n@@ -375,7 +376,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     span_attrs.push(\"primary_span\")\n                 }\n \n-                invalid_attr(attr, &Meta::Path(path))\n+                invalid_attr(attr)\n                     .help(format!(\n                         \"only `{}`, `applicability` and `skip_arg` are valid field attributes\",\n                         span_attrs.join(\", \")\n@@ -394,7 +395,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         kind_stats: KindsStatistics,\n         attr: &Attribute,\n         info: FieldInfo<'_>,\n-        list: MetaList,\n+        list: &MetaList,\n         clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let span = attr.span().unwrap();\n@@ -405,7 +406,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         match name {\n             \"suggestion_part\" => {\n                 if !kind_stats.has_multipart_suggestion {\n-                    throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n+                    throw_invalid_attr!(attr, |diag| {\n                         diag.help(\n                             \"`#[suggestion_part(...)]` is only valid in multipart suggestions\",\n                         )\n@@ -417,31 +418,27 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                 report_error_if_not_applied_to_span(attr, &info)?;\n \n                 let mut code = None;\n-                for nested_attr in list.nested.iter() {\n-                    let NestedMeta::Meta(ref meta) = nested_attr else {\n-                        throw_invalid_nested_attr!(attr, nested_attr);\n-                    };\n-\n-                    let span = meta.span().unwrap();\n-                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                    let nested_name = nested_name.as_str();\n-\n-                    match nested_name {\n-                        \"code\" => {\n-                            let code_field = new_code_ident();\n-                            let formatting_init = build_suggestion_code(\n-                                &code_field,\n-                                meta,\n-                                self,\n-                                AllowMultipleAlternatives::No,\n-                            );\n-                            code.set_once((code_field, formatting_init), span);\n-                        }\n-                        _ => throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n-                            diag.help(\"`code` is the only valid nested attribute\")\n-                        }),\n+\n+                list.parse_nested_meta(|nested| {\n+                    if nested.path.is_ident(\"code\") {\n+                        let code_field = new_code_ident();\n+                        let span = nested.path.span().unwrap();\n+                        let formatting_init = build_suggestion_code(\n+                            &code_field,\n+                            nested,\n+                            self,\n+                            AllowMultipleAlternatives::No,\n+                        );\n+                        code.set_once((code_field, formatting_init), span);\n+                    } else {\n+                        span_err(\n+                            nested.path.span().unwrap(),\n+                            \"`code` is the only valid nested attribute\",\n+                        )\n+                        .emit();\n                     }\n-                }\n+                    Ok(())\n+                })?;\n \n                 let Some((code_field, formatting_init)) = code.value() else {\n                     span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n@@ -458,7 +455,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                 };\n                 Ok(quote! { suggestions.push((#binding, #code_field)); })\n             }\n-            _ => throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n+            _ => throw_invalid_attr!(attr, |diag| {\n                 let mut span_attrs = vec![];\n                 if kind_stats.has_multipart_suggestion {\n                     span_attrs.push(\"suggestion_part\");"}, {"sha": "b9b09c66230b8de6bde1ee419cb04633cfd40ac3", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 116, "deletions": 106, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -1,5 +1,5 @@\n use crate::diagnostics::error::{\n-    span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err, DiagnosticDeriveError,\n+    span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use proc_macro::Span;\n use proc_macro2::{Ident, TokenStream};\n@@ -8,11 +8,13 @@ use std::cell::RefCell;\n use std::collections::{BTreeSet, HashMap};\n use std::fmt;\n use std::str::FromStr;\n+use syn::meta::ParseNestedMeta;\n+use syn::punctuated::Punctuated;\n+use syn::{parenthesized, LitStr, Path, Token};\n use syn::{spanned::Spanned, Attribute, Field, Meta, Type, TypeTuple};\n-use syn::{MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, VariantInfo};\n \n-use super::error::{invalid_attr, invalid_nested_attr};\n+use super::error::invalid_attr;\n \n thread_local! {\n     pub static CODE_IDENT_COUNT: RefCell<u32> = RefCell::new(0);\n@@ -60,8 +62,8 @@ pub(crate) fn report_type_error(\n     attr: &Attribute,\n     ty_name: &str,\n ) -> Result<!, DiagnosticDeriveError> {\n-    let name = attr.path.segments.last().unwrap().ident.to_string();\n-    let meta = attr.parse_meta()?;\n+    let name = attr.path().segments.last().unwrap().ident.to_string();\n+    let meta = &attr.meta;\n \n     throw_span_err!(\n         attr.span().unwrap(),\n@@ -418,59 +420,62 @@ pub(super) enum AllowMultipleAlternatives {\n     Yes,\n }\n \n+fn parse_suggestion_values(\n+    nested: ParseNestedMeta<'_>,\n+    allow_multiple: AllowMultipleAlternatives,\n+) -> syn::Result<Vec<LitStr>> {\n+    let values = if let Ok(val) = nested.value() {\n+        vec![val.parse()?]\n+    } else {\n+        let content;\n+        parenthesized!(content in nested.input);\n+\n+        if let AllowMultipleAlternatives::No = allow_multiple {\n+            span_err(\n+                nested.input.span().unwrap(),\n+                \"expected exactly one string literal for `code = ...`\",\n+            )\n+            .emit();\n+            vec![]\n+        } else {\n+            let literals = Punctuated::<LitStr, Token![,]>::parse_terminated(&content);\n+\n+            match literals {\n+                Ok(p) if p.is_empty() => {\n+                    span_err(\n+                        content.span().unwrap(),\n+                        \"expected at least one string literal for `code(...)`\",\n+                    )\n+                    .emit();\n+                    vec![]\n+                }\n+                Ok(p) => p.into_iter().collect(),\n+                Err(_) => {\n+                    span_err(\n+                        content.span().unwrap(),\n+                        \"`code(...)` must contain only string literals\",\n+                    )\n+                    .emit();\n+                    vec![]\n+                }\n+            }\n+        }\n+    };\n+\n+    Ok(values)\n+}\n+\n /// Constructs the `format!()` invocation(s) necessary for a `#[suggestion*(code = \"foo\")]` or\n /// `#[suggestion*(code(\"foo\", \"bar\"))]` attribute field\n pub(super) fn build_suggestion_code(\n     code_field: &Ident,\n-    meta: &Meta,\n+    nested: ParseNestedMeta<'_>,\n     fields: &impl HasFieldMap,\n     allow_multiple: AllowMultipleAlternatives,\n ) -> TokenStream {\n-    let values = match meta {\n-        // `code = \"foo\"`\n-        Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => vec![s],\n-        // `code(\"foo\", \"bar\")`\n-        Meta::List(MetaList { nested, .. }) => {\n-            if let AllowMultipleAlternatives::No = allow_multiple {\n-                span_err(\n-                    meta.span().unwrap(),\n-                    \"expected exactly one string literal for `code = ...`\",\n-                )\n-                .emit();\n-                vec![]\n-            } else if nested.is_empty() {\n-                span_err(\n-                    meta.span().unwrap(),\n-                    \"expected at least one string literal for `code(...)`\",\n-                )\n-                .emit();\n-                vec![]\n-            } else {\n-                nested\n-                    .into_iter()\n-                    .filter_map(|item| {\n-                        if let NestedMeta::Lit(syn::Lit::Str(s)) = item {\n-                            Some(s)\n-                        } else {\n-                            span_err(\n-                                item.span().unwrap(),\n-                                \"`code(...)` must contain only string literals\",\n-                            )\n-                            .emit();\n-                            None\n-                        }\n-                    })\n-                    .collect()\n-            }\n-        }\n-        _ => {\n-            span_err(\n-                meta.span().unwrap(),\n-                r#\"`code = \"...\"`/`code(...)` must contain only string literals\"#,\n-            )\n-            .emit();\n-            vec![]\n-        }\n+    let values = match parse_suggestion_values(nested, allow_multiple) {\n+        Ok(x) => x,\n+        Err(e) => return e.into_compile_error(),\n     };\n \n     if let AllowMultipleAlternatives::Yes = allow_multiple {\n@@ -601,11 +606,9 @@ impl SubdiagnosticKind {\n \n         let span = attr.span().unwrap();\n \n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = attr.path().segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n \n-        let meta = attr.parse_meta()?;\n-\n         let mut kind = match name {\n             \"label\" => SubdiagnosticKind::Label,\n             \"note\" => SubdiagnosticKind::Note,\n@@ -618,7 +621,7 @@ impl SubdiagnosticKind {\n                     name.strip_prefix(\"suggestion\").and_then(SuggestionKind::from_suffix)\n                 {\n                     if suggestion_kind != SuggestionKind::Normal {\n-                        invalid_attr(attr, &meta)\n+                        invalid_attr(attr)\n                             .help(format!(\n                                 r#\"Use `#[suggestion(..., style = \"{suggestion_kind}\")]` instead\"#\n                             ))\n@@ -635,7 +638,7 @@ impl SubdiagnosticKind {\n                     name.strip_prefix(\"multipart_suggestion\").and_then(SuggestionKind::from_suffix)\n                 {\n                     if suggestion_kind != SuggestionKind::Normal {\n-                        invalid_attr(attr, &meta)\n+                        invalid_attr(attr)\n                             .help(format!(\n                                 r#\"Use `#[multipart_suggestion(..., style = \"{suggestion_kind}\")]` instead\"#\n                             ))\n@@ -647,16 +650,16 @@ impl SubdiagnosticKind {\n                         applicability: None,\n                     }\n                 } else {\n-                    throw_invalid_attr!(attr, &meta);\n+                    throw_invalid_attr!(attr);\n                 }\n             }\n         };\n \n-        let nested = match meta {\n-            Meta::List(MetaList { ref nested, .. }) => {\n+        let list = match &attr.meta {\n+            Meta::List(list) => {\n                 // An attribute with properties, such as `#[suggestion(code = \"...\")]` or\n                 // `#[error(some::slug)]`\n-                nested\n+                list\n             }\n             Meta::Path(_) => {\n                 // An attribute without a slug or other properties, such as `#[note]` - return\n@@ -678,69 +681,68 @@ impl SubdiagnosticKind {\n                 }\n             }\n             _ => {\n-                throw_invalid_attr!(attr, &meta)\n+                throw_invalid_attr!(attr)\n             }\n         };\n \n         let mut code = None;\n         let mut suggestion_kind = None;\n \n-        let mut nested_iter = nested.into_iter().peekable();\n+        let mut first = true;\n+        let mut slug = None;\n \n-        // Peek at the first nested attribute: if it's a slug path, consume it.\n-        let slug = if let Some(NestedMeta::Meta(Meta::Path(path))) = nested_iter.peek() {\n-            let path = path.clone();\n-            // Advance the iterator.\n-            nested_iter.next();\n-            Some(path)\n-        } else {\n-            None\n-        };\n-\n-        for nested_attr in nested_iter {\n-            let meta = match nested_attr {\n-                NestedMeta::Meta(ref meta) => meta,\n-                NestedMeta::Lit(_) => {\n-                    invalid_nested_attr(attr, nested_attr).emit();\n-                    continue;\n+        list.parse_nested_meta(|nested| {\n+            if nested.input.is_empty() || nested.input.peek(Token![,]) {\n+                if first {\n+                    slug = Some(nested.path);\n+                } else {\n+                    span_err(nested.input.span().unwrap(), \"a diagnostic slug must be the first argument to the attribute\").emit();\n                 }\n-            };\n \n-            let span = meta.span().unwrap();\n-            let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                first = false;\n+                return Ok(());\n+            }\n+\n+            first = false;\n+\n+            let nested_name = nested.path.segments.last().unwrap().ident.to_string();\n             let nested_name = nested_name.as_str();\n \n-            let string_value = match meta {\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => Some(value),\n+            let path_span = nested.path.span().unwrap();\n+            let val_span = nested.input.span().unwrap();\n \n-                Meta::Path(_) => throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n-                    diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n-                }),\n-                _ => None,\n-            };\n+            macro_rules! get_string {\n+                () => {{\n+                    let Ok(value) = nested.value().and_then(|x| x.parse::<LitStr>()) else {\n+                        span_err(val_span, \"expected `= \\\"xxx\\\"`\").emit();\n+                        return Ok(());\n+                    };\n+                    value\n+                }};\n+            }\n+\n+            let mut has_errors = false;\n+            let input = nested.input;\n \n             match (nested_name, &mut kind) {\n                 (\"code\", SubdiagnosticKind::Suggestion { code_field, .. }) => {\n                     let code_init = build_suggestion_code(\n                         code_field,\n-                        meta,\n+                        nested,\n                         fields,\n                         AllowMultipleAlternatives::Yes,\n                     );\n-                    code.set_once(code_init, span);\n+                    code.set_once(code_init, path_span);\n                 }\n                 (\n                     \"applicability\",\n                     SubdiagnosticKind::Suggestion { ref mut applicability, .. }\n                     | SubdiagnosticKind::MultipartSuggestion { ref mut applicability, .. },\n                 ) => {\n-                    let Some(value) = string_value else {\n-                        invalid_nested_attr(attr, nested_attr).emit();\n-                        continue;\n-                    };\n-\n+                    let value = get_string!();\n                     let value = Applicability::from_str(&value.value()).unwrap_or_else(|()| {\n-                        span_err(span, \"invalid applicability\").emit();\n+                        span_err(value.span().unwrap(), \"invalid applicability\").emit();\n+                        has_errors = true;\n                         Applicability::Unspecified\n                     });\n                     applicability.set_once(value, span);\n@@ -750,15 +752,13 @@ impl SubdiagnosticKind {\n                     SubdiagnosticKind::Suggestion { .. }\n                     | SubdiagnosticKind::MultipartSuggestion { .. },\n                 ) => {\n-                    let Some(value) = string_value else {\n-                        invalid_nested_attr(attr, nested_attr).emit();\n-                        continue;\n-                    };\n+                    let value = get_string!();\n \n                     let value = value.value().parse().unwrap_or_else(|()| {\n                         span_err(value.span().unwrap(), \"invalid suggestion style\")\n                             .help(\"valid styles are `normal`, `short`, `hidden`, `verbose` and `tool-only`\")\n                             .emit();\n+                        has_errors = true;\n                         SuggestionKind::Normal\n                     });\n \n@@ -767,22 +767,32 @@ impl SubdiagnosticKind {\n \n                 // Invalid nested attribute\n                 (_, SubdiagnosticKind::Suggestion { .. }) => {\n-                    invalid_nested_attr(attr, nested_attr)\n+                    span_err(path_span, \"invalid nested attribute\")\n                         .help(\n                             \"only `style`, `code` and `applicability` are valid nested attributes\",\n                         )\n                         .emit();\n+                    has_errors = true;\n                 }\n                 (_, SubdiagnosticKind::MultipartSuggestion { .. }) => {\n-                    invalid_nested_attr(attr, nested_attr)\n+                    span_err(path_span, \"invalid nested attribute\")\n                         .help(\"only `style` and `applicability` are valid nested attributes\")\n-                        .emit()\n+                        .emit();\n+                    has_errors = true;\n                 }\n                 _ => {\n-                    invalid_nested_attr(attr, nested_attr).emit();\n+                    span_err(path_span, \"invalid nested attribute\").emit();\n+                    has_errors = true;\n                 }\n             }\n-        }\n+\n+            if has_errors {\n+                // Consume the rest of the input to avoid spamming errors\n+                let _ = input.parse::<TokenStream>();\n+            }\n+\n+            Ok(())\n+        })?;\n \n         match kind {\n             SubdiagnosticKind::Suggestion {\n@@ -845,5 +855,5 @@ pub(super) fn should_generate_set_arg(field: &Field) -> bool {\n }\n \n pub(super) fn is_doc_comment(attr: &Attribute) -> bool {\n-    attr.path.segments.last().unwrap().ident == \"doc\"\n+    attr.path().segments.last().unwrap().ident == \"doc\"\n }"}, {"sha": "75a2f7009c2589d7e684a4b1f74ca6c2cdcd5b2e", "filename": "compiler/rustc_macros/src/hash_stable.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -1,6 +1,6 @@\n use proc_macro2::{self, Ident};\n use quote::quote;\n-use syn::{self, parse_quote, Meta, NestedMeta};\n+use syn::{self, parse_quote};\n \n struct Attributes {\n     ignore: bool,\n@@ -10,32 +10,29 @@ struct Attributes {\n fn parse_attributes(field: &syn::Field) -> Attributes {\n     let mut attrs = Attributes { ignore: false, project: None };\n     for attr in &field.attrs {\n-        if let Ok(meta) = attr.parse_meta() {\n-            if !meta.path().is_ident(\"stable_hasher\") {\n-                continue;\n+        let meta = &attr.meta;\n+        if !meta.path().is_ident(\"stable_hasher\") {\n+            continue;\n+        }\n+        let mut any_attr = false;\n+        let _ = attr.parse_nested_meta(|nested| {\n+            if nested.path.is_ident(\"ignore\") {\n+                attrs.ignore = true;\n+                any_attr = true;\n             }\n-            let mut any_attr = false;\n-            if let Meta::List(list) = meta {\n-                for nested in list.nested.iter() {\n-                    if let NestedMeta::Meta(meta) = nested {\n-                        if meta.path().is_ident(\"ignore\") {\n-                            attrs.ignore = true;\n-                            any_attr = true;\n-                        }\n-                        if meta.path().is_ident(\"project\") {\n-                            if let Meta::List(list) = meta {\n-                                if let Some(NestedMeta::Meta(meta)) = list.nested.iter().next() {\n-                                    attrs.project = meta.path().get_ident().cloned();\n-                                    any_attr = true;\n-                                }\n-                            }\n-                        }\n+            if nested.path.is_ident(\"project\") {\n+                let _ = nested.parse_nested_meta(|meta| {\n+                    if attrs.project.is_none() {\n+                        attrs.project = meta.path.get_ident().cloned();\n                     }\n-                }\n-            }\n-            if !any_attr {\n-                panic!(\"error parsing stable_hasher\");\n+                    any_attr = true;\n+                    Ok(())\n+                });\n             }\n+            Ok(())\n+        });\n+        if !any_attr {\n+            panic!(\"error parsing stable_hasher\");\n         }\n     }\n     attrs"}, {"sha": "78a6f74887d4b1a3e258f3411f9c0ef7ee91fefd", "filename": "compiler/rustc_macros/src/newtype.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -25,7 +25,7 @@ impl Parse for Newtype {\n         let mut encodable = true;\n         let mut ord = true;\n \n-        attrs.retain(|attr| match attr.path.get_ident() {\n+        attrs.retain(|attr| match attr.path().get_ident() {\n             Some(ident) => match &*ident.to_string() {\n                 \"custom_encodable\" => {\n                     encodable = false;\n@@ -36,22 +36,22 @@ impl Parse for Newtype {\n                     false\n                 }\n                 \"max\" => {\n-                    let Ok(Meta::NameValue(literal) )= attr.parse_meta() else {\n+                    let Meta::NameValue(MetaNameValue { value: Expr::Lit(lit), .. }) = &attr.meta else {\n                         panic!(\"#[max = NUMBER] attribute requires max value\");\n                     };\n \n-                    if let Some(old) = max.replace(literal.lit) {\n+                    if let Some(old) = max.replace(lit.lit.clone()) {\n                         panic!(\"Specified multiple max: {old:?}\");\n                     }\n \n                     false\n                 }\n                 \"debug_format\" => {\n-                    let Ok(Meta::NameValue(literal) )= attr.parse_meta() else {\n+                    let Meta::NameValue(MetaNameValue { value: Expr::Lit(lit), .. }) = &attr.meta else {\n                         panic!(\"#[debug_format = FMT] attribute requires a format\");\n                     };\n \n-                    if let Some(old) = debug_format.replace(literal.lit) {\n+                    if let Some(old) = debug_format.replace(lit.lit.clone()) {\n                         panic!(\"Specified multiple debug format options: {old:?}\");\n                     }\n "}, {"sha": "f85ba38003c13a39599c31959e049d8ef3a7b32b", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -15,7 +15,7 @@ mod kw {\n /// Ensures only doc comment attributes are used\n fn check_attributes(attrs: Vec<Attribute>) -> Result<Vec<Attribute>> {\n     let inner = |attr: Attribute| {\n-        if !attr.path.is_ident(\"doc\") {\n+        if !attr.path().is_ident(\"doc\") {\n             Err(Error::new(attr.span(), \"attributes not supported on queries\"))\n         } else if attr.style != AttrStyle::Outer {\n             Err(Error::new(\n@@ -48,7 +48,7 @@ impl Parse for Query {\n         let name: Ident = input.parse()?;\n         let arg_content;\n         parenthesized!(arg_content in input);\n-        let key = arg_content.parse()?;\n+        let key = Pat::parse_single(&arg_content)?;\n         arg_content.parse::<Token![:]>()?;\n         let arg = arg_content.parse()?;\n         let result = input.parse()?;\n@@ -158,15 +158,15 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n             } else {\n                 None\n             };\n-            let list = attr_content.parse_terminated(Expr::parse)?;\n+            let list = attr_content.parse_terminated(Expr::parse, Token![,])?;\n             try_insert!(desc = (tcx, list));\n         } else if modifier == \"cache_on_disk_if\" {\n             // Parse a cache modifier like:\n             // `cache(tcx) { |tcx| key.is_local() }`\n             let args = if input.peek(token::Paren) {\n                 let args;\n                 parenthesized!(args in input);\n-                let tcx = args.parse()?;\n+                let tcx = Pat::parse_single(&args)?;\n                 Some(tcx)\n             } else {\n                 None"}, {"sha": "5ee4d8793135ca8865982460f621012f015edd27", "filename": "compiler/rustc_macros/src/type_foldable.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -1,5 +1,5 @@\n use quote::{quote, ToTokens};\n-use syn::{parse_quote, Attribute, Meta, NestedMeta};\n+use syn::parse_quote;\n \n pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n     if let syn::Data::Union(_) = s.ast().data {\n@@ -17,21 +17,20 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n         vi.construct(|_, index| {\n             let bind = &bindings[index];\n \n+            let mut fixed = false;\n+\n             // retain value of fields with #[type_foldable(identity)]\n-            let fixed = bind\n-                .ast()\n-                .attrs\n-                .iter()\n-                .map(Attribute::parse_meta)\n-                .filter_map(Result::ok)\n-                .flat_map(|attr| match attr {\n-                    Meta::List(list) if list.path.is_ident(\"type_foldable\") => list.nested,\n-                    _ => Default::default(),\n-                })\n-                .any(|nested| match nested {\n-                    NestedMeta::Meta(Meta::Path(path)) => path.is_ident(\"identity\"),\n-                    _ => false,\n+            bind.ast().attrs.iter().for_each(|x| {\n+                if !x.path().is_ident(\"type_foldable\") {\n+                    return;\n+                }\n+                let _ = x.parse_nested_meta(|nested| {\n+                    if nested.path.is_ident(\"identity\") {\n+                        fixed = true;\n+                    }\n+                    Ok(())\n                 });\n+            });\n \n             if fixed {\n                 bind.to_token_stream()"}, {"sha": "dcd505a105e579c8387f696b82b70b94e8d0655f", "filename": "compiler/rustc_macros/src/type_visitable.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -1,5 +1,5 @@\n use quote::quote;\n-use syn::{parse_quote, Attribute, Meta, NestedMeta};\n+use syn::parse_quote;\n \n pub fn type_visitable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n     if let syn::Data::Union(_) = s.ast().data {\n@@ -8,19 +8,21 @@ pub fn type_visitable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2:\n \n     // ignore fields with #[type_visitable(ignore)]\n     s.filter(|bi| {\n-        !bi.ast()\n-            .attrs\n-            .iter()\n-            .map(Attribute::parse_meta)\n-            .filter_map(Result::ok)\n-            .flat_map(|attr| match attr {\n-                Meta::List(list) if list.path.is_ident(\"type_visitable\") => list.nested,\n-                _ => Default::default(),\n-            })\n-            .any(|nested| match nested {\n-                NestedMeta::Meta(Meta::Path(path)) => path.is_ident(\"ignore\"),\n-                _ => false,\n-            })\n+        let mut ignored = false;\n+\n+        bi.ast().attrs.iter().for_each(|attr| {\n+            if !attr.path().is_ident(\"type_visitable\") {\n+                return;\n+            }\n+            let _ = attr.parse_nested_meta(|nested| {\n+                if nested.path.is_ident(\"ignore\") {\n+                    ignored = true;\n+                }\n+                Ok(())\n+            });\n+        });\n+\n+        !ignored\n     });\n \n     if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {"}, {"sha": "61724c11745c3e55d9185443737dadb22d374ea4", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -50,7 +50,7 @@ enum DiagnosticOnEnum {\n #[derive(Diagnostic)]\n #[diag(no_crate_example, code = \"E0123\")]\n #[diag = \"E0123\"]\n-//~^ ERROR `#[diag = ...]` is not a valid attribute\n+//~^ ERROR expected parentheses: #[diag(...)]\n struct WrongStructAttrStyle {}\n \n #[derive(Diagnostic)]\n@@ -62,8 +62,7 @@ struct InvalidStructAttr {}\n \n #[derive(Diagnostic)]\n #[diag(\"E0123\")]\n-//~^ ERROR `#[diag(\"...\")]` is not a valid attribute\n-//~^^ ERROR diagnostic slug not specified\n+//~^ ERROR diagnostic slug not specified\n struct InvalidLitNestedAttr {}\n \n #[derive(Diagnostic)]\n@@ -73,27 +72,25 @@ struct InvalidNestedStructAttr {}\n \n #[derive(Diagnostic)]\n #[diag(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n-//~^ ERROR `#[diag(nonsense(...))]` is not a valid attribute\n-//~^^ ERROR diagnostic slug not specified\n+//~^ ERROR diagnostic slug must be the first argument\n+//~| ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr1 {}\n \n #[derive(Diagnostic)]\n #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n-//~^ ERROR `#[diag(nonsense = ...)]` is not a valid attribute\n-//~| ERROR `#[diag(slug = ...)]` is not a valid attribute\n+//~^ ERROR unknown argument\n //~| ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr2 {}\n \n #[derive(Diagnostic)]\n #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n-//~^ ERROR `#[diag(nonsense = ...)]` is not a valid attribute\n-//~| ERROR `#[diag(slug = ...)]` is not a valid attribute\n+//~^ ERROR unknown argument\n //~| ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr3 {}\n \n #[derive(Diagnostic)]\n #[diag(no_crate_example, code = \"E0123\", slug = \"foo\")]\n-//~^ ERROR `#[diag(slug = ...)]` is not a valid attribute\n+//~^ ERROR unknown argument\n struct InvalidNestedStructAttr4 {}\n \n #[derive(Diagnostic)]\n@@ -118,7 +115,7 @@ struct CodeSpecifiedTwice {}\n \n #[derive(Diagnostic)]\n #[diag(no_crate_example, no_crate::example, code = \"E0456\")]\n-//~^ ERROR `#[diag(no_crate::example)]` is not a valid attribute\n+//~^ ERROR diagnostic slug must be the first argument\n struct SlugSpecifiedTwice {}\n \n #[derive(Diagnostic)]\n@@ -232,7 +229,7 @@ struct SuggestWithoutCode {\n #[diag(no_crate_example, code = \"E0123\")]\n struct SuggestWithBadKey {\n     #[suggestion(nonsense = \"bar\")]\n-    //~^ ERROR `#[suggestion(nonsense = ...)]` is not a valid attribute\n+    //~^ ERROR invalid nested attribute\n     //~| ERROR suggestion without `code = \"...\"`\n     suggestion: (Span, Applicability),\n }\n@@ -241,7 +238,7 @@ struct SuggestWithBadKey {\n #[diag(no_crate_example, code = \"E0123\")]\n struct SuggestWithShorthandMsg {\n     #[suggestion(msg = \"bar\")]\n-    //~^ ERROR `#[suggestion(msg = ...)]` is not a valid attribute\n+    //~^ ERROR invalid nested attribute\n     //~| ERROR suggestion without `code = \"...\"`\n     suggestion: (Span, Applicability),\n }\n@@ -530,23 +527,23 @@ struct BoolField {\n #[diag(no_crate_example, code = \"E0123\")]\n struct LabelWithTrailingPath {\n     #[label(no_crate_label, foo)]\n-    //~^ ERROR `#[label(foo)]` is not a valid attribute\n+    //~^ ERROR a diagnostic slug must be the first argument to the attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n #[diag(no_crate_example, code = \"E0123\")]\n struct LabelWithTrailingNameValue {\n     #[label(no_crate_label, foo = \"...\")]\n-    //~^ ERROR `#[label(foo = ...)]` is not a valid attribute\n+    //~^ ERROR invalid nested attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n #[diag(no_crate_example, code = \"E0123\")]\n struct LabelWithTrailingList {\n     #[label(no_crate_label, foo(\"...\"))]\n-    //~^ ERROR `#[label(foo(...))]` is not a valid attribute\n+    //~^ ERROR invalid nested attribute\n     span: Span,\n }\n \n@@ -643,8 +640,8 @@ struct MissingCodeInSuggestion {\n //~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n //~| ERROR cannot find attribute `multipart_suggestion` in this scope\n #[multipart_suggestion()]\n-//~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n-//~| ERROR cannot find attribute `multipart_suggestion` in this scope\n+//~^ ERROR cannot find attribute `multipart_suggestion` in this scope\n+//~| ERROR unexpected end of input, unexpected token in nested attribute, expected ident\n struct MultipartSuggestion {\n     #[multipart_suggestion(no_crate_suggestion)]\n     //~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n@@ -698,7 +695,7 @@ struct RawIdentDiagnosticArg {\n #[diag(no_crate_example)]\n struct SubdiagnosticBad {\n     #[subdiagnostic(bad)]\n-    //~^ ERROR `#[subdiagnostic(...)]` is not a valid attribute\n+    //~^ ERROR `eager` is the only supported nested attribute for `subdiagnostic`\n     note: Note,\n }\n \n@@ -714,15 +711,15 @@ struct SubdiagnosticBadStr {\n #[diag(no_crate_example)]\n struct SubdiagnosticBadTwice {\n     #[subdiagnostic(bad, bad)]\n-    //~^ ERROR `#[subdiagnostic(...)]` is not a valid attribute\n+    //~^ ERROR `eager` is the only supported nested attribute for `subdiagnostic`\n     note: Note,\n }\n \n #[derive(Diagnostic)]\n #[diag(no_crate_example)]\n struct SubdiagnosticBadLitStr {\n     #[subdiagnostic(\"bad\")]\n-    //~^ ERROR `#[subdiagnostic(...)]` is not a valid attribute\n+    //~^ ERROR `eager` is the only supported nested attribute for `subdiagnostic`\n     note: Note,\n }\n \n@@ -797,14 +794,15 @@ struct SuggestionsNoItem {\n struct SuggestionsInvalidItem {\n     #[suggestion(code(foo))]\n     //~^ ERROR `code(...)` must contain only string literals\n+    //~| ERROR unexpected token\n     sub: Span,\n }\n \n-#[derive(Diagnostic)]\n+#[derive(Diagnostic)] //~ ERROR cannot find value `__code_34` in this scope\n #[diag(no_crate_example)]\n struct SuggestionsInvalidLiteral {\n     #[suggestion(code = 3)]\n-    //~^ ERROR `code = \"...\"`/`code(...)` must contain only string literals\n+    //~^ ERROR expected string literal\n     sub: Span,\n }\n "}, {"sha": "cd14c7496b37deb1ffbb9aa87618ede10e91547b", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 144, "deletions": 169, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -20,11 +20,11 @@ LL |     Bar,\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n-error: `#[diag = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:52:1\n+error: expected parentheses: #[diag(...)]\n+  --> $DIR/diagnostic-derive.rs:52:8\n    |\n LL | #[diag = \"E0123\"]\n-   | ^^^^^^^^^^^^^^^^^\n+   |        ^\n \n error: `#[nonsense(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:57:1\n@@ -44,35 +44,24 @@ LL | | struct InvalidStructAttr {}\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n-error: `#[diag(\"...\")]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:64:8\n-   |\n-LL | #[diag(\"E0123\")]\n-   |        ^^^^^^^\n-   |\n-   = help: a diagnostic slug is required as the first argument\n-\n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:64:1\n    |\n LL | / #[diag(\"E0123\")]\n LL | |\n-LL | |\n LL | | struct InvalidLitNestedAttr {}\n    | |______________________________^\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n-error: `#[diag(nonsense(...))]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:75:8\n+error: diagnostic slug must be the first argument\n+  --> $DIR/diagnostic-derive.rs:74:16\n    |\n LL | #[diag(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n-   |        ^^^^^^^^^^^^^^^\n-   |\n-   = help: a diagnostic slug is required as the first argument\n+   |                ^\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:75:1\n+  --> $DIR/diagnostic-derive.rs:74:1\n    |\n LL | / #[diag(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n LL | |\n@@ -82,128 +71,110 @@ LL | | struct InvalidNestedStructAttr1 {}\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n-error: `#[diag(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:81:8\n-   |\n-LL | #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n-   |        ^^^^^^^^^^^^^^^^\n-   |\n-   = help: only `code` is a valid nested attributes following the slug\n-\n-error: `#[diag(slug = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:81:42\n+error: unknown argument\n+  --> $DIR/diagnostic-derive.rs:80:8\n    |\n LL | #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n-   |                                          ^^^^^^^^^^^^\n+   |        ^^^^^^^^\n    |\n-   = help: only `code` is a valid nested attributes following the slug\n+   = note: only the `code` parameter is valid after the slug\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:81:1\n+  --> $DIR/diagnostic-derive.rs:80:1\n    |\n LL | / #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n LL | |\n LL | |\n-LL | |\n LL | | struct InvalidNestedStructAttr2 {}\n    | |__________________________________^\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n-error: `#[diag(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:88:8\n-   |\n-LL | #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n-   |        ^^^^^^^^^^^^\n-\n-error: `#[diag(slug = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:88:38\n+error: unknown argument\n+  --> $DIR/diagnostic-derive.rs:86:8\n    |\n LL | #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n-   |                                      ^^^^^^^^^^^^\n+   |        ^^^^^^^^\n    |\n-   = help: only `code` is a valid nested attributes following the slug\n+   = note: only the `code` parameter is valid after the slug\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:88:1\n+  --> $DIR/diagnostic-derive.rs:86:1\n    |\n LL | / #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n LL | |\n LL | |\n-LL | |\n LL | | struct InvalidNestedStructAttr3 {}\n    | |__________________________________^\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n-error: `#[diag(slug = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:95:42\n+error: unknown argument\n+  --> $DIR/diagnostic-derive.rs:92:42\n    |\n LL | #[diag(no_crate_example, code = \"E0123\", slug = \"foo\")]\n-   |                                          ^^^^^^^^^^^^\n+   |                                          ^^^^\n    |\n-   = help: only `code` is a valid nested attributes following the slug\n+   = note: only the `code` parameter is valid after the slug\n \n error: `#[suggestion = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:102:5\n+  --> $DIR/diagnostic-derive.rs:99:5\n    |\n LL |     #[suggestion = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:109:8\n+  --> $DIR/diagnostic-derive.rs:106:8\n    |\n LL | #[diag(no_crate_example, code = \"E0456\")]\n    |        ^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:108:8\n+  --> $DIR/diagnostic-derive.rs:105:8\n    |\n LL | #[diag(no_crate_example, code = \"E0123\")]\n    |        ^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:109:33\n+  --> $DIR/diagnostic-derive.rs:106:26\n    |\n LL | #[diag(no_crate_example, code = \"E0456\")]\n-   |                                 ^^^^^^^\n+   |                          ^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:108:33\n+  --> $DIR/diagnostic-derive.rs:105:26\n    |\n LL | #[diag(no_crate_example, code = \"E0123\")]\n-   |                                 ^^^^^^^\n+   |                          ^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:115:49\n+  --> $DIR/diagnostic-derive.rs:112:42\n    |\n LL | #[diag(no_crate_example, code = \"E0456\", code = \"E0457\")]\n-   |                                                 ^^^^^^^\n+   |                                          ^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:115:33\n+  --> $DIR/diagnostic-derive.rs:112:26\n    |\n LL | #[diag(no_crate_example, code = \"E0456\", code = \"E0457\")]\n-   |                                 ^^^^^^^\n+   |                          ^^^^\n \n-error: `#[diag(no_crate::example)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:120:26\n+error: diagnostic slug must be the first argument\n+  --> $DIR/diagnostic-derive.rs:117:43\n    |\n LL | #[diag(no_crate_example, no_crate::example, code = \"E0456\")]\n-   |                          ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: diagnostic slug must be the first argument\n+   |                                           ^\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:125:1\n+  --> $DIR/diagnostic-derive.rs:122:1\n    |\n LL | struct KindNotProvided {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:128:1\n+  --> $DIR/diagnostic-derive.rs:125:1\n    |\n LL | / #[diag(code = \"E0456\")]\n LL | |\n@@ -213,31 +184,31 @@ LL | | struct SlugNotProvided {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/diagnostic-derive.rs:139:5\n+  --> $DIR/diagnostic-derive.rs:136:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: `#[nonsense]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:147:5\n+  --> $DIR/diagnostic-derive.rs:144:5\n    |\n LL |     #[nonsense]\n    |     ^^^^^^^^^^^\n \n error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/diagnostic-derive.rs:164:5\n+  --> $DIR/diagnostic-derive.rs:161:5\n    |\n LL |     #[label(no_crate_label)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `name` doesn't refer to a field on this type\n-  --> $DIR/diagnostic-derive.rs:172:46\n+  --> $DIR/diagnostic-derive.rs:169:46\n    |\n LL |     #[suggestion(no_crate_suggestion, code = \"{name}\")]\n    |                                              ^^^^^^^^\n \n error: invalid format string: expected `'}'` but string was terminated\n-  --> $DIR/diagnostic-derive.rs:177:10\n+  --> $DIR/diagnostic-derive.rs:174:10\n    |\n LL | #[derive(Diagnostic)]\n    |          ^^^^^^^^^^ expected `'}'` in format string\n@@ -246,7 +217,7 @@ LL | #[derive(Diagnostic)]\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: invalid format string: unmatched `}` found\n-  --> $DIR/diagnostic-derive.rs:187:10\n+  --> $DIR/diagnostic-derive.rs:184:10\n    |\n LL | #[derive(Diagnostic)]\n    |          ^^^^^^^^^^ unmatched `}` in format string\n@@ -255,47 +226,47 @@ LL | #[derive(Diagnostic)]\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/diagnostic-derive.rs:207:5\n+  --> $DIR/diagnostic-derive.rs:204:5\n    |\n LL |     #[label(no_crate_label)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: suggestion without `code = \"...\"`\n-  --> $DIR/diagnostic-derive.rs:226:5\n+  --> $DIR/diagnostic-derive.rs:223:5\n    |\n LL |     #[suggestion(no_crate_suggestion)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `#[suggestion(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:234:18\n+error: invalid nested attribute\n+  --> $DIR/diagnostic-derive.rs:231:18\n    |\n LL |     #[suggestion(nonsense = \"bar\")]\n-   |                  ^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^\n    |\n    = help: only `style`, `code` and `applicability` are valid nested attributes\n \n error: suggestion without `code = \"...\"`\n-  --> $DIR/diagnostic-derive.rs:234:5\n+  --> $DIR/diagnostic-derive.rs:231:5\n    |\n LL |     #[suggestion(nonsense = \"bar\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `#[suggestion(msg = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:243:18\n+error: invalid nested attribute\n+  --> $DIR/diagnostic-derive.rs:240:18\n    |\n LL |     #[suggestion(msg = \"bar\")]\n-   |                  ^^^^^^^^^^^\n+   |                  ^^^\n    |\n    = help: only `style`, `code` and `applicability` are valid nested attributes\n \n error: suggestion without `code = \"...\"`\n-  --> $DIR/diagnostic-derive.rs:243:5\n+  --> $DIR/diagnostic-derive.rs:240:5\n    |\n LL |     #[suggestion(msg = \"bar\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: wrong field type for suggestion\n-  --> $DIR/diagnostic-derive.rs:266:5\n+  --> $DIR/diagnostic-derive.rs:263:5\n    |\n LL | /     #[suggestion(no_crate_suggestion, code = \"This is suggested code\")]\n LL | |\n@@ -305,95 +276,93 @@ LL | |     suggestion: Applicability,\n    = help: `#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:282:24\n+  --> $DIR/diagnostic-derive.rs:279:24\n    |\n LL |     suggestion: (Span, Span, Applicability),\n    |                        ^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:282:18\n+  --> $DIR/diagnostic-derive.rs:279:18\n    |\n LL |     suggestion: (Span, Span, Applicability),\n    |                  ^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:290:33\n+  --> $DIR/diagnostic-derive.rs:287:33\n    |\n LL |     suggestion: (Applicability, Applicability, Span),\n    |                                 ^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:290:18\n+  --> $DIR/diagnostic-derive.rs:287:18\n    |\n LL |     suggestion: (Applicability, Applicability, Span),\n    |                  ^^^^^^^^^^^^^\n \n error: `#[label = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:297:5\n+  --> $DIR/diagnostic-derive.rs:294:5\n    |\n LL |     #[label = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:448:53\n+  --> $DIR/diagnostic-derive.rs:445:5\n    |\n LL |     #[suggestion(no_crate_suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n-   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:450:24\n+  --> $DIR/diagnostic-derive.rs:447:24\n    |\n LL |     suggestion: (Span, Applicability),\n    |                        ^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/diagnostic-derive.rs:456:53\n+  --> $DIR/diagnostic-derive.rs:453:69\n    |\n LL |     #[suggestion(no_crate_suggestion, code = \"...\", applicability = \"batman\")]\n-   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                                                     ^^^^^^^^\n \n error: the `#[help(...)]` attribute can only be applied to fields of type `Span`, `bool` or `()`\n-  --> $DIR/diagnostic-derive.rs:523:5\n+  --> $DIR/diagnostic-derive.rs:520:5\n    |\n LL |     #[help(no_crate_help)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `#[label(foo)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:532:29\n+error: a diagnostic slug must be the first argument to the attribute\n+  --> $DIR/diagnostic-derive.rs:529:32\n    |\n LL |     #[label(no_crate_label, foo)]\n-   |                             ^^^\n-   |\n-   = help: a diagnostic slug must be the first argument to the attribute\n+   |                                ^\n \n-error: `#[label(foo = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:540:29\n+error: invalid nested attribute\n+  --> $DIR/diagnostic-derive.rs:537:29\n    |\n LL |     #[label(no_crate_label, foo = \"...\")]\n-   |                             ^^^^^^^^^^^\n+   |                             ^^^\n \n-error: `#[label(foo(...))]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:548:29\n+error: invalid nested attribute\n+  --> $DIR/diagnostic-derive.rs:545:29\n    |\n LL |     #[label(no_crate_label, foo(\"...\"))]\n-   |                             ^^^^^^^^^^\n+   |                             ^^^\n \n error: `#[primary_span]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:560:5\n+  --> $DIR/diagnostic-derive.rs:557:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n    = help: the `primary_span` field attribute is not valid for lint diagnostics\n \n error: `#[error(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:580:1\n+  --> $DIR/diagnostic-derive.rs:577:1\n    |\n LL | #[error(no_crate_example, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:580:1\n+  --> $DIR/diagnostic-derive.rs:577:1\n    |\n LL | / #[error(no_crate_example, code = \"E0123\")]\n LL | |\n@@ -405,13 +374,13 @@ LL | | struct ErrorAttribute {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: `#[warn_(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:587:1\n+  --> $DIR/diagnostic-derive.rs:584:1\n    |\n LL | #[warn_(no_crate_example, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:587:1\n+  --> $DIR/diagnostic-derive.rs:584:1\n    |\n LL | / #[warn_(no_crate_example, code = \"E0123\")]\n LL | |\n@@ -423,13 +392,13 @@ LL | | struct WarnAttribute {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: `#[lint(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:594:1\n+  --> $DIR/diagnostic-derive.rs:591:1\n    |\n LL | #[lint(no_crate_example, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:594:1\n+  --> $DIR/diagnostic-derive.rs:591:1\n    |\n LL | / #[lint(no_crate_example, code = \"E0123\")]\n LL | |\n@@ -441,19 +410,19 @@ LL | | struct LintAttributeOnSessionDiag {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: `#[lint(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:601:1\n+  --> $DIR/diagnostic-derive.rs:598:1\n    |\n LL | #[lint(no_crate_example, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[lint(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:601:1\n+  --> $DIR/diagnostic-derive.rs:598:1\n    |\n LL | #[lint(no_crate_example, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:601:1\n+  --> $DIR/diagnostic-derive.rs:598:1\n    |\n LL | / #[lint(no_crate_example, code = \"E0123\")]\n LL | |\n@@ -466,137 +435,135 @@ LL | | struct LintAttributeOnLintDiag {}\n    = help: specify the slug as the first argument to the attribute, such as `#[diag(compiletest_example)]`\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:611:53\n+  --> $DIR/diagnostic-derive.rs:608:53\n    |\n LL |     #[suggestion(no_crate_suggestion, code = \"...\", code = \",,,\")]\n-   |                                                     ^^^^^^^^^^^^\n+   |                                                     ^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:611:39\n+  --> $DIR/diagnostic-derive.rs:608:39\n    |\n LL |     #[suggestion(no_crate_suggestion, code = \"...\", code = \",,,\")]\n-   |                                       ^^^^^^^^^^^^\n+   |                                       ^^^^\n \n error: wrong types for suggestion\n-  --> $DIR/diagnostic-derive.rs:620:24\n+  --> $DIR/diagnostic-derive.rs:617:24\n    |\n LL |     suggestion: (Span, usize),\n    |                        ^^^^^\n    |\n    = help: `#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\n \n error: wrong types for suggestion\n-  --> $DIR/diagnostic-derive.rs:628:17\n+  --> $DIR/diagnostic-derive.rs:625:17\n    |\n LL |     suggestion: (Span,),\n    |                 ^^^^^^^\n    |\n    = help: `#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\n \n error: suggestion without `code = \"...\"`\n-  --> $DIR/diagnostic-derive.rs:635:5\n+  --> $DIR/diagnostic-derive.rs:632:5\n    |\n LL |     #[suggestion(no_crate_suggestion)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[multipart_suggestion(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:642:1\n+  --> $DIR/diagnostic-derive.rs:639:1\n    |\n LL | #[multipart_suggestion(no_crate_suggestion)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider creating a `Subdiagnostic` instead\n \n error: `#[multipart_suggestion(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:645:1\n-   |\n-LL | #[multipart_suggestion()]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider creating a `Subdiagnostic` instead\n-\n-error: `#[multipart_suggestion(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:649:5\n+  --> $DIR/diagnostic-derive.rs:646:5\n    |\n LL |     #[multipart_suggestion(no_crate_suggestion)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider creating a `Subdiagnostic` instead\n \n+error: unexpected end of input, unexpected token in nested attribute, expected ident\n+  --> $DIR/diagnostic-derive.rs:642:24\n+   |\n+LL | #[multipart_suggestion()]\n+   |                        ^\n+\n error: `#[suggestion(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:657:1\n+  --> $DIR/diagnostic-derive.rs:654:1\n    |\n LL | #[suggestion(no_crate_suggestion, code = \"...\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: `#[label]` and `#[suggestion]` can only be applied to fields\n \n error: `#[label]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:666:1\n+  --> $DIR/diagnostic-derive.rs:663:1\n    |\n LL | #[label]\n    | ^^^^^^^^\n    |\n    = help: `#[label]` and `#[suggestion]` can only be applied to fields\n \n-error: `#[subdiagnostic(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:700:5\n+error: `eager` is the only supported nested attribute for `subdiagnostic`\n+  --> $DIR/diagnostic-derive.rs:697:7\n    |\n LL |     #[subdiagnostic(bad)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `eager` is the only supported nested attribute for `subdiagnostic`\n+   |       ^^^^^^^^^^^^^^^^^^\n \n error: `#[subdiagnostic = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:708:5\n+  --> $DIR/diagnostic-derive.rs:705:5\n    |\n LL |     #[subdiagnostic = \"bad\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `#[subdiagnostic(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:716:5\n+error: `eager` is the only supported nested attribute for `subdiagnostic`\n+  --> $DIR/diagnostic-derive.rs:713:7\n    |\n LL |     #[subdiagnostic(bad, bad)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `eager` is the only supported nested attribute for `subdiagnostic`\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `#[subdiagnostic(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:724:5\n+error: `eager` is the only supported nested attribute for `subdiagnostic`\n+  --> $DIR/diagnostic-derive.rs:721:7\n    |\n LL |     #[subdiagnostic(\"bad\")]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `eager` is the only supported nested attribute for `subdiagnostic`\n+   |       ^^^^^^^^^^^^^^^^^^^^\n \n error: `#[subdiagnostic(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:732:5\n+  --> $DIR/diagnostic-derive.rs:729:5\n    |\n LL |     #[subdiagnostic(eager)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: eager subdiagnostics are not supported on lints\n \n error: expected at least one string literal for `code(...)`\n-  --> $DIR/diagnostic-derive.rs:790:18\n+  --> $DIR/diagnostic-derive.rs:787:23\n    |\n LL |     #[suggestion(code())]\n-   |                  ^^^^^^\n+   |                       ^\n \n error: `code(...)` must contain only string literals\n-  --> $DIR/diagnostic-derive.rs:798:23\n+  --> $DIR/diagnostic-derive.rs:795:23\n    |\n LL |     #[suggestion(code(foo))]\n    |                       ^^^\n \n-error: `code = \"...\"`/`code(...)` must contain only string literals\n-  --> $DIR/diagnostic-derive.rs:806:18\n+error: unexpected token\n+  --> $DIR/diagnostic-derive.rs:795:23\n+   |\n+LL |     #[suggestion(code(foo))]\n+   |                       ^^^\n+\n+error: expected string literal\n+  --> $DIR/diagnostic-derive.rs:804:25\n    |\n LL |     #[suggestion(code = 3)]\n-   |                  ^^^^^^^^\n+   |                         ^\n \n error: `#[suggestion(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:821:5\n+  --> $DIR/diagnostic-derive.rs:819:5\n    |\n LL |     #[suggestion(no_crate_suggestion, code = \"\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -612,61 +579,69 @@ LL | #[nonsense(no_crate_example, code = \"E0123\")]\n    |   ^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n-  --> $DIR/diagnostic-derive.rs:147:7\n+  --> $DIR/diagnostic-derive.rs:144:7\n    |\n LL |     #[nonsense]\n    |       ^^^^^^^^\n \n error: cannot find attribute `error` in this scope\n-  --> $DIR/diagnostic-derive.rs:580:3\n+  --> $DIR/diagnostic-derive.rs:577:3\n    |\n LL | #[error(no_crate_example, code = \"E0123\")]\n    |   ^^^^^\n \n error: cannot find attribute `warn_` in this scope\n-  --> $DIR/diagnostic-derive.rs:587:3\n+  --> $DIR/diagnostic-derive.rs:584:3\n    |\n LL | #[warn_(no_crate_example, code = \"E0123\")]\n    |   ^^^^^ help: a built-in attribute with a similar name exists: `warn`\n \n error: cannot find attribute `lint` in this scope\n-  --> $DIR/diagnostic-derive.rs:594:3\n+  --> $DIR/diagnostic-derive.rs:591:3\n    |\n LL | #[lint(no_crate_example, code = \"E0123\")]\n    |   ^^^^ help: a built-in attribute with a similar name exists: `link`\n \n error: cannot find attribute `lint` in this scope\n-  --> $DIR/diagnostic-derive.rs:601:3\n+  --> $DIR/diagnostic-derive.rs:598:3\n    |\n LL | #[lint(no_crate_example, code = \"E0123\")]\n    |   ^^^^ help: a built-in attribute with a similar name exists: `link`\n \n error: cannot find attribute `multipart_suggestion` in this scope\n-  --> $DIR/diagnostic-derive.rs:642:3\n+  --> $DIR/diagnostic-derive.rs:639:3\n    |\n LL | #[multipart_suggestion(no_crate_suggestion)]\n    |   ^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `multipart_suggestion` in this scope\n-  --> $DIR/diagnostic-derive.rs:645:3\n+  --> $DIR/diagnostic-derive.rs:642:3\n    |\n LL | #[multipart_suggestion()]\n    |   ^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `multipart_suggestion` in this scope\n-  --> $DIR/diagnostic-derive.rs:649:7\n+  --> $DIR/diagnostic-derive.rs:646:7\n    |\n LL |     #[multipart_suggestion(no_crate_suggestion)]\n    |       ^^^^^^^^^^^^^^^^^^^^\n \n error[E0425]: cannot find value `nonsense` in module `crate::fluent_generated`\n-  --> $DIR/diagnostic-derive.rs:70:8\n+  --> $DIR/diagnostic-derive.rs:69:8\n    |\n LL | #[diag(nonsense, code = \"E0123\")]\n    |        ^^^^^^^^ not found in `crate::fluent_generated`\n \n+error[E0425]: cannot find value `__code_34` in this scope\n+  --> $DIR/diagnostic-derive.rs:801:10\n+   |\n+LL | #[derive(Diagnostic)]\n+   |          ^^^^^^^^^^ not found in this scope\n+   |\n+   = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error[E0277]: the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n-  --> $DIR/diagnostic-derive.rs:341:10\n+  --> $DIR/diagnostic-derive.rs:338:10\n    |\n LL | #[derive(Diagnostic)]\n    |          ^^^^^^^^^^ the trait `IntoDiagnosticArg` is not implemented for `Hello`\n@@ -676,7 +651,7 @@ note: required by a bound in `DiagnosticBuilder::<'a, G>::set_arg`\n   --> $COMPILER_DIR/rustc_errors/src/diagnostic_builder.rs:LL:CC\n    = note: this error originates in the derive macro `Diagnostic` which comes from the expansion of the macro `forward` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 85 previous errors\n+error: aborting due to 84 previous errors\n \n Some errors have detailed explanations: E0277, E0425.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "1d928ca93f9cb24a8e121b32c088e9faddbc323d", "filename": "tests/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -82,7 +82,7 @@ struct F {\n \n #[derive(Subdiagnostic)]\n #[label(bug = \"...\")]\n-//~^ ERROR `#[label(bug = ...)]` is not a valid attribute\n+//~^ ERROR invalid nested attribute\n //~| ERROR diagnostic slug must be first argument\n struct G {\n     #[primary_span]\n@@ -92,8 +92,7 @@ struct G {\n \n #[derive(Subdiagnostic)]\n #[label(\"...\")]\n-//~^ ERROR `#[label(\"...\")]` is not a valid attribute\n-//~| ERROR diagnostic slug must be first argument\n+//~^ ERROR unexpected literal in nested attribute, expected ident\n struct H {\n     #[primary_span]\n     span: Span,\n@@ -102,7 +101,7 @@ struct H {\n \n #[derive(Subdiagnostic)]\n #[label(slug = 4)]\n-//~^ ERROR `#[label(slug = ...)]` is not a valid attribute\n+//~^ ERROR invalid nested attribute\n //~| ERROR diagnostic slug must be first argument\n struct J {\n     #[primary_span]\n@@ -112,7 +111,7 @@ struct J {\n \n #[derive(Subdiagnostic)]\n #[label(slug(\"...\"))]\n-//~^ ERROR `#[label(slug(...))]` is not a valid attribute\n+//~^ ERROR invalid nested attribute\n //~| ERROR diagnostic slug must be first argument\n struct K {\n     #[primary_span]\n@@ -132,7 +131,7 @@ struct L {\n \n #[derive(Subdiagnostic)]\n #[label()]\n-//~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n+//~^ ERROR unexpected end of input, unexpected token in nested attribute, expected ident\n struct M {\n     #[primary_span]\n     span: Span,\n@@ -141,7 +140,7 @@ struct M {\n \n #[derive(Subdiagnostic)]\n #[label(no_crate_example, code = \"...\")]\n-//~^ ERROR `#[label(code = ...)]` is not a valid attribute\n+//~^ ERROR invalid nested attribute\n struct N {\n     #[primary_span]\n     span: Span,\n@@ -150,7 +149,7 @@ struct N {\n \n #[derive(Subdiagnostic)]\n #[label(no_crate_example, applicability = \"machine-applicable\")]\n-//~^ ERROR `#[label(applicability = ...)]` is not a valid attribute\n+//~^ ERROR invalid nested attribute\n struct O {\n     #[primary_span]\n     span: Span,\n@@ -222,7 +221,7 @@ enum T {\n enum U {\n     #[label(code = \"...\")]\n     //~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n-    //~| ERROR `#[label(code = ...)]` is not a valid attribute\n+    //~| ERROR invalid nested attribute\n     A {\n         #[primary_span]\n         span: Span,\n@@ -323,7 +322,7 @@ struct AD {\n \n #[derive(Subdiagnostic)]\n #[label(no_crate_example, no_crate::example)]\n-//~^ ERROR `#[label(no_crate::example)]` is not a valid attribute\n+//~^ ERROR a diagnostic slug must be the first argument to the attribute\n struct AE {\n     #[primary_span]\n     span: Span,\n@@ -537,7 +536,7 @@ struct BA {\n #[derive(Subdiagnostic)]\n #[multipart_suggestion(no_crate_example, code = \"...\", applicability = \"machine-applicable\")]\n //~^ ERROR multipart suggestion without any `#[suggestion_part(...)]` fields\n-//~| ERROR `#[multipart_suggestion(code = ...)]` is not a valid attribute\n+//~| ERROR invalid nested attribute\n struct BBa {\n     var: String,\n }\n@@ -554,7 +553,7 @@ struct BBb {\n #[multipart_suggestion(no_crate_example, applicability = \"machine-applicable\")]\n struct BBc {\n     #[suggestion_part()]\n-    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+    //~^ ERROR unexpected end of input, unexpected token in nested attribute, expected ident\n     span1: Span,\n }\n \n@@ -574,10 +573,11 @@ struct BD {\n     //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n     span1: Span,\n     #[suggestion_part()]\n-    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+    //~^ ERROR unexpected end of input, unexpected token in nested attribute, expected ident\n     span2: Span,\n     #[suggestion_part(foo = \"bar\")]\n-    //~^ ERROR `#[suggestion_part(foo = ...)]` is not a valid attribute\n+    //~^ ERROR `code` is the only valid nested attribute\n+    //~| ERROR expected `,`\n     span4: Span,\n     #[suggestion_part(code = \"...\")]\n     //~^ ERROR the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n@@ -669,6 +669,7 @@ enum BL {\n struct BM {\n     #[suggestion_part(code(\"foo\"))]\n     //~^ ERROR expected exactly one string literal for `code = ...`\n+    //~| ERROR unexpected token\n     span: Span,\n     r#type: String,\n }\n@@ -678,6 +679,7 @@ struct BM {\n struct BN {\n     #[suggestion_part(code(\"foo\", \"bar\"))]\n     //~^ ERROR expected exactly one string literal for `code = ...`\n+    //~| ERROR unexpected token\n     span: Span,\n     r#type: String,\n }\n@@ -687,6 +689,7 @@ struct BN {\n struct BO {\n     #[suggestion_part(code(3))]\n     //~^ ERROR expected exactly one string literal for `code = ...`\n+    //~| ERROR unexpected token\n     span: Span,\n     r#type: String,\n }\n@@ -701,10 +704,13 @@ struct BP {\n }\n \n #[derive(Subdiagnostic)]\n+//~^ ERROR cannot find value `__code_29` in this scope\n+//~| NOTE in this expansion\n+//~| NOTE not found in this scope\n #[multipart_suggestion(no_crate_example)]\n struct BQ {\n     #[suggestion_part(code = 3)]\n-    //~^ ERROR `code = \"...\"`/`code(...)` must contain only string literals\n+    //~^ ERROR expected string literal\n     span: Span,\n     r#type: String,\n }\n@@ -779,23 +785,24 @@ struct SuggestionStyleInvalid1 {\n \n #[derive(Subdiagnostic)]\n #[suggestion(no_crate_example, code = \"\", style = 42)]\n-//~^ ERROR `#[suggestion(style = ...)]` is not a valid attribute\n+//~^ ERROR expected `= \"xxx\"`\n struct SuggestionStyleInvalid2 {\n     #[primary_span]\n     sub: Span,\n }\n \n #[derive(Subdiagnostic)]\n #[suggestion(no_crate_example, code = \"\", style)]\n-//~^ ERROR `#[suggestion(style)]` is not a valid attribute\n+//~^ ERROR a diagnostic slug must be the first argument to the attribute\n struct SuggestionStyleInvalid3 {\n     #[primary_span]\n     sub: Span,\n }\n \n #[derive(Subdiagnostic)]\n #[suggestion(no_crate_example, code = \"\", style(\"foo\"))]\n-//~^ ERROR `#[suggestion(style(...))]` is not a valid attribute\n+//~^ ERROR expected `= \"xxx\"`\n+//~| ERROr expected `,`\n struct SuggestionStyleInvalid4 {\n     #[primary_span]\n     sub: Span,"}, {"sha": "4211b91f04a0ed0ea14aeeadc8963966770f70d1", "filename": "tests/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 157, "deletions": 131, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/32ea4bb9e3785ae76660b1303e821255c02aad1a/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32ea4bb9e3785ae76660b1303e821255c02aad1a/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=32ea4bb9e3785ae76660b1303e821255c02aad1a", "patch": "@@ -26,122 +26,116 @@ error: `#[label = ...]` is not a valid attribute\n LL | #[label = \"...\"]\n    | ^^^^^^^^^^^^^^^^\n \n-error: `#[label(bug = ...)]` is not a valid attribute\n+error: invalid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:84:9\n    |\n LL | #[label(bug = \"...\")]\n-   |         ^^^^^^^^^^^\n+   |         ^^^\n \n error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n   --> $DIR/subdiagnostic-derive.rs:84:1\n    |\n LL | #[label(bug = \"...\")]\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n-error: `#[label(\"...\")]` is not a valid attribute\n+error: unexpected literal in nested attribute, expected ident\n   --> $DIR/subdiagnostic-derive.rs:94:9\n    |\n LL | #[label(\"...\")]\n    |         ^^^^^\n \n-error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n-  --> $DIR/subdiagnostic-derive.rs:94:1\n-   |\n-LL | #[label(\"...\")]\n-   | ^^^^^^^^^^^^^^^\n-\n-error: `#[label(slug = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:104:9\n+error: invalid nested attribute\n+  --> $DIR/subdiagnostic-derive.rs:103:9\n    |\n LL | #[label(slug = 4)]\n-   |         ^^^^^^^^\n+   |         ^^^^\n \n error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n-  --> $DIR/subdiagnostic-derive.rs:104:1\n+  --> $DIR/subdiagnostic-derive.rs:103:1\n    |\n LL | #[label(slug = 4)]\n    | ^^^^^^^^^^^^^^^^^^\n \n-error: `#[label(slug(...))]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:114:9\n+error: invalid nested attribute\n+  --> $DIR/subdiagnostic-derive.rs:113:9\n    |\n LL | #[label(slug(\"...\"))]\n-   |         ^^^^^^^^^^^\n+   |         ^^^^\n \n error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n-  --> $DIR/subdiagnostic-derive.rs:114:1\n+  --> $DIR/subdiagnostic-derive.rs:113:1\n    |\n LL | #[label(slug(\"...\"))]\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n-error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n-  --> $DIR/subdiagnostic-derive.rs:134:1\n+error: unexpected end of input, unexpected token in nested attribute, expected ident\n+  --> $DIR/subdiagnostic-derive.rs:133:9\n    |\n LL | #[label()]\n-   | ^^^^^^^^^^\n+   |         ^\n \n-error: `#[label(code = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:143:27\n+error: invalid nested attribute\n+  --> $DIR/subdiagnostic-derive.rs:142:27\n    |\n LL | #[label(no_crate_example, code = \"...\")]\n-   |                           ^^^^^^^^^^^^\n+   |                           ^^^^\n \n-error: `#[label(applicability = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:152:27\n+error: invalid nested attribute\n+  --> $DIR/subdiagnostic-derive.rs:151:27\n    |\n LL | #[label(no_crate_example, applicability = \"machine-applicable\")]\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                           ^^^^^^^^^^^^^\n \n error: unsupported type attribute for subdiagnostic enum\n-  --> $DIR/subdiagnostic-derive.rs:161:1\n+  --> $DIR/subdiagnostic-derive.rs:160:1\n    |\n LL | #[foo]\n    | ^^^^^^\n \n error: `#[bar]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:175:5\n+  --> $DIR/subdiagnostic-derive.rs:174:5\n    |\n LL |     #[bar]\n    |     ^^^^^^\n \n error: `#[bar = ...]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:187:5\n+  --> $DIR/subdiagnostic-derive.rs:186:5\n    |\n LL |     #[bar = \"...\"]\n    |     ^^^^^^^^^^^^^^\n \n error: `#[bar = ...]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:199:5\n+  --> $DIR/subdiagnostic-derive.rs:198:5\n    |\n LL |     #[bar = 4]\n    |     ^^^^^^^^^^\n \n error: `#[bar(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:211:5\n+  --> $DIR/subdiagnostic-derive.rs:210:5\n    |\n LL |     #[bar(\"...\")]\n    |     ^^^^^^^^^^^^^\n \n-error: `#[label(code = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:223:13\n+error: invalid nested attribute\n+  --> $DIR/subdiagnostic-derive.rs:222:13\n    |\n LL |     #[label(code = \"...\")]\n-   |             ^^^^^^^^^^^^\n+   |             ^^^^\n \n error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n-  --> $DIR/subdiagnostic-derive.rs:223:5\n+  --> $DIR/subdiagnostic-derive.rs:222:5\n    |\n LL |     #[label(code = \"...\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/subdiagnostic-derive.rs:252:5\n+  --> $DIR/subdiagnostic-derive.rs:251:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: label without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:249:1\n+  --> $DIR/subdiagnostic-derive.rs:248:1\n    |\n LL | / #[label(no_crate_example)]\n LL | |\n@@ -153,35 +147,35 @@ LL | | }\n    | |_^\n \n error: `#[applicability]` is only valid on suggestions\n-  --> $DIR/subdiagnostic-derive.rs:262:5\n+  --> $DIR/subdiagnostic-derive.rs:261:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: `#[bar]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:272:5\n+  --> $DIR/subdiagnostic-derive.rs:271:5\n    |\n LL |     #[bar]\n    |     ^^^^^^\n    |\n    = help: only `primary_span`, `applicability` and `skip_arg` are valid field attributes\n \n error: `#[bar = ...]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:283:5\n+  --> $DIR/subdiagnostic-derive.rs:282:5\n    |\n LL |     #[bar = \"...\"]\n    |     ^^^^^^^^^^^^^^\n \n error: `#[bar(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:294:5\n+  --> $DIR/subdiagnostic-derive.rs:293:5\n    |\n LL |     #[bar(\"...\")]\n    |     ^^^^^^^^^^^^^\n    |\n    = help: only `primary_span`, `applicability` and `skip_arg` are valid field attributes\n \n error: unexpected unsupported untagged union\n-  --> $DIR/subdiagnostic-derive.rs:310:1\n+  --> $DIR/subdiagnostic-derive.rs:309:1\n    |\n LL | / union AC {\n LL | |\n@@ -190,76 +184,74 @@ LL | |     b: u64,\n LL | | }\n    | |_^\n \n-error: `#[label(no_crate::example)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:325:27\n+error: a diagnostic slug must be the first argument to the attribute\n+  --> $DIR/subdiagnostic-derive.rs:324:44\n    |\n LL | #[label(no_crate_example, no_crate::example)]\n-   |                           ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: a diagnostic slug must be the first argument to the attribute\n+   |                                            ^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:338:5\n+  --> $DIR/subdiagnostic-derive.rs:337:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:335:5\n+  --> $DIR/subdiagnostic-derive.rs:334:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: subdiagnostic kind not specified\n-  --> $DIR/subdiagnostic-derive.rs:344:8\n+  --> $DIR/subdiagnostic-derive.rs:343:8\n    |\n LL | struct AG {\n    |        ^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:381:46\n+  --> $DIR/subdiagnostic-derive.rs:380:46\n    |\n LL | #[suggestion(no_crate_example, code = \"...\", code = \"...\")]\n-   |                                              ^^^^^^^^^^^^\n+   |                                              ^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:381:32\n+  --> $DIR/subdiagnostic-derive.rs:380:32\n    |\n LL | #[suggestion(no_crate_example, code = \"...\", code = \"...\")]\n-   |                                ^^^^^^^^^^^^\n+   |                                ^^^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:399:5\n+  --> $DIR/subdiagnostic-derive.rs:398:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:396:5\n+  --> $DIR/subdiagnostic-derive.rs:395:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n-  --> $DIR/subdiagnostic-derive.rs:409:5\n+  --> $DIR/subdiagnostic-derive.rs:408:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: suggestion without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:422:1\n+  --> $DIR/subdiagnostic-derive.rs:421:1\n    |\n LL | #[suggestion(no_crate_example)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/subdiagnostic-derive.rs:432:46\n+  --> $DIR/subdiagnostic-derive.rs:431:62\n    |\n LL | #[suggestion(no_crate_example, code = \"...\", applicability = \"foo\")]\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^\n+   |                                                              ^^^^^\n \n error: suggestion without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:450:1\n+  --> $DIR/subdiagnostic-derive.rs:449:1\n    |\n LL | / #[suggestion(no_crate_example, code = \"...\")]\n LL | |\n@@ -269,41 +261,41 @@ LL | | }\n    | |_^\n \n error: unsupported type attribute for subdiagnostic enum\n-  --> $DIR/subdiagnostic-derive.rs:464:1\n+  --> $DIR/subdiagnostic-derive.rs:463:1\n    |\n LL | #[label]\n    | ^^^^^^^^\n \n error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:484:39\n+  --> $DIR/subdiagnostic-derive.rs:483:39\n    |\n LL | #[suggestion(no_crate_example, code = \"{var}\", applicability = \"machine-applicable\")]\n    |                                       ^^^^^^^\n \n error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:503:43\n+  --> $DIR/subdiagnostic-derive.rs:502:43\n    |\n LL |     #[suggestion(no_crate_example, code = \"{var}\", applicability = \"machine-applicable\")]\n    |                                           ^^^^^^^\n \n error: `#[suggestion_part]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:526:5\n+  --> $DIR/subdiagnostic-derive.rs:525:5\n    |\n LL |     #[suggestion_part]\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = help: `#[suggestion_part(...)]` is only valid in multipart suggestions, use `#[primary_span]` instead\n \n error: `#[suggestion_part(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:529:5\n+  --> $DIR/subdiagnostic-derive.rs:528:5\n    |\n LL |     #[suggestion_part(code = \"...\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: `#[suggestion_part(...)]` is only valid in multipart suggestions\n \n error: suggestion without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:523:1\n+  --> $DIR/subdiagnostic-derive.rs:522:1\n    |\n LL | / #[suggestion(no_crate_example, code = \"...\")]\n LL | |\n@@ -314,16 +306,16 @@ LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: `#[multipart_suggestion(code = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:538:42\n+error: invalid nested attribute\n+  --> $DIR/subdiagnostic-derive.rs:537:42\n    |\n LL | #[multipart_suggestion(no_crate_example, code = \"...\", applicability = \"machine-applicable\")]\n-   |                                          ^^^^^^^^^^^^\n+   |                                          ^^^^\n    |\n    = help: only `style` and `applicability` are valid nested attributes\n \n error: multipart suggestion without any `#[suggestion_part(...)]` fields\n-  --> $DIR/subdiagnostic-derive.rs:538:1\n+  --> $DIR/subdiagnostic-derive.rs:537:1\n    |\n LL | / #[multipart_suggestion(no_crate_example, code = \"...\", applicability = \"machine-applicable\")]\n LL | |\n@@ -334,27 +326,27 @@ LL | | }\n    | |_^\n \n error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:548:5\n+  --> $DIR/subdiagnostic-derive.rs:547:5\n    |\n LL |     #[suggestion_part]\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:556:5\n+error: unexpected end of input, unexpected token in nested attribute, expected ident\n+  --> $DIR/subdiagnostic-derive.rs:555:23\n    |\n LL |     #[suggestion_part()]\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+   |                       ^\n \n error: `#[primary_span]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:565:5\n+  --> $DIR/subdiagnostic-derive.rs:564:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n    = help: multipart suggestions use one or more `#[suggestion_part]`s rather than one `#[primary_span]`\n \n error: multipart suggestion without any `#[suggestion_part(...)]` fields\n-  --> $DIR/subdiagnostic-derive.rs:562:1\n+  --> $DIR/subdiagnostic-derive.rs:561:1\n    |\n LL | / #[multipart_suggestion(no_crate_example)]\n LL | |\n@@ -366,24 +358,16 @@ LL | | }\n    | |_^\n \n error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:573:5\n+  --> $DIR/subdiagnostic-derive.rs:572:5\n    |\n LL |     #[suggestion_part]\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:576:5\n-   |\n-LL |     #[suggestion_part()]\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-\n-error: `#[suggestion_part(foo = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:579:23\n+error: `code` is the only valid nested attribute\n+  --> $DIR/subdiagnostic-derive.rs:578:23\n    |\n LL |     #[suggestion_part(foo = \"bar\")]\n-   |                       ^^^^^^^^^^^\n-   |\n-   = help: `code` is the only valid nested attribute\n+   |                       ^^^\n \n error: the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/subdiagnostic-derive.rs:582:5\n@@ -397,17 +381,29 @@ error: the `#[suggestion_part(...)]` attribute can only be applied to fields of\n LL |     #[suggestion_part()]\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n+error: unexpected end of input, unexpected token in nested attribute, expected ident\n+  --> $DIR/subdiagnostic-derive.rs:575:23\n+   |\n+LL |     #[suggestion_part()]\n+   |                       ^\n+\n+error: expected `,`\n+  --> $DIR/subdiagnostic-derive.rs:578:27\n+   |\n+LL |     #[suggestion_part(foo = \"bar\")]\n+   |                           ^\n+\n error: specified multiple times\n   --> $DIR/subdiagnostic-derive.rs:593:37\n    |\n LL |     #[suggestion_part(code = \"...\", code = \",,,\")]\n-   |                                     ^^^^^^^^^^^^\n+   |                                     ^^^^\n    |\n note: previously specified here\n   --> $DIR/subdiagnostic-derive.rs:593:23\n    |\n LL |     #[suggestion_part(code = \"...\", code = \",,,\")]\n-   |                       ^^^^^^^^^^^^\n+   |                       ^^^^\n \n error: `#[applicability]` has no effect if all `#[suggestion]`/`#[multipart_suggestion]` attributes have a static `applicability = \"...\"`\n   --> $DIR/subdiagnostic-derive.rs:622:5\n@@ -416,93 +412,115 @@ LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: expected exactly one string literal for `code = ...`\n-  --> $DIR/subdiagnostic-derive.rs:670:23\n+  --> $DIR/subdiagnostic-derive.rs:670:34\n    |\n LL |     #[suggestion_part(code(\"foo\"))]\n-   |                       ^^^^^^^^^^^\n+   |                                  ^\n+\n+error: unexpected token\n+  --> $DIR/subdiagnostic-derive.rs:670:28\n+   |\n+LL |     #[suggestion_part(code(\"foo\"))]\n+   |                            ^^^^^\n \n error: expected exactly one string literal for `code = ...`\n-  --> $DIR/subdiagnostic-derive.rs:679:23\n+  --> $DIR/subdiagnostic-derive.rs:680:41\n+   |\n+LL |     #[suggestion_part(code(\"foo\", \"bar\"))]\n+   |                                         ^\n+\n+error: unexpected token\n+  --> $DIR/subdiagnostic-derive.rs:680:28\n    |\n LL |     #[suggestion_part(code(\"foo\", \"bar\"))]\n-   |                       ^^^^^^^^^^^^^^^^^^\n+   |                            ^^^^^\n \n error: expected exactly one string literal for `code = ...`\n-  --> $DIR/subdiagnostic-derive.rs:688:23\n+  --> $DIR/subdiagnostic-derive.rs:690:30\n    |\n LL |     #[suggestion_part(code(3))]\n-   |                       ^^^^^^^\n+   |                              ^\n+\n+error: unexpected token\n+  --> $DIR/subdiagnostic-derive.rs:690:28\n+   |\n+LL |     #[suggestion_part(code(3))]\n+   |                            ^\n \n error: expected exactly one string literal for `code = ...`\n-  --> $DIR/subdiagnostic-derive.rs:697:23\n+  --> $DIR/subdiagnostic-derive.rs:700:29\n    |\n LL |     #[suggestion_part(code())]\n-   |                       ^^^^^^\n+   |                             ^\n \n-error: `code = \"...\"`/`code(...)` must contain only string literals\n-  --> $DIR/subdiagnostic-derive.rs:706:23\n+error: expected string literal\n+  --> $DIR/subdiagnostic-derive.rs:712:30\n    |\n LL |     #[suggestion_part(code = 3)]\n-   |                       ^^^^^^^^\n+   |                              ^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:748:61\n+  --> $DIR/subdiagnostic-derive.rs:754:1\n    |\n LL | #[suggestion(no_crate_example, code = \"\", style = \"hidden\", style = \"normal\")]\n-   |                                                             ^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:748:43\n+  --> $DIR/subdiagnostic-derive.rs:754:1\n    |\n LL | #[suggestion(no_crate_example, code = \"\", style = \"hidden\", style = \"normal\")]\n-   |                                           ^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion_hidden(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:757:1\n+  --> $DIR/subdiagnostic-derive.rs:763:1\n    |\n LL | #[suggestion_hidden(no_crate_example, code = \"\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: Use `#[suggestion(..., style = \"hidden\")]` instead\n \n error: `#[suggestion_hidden(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:765:1\n+  --> $DIR/subdiagnostic-derive.rs:771:1\n    |\n LL | #[suggestion_hidden(no_crate_example, code = \"\", style = \"normal\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: Use `#[suggestion(..., style = \"hidden\")]` instead\n \n error: invalid suggestion style\n-  --> $DIR/subdiagnostic-derive.rs:773:51\n+  --> $DIR/subdiagnostic-derive.rs:779:51\n    |\n LL | #[suggestion(no_crate_example, code = \"\", style = \"foo\")]\n    |                                                   ^^^^^\n    |\n    = help: valid styles are `normal`, `short`, `hidden`, `verbose` and `tool-only`\n \n-error: `#[suggestion(style = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:781:43\n+error: expected `= \"xxx\"`\n+  --> $DIR/subdiagnostic-derive.rs:787:49\n    |\n LL | #[suggestion(no_crate_example, code = \"\", style = 42)]\n-   |                                           ^^^^^^^^^^\n+   |                                                 ^\n \n-error: `#[suggestion(style)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:789:43\n+error: a diagnostic slug must be the first argument to the attribute\n+  --> $DIR/subdiagnostic-derive.rs:795:48\n    |\n LL | #[suggestion(no_crate_example, code = \"\", style)]\n-   |                                           ^^^^^\n+   |                                                ^\n+\n+error: expected `= \"xxx\"`\n+  --> $DIR/subdiagnostic-derive.rs:803:48\n    |\n-   = help: a diagnostic slug must be the first argument to the attribute\n+LL | #[suggestion(no_crate_example, code = \"\", style(\"foo\"))]\n+   |                                                ^\n \n-error: `#[suggestion(style(...))]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:797:43\n+error: expected `,`\n+  --> $DIR/subdiagnostic-derive.rs:803:48\n    |\n LL | #[suggestion(no_crate_example, code = \"\", style(\"foo\"))]\n-   |                                           ^^^^^^^^^^^^\n+   |                                                ^\n \n error: `#[primary_span]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:808:5\n+  --> $DIR/subdiagnostic-derive.rs:815:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n@@ -511,7 +529,7 @@ LL |     #[primary_span]\n    = help: to create a suggestion with multiple spans, use `#[multipart_suggestion]` instead\n \n error: suggestion without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:805:1\n+  --> $DIR/subdiagnostic-derive.rs:812:1\n    |\n LL | / #[suggestion(no_crate_example, code = \"\")]\n LL | |\n@@ -529,59 +547,67 @@ LL | #[foo]\n    |   ^^^\n \n error: cannot find attribute `foo` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:161:3\n+  --> $DIR/subdiagnostic-derive.rs:160:3\n    |\n LL | #[foo]\n    |   ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:175:7\n+  --> $DIR/subdiagnostic-derive.rs:174:7\n    |\n LL |     #[bar]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:187:7\n+  --> $DIR/subdiagnostic-derive.rs:186:7\n    |\n LL |     #[bar = \"...\"]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:199:7\n+  --> $DIR/subdiagnostic-derive.rs:198:7\n    |\n LL |     #[bar = 4]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:211:7\n+  --> $DIR/subdiagnostic-derive.rs:210:7\n    |\n LL |     #[bar(\"...\")]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:272:7\n+  --> $DIR/subdiagnostic-derive.rs:271:7\n    |\n LL |     #[bar]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:283:7\n+  --> $DIR/subdiagnostic-derive.rs:282:7\n    |\n LL |     #[bar = \"...\"]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:294:7\n+  --> $DIR/subdiagnostic-derive.rs:293:7\n    |\n LL |     #[bar(\"...\")]\n    |       ^^^\n \n error[E0425]: cannot find value `slug` in module `crate::fluent_generated`\n-  --> $DIR/subdiagnostic-derive.rs:124:9\n+  --> $DIR/subdiagnostic-derive.rs:123:9\n    |\n LL | #[label(slug)]\n    |         ^^^^ not found in `crate::fluent_generated`\n \n-error: aborting due to 81 previous errors\n+error[E0425]: cannot find value `__code_29` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:706:10\n+   |\n+LL | #[derive(Subdiagnostic)]\n+   |          ^^^^^^^^^^^^^ not found in this scope\n+   |\n+   = note: this error originates in the derive macro `Subdiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 86 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}]}