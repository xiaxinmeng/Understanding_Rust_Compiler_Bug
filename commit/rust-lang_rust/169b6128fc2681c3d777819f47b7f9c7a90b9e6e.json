{"sha": "169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2OWI2MTI4ZmMyNjgxYzNkNzc3ODE5ZjQ3YjdmOWM3YTkwYjllNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-18T02:57:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-18T02:57:22Z"}, "message": "Auto merge of #35702 - jonathandturner:add_backtrace_labels, r=nikomatsakis\n\nReplace macro backtraces with labeled local uses\n\nThis PR (which builds on https://github.com/rust-lang/rust/pull/35688) follows from the conversations on how best to [handle the macro backtraces](https://internals.rust-lang.org/t/improving-macro-errors/3809).  The feeling there was that there were two different \"groups\" of users.\n\nThe first group, the macro users, rarely (and likely never) want to see the macro backtrace.  This is often more confusing to users as it will be talking about code they didn't write.\n\nThe second group, the macro writers, are trying to debug a macro.  They'll want to see something of the backtrace so that they can see where it's going wrong and what the steps were to get there.\n\nFor the first group, it seems clear that we don't want to show *any* macro backtrace.  For the second group, we want to show enough to help the macro writer.\n\nThis PR uses a heuristic.  It will only show any backtrace steps if they are in the same crate that is being compiled.  This keeps errors in foreign crates from showing to users that didn't need them.\n\nAdditionally, in asking around I repeated heard that the middle steps of the backtrace are rarely, if ever, used in practice.  This PR takes and applies this knowledge.  Now, instead of a full backtrace, the user is given the error underline inside of a local macro as well as the use site as a secondary label.  This effectively means seeing the root of the error and the top of the backtrace, eliding the middle steps.\n\nRather than being the \"perfect solution\", this PR opts to take an incremental step towards a better experience.  Likely it would help to have additional macro debugging tools, as they could be much more verbose than we'd likely want to use in the error messages themselves.\n\nSome examples follow.\n\n**Example 1**\n\nBefore:\n\n<img width=\"1275\" alt=\"screen shot 2016-08-15 at 4 13 18 pm\" src=\"https://cloud.githubusercontent.com/assets/547158/17682828/3948cea2-6303-11e6-93b4-b567e9d62848.png\">\n\nAfter:\n\n<img width=\"596\" alt=\"screen shot 2016-08-15 at 4 13 03 pm\" src=\"https://cloud.githubusercontent.com/assets/547158/17682832/3d670d8c-6303-11e6-9bdc-f30a30bf11ac.png\">\n\n**Example 2**\n\nBefore:\n\n<img width=\"918\" alt=\"screen shot 2016-08-15 at 4 14 35 pm\" src=\"https://cloud.githubusercontent.com/assets/547158/17682870/722225de-6303-11e6-9175-336a3f7ce308.png\">\n\nAfter:\n\n<img width=\"483\" alt=\"screen shot 2016-08-15 at 4 15 01 pm\" src=\"https://cloud.githubusercontent.com/assets/547158/17682872/7582cf6c-6303-11e6-9235-f67960f6bd4c.png\">", "tree": {"sha": "997f30f9d5782b8edaf9bffbefd045df7b643463", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/997f30f9d5782b8edaf9bffbefd045df7b643463"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "html_url": "https://github.com/rust-lang/rust/commit/169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aef6971ca96be5f04291420cc773b8bfacb8b36d", "url": "https://api.github.com/repos/rust-lang/rust/commits/aef6971ca96be5f04291420cc773b8bfacb8b36d", "html_url": "https://github.com/rust-lang/rust/commit/aef6971ca96be5f04291420cc773b8bfacb8b36d"}, {"sha": "54d42cc912d1510e561a4d4274e4f821becd1736", "url": "https://api.github.com/repos/rust-lang/rust/commits/54d42cc912d1510e561a4d4274e4f821becd1736", "html_url": "https://github.com/rust-lang/rust/commit/54d42cc912d1510e561a4d4274e4f821becd1736"}], "stats": {"total": 445, "additions": 368, "deletions": 77}, "files": [{"sha": "5fd9226aba9d4ea619619f93d32a3d200a666eeb", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 103, "deletions": 41, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -12,7 +12,7 @@ use self::Destination::*;\n \n use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, CharPos};\n \n-use {Level, CodeSuggestion, DiagnosticBuilder, CodeMapper};\n+use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapper};\n use RenderSpan::*;\n use snippet::{StyledString, Style, Annotation, Line};\n use styled_buffer::StyledBuffer;\n@@ -30,7 +30,10 @@ pub trait Emitter {\n \n impl Emitter for EmitterWriter {\n     fn emit(&mut self, db: &DiagnosticBuilder) {\n-        self.emit_messages_default(db);\n+        let mut primary_span = db.span.clone();\n+        let mut children = db.children.clone();\n+        self.fix_multispans_in_std_macros(&mut primary_span, &mut children);\n+        self.emit_messages_default(&db.level, &db.message, &db.code, &primary_span, &children);\n     }\n }\n \n@@ -381,19 +384,100 @@ impl EmitterWriter {\n         max\n     }\n \n-    fn get_max_line_num(&mut self, db: &DiagnosticBuilder) -> usize {\n+    fn get_max_line_num(&mut self, span: &MultiSpan, children: &Vec<SubDiagnostic>) -> usize {\n         let mut max = 0;\n \n-        let primary = self.get_multispan_max_line_num(&db.span);\n+        let primary = self.get_multispan_max_line_num(span);\n         max = if primary > max { primary } else { max };\n \n-        for sub in &db.children {\n+        for sub in children {\n             let sub_result = self.get_multispan_max_line_num(&sub.span);\n             max = if sub_result > max { primary } else { max };\n         }\n         max\n     }\n \n+    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n+    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n+    // <*macros> to their corresponding use site.\n+    fn fix_multispan_in_std_macros(&mut self, span: &mut MultiSpan) -> bool {\n+        let mut spans_updated = false;\n+\n+        if let Some(ref cm) = self.cm {\n+            let mut before_after: Vec<(Span, Span)> = vec![];\n+            let mut new_labels: Vec<(Span, String)> = vec![];\n+\n+            // First, find all the spans in <*macros> and point instead at their use site\n+            for sp in span.primary_spans() {\n+                if (*sp == COMMAND_LINE_SP) || (*sp == DUMMY_SP) {\n+                    continue;\n+                }\n+                if cm.span_to_filename(sp.clone()).contains(\"macros>\") {\n+                    let v = cm.macro_backtrace(sp.clone());\n+                    if let Some(use_site) = v.last() {\n+                        before_after.push((sp.clone(), use_site.call_site.clone()));\n+                    }\n+                }\n+                for trace in cm.macro_backtrace(sp.clone()).iter().rev() {\n+                    // Only show macro locations that are local\n+                    // and display them like a span_note\n+                    if let Some(def_site) = trace.def_site_span {\n+                        if (def_site == COMMAND_LINE_SP) || (def_site == DUMMY_SP) {\n+                            continue;\n+                        }\n+                        // Check to make sure we're not in any <*macros>\n+                        if !cm.span_to_filename(def_site).contains(\"macros>\") {\n+                            new_labels.push((trace.call_site,\n+                                             \"in this macro invocation\".to_string()));\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            for (label_span, label_text) in new_labels {\n+                span.push_span_label(label_span, label_text);\n+            }\n+            for sp_label in span.span_labels() {\n+                if (sp_label.span == COMMAND_LINE_SP) || (sp_label.span == DUMMY_SP) {\n+                    continue;\n+                }\n+                if cm.span_to_filename(sp_label.span.clone()).contains(\"macros>\") {\n+                    let v = cm.macro_backtrace(sp_label.span.clone());\n+                    if let Some(use_site) = v.last() {\n+                        before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n+                    }\n+                }\n+            }\n+            // After we have them, make sure we replace these 'bad' def sites with their use sites\n+            for (before, after) in before_after {\n+                span.replace(before, after);\n+                spans_updated = true;\n+            }\n+        }\n+\n+        spans_updated\n+    }\n+\n+    // This does a small \"fix\" for multispans by looking to see if it can find any that\n+    // point directly at <*macros>. Since these are often difficult to read, this\n+    // will change the span to point at the use site.\n+    fn fix_multispans_in_std_macros(&mut self,\n+                                    span: &mut MultiSpan,\n+                                    children: &mut Vec<SubDiagnostic>) {\n+        let mut spans_updated = self.fix_multispan_in_std_macros(span);\n+        for child in children.iter_mut() {\n+            spans_updated |= self.fix_multispan_in_std_macros(&mut child.span);\n+        }\n+        if spans_updated {\n+            children.push(SubDiagnostic {\n+                level: Level::Note,\n+                message: \"this error originates in a macro from the standard library\".to_string(),\n+                span: MultiSpan::new(),\n+                render_span: None\n+            });\n+        }\n+    }\n+\n     fn emit_message_default(&mut self,\n                             msp: &MultiSpan,\n                             msg: &str,\n@@ -528,10 +612,6 @@ impl EmitterWriter {\n             }\n         }\n \n-        if let Some(ref primary_span) = msp.primary_span().as_ref() {\n-            self.render_macro_backtrace_old_school(primary_span, &mut buffer)?;\n-        }\n-\n         // final step: take our styled buffer, render it, then output it\n         emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n \n@@ -578,26 +658,31 @@ impl EmitterWriter {\n         }\n         Ok(())\n     }\n-    fn emit_messages_default(&mut self, db: &DiagnosticBuilder) {\n-        let max_line_num = self.get_max_line_num(db);\n+    fn emit_messages_default(&mut self,\n+                             level: &Level,\n+                             message: &String,\n+                             code: &Option<String>,\n+                             span: &MultiSpan,\n+                             children: &Vec<SubDiagnostic>) {\n+        let max_line_num = self.get_max_line_num(span, children);\n         let max_line_num_len = max_line_num.to_string().len();\n \n-        match self.emit_message_default(&db.span,\n-                                        &db.message,\n-                                        &db.code,\n-                                        &db.level,\n+        match self.emit_message_default(span,\n+                                        message,\n+                                        code,\n+                                        level,\n                                         max_line_num_len,\n                                         false) {\n             Ok(()) => {\n-                if !db.children.is_empty() {\n+                if !children.is_empty() {\n                     let mut buffer = StyledBuffer::new();\n                     draw_col_separator_no_space(&mut buffer, 0, max_line_num_len + 1);\n-                    match emit_to_destination(&buffer.render(), &db.level, &mut self.dst) {\n+                    match emit_to_destination(&buffer.render(), level, &mut self.dst) {\n                         Ok(()) => (),\n                         Err(e) => panic!(\"failed to emit error: {}\", e)\n                     }\n                 }\n-                for child in &db.children {\n+                for child in children {\n                     match child.render_span {\n                         Some(FullSpan(ref msp)) => {\n                             match self.emit_message_default(msp,\n@@ -640,29 +725,6 @@ impl EmitterWriter {\n             _ => ()\n         }\n     }\n-    fn render_macro_backtrace_old_school(&mut self,\n-                                         sp: &Span,\n-                                         buffer: &mut StyledBuffer) -> io::Result<()> {\n-        if let Some(ref cm) = self.cm {\n-            for trace in cm.macro_backtrace(sp.clone()) {\n-                let line_offset = buffer.num_lines();\n-\n-                let mut diag_string =\n-                    format!(\"in this expansion of {}\", trace.macro_decl_name);\n-                if let Some(def_site_span) = trace.def_site_span {\n-                    diag_string.push_str(\n-                        &format!(\" (defined in {})\",\n-                            cm.span_to_filename(def_site_span)));\n-                }\n-                let snippet = cm.span_to_string(trace.call_site);\n-                buffer.append(line_offset, &format!(\"{} \", snippet), Style::NoStyle);\n-                buffer.append(line_offset, \"note\", Style::Level(Level::Note));\n-                buffer.append(line_offset, \": \", Style::NoStyle);\n-                buffer.append(line_offset, &diag_string, Style::OldSchoolNoteText);\n-            }\n-        }\n-        Ok(())\n-    }\n }\n \n fn draw_col_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {"}, {"sha": "b11bbea84abcedfa3e77f15cd85347a3e26e7087", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -221,6 +221,25 @@ impl MultiSpan {\n         &self.primary_spans\n     }\n \n+    /// Replaces all occurances of one Span with another. Used to move Spans in areas that don't\n+    /// display well (like std macros). Returns true if replacements occurred.\n+    pub fn replace(&mut self, before: Span, after: Span) -> bool {\n+        let mut replacements_occurred = false;\n+        for primary_span in &mut self.primary_spans {\n+            if *primary_span == before {\n+                *primary_span = after;\n+                replacements_occurred = true;\n+            }\n+        }\n+        for span_label in &mut self.span_labels {\n+            if span_label.0 == before {\n+                span_label.0 = after;\n+                replacements_occurred = true;\n+            }\n+        }\n+        replacements_occurred\n+    }\n+\n     /// Returns the strings to highlight. We always ensure that there\n     /// is an entry for each of the primary spans -- for each primary\n     /// span P, if there is at least one label with span P, we return"}, {"sha": "47e97abbbaa47ef441ed1344e170279f0412f236", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -40,8 +40,10 @@ fn main() {\n     });\n     let cx = &mut cx;\n \n+    println!(\"{}\", pprust::expr_to_string(&*quote_expr!(&cx, 23)));\n     assert_eq!(pprust::expr_to_string(&*quote_expr!(&cx, 23)), \"23\");\n \n     let expr = quote_expr!(&cx, let x isize = 20;);\n+    println!(\"{}\", pprust::expr_to_string(&*expr));\n     assert_eq!(pprust::expr_to_string(&*expr), \"let x isize = 20;\");\n }"}, {"sha": "de7bc88f9ba9c5c39637fc64cb390e32b850ae71", "filename": "src/test/ui/codemap_tests/bad-format-args.rs", "status": "renamed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcodemap_tests%2Fbad-format-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcodemap_tests%2Fbad-format-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fbad-format-args.rs?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -8,13 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: requires at least a format string argument\n-// error-pattern: in this expansion\n-\n-// error-pattern: expected token: `,`\n-// error-pattern: in this expansion\n-// error-pattern: in this expansion\n-\n fn main() {\n     format!();\n     format!(\"\" 1);", "previous_filename": "src/test/compile-fail/bad-format-args.rs"}, {"sha": "fab8e2c8ce136d72ca000a039a82a4a68fc58809", "filename": "src/test/ui/codemap_tests/bad-format-args.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcodemap_tests%2Fbad-format-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcodemap_tests%2Fbad-format-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fbad-format-args.stderr?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -0,0 +1,26 @@\n+error: requires at least a format string argument\n+  --> $DIR/bad-format-args.rs:12:5\n+   |\n+12 |     format!();\n+   |     ^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro from the standard library\n+\n+error: expected token: `,`\n+  --> $DIR/bad-format-args.rs:13:5\n+   |\n+13 |     format!(\"\" 1);\n+   |     ^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro from the standard library\n+\n+error: expected token: `,`\n+  --> $DIR/bad-format-args.rs:14:5\n+   |\n+14 |     format!(\"\", 1 1);\n+   |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro from the standard library\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "e3a4920d951fd5deb7ef79ad76d9da08ef4c5f5d", "filename": "src/test/ui/codemap_tests/issue-28308.rs", "status": "renamed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.rs?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// this error is dispayed in `<std macros>`\n-// error-pattern:cannot apply unary operator `!` to type `&'static str`\n-// error-pattern:in this expansion of assert!\n-\n fn main() {\n     assert!(\"foo\");\n }", "previous_filename": "src/test/compile-fail/issue-28308.rs"}, {"sha": "0d51a3f36e9230b37bd89e11eda4317b422656b6", "filename": "src/test/ui/codemap_tests/issue-28308.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -0,0 +1,10 @@\n+error: cannot apply unary operator `!` to type `&'static str`\n+  --> $DIR/issue-28308.rs:12:5\n+   |\n+12 |     assert!(\"foo\");\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro from the standard library\n+\n+error: aborting due to previous error\n+"}, {"sha": "3abc91d4f5ff10b7306b121702491d02a7fa8ff5", "filename": "src/test/ui/codemap_tests/repair_span_std_macros.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcodemap_tests%2Frepair_span_std_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcodemap_tests%2Frepair_span_std_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Frepair_span_std_macros.rs?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = vec![];\n+}"}, {"sha": "1c9cbd63c338839e719c5a5d40451c4c74964d50", "filename": "src/test/ui/codemap_tests/repair_span_std_macros.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcodemap_tests%2Frepair_span_std_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcodemap_tests%2Frepair_span_std_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Frepair_span_std_macros.stderr?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -0,0 +1,11 @@\n+error[E0282]: unable to infer enough type information about `_`\n+  --> $DIR/repair_span_std_macros.rs:12:13\n+   |\n+12 |     let x = vec![];\n+   |             ^^^^^^ cannot infer type for `_`\n+   |\n+   = note: type annotations or generic parameter binding required\n+   = note: this error originates in a macro from the standard library\n+\n+error: aborting due to previous error\n+"}, {"sha": "598e9f0f53aeed57b30729138c2477ed4bc19401", "filename": "src/test/ui/cross-crate-macro-backtrace/auxiliary/extern_macro_crate.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcross-crate-macro-backtrace%2Fauxiliary%2Fextern_macro_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcross-crate-macro-backtrace%2Fauxiliary%2Fextern_macro_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross-crate-macro-backtrace%2Fauxiliary%2Fextern_macro_crate.rs?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"dylib\"]\n+\n+pub fn print(_args: std::fmt::Arguments) {}\n+\n+#[macro_export]\n+macro_rules! myprint {\n+    ($($arg:tt)*) => (print(format_args!($($arg)*)));\n+}\n+\n+#[macro_export]\n+macro_rules! myprintln {\n+    ($fmt:expr) => (myprint!(concat!($fmt, \"\\n\")));\n+}"}, {"sha": "f8bb84abcd41928be74faf7c63177c3caa95f34c", "filename": "src/test/ui/cross-crate-macro-backtrace/main.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcross-crate-macro-backtrace%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcross-crate-macro-backtrace%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross-crate-macro-backtrace%2Fmain.rs?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:extern_macro_crate.rs\n+#[macro_use(myprintln, myprint)]\n+extern crate extern_macro_crate;\n+\n+fn main() {\n+    myprintln!(\"{}\"); //~ ERROR in this macro\n+}"}, {"sha": "fceaa70288cf391aa91a04c57db2fa0a9d2fcd95", "filename": "src/test/ui/cross-crate-macro-backtrace/main.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcross-crate-macro-backtrace%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fcross-crate-macro-backtrace%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross-crate-macro-backtrace%2Fmain.stderr?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -0,0 +1,10 @@\n+error: invalid reference to argument `0` (no arguments given)\n+  --> $DIR/main.rs:16:5\n+   |\n+16 |     myprintln!(\"{}\"); //~ ERROR in this macro\n+   |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro from the standard library\n+\n+error: aborting due to previous error\n+"}, {"sha": "a18771deacee7c16775986eb67276da7e545562a", "filename": "src/test/ui/macros/bad_hello.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fbad_hello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fbad_hello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbad_hello.rs?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(3 + 4);\n+}"}, {"sha": "bffb33f468fc886c7c10433111713bb242add472", "filename": "src/test/ui/macros/bad_hello.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fbad_hello.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fbad_hello.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbad_hello.stderr?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -0,0 +1,8 @@\n+error: expected a literal\n+  --> $DIR/bad_hello.rs:12:14\n+   |\n+12 |     println!(3 + 4);\n+   |              ^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "546e06b6c79f3888b0d2219f1d3fca976ad902f9", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.rs", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -12,46 +12,46 @@\n \n macro_rules! fake_method_stmt {\n      () => {\n-          1.fake() //~ ERROR no method named `fake` found\n+          1.fake()\n      }\n }\n \n macro_rules! fake_field_stmt {\n      () => {\n-          1.fake //~ ERROR no field with that name\n+          1.fake\n      }\n }\n \n macro_rules! fake_anon_field_stmt {\n      () => {\n-          (1).0 //~ ERROR type was not a tuple\n+          (1).0\n      }\n }\n \n macro_rules! fake_method_expr {\n      () => {\n-          1.fake() //~ ERROR no method named `fake` found\n+          1.fake()\n      }\n }\n \n macro_rules! fake_field_expr {\n      () => {\n-          1.fake //~ ERROR no field with that name\n+          1.fake\n      }\n }\n \n macro_rules! fake_anon_field_expr {\n      () => {\n-          (1).0 //~ ERROR type was not a tuple\n+          (1).0\n      }\n }\n \n fn main() {\n-    fake_method_stmt!(); //~ NOTE in this expansion of\n-    fake_field_stmt!(); //~ NOTE in this expansion of\n-    fake_anon_field_stmt!(); //~ NOTE in this expansion of\n+    fake_method_stmt!();\n+    fake_field_stmt!();\n+    fake_anon_field_stmt!();\n \n-    let _ = fake_method_expr!(); //~ NOTE in this expansion of\n-    let _ = fake_field_expr!(); //~ NOTE in this expansion of\n-    let _ = fake_anon_field_expr!(); //~ NOTE in this expansion of\n+    let _ = fake_method_expr!();\n+    let _ = fake_field_expr!();\n+    let _ = fake_anon_field_expr!();\n }", "previous_filename": "src/test/compile-fail/macro-backtrace-invalid-internals.rs"}, {"sha": "82000a59bfb17fdcd29552c8ab07da0c45c5c6d1", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -0,0 +1,56 @@\n+error: no method named `fake` found for type `{integer}` in the current scope\n+  --> $DIR/macro-backtrace-invalid-internals.rs:15:13\n+   |\n+15 |           1.fake()\n+   |             ^^^^\n+...\n+50 |     fake_method_stmt!();\n+   |     -------------------- in this macro invocation\n+\n+error: attempted access of field `fake` on type `{integer}`, but no field with that name was found\n+  --> $DIR/macro-backtrace-invalid-internals.rs:21:11\n+   |\n+21 |           1.fake\n+   |           ^^^^^^\n+...\n+51 |     fake_field_stmt!();\n+   |     ------------------- in this macro invocation\n+\n+error: attempted tuple index `0` on type `{integer}`, but the type was not a tuple or tuple struct\n+  --> $DIR/macro-backtrace-invalid-internals.rs:27:11\n+   |\n+27 |           (1).0\n+   |           ^^^^^\n+...\n+52 |     fake_anon_field_stmt!();\n+   |     ------------------------ in this macro invocation\n+\n+error: no method named `fake` found for type `{integer}` in the current scope\n+  --> $DIR/macro-backtrace-invalid-internals.rs:33:13\n+   |\n+33 |           1.fake()\n+   |             ^^^^\n+...\n+54 |     let _ = fake_method_expr!();\n+   |             ------------------- in this macro invocation\n+\n+error: attempted access of field `fake` on type `{integer}`, but no field with that name was found\n+  --> $DIR/macro-backtrace-invalid-internals.rs:39:11\n+   |\n+39 |           1.fake\n+   |           ^^^^^^\n+...\n+55 |     let _ = fake_field_expr!();\n+   |             ------------------ in this macro invocation\n+\n+error: attempted tuple index `0` on type `{integer}`, but the type was not a tuple or tuple struct\n+  --> $DIR/macro-backtrace-invalid-internals.rs:45:11\n+   |\n+45 |           (1).0\n+   |           ^^^^^\n+...\n+56 |     let _ = fake_anon_field_expr!();\n+   |             ----------------------- in this macro invocation\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "d8bf6222c1c2c6fd174ac637e94c02afe127bc0e", "filename": "src/test/ui/macros/macro-backtrace-nested.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-nested.rs?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -12,19 +12,18 @@\n // we replace the span of the expanded expression with that of the call site.\n \n macro_rules! nested_expr {\n-    () => (fake) //~ ERROR unresolved name\n-                 //~^ ERROR unresolved name\n+    () => (fake)\n }\n \n macro_rules! call_nested_expr {\n-    () => (nested_expr!()) //~ NOTE in this expansion of nested_expr!\n+    () => (nested_expr!())\n }\n \n macro_rules! call_nested_expr_sum {\n-    () => { 1 + nested_expr!(); } //~ NOTE in this expansion of nested_expr!\n+    () => { 1 + nested_expr!(); }\n }\n \n fn main() {\n-    1 + call_nested_expr!(); //~ NOTE in this expansion of call_nested_expr!\n-    call_nested_expr_sum!(); //~ NOTE in this expansion of\n+    1 + call_nested_expr!();\n+    call_nested_expr_sum!();\n }", "previous_filename": "src/test/compile-fail/macro-backtrace-nested.rs"}, {"sha": "e452e8d69bdad6e7d7b9dce388bcf9cc5be45d75", "filename": "src/test/ui/macros/macro-backtrace-nested.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-nested.stderr?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -0,0 +1,20 @@\n+error[E0425]: unresolved name `fake`\n+  --> $DIR/macro-backtrace-nested.rs:15:12\n+   |\n+15 |     () => (fake)\n+   |            ^^^^\n+...\n+27 |     1 + call_nested_expr!();\n+   |         ------------------- in this macro invocation\n+\n+error[E0425]: unresolved name `fake`\n+  --> $DIR/macro-backtrace-nested.rs:15:12\n+   |\n+15 |     () => (fake)\n+   |            ^^^^\n+...\n+28 |     call_nested_expr_sum!();\n+   |     ------------------------ in this macro invocation\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "baf276919a5e8f130b0c4fb2914ce28d689a8728", "filename": "src/test/ui/macros/macro-backtrace-println.rs", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-println.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-println.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-println.rs?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -17,15 +17,13 @@\n fn print(_args: std::fmt::Arguments) {}\n \n macro_rules! myprint {\n-    ($($arg:tt)*) => (print(format_args!($($arg)*)));   //~ NOTE in this expansion of\n+    ($($arg:tt)*) => (print(format_args!($($arg)*)));\n }\n \n macro_rules! myprintln {\n-    ($fmt:expr) => (myprint!(concat!($fmt, \"\\n\"))); //~ ERROR invalid reference to argument `0`\n-                                                    //~| NOTE in this expansion of concat!\n-                                                    //~| NOTE in this expansion of myprint!\n+    ($fmt:expr) => (myprint!(concat!($fmt, \"\\n\")));\n }\n \n fn main() {\n-    myprintln!(\"{}\"); //~ NOTE in this expansion of\n+    myprintln!(\"{}\");\n }", "previous_filename": "src/test/compile-fail/macro-backtrace-println.rs"}, {"sha": "f21253bb67fb0c10e46458e63aa3997d639283cf", "filename": "src/test/ui/macros/macro-backtrace-println.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-println.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-println.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-println.stderr?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -0,0 +1,11 @@\n+error: invalid reference to argument `0` (no arguments given)\n+  --> $DIR/macro-backtrace-println.rs:24:30\n+   |\n+24 |     ($fmt:expr) => (myprint!(concat!($fmt, \"/n\")));\n+   |                              ^^^^^^^^^^^^^^^^^^^\n+...\n+28 |     myprintln!(\"{}\");\n+   |     ----------------- in this macro invocation\n+\n+error: aborting due to previous error\n+"}, {"sha": "5d07ee1648a3ecfffe90986405e78bec9e8abfb5", "filename": "src/test/ui/mismatched_types/issue-26480.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/169b6128fc2681c3d777819f47b7f9c7a90b9e6e/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr?ref=169b6128fc2681c3d777819f47b7f9c7a90b9e6e", "patch": "@@ -3,14 +3,18 @@ error[E0308]: mismatched types\n    |\n 26 |                   $arr.len() * size_of($arr[0]));\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected u64, found usize\n-$DIR/issue-26480.rs:37:5: 37:19 note: in this expansion of write! (defined in $DIR/issue-26480.rs)\n+...\n+37 |     write!(hello);\n+   |     -------------- in this macro invocation\n \n error: non-scalar cast: `{integer}` as `()`\n   --> $DIR/issue-26480.rs:32:19\n    |\n 32 |     ($x:expr) => ($x as ())\n    |                   ^^^^^^^^\n-$DIR/issue-26480.rs:38:5: 38:14 note: in this expansion of cast! (defined in $DIR/issue-26480.rs)\n+...\n+38 |     cast!(2);\n+   |     --------- in this macro invocation\n \n error: aborting due to 2 previous errors\n "}]}