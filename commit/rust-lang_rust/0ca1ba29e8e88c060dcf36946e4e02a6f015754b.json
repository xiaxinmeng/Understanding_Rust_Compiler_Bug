{"sha": "0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYTFiYTI5ZThlODhjMDYwZGNmMzY5NDZlNGUwMmE2ZjAxNTc1NGI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-15T16:50:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-15T16:50:41Z"}, "message": "Don't expose hir::Path out of hir\n\nConjecture: it's impossible to use hir::Path *correctly* from an IDE.\n\nI am not entirely sure about this, and we might need to add it back at\nsome point, but I have to arguments that convince me that we probably\nwon't:\n\n* `hir::Path` has to know about hygiene, which an IDE can't set up\n  properly.\n\n* `hir::Path` lacks identity, but you actually have to know identity\n  to resolve it correctly", "tree": {"sha": "7b652995dda3849f9deb13c8eac6ad72a39cb283", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b652995dda3849f9deb13c8eac6ad72a39cb283"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "html_url": "https://github.com/rust-lang/rust/commit/0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2052d33b9b0e2254f53848501a9113aa12ddf4da", "url": "https://api.github.com/repos/rust-lang/rust/commits/2052d33b9b0e2254f53848501a9113aa12ddf4da", "html_url": "https://github.com/rust-lang/rust/commit/2052d33b9b0e2254f53848501a9113aa12ddf4da"}], "stats": {"total": 143, "additions": 51, "deletions": 92}, "files": [{"sha": "b9ec3f10b65e2adefbba3b63265753cc839a7dac", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n             |builder| {\n                 insert_use_statement(\n                     &auto_import_assets.syntax_under_caret,\n-                    &import,\n+                    &import.to_string(),\n                     ctx,\n                     builder.text_edit_builder(),\n                 );"}, {"sha": "81d0af2f353485735d44ae64ed80f79493732e2d", "filename": "crates/assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "patch": "@@ -1,3 +1,4 @@\n+use either::Either;\n use hir::{AssocItem, MacroDef, ModuleDef, Name, PathResolution, ScopeDef, SemanticsScope};\n use ide_db::{\n     defs::{classify_name_ref, Definition, NameRefClass},\n@@ -10,8 +11,6 @@ use crate::{\n     AssistId, AssistKind,\n };\n \n-use either::Either;\n-\n // Assist: expand_glob_import\n //\n // Expands glob imports.\n@@ -40,11 +39,15 @@ use either::Either;\n pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let star = ctx.find_token_at_offset(T![*])?;\n     let mod_path = find_mod_path(&star)?;\n+    let module = match ctx.sema.resolve_path(&mod_path)? {\n+        PathResolution::Def(ModuleDef::Module(it)) => it,\n+        _ => return None,\n+    };\n \n     let source_file = ctx.source_file();\n     let scope = ctx.sema.scope_at_offset(source_file.syntax(), ctx.offset());\n \n-    let defs_in_mod = find_defs_in_mod(ctx, scope, &mod_path)?;\n+    let defs_in_mod = find_defs_in_mod(ctx, scope, module)?;\n     let name_refs_in_source_file =\n         source_file.syntax().descendants().filter_map(ast::NameRef::cast).collect();\n     let used_names = find_used_names(ctx, defs_in_mod, name_refs_in_source_file);\n@@ -82,17 +85,8 @@ impl Def {\n fn find_defs_in_mod(\n     ctx: &AssistContext,\n     from: SemanticsScope<'_>,\n-    path: &ast::Path,\n+    module: hir::Module,\n ) -> Option<Vec<Def>> {\n-    let hir_path = ctx.sema.lower_path(&path)?;\n-    let module = if let Some(PathResolution::Def(ModuleDef::Module(module))) =\n-        from.resolve_hir_path_qualifier(&hir_path)\n-    {\n-        module\n-    } else {\n-        return None;\n-    };\n-\n     let module_scope = module.scope(ctx.db(), from.module());\n \n     let mut defs = vec![];"}, {"sha": "d62e06b4a81f32388125843933ffe1065518dccd", "filename": "crates/assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "patch": "@@ -106,7 +106,12 @@ fn insert_import(\n     if let Some(mut mod_path) = mod_path {\n         mod_path.segments.pop();\n         mod_path.segments.push(variant_hir_name.clone());\n-        insert_use_statement(path.syntax(), &mod_path, ctx, builder.text_edit_builder());\n+        insert_use_statement(\n+            path.syntax(),\n+            &mod_path.to_string(),\n+            ctx,\n+            builder.text_edit_builder(),\n+        );\n     }\n     Some(())\n }"}, {"sha": "470e5f8ff752bfcd6928de55c2250ff351e9d0bd", "filename": "crates/assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "patch": "@@ -1,5 +1,5 @@\n-use hir;\n-use syntax::{algo::SyntaxRewriter, ast, match_ast, AstNode, SmolStr, SyntaxNode};\n+use syntax::{algo::SyntaxRewriter, ast, match_ast, AstNode, SyntaxNode, TextRange};\n+use test_utils::mark;\n \n use crate::{\n     utils::{find_insert_use_container, insert_use_statement},\n@@ -28,25 +28,36 @@ pub(crate) fn replace_qualified_name_with_use(\n     if path.syntax().ancestors().find_map(ast::Use::cast).is_some() {\n         return None;\n     }\n-\n-    let hir_path = ctx.sema.lower_path(&path)?;\n-    let segments = collect_hir_path_segments(&hir_path)?;\n-    if segments.len() < 2 {\n+    if path.qualifier().is_none() {\n+        mark::hit!(dont_import_trivial_paths);\n         return None;\n     }\n+    let path_to_import = path.to_string().clone();\n+    let path_to_import = match path.segment()?.generic_arg_list() {\n+        Some(generic_args) => {\n+            let generic_args_start =\n+                generic_args.syntax().text_range().start() - path.syntax().text_range().start();\n+            &path_to_import[TextRange::up_to(generic_args_start)]\n+        }\n+        None => path_to_import.as_str(),\n+    };\n \n     let target = path.syntax().text_range();\n     acc.add(\n         AssistId(\"replace_qualified_name_with_use\", AssistKind::RefactorRewrite),\n         \"Replace qualified path with use\",\n         target,\n         |builder| {\n-            let path_to_import = hir_path.mod_path().clone();\n             let container = match find_insert_use_container(path.syntax(), ctx) {\n                 Some(c) => c,\n                 None => return,\n             };\n-            insert_use_statement(path.syntax(), &path_to_import, ctx, builder.text_edit_builder());\n+            insert_use_statement(\n+                path.syntax(),\n+                &path_to_import.to_string(),\n+                ctx,\n+                builder.text_edit_builder(),\n+            );\n \n             // Now that we've brought the name into scope, re-qualify all paths that could be\n             // affected (that is, all paths inside the node we added the `use` to).\n@@ -58,26 +69,6 @@ pub(crate) fn replace_qualified_name_with_use(\n     )\n }\n \n-fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n-    let mut ps = Vec::<SmolStr>::with_capacity(10);\n-    match path.kind() {\n-        hir::PathKind::Abs => ps.push(\"\".into()),\n-        hir::PathKind::Crate => ps.push(\"crate\".into()),\n-        hir::PathKind::Plain => {}\n-        hir::PathKind::Super(0) => ps.push(\"self\".into()),\n-        hir::PathKind::Super(lvl) => {\n-            let mut chain = \"super\".to_string();\n-            for _ in 0..*lvl {\n-                chain += \"::super\";\n-            }\n-            ps.push(chain.into());\n-        }\n-        hir::PathKind::DollarCrate(_) => return None,\n-    }\n-    ps.extend(path.segments().iter().map(|it| it.name.to_string().into()));\n-    Some(ps)\n-}\n-\n /// Adds replacements to `re` that shorten `path` in all descendants of `node`.\n fn shorten_paths(rewriter: &mut SyntaxRewriter<'static>, node: SyntaxNode, path: ast::Path) {\n     for child in node.children() {\n@@ -467,7 +458,8 @@ impl Debug for Foo {\n     }\n \n     #[test]\n-    fn test_replace_not_applicable_one_segment() {\n+    fn dont_import_trivial_paths() {\n+        mark::check!(dont_import_trivial_paths);\n         check_assist_not_applicable(\n             replace_qualified_name_with_use,\n             r\""}, {"sha": "49096a67c7aef3e266392a6c865124a7b683e876", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "patch": "@@ -5,7 +5,6 @@\n use std::iter::successors;\n \n use either::Either;\n-use hir::{self, ModPath};\n use syntax::{\n     ast::{self, NameOwner, VisibilityOwner},\n     AstNode, AstToken, Direction, SmolStr,\n@@ -35,11 +34,11 @@ pub(crate) fn find_insert_use_container(\n pub(crate) fn insert_use_statement(\n     // Ideally the position of the cursor, used to\n     position: &SyntaxNode,\n-    path_to_import: &ModPath,\n+    path_to_import: &str,\n     ctx: &AssistContext,\n     builder: &mut TextEditBuilder,\n ) {\n-    let target = path_to_import.to_string().split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n+    let target = path_to_import.split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n     let container = find_insert_use_container(position, ctx);\n \n     if let Some(container) = container {"}, {"sha": "c442654dd0fc2ddc3d3229d9e65656eed11436b0", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "patch": "@@ -12,6 +12,7 @@ use hir_def::{\n     docs::Documentation,\n     expr::{BindingAnnotation, Pat, PatId},\n     import_map,\n+    path::ModPath,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n@@ -344,11 +345,7 @@ impl Module {\n \n     /// Finds a path that can be used to refer to the given item from within\n     /// this module, if possible.\n-    pub fn find_use_path(\n-        self,\n-        db: &dyn DefDatabase,\n-        item: impl Into<ItemInNs>,\n-    ) -> Option<hir_def::path::ModPath> {\n+    pub fn find_use_path(self, db: &dyn DefDatabase, item: impl Into<ItemInNs>) -> Option<ModPath> {\n         hir_def::find_path::find_path(db, item.into(), self.into())\n     }\n }\n@@ -1126,7 +1123,7 @@ impl ImplDef {\n             .value\n             .attrs()\n             .filter_map(|it| {\n-                let path = hir_def::path::ModPath::from_src(it.path()?, &hygenic)?;\n+                let path = ModPath::from_src(it.path()?, &hygenic)?;\n                 if path.as_ident()?.to_string() == \"derive\" {\n                     Some(it)\n                 } else {"}, {"sha": "8961ba8fd6c52b8363e9d6ea468396ed0db9ef19", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "patch": "@@ -48,7 +48,7 @@ pub use hir_def::{\n     builtin_type::BuiltinType,\n     docs::Documentation,\n     nameres::ModuleSource,\n-    path::{ModPath, Path, PathKind},\n+    path::ModPath,\n     type_ref::{Mutability, TypeRef},\n };\n pub use hir_expand::{\n@@ -60,4 +60,7 @@ pub use hir_ty::display::HirDisplay;\n // These are negative re-exports: pub using these names is forbidden, they\n // should remain private to hir internals.\n #[allow(unused)]\n-use hir_expand::hygiene::Hygiene;\n+use {\n+    hir_def::path::{Path, PathKind},\n+    hir_expand::hygiene::Hygiene,\n+};"}, {"sha": "c693176fa48f3ae7910708c69ca3115abf13880e", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "patch": "@@ -6,7 +6,7 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use base_db::{FileId, FileRange};\n use hir_def::{\n-    resolver::{self, HasResolver, Resolver},\n+    resolver::{self, HasResolver, Resolver, TypeNs},\n     AsMacroCall, FunctionId, TraitId, VariantId,\n };\n use hir_expand::{hygiene::Hygiene, name::AsName, ExpansionInfo};\n@@ -22,12 +22,11 @@ use crate::{\n     db::HirDatabase,\n     diagnostics::Diagnostic,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n-    source_analyzer::{resolve_hir_path, resolve_hir_path_qualifier, SourceAnalyzer},\n+    source_analyzer::{resolve_hir_path, SourceAnalyzer},\n     AssocItem, Callable, Crate, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef,\n     Module, ModuleDef, Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, TypeRef,\n     VariantDef,\n };\n-use resolver::TypeNs;\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum PathResolution {\n@@ -228,10 +227,6 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_variant(record_lit).map(VariantDef::from)\n     }\n \n-    pub fn lower_path(&self, path: &ast::Path) -> Option<Path> {\n-        self.imp.lower_path(path)\n-    }\n-\n     pub fn resolve_bind_pat_to_const(&self, pat: &ast::IdentPat) -> Option<ModuleDef> {\n         self.imp.resolve_bind_pat_to_const(pat)\n     }\n@@ -467,11 +462,6 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(record_lit.syntax()).resolve_variant(self.db, record_lit)\n     }\n \n-    fn lower_path(&self, path: &ast::Path) -> Option<Path> {\n-        let src = self.find_file(path.syntax().clone());\n-        Path::from_src(path.clone(), &Hygiene::new(self.db.upcast(), src.file_id.into()))\n-    }\n-\n     fn resolve_bind_pat_to_const(&self, pat: &ast::IdentPat) -> Option<ModuleDef> {\n         self.analyze(pat.syntax()).resolve_bind_pat_to_const(self.db, pat)\n     }\n@@ -758,28 +748,7 @@ impl<'a> SemanticsScope<'a> {\n     pub fn speculative_resolve(&self, path: &ast::Path) -> Option<PathResolution> {\n         let hygiene = Hygiene::new(self.db.upcast(), self.file_id);\n         let path = Path::from_src(path.clone(), &hygiene)?;\n-        self.resolve_hir_path(&path)\n-    }\n-\n-    pub fn resolve_hir_path(&self, path: &Path) -> Option<PathResolution> {\n-        resolve_hir_path(self.db, &self.resolver, path)\n-    }\n-\n-    /// Resolves a path where we know it is a qualifier of another path.\n-    ///\n-    /// For example, if we have:\n-    /// ```\n-    /// mod my {\n-    ///     pub mod foo {\n-    ///         struct Bar;\n-    ///     }\n-    ///\n-    ///     pub fn foo() {}\n-    /// }\n-    /// ```\n-    /// then we know that `foo` in `my::foo::Bar` refers to the module, not the function.\n-    pub fn resolve_hir_path_qualifier(&self, path: &Path) -> Option<PathResolution> {\n-        resolve_hir_path_qualifier(self.db, &self.resolver, path)\n+        resolve_hir_path(self.db, &self.resolver, &path)\n     }\n }\n "}, {"sha": "1d13c4f1d3b7d276b883e0f9edb6e52a59ec9c1a", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca1ba29e8e88c060dcf36946e4e02a6f015754b/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=0ca1ba29e8e88c060dcf36946e4e02a6f015754b", "patch": "@@ -13,6 +13,7 @@ use hir_def::{\n         Body, BodySourceMap,\n     },\n     expr::{ExprId, Pat, PatId},\n+    path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     AsMacroCall, DefWithBodyId, FieldId, FunctionId, LocalFieldId, VariantId,\n };\n@@ -28,8 +29,7 @@ use syntax::{\n \n use crate::{\n     db::HirDatabase, semantics::PathResolution, Adt, Const, EnumVariant, Field, Function, Local,\n-    MacroDef, ModPath, ModuleDef, Path, PathKind, Static, Struct, Trait, Type, TypeAlias,\n-    TypeParam,\n+    MacroDef, ModuleDef, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n };\n use base_db::CrateId;\n \n@@ -508,7 +508,7 @@ pub(crate) fn resolve_hir_path(\n /// }\n /// ```\n /// then we know that `foo` in `my::foo::Bar` refers to the module, not the function.\n-pub(crate) fn resolve_hir_path_qualifier(\n+fn resolve_hir_path_qualifier(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n     path: &Path,"}]}