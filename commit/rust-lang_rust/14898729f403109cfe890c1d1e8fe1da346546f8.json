{"sha": "14898729f403109cfe890c1d1e8fe1da346546f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ODk4NzI5ZjQwMzEwOWNmZTg5MGMxZDFlOGZlMWRhMzQ2NTQ2Zjg=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-08-03T12:01:00Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-08-07T19:54:38Z"}, "message": "Account sized bounds in parentheses printing inside of ptr/ref of rpit.", "tree": {"sha": "6e56b9513235f5ea55f4507de88365d782c5e5b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e56b9513235f5ea55f4507de88365d782c5e5b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14898729f403109cfe890c1d1e8fe1da346546f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14898729f403109cfe890c1d1e8fe1da346546f8", "html_url": "https://github.com/rust-lang/rust/commit/14898729f403109cfe890c1d1e8fe1da346546f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14898729f403109cfe890c1d1e8fe1da346546f8/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9ec88ea23baf1b8ecee0ea1df6fcf3bbeff284b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9ec88ea23baf1b8ecee0ea1df6fcf3bbeff284b", "html_url": "https://github.com/rust-lang/rust/commit/d9ec88ea23baf1b8ecee0ea1df6fcf3bbeff284b"}], "stats": {"total": 191, "additions": 153, "deletions": 38}, "files": [{"sha": "9f33fd26e845ce4d79412d7aa3d7588103b01a24", "filename": "crates/hir_def/src/type_ref.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs?ref=14898729f403109cfe890c1d1e8fe1da346546f8", "patch": "@@ -307,7 +307,9 @@ impl TypeBound {\n                     Some(_) => TraitBoundModifier::Maybe,\n                     None => TraitBoundModifier::None,\n                 };\n-                lower_path_type(path_type).map(|p| TypeBound::Path(p, m)).unwrap_or(TypeBound::Error)\n+                lower_path_type(path_type)\n+                    .map(|p| TypeBound::Path(p, m))\n+                    .unwrap_or(TypeBound::Error)\n             }\n             ast::TypeBoundKind::ForType(for_type) => {\n                 let lt_refs = match for_type.generic_param_list() {"}, {"sha": "2472d9ce20d4d4ec0d6d59b3f0fe43066ba5fdd1", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 48, "deletions": 18, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=14898729f403109cfe890c1d1e8fe1da346546f8", "patch": "@@ -377,10 +377,20 @@ impl HirDisplay for Ty {\n                 }\n \n                 // FIXME: all this just to decide whether to use parentheses...\n-                let datas;\n-                let predicates: Vec<_> = match t.kind(&Interner) {\n+                let conains_impl_fn = |bounds: &[QuantifiedWhereClause]| {\n+                    bounds.iter().any(|bound| {\n+                        if let WhereClause::Implemented(trait_ref) = bound.skip_binders() {\n+                            let trait_ = trait_ref.hir_trait_id();\n+                            fn_traits(f.db.upcast(), trait_).any(|it| it == trait_)\n+                        } else {\n+                            false\n+                        }\n+                    })\n+                };\n+                let (preds_to_print, has_impl_fn_pred) = match t.kind(&Interner) {\n                     TyKind::Dyn(dyn_ty) if dyn_ty.bounds.skip_binders().interned().len() > 1 => {\n-                        dyn_ty.bounds.skip_binders().interned().iter().cloned().collect()\n+                        let bounds = dyn_ty.bounds.skip_binders().interned();\n+                        (bounds.len(), conains_impl_fn(bounds))\n                     }\n                     TyKind::Alias(AliasTy::Opaque(OpaqueTy {\n                         opaque_ty_id,\n@@ -390,33 +400,54 @@ impl HirDisplay for Ty {\n                         let impl_trait_id =\n                             f.db.lookup_intern_impl_trait_id((*opaque_ty_id).into());\n                         if let ImplTraitId::ReturnTypeImplTrait(func, idx) = impl_trait_id {\n-                            datas =\n+                            let datas =\n                                 f.db.return_type_impl_traits(func)\n                                     .expect(\"impl trait id without data\");\n                             let data = (*datas)\n                                 .as_ref()\n                                 .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                             let bounds = data.substitute(&Interner, parameters);\n-                            bounds.into_value_and_skipped_binders().0\n+                            let mut len = bounds.skip_binders().len();\n+\n+                            // Don't count Sized but count when it absent\n+                            // (i.e. when explicit ?Sized bound is set).\n+                            let default_sized = SizedByDefault::Sized {\n+                                anchor: func.lookup(f.db.upcast()).module(f.db.upcast()).krate(),\n+                            };\n+                            let sized_bounds = bounds\n+                                .skip_binders()\n+                                .iter()\n+                                .filter(|b| {\n+                                    matches!(\n+                                        b.skip_binders(),\n+                                        WhereClause::Implemented(trait_ref)\n+                                            if default_sized.is_sized_trait(\n+                                                trait_ref.hir_trait_id(),\n+                                                f.db.upcast(),\n+                                            ),\n+                                    )\n+                                })\n+                                .count();\n+                            match sized_bounds {\n+                                0 => len += 1,\n+                                _ => {\n+                                    len = len.saturating_sub(sized_bounds);\n+                                }\n+                            }\n+\n+                            (len, conains_impl_fn(bounds.skip_binders()))\n                         } else {\n-                            Vec::new()\n+                            (0, false)\n                         }\n                     }\n-                    _ => Vec::new(),\n+                    _ => (0, false),\n                 };\n \n-                if let Some(WhereClause::Implemented(trait_ref)) =\n-                    predicates.get(0).map(|b| b.skip_binders())\n-                {\n-                    let trait_ = trait_ref.hir_trait_id();\n-                    if fn_traits(f.db.upcast(), trait_).any(|it| it == trait_)\n-                        && predicates.len() <= 2\n-                    {\n-                        return t.hir_fmt(f);\n-                    }\n+                if has_impl_fn_pred && preds_to_print <= 2 {\n+                    return t.hir_fmt(f);\n                 }\n \n-                if predicates.len() > 1 {\n+                if preds_to_print > 1 {\n                     write!(f, \"(\")?;\n                     t.hir_fmt(f)?;\n                     write!(f, \")\")?;\n@@ -1085,7 +1116,6 @@ impl HirDisplay for TypeBound {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         match self {\n             TypeBound::Path(path, modifier) => {\n-                // todo don't print implicit Sized; implicit ?Sized on Self of a trait\n                 match modifier {\n                     TraitBoundModifier::None => (),\n                     TraitBoundModifier::Maybe => write!(f, \"?\")?,"}, {"sha": "b72e1fc46a18f2408af03bd84a20a0b66cbecafc", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=14898729f403109cfe890c1d1e8fe1da346546f8", "patch": "@@ -828,7 +828,9 @@ impl<'a> TyLoweringContext<'a> {\n         trait_ref: TraitRef,\n     ) -> impl Iterator<Item = QuantifiedWhereClause> + 'a {\n         let last_segment = match bound {\n-            TypeBound::Path(path, TraitBoundModifier::None) | TypeBound::ForLifetime(_, path) => path.segments().last(),\n+            TypeBound::Path(path, TraitBoundModifier::None) | TypeBound::ForLifetime(_, path) => {\n+                path.segments().last()\n+            }\n             TypeBound::Path(_, TraitBoundModifier::Maybe)\n             | TypeBound::Error\n             | TypeBound::Lifetime(_) => None,"}, {"sha": "240942e488d7de79adbe9e9a08e8fe6b8e44255c", "filename": "crates/hir_ty/src/tests/display_source_code.rs", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=14898729f403109cfe890c1d1e8fe1da346546f8", "patch": "@@ -42,16 +42,15 @@ fn main() {\n \n #[test]\n fn render_raw_ptr_impl_ty() {\n-    // FIXME: remove parens, they apper because there is an implicit Sized bound\n     check_types_source_code(\n         r#\"\n //- minicore: sized\n trait Unpin {}\n-fn foo() -> *const impl Unpin { loop {} }\n+fn foo() -> *const (impl Unpin + Sized) { loop {} }\n fn main() {\n     let foo = foo();\n     foo;\n-} //^^^ *const (impl Unpin)\n+} //^^^ *const impl Unpin\n \"#,\n     );\n }\n@@ -94,9 +93,9 @@ fn test(\n     d;\n   //^ S<impl Foo>\n     ref_any;\n-  //^ &impl ?Sized\n+  //^^^^^^^ &impl ?Sized\n     empty;\n-} //^ impl Sized\n+} //^^^^^ impl Sized\n \"#,\n     );\n }\n@@ -107,11 +106,50 @@ fn sized_bounds_rpit() {\n         r#\"\n //- minicore: sized\n trait Foo {}\n-fn foo() -> impl Foo { loop {} }\n-fn test<T: Foo>() {\n-    let foo = foo();\n+fn foo1() -> impl Foo { loop {} }\n+fn foo2() -> impl Foo + Sized { loop {} }\n+fn foo3() -> impl Foo + ?Sized { loop {} }\n+fn test() {\n+    let foo = foo1();\n+    foo;\n+  //^^^ impl Foo\n+    let foo = foo2();\n+    foo;\n+  //^^^ impl Foo\n+    let foo = foo3();\n+    foo;\n+} //^^^ impl Foo + ?Sized\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn parenthesize_ptr_rpit_sized_bounds() {\n+    check_types_source_code(\n+        r#\"\n+//- minicore: sized\n+trait Foo {}\n+fn foo1() -> *const impl Foo { loop {} }\n+fn foo2() -> *const (impl Foo + Sized) { loop {} }\n+fn foo3() -> *const (impl Sized + Foo) { loop {} }\n+fn foo4() -> *const (impl Foo + ?Sized) { loop {} }\n+fn foo5() -> *const (impl ?Sized + Foo) { loop {} }\n+fn test() {\n+    let foo = foo1();\n+    foo;\n+  //^^^ *const impl Foo\n+    let foo = foo2();\n+    foo;\n+  //^^^ *const impl Foo\n+    let foo = foo3();\n+    foo;\n+  //^^^ *const impl Foo\n+    let foo = foo4();\n+    foo;\n+  //^^^ *const (impl Foo + ?Sized)\n+    let foo = foo5();\n     foo;\n-}   //^ impl Foo\n+} //^^^ *const (impl Foo + ?Sized)\n \"#,\n     );\n }"}, {"sha": "ed05d55f913a1988bd3d082b33b1ad5a62628130", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=14898729f403109cfe890c1d1e8fe1da346546f8", "patch": "@@ -944,7 +944,7 @@ fn lifetime_from_chalk_during_deref() {\n         r#\"\n //- minicore: deref\n struct Box<T: ?Sized> {}\n-impl<T> core::ops::Deref for Box<T> {\n+impl<T: ?Sized> core::ops::Deref for Box<T> {\n     type Target = T;\n \n     fn deref(&self) -> &Self::Target {\n@@ -1063,6 +1063,7 @@ fn cfg_tail() {\n fn impl_trait_in_option_9530() {\n     check_types(\n         r#\"\n+//- minicore: sized\n struct Option<T>;\n impl<T> Option<T> {\n     fn unwrap(self) -> T { loop {} }"}, {"sha": "35854e42c120782fad256fedd2ee8e6464199cfa", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=14898729f403109cfe890c1d1e8fe1da346546f8", "patch": "@@ -3534,9 +3534,7 @@ fn test() {\n fn associated_type_sized_bounds() {\n     check_infer(\n         r#\"\n-#[lang = \"sized\"]\n-pub trait Sized {}\n-\n+//- minicore: sized\n struct Yes;\n trait IsSized { const IS_SIZED: Yes; }\n impl<T: Sized> IsSized for T { const IS_SIZED: Yes = Yes; }\n@@ -3553,11 +3551,11 @@ fn f<F: Foo>() {\n }\n \"#,\n         expect![[r#\"\n-            142..145 'Yes': Yes\n-            250..333 '{     ...ZED; }': ()\n-            256..277 'F::Exp..._SIZED': Yes\n-            283..304 'F::Imp..._SIZED': Yes\n-            310..330 'F::Rel..._SIZED': {unknown}\n+            104..107 'Yes': Yes\n+            212..295 '{     ...ZED; }': ()\n+            218..239 'F::Exp..._SIZED': Yes\n+            245..266 'F::Imp..._SIZED': Yes\n+            272..292 'F::Rel..._SIZED': {unknown}\n         \"#]],\n     );\n }"}, {"sha": "e3d63cc949e1d81c72233323381a149a9be31727", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14898729f403109cfe890c1d1e8fe1da346546f8/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=14898729f403109cfe890c1d1e8fe1da346546f8", "patch": "@@ -932,6 +932,50 @@ fn main() {\n         )\n     }\n \n+    #[test]\n+    fn fn_hints_ptr_rpit_fn_parentheses() {\n+        check_types(\n+            r#\"\n+//- minicore: fn, sized\n+trait Trait {}\n+\n+fn foo1() -> *const impl Fn() { loop {} }\n+fn foo2() -> *const (impl Fn() + Sized) { loop {} }\n+fn foo3() -> *const (impl Fn() + ?Sized) { loop {} }\n+fn foo4() -> *const (impl Sized + Fn()) { loop {} }\n+fn foo5() -> *const (impl ?Sized + Fn()) { loop {} }\n+fn foo6() -> *const (impl Fn() + Trait) { loop {} }\n+fn foo7() -> *const (impl Fn() + Sized + Trait) { loop {} }\n+fn foo8() -> *const (impl Fn() + ?Sized + Trait) { loop {} }\n+fn foo9() -> *const (impl Fn() -> u8 + ?Sized) { loop {} }\n+fn foo10() -> *const (impl Fn() + Sized + ?Sized) { loop {} }\n+\n+fn main() {\n+    let foo = foo1();\n+    //  ^^^ *const impl Fn()\n+    let foo = foo2();\n+    //  ^^^ *const impl Fn()\n+    let foo = foo3();\n+    //  ^^^ *const (impl Fn() + ?Sized)\n+    let foo = foo4();\n+    //  ^^^ *const impl Fn()\n+    let foo = foo5();\n+    //  ^^^ *const (impl Fn() + ?Sized)\n+    let foo = foo6();\n+    //  ^^^ *const (impl Fn() + Trait)\n+    let foo = foo7();\n+    //  ^^^ *const (impl Fn() + Trait)\n+    let foo = foo8();\n+    //  ^^^ *const (impl Fn() + Trait + ?Sized)\n+    let foo = foo9();\n+    //  ^^^ *const (impl Fn() -> u8 + ?Sized)\n+    let foo = foo10();\n+    //  ^^^ *const impl Fn()\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn unit_structs_have_no_type_hints() {\n         check_types("}]}