{"sha": "1c771fec3329ef1d8c66697daf9517501d0c129a", "node_id": "C_kwDOAAsO6NoAKDFjNzcxZmVjMzMyOWVmMWQ4YzY2Njk3ZGFmOTUxNzUwMWQwYzEyOWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-23T01:26:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-23T01:26:59Z"}, "message": "Auto merge of #108861 - b-naber:eager-nll-type-relating, r=lcnr\n\nMake NLL Type Relating Eager\n\nWe previously instantiated bound regions in nll type relating lazily. Making this eager is more consistent with how we handle type relating in [`higher_ranked_sub`](https://github.com/rust-lang/rust/blob/0a3b557d528dd7c8a88ceca6f7dc0699b89a3ef4/compiler/rustc_infer/src/infer/higher_ranked/mod.rs#L28) and should allow us to short circuit in case there's structural equality.", "tree": {"sha": "55e8a9f79e5a7e4c59d469eb7580f9ad1f1ffe7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55e8a9f79e5a7e4c59d469eb7580f9ad1f1ffe7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c771fec3329ef1d8c66697daf9517501d0c129a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c771fec3329ef1d8c66697daf9517501d0c129a", "html_url": "https://github.com/rust-lang/rust/commit/1c771fec3329ef1d8c66697daf9517501d0c129a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c771fec3329ef1d8c66697daf9517501d0c129a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8859fde21fa4e059c71a843cc7ee995c189a97c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8859fde21fa4e059c71a843cc7ee995c189a97c0", "html_url": "https://github.com/rust-lang/rust/commit/8859fde21fa4e059c71a843cc7ee995c189a97c0"}, {"sha": "8f4cf2e00073a65d888fb3fefe17a8a50a6d2a1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f4cf2e00073a65d888fb3fefe17a8a50a6d2a1f", "html_url": "https://github.com/rust-lang/rust/commit/8f4cf2e00073a65d888fb3fefe17a8a50a6d2a1f"}], "stats": {"total": 358, "additions": 159, "deletions": 199}, "files": [{"sha": "b7ce3afce7bb2712b3689db1152e07aa8b0aff00", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=1c771fec3329ef1d8c66697daf9517501d0c129a", "patch": "@@ -510,16 +510,11 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n             .as_var()\n             .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n \n-        if cfg!(debug_assertions) {\n+        if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n             let ctxt = get_ctxt_fn();\n             let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n-            let prev = var_to_origin.insert(vid, ctxt);\n-\n-            // This only makes sense if not called in a canonicalization context. If this\n-            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n-            // or modify how we track nll region vars for that map.\n-            assert!(matches!(prev, None));\n+            var_to_origin.insert(vid, ctxt);\n         }\n \n         next_region\n@@ -539,16 +534,11 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n             .as_var()\n             .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n \n-        if cfg!(debug_assertions) {\n+        if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n             let ctxt = get_ctxt_fn();\n             let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n-            let prev = var_to_origin.insert(vid, ctxt);\n-\n-            // This only makes sense if not called in a canonicalization context. If this\n-            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n-            // or modify how we track nll region vars for that map.\n-            assert!(matches!(prev, None));\n+            var_to_origin.insert(vid, ctxt);\n         }\n \n         next_region"}, {"sha": "03f175daca9e8d26e4237d778df738453a0e0348", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=1c771fec3329ef1d8c66697daf9517501d0c129a", "patch": "@@ -256,11 +256,12 @@ fn sccs_info<'cx, 'tcx>(\n \n     let mut var_to_origin_sorted = var_to_origin.clone().into_iter().collect::<Vec<_>>();\n     var_to_origin_sorted.sort_by_key(|vto| vto.0);\n-    let mut debug_str = \"region variables to origins:\\n\".to_string();\n+\n+    let mut reg_vars_to_origins_str = \"region variables to origins:\\n\".to_string();\n     for (reg_var, origin) in var_to_origin_sorted.into_iter() {\n-        debug_str.push_str(&format!(\"{:?}: {:?}\\n\", reg_var, origin));\n+        reg_vars_to_origins_str.push_str(&format!(\"{:?}: {:?}\\n\", reg_var, origin));\n     }\n-    debug!(debug_str);\n+    debug!(\"{}\", reg_vars_to_origins_str);\n \n     let num_components = sccs.scc_data().ranges().len();\n     let mut components = vec![FxIndexSet::default(); num_components];\n@@ -275,12 +276,12 @@ fn sccs_info<'cx, 'tcx>(\n     for (scc_idx, reg_vars_origins) in components.iter().enumerate() {\n         let regions_info = reg_vars_origins.clone().into_iter().collect::<Vec<_>>();\n         components_str.push_str(&format!(\n-            \"{:?}: {:?})\",\n+            \"{:?}: {:?},\\n)\",\n             ConstraintSccIndex::from_usize(scc_idx),\n             regions_info,\n         ))\n     }\n-    debug!(components_str);\n+    debug!(\"{}\", components_str);\n \n     // calculate the best representative for each component\n     let components_representatives = components"}, {"sha": "305e2c8fe8ebbcc539e7d24a00cc7ab414bda503", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=1c771fec3329ef1d8c66697daf9517501d0c129a", "patch": "@@ -132,9 +132,12 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n \n         let reg_var =\n             reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n-        let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-        let prev = var_to_origin.insert(reg_var, RegionCtxt::Placeholder(reg_info));\n-        assert!(matches!(prev, None));\n+\n+        if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n+            let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n+            debug!(?reg_var);\n+            var_to_origin.insert(reg_var, RegionCtxt::Placeholder(reg_info));\n+        }\n \n         reg\n     }\n@@ -149,14 +152,9 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         let reg_var =\n             reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n \n-        if cfg!(debug_assertions) {\n+        if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            let prev = var_to_origin.insert(reg_var, RegionCtxt::Existential(None));\n-\n-            // It only makes sense to track region vars in non-canonicalization contexts. If this\n-            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n-            // or modify how we track nll region vars for that map.\n-            assert!(matches!(prev, None));\n+            var_to_origin.insert(reg_var, RegionCtxt::Existential(None));\n         }\n \n         reg"}, {"sha": "d240d8e491fafb3aa3f29920670e71782cb3a85b", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=1c771fec3329ef1d8c66697daf9517501d0c129a", "patch": "@@ -30,6 +30,8 @@ use super::*;\n use rustc_middle::ty::relate::{Relate, TypeRelation};\n use rustc_middle::ty::{Const, ImplSubject};\n \n+use std::cell::Cell;\n+\n /// Whether we should define opaque types or just treat them opaquely.\n ///\n /// Currently only used to prevent predicate matching from matching anything\n@@ -82,6 +84,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             in_snapshot: self.in_snapshot.clone(),\n             universe: self.universe.clone(),\n             intercrate: self.intercrate,\n+            inside_canonicalization_ctxt: Cell::new(self.inside_canonicalization_ctxt()),\n         }\n     }\n }"}, {"sha": "96a5f6532fecdadc0aa2a9f1dcbad2de4a60e305", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=1c771fec3329ef1d8c66697daf9517501d0c129a", "patch": "@@ -561,6 +561,8 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     where\n         V: TypeFoldable<TyCtxt<'tcx>>,\n     {\n+        let _inside_canonical_ctxt_guard = infcx.set_canonicalization_ctxt();\n+\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::NEEDS_INFER |\n             TypeFlags::HAS_FREE_REGIONS | // `HAS_RE_PLACEHOLDER` implies `HAS_FREE_REGIONS`"}, {"sha": "8f1a1579290a7f0efdee220560cada2856588714", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=1c771fec3329ef1d8c66697daf9517501d0c129a", "patch": "@@ -39,6 +39,7 @@ use rustc_span::Span;\n \n use std::cell::{Cell, RefCell};\n use std::fmt;\n+use std::ops::Drop;\n \n use self::combine::CombineFields;\n use self::error_reporting::TypeErrCtxt;\n@@ -342,6 +343,11 @@ pub struct InferCtxt<'tcx> {\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n     pub intercrate: bool,\n+\n+    /// Flag that is set when we enter canonicalization. Used for debugging to ensure\n+    /// that we only collect region information for `BorrowckInferCtxt::reg_var_to_origin`\n+    /// inside non-canonicalization contexts.\n+    inside_canonicalization_ctxt: Cell<bool>,\n }\n \n /// See the `error_reporting` module for more details.\n@@ -633,6 +639,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             skip_leak_check: Cell::new(false),\n             universe: Cell::new(ty::UniverseIndex::ROOT),\n             intercrate,\n+            inside_canonicalization_ctxt: Cell::new(false),\n         }\n     }\n }\n@@ -1728,6 +1735,31 @@ impl<'tcx> InferCtxt<'tcx> {\n             }\n         }\n     }\n+\n+    pub fn inside_canonicalization_ctxt(&self) -> bool {\n+        self.inside_canonicalization_ctxt.get()\n+    }\n+\n+    pub fn set_canonicalization_ctxt(&self) -> CanonicalizationCtxtGuard<'_, 'tcx> {\n+        let prev_ctxt = self.inside_canonicalization_ctxt();\n+        self.inside_canonicalization_ctxt.set(true);\n+        CanonicalizationCtxtGuard { prev_ctxt, infcx: self }\n+    }\n+\n+    fn set_canonicalization_ctxt_to(&self, ctxt: bool) {\n+        self.inside_canonicalization_ctxt.set(ctxt);\n+    }\n+}\n+\n+pub struct CanonicalizationCtxtGuard<'cx, 'tcx> {\n+    prev_ctxt: bool,\n+    infcx: &'cx InferCtxt<'tcx>,\n+}\n+\n+impl<'cx, 'tcx> Drop for CanonicalizationCtxtGuard<'cx, 'tcx> {\n+    fn drop(&mut self) {\n+        self.infcx.set_canonicalization_ctxt_to(self.prev_ctxt)\n+    }\n }\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {"}, {"sha": "2320f6bfb1674a434c493896e850870210fddff3", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 104, "deletions": 170, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c771fec3329ef1d8c66697daf9517501d0c129a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=1c771fec3329ef1d8c66697daf9517501d0c129a", "patch": "@@ -28,6 +28,7 @@ use crate::traits::{Obligation, PredicateObligations};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor};\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n@@ -55,21 +56,6 @@ where\n     ambient_variance: ty::Variance,\n \n     ambient_variance_info: ty::VarianceDiagInfo<'tcx>,\n-\n-    /// When we pass through a set of binders (e.g., when looking into\n-    /// a `fn` type), we push a new bound region scope onto here. This\n-    /// will contain the instantiated region for each region in those\n-    /// binders. When we then encounter a `ReLateBound(d, br)`, we can\n-    /// use the De Bruijn index `d` to find the right scope, and then\n-    /// bound region name `br` to find the specific instantiation from\n-    /// within that scope. See `replace_bound_region`.\n-    ///\n-    /// This field stores the instantiations for late-bound regions in\n-    /// the `a` type.\n-    a_scopes: Vec<BoundRegionScope<'tcx>>,\n-\n-    /// Same as `a_scopes`, but for the `b` type.\n-    b_scopes: Vec<BoundRegionScope<'tcx>>,\n }\n \n pub trait TypeRelatingDelegate<'tcx> {\n@@ -147,8 +133,6 @@ where\n             delegate,\n             ambient_variance,\n             ambient_variance_info: ty::VarianceDiagInfo::default(),\n-            a_scopes: vec![],\n-            b_scopes: vec![],\n         }\n     }\n \n@@ -166,88 +150,6 @@ where\n         }\n     }\n \n-    fn create_scope(\n-        &mut self,\n-        value: ty::Binder<'tcx, impl Relate<'tcx>>,\n-        universally_quantified: UniversallyQuantified,\n-    ) -> BoundRegionScope<'tcx> {\n-        let mut scope = BoundRegionScope::default();\n-\n-        // Create a callback that creates (via the delegate) either an\n-        // existential or placeholder region as needed.\n-        let mut next_region = {\n-            let delegate = &mut self.delegate;\n-            let mut lazy_universe = None;\n-            move |br: ty::BoundRegion| {\n-                if universally_quantified.0 {\n-                    // The first time this closure is called, create a\n-                    // new universe for the placeholders we will make\n-                    // from here out.\n-                    let universe = lazy_universe.unwrap_or_else(|| {\n-                        let universe = delegate.create_next_universe();\n-                        lazy_universe = Some(universe);\n-                        universe\n-                    });\n-\n-                    let placeholder = ty::PlaceholderRegion { universe, name: br.kind };\n-                    delegate.next_placeholder_region(placeholder)\n-                } else {\n-                    delegate.next_existential_region_var(true, br.kind.get_name())\n-                }\n-            }\n-        };\n-\n-        value.skip_binder().visit_with(&mut ScopeInstantiator {\n-            next_region: &mut next_region,\n-            target_index: ty::INNERMOST,\n-            bound_region_scope: &mut scope,\n-        });\n-\n-        scope\n-    }\n-\n-    /// When we encounter binders during the type traversal, we record\n-    /// the value to substitute for each of the things contained in\n-    /// that binder. (This will be either a universal placeholder or\n-    /// an existential inference variable.) Given the De Bruijn index\n-    /// `debruijn` (and name `br`) of some binder we have now\n-    /// encountered, this routine finds the value that we instantiated\n-    /// the region with; to do so, it indexes backwards into the list\n-    /// of ambient scopes `scopes`.\n-    fn lookup_bound_region(\n-        debruijn: ty::DebruijnIndex,\n-        br: &ty::BoundRegion,\n-        first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope<'tcx>],\n-    ) -> ty::Region<'tcx> {\n-        // The debruijn index is a \"reverse index\" into the\n-        // scopes listing. So when we have INNERMOST (0), we\n-        // want the *last* scope pushed, and so forth.\n-        let debruijn_index = debruijn.index() - first_free_index.index();\n-        let scope = &scopes[scopes.len() - debruijn_index - 1];\n-\n-        // Find this bound region in that scope to map to a\n-        // particular region.\n-        scope.map[br]\n-    }\n-\n-    /// If `r` is a bound region, find the scope in which it is bound\n-    /// (from `scopes`) and return the value that we instantiated it\n-    /// with. Otherwise just return `r`.\n-    fn replace_bound_region(\n-        &self,\n-        r: ty::Region<'tcx>,\n-        first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope<'tcx>],\n-    ) -> ty::Region<'tcx> {\n-        debug!(\"replace_bound_regions(scopes={:?})\", scopes);\n-        if let ty::ReLateBound(debruijn, br) = *r {\n-            Self::lookup_bound_region(debruijn, &br, first_free_index, scopes)\n-        } else {\n-            r\n-        }\n-    }\n-\n     /// Push a new outlives requirement into our output set of\n     /// constraints.\n     fn push_outlives(\n@@ -314,18 +216,9 @@ where\n \n         self.infcx.inner.borrow_mut().type_variables().instantiate(vid, generalized_ty);\n \n-        // The generalized values we extract from `canonical_var_values` have\n-        // been fully instantiated and hence the set of scopes we have\n-        // doesn't matter -- just to be sure, put an empty vector\n-        // in there.\n-        let old_a_scopes = std::mem::take(pair.vid_scopes(self));\n-\n         // Relate the generalized kind to the original one.\n         let result = pair.relate_generalized_ty(self, generalized_ty);\n \n-        // Restore the old scopes now.\n-        *pair.vid_scopes(self) = old_a_scopes;\n-\n         debug!(\"relate_ty_var: complete, result = {:?}\", result);\n         result\n     }\n@@ -379,6 +272,97 @@ where\n         trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n         Ok(a)\n     }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn instantiate_binder_with_placeholders<T>(&mut self, binder: ty::Binder<'tcx, T>) -> T\n+    where\n+        T: ty::TypeFoldable<TyCtxt<'tcx>> + Copy,\n+    {\n+        if let Some(inner) = binder.no_bound_vars() {\n+            return inner;\n+        }\n+\n+        let mut next_region = {\n+            let nll_delegate = &mut self.delegate;\n+            let mut lazy_universe = None;\n+\n+            move |br: ty::BoundRegion| {\n+                // The first time this closure is called, create a\n+                // new universe for the placeholders we will make\n+                // from here out.\n+                let universe = lazy_universe.unwrap_or_else(|| {\n+                    let universe = nll_delegate.create_next_universe();\n+                    lazy_universe = Some(universe);\n+                    universe\n+                });\n+\n+                let placeholder = ty::PlaceholderRegion { universe, name: br.kind };\n+                debug!(?placeholder);\n+                let placeholder_reg = nll_delegate.next_placeholder_region(placeholder);\n+                debug!(?placeholder_reg);\n+\n+                placeholder_reg\n+            }\n+        };\n+\n+        let delegate = FnMutDelegate {\n+            regions: &mut next_region,\n+            types: &mut |_bound_ty: ty::BoundTy| {\n+                unreachable!(\"we only replace regions in nll_relate, not types\")\n+            },\n+            consts: &mut |_bound_var: ty::BoundVar, _ty| {\n+                unreachable!(\"we only replace regions in nll_relate, not consts\")\n+            },\n+        };\n+\n+        let replaced = self.infcx.tcx.replace_bound_vars_uncached(binder, delegate);\n+        debug!(?replaced);\n+\n+        replaced\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn instantiate_binder_with_existentials<T>(&mut self, binder: ty::Binder<'tcx, T>) -> T\n+    where\n+        T: ty::TypeFoldable<TyCtxt<'tcx>> + Copy,\n+    {\n+        if let Some(inner) = binder.no_bound_vars() {\n+            return inner;\n+        }\n+\n+        let mut next_region = {\n+            let nll_delegate = &mut self.delegate;\n+            let mut reg_map = FxHashMap::default();\n+\n+            move |br: ty::BoundRegion| {\n+                if let Some(ex_reg_var) = reg_map.get(&br) {\n+                    return *ex_reg_var;\n+                } else {\n+                    let ex_reg_var =\n+                        nll_delegate.next_existential_region_var(true, br.kind.get_name());\n+                    debug!(?ex_reg_var);\n+                    reg_map.insert(br, ex_reg_var);\n+\n+                    ex_reg_var\n+                }\n+            }\n+        };\n+\n+        let delegate = FnMutDelegate {\n+            regions: &mut next_region,\n+            types: &mut |_bound_ty: ty::BoundTy| {\n+                unreachable!(\"we only replace regions in nll_relate, not types\")\n+            },\n+            consts: &mut |_bound_var: ty::BoundVar, _ty| {\n+                unreachable!(\"we only replace regions in nll_relate, not consts\")\n+            },\n+        };\n+\n+        let replaced = self.infcx.tcx.replace_bound_vars_uncached(binder, delegate);\n+        debug!(?replaced);\n+\n+        replaced\n+    }\n }\n \n /// When we instantiate an inference variable with a value in\n@@ -396,14 +380,6 @@ trait VidValuePair<'tcx>: Debug {\n     /// opposite part of the tuple from the vid).\n     fn value_ty(&self) -> Ty<'tcx>;\n \n-    /// Extract the scopes that apply to whichever side of the tuple\n-    /// the vid was found on. See the comment where this is called\n-    /// for more details on why we want them.\n-    fn vid_scopes<'r, D: TypeRelatingDelegate<'tcx>>(\n-        &self,\n-        relate: &'r mut TypeRelating<'_, 'tcx, D>,\n-    ) -> &'r mut Vec<BoundRegionScope<'tcx>>;\n-\n     /// Given a generalized type G that should replace the vid, relate\n     /// G to the value, putting G on whichever side the vid would have\n     /// appeared.\n@@ -425,16 +401,6 @@ impl<'tcx> VidValuePair<'tcx> for (ty::TyVid, Ty<'tcx>) {\n         self.1\n     }\n \n-    fn vid_scopes<'r, D>(\n-        &self,\n-        relate: &'r mut TypeRelating<'_, 'tcx, D>,\n-    ) -> &'r mut Vec<BoundRegionScope<'tcx>>\n-    where\n-        D: TypeRelatingDelegate<'tcx>,\n-    {\n-        &mut relate.a_scopes\n-    }\n-\n     fn relate_generalized_ty<D>(\n         &self,\n         relate: &mut TypeRelating<'_, 'tcx, D>,\n@@ -457,16 +423,6 @@ impl<'tcx> VidValuePair<'tcx> for (Ty<'tcx>, ty::TyVid) {\n         self.0\n     }\n \n-    fn vid_scopes<'r, D>(\n-        &self,\n-        relate: &'r mut TypeRelating<'_, 'tcx, D>,\n-    ) -> &'r mut Vec<BoundRegionScope<'tcx>>\n-    where\n-        D: TypeRelatingDelegate<'tcx>,\n-    {\n-        &mut relate.b_scopes\n-    }\n-\n     fn relate_generalized_ty<D>(\n         &self,\n         relate: &mut TypeRelating<'_, 'tcx, D>,\n@@ -602,20 +558,14 @@ where\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(?self.ambient_variance);\n \n-        let v_a = self.replace_bound_region(a, ty::INNERMOST, &self.a_scopes);\n-        let v_b = self.replace_bound_region(b, ty::INNERMOST, &self.b_scopes);\n-\n-        debug!(?v_a);\n-        debug!(?v_b);\n-\n         if self.ambient_covariance() {\n             // Covariant: &'a u8 <: &'b u8. Hence, `'a: 'b`.\n-            self.push_outlives(v_a, v_b, self.ambient_variance_info);\n+            self.push_outlives(a, b, self.ambient_variance_info);\n         }\n \n         if self.ambient_contravariance() {\n             // Contravariant: &'b u8 <: &'a u8. Hence, `'b: 'a`.\n-            self.push_outlives(v_b, v_a, self.ambient_variance_info);\n+            self.push_outlives(b, a, self.ambient_variance_info);\n         }\n \n         Ok(a)\n@@ -689,15 +639,6 @@ where\n             // instantiation of B (i.e., B instantiated with\n             // universals).\n \n-            let b_scope = self.create_scope(b, UniversallyQuantified(true));\n-            let a_scope = self.create_scope(a, UniversallyQuantified(false));\n-\n-            debug!(?a_scope, \"(existential)\");\n-            debug!(?b_scope, \"(universal)\");\n-\n-            self.b_scopes.push(b_scope);\n-            self.a_scopes.push(a_scope);\n-\n             // Reset the ambient variance to covariant. This is needed\n             // to correctly handle cases like\n             //\n@@ -718,12 +659,14 @@ where\n             //   subtyping (i.e., `&'b u32 <: &{P} u32`).\n             let variance = std::mem::replace(&mut self.ambient_variance, ty::Variance::Covariant);\n \n-            self.relate(a.skip_binder(), b.skip_binder())?;\n+            // Note: the order here is important. Create the placeholders first, otherwise\n+            // we assign the wrong universe to the existential!\n+            let b_replaced = self.instantiate_binder_with_placeholders(b);\n+            let a_replaced = self.instantiate_binder_with_existentials(a);\n \n-            self.ambient_variance = variance;\n+            self.relate(a_replaced, b_replaced)?;\n \n-            self.b_scopes.pop().unwrap();\n-            self.a_scopes.pop().unwrap();\n+            self.ambient_variance = variance;\n         }\n \n         if self.ambient_contravariance() {\n@@ -733,26 +676,17 @@ where\n             // instantiation of B (i.e., B instantiated with\n             // existentials). Opposite of above.\n \n-            let a_scope = self.create_scope(a, UniversallyQuantified(true));\n-            let b_scope = self.create_scope(b, UniversallyQuantified(false));\n-\n-            debug!(?a_scope, \"(universal)\");\n-            debug!(?b_scope, \"(existential)\");\n-\n-            self.a_scopes.push(a_scope);\n-            self.b_scopes.push(b_scope);\n-\n             // Reset ambient variance to contravariance. See the\n             // covariant case above for an explanation.\n             let variance =\n                 std::mem::replace(&mut self.ambient_variance, ty::Variance::Contravariant);\n \n-            self.relate(a.skip_binder(), b.skip_binder())?;\n+            let a_replaced = self.instantiate_binder_with_placeholders(a);\n+            let b_replaced = self.instantiate_binder_with_existentials(b);\n \n-            self.ambient_variance = variance;\n+            self.relate(a_replaced, b_replaced)?;\n \n-            self.b_scopes.pop().unwrap();\n-            self.a_scopes.pop().unwrap();\n+            self.ambient_variance = variance;\n         }\n \n         Ok(a)"}]}