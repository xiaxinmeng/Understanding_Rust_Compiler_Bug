{"sha": "1d3e08d8c6248c4e8c668bf53ff0a308873da31d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkM2UwOGQ4YzYyNDhjNGU4YzY2OGJmNTNmZjBhMzA4ODczZGEzMWQ=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-02-21T19:29:36Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-29T01:56:15Z"}, "message": "finishing up simple uv_timer impl\n\nas it stands, basic async nad timer support is added", "tree": {"sha": "c3089b452dfd2f5127d6e81dfd0c8e3848dbdca2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3089b452dfd2f5127d6e81dfd0c8e3848dbdca2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d3e08d8c6248c4e8c668bf53ff0a308873da31d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d3e08d8c6248c4e8c668bf53ff0a308873da31d", "html_url": "https://github.com/rust-lang/rust/commit/1d3e08d8c6248c4e8c668bf53ff0a308873da31d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d3e08d8c6248c4e8c668bf53ff0a308873da31d/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b68eb507da6a2621a74676fc9a4ca76b37561ec8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b68eb507da6a2621a74676fc9a4ca76b37561ec8", "html_url": "https://github.com/rust-lang/rust/commit/b68eb507da6a2621a74676fc9a4ca76b37561ec8"}], "stats": {"total": 241, "additions": 211, "deletions": 30}, "files": [{"sha": "123cd8ac2a81c909934304d0568f5cdddfb78e37", "filename": "src/libstd/uvtmp.rs", "status": "modified", "additions": 160, "deletions": 22, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/1d3e08d8c6248c4e8c668bf53ff0a308873da31d/src%2Flibstd%2Fuvtmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3e08d8c6248c4e8c668bf53ff0a308873da31d/src%2Flibstd%2Fuvtmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuvtmp.rs?ref=1d3e08d8c6248c4e8c668bf53ff0a308873da31d", "patch": "@@ -6,11 +6,15 @@\n // process_operation() crust fn below\n enum uv_operation {\n     op_async_init([u8]),\n-    op_close(uv_handle, *ctypes::void)\n+    op_close(uv_handle, *ctypes::void),\n+    op_timer_init([u8]),\n+    op_timer_start([u8], *ctypes::void, u32, u32),\n+    op_timer_stop([u8], *ctypes::void, fn~(uv_handle))\n }\n \n enum uv_handle {\n-    uv_async([u8], uv_loop)\n+    uv_async([u8], uv_loop),\n+    uv_timer([u8], uv_loop)\n }\n \n enum uv_msg {\n@@ -20,11 +24,17 @@ enum uv_msg {\n     msg_async_init(fn~(uv_handle), fn~(uv_handle)),\n     msg_async_send([u8]),\n     msg_close(uv_handle, fn~()),\n+    msg_timer_init(fn~(uv_handle)),\n+    msg_timer_start([u8], u32, u32, fn~(uv_handle)),\n+    msg_timer_stop([u8], fn~(uv_handle)),\n \n     // dispatches from libuv\n     uv_async_init([u8], *ctypes::void),\n     uv_async_send([u8]),\n     uv_close([u8]),\n+    uv_timer_init([u8], *ctypes::void),\n+    uv_timer_call([u8]),\n+    uv_timer_stop([u8], fn~(uv_handle)),\n     uv_end()\n }\n \n@@ -74,16 +84,26 @@ native mod rustrt {\n     fn rust_uvtmp_uv_run(loop_handle: *ctypes::void);\n     fn rust_uvtmp_uv_close(handle: *ctypes::void, cb: *u8);\n     fn rust_uvtmp_uv_close_async(handle: *ctypes::void);\n+    fn rust_uvtmp_uv_close_timer(handle: *ctypes::void);\n     fn rust_uvtmp_uv_async_send(handle: *ctypes::void);\n     fn rust_uvtmp_uv_async_init(\n         loop_handle: *ctypes::void,\n         cb: *u8,\n         id: *u8) -> *ctypes::void;\n+    fn rust_uvtmp_uv_timer_init(\n+        loop_handle: *ctypes::void,\n+        cb: *u8,\n+        id: *u8) -> *ctypes::void;\n+    fn rust_uvtmp_uv_timer_start(\n+        timer_handle: *ctypes::void,\n+        timeout: ctypes::c_uint,\n+        repeat: ctypes::c_uint);\n+    fn rust_uvtmp_uv_timer_stop(handle: *ctypes::void);\n }\n \n mod uv {\n     export loop_new, run, close, run_in_bg, async_init, async_send,\n-           timer_init;\n+           timer_init, timer_start, timer_stop;\n \n     // public functions\n     fn loop_new() -> uv_loop unsafe {\n@@ -92,9 +112,7 @@ mod uv {\n         let ret_recv_chan: comm::chan<uv_loop> =\n             comm::chan(ret_recv_port);\n \n-        let num_threads = 4u; // would be cool to tie this to\n-                              // the number of logical procs\n-        task::spawn_sched(num_threads) {||\n+        task::spawn_sched(task::manual_threads(4u)) {||\n             // our beloved uv_loop_t ptr\n             let loop_handle = rustrt::\n                 rust_uvtmp_uv_loop_new();\n@@ -140,13 +158,15 @@ mod uv {\n                 map::new_bytes_hash();\n             let id_to_handle: map::map<[u8], uv_handle> =\n                 map::new_bytes_hash();\n-            let async_cbs: map::map<[u8], fn~(uv_handle)> =\n-                map::new_bytes_hash();\n-            let async_init_after_cbs: map::map<[u8],\n-                                               fn~(uv_handle)> =\n+            let after_cbs: map::map<[u8], fn~(uv_handle)> =\n                 map::new_bytes_hash();\n             let close_callbacks: map::map<[u8], fn~()> =\n                 map::new_bytes_hash();\n+            \n+            let async_cbs: map::map<[u8], fn~(uv_handle)> =\n+                map::new_bytes_hash();\n+            let timer_cbs: map::map<[u8], fn~(uv_handle)> =\n+                map::new_bytes_hash();\n \n             // the main loop that this task blocks on.\n             // should have the same lifetime as the C libuv\n@@ -160,7 +180,7 @@ mod uv {\n                     // the operation handle to have the\n                     // loop process any pending operations\n                     // once its up and running\n-                    task::spawn_sched(1u) {||\n+                    task::spawn_sched(task::manual_threads(1u)) {||\n                         // this call blocks\n                         rustrt::rust_uvtmp_uv_run(loop_handle);\n                         // when we're done, msg the\n@@ -172,7 +192,7 @@ mod uv {\n                   }\n                   \n                   msg_run_in_bg {\n-                    task::spawn_sched(1u) {||\n+                    task::spawn_sched(task::manual_threads(1u)) {||\n                         // this call blocks\n                         rustrt::rust_uvtmp_uv_run(loop_handle);\n                     };\n@@ -194,6 +214,9 @@ mod uv {\n                       uv_async(id, _) {\n                         async_cbs.remove(id);\n                       }\n+                      uv_timer(id, _) {\n+                        timer_cbs.remove(id);\n+                      }\n                       _ {\n                         fail \"unknown form of uv_handle encountered \"\n                             + \"in uv_close handler\";\n@@ -213,7 +236,7 @@ mod uv {\n                     // invocation on msg_async_send\n                     let id = gen_handle_id();\n                     async_cbs.insert(id, callback);\n-                    async_init_after_cbs.insert(id, after_cb);\n+                    after_cbs.insert(id, after_cb);\n                     let op = op_async_init(id);\n                     pass_to_libuv(op_handle, operation_chan, op);\n                   }\n@@ -223,8 +246,8 @@ mod uv {\n                     // then invoke the supplied callback\n                     // for after completion\n                     handles.insert(id, async_handle);\n-                    let after_cb = async_init_after_cbs.get(id);\n-                    async_init_after_cbs.remove(id);\n+                    let after_cb = after_cbs.get(id);\n+                    after_cbs.remove(id);\n                     let async = uv_async(id, rust_loop_chan);\n                     id_to_handle.insert(id, copy(async));\n                     task::spawn {||\n@@ -242,6 +265,50 @@ mod uv {\n                         async_cb(uv_async(id, rust_loop_chan));\n                     };\n                   }\n+\n+                  msg_timer_init(after_cb) {\n+                    let id = gen_handle_id();\n+                    after_cbs.insert(id, after_cb);\n+                    let op = op_timer_init(id);\n+                    pass_to_libuv(op_handle, operation_chan, op);\n+                  }\n+                  uv_timer_init(id, handle) {\n+                    handles.insert(id, handle);\n+                    let after_cb = after_cbs.get(id);\n+                    after_cbs.remove(id);\n+                    let new_timer = uv_timer(id, rust_loop_chan);\n+                    id_to_handle.insert(id, copy(new_timer));\n+                    task::spawn {||\n+                        after_cb(new_timer);\n+                    };\n+                  }\n+\n+                  uv_timer_call(id) {\n+                    let cb = timer_cbs.get(id);\n+                    let the_timer = id_to_handle.get(id);\n+                    task::spawn {||\n+                        cb(the_timer);\n+                    };\n+                  }\n+\n+                  msg_timer_start(id, timeout, repeat, timer_call_cb) {\n+                    timer_cbs.insert(id, timer_call_cb);\n+                    let handle = handles.get(id);\n+                    let op = op_timer_start(id, handle, timeout,\n+                                            repeat);\n+                    pass_to_libuv(op_handle, operation_chan, op);\n+                  }\n+\n+                  msg_timer_stop(id, after_cb) {\n+                    let handle = handles.get(id);\n+                    let op = op_timer_stop(id, handle, after_cb);\n+                    pass_to_libuv(op_handle, operation_chan, op);\n+                  }\n+                  uv_timer_stop(id, after_cb) {\n+                    let the_timer = id_to_handle.get(id);\n+                    after_cb(the_timer);\n+                  }\n+                  \n                   uv_end() {\n                     keep_going = false;\n                   }\n@@ -294,6 +361,33 @@ mod uv {\n         comm::send(loop, msg);\n     }\n \n+    fn timer_start(the_timer: uv_handle, timeout: u32, repeat:u32,\n+                   timer_cb: fn~(uv_handle)) {\n+        alt the_timer {\n+          uv_timer(id, loop_chan) {\n+            let msg = msg_timer_start(id, timeout, repeat, timer_cb);\n+            comm::send(loop_chan, msg);\n+          }\n+          _ {\n+            fail \"can only pass a uv_timer form of uv_handle to \"+\n+                 \" uv::timer_start()\";\n+          }\n+        }\n+    }\n+\n+    fn timer_stop(the_timer: uv_handle, after_cb: fn~(uv_handle)) {\n+        alt the_timer {\n+          uv_timer(id, loop_chan) {\n+            let msg = msg_timer_stop(id, after_cb);\n+            comm::send(loop_chan, msg);\n+          }\n+          _ {\n+            fail \"only uv_timer form is allowed in calls to \"+\n+                 \" uv::timer_stop()\";\n+          }\n+        }\n+    }\n+\n     // internal functions\n     fn pass_to_libuv(\n             op_handle: *ctypes::void,\n@@ -320,7 +414,7 @@ mod uv {\n     fn get_loop_chan_from_handle(handle: uv_handle)\n         -> uv_loop {\n         alt handle {\n-          uv_async(id,loop) {\n+          uv_async(id,loop) | uv_timer(id,loop) {\n             ret loop;\n           }\n           _ {\n@@ -332,7 +426,7 @@ mod uv {\n \n     fn get_id_from_handle(handle: uv_handle) -> [u8] {\n         alt handle {\n-          uv_async(id,loop) {\n+          uv_async(id,loop) | uv_timer(id,loop) {\n             ret id;\n           }\n           _ {\n@@ -363,6 +457,24 @@ mod uv {\n               op_close(handle, handle_ptr) {\n                 handle_op_close(handle, handle_ptr);\n               }\n+              op_timer_init(id) {\n+                let id_ptr = vec::unsafe::to_ptr(id);\n+                let timer_handle = rustrt::rust_uvtmp_uv_timer_init(\n+                    loop,\n+                    process_timer_call,\n+                    id_ptr);\n+                comm::send(loop_chan, uv_timer_init(\n+                    id,\n+                    timer_handle));\n+              }\n+              op_timer_start(id, handle, timeout, repeat) {\n+                rustrt::rust_uvtmp_uv_timer_start(handle, timeout,\n+                                                  repeat);\n+              }\n+              op_timer_stop(id, handle, after_cb) {\n+                rustrt::rust_uvtmp_uv_timer_stop(handle);\n+                comm::send(loop_chan, uv_timer_stop(id, after_cb));\n+              }\n               \n               _ { fail \"unknown form of uv_operation received\"; }\n             }\n@@ -378,6 +490,11 @@ mod uv {\n             rustrt::rust_uvtmp_uv_close(\n                 handle_ptr, cb);\n           }\n+          uv_timer(id, loop) {\n+            let cb = process_close_timer;\n+            rustrt::rust_uvtmp_uv_close(\n+                handle_ptr, cb);\n+          }\n           _ {\n             fail \"unknown form of uv_handle encountered \" +\n                 \"in process_operation/op_close\";\n@@ -386,12 +503,19 @@ mod uv {\n     }\n \n     crust fn process_async_send(id_buf: *u8, data: *uv_loop_data)\n-            unsafe {\n+        unsafe {\n         let handle_id = get_handle_id_from(id_buf);\n         let loop_chan = get_loop_chan_from_data(data);\n         comm::send(loop_chan, uv_async_send(handle_id));\n     }\n \n+    crust fn process_timer_call(id_buf: *u8, data: *uv_loop_data)\n+        unsafe {\n+        let handle_id = get_handle_id_from(id_buf);\n+        let loop_chan = get_loop_chan_from_data(data);\n+        comm::send(loop_chan, uv_timer_call(handle_id));\n+    }\n+\n     fn process_close_common(id: [u8], data: *uv_loop_data)\n         unsafe {\n         // notify the rust loop that their handle is closed, then\n@@ -414,6 +538,16 @@ mod uv {\n         // close cb\n         process_close_common(id, data);\n     }\n+    \n+    crust fn process_close_timer(\n+        id_buf: *u8,\n+        handle_ptr: *ctypes::void,\n+        data: *uv_loop_data)\n+        unsafe {\n+        let id = get_handle_id_from(id_buf);\n+        rustrt::rust_uvtmp_uv_close_timer(handle_ptr);\n+        process_close_common(id, data);\n+    }\n \n     \n }\n@@ -446,11 +580,15 @@ fn test_uvtmp_uv_timer() {\n     let test_loop = uv::loop_new();\n     let exit_port = comm::port::<bool>();\n     let exit_chan = comm::chan::<bool>(exit_port);\n-    uv::timer(test_loop, {|new_timer|\n-        uv::timer_start(new_async) {||\n-            comm::send(exit_chan, true);\n+    uv::timer_init(test_loop) {|new_timer|\n+        uv::timer_start(new_timer, 1u32, 0u32) {|started_timer|\n+            uv::timer_stop(started_timer) {|stopped_timer|\n+                uv::close(stopped_timer) {||\n+                    comm::send(exit_chan, true);\n+                };\n+            };\n         };\n-    }); \n+    }; \n     uv::run(test_loop);\n     assert comm::recv(exit_port);\n }"}, {"sha": "697231dff1b56c8dbb1b83312efff738f9ee7688", "filename": "src/rt/rust_uvtmp.cpp", "status": "modified", "additions": 51, "deletions": 8, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1d3e08d8c6248c4e8c668bf53ff0a308873da31d/src%2Frt%2Frust_uvtmp.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1d3e08d8c6248c4e8c668bf53ff0a308873da31d/src%2Frt%2Frust_uvtmp.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uvtmp.cpp?ref=1d3e08d8c6248c4e8c668bf53ff0a308873da31d", "patch": "@@ -59,7 +59,7 @@ struct timer_start_data {\n \n // crust fn pointers\n typedef void (*crust_async_op_cb)(uv_loop_t* loop, void* data);\n-typedef void (*crust_async_cb)(uint8_t* id_buf, void* loop_data);\n+typedef void (*crust_simple_cb)(uint8_t* id_buf, void* loop_data);\n typedef void (*crust_close_cb)(uint8_t* id_buf, void* handle,\n \t\t\t\t\t\t\t  void* data);\n \n@@ -68,7 +68,7 @@ typedef void (*crust_close_cb)(uint8_t* id_buf, void* handle,\n \n struct handle_data {\n \tuint8_t id_buf[RUST_UV_HANDLE_LEN];\n-\tcrust_async_cb cb;\n+\tcrust_simple_cb cb;\n \tcrust_close_cb close_cb;\n };\n \n@@ -84,6 +84,16 @@ current_kernel_free(void* ptr) {\n   rust_task_thread::get_task()->kernel->free(ptr);\n }\n \n+static handle_data*\n+new_handle_data_from(uint8_t* buf, crust_simple_cb cb) {\n+\thandle_data* data = (handle_data*)current_kernel_malloc(\n+\t\tsizeof(handle_data),\n+\t\t\"handle_data\");\n+\tmemcpy(data->id_buf, buf, RUST_UV_HANDLE_LEN);\n+\tdata->cb = cb;\n+\treturn data;\n+}\n+\n // libuv callback impls\n static void\n native_crust_async_op_cb(uv_async_t* handle, int status) {\n@@ -99,6 +109,13 @@ native_async_cb(uv_async_t* handle, int status) {\n \thandle_d->cb(handle_d->id_buf, loop_data);\n }\n \n+static void\n+native_timer_cb(uv_timer_t* handle, int status) {\n+\thandle_data* handle_d = (handle_data*)handle->data;\n+\tvoid* loop_data = handle->loop->data;\n+\thandle_d->cb(handle_d->id_buf, loop_data);\n+}\n+\n static void\n native_close_cb(uv_handle_t* handle) {\n \thandle_data* data = (handle_data*)handle->data;\n@@ -172,28 +189,54 @@ rust_uvtmp_uv_close_async(uv_async_t* handle) {\n   current_kernel_free(handle);\n }\n \n+extern \"C\" void\n+rust_uvtmp_uv_close_timer(uv_async_t* handle) {\n+  current_kernel_free(handle->data);\n+  current_kernel_free(handle);\n+}\n+\n extern \"C\" void\n rust_uvtmp_uv_async_send(uv_async_t* handle) {\n     uv_async_send(handle);\n }\n \n extern \"C\" void*\n-rust_uvtmp_uv_async_init(uv_loop_t* loop, crust_async_cb cb,\n+rust_uvtmp_uv_async_init(uv_loop_t* loop, crust_simple_cb cb,\n \t\t\t\t\t\t uint8_t* buf) {\n \tuv_async_t* async = (uv_async_t*)current_kernel_malloc(\n \t\tsizeof(uv_async_t),\n \t\t\"uv_async_t\");\n \tuv_async_init(loop, async, native_async_cb);\n-\thandle_data* data = (handle_data*)current_kernel_malloc(\n-\t\tsizeof(handle_data),\n-\t\t\"handle_data\");\n-\tmemcpy(data->id_buf, buf, RUST_UV_HANDLE_LEN);\n-\tdata->cb = cb;\n+\thandle_data* data = new_handle_data_from(buf, cb);\n \tasync->data = data;\n \n \treturn async;\n }\n \n+extern \"C\" void*\n+rust_uvtmp_uv_timer_init(uv_loop_t* loop, crust_simple_cb cb,\n+\t\t\t\t\t\t uint8_t* buf) {\n+\tuv_timer_t* new_timer = (uv_timer_t*)current_kernel_malloc(\n+\t\tsizeof(uv_timer_t),\n+\t\t\"uv_timer_t\");\n+\tuv_timer_init(loop, new_timer);\n+\thandle_data* data = new_handle_data_from(buf, cb);\n+\tnew_timer->data = data;\n+\n+\treturn new_timer;\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_uv_timer_start(uv_timer_t* the_timer, uint32_t timeout,\n+\t\t\t\t\t\t  uint32_t repeat) {\n+\tuv_timer_start(the_timer, native_timer_cb, timeout, repeat);\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_uv_timer_stop(uv_timer_t* the_timer) {\n+  uv_timer_stop(the_timer); \n+}\n+\n // UVTMP REWORK\n \n // FIXME: Copied from rust_builtins.cpp. Could bitrot easily"}]}