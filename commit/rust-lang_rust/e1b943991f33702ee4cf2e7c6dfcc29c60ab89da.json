{"sha": "e1b943991f33702ee4cf2e7c6dfcc29c60ab89da", "node_id": "C_kwDOAAsO6NoAKGUxYjk0Mzk5MWYzMzcwMmVlNGNmMmU3YzZkZmNjMjljNjBhYjg5ZGE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-16T15:58:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-16T15:58:14Z"}, "message": "Rollup merge of #92635 - camelid:yet-more-cleanup, r=Manishearth\n\nrustdoc: Yet more intra-doc links cleanup\n\nr? `@Manishearth`", "tree": {"sha": "442be7165438cf454a09640baf3f68354cdaed79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/442be7165438cf454a09640baf3f68354cdaed79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh5ECXCRBK7hj4Ov3rIwAAj8YIADsmffdxd0SbdTMEwdXBmifo\nHEcOfrUtCbScdUNUMRvA0c3X8+OJL0Xd9PxbYSnKMiiSfsuzccjKqVaPCkJCE+No\nnDlqBFIGFoiMPT8t1gNCbfns2LePob5i8voIXP3D6iSG70tJdrBp0VLc0ro8dfOo\nfJB2yJQB+LkkykADOFLu03AJdTonvbsQR7VaHCX9ietgO8XFKm4F7C+9DBiUvvIL\nCAQOfHnp2sQC8tDpRJQZUx86q3Wth6cym3QS2TBQiysdlnuWYj4Cx1niN7SD84N8\nhkcYP87DExqsrdksXXGZOtsNenpvaJ7B44fAD6sChIxnPb9JTF8OscS+HUaNrGE=\n=lJbi\n-----END PGP SIGNATURE-----\n", "payload": "tree 442be7165438cf454a09640baf3f68354cdaed79\nparent cf4549c920a62a0bc71357172d8471bb4182637b\nparent 554c7659e8106ee3390ba9bbcc8b44950bda309d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642348694 +0100\ncommitter GitHub <noreply@github.com> 1642348694 +0100\n\nRollup merge of #92635 - camelid:yet-more-cleanup, r=Manishearth\n\nrustdoc: Yet more intra-doc links cleanup\n\nr? `@Manishearth`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da", "html_url": "https://github.com/rust-lang/rust/commit/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf4549c920a62a0bc71357172d8471bb4182637b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf4549c920a62a0bc71357172d8471bb4182637b", "html_url": "https://github.com/rust-lang/rust/commit/cf4549c920a62a0bc71357172d8471bb4182637b"}, {"sha": "554c7659e8106ee3390ba9bbcc8b44950bda309d", "url": "https://api.github.com/repos/rust-lang/rust/commits/554c7659e8106ee3390ba9bbcc8b44950bda309d", "html_url": "https://github.com/rust-lang/rust/commit/554c7659e8106ee3390ba9bbcc8b44950bda309d"}], "stats": {"total": 345, "additions": 182, "deletions": 163}, "files": [{"sha": "5c28ff0afe0e9301d48e4d6c460d4499246d6090", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 159, "deletions": 157, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e1b943991f33702ee4cf2e7c6dfcc29c60ab89da", "patch": "@@ -6,13 +6,12 @@ use rustc_ast as ast;\n use rustc_data_structures::{fx::FxHashMap, stable_set::FxHashSet};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_expand::base::SyntaxExtensionKind;\n-use rustc_hir as hir;\n use rustc_hir::def::{\n     DefKind,\n     Namespace::{self, *},\n     PerNS,\n };\n-use rustc_hir::def_id::{CrateNum, DefId};\n+use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_ID};\n use rustc_middle::ty::{DefIdTree, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug, ty};\n use rustc_resolve::ParentScope;\n@@ -109,6 +108,45 @@ impl Res {\n             Res::Primitive(_) => None,\n         }\n     }\n+\n+    /// Used for error reporting.\n+    fn disambiguator_suggestion(self) -> Suggestion {\n+        let kind = match self {\n+            Res::Primitive(_) => return Suggestion::Prefix(\"prim\"),\n+            Res::Def(kind, _) => kind,\n+        };\n+        if kind == DefKind::Macro(MacroKind::Bang) {\n+            return Suggestion::Macro;\n+        } else if kind == DefKind::Fn || kind == DefKind::AssocFn {\n+            return Suggestion::Function;\n+        } else if kind == DefKind::Field {\n+            return Suggestion::RemoveDisambiguator;\n+        }\n+\n+        let prefix = match kind {\n+            DefKind::Struct => \"struct\",\n+            DefKind::Enum => \"enum\",\n+            DefKind::Trait => \"trait\",\n+            DefKind::Union => \"union\",\n+            DefKind::Mod => \"mod\",\n+            DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst => {\n+                \"const\"\n+            }\n+            DefKind::Static => \"static\",\n+            DefKind::Macro(MacroKind::Derive) => \"derive\",\n+            // Now handle things that don't have a specific disambiguator\n+            _ => match kind\n+                .ns()\n+                .expect(\"tried to calculate a disambiguator for a def without a namespace?\")\n+            {\n+                Namespace::TypeNS => \"type\",\n+                Namespace::ValueNS => \"value\",\n+                Namespace::MacroNS => \"macro\",\n+            },\n+        };\n+\n+        Suggestion::Prefix(prefix)\n+    }\n }\n \n impl TryFrom<ResolveRes> for Res {\n@@ -346,7 +384,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// In particular, this will return an error whenever there aren't three\n     /// full path segments left in the link.\n     ///\n-    /// [enum struct variant]: hir::VariantData::Struct\n+    /// [enum struct variant]: rustc_hir::VariantData::Struct\n     fn variant_field<'path>(\n         &self,\n         path_str: &'path str,\n@@ -667,10 +705,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         }))\n     }\n \n-    /// Returns:\n-    /// - None if no associated item was found\n-    /// - Some((_, _, Some(_))) if an item was found and should go through a side channel\n-    /// - Some((_, _, None)) otherwise\n+    /// Resolve an associated item, returning its containing page's `Res`\n+    /// and the fragment targeting the associated item on its page.\n     fn resolve_associated_item(\n         &mut self,\n         root_res: Res,\n@@ -958,17 +994,7 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n             {\n                 self.cx.tcx.parent(did)\n             }\n-            Some(did) => match self.cx.tcx.parent(did) {\n-                // HACK(jynelson): `clean` marks associated types as `TypedefItem`, not as `AssocTypeItem`.\n-                // Fixing this breaks `fn render_deref_methods`.\n-                // As a workaround, see if the parent of the item is an `impl`; if so this must be an associated item,\n-                // regardless of what rustdoc wants to call it.\n-                Some(parent) => {\n-                    let parent_kind = self.cx.tcx.def_kind(parent);\n-                    Some(if parent_kind == DefKind::Impl { parent } else { did })\n-                }\n-                None => Some(did),\n-            },\n+            Some(did) => Some(did),\n         };\n \n         // FIXME(jynelson): this shouldn't go through stringification, rustdoc should just use the DefId directly\n@@ -1277,79 +1303,9 @@ impl LinkCollector<'_, '_> {\n             }\n         }\n \n-        let report_mismatch = |specified: Disambiguator, resolved: Disambiguator| {\n-            // The resolved item did not match the disambiguator; give a better error than 'not found'\n-            let msg = format!(\"incompatible link kind for `{}`\", path_str);\n-            let callback = |diag: &mut DiagnosticBuilder<'_>, sp: Option<rustc_span::Span>| {\n-                let note = format!(\n-                    \"this link resolved to {} {}, which is not {} {}\",\n-                    resolved.article(),\n-                    resolved.descr(),\n-                    specified.article(),\n-                    specified.descr()\n-                );\n-                if let Some(sp) = sp {\n-                    diag.span_label(sp, &note);\n-                } else {\n-                    diag.note(&note);\n-                }\n-                suggest_disambiguator(resolved, diag, path_str, &ori_link.link, sp);\n-            };\n-            report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, &diag_info, callback);\n-        };\n-\n-        let verify = |kind: DefKind, id: DefId| {\n-            let (kind, id) = if let Some(UrlFragment::Item(ItemFragment(_, id))) = fragment {\n-                (self.cx.tcx.def_kind(id), id)\n-            } else {\n-                (kind, id)\n-            };\n-            debug!(\"intra-doc link to {} resolved to {:?} (id: {:?})\", path_str, res, id);\n-\n-            // Disallow e.g. linking to enums with `struct@`\n-            debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n-            match (kind, disambiguator) {\n-                | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n-                // NOTE: this allows 'method' to mean both normal functions and associated functions\n-                // This can't cause ambiguity because both are in the same namespace.\n-                | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n-                // These are namespaces; allow anything in the namespace to match\n-                | (_, Some(Disambiguator::Namespace(_)))\n-                // If no disambiguator given, allow anything\n-                | (_, None)\n-                // All of these are valid, so do nothing\n-                => {}\n-                (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n-                (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n-                    report_mismatch(specified, Disambiguator::Kind(kind));\n-                    return None;\n-                }\n-            }\n-\n-            // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n-            if let Some((src_id, dst_id)) = id\n-                .as_local()\n-                // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n-                // would presumably panic if a fake `DefIndex` were passed.\n-                .and_then(|dst_id| {\n-                    item.def_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n-                })\n-            {\n-                if self.cx.tcx.privacy_access_levels(()).is_exported(src_id)\n-                    && !self.cx.tcx.privacy_access_levels(()).is_exported(dst_id)\n-                {\n-                    privacy_error(self.cx, &diag_info, path_str);\n-                }\n-            }\n-\n-            Some(())\n-        };\n-\n         match res {\n             Res::Primitive(prim) => {\n                 if let Some(UrlFragment::Item(ItemFragment(_, id))) = fragment {\n-                    let kind = self.cx.tcx.def_kind(id);\n-\n                     // We're actually resolving an associated item of a primitive, so we need to\n                     // verify the disambiguator (if any) matches the type of the associated item.\n                     // This case should really follow the same flow as the `Res::Def` branch below,\n@@ -1358,7 +1314,16 @@ impl LinkCollector<'_, '_> {\n                     // doesn't allow statements like `use str::trim;`, making this a (hopefully)\n                     // valid omission. See https://github.com/rust-lang/rust/pull/80660#discussion_r551585677\n                     // for discussion on the matter.\n-                    verify(kind, id)?;\n+                    let kind = self.cx.tcx.def_kind(id);\n+                    self.verify_disambiguator(\n+                        path_str,\n+                        &ori_link,\n+                        kind,\n+                        id,\n+                        disambiguator,\n+                        item,\n+                        &diag_info,\n+                    )?;\n \n                     // FIXME: it would be nice to check that the feature gate was enabled in the original crate, not just ignore it altogether.\n                     // However I'm not sure how to check that across crates.\n@@ -1372,7 +1337,9 @@ impl LinkCollector<'_, '_> {\n                     match disambiguator {\n                         Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {}\n                         Some(other) => {\n-                            report_mismatch(other, Disambiguator::Primitive);\n+                            self.report_disambiguator_mismatch(\n+                                path_str, &ori_link, other, res, &diag_info,\n+                            );\n                             return None;\n                         }\n                     }\n@@ -1386,13 +1353,106 @@ impl LinkCollector<'_, '_> {\n                 })\n             }\n             Res::Def(kind, id) => {\n-                verify(kind, id)?;\n+                let (kind_for_dis, id_for_dis) =\n+                    if let Some(UrlFragment::Item(ItemFragment(_, id))) = fragment {\n+                        (self.cx.tcx.def_kind(id), id)\n+                    } else {\n+                        (kind, id)\n+                    };\n+                self.verify_disambiguator(\n+                    path_str,\n+                    &ori_link,\n+                    kind_for_dis,\n+                    id_for_dis,\n+                    disambiguator,\n+                    item,\n+                    &diag_info,\n+                )?;\n                 let id = clean::register_res(self.cx, rustc_hir::def::Res::Def(kind, id));\n                 Some(ItemLink { link: ori_link.link, link_text, did: id, fragment })\n             }\n         }\n     }\n \n+    fn verify_disambiguator(\n+        &self,\n+        path_str: &str,\n+        ori_link: &MarkdownLink,\n+        kind: DefKind,\n+        id: DefId,\n+        disambiguator: Option<Disambiguator>,\n+        item: &Item,\n+        diag_info: &DiagnosticInfo<'_>,\n+    ) -> Option<()> {\n+        debug!(\"intra-doc link to {} resolved to {:?}\", path_str, (kind, id));\n+\n+        // Disallow e.g. linking to enums with `struct@`\n+        debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n+        match (kind, disambiguator) {\n+                | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n+                // NOTE: this allows 'method' to mean both normal functions and associated functions\n+                // This can't cause ambiguity because both are in the same namespace.\n+                | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n+                // These are namespaces; allow anything in the namespace to match\n+                | (_, Some(Disambiguator::Namespace(_)))\n+                // If no disambiguator given, allow anything\n+                | (_, None)\n+                // All of these are valid, so do nothing\n+                => {}\n+                (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n+                (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n+                    self.report_disambiguator_mismatch(path_str,ori_link,specified, Res::Def(kind, id),diag_info);\n+                    return None;\n+                }\n+            }\n+\n+        // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n+        if let Some((src_id, dst_id)) = id\n+            .as_local()\n+            // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n+            // would presumably panic if a fake `DefIndex` were passed.\n+            .and_then(|dst_id| {\n+                item.def_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n+            })\n+        {\n+            if self.cx.tcx.privacy_access_levels(()).is_exported(src_id)\n+                && !self.cx.tcx.privacy_access_levels(()).is_exported(dst_id)\n+            {\n+                privacy_error(self.cx, diag_info, path_str);\n+            }\n+        }\n+\n+        Some(())\n+    }\n+\n+    fn report_disambiguator_mismatch(\n+        &self,\n+        path_str: &str,\n+        ori_link: &MarkdownLink,\n+        specified: Disambiguator,\n+        resolved: Res,\n+        diag_info: &DiagnosticInfo<'_>,\n+    ) {\n+        // The resolved item did not match the disambiguator; give a better error than 'not found'\n+        let msg = format!(\"incompatible link kind for `{}`\", path_str);\n+        let callback = |diag: &mut DiagnosticBuilder<'_>, sp: Option<rustc_span::Span>| {\n+            let note = format!(\n+                \"this link resolved to {} {}, which is not {} {}\",\n+                resolved.article(),\n+                resolved.descr(),\n+                specified.article(),\n+                specified.descr(),\n+            );\n+            if let Some(sp) = sp {\n+                diag.span_label(sp, &note);\n+            } else {\n+                diag.note(&note);\n+            }\n+            suggest_disambiguator(resolved, diag, path_str, &ori_link.link, sp);\n+        };\n+        report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, &diag_info, callback);\n+    }\n+\n     fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &MarkdownLink, item: &Item) {\n         let span =\n             super::source_span_for_markdown_range(self.cx.tcx, dox, &ori_link.range, &item.attrs)\n@@ -1413,7 +1473,6 @@ impl LinkCollector<'_, '_> {\n         diag: DiagnosticInfo<'_>,\n         cache_resolution_failure: bool,\n     ) -> Option<(Res, Option<UrlFragment>)> {\n-        // Try to look up both the result and the corresponding side channel value\n         if let Some(ref cached) = self.visited_links.get(&key) {\n             match cached {\n                 Some(cached) => {\n@@ -1686,53 +1745,6 @@ impl Disambiguator {\n         }\n     }\n \n-    fn from_res(res: Res) -> Self {\n-        match res {\n-            Res::Def(kind, _) => Disambiguator::Kind(kind),\n-            Res::Primitive(_) => Disambiguator::Primitive,\n-        }\n-    }\n-\n-    /// Used for error reporting.\n-    fn suggestion(self) -> Suggestion {\n-        let kind = match self {\n-            Disambiguator::Primitive => return Suggestion::Prefix(\"prim\"),\n-            Disambiguator::Kind(kind) => kind,\n-            Disambiguator::Namespace(_) => panic!(\"display_for cannot be used on namespaces\"),\n-        };\n-        if kind == DefKind::Macro(MacroKind::Bang) {\n-            return Suggestion::Macro;\n-        } else if kind == DefKind::Fn || kind == DefKind::AssocFn {\n-            return Suggestion::Function;\n-        } else if kind == DefKind::Field {\n-            return Suggestion::RemoveDisambiguator;\n-        }\n-\n-        let prefix = match kind {\n-            DefKind::Struct => \"struct\",\n-            DefKind::Enum => \"enum\",\n-            DefKind::Trait => \"trait\",\n-            DefKind::Union => \"union\",\n-            DefKind::Mod => \"mod\",\n-            DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst => {\n-                \"const\"\n-            }\n-            DefKind::Static => \"static\",\n-            DefKind::Macro(MacroKind::Derive) => \"derive\",\n-            // Now handle things that don't have a specific disambiguator\n-            _ => match kind\n-                .ns()\n-                .expect(\"tried to calculate a disambiguator for a def without a namespace?\")\n-            {\n-                Namespace::TypeNS => \"type\",\n-                Namespace::ValueNS => \"value\",\n-                Namespace::MacroNS => \"macro\",\n-            },\n-        };\n-\n-        Suggestion::Prefix(prefix)\n-    }\n-\n     fn ns(self) -> Namespace {\n         match self {\n             Self::Namespace(n) => n,\n@@ -1754,9 +1766,9 @@ impl Disambiguator {\n     fn descr(self) -> &'static str {\n         match self {\n             Self::Namespace(n) => n.descr(),\n-            // HACK(jynelson): by looking at the source I saw the DefId we pass\n-            // for `expected.descr()` doesn't matter, since it's not a crate\n-            Self::Kind(k) => k.descr(DefId::local(hir::def_id::DefIndex::from_usize(0))),\n+            // HACK(jynelson): the source of `DefKind::descr` only uses the DefId for\n+            // printing \"module\" vs \"crate\" so using the wrong ID is not a huge problem\n+            Self::Kind(k) => k.descr(CRATE_DEF_ID.to_def_id()),\n             Self::Primitive => \"builtin type\",\n         }\n     }\n@@ -2080,16 +2092,7 @@ fn resolution_failure(\n                     ResolutionFailure::NotResolved { .. } => unreachable!(\"handled above\"),\n                     ResolutionFailure::Dummy => continue,\n                     ResolutionFailure::WrongNamespace { res, expected_ns } => {\n-                        if let Res::Def(kind, _) = res {\n-                            let disambiguator = Disambiguator::Kind(kind);\n-                            suggest_disambiguator(\n-                                disambiguator,\n-                                diag,\n-                                path_str,\n-                                diag_info.ori_link,\n-                                sp,\n-                            )\n-                        }\n+                        suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n \n                         format!(\n                             \"this link resolves to {}, which is not in the {} namespace\",\n@@ -2224,23 +2227,22 @@ fn ambiguity_error(\n         }\n \n         for res in candidates {\n-            let disambiguator = Disambiguator::from_res(res);\n-            suggest_disambiguator(disambiguator, diag, path_str, diag_info.ori_link, sp);\n+            suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n         }\n     });\n }\n \n /// In case of an ambiguity or mismatched disambiguator, suggest the correct\n /// disambiguator.\n fn suggest_disambiguator(\n-    disambiguator: Disambiguator,\n+    res: Res,\n     diag: &mut DiagnosticBuilder<'_>,\n     path_str: &str,\n     ori_link: &str,\n     sp: Option<rustc_span::Span>,\n ) {\n-    let suggestion = disambiguator.suggestion();\n-    let help = format!(\"to link to the {}, {}\", disambiguator.descr(), suggestion.descr());\n+    let suggestion = res.disambiguator_suggestion();\n+    let help = format!(\"to link to the {}, {}\", res.descr(), suggestion.descr());\n \n     if let Some(sp) = sp {\n         let mut spans = suggestion.as_help_span(path_str, ori_link, sp);"}, {"sha": "2d66566119bc3027accb42f24cf09c473ebd14bd", "filename": "src/test/rustdoc-ui/intra-doc/disambiguator-mismatch.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fdisambiguator-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fdisambiguator-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fdisambiguator-mismatch.rs?ref=e1b943991f33702ee4cf2e7c6dfcc29c60ab89da", "patch": "@@ -73,4 +73,9 @@ trait T {}\n //~^ ERROR incompatible link kind for `f`\n //~| NOTE this link resolved\n //~| HELP add parentheses\n+\n+/// Link to [fn@std]\n+//~^ ERROR unresolved link to `std`\n+//~| NOTE this link resolves to the crate `std`\n+//~| HELP to link to the crate, prefix with `mod@`\n pub fn f() {}"}, {"sha": "ad9102c506f7fb792dc291b64071b9c3ff43da63", "filename": "src/test/rustdoc-ui/intra-doc/disambiguator-mismatch.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fdisambiguator-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fdisambiguator-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fdisambiguator-mismatch.stderr?ref=e1b943991f33702ee4cf2e7c6dfcc29c60ab89da", "patch": "@@ -138,5 +138,16 @@ LL - /// Link to [const@f]\n LL + /// Link to [f()]\n    | \n \n-error: aborting due to 12 previous errors\n+error: unresolved link to `std`\n+  --> $DIR/disambiguator-mismatch.rs:77:14\n+   |\n+LL | /// Link to [fn@std]\n+   |              ^^^^^^ this link resolves to the crate `std`, which is not in the value namespace\n+   |\n+help: to link to the crate, prefix with `mod@`\n+   |\n+LL | /// Link to [mod@std]\n+   |              ~~~~\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "7a65723d77b21182efe2a94a716be9d7e0403e9a", "filename": "src/test/rustdoc/intra-doc/prim-self.rs", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-self.rs?ref=e1b943991f33702ee4cf2e7c6dfcc29c60ab89da", "patch": "@@ -1,13 +1,15 @@\n #![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(incomplete_features)] // inherent_associated_types\n #![feature(lang_items)]\n #![feature(no_core)]\n #![feature(rustdoc_internals)]\n+#![feature(inherent_associated_types)]\n #![no_core]\n \n #[lang = \"usize\"]\n /// [Self::f]\n /// [Self::MAX]\n-// @has intra_link_prim_self/primitive.usize.html\n+// @has prim_self/primitive.usize.html\n // @has - '//a[@href=\"primitive.usize.html#method.f\"]' 'Self::f'\n // @has - '//a[@href=\"primitive.usize.html#associatedconstant.MAX\"]' 'Self::MAX'\n impl usize {\n@@ -17,10 +19,9 @@ impl usize {\n     /// 10 and 2^32 are basically the same.\n     pub const MAX: usize = 10;\n \n-    // FIXME(#8995) uncomment this when associated types in inherent impls are supported\n-    // @ has - '//a[@href=\"{{channel}}/std/primitive.usize.html#associatedtype.ME\"]' 'Self::ME'\n-    // / [Self::ME]\n-    //pub type ME = usize;\n+    // @has - '//a[@href=\"primitive.usize.html#associatedtype.ME\"]' 'Self::ME'\n+    /// [Self::ME]\n+    pub type ME = usize;\n }\n \n #[doc(primitive = \"usize\")]", "previous_filename": "src/test/rustdoc/intra-link-prim-self.rs"}, {"sha": "63bf7fa5768a718992c85318e13a0dc197481b75", "filename": "src/test/rustdoc/intra-doc/self-cache.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da/src%2Ftest%2Frustdoc%2Fintra-doc%2Fself-cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b943991f33702ee4cf2e7c6dfcc29c60ab89da/src%2Ftest%2Frustdoc%2Fintra-doc%2Fself-cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fself-cache.rs?ref=e1b943991f33702ee4cf2e7c6dfcc29c60ab89da", "previous_filename": "src/test/rustdoc/intra-link-self-cache.rs"}]}