{"sha": "79ef13592e617e58b84146ba568c43bad81e77bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZWYxMzU5MmU2MTdlNThiODQxNDZiYTU2OGM0M2JhZDgxZTc3YmY=", "commit": {"author": {"name": "R.Chavignat", "email": "r.chavignat@gmail.com", "date": "2015-08-22T21:49:03Z"}, "committer": {"name": "R.Chavignat", "email": "r.chavignat@gmail.com", "date": "2015-08-22T21:49:03Z"}, "message": "Completed the implementation of *size handling.\n\nAdded some more cases to the test, and implemented a new lint,\ncast_possible_wrap, triggered when casting from an unsigned type to a\nsigned type of the same size.", "tree": {"sha": "db9320eb280416f57ae36f764adf7931b57b4a30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db9320eb280416f57ae36f764adf7931b57b4a30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79ef13592e617e58b84146ba568c43bad81e77bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79ef13592e617e58b84146ba568c43bad81e77bf", "html_url": "https://github.com/rust-lang/rust/commit/79ef13592e617e58b84146ba568c43bad81e77bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79ef13592e617e58b84146ba568c43bad81e77bf/comments", "author": {"login": "Robzz", "id": 304428, "node_id": "MDQ6VXNlcjMwNDQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/304428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Robzz", "html_url": "https://github.com/Robzz", "followers_url": "https://api.github.com/users/Robzz/followers", "following_url": "https://api.github.com/users/Robzz/following{/other_user}", "gists_url": "https://api.github.com/users/Robzz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Robzz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Robzz/subscriptions", "organizations_url": "https://api.github.com/users/Robzz/orgs", "repos_url": "https://api.github.com/users/Robzz/repos", "events_url": "https://api.github.com/users/Robzz/events{/privacy}", "received_events_url": "https://api.github.com/users/Robzz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Robzz", "id": 304428, "node_id": "MDQ6VXNlcjMwNDQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/304428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Robzz", "html_url": "https://github.com/Robzz", "followers_url": "https://api.github.com/users/Robzz/followers", "following_url": "https://api.github.com/users/Robzz/following{/other_user}", "gists_url": "https://api.github.com/users/Robzz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Robzz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Robzz/subscriptions", "organizations_url": "https://api.github.com/users/Robzz/orgs", "repos_url": "https://api.github.com/users/Robzz/repos", "events_url": "https://api.github.com/users/Robzz/events{/privacy}", "received_events_url": "https://api.github.com/users/Robzz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "807dab943bc35b8f579cc082f385bdd5a6a98c63", "url": "https://api.github.com/repos/rust-lang/rust/commits/807dab943bc35b8f579cc082f385bdd5a6a98c63", "html_url": "https://github.com/rust-lang/rust/commit/807dab943bc35b8f579cc082f385bdd5a6a98c63"}], "stats": {"total": 96, "additions": 75, "deletions": 21}, "files": [{"sha": "7ac5388e0fe5c8097d1bd03989c3c19275c29e84", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79ef13592e617e58b84146ba568c43bad81e77bf/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/79ef13592e617e58b84146ba568c43bad81e77bf/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=79ef13592e617e58b84146ba568c43bad81e77bf", "patch": "@@ -12,6 +12,7 @@ approx_constant          | warn    | the approximate of a known float constant (\n bad_bit_mask             | deny    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n box_vec                  | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n cast_possible_truncation | allow   | casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n+cast_possible_wrap       | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n cast_precision_loss      | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`\n cast_sign_loss           | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n cmp_nan                  | deny    | comparisons to NAN (which will always return false, which is probably not intended)"}, {"sha": "19a62dd214bc5638e5865ca826563efe27229802", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79ef13592e617e58b84146ba568c43bad81e77bf/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79ef13592e617e58b84146ba568c43bad81e77bf/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=79ef13592e617e58b84146ba568c43bad81e77bf", "patch": "@@ -107,6 +107,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         strings::STRING_ADD_ASSIGN,\n         types::BOX_VEC,\n         types::CAST_POSSIBLE_TRUNCATION,\n+        types::CAST_POSSIBLE_WRAP,\n         types::CAST_PRECISION_LOSS,\n         types::CAST_SIGN_LOSS,\n         types::LET_UNIT_VALUE,"}, {"sha": "579527cfff44f12a420c534f26330e12222a5ce0", "filename": "src/types.rs", "status": "modified", "additions": 66, "deletions": 20, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/79ef13592e617e58b84146ba568c43bad81e77bf/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79ef13592e617e58b84146ba568c43bad81e77bf/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=79ef13592e617e58b84146ba568c43bad81e77bf", "patch": "@@ -145,6 +145,8 @@ declare_lint!(pub CAST_SIGN_LOSS, Allow,\n               \"casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\");\n declare_lint!(pub CAST_POSSIBLE_TRUNCATION, Allow,\n               \"casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\");\n+declare_lint!(pub CAST_POSSIBLE_WRAP, Allow,\n+              \"casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\");\n \n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n@@ -169,7 +171,8 @@ impl LintPass for CastPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(CAST_PRECISION_LOSS,\n                     CAST_SIGN_LOSS,\n-                    CAST_POSSIBLE_TRUNCATION)\n+                    CAST_POSSIBLE_TRUNCATION,\n+                    CAST_POSSIBLE_WRAP)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n@@ -186,50 +189,93 @@ impl LintPass for CastPass {\n                         };\n                         if from_nbits != 0 {\n                             // When casting to f32, precision loss would occur regardless of the arch\n-                            if is_isize_or_usize(cast_from) && to_nbits == 64 {\n-                                span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n-                                          &format!(\"converting from {0} to f64, which causes a loss of precision on 64-bit architectures \\\n-                                          \t\t\t({0} is 64 bits wide, but f64's mantissa is only 52 bits wide)\",\n-                                                   cast_from));\n+                            if is_isize_or_usize(cast_from) {\n+                                if to_nbits == 64 {\n+                                    span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n+                                              &format!(\"casting {0} to f64 causes a loss of precision on targets with 64-bit wide pointers \\\n+                                        \t  \t\t\t({0} is 64 bits wide, but f64's mantissa is only 52 bits wide)\",\n+                                                       cast_from));\n+                                }\n+                                else {\n+                                    span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n+                                              &format!(\"casting {0} to f32 causes a loss of precision \\\n+                                        \t  \t\t\t({0} is 32 or 64 bits wide, but f32's mantissa is only 23 bits wide)\",\n+                                                       cast_from));\n+                                }\n                             }\n                             else if from_nbits >= to_nbits {\n                                 span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n-                                          &format!(\"converting from {0} to {1}, which causes a loss of precision \\\n+                                          &format!(\"casting {0} to {1} causes a loss of precision \\\n                                           \t\t\t({0} is {2} bits wide, but {1}'s mantissa is only {3} bits wide)\",\n                                                    cast_from, cast_to, from_nbits, if to_nbits == 64 {52} else {23} ));\n                             }\n                         }\n                     },\n-                    (false, true) => { // Nothing to add there\n+                    (false, true) => {\n+                        // Nothing to add there as long as UB in involved when the cast overflows\n                         span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                                  &format!(\"casting {} to {} may cause truncation of the value\", cast_from, cast_to));\n+                                  &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to));\n                         if !cast_to.is_signed() {\n                             span_lint(cx, CAST_SIGN_LOSS, expr.span,\n-                                      &format!(\"casting from {} to {} loses the sign of the value\", cast_from, cast_to));\n+                                      &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n                         }\n                     },\n                     (true, true) => {\n+                        let from_nbits = int_ty_to_nbits(cast_from);\n+                        let to_nbits   = int_ty_to_nbits(cast_to);\n                         if cast_from.is_signed() && !cast_to.is_signed() {\n                             span_lint(cx, CAST_SIGN_LOSS, expr.span,\n-                                      &format!(\"casting from {} to {} loses the sign of the value\", cast_from, cast_to));\n+                                      &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n                         }\n-                        let from_nbits = int_ty_to_nbits(cast_from);\n-                        let to_nbits   = int_ty_to_nbits(cast_to);\n                         match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n                             (true, true) | (false, false) =>\n-                                if to_nbits < from_nbits ||\n-                                   (!cast_from.is_signed() && cast_to.is_signed() && to_nbits <= from_nbits) {\n-                                        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                                                  &format!(\"casting {} to {} may cause truncation of the value\", cast_from, cast_to));\n+                                if to_nbits < from_nbits {\n+                                    span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+                                              &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to));\n+                                }\n+                                else if !cast_from.is_signed() && cast_to.is_signed() && to_nbits == from_nbits {\n+                                    span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n+                                              &format!(\"casting {} to {} may wrap around the value\", cast_from, cast_to));\n+                                },\n+                            (true, false) =>\n+                                if to_nbits == 32 {\n+                                    span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+                                              &format!(\"casting {} to {} may truncate the value on targets with 64-bit wide pointers\",\n+                                                       cast_from, cast_to));\n+                                    if !cast_from.is_signed() && cast_to.is_signed() {\n+                                        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n+                                                  &format!(\"casting {} to {} may wrap around the value on targets with 32-bit wide pointers\",\n+                                                           cast_from, cast_to));\n+                                    }\n+                                }\n+                                else if to_nbits < 32 {\n+                                    span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+                                              &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to));\n                                 },\n-                            (true, false) => (), // TODO\n-                            (false, true) => ()  // TODO\n+                            (false, true) =>\n+                                if from_nbits == 64 {\n+                                    span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+                                              &format!(\"casting {} to {} may truncate the value on targets with 32-bit wide pointers\",\n+                                                       cast_from, cast_to));\n+                                    if !cast_from.is_signed() && cast_to.is_signed() {\n+                                        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n+                                                  &format!(\"casting {} to {} may wrap around the value on targets with 64-bit wide pointers\",\n+                                                           cast_from, cast_to));\n+                                    }\n+                                }\n+                                else {\n+                                    if !cast_from.is_signed() && cast_to.is_signed() {\n+                                        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n+                                                  &format!(\"casting {} to {} may wrap around the value on targets with 32-bit wide pointers\",\n+                                                           cast_from, cast_to));\n+                                    }\n+                                }\n                         }\n                     }\n                     (false, false) => {\n                         if let (&ty::TyFloat(ast::TyF64),\n                                 &ty::TyFloat(ast::TyF32)) = (&cast_from.sty, &cast_to.sty) {\n-                            span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span, \"casting f64 to f32 may cause truncation of the value\");\n+                            span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span, \"casting f64 to f32 may truncate the value\");\n                         }\n                     }\n                 }"}, {"sha": "b17f5de841b409dba142a8257e253202dac43754", "filename": "tests/compile-fail/cast.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79ef13592e617e58b84146ba568c43bad81e77bf/tests%2Fcompile-fail%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79ef13592e617e58b84146ba568c43bad81e77bf/tests%2Fcompile-fail%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast.rs?ref=79ef13592e617e58b84146ba568c43bad81e77bf", "patch": "@@ -45,13 +45,19 @@ fn main() {\n     1usize as f32; //~ERROR casting usize to f32 causes a loss of precision (usize is 32 or 64 bits wide, but f32's mantissa is only 23 bits wide)\n     1isize as i32; //~ERROR casting isize to i32 may truncate the value on targets with 64-bit wide pointers\n     1isize as u32; //~ERROR casting isize to u32 may lose the sign of the value\n-                  //~^ERROR casting isize to u32 may truncate the value on targets with 64-bit wide pointers        \n+                  //~^ERROR casting isize to u32 may truncate the value on targets with 64-bit wide pointers       \n     1usize as u32; //~ERROR casting usize to u32 may truncate the value on targets with 64-bit wide pointers\n+    1usize as i32; //~ERROR casting usize to i32 may truncate the value on targets with 64-bit wide pointers\n+                  //~^ERROR casting usize to i32 may wrap around the value on targets with 32-bit wide pointers\n     // Casting to *size\n     1i64 as isize; //~ERROR casting i64 to isize may truncate the value on targets with 32-bit wide pointers\n     1i64 as usize; //~ERROR casting i64 to usize may truncate the value on targets with 32-bit wide pointers\n                   //~^ERROR casting i64 to usize may lose the sign of the value\n     1u64 as isize; //~ERROR casting u64 to isize may truncate the value on targets with 32-bit wide pointers\n                   //~^ERROR casting u64 to isize may wrap around the value on targets with 64-bit wide pointers\n     1u64 as usize; //~ERROR casting u64 to usize may truncate the value on targets with 32-bit wide pointers\n+    1u32 as isize; //~ERROR casting u32 to isize may wrap around the value on targets with 32-bit wide pointers\n+    1u32 as usize; // Should not trigger any lint\n+    1i32 as isize; // Neither should this\n+    1i32 as usize; //~ERROR casting i32 to usize may lose the sign of the value\n }\n\\ No newline at end of file"}]}