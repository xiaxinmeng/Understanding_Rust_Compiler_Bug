{"sha": "6121d82d476c43b533a24e3ec697d681199df497", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMjFkODJkNDc2YzQzYjUzM2EyNGUzZWM2OTdkNjgxMTk5ZGY0OTc=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-07-25T23:48:05Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-07-30T13:36:32Z"}, "message": "Guide: testing", "tree": {"sha": "85effc1a2722f569a7633f1eb7689f7c6caadbf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85effc1a2722f569a7633f1eb7689f7c6caadbf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6121d82d476c43b533a24e3ec697d681199df497", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6121d82d476c43b533a24e3ec697d681199df497", "html_url": "https://github.com/rust-lang/rust/commit/6121d82d476c43b533a24e3ec697d681199df497", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6121d82d476c43b533a24e3ec697d681199df497/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "692077b6431460b96beb0ccf4f38299618d51db2", "url": "https://api.github.com/repos/rust-lang/rust/commits/692077b6431460b96beb0ccf4f38299618d51db2", "html_url": "https://github.com/rust-lang/rust/commit/692077b6431460b96beb0ccf4f38299618d51db2"}], "stats": {"total": 575, "additions": 574, "deletions": 1}, "files": [{"sha": "2ee926d08a1cb5bdafd2b4b2d88ef8827e9b9c1c", "filename": "src/doc/guide.md", "status": "modified", "additions": 574, "deletions": 1, "changes": 575, "blob_url": "https://github.com/rust-lang/rust/blob/6121d82d476c43b533a24e3ec697d681199df497/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/6121d82d476c43b533a24e3ec697d681199df497/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=6121d82d476c43b533a24e3ec697d681199df497", "patch": "@@ -2808,9 +2808,582 @@ By just bringing the module into scope, we can keep one level of namespacing.\n \n # Testing\n \n+Traditionally, testing has not been a strong suit of most systems programming\n+languages. Rust, however, has very basic testing built into the language\n+itself.  While automated testing cannot prove that your code is bug-free, it is\n+useful for verifying that certain behaviors work as intended.\n+\n+Here's a very basic test:\n+\n+```{rust}\n+#[test]\n+fn is_one_equal_to_one() {\n+    assert_eq!(1i, 1i);\n+}\n+```\n+\n+You may notice something new: that `#[test]`. Before we get into the mechanics\n+of testing, let's talk about attributes.\n+\n ## Attributes\n \n-## Stability Markers\n+Rust's testing system uses **attribute**s to mark which functions are tests.\n+Attributes can be placed on any Rust **item**. Remember how most things in\n+Rust are an expression, but `let` is not? Item declarations are also not\n+expressions. Here's a list of things that qualify as an item:\n+\n+* functions\n+* modules\n+* type definitions\n+* structures\n+* enumerations\n+* static items\n+* traits\n+* implementations\n+\n+You haven't learned about all of these things yet, but that's the list. As\n+you can see, functions are at the top of it.\n+\n+Attributes can appear in three ways:\n+\n+1. A single identifier, the attribute name. `#[test]` is an example of this.\n+2. An identifier followed by an equals sign (`=`) and a literal. `#[cfg=test]`\n+   is an example of this.\n+3. An identifier followed by a parenthesized list of sub-attribute arguments.\n+   `#[cfg(unix, target_word_size = \"32\")]` is an example of this, where one of\n+    the sub-arguments is of the second kind.\n+\n+There are a number of different kinds of attributes, enough that we won't go\n+over them all here. Before we talk about the testing-specific attributes, I\n+want to call out one of the most important kinds of attributes: stability\n+markers.\n+\n+## Stability attributes\n+\n+Rust provides six attributes to indicate the stability level of various\n+parts of your library. The six levels are:\n+\n+* deprecated: this item should no longer be used. No guarantee of backwards\n+  compatibility.\n+* experimental: This item was only recently introduced or is otherwise in a\n+  state of flux. It may change significantly, or even be removed. No guarantee\n+  of backwards-compatibility.\n+* unstable: This item is still under development, but requires more testing to\n+  be considered stable. No guarantee of backwards-compatibility.\n+* stable: This item is considered stable, and will not change significantly.\n+  Guarantee of backwards-compatibility.\n+* frozen: This item is very stable, and is unlikely to change. Guarantee of\n+  backwards-compatibility.\n+* locked: This item will never change unless a serious bug is found. Guarantee\n+  of backwards-compatibility.\n+\n+All of Rust's standard library uses these attribute markers to communicate\n+their relative stability, and you should use them in your code, as well.\n+There's an associated attribute, `warn`, that allows you to warn when you\n+import an item marked with certain levels: deprecated, experimental and\n+unstable. For now, only deprecated warns by default, but this will change once\n+the standard library has been stabilized.\n+\n+You can use the `warn` attribute like this:\n+\n+```{rust,ignore}\n+#![warn(unstable)]\n+```\n+\n+And later, when you import a crate:\n+\n+```{rust,ignore}\n+extern crate some_crate;\n+```\n+\n+You'll get a warning if you use something marked unstable.\n+\n+You may have noticed an exclamation point in the `warn` attribute declaration.\n+The `!` in this attribute means that this attribute applies to the enclosing\n+item, rather than to the item that follows the attribute. So this `warn`\n+attribute declaration applies to the enclosing crate itself, rather than\n+to whatever item statement follows it:\n+\n+```{rust,ignore}\n+// applies to the crate we're in\n+#![warn(unstable)]\n+\n+extern crate some_crate;\n+\n+// applies to the following `fn`.\n+#[test]\n+fn a_test() {\n+  // ...\n+}\n+```\n+\n+## Writing tests\n+\n+Let's write a very simple crate in a test-driven manner. You know the drill by\n+now: make a new project:\n+\n+```{bash,ignore}\n+$ cd ~/projects\n+$ mkdir testing\n+$ cd testing\n+$ mkdir test\n+```\n+\n+In `src/main.rs`:\n+\n+```{rust}\n+fn main() {\n+    println!(\"Hello, world!\");\n+}\n+```\n+\n+And in `Cargo.toml`:\n+\n+```{notrust,ignore}\n+[package]\n+\n+name = \"testing\"\n+version = \"0.1.0\"\n+authors = [ \"someone@example.com\" ]\n+```\n+\n+And try it out:\n+\n+```{notrust,ignore}\n+$ cargo run\n+   Compiling testing v0.1.0 (file:/home/you/projects/testing)\n+Hello, world!\n+$\n+```\n+\n+Great. Rust's infrastructure supports tests in two sorts of places, and they're\n+for two kinds of tests: you include **unit test**s inside of the crate itself,\n+and you place **integration test**s inside a `tests` directory. \"Unit tests\"\n+are small tests that test one focused unit, \"integration tests\" tests multiple\n+units in integration. That said, this is a social convention, they're no different\n+in syntax. Let's make a `tests` directory:\n+\n+```{bash,ignore}\n+$ mkdir tests\n+```\n+\n+Next, let's create an integration test in `tests/lib.rs`:\n+\n+```{rust,no_run}\n+#[test]\n+fn foo() {\n+    assert!(false);\n+}\n+```\n+\n+It doesn't matter what you name your test functions, though it's nice if\n+you give them descriptive names. You'll see why in a moment. We then use a\n+macro, `assert!`, to assert that something is true. In this case, we're giving\n+it `false`, so this test should fail. Let's try it!\n+\n+```{notrust,ignore}\n+$ cargo test\n+   Compiling testing v0.1.0 (file:/home/you/projects/testing)\n+/home/you/projects/testing/src/main.rs:1:1: 3:2 warning: code is never used: `main`, #[warn(dead_code)] on by default\n+/home/you/projects/testing/src/main.rs:1 fn main() {\n+/home/you/projects/testing/src/main.rs:2     println!(\"Hello, world\");\n+/home/you/projects/testing/src/main.rs:3 }\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+\n+\n+running 1 test\n+test foo ... FAILED\n+\n+failures:\n+\n+---- foo stdout ----\n+        task 'foo' failed at 'assertion failed: false', /home/you/projects/testing/tests/lib.rs:3\n+\n+\n+\n+failures:\n+    foo\n+\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n+\n+task '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:242\n+```\n+\n+Lots of output! Let's break this down:\n+\n+```{notrust,ignore}\n+$ cargo test\n+   Compiling testing v0.1.0 (file:/home/you/projects/testing)\n+```\n+\n+You can run all of your tests with `cargo test`. This runs both your tests in\n+`tests`, as well as the tests you put inside of your crate.\n+\n+```{notrust,ignore}\n+/home/you/projects/testing/src/main.rs:1:1: 3:2 warning: code is never used: `main`, #[warn(dead_code)] on by default\n+/home/you/projects/testing/src/main.rs:1 fn main() {\n+/home/you/projects/testing/src/main.rs:2     println!(\"Hello, world\");\n+/home/you/projects/testing/src/main.rs:3 }\n+```\n+\n+Rust has a **lint** called 'warn on dead code' used by default. A lint is a\n+bit of code that checks your code, and can tell you things about it. In this\n+case, Rust is warning us that we've written some code that's never used: our\n+`main` function. Of course, since we're running tests, we don't use `main`.\n+We'll turn this lint off for just this function soon. For now, just ignore this\n+output.\n+\n+```{notrust,ignore}\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+```\n+\n+Wait a minute, zero tests? Didn't we define one? Yup. This output is from\n+attempting to run the tests in our crate, of which we don't have any.\n+You'll note that Rust reports on several kinds of tests: passed, failed,\n+ignored, and measured. The 'measured' tests refer to benchmark tests, which\n+we'll cover soon enough!\n+\n+```{notrust,ignore}\n+running 1 test\n+test foo ... FAILED\n+```\n+\n+Now we're getting somewhere. Remember when we talked about naming our tests\n+with good names? This is why. Here, it says 'test foo' because we called our\n+test 'foo.' If we had given it a good name, it'd be more clear which test\n+failed, especially as we accumulate more tests.\n+\n+```{notrust,ignore}\n+failures:\n+\n+---- foo stdout ----\n+        task 'foo' failed at 'assertion failed: false', /home/you/projects/testing/tests/lib.rs:3\n+\n+\n+\n+failures:\n+    foo\n+\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n+\n+task '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:242\n+```\n+\n+After all the tests run, Rust will show us any output from our failed tests.\n+In this instance, Rust tells us that our assertion failed, with false. This was\n+what we expected.\n+\n+Whew! Let's fix our test:\n+\n+```{rust}\n+#[test]\n+fn foo() {\n+    assert!(true);\n+}\n+```\n+\n+And then try to run our tests again:\n+\n+```{notrust,ignore}\n+$ cargo test\n+   Compiling testing v0.1.0 (file:/home/you/projects/testing)\n+/home/you/projects/testing/src/main.rs:1:1: 3:2 warning: code is never used: `main`, #[warn(dead_code)] on by default\n+/home/you/projects/testing/src/main.rs:1 fn main() {\n+/home/you/projects/testing/src/main.rs:2     println!(\"Hello, world\");\n+/home/you/projects/testing/src/main.rs:3 }\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+\n+\n+running 1 test\n+test foo ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+$\n+```\n+\n+Nice! Our test passes, as we expected. Let's get rid of that warning for our `main`\n+function. Change your `src/main.rs` to look like this:\n+\n+```{rust}\n+#[cfg(not(test))]\n+fn main() {\n+    println!(\"Hello, world\");\n+}\n+```\n+\n+This attribute combines two things: `cfg` and `not`. The `cfg` attribute allows\n+you to conditionally compile code based on something. The following item will\n+only be compiled if the configuration says it's true. And when Cargo compiles\n+our tests, it sets things up so that `cfg(test)` is true. But we want to only\n+include `main` when it's _not_ true. So we use `not` to negate things:\n+`cfg(not(test))` will only compile our code when the `cfg(test)` is false.\n+\n+With this attribute, we won't get the warning:\n+\n+```{notrust,ignore}\n+$ cargo test\n+   Compiling testing v0.1.0 (file:/home/you/projects/testing)\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+\n+\n+running 1 test\n+test foo ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+```\n+\n+Nice. Okay, let's write a real test now. Change your `tests/lib.rs`\n+to look like this:\n+\n+```{rust,ignore}\n+#[test]\n+fn math_checks_out() {\n+    let result = add_three_times_four(5i);\n+\n+    assert_eq!(32i, result);\n+}\n+```\n+\n+And try to run the test:\n+\n+```{notrust,ignore}\n+$ cargo test\n+   Compiling testing v0.1.0 (file:/home/youg/projects/testing)\n+/home/youg/projects/testing/tests/lib.rs:3:18: 3:38 error: unresolved name `add_three_times_four`.\n+/home/youg/projects/testing/tests/lib.rs:3     let result = add_three_times_four(5i);\n+                                                            ^~~~~~~~~~~~~~~~~~~~\n+error: aborting due to previous error\n+Build failed, waiting for other jobs to finish...\n+Could not compile `testing`.\n+\n+To learn more, run the command again with --verbose.\n+```\n+\n+Rust can't find this function. That makes sense, as we didn't write it yet!\n+\n+In order to share this codes with our tests, we'll need to make a library crate.\n+This is also just good software design: as we mentioned before, it's a good idea\n+to put most of your functionality into a library crate, and have your executable\n+crate use that library. This allows for code re-use.\n+\n+To do that, we'll need to make a new module. Make a new file, `src/lib.rs`,\n+and put this in it:\n+\n+```{rust}\n+fn add_three_times_four(x: int) -> int {\n+    (x + 3) * 4\n+}\n+```\n+\n+We're calling this file `lib.rs` because it has the same name as our project,\n+and so it's named this, by convention.\n+\n+We'll then need to use this crate in our `src/main.rs`:\n+\n+```{rust,ignore}\n+extern crate testing;\n+\n+#[cfg(not(test))]\n+fn main() {\n+    println!(\"Hello, world\");\n+}\n+```\n+\n+Finally, let's import this function in our `tests/lib.rs`:\n+\n+```{rust,ignore}\n+extern crate testing;\n+use testing::add_three_times_four;\n+\n+#[test]\n+fn math_checks_out() {\n+    let result = add_three_times_four(5i);\n+\n+    assert_eq!(32i, result);\n+}\n+```\n+\n+Let's give it a run:\n+\n+```{ignore,notrust}\n+$ cargo test\n+   Compiling testing v0.1.0 (file:/home/you/projects/testing)\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+\n+\n+running 1 test\n+test math_checks_out ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+```\n+\n+Great! One test passed. We've got an integration test showing that our public\n+method works, but maybe we want to test some of the internal logic as well.\n+While this function is simple, if it were more complicated, you can imagine\n+we'd need more tests. So let's break it up into two helper functions, and\n+write some unit tests to test those.\n+\n+Change your `src/lib.rs` to look like this:\n+\n+```{rust,ignore}\n+pub fn add_three_times_four(x: int) -> int {\n+    times_four(add_three(x))\n+}\n+\n+fn add_three(x: int) -> int { x + 3 }\n+\n+fn times_four(x: int) -> int { x * 4 }\n+```\n+\n+If you run `cargo test`, you should get the same output:\n+\n+```{ignore,notrust}\n+$ cargo test\n+   Compiling testing v0.1.0 (file:/home/you/projects/testing)\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+\n+\n+running 1 test\n+test math_checks_out ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+```\n+\n+If we tried to write a test for these two new functions, it wouldn't\n+work. For example:\n+\n+```{rust,ignore}\n+extern crate testing;\n+use testing::add_three_times_four;\n+use testing::add_three;\n+\n+#[test]\n+fn math_checks_out() {\n+    let result = add_three_times_four(5i);\n+\n+    assert_eq!(32i, result);\n+}\n+\n+#[test]\n+fn test_add_three() {\n+    let result = add_three(5i);\n+\n+    assert_eq!(8i, result);\n+}\n+```\n+\n+We'd get this error:\n+\n+```{notrust,ignore}\n+   Compiling testing v0.1.0 (file:/home/you/projects/testing)\n+/home/you/projects/testing/tests/lib.rs:3:5: 3:24 error: function `add_three` is private\n+/home/you/projects/testing/tests/lib.rs:3 use testing::add_three;\n+                                              ^~~~~~~~~~~~~~~~~~~\n+```\n+\n+Right. It's private. So external, integration tests won't work. We need a\n+unit test. Open up your `src/lib.rs` and add this:\n+\n+```{rust,ignore}\n+pub fn add_three_times_four(x: int) -> int {\n+    times_four(add_three(x))\n+}\n+\n+fn add_three(x: int) -> int { x + 3 }\n+\n+fn times_four(x: int) -> int { x * 4 }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::add_three;\n+    use super::add_four;\n+\n+    #[test]\n+    fn test_add_three() {\n+        let result = add_three(5i);\n+\n+        assert_eq!(8i, result);\n+    }\n+\n+    #[test]\n+    fn test_times_four() {\n+        let result = times_four(5i);\n+\n+        assert_eq!(20i, result);\n+    }\n+}\n+```\n+\n+Let's give it a shot:\n+\n+```{ignore,notrust}\n+$ cargo test\n+   Compiling testing v0.1.0 (file:/home/you/projects/testing)\n+\n+running 1 test\n+test test::test_times_four ... ok\n+test test::test_add_three ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+\n+\n+running 1 test\n+test math_checks_out ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+```\n+\n+Cool! We now have two tests of our internal functions. You'll note that there\n+are three sets of output now: one for `src/main.rs`, one for `src/lib.rs`, and\n+one for `tests/lib.rs`. There's one interesting thing that we haven't talked\n+about yet, and that's these lines:\n+\n+```{rust,ignore}\n+use super::add_three;\n+use super::add_four;\n+```\n+\n+Because we've made a nested module, we can import functions from the parent\n+module by using `super`. Sub-modules are allowed to 'see' private functions in\n+the parent. We sometimes call this usage of `use` a 're-export,' because we're\n+exporting the name again, somewhere else.\n+\n+We've now covered the basics of testing. Rust's tools are primitive, but they\n+work well in the simple cases. There are some Rustaceans working on building\n+more complicated frameworks on top of all of this, but thery're just starting\n+out.\n \n # Pointers\n "}]}