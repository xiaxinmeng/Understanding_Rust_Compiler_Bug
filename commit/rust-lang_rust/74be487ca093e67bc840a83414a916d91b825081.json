{"sha": "74be487ca093e67bc840a83414a916d91b825081", "node_id": "C_kwDOAAsO6NoAKDc0YmU0ODdjYTA5M2U2N2JjODQwYTgzNDE0YTkxNmQ5MWI4MjUwODE", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-07-25T22:14:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-25T22:14:48Z"}, "message": "Rollup merge of #99178 - Dajamante:clean_up, r=oli-obk\n\nLighten up const_prop_lint, reusing const_prop\n\nr? `@oli-obk`", "tree": {"sha": "0bdabbd6b62dac40e8ee22da6f2517c3fc7e41f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bdabbd6b62dac40e8ee22da6f2517c3fc7e41f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74be487ca093e67bc840a83414a916d91b825081", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi3xXYCRBK7hj4Ov3rIwAAiqQIAAm3SiViJuqZ7A0gCAfFVRHP\n9hDR2L+cY5pyfD3Tb02YXl937Dhz2pKZX4pOtfVkGXe2kQu6+N8uw6jGJMHXs2hi\nWNm2HKZP/ou8siZyYWGWwadKdmJGEc9gdPxMFFEh7PEPxoZg8Qt3xIev0ux7/VC7\ncoTzLGyTVns5l43iCWuhLb4Azr2PMs6CkVEydV8rtixhZnxmZ47Gry49Eq0AP8MO\njuzUaOtVUVqLhKWTZLDRJ4TkpQAawyHQsqVNLRFxve4of7C1LANtUtvT7VgLwzIn\nlE//3wJhxpX+yGM4AONdeTAmcv+v3OmRR3OL+GEnHOFsHvIpnWPG0ZldDUzD4bs=\n=i4KN\n-----END PGP SIGNATURE-----\n", "payload": "tree 0bdabbd6b62dac40e8ee22da6f2517c3fc7e41f0\nparent aeca079d7e91a2ae34b6c5f743689750257c094c\nparent e6518296dcd9e878ac450afdfee4f4bc3fec72f3\nauthor Yuki Okushi <jtitor@2k36.org> 1658787288 +0900\ncommitter GitHub <noreply@github.com> 1658787288 +0900\n\nRollup merge of #99178 - Dajamante:clean_up, r=oli-obk\n\nLighten up const_prop_lint, reusing const_prop\n\nr? `@oli-obk`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74be487ca093e67bc840a83414a916d91b825081", "html_url": "https://github.com/rust-lang/rust/commit/74be487ca093e67bc840a83414a916d91b825081", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74be487ca093e67bc840a83414a916d91b825081/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeca079d7e91a2ae34b6c5f743689750257c094c", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeca079d7e91a2ae34b6c5f743689750257c094c", "html_url": "https://github.com/rust-lang/rust/commit/aeca079d7e91a2ae34b6c5f743689750257c094c"}, {"sha": "e6518296dcd9e878ac450afdfee4f4bc3fec72f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6518296dcd9e878ac450afdfee4f4bc3fec72f3", "html_url": "https://github.com/rust-lang/rust/commit/e6518296dcd9e878ac450afdfee4f4bc3fec72f3"}], "stats": {"total": 367, "additions": 23, "deletions": 344}, "files": [{"sha": "85ad6b8f2feff052b70b19c74fb2a3244a1f5226", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74be487ca093e67bc840a83414a916d91b825081/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74be487ca093e67bc840a83414a916d91b825081/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=74be487ca093e67bc840a83414a916d91b825081", "patch": "@@ -155,18 +155,18 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n     }\n }\n \n-struct ConstPropMachine<'mir, 'tcx> {\n+pub struct ConstPropMachine<'mir, 'tcx> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx>>,\n     /// `OnlyInsideOwnBlock` locals that were written in the current block get erased at the end.\n-    written_only_inside_own_block_locals: FxHashSet<Local>,\n+    pub written_only_inside_own_block_locals: FxHashSet<Local>,\n     /// Locals that need to be cleared after every block terminates.\n-    only_propagate_inside_block_locals: BitSet<Local>,\n-    can_const_prop: IndexVec<Local, ConstPropMode>,\n+    pub only_propagate_inside_block_locals: BitSet<Local>,\n+    pub can_const_prop: IndexVec<Local, ConstPropMode>,\n }\n \n impl ConstPropMachine<'_, '_> {\n-    fn new(\n+    pub fn new(\n         only_propagate_inside_block_locals: BitSet<Local>,\n         can_const_prop: IndexVec<Local, ConstPropMode>,\n     ) -> Self {\n@@ -816,7 +816,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n /// The mode that `ConstProp` is allowed to run in for a given `Local`.\n #[derive(Clone, Copy, Debug, PartialEq)]\n-enum ConstPropMode {\n+pub enum ConstPropMode {\n     /// The `Local` can be propagated into and reads of this `Local` can also be propagated.\n     FullConstProp,\n     /// The `Local` can only be propagated into and from its own block.\n@@ -828,7 +828,7 @@ enum ConstPropMode {\n     NoPropagation,\n }\n \n-struct CanConstProp {\n+pub struct CanConstProp {\n     can_const_prop: IndexVec<Local, ConstPropMode>,\n     // False at the beginning. Once set, no more assignments are allowed to that local.\n     found_assignment: BitSet<Local>,\n@@ -838,7 +838,7 @@ struct CanConstProp {\n \n impl CanConstProp {\n     /// Returns true if `local` can be propagated\n-    fn check<'tcx>(\n+    pub fn check<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,\n         body: &Body<'tcx>,"}, {"sha": "3ae6a88a140ead840ecbe322b11078fa74ad0202", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 15, "deletions": 336, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/74be487ca093e67bc840a83414a916d91b825081/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74be487ca093e67bc840a83414a916d91b825081/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=74be487ca093e67bc840a83414a916d91b825081", "patch": "@@ -1,19 +1,24 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use std::cell::Cell;\n-\n-use rustc_ast::Mutability;\n-use rustc_data_structures::fx::FxHashSet;\n+use crate::const_prop::CanConstProp;\n+use crate::const_prop::ConstPropMachine;\n+use crate::const_prop::ConstPropMode;\n+use crate::MirLint;\n+use rustc_const_eval::const_eval::ConstEvalErr;\n+use rustc_const_eval::interpret::{\n+    self, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, Scalar,\n+    ScalarMaybeUninit, StackPopCleanup,\n+};\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n+use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{\n-    AssertKind, BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind,\n-    Location, Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement,\n-    StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n+    AssertKind, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, Location, Operand, Place,\n+    Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator,\n+    TerminatorKind, UnOp, RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -22,42 +27,15 @@ use rustc_middle::ty::{\n     TypeVisitable,\n };\n use rustc_session::lint;\n-use rustc_span::{def_id::DefId, Span};\n+use rustc_span::Span;\n use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n-use rustc_target::spec::abi::Abi as CallAbi;\n use rustc_trait_selection::traits;\n-\n-use crate::MirLint;\n-use rustc_const_eval::const_eval::ConstEvalErr;\n-use rustc_const_eval::interpret::{\n-    self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    LocalState, LocalValue, MemoryKind, OpTy, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n-    StackPopCleanup, StackPopUnwind,\n-};\n+use std::cell::Cell;\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n /// Needed for #66397, because otherwise we eval into large places and that can cause OOM or just\n /// Severely regress performance.\n const MAX_ALLOC_LIMIT: u64 = 1024;\n-\n-/// Macro for machine-specific `InterpError` without allocation.\n-/// (These will never be shown to the user, but they help diagnose ICEs.)\n-macro_rules! throw_machine_stop_str {\n-    ($($tt:tt)*) => {{\n-        // We make a new local type for it. The type itself does not carry any information,\n-        // but its vtable (for the `MachineStopType` trait) does.\n-        struct Zst;\n-        // Printing this type shows the desired string.\n-        impl std::fmt::Display for Zst {\n-            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-                write!(f, $($tt)*)\n-            }\n-        }\n-        impl rustc_middle::mir::interpret::MachineStopType for Zst {}\n-        throw_machine_stop!(Zst)\n-    }};\n-}\n-\n pub struct ConstProp;\n \n impl<'tcx> MirLint<'tcx> for ConstProp {\n@@ -151,172 +129,6 @@ impl<'tcx> MirLint<'tcx> for ConstProp {\n     }\n }\n \n-struct ConstPropMachine<'mir, 'tcx> {\n-    /// The virtual call stack.\n-    stack: Vec<Frame<'mir, 'tcx>>,\n-    /// `OnlyInsideOwnBlock` locals that were written in the current block get erased at the end.\n-    written_only_inside_own_block_locals: FxHashSet<Local>,\n-    /// Locals that need to be cleared after every block terminates.\n-    only_propagate_inside_block_locals: BitSet<Local>,\n-    can_const_prop: IndexVec<Local, ConstPropMode>,\n-}\n-\n-impl ConstPropMachine<'_, '_> {\n-    fn new(\n-        only_propagate_inside_block_locals: BitSet<Local>,\n-        can_const_prop: IndexVec<Local, ConstPropMode>,\n-    ) -> Self {\n-        Self {\n-            stack: Vec::new(),\n-            written_only_inside_own_block_locals: Default::default(),\n-            only_propagate_inside_block_locals,\n-            can_const_prop,\n-        }\n-    }\n-}\n-\n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx> {\n-    compile_time_machine!(<'mir, 'tcx>);\n-    const PANIC_ON_ALLOC_FAIL: bool = true; // all allocations are small (see `MAX_ALLOC_LIMIT`)\n-\n-    type MemoryKind = !;\n-\n-    fn load_mir(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        _instance: ty::InstanceDef<'tcx>,\n-    ) -> InterpResult<'tcx, &'tcx Body<'tcx>> {\n-        throw_machine_stop_str!(\"calling functions isn't supported in ConstProp\")\n-    }\n-\n-    fn find_mir_or_eval_fn(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _instance: ty::Instance<'tcx>,\n-        _abi: CallAbi,\n-        _args: &[OpTy<'tcx>],\n-        _destination: &PlaceTy<'tcx>,\n-        _target: Option<BasicBlock>,\n-        _unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx, Option<(&'mir Body<'tcx>, ty::Instance<'tcx>)>> {\n-        Ok(None)\n-    }\n-\n-    fn call_intrinsic(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _instance: ty::Instance<'tcx>,\n-        _args: &[OpTy<'tcx>],\n-        _destination: &PlaceTy<'tcx>,\n-        _target: Option<BasicBlock>,\n-        _unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx> {\n-        throw_machine_stop_str!(\"calling intrinsics isn't supported in ConstProp\")\n-    }\n-\n-    fn assert_panic(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _msg: &rustc_middle::mir::AssertMessage<'tcx>,\n-        _unwind: Option<rustc_middle::mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        bug!(\"panics terminators are not evaluated in ConstProp\")\n-    }\n-\n-    fn binary_ptr_op(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        _bin_op: BinOp,\n-        _left: &ImmTy<'tcx>,\n-        _right: &ImmTy<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        // We can't do this because aliasing of memory can differ between const eval and llvm\n-        throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n-    }\n-\n-    fn access_local<'a>(\n-        frame: &'a Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n-        local: Local,\n-    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::Provenance>> {\n-        let l = &frame.locals[local];\n-\n-        if matches!(\n-            l.value,\n-            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n-        ) {\n-            // For us \"uninit\" means \"we don't know its value, might be initiailized or not\".\n-            // So stop here.\n-            throw_machine_stop_str!(\"tried to access a local with unknown value\")\n-        }\n-\n-        l.access()\n-    }\n-\n-    fn access_local_mut<'a>(\n-        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n-        frame: usize,\n-        local: Local,\n-    ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::Provenance>> {\n-        if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n-            throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n-        }\n-        if frame == 0 && ecx.machine.only_propagate_inside_block_locals.contains(local) {\n-            trace!(\n-                \"mutating local {:?} which is restricted to its block. \\\n-                Will remove it from const-prop after block is finished.\",\n-                local\n-            );\n-            ecx.machine.written_only_inside_own_block_locals.insert(local);\n-        }\n-        ecx.machine.stack[frame].locals[local].access_mut()\n-    }\n-\n-    fn before_access_global(\n-        _tcx: TyCtxt<'tcx>,\n-        _machine: &Self,\n-        _alloc_id: AllocId,\n-        alloc: ConstAllocation<'tcx, Self::Provenance, Self::AllocExtra>,\n-        _static_def_id: Option<DefId>,\n-        is_write: bool,\n-    ) -> InterpResult<'tcx> {\n-        if is_write {\n-            throw_machine_stop_str!(\"can't write to global\");\n-        }\n-        // If the static allocation is mutable, then we can't const prop it as its content\n-        // might be different at runtime.\n-        if alloc.inner().mutability == Mutability::Mut {\n-            throw_machine_stop_str!(\"can't access mutable globals in ConstProp\");\n-        }\n-\n-        Ok(())\n-    }\n-\n-    #[inline(always)]\n-    fn expose_ptr(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _ptr: Pointer<AllocId>,\n-    ) -> InterpResult<'tcx> {\n-        throw_machine_stop_str!(\"exposing pointers isn't supported in ConstProp\")\n-    }\n-\n-    #[inline(always)]\n-    fn init_frame_extra(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        frame: Frame<'mir, 'tcx>,\n-    ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n-        Ok(frame)\n-    }\n-\n-    #[inline(always)]\n-    fn stack<'a>(\n-        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a [Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>] {\n-        &ecx.machine.stack\n-    }\n-\n-    #[inline(always)]\n-    fn stack_mut<'a>(\n-        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>> {\n-        &mut ecx.machine.stack\n-    }\n-}\n-\n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n@@ -711,139 +523,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n }\n \n-/// The mode that `ConstProp` is allowed to run in for a given `Local`.\n-#[derive(Clone, Copy, Debug, PartialEq)]\n-enum ConstPropMode {\n-    /// The `Local` can be propagated into and reads of this `Local` can also be propagated.\n-    FullConstProp,\n-    /// The `Local` can only be propagated into and from its own block.\n-    OnlyInsideOwnBlock,\n-    /// The `Local` can be propagated into but reads cannot be propagated.\n-    OnlyPropagateInto,\n-    /// The `Local` cannot be part of propagation at all. Any statement\n-    /// referencing it either for reading or writing will not get propagated.\n-    NoPropagation,\n-}\n-\n-struct CanConstProp {\n-    can_const_prop: IndexVec<Local, ConstPropMode>,\n-    // False at the beginning. Once set, no more assignments are allowed to that local.\n-    found_assignment: BitSet<Local>,\n-    // Cache of locals' information\n-    local_kinds: IndexVec<Local, LocalKind>,\n-}\n-\n-impl CanConstProp {\n-    /// Returns true if `local` can be propagated\n-    fn check<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ParamEnv<'tcx>,\n-        body: &Body<'tcx>,\n-    ) -> IndexVec<Local, ConstPropMode> {\n-        let mut cpv = CanConstProp {\n-            can_const_prop: IndexVec::from_elem(ConstPropMode::FullConstProp, &body.local_decls),\n-            found_assignment: BitSet::new_empty(body.local_decls.len()),\n-            local_kinds: IndexVec::from_fn_n(\n-                |local| body.local_kind(local),\n-                body.local_decls.len(),\n-            ),\n-        };\n-        for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n-            let ty = body.local_decls[local].ty;\n-            match tcx.layout_of(param_env.and(ty)) {\n-                Ok(layout) if layout.size < Size::from_bytes(MAX_ALLOC_LIMIT) => {}\n-                // Either the layout fails to compute, then we can't use this local anyway\n-                // or the local is too large, then we don't want to.\n-                _ => {\n-                    *val = ConstPropMode::NoPropagation;\n-                    continue;\n-                }\n-            }\n-            // Cannot use args at all\n-            // Cannot use locals because if x < y { y - x } else { x - y } would\n-            //        lint for x != y\n-            // FIXME(oli-obk): lint variables until they are used in a condition\n-            // FIXME(oli-obk): lint if return value is constant\n-            if cpv.local_kinds[local] == LocalKind::Arg {\n-                *val = ConstPropMode::OnlyPropagateInto;\n-                trace!(\n-                    \"local {:?} can't be const propagated because it's a function argument\",\n-                    local\n-                );\n-            } else if cpv.local_kinds[local] == LocalKind::Var {\n-                *val = ConstPropMode::OnlyInsideOwnBlock;\n-                trace!(\n-                    \"local {:?} will only be propagated inside its block, because it's a user variable\",\n-                    local\n-                );\n-            }\n-        }\n-        cpv.visit_body(&body);\n-        cpv.can_const_prop\n-    }\n-}\n-\n-impl Visitor<'_> for CanConstProp {\n-    fn visit_local(&mut self, local: Local, context: PlaceContext, _: Location) {\n-        use rustc_middle::mir::visit::PlaceContext::*;\n-        match context {\n-            // Projections are fine, because `&mut foo.x` will be caught by\n-            // `MutatingUseContext::Borrow` elsewhere.\n-            MutatingUse(MutatingUseContext::Projection)\n-            // These are just stores, where the storing is not propagatable, but there may be later\n-            // mutations of the same local via `Store`\n-            | MutatingUse(MutatingUseContext::Call)\n-            | MutatingUse(MutatingUseContext::AsmOutput)\n-            | MutatingUse(MutatingUseContext::Deinit)\n-            // Actual store that can possibly even propagate a value\n-            | MutatingUse(MutatingUseContext::SetDiscriminant)\n-            | MutatingUse(MutatingUseContext::Store) => {\n-                if !self.found_assignment.insert(local) {\n-                    match &mut self.can_const_prop[local] {\n-                        // If the local can only get propagated in its own block, then we don't have\n-                        // to worry about multiple assignments, as we'll nuke the const state at the\n-                        // end of the block anyway, and inside the block we overwrite previous\n-                        // states as applicable.\n-                        ConstPropMode::OnlyInsideOwnBlock => {}\n-                        ConstPropMode::NoPropagation => {}\n-                        ConstPropMode::OnlyPropagateInto => {}\n-                        other @ ConstPropMode::FullConstProp => {\n-                            trace!(\n-                                \"local {:?} can't be propagated because of multiple assignments. Previous state: {:?}\",\n-                                local, other,\n-                            );\n-                            *other = ConstPropMode::OnlyInsideOwnBlock;\n-                        }\n-                    }\n-                }\n-            }\n-            // Reading constants is allowed an arbitrary number of times\n-            NonMutatingUse(NonMutatingUseContext::Copy)\n-            | NonMutatingUse(NonMutatingUseContext::Move)\n-            | NonMutatingUse(NonMutatingUseContext::Inspect)\n-            | NonMutatingUse(NonMutatingUseContext::Projection)\n-            | NonUse(_) => {}\n-\n-            // These could be propagated with a smarter analysis or just some careful thinking about\n-            // whether they'd be fine right now.\n-            MutatingUse(MutatingUseContext::Yield)\n-            | MutatingUse(MutatingUseContext::Drop)\n-            | MutatingUse(MutatingUseContext::Retag)\n-            // These can't ever be propagated under any scheme, as we can't reason about indirect\n-            // mutation.\n-            | NonMutatingUse(NonMutatingUseContext::SharedBorrow)\n-            | NonMutatingUse(NonMutatingUseContext::ShallowBorrow)\n-            | NonMutatingUse(NonMutatingUseContext::UniqueBorrow)\n-            | NonMutatingUse(NonMutatingUseContext::AddressOf)\n-            | MutatingUse(MutatingUseContext::Borrow)\n-            | MutatingUse(MutatingUseContext::AddressOf) => {\n-                trace!(\"local {:?} can't be propagaged because it's used: {:?}\", local, context);\n-                self.can_const_prop[local] = ConstPropMode::NoPropagation;\n-            }\n-        }\n-    }\n-}\n-\n impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     fn visit_body(&mut self, body: &Body<'tcx>) {\n         for (bb, data) in body.basic_blocks().iter_enumerated() {"}]}