{"sha": "e0eba9cafcc8aaf3821f4b0b9777954caf049498", "node_id": "C_kwDOAAsO6NoAKGUwZWJhOWNhZmNjOGFhZjM4MjFmNGIwYjk3Nzc5NTRjYWYwNDk0OTg", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-11-29T15:36:43Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-11-30T15:53:27Z"}, "message": "Don't cross contexts while building the suggestion for `redundant_closure_call`", "tree": {"sha": "24149d3d131d8ff45af954cfbf5637062ea60629", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24149d3d131d8ff45af954cfbf5637062ea60629"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0eba9cafcc8aaf3821f4b0b9777954caf049498", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0eba9cafcc8aaf3821f4b0b9777954caf049498", "html_url": "https://github.com/rust-lang/rust/commit/e0eba9cafcc8aaf3821f4b0b9777954caf049498", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0eba9cafcc8aaf3821f4b0b9777954caf049498/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12074808c7a5a2fd9005ed228d9347e9e57f72dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/12074808c7a5a2fd9005ed228d9347e9e57f72dd", "html_url": "https://github.com/rust-lang/rust/commit/12074808c7a5a2fd9005ed228d9347e9e57f72dd"}], "stats": {"total": 165, "additions": 122, "deletions": 43}, "files": [{"sha": "b38e09dc09f46e5d2053f8080b3e87e2f17844e4", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0eba9cafcc8aaf3821f4b0b9777954caf049498/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eba9cafcc8aaf3821f4b0b9777954caf049498/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=e0eba9cafcc8aaf3821f4b0b9777954caf049498", "patch": "@@ -160,11 +160,13 @@ fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &\n         if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.kind;\n         // Prevent triggering on `if c { if let a = b { .. } }`.\n         if !matches!(check_inner.kind, ast::ExprKind::Let(..));\n-        if expr.span.ctxt() == inner.span.ctxt();\n+        let ctxt = expr.span.ctxt();\n+        if inner.span.ctxt() == ctxt;\n         then {\n             span_lint_and_then(cx, COLLAPSIBLE_IF, expr.span, \"this `if` statement can be collapsed\", |diag| {\n-                let lhs = Sugg::ast(cx, check, \"..\");\n-                let rhs = Sugg::ast(cx, check_inner, \"..\");\n+                let mut app = Applicability::MachineApplicable;\n+                let lhs = Sugg::ast(cx, check, \"..\", ctxt, &mut app);\n+                let rhs = Sugg::ast(cx, check_inner, \"..\", ctxt, &mut app);\n                 diag.span_suggestion(\n                     expr.span,\n                     \"collapse nested if block\",\n@@ -173,7 +175,7 @@ fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &\n                         lhs.and(&rhs),\n                         snippet_block(cx, content.span, \"..\", Some(expr.span)),\n                     ),\n-                    Applicability::MachineApplicable, // snippet\n+                    app, // snippet\n                 );\n             });\n         }"}, {"sha": "2a42e73488f1905c4b98cb45ea1fee522baaf567", "filename": "clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0eba9cafcc8aaf3821f4b0b9777954caf049498/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eba9cafcc8aaf3821f4b0b9777954caf049498/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=e0eba9cafcc8aaf3821f4b0b9777954caf049498", "patch": "@@ -81,8 +81,8 @@ impl EarlyLintPass for RedundantClosureCall {\n                         \"try not to call a closure in the expression where it is declared\",\n                         |diag| {\n                             if fn_decl.inputs.is_empty() {\n-                                let app = Applicability::MachineApplicable;\n-                                let mut hint = Sugg::ast(cx, body, \"..\");\n+                                let mut app = Applicability::MachineApplicable;\n+                                let mut hint = Sugg::ast(cx, body, \"..\", closure.span.ctxt(), &mut app);\n \n                                 if asyncness.is_async() {\n                                     // `async x` is a syntax error, so it becomes `async { x }`"}, {"sha": "cd5dcfdaca34b64245632331bd7707c36205adcd", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e0eba9cafcc8aaf3821f4b0b9777954caf049498/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eba9cafcc8aaf3821f4b0b9777954caf049498/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=e0eba9cafcc8aaf3821f4b0b9777954caf049498", "patch": "@@ -5,6 +5,7 @@\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LintContext};\n+use rustc_session::Session;\n use rustc_span::hygiene;\n use rustc_span::source_map::{original_sp, SourceMap};\n use rustc_span::{BytePos, Pos, Span, SpanData, SyntaxContext, DUMMY_SP};\n@@ -204,11 +205,20 @@ pub fn snippet_with_applicability<'a, T: LintContext>(\n     span: Span,\n     default: &'a str,\n     applicability: &mut Applicability,\n+) -> Cow<'a, str> {\n+    snippet_with_applicability_sess(cx.sess(), span, default, applicability)\n+}\n+\n+fn snippet_with_applicability_sess<'a>(\n+    sess: &Session,\n+    span: Span,\n+    default: &'a str,\n+    applicability: &mut Applicability,\n ) -> Cow<'a, str> {\n     if *applicability != Applicability::Unspecified && span.from_expansion() {\n         *applicability = Applicability::MaybeIncorrect;\n     }\n-    snippet_opt(cx, span).map_or_else(\n+    snippet_opt_sess(sess, span).map_or_else(\n         || {\n             if *applicability == Applicability::MachineApplicable {\n                 *applicability = Applicability::HasPlaceholders;\n@@ -226,8 +236,12 @@ pub fn snippet_with_macro_callsite<'a, T: LintContext>(cx: &T, span: Span, defau\n }\n \n /// Converts a span to a code snippet. Returns `None` if not available.\n-pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n-    cx.sess().source_map().span_to_snippet(span).ok()\n+pub fn snippet_opt(cx: &impl LintContext, span: Span) -> Option<String> {\n+    snippet_opt_sess(cx.sess(), span)\n+}\n+\n+fn snippet_opt_sess(sess: &Session, span: Span) -> Option<String> {\n+    sess.source_map().span_to_snippet(span).ok()\n }\n \n /// Converts a span (from a block) to a code snippet if available, otherwise use default.\n@@ -277,8 +291,8 @@ pub fn snippet_block<'a, T: LintContext>(\n \n /// Same as `snippet_block`, but adapts the applicability level by the rules of\n /// `snippet_with_applicability`.\n-pub fn snippet_block_with_applicability<'a, T: LintContext>(\n-    cx: &T,\n+pub fn snippet_block_with_applicability<'a>(\n+    cx: &impl LintContext,\n     span: Span,\n     default: &'a str,\n     indent_relative_to: Option<Span>,\n@@ -299,7 +313,17 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n ///\n /// This will also return whether or not the snippet is a macro call.\n pub fn snippet_with_context<'a>(\n-    cx: &LateContext<'_>,\n+    cx: &impl LintContext,\n+    span: Span,\n+    outer: SyntaxContext,\n+    default: &'a str,\n+    applicability: &mut Applicability,\n+) -> (Cow<'a, str>, bool) {\n+    snippet_with_context_sess(cx.sess(), span, outer, default, applicability)\n+}\n+\n+fn snippet_with_context_sess<'a>(\n+    sess: &Session,\n     span: Span,\n     outer: SyntaxContext,\n     default: &'a str,\n@@ -318,7 +342,7 @@ pub fn snippet_with_context<'a>(\n     );\n \n     (\n-        snippet_with_applicability(cx, span, default, applicability),\n+        snippet_with_applicability_sess(sess, span, default, applicability),\n         is_macro_call,\n     )\n }"}, {"sha": "b66604f33db1799d49b8fd5fb9b3ccfaa40fa1f1", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e0eba9cafcc8aaf3821f4b0b9777954caf049498/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eba9cafcc8aaf3821f4b0b9777954caf049498/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=e0eba9cafcc8aaf3821f4b0b9777954caf049498", "patch": "@@ -176,25 +176,28 @@ impl<'a> Sugg<'a> {\n     }\n \n     /// Prepare a suggestion from an expression.\n-    pub fn ast(cx: &EarlyContext<'_>, expr: &ast::Expr, default: &'a str) -> Self {\n+    pub fn ast(\n+        cx: &EarlyContext<'_>,\n+        expr: &ast::Expr,\n+        default: &'a str,\n+        ctxt: SyntaxContext,\n+        app: &mut Applicability,\n+    ) -> Self {\n         use rustc_ast::ast::RangeLimits;\n \n-        let snippet_without_expansion = |cx, span: Span, default| {\n-            if span.from_expansion() {\n-                snippet_with_macro_callsite(cx, span, default)\n-            } else {\n-                snippet(cx, span, default)\n-            }\n-        };\n-\n+        #[expect(clippy::match_wildcard_for_single_variants)]\n         match expr.kind {\n+            _ if expr.span.ctxt() != ctxt => Sugg::NonParen(snippet_with_context(cx, expr.span, ctxt, default, app).0),\n             ast::ExprKind::AddrOf(..)\n             | ast::ExprKind::Box(..)\n             | ast::ExprKind::Closure { .. }\n             | ast::ExprKind::If(..)\n             | ast::ExprKind::Let(..)\n             | ast::ExprKind::Unary(..)\n-            | ast::ExprKind::Match(..) => Sugg::MaybeParen(snippet_without_expansion(cx, expr.span, default)),\n+            | ast::ExprKind::Match(..) => match snippet_with_context(cx, expr.span, ctxt, default, app) {\n+                (snip, false) => Sugg::MaybeParen(snip),\n+                (snip, true) => Sugg::NonParen(snip),\n+            },\n             ast::ExprKind::Async(..)\n             | ast::ExprKind::Block(..)\n             | ast::ExprKind::Break(..)\n@@ -224,45 +227,49 @@ impl<'a> Sugg<'a> {\n             | ast::ExprKind::Array(..)\n             | ast::ExprKind::While(..)\n             | ast::ExprKind::Await(..)\n-            | ast::ExprKind::Err => Sugg::NonParen(snippet_without_expansion(cx, expr.span, default)),\n+            | ast::ExprKind::Err => Sugg::NonParen(snippet_with_context(cx, expr.span, ctxt, default, app).0),\n             ast::ExprKind::Range(ref lhs, ref rhs, RangeLimits::HalfOpen) => Sugg::BinOp(\n                 AssocOp::DotDot,\n-                lhs.as_ref()\n-                    .map_or(\"\".into(), |lhs| snippet_without_expansion(cx, lhs.span, default)),\n-                rhs.as_ref()\n-                    .map_or(\"\".into(), |rhs| snippet_without_expansion(cx, rhs.span, default)),\n+                lhs.as_ref().map_or(\"\".into(), |lhs| {\n+                    snippet_with_context(cx, lhs.span, ctxt, default, app).0\n+                }),\n+                rhs.as_ref().map_or(\"\".into(), |rhs| {\n+                    snippet_with_context(cx, rhs.span, ctxt, default, app).0\n+                }),\n             ),\n             ast::ExprKind::Range(ref lhs, ref rhs, RangeLimits::Closed) => Sugg::BinOp(\n                 AssocOp::DotDotEq,\n-                lhs.as_ref()\n-                    .map_or(\"\".into(), |lhs| snippet_without_expansion(cx, lhs.span, default)),\n-                rhs.as_ref()\n-                    .map_or(\"\".into(), |rhs| snippet_without_expansion(cx, rhs.span, default)),\n+                lhs.as_ref().map_or(\"\".into(), |lhs| {\n+                    snippet_with_context(cx, lhs.span, ctxt, default, app).0\n+                }),\n+                rhs.as_ref().map_or(\"\".into(), |rhs| {\n+                    snippet_with_context(cx, rhs.span, ctxt, default, app).0\n+                }),\n             ),\n             ast::ExprKind::Assign(ref lhs, ref rhs, _) => Sugg::BinOp(\n                 AssocOp::Assign,\n-                snippet_without_expansion(cx, lhs.span, default),\n-                snippet_without_expansion(cx, rhs.span, default),\n+                snippet_with_context(cx, lhs.span, ctxt, default, app).0,\n+                snippet_with_context(cx, rhs.span, ctxt, default, app).0,\n             ),\n             ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => Sugg::BinOp(\n                 astbinop2assignop(op),\n-                snippet_without_expansion(cx, lhs.span, default),\n-                snippet_without_expansion(cx, rhs.span, default),\n+                snippet_with_context(cx, lhs.span, ctxt, default, app).0,\n+                snippet_with_context(cx, rhs.span, ctxt, default, app).0,\n             ),\n             ast::ExprKind::Binary(op, ref lhs, ref rhs) => Sugg::BinOp(\n                 AssocOp::from_ast_binop(op.node),\n-                snippet_without_expansion(cx, lhs.span, default),\n-                snippet_without_expansion(cx, rhs.span, default),\n+                snippet_with_context(cx, lhs.span, ctxt, default, app).0,\n+                snippet_with_context(cx, rhs.span, ctxt, default, app).0,\n             ),\n             ast::ExprKind::Cast(ref lhs, ref ty) => Sugg::BinOp(\n                 AssocOp::As,\n-                snippet_without_expansion(cx, lhs.span, default),\n-                snippet_without_expansion(cx, ty.span, default),\n+                snippet_with_context(cx, lhs.span, ctxt, default, app).0,\n+                snippet_with_context(cx, ty.span, ctxt, default, app).0,\n             ),\n             ast::ExprKind::Type(ref lhs, ref ty) => Sugg::BinOp(\n                 AssocOp::Colon,\n-                snippet_without_expansion(cx, lhs.span, default),\n-                snippet_without_expansion(cx, ty.span, default),\n+                snippet_with_context(cx, lhs.span, ctxt, default, app).0,\n+                snippet_with_context(cx, ty.span, ctxt, default, app).0,\n             ),\n         }\n     }"}, {"sha": "c0e49ff4caa7472f09bc38ce817b046f1cdb10a9", "filename": "tests/ui/redundant_closure_call_fixable.fixed", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0eba9cafcc8aaf3821f4b0b9777954caf049498/tests%2Fui%2Fredundant_closure_call_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e0eba9cafcc8aaf3821f4b0b9777954caf049498/tests%2Fui%2Fredundant_closure_call_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_closure_call_fixable.fixed?ref=e0eba9cafcc8aaf3821f4b0b9777954caf049498", "patch": "@@ -25,4 +25,16 @@ fn main() {\n         x * y\n     };\n     let d = async { something().await };\n+\n+    macro_rules! m {\n+        () => {\n+            0\n+        };\n+    }\n+    macro_rules! m2 {\n+        () => {\n+            m!()\n+        };\n+    }\n+    m2!();\n }"}, {"sha": "9e6e54348a8c28f36f615a0444e86c59ef94b1f3", "filename": "tests/ui/redundant_closure_call_fixable.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0eba9cafcc8aaf3821f4b0b9777954caf049498/tests%2Fui%2Fredundant_closure_call_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eba9cafcc8aaf3821f4b0b9777954caf049498/tests%2Fui%2Fredundant_closure_call_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_closure_call_fixable.rs?ref=e0eba9cafcc8aaf3821f4b0b9777954caf049498", "patch": "@@ -25,4 +25,16 @@ fn main() {\n         x * y\n     })();\n     let d = (async || something().await)();\n+\n+    macro_rules! m {\n+        () => {\n+            (|| 0)()\n+        };\n+    }\n+    macro_rules! m2 {\n+        () => {\n+            (|| m!())()\n+        };\n+    }\n+    m2!();\n }"}, {"sha": "d71bcba2a8200414b0b74b98bb6c60a588f0e649", "filename": "tests/ui/redundant_closure_call_fixable.stderr", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0eba9cafcc8aaf3821f4b0b9777954caf049498/tests%2Fui%2Fredundant_closure_call_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0eba9cafcc8aaf3821f4b0b9777954caf049498/tests%2Fui%2Fredundant_closure_call_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_closure_call_fixable.stderr?ref=e0eba9cafcc8aaf3821f4b0b9777954caf049498", "patch": "@@ -52,5 +52,27 @@ error: try not to call a closure in the expression where it is declared\n LL |     let d = (async || something().await)();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try doing something like: `async { something().await }`\n \n-error: aborting due to 4 previous errors\n+error: try not to call a closure in the expression where it is declared\n+  --> $DIR/redundant_closure_call_fixable.rs:36:13\n+   |\n+LL |             (|| m!())()\n+   |             ^^^^^^^^^^^ help: try doing something like: `m!()`\n+...\n+LL |     m2!();\n+   |     ----- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m2` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: try not to call a closure in the expression where it is declared\n+  --> $DIR/redundant_closure_call_fixable.rs:31:13\n+   |\n+LL |             (|| 0)()\n+   |             ^^^^^^^^ help: try doing something like: `0`\n+...\n+LL |     m2!();\n+   |     ----- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` which comes from the expansion of the macro `m2` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 6 previous errors\n "}]}