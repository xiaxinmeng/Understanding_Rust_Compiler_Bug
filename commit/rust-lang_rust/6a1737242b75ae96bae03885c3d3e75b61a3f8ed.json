{"sha": "6a1737242b75ae96bae03885c3d3e75b61a3f8ed", "node_id": "C_kwDOAAsO6NoAKDZhMTczNzI0MmI3NWFlOTZiYWUwMzg4NWMzZDNlNzViNjFhM2Y4ZWQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-08-05T10:06:31Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-08-05T10:06:42Z"}, "message": "Don't switch workspace on vfs file changes from libraries\n\nWhen r-a starts up, it starts switching the workspace before all vfs\nevents have been processed which causes us to switch workspace multiple\ntimes until all vfs changes have been processed. This scales with the\nsize of the project and its dependencies. If workspace files from\ndependencies as well as the sysroot get loaded, we shouldn't switch\nthe workspace as those have no impact on the project workspace.", "tree": {"sha": "08dce64f8f766db099ac5545df8d1a692f39cf64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08dce64f8f766db099ac5545df8d1a692f39cf64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a1737242b75ae96bae03885c3d3e75b61a3f8ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a1737242b75ae96bae03885c3d3e75b61a3f8ed", "html_url": "https://github.com/rust-lang/rust/commit/6a1737242b75ae96bae03885c3d3e75b61a3f8ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a1737242b75ae96bae03885c3d3e75b61a3f8ed/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb522717016044ab63de0ee1375800787d4c72f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb522717016044ab63de0ee1375800787d4c72f4", "html_url": "https://github.com/rust-lang/rust/commit/cb522717016044ab63de0ee1375800787d4c72f4"}], "stats": {"total": 83, "additions": 47, "deletions": 36}, "files": [{"sha": "b5f6aef2e1a84e60abb268aeebf86bd6be85301c", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6a1737242b75ae96bae03885c3d3e75b61a3f8ed/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1737242b75ae96bae03885c3d3e75b61a3f8ed/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=6a1737242b75ae96bae03885c3d3e75b61a3f8ed", "patch": "@@ -8,7 +8,7 @@ use std::{sync::Arc, time::Instant};\n use crossbeam_channel::{unbounded, Receiver, Sender};\n use flycheck::FlycheckHandle;\n use ide::{Analysis, AnalysisHost, Cancellable, Change, FileId};\n-use ide_db::base_db::{CrateId, FileLoader, SourceDatabase};\n+use ide_db::base_db::{CrateId, FileLoader, SourceDatabase, SourceDatabaseExt};\n use lsp_types::{SemanticTokens, Url};\n use parking_lot::{Mutex, RwLock};\n use proc_macro_api::ProcMacroServer;\n@@ -176,7 +176,7 @@ impl GlobalState {\n \n     pub(crate) fn process_changes(&mut self) -> bool {\n         let _p = profile::span(\"GlobalState::process_changes\");\n-        let mut fs_changes = Vec::new();\n+        let mut fs_refresh_changes = Vec::new();\n         // A file was added or deleted\n         let mut has_structure_changes = false;\n \n@@ -192,11 +192,8 @@ impl GlobalState {\n                 if let Some(path) = vfs.file_path(file.file_id).as_path() {\n                     let path = path.to_path_buf();\n                     if reload::should_refresh_for_change(&path, file.change_kind) {\n-                        tracing::warn!(\"fetch-fiel_change\");\n-                        self.fetch_workspaces_queue\n-                            .request_op(format!(\"vfs file change: {}\", path.display()));\n+                        fs_refresh_changes.push((path, file.file_id));\n                     }\n-                    fs_changes.push((path, file.change_kind));\n                     if file.is_created_or_deleted() {\n                         has_structure_changes = true;\n                     }\n@@ -228,14 +225,25 @@ impl GlobalState {\n \n         self.analysis_host.apply_change(change);\n \n-        let raw_database = &self.analysis_host.raw_database();\n-        self.proc_macro_changed =\n-            changed_files.iter().filter(|file| !file.is_created_or_deleted()).any(|file| {\n-                let crates = raw_database.relevant_crates(file.file_id);\n-                let crate_graph = raw_database.crate_graph();\n+        {\n+            let raw_database = self.analysis_host.raw_database();\n+            let workspace_structure_change =\n+                fs_refresh_changes.into_iter().find(|&(_, file_id)| {\n+                    !raw_database.source_root(raw_database.file_source_root(file_id)).is_library\n+                });\n+            if let Some((path, _)) = workspace_structure_change {\n+                self.fetch_workspaces_queue\n+                    .request_op(format!(\"workspace vfs file change: {}\", path.display()));\n+            }\n+            self.proc_macro_changed =\n+                changed_files.iter().filter(|file| !file.is_created_or_deleted()).any(|file| {\n+                    let crates = raw_database.relevant_crates(file.file_id);\n+                    let crate_graph = raw_database.crate_graph();\n+\n+                    crates.iter().any(|&krate| crate_graph[krate].is_proc_macro)\n+                });\n+        }\n \n-                crates.iter().any(|&krate| crate_graph[krate].is_proc_macro)\n-            });\n         true\n     }\n "}, {"sha": "49ccad71a10e851e0cdcac2aeadab773f2171f7b", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6a1737242b75ae96bae03885c3d3e75b61a3f8ed/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1737242b75ae96bae03885c3d3e75b61a3f8ed/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=6a1737242b75ae96bae03885c3d3e75b61a3f8ed", "patch": "@@ -196,10 +196,7 @@ impl GlobalState {\n         }\n \n         if let Err(error) = self.fetch_build_data_error() {\n-            self.show_and_log_error(\n-                \"rust-analyzer failed to run build scripts\".to_string(),\n-                Some(error),\n-            );\n+            self.show_and_log_error(\"failed to run build scripts\".to_string(), Some(error));\n         }\n \n         let workspaces = self\n@@ -308,6 +305,7 @@ impl GlobalState {\n \n         if self.proc_macro_clients.is_empty() {\n             if let Some((path, args)) = self.config.proc_macro_srv() {\n+                tracing::info!(\"Spawning proc-macro servers\");\n                 self.proc_macro_clients = self\n                     .workspaces\n                     .iter()\n@@ -316,35 +314,31 @@ impl GlobalState {\n                         let mut path = path.clone();\n \n                         if let ProjectWorkspace::Cargo { sysroot, .. } = ws {\n-                            tracing::info!(\"Found a cargo workspace...\");\n+                            tracing::debug!(\"Found a cargo workspace...\");\n                             if let Some(sysroot) = sysroot.as_ref() {\n-                                tracing::info!(\"Found a cargo workspace with a sysroot...\");\n+                                tracing::debug!(\"Found a cargo workspace with a sysroot...\");\n                                 let server_path =\n                                     sysroot.root().join(\"libexec\").join(&standalone_server_name);\n                                 if std::fs::metadata(&server_path).is_ok() {\n-                                    tracing::info!(\n+                                    tracing::debug!(\n                                         \"And the server exists at {}\",\n                                         server_path.display()\n                                     );\n                                     path = server_path;\n                                     args = vec![];\n                                 } else {\n-                                    tracing::info!(\n+                                    tracing::debug!(\n                                         \"And the server does not exist at {}\",\n                                         server_path.display()\n                                     );\n                                 }\n                             }\n                         }\n \n-                        tracing::info!(\n-                            \"Using proc-macro server at {} with args {:?}\",\n-                            path.display(),\n-                            args\n-                        );\n+                        tracing::info!(?args, \"Using proc-macro server at {}\", path.display(),);\n                         ProcMacroServer::spawn(path.clone(), args.clone()).map_err(|err| {\n                             let error = format!(\n-                                \"Failed to run proc_macro_srv from path {}, error: {:?}\",\n+                                \"Failed to run proc-macro server from path {}, error: {:?}\",\n                                 path.display(),\n                                 err\n                             );\n@@ -684,22 +678,26 @@ pub(crate) fn load_proc_macro(\n pub(crate) fn should_refresh_for_change(path: &AbsPath, change_kind: ChangeKind) -> bool {\n     const IMPLICIT_TARGET_FILES: &[&str] = &[\"build.rs\", \"src/main.rs\", \"src/lib.rs\"];\n     const IMPLICIT_TARGET_DIRS: &[&str] = &[\"src/bin\", \"examples\", \"tests\", \"benches\"];\n-    let file_name = path.file_name().unwrap_or_default();\n \n-    if file_name == \"Cargo.toml\" || file_name == \"Cargo.lock\" {\n+    let file_name = match path.file_name().unwrap_or_default().to_str() {\n+        Some(it) => it,\n+        None => return false,\n+    };\n+\n+    if let \"Cargo.toml\" | \"Cargo.lock\" = file_name {\n         return true;\n     }\n     if change_kind == ChangeKind::Modify {\n         return false;\n     }\n+\n+    // .cargo/config{.toml}\n     if path.extension().unwrap_or_default() != \"rs\" {\n-        if (file_name == \"config.toml\" || file_name == \"config\")\n-            && path.parent().map(|parent| parent.as_ref().ends_with(\".cargo\")) == Some(true)\n-        {\n-            return true;\n-        }\n-        return false;\n+        let is_cargo_config = matches!(file_name, \"config.toml\" | \"config\")\n+            && path.parent().map(|parent| parent.as_ref().ends_with(\".cargo\")).unwrap_or(false);\n+        return is_cargo_config;\n     }\n+\n     if IMPLICIT_TARGET_FILES.iter().any(|it| path.as_ref().ends_with(it)) {\n         return true;\n     }"}, {"sha": "d6d9c66159fe1fa624c742d69a9ecfbbd3918de2", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a1737242b75ae96bae03885c3d3e75b61a3f8ed/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1737242b75ae96bae03885c3d3e75b61a3f8ed/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=6a1737242b75ae96bae03885c3d3e75b61a3f8ed", "patch": "@@ -40,12 +40,15 @@ impl loader::Handle for NotifyHandle {\n             .expect(\"failed to spawn thread\");\n         NotifyHandle { sender, _thread: thread }\n     }\n+\n     fn set_config(&mut self, config: loader::Config) {\n         self.sender.send(Message::Config(config)).unwrap();\n     }\n+\n     fn invalidate(&mut self, path: AbsPathBuf) {\n         self.sender.send(Message::Invalidate(path)).unwrap();\n     }\n+\n     fn load_sync(&mut self, path: &AbsPath) -> Option<Vec<u8>> {\n         read(path)\n     }\n@@ -70,16 +73,18 @@ impl NotifyActor {\n     fn new(sender: loader::Sender) -> NotifyActor {\n         NotifyActor { sender, watched_entries: Vec::new(), watcher: None }\n     }\n+\n     fn next_event(&self, receiver: &Receiver<Message>) -> Option<Event> {\n         let watcher_receiver = self.watcher.as_ref().map(|(_, receiver)| receiver);\n         select! {\n             recv(receiver) -> it => it.ok().map(Event::Message),\n             recv(watcher_receiver.unwrap_or(&never())) -> it => Some(Event::NotifyEvent(it.unwrap())),\n         }\n     }\n+\n     fn run(mut self, inbox: Receiver<Message>) {\n         while let Some(event) = self.next_event(&inbox) {\n-            tracing::debug!(\"vfs-notify event: {:?}\", event);\n+            tracing::debug!(?event, \"vfs-notify event\");\n             match event {\n                 Event::Message(msg) => match msg {\n                     Message::Config(config) => {"}]}