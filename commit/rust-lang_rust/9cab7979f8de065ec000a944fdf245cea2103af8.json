{"sha": "9cab7979f8de065ec000a944fdf245cea2103af8", "node_id": "C_kwDOAAsO6NoAKDljYWI3OTc5ZjhkZTA2NWVjMDAwYTk0NGZkZjI0NWNlYTIxMDNhZjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-21T21:08:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-21T21:08:02Z"}, "message": "Auto merge of #2414 - RalfJung:cargo-miri, r=RalfJung\n\nA bit of cargo-miri cleanup", "tree": {"sha": "83cf3af4d19229c07803a0f303d8c632815b5ca2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83cf3af4d19229c07803a0f303d8c632815b5ca2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cab7979f8de065ec000a944fdf245cea2103af8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cab7979f8de065ec000a944fdf245cea2103af8", "html_url": "https://github.com/rust-lang/rust/commit/9cab7979f8de065ec000a944fdf245cea2103af8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cab7979f8de065ec000a944fdf245cea2103af8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dac1676eb3bea10e94404bc5b40412742ea5e8d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/dac1676eb3bea10e94404bc5b40412742ea5e8d9", "html_url": "https://github.com/rust-lang/rust/commit/dac1676eb3bea10e94404bc5b40412742ea5e8d9"}, {"sha": "fb428dfee3252f378f796c7497a8fb29753c795d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb428dfee3252f378f796c7497a8fb29753c795d", "html_url": "https://github.com/rust-lang/rust/commit/fb428dfee3252f378f796c7497a8fb29753c795d"}], "stats": {"total": 113, "additions": 48, "deletions": 65}, "files": [{"sha": "8b60d90520ab2f394c4831f6548b56f8010d7f39", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 48, "deletions": 65, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9cab7979f8de065ec000a944fdf245cea2103af8/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cab7979f8de065ec000a944fdf245cea2103af8/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=9cab7979f8de065ec000a944fdf245cea2103af8", "patch": "@@ -60,7 +60,7 @@ struct CrateRunEnv {\n \n impl CrateRunEnv {\n     /// Gather all the information we need.\n-    fn collect(args: env::Args, capture_stdin: bool) -> Self {\n+    fn collect(args: impl Iterator<Item = String>, capture_stdin: bool) -> Self {\n         let args = args.collect();\n         let env = env::vars_os().collect();\n         let current_dir = env::current_dir().unwrap().into_os_string();\n@@ -757,7 +757,7 @@ enum RustcPhase {\n     Rustdoc,\n }\n \n-fn phase_rustc(mut args: env::Args, phase: RustcPhase) {\n+fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n     /// Determines if we are being invoked (as rustc) to build a crate for\n     /// the \"target\" architecture, in contrast to the \"host\" architecture.\n     /// Host crates are for build scripts and proc macros and still need to\n@@ -978,10 +978,11 @@ enum RunnerPhase {\n     Rustdoc,\n }\n \n-fn phase_runner(binary: &Path, binary_args: impl Iterator<Item = String>, phase: RunnerPhase) {\n+fn phase_runner(mut binary_args: impl Iterator<Item = String>, phase: RunnerPhase) {\n     let verbose = std::env::var(\"MIRI_VERBOSE\")\n         .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n \n+    let binary = binary_args.next().unwrap();\n     let file = File::open(&binary)\n         .unwrap_or_else(|_| show_error(format!(\"file {:?} not found or `cargo-miri` invoked incorrectly; please only invoke this binary through `cargo miri`\", binary)));\n     let file = BufReader::new(file);\n@@ -1007,14 +1008,16 @@ fn phase_runner(binary: &Path, binary_args: impl Iterator<Item = String>, phase:\n     // Set missing env vars. We prefer build-time env vars over run-time ones; see\n     // <https://github.com/rust-lang/miri/issues/1661> for the kind of issue that fixes.\n     for (name, val) in info.env {\n-        if verbose > 0 {\n-            if let Some(old_val) = env::var_os(&name) {\n-                if old_val != val {\n-                    eprintln!(\n-                        \"[cargo-miri runner] Overwriting run-time env var {:?}={:?} with build-time value {:?}\",\n-                        name, old_val, val\n-                    );\n-                }\n+        if let Some(old_val) = env::var_os(&name) {\n+            if old_val == val {\n+                // This one did not actually change, no need to re-set it.\n+                // (This keeps the `debug_cmd` below more manageable.)\n+                continue;\n+            } else if verbose > 0 {\n+                eprintln!(\n+                    \"[cargo-miri runner] Overwriting run-time env var {:?}={:?} with build-time value {:?}\",\n+                    name, old_val, val\n+                );\n             }\n         }\n         cmd.env(name, val);\n@@ -1071,25 +1074,16 @@ fn phase_runner(binary: &Path, binary_args: impl Iterator<Item = String>, phase:\n     }\n }\n \n-fn phase_rustdoc(fst_arg: &str, mut args: env::Args) {\n+fn phase_rustdoc(mut args: impl Iterator<Item = String>) {\n     let verbose = std::env::var(\"MIRI_VERBOSE\")\n         .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n \n     // phase_cargo_miri sets the RUSTDOC env var to ourselves, so we can't use that here;\n     // just default to a straight-forward invocation for now:\n     let mut cmd = Command::new(\"rustdoc\");\n \n-    // Because of the way the main function is structured, we have to take the first argument spearately\n-    // from the rest; to simplify the following argument patching loop, we'll just skip that one.\n-    // This is fine for now, because cargo will never pass --extern arguments in the first position,\n-    // but we should defensively assert that this will work.\n     let extern_flag = \"--extern\";\n-    assert!(fst_arg != extern_flag);\n-    cmd.arg(fst_arg);\n-\n     let runtool_flag = \"--runtool\";\n-    // `crossmode` records if *any* argument matches `runtool_flag`; here we check the first one.\n-    let mut crossmode = fst_arg == runtool_flag;\n     while let Some(arg) = args.next() {\n         if arg == extern_flag {\n             // Patch --extern arguments to use *.rmeta files, since phase_cargo_rustc only creates stub *.rlib files.\n@@ -1098,17 +1092,12 @@ fn phase_rustdoc(fst_arg: &str, mut args: env::Args) {\n             // An existing --runtool flag indicates cargo is running in cross-target mode, which we don't support.\n             // Note that this is only passed when cargo is run with the unstable -Zdoctest-xcompile flag;\n             // otherwise, we won't be called as rustdoc at all.\n-            crossmode = true;\n-            break;\n+            show_error(format!(\"cross-interpreting doctests is not currently supported by Miri.\"));\n         } else {\n             cmd.arg(arg);\n         }\n     }\n \n-    if crossmode {\n-        show_error(format!(\"cross-interpreting doctests is not currently supported by Miri.\"));\n-    }\n-\n     // Doctests of `proc-macro` crates (and their dependencies) are always built for the host,\n     // so we are not able to run them in Miri.\n     if ArgFlagValueIter::new(\"--crate-type\").any(|crate_type| crate_type == \"proc-macro\") {\n@@ -1178,52 +1167,46 @@ fn main() {\n         // since we don't specify any runtool-args, and rustdoc supplies multiple arguments to\n         // the test-builder unconditionally, we can just check the number of remaining arguments:\n         if args.len() == 1 {\n-            let arg = args.next().unwrap();\n-            let binary = Path::new(&arg);\n-            if binary.exists() {\n-                phase_runner(binary, args, RunnerPhase::Rustdoc);\n-            } else {\n-                show_error(format!(\n-                    \"`cargo-miri` called with non-existing path argument `{}` in rustdoc mode; please invoke this binary through `cargo miri`\",\n-                    arg\n-                ));\n-            }\n+            phase_runner(args, RunnerPhase::Rustdoc);\n         } else {\n             phase_rustc(args, RustcPhase::Rustdoc);\n         }\n \n         return;\n     }\n \n-    match args.next().as_deref() {\n-        Some(\"miri\") => phase_cargo_miri(args),\n-        Some(arg) => {\n-            // If the first arg is equal to the RUSTC variable (which should be set at this point),\n-            // then we need to behave as rustc. This is the somewhat counter-intuitive behavior of\n-            // having both RUSTC and RUSTC_WRAPPER set (see\n-            // https://github.com/rust-lang/cargo/issues/10886).\n-            if arg == env::var_os(\"RUSTC\").unwrap() {\n-                return phase_rustc(args, RustcPhase::Build);\n-            }\n-            // We have to distinguish the \"runner\" and \"rustdoc\" cases.\n-            // As runner, the first argument is the binary (a file that should exist, with an absolute path);\n-            // as rustdoc, the first argument is a flag (`--something`).\n-            let binary = Path::new(arg);\n-            if binary.exists() {\n-                assert!(!arg.starts_with(\"--\")); // not a flag\n-                phase_runner(binary, args, RunnerPhase::Cargo);\n-            } else if arg.starts_with(\"--\") {\n-                phase_rustdoc(arg, args);\n-            } else {\n-                show_error(format!(\n-                    \"`cargo-miri` called with unexpected first argument `{}`; please only invoke this binary through `cargo miri`\",\n-                    arg\n-                ));\n-            }\n+    let mut args = args.peekable();\n+    if args.next_if(|a| a == \"miri\").is_some() {\n+        phase_cargo_miri(args);\n+    } else if let Some(arg) = args.peek().cloned() {\n+        // Cargo calls us for everything it does. We could be invoked as rustc, rustdoc, or the runner.\n+\n+        // If the first arg is equal to the RUSTC variable (which should be set at this point),\n+        // then we need to behave as rustc. This is the somewhat counter-intuitive behavior of\n+        // having both RUSTC and RUSTC_WRAPPER set (see\n+        // https://github.com/rust-lang/cargo/issues/10886).\n+        if arg == env::var(\"RUSTC\").unwrap() {\n+            args.next().unwrap(); // consume wrapped RUSTC command.\n+            return phase_rustc(args, RustcPhase::Build);\n         }\n-        _ =>\n+        // We have to distinguish the \"runner\" and \"rustdoc\" cases.\n+        // As runner, the first argument is the binary (a file that should exist, with an absolute path);\n+        // as rustdoc, the first argument is a flag (`--something`).\n+        let binary = Path::new(&arg);\n+        if binary.exists() {\n+            assert!(!arg.starts_with(\"--\")); // not a flag\n+            phase_runner(args, RunnerPhase::Cargo);\n+        } else if arg.starts_with(\"--\") {\n+            phase_rustdoc(args);\n+        } else {\n             show_error(format!(\n-                \"`cargo-miri` called without first argument; please only invoke this binary through `cargo miri`\"\n-            )),\n+                \"`cargo-miri` called with unexpected first argument `{}`; please only invoke this binary through `cargo miri`\",\n+                arg\n+            ));\n+        }\n+    } else {\n+        show_error(format!(\n+            \"`cargo-miri` called without first argument; please only invoke this binary through `cargo miri`\"\n+        ));\n     }\n }"}]}