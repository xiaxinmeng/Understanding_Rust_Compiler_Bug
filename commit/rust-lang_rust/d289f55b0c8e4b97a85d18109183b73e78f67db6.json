{"sha": "d289f55b0c8e4b97a85d18109183b73e78f67db6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyODlmNTViMGM4ZTRiOTdhODVkMTgxMDkxODNiNzNlNzhmNjdkYjY=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-12-03T18:59:50Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-12-04T16:43:24Z"}, "message": "Move empty match check to `check_exhaustive`", "tree": {"sha": "388a6ece76dd3cc20a3767590adb24d79c5ed1bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/388a6ece76dd3cc20a3767590adb24d79c5ed1bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d289f55b0c8e4b97a85d18109183b73e78f67db6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d289f55b0c8e4b97a85d18109183b73e78f67db6", "html_url": "https://github.com/rust-lang/rust/commit/d289f55b0c8e4b97a85d18109183b73e78f67db6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d289f55b0c8e4b97a85d18109183b73e78f67db6/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "353283573896502c185d048b6f2c99561a343853", "url": "https://api.github.com/repos/rust-lang/rust/commits/353283573896502c185d048b6f2c99561a343853", "html_url": "https://github.com/rust-lang/rust/commit/353283573896502c185d048b6f2c99561a343853"}], "stats": {"total": 109, "additions": 56, "deletions": 53}, "files": [{"sha": "40de154129dffc11aecb47eb561e1f595037d024", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 56, "deletions": 53, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/d289f55b0c8e4b97a85d18109183b73e78f67db6/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d289f55b0c8e4b97a85d18109183b73e78f67db6/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=d289f55b0c8e4b97a85d18109183b73e78f67db6", "patch": "@@ -166,60 +166,10 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             // Fourth, check for unreachable arms.\n             let matrix = check_arms(cx, &inlined_arms, source);\n \n-            // Then, if the match has no arms, check whether the scrutinee\n-            // is uninhabited.\n-            let scrut_ty = self.tables.node_type(scrut.hir_id);\n-            if inlined_arms.is_empty() {\n-                let scrutinee_is_visibly_uninhabited = if self.tcx.features().exhaustive_patterns {\n-                    let module = self.tcx.hir().get_module_parent(scrut.hir_id);\n-                    self.tcx.is_ty_uninhabited_from(module, scrut_ty)\n-                } else {\n-                    match scrut_ty.kind {\n-                        ty::Never => true,\n-                        ty::Adt(def, _) if def.is_enum() => {\n-                            def.variants.is_empty() && !cx.is_foreign_non_exhaustive_enum(scrut_ty)\n-                        }\n-                        _ => false,\n-                    }\n-                };\n-                if scrutinee_is_visibly_uninhabited {\n-                    // If the type *is* uninhabited, it's vacuously exhaustive.\n-                    // This early return is only needed here because in the absence of the\n-                    // `exhaustive_patterns` feature, empty matches are not detected by `is_useful`\n-                    // to exhaustively match uninhabited types.\n-                    return;\n-                } else {\n-                    // We know the type is inhabited, so this must be wrong\n-                    let (def_span, non_empty_enum) = match scrut_ty.kind {\n-                        ty::Adt(def, _) if def.is_enum() => {\n-                            (self.tcx.hir().span_if_local(def.did), !def.variants.is_empty())\n-                        }\n-                        _ => (None, false),\n-                    };\n-\n-                    if non_empty_enum {\n-                        // Continue to the normal code path to display missing variants.\n-                    } else {\n-                        let mut err = create_e0004(\n-                            self.tcx.sess,\n-                            scrut.span,\n-                            format!(\"non-exhaustive patterns: type `{}` is non-empty\", scrut_ty),\n-                        );\n-                        err.help(\n-                            \"ensure that all possible cases are being handled, \\\n-                             possibly by adding wildcards or more match arms\",\n-                        );\n-                        if let Some(sp) = def_span {\n-                            err.span_label(sp, format!(\"`{}` defined here\", scrut_ty));\n-                        }\n-                        err.emit();\n-                        return;\n-                    }\n-                }\n-            }\n-\n             // Fifth, check if the match is exhaustive.\n-            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id);\n+            let scrut_ty = self.tables.node_type(scrut.hir_id);\n+            let is_empty_match = inlined_arms.is_empty();\n+            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id, is_empty_match);\n         })\n     }\n \n@@ -483,7 +433,60 @@ fn check_exhaustive<'p, 'tcx>(\n     sp: Span,\n     matrix: &Matrix<'p, 'tcx>,\n     hir_id: HirId,\n+    is_empty_match: bool,\n ) {\n+    // If the match has no arms, check whether the scrutinee is uninhabited.\n+    // Note: An empty match isn't the same as an empty matrix for diagnostics purposes, since an\n+    // empty matrix can occur when there are arms, if those arms all have guards.\n+    if is_empty_match {\n+        let scrutinee_is_visibly_uninhabited = if cx.tcx.features().exhaustive_patterns {\n+            let module = cx.tcx.hir().get_module_parent(hir_id);\n+            cx.tcx.is_ty_uninhabited_from(module, scrut_ty)\n+        } else {\n+            match scrut_ty.kind {\n+                ty::Never => true,\n+                ty::Adt(def, _) if def.is_enum() => {\n+                    def.variants.is_empty() && !cx.is_foreign_non_exhaustive_enum(scrut_ty)\n+                }\n+                _ => false,\n+            }\n+        };\n+        if scrutinee_is_visibly_uninhabited {\n+            // If the type *is* uninhabited, it's vacuously exhaustive.\n+            // This early return is only needed here because in the absence of the\n+            // `exhaustive_patterns` feature, empty matches are not detected by `is_useful`\n+            // to exhaustively match uninhabited types.\n+            return;\n+        } else {\n+            // We know the type is inhabited, so this must be wrong\n+            let (def_span, non_empty_enum) = match scrut_ty.kind {\n+                ty::Adt(def, _) if def.is_enum() => {\n+                    (cx.tcx.hir().span_if_local(def.did), !def.variants.is_empty())\n+                }\n+                _ => (None, false),\n+            };\n+\n+            if non_empty_enum {\n+                // Continue to the normal code path to display missing variants.\n+            } else {\n+                let mut err = create_e0004(\n+                    cx.tcx.sess,\n+                    sp,\n+                    format!(\"non-exhaustive patterns: type `{}` is non-empty\", scrut_ty),\n+                );\n+                err.help(\n+                    \"ensure that all possible cases are being handled, \\\n+                     possibly by adding wildcards or more match arms\",\n+                );\n+                if let Some(sp) = def_span {\n+                    err.span_label(sp, format!(\"`{}` defined here\", scrut_ty));\n+                }\n+                err.emit();\n+                return;\n+            }\n+        }\n+    }\n+\n     let witnesses = match check_not_useful(cx, scrut_ty, matrix, hir_id) {\n         Ok(_) => return,\n         Err(err) => err,"}]}