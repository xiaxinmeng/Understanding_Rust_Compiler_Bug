{"sha": "83fbfb95c03d2cb3dee8b1adf9e24687b2cdf99a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZmJmYjk1YzAzZDJjYjNkZWU4YjFhZGY5ZTI0Njg3YjJjZGY5OWE=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-02-28T07:07:03Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-02-28T07:07:03Z"}, "message": "WIP: Add EvalError/EvalResult and apply throughout.", "tree": {"sha": "d7369aed88c1231a5ecfb7e966739edb8b3f6c6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7369aed88c1231a5ecfb7e966739edb8b3f6c6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83fbfb95c03d2cb3dee8b1adf9e24687b2cdf99a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83fbfb95c03d2cb3dee8b1adf9e24687b2cdf99a", "html_url": "https://github.com/rust-lang/rust/commit/83fbfb95c03d2cb3dee8b1adf9e24687b2cdf99a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83fbfb95c03d2cb3dee8b1adf9e24687b2cdf99a/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "255927bc0c77d275ee176f47dd7a47001cc40b56", "url": "https://api.github.com/repos/rust-lang/rust/commits/255927bc0c77d275ee176f47dd7a47001cc40b56", "html_url": "https://github.com/rust-lang/rust/commit/255927bc0c77d275ee176f47dd7a47001cc40b56"}], "stats": {"total": 60, "additions": 44, "deletions": 16}, "files": [{"sha": "5284cd62998af163c4b993d4d5af1651940f2649", "filename": "src/interpreter.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/83fbfb95c03d2cb3dee8b1adf9e24687b2cdf99a/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83fbfb95c03d2cb3dee8b1adf9e24687b2cdf99a/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=83fbfb95c03d2cb3dee8b1adf9e24687b2cdf99a", "patch": "@@ -8,11 +8,12 @@ use rustc::middle::cstore::CrateStore;\n use rustc::mir::repr::{self as mir, Mir};\n use rustc::mir::mir_map::MirMap;\n use std::collections::HashMap;\n+use std::error::Error;\n+use std::fmt;\n+use std::iter;\n use syntax::ast::Attribute;\n use syntax::attr::AttrMetaMethods;\n \n-use std::iter;\n-\n const TRACE_EXECUTION: bool = true;\n \n mod memory {\n@@ -113,6 +114,27 @@ mod memory {\n }\n use self::memory::{Pointer, Repr, Value};\n \n+#[derive(Clone, Debug)]\n+pub struct EvalError;\n+\n+pub type EvalResult<T> = Result<T, EvalError>;\n+\n+impl Error for EvalError {\n+    fn description(&self) -> &str {\n+        \"error during MIR evaluation\"\n+    }\n+\n+    fn cause(&self) -> Option<&Error> {\n+        None\n+    }\n+}\n+\n+impl fmt::Display for EvalError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.description())\n+    }\n+}\n+\n // #[derive(Clone, Debug, PartialEq)]\n // enum Value {\n //     Uninit,\n@@ -228,7 +250,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n     //     ptr\n     // }\n \n-    fn call(&mut self, mir: &Mir, args: &[Value], return_ptr: Option<Pointer>) {\n+    fn call(&mut self, mir: &Mir, args: &[Value], return_ptr: Option<Pointer>) -> EvalResult<()> {\n         // self.push_stack_frame(mir, args, return_ptr);\n         let mut block = mir::START_BLOCK;\n \n@@ -241,8 +263,8 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n \n                 match stmt.kind {\n                     mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                        let ptr = self.lvalue_to_ptr(lvalue);\n-                        self.eval_rvalue_into(rvalue, ptr);\n+                        let ptr = try!(self.lvalue_to_ptr(lvalue));\n+                        try!(self.eval_rvalue_into(rvalue, ptr));\n                     }\n                 }\n             }\n@@ -319,18 +341,22 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         }\n \n         // self.pop_stack_frame();\n+\n+        Ok(())\n     }\n \n-    fn lvalue_to_ptr(&self, lvalue: &mir::Lvalue) -> Pointer {\n-        match *lvalue {\n+    fn lvalue_to_ptr(&self, lvalue: &mir::Lvalue) -> EvalResult<Pointer> {\n+        let ptr = match *lvalue {\n             mir::Lvalue::ReturnPointer => Pointer {\n                 alloc_id: self::memory::alloc_id_hack(0),\n                 offset: 0,\n                 repr: Repr::Int,\n             },\n \n             _ => unimplemented!(),\n-        }\n+        };\n+\n+        Ok(ptr)\n \n         // let frame = self.call_stack.last().expect(\"missing call frame\");\n \n@@ -408,22 +434,22 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         }\n     }\n \n-    fn eval_rvalue_into(&mut self, rvalue: &mir::Rvalue, out: Pointer) {\n+    fn eval_rvalue_into(&mut self, rvalue: &mir::Rvalue, out: Pointer) -> EvalResult<()> {\n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n-                let ptr = self.operand_to_ptr(operand);\n+                let ptr = try!(self.operand_to_ptr(operand));\n                 let val = self.read_pointer(ptr);\n                 self.write_pointer(out, val);\n             }\n \n             mir::Rvalue::BinaryOp(bin_op, ref left, ref right) => {\n-                let left_ptr = self.operand_to_ptr(left);\n-                let right_ptr = self.operand_to_ptr(right);\n+                let left_ptr = try!(self.operand_to_ptr(left));\n+                let right_ptr = try!(self.operand_to_ptr(right));\n                 self.eval_binary_op(bin_op, left_ptr, right_ptr, out)\n             }\n \n             mir::Rvalue::UnaryOp(un_op, ref operand) => {\n-                let ptr = self.operand_to_ptr(operand);\n+                let ptr = try!(self.operand_to_ptr(operand));\n                 let m = byteorder::NativeEndian::read_i64(&self.memory.value(ptr.alloc_id).unwrap().bytes);\n                 let n = match (un_op, ptr.repr) {\n                     (mir::UnOp::Not, Repr::Int) => !m,\n@@ -457,15 +483,17 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n \n             ref r => panic!(\"can't handle rvalue: {:?}\", r),\n         }\n+\n+        Ok(())\n     }\n \n-    fn operand_to_ptr(&mut self, op: &mir::Operand) -> Pointer {\n+    fn operand_to_ptr(&mut self, op: &mir::Operand) -> EvalResult<Pointer> {\n         match *op {\n             mir::Operand::Consume(ref lvalue) => self.lvalue_to_ptr(lvalue),\n \n             mir::Operand::Constant(ref constant) => {\n                 match constant.literal {\n-                    mir::Literal::Value { ref value } => self.const_to_ptr(value),\n+                    mir::Literal::Value { ref value } => Ok(self.const_to_ptr(value)),\n \n                     mir::Literal::Item { def_id, kind, .. } => match kind {\n                         // mir::ItemKind::Function | mir::ItemKind::Method => Value::Func(def_id),\n@@ -533,7 +561,7 @@ pub fn interpret_start_points<'tcx>(tcx: &ty::ctxt<'tcx>, mir_map: &MirMap<'tcx>\n                     }\n                     ty::FnOutput::FnDiverging => None,\n                 };\n-                interpreter.call(mir, &[], return_ptr.clone());\n+                interpreter.call(mir, &[], return_ptr.clone()).unwrap();\n \n                 let val_str = format!(\"{:?}\", interpreter.read_pointer(return_ptr.unwrap()));\n                 if !check_expected(&val_str, attr) {"}]}