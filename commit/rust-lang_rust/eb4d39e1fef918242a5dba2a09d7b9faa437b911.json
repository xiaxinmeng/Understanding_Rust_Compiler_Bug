{"sha": "eb4d39e1fef918242a5dba2a09d7b9faa437b911", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNGQzOWUxZmVmOTE4MjQyYTVkYmEyYTA5ZDdiOWZhYTQzN2I5MTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-26T00:57:39Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T18:42:45Z"}, "message": "libstd: Remove \"dual impls\" from the language and enforce coherence rules. r=brson\n\n\"Dual impls\" are impls that are both type implementations and trait\nimplementations. They can lead to ambiguity and so this patch removes them\nfrom the language.\n\nThis also enforces coherence rules. Without this patch, records can implement\ntraits not defined in the current crate. This patch fixes this, and updates\nall of rustc to adhere to the new enforcement. Most of this patch is fixing\nrustc to obey the coherence rules, which involves converting a bunch of records\nto structs.", "tree": {"sha": "92d923119a6d8f1b16d83c2214e8acf9d0dd25e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92d923119a6d8f1b16d83c2214e8acf9d0dd25e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb4d39e1fef918242a5dba2a09d7b9faa437b911", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb4d39e1fef918242a5dba2a09d7b9faa437b911", "html_url": "https://github.com/rust-lang/rust/commit/eb4d39e1fef918242a5dba2a09d7b9faa437b911", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb4d39e1fef918242a5dba2a09d7b9faa437b911/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1e78c6dd7dc41a9937c466a7af5d0efc779909f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1e78c6dd7dc41a9937c466a7af5d0efc779909f", "html_url": "https://github.com/rust-lang/rust/commit/f1e78c6dd7dc41a9937c466a7af5d0efc779909f"}], "stats": {"total": 1541, "additions": 704, "deletions": 837}, "files": [{"sha": "4e69947ac67b4345ed000248f71e4877e1f0da50", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -42,6 +42,7 @@ with destructors.\n #[allow(structural_records)];\n \n use cast;\n+use container::{Container, Mutable, Map, Set};\n use io;\n use libc::{size_t, uintptr_t};\n use option::{None, Option, Some};"}, {"sha": "df98e469bbcffb359c02077a7b607088e85c8c2c", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -16,7 +16,6 @@\n \n use cmp::Eq;\n use hash::Hash;\n-use prelude::*;\n use to_bytes::IterBytes;\n \n /// Open addressing with linear probing.\n@@ -464,6 +463,7 @@ pub mod linear {\n \n #[test]\n pub mod test {\n+    use container::{Container, Mutable, Map, Set};\n     use option::{None, Some};\n     use hashmap::linear::LinearMap;\n     use hashmap::linear;"}, {"sha": "6eb22e53a2413be1aaf7b563f7d61e2c53c33cd3", "filename": "src/libcore/num.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -23,6 +23,11 @@ pub trait Num {\n     static pure fn from_int(n: int) -> self;\n }\n \n+pub trait IntConvertible {\n+    pure fn to_int(&self) -> int;\n+    static pure fn from_int(n: int) -> self;\n+}\n+\n pub trait Zero {\n     static pure fn zero() -> self;\n }"}, {"sha": "33826d10c3c0c4b2a29b509804c8eb490fa5c9a0", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -96,10 +96,9 @@ use either::{Either, Left, Right};\n use kinds::Owned;\n use libc;\n use option;\n-use option::unwrap;\n+use option::{None, Option, Some, unwrap};\n use pipes;\n use ptr;\n-use prelude::*;\n use private;\n use task;\n use vec;"}, {"sha": "d3813d1ae852e1d9f50168630fb69d6e3ab7e632", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -35,6 +35,8 @@ pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n pub use vec::{OwnedVector, OwnedCopyableVector};\n pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n+pub use container::{Container, Mutable, Map, Set};\n+pub use pipes::{GenericChan, GenericPort};\n \n pub use num::Num;\n pub use ptr::Ptr;"}, {"sha": "573a3e54b444bdc21a514e85944a69b53b0e5880", "filename": "src/libcore/private/weak_task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Fprivate%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Fprivate%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fweak_task.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -22,7 +22,7 @@ use option::{Some, None, swap_unwrap};\n use private::at_exit::at_exit;\n use private::global::global_data_clone_create;\n use private::finally::Finally;\n-use pipes::{Port, Chan, SharedChan, stream};\n+use pipes::{Port, Chan, SharedChan, GenericSmartChan, stream};\n use task::{Task, task, spawn};\n use task::rt::{task_id, get_task_id};\n use hashmap::linear::LinearMap;"}, {"sha": "9ddafee6938986249cfb17338479877a93439cb8", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -45,7 +45,7 @@ use iter;\n use libc;\n use option;\n use result::Result;\n-use pipes::{stream, Chan, Port, SharedChan};\n+use pipes::{stream, Chan, GenericChan, GenericPort, Port, SharedChan};\n use pipes;\n use prelude::*;\n use ptr;"}, {"sha": "0a2f6634214e660dfadf306c59176ee4a16b2e15", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -74,8 +74,10 @@\n #[warn(deprecated_mode)];\n \n use cast;\n+use container::Map;\n+use oldcomm;\n use option;\n-use pipes::{stream, Chan, Port};\n+use pipes::{Chan, GenericChan, GenericPort, Port};\n use pipes;\n use prelude::*;\n use private;"}, {"sha": "399184ea8a5867e59338ab815251be97a00cfd89", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -37,6 +37,7 @@ use core::to_bytes::IterBytes;\n use core::uint;\n use core::vec;\n use std::map::HashMap;\n+use std::serialize::Encodable;\n use std::{ebml, map};\n use std;\n use syntax::ast::*;"}, {"sha": "787a1d3c906c22e9f6ba3370c3d198215ac233d5", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -17,7 +17,8 @@\n use core::prelude::*;\n \n use middle::ty;\n-use middle::ty::{FnTyBase, FnMeta, FnSig};\n+use middle::ty::{FnTyBase, FnMeta, FnSig, arg, creader_cache_key, field};\n+use middle::ty::{substs};\n \n use core::io;\n use core::str;\n@@ -174,9 +175,11 @@ fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n     while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n     st.pos = st.pos + 1u;\n \n-    return {self_r: self_r,\n-         self_ty: self_ty,\n-         tps: params};\n+    return substs {\n+        self_r: self_r,\n+        self_ty: self_ty,\n+        tps: params\n+    };\n }\n \n fn parse_bound_region(st: @pstate) -> ty::bound_region {\n@@ -308,7 +311,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         let mut fields: ~[ty::field] = ~[];\n         while peek(st) != ']' {\n             let name = st.tcx.sess.ident_of(parse_str(st, '='));\n-            fields.push({ident: name, mt: parse_mt(st, conv)});\n+            fields.push(ty::field { ident: name, mt: parse_mt(st, conv) });\n         }\n         st.pos = st.pos + 1u;\n         return ty::mk_rec(st.tcx, fields);\n@@ -333,12 +336,13 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         assert (next(st) == ':');\n         let len = parse_hex(st);\n         assert (next(st) == '#');\n-        match st.tcx.rcache.find({cnum: st.crate, pos: pos, len: len}) {\n+        let key = creader_cache_key { cnum: st.crate, pos: pos, len: len };\n+        match st.tcx.rcache.find(key) {\n           Some(tt) => return tt,\n           None => {\n             let ps = @{pos: pos ,.. copy *st};\n             let tt = parse_ty(ps, conv);\n-            st.tcx.rcache.insert({cnum: st.crate, pos: pos, len: len}, tt);\n+            st.tcx.rcache.insert(key, tt);\n             return tt;\n           }\n         }\n@@ -421,8 +425,7 @@ fn parse_onceness(c: char) -> ast::Onceness {\n }\n \n fn parse_arg(st: @pstate, conv: conv_did) -> ty::arg {\n-    {mode: parse_mode(st),\n-     ty: parse_ty(st, conv)}\n+    ty::arg { mode: parse_mode(st), ty: parse_ty(st, conv) }\n }\n \n fn parse_mode(st: @pstate) -> ast::mode {\n@@ -446,7 +449,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::FnTy {\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n         let mode = parse_mode(st);\n-        inputs.push({mode: mode, ty: parse_ty(st, conv)});\n+        inputs.push(ty::arg { mode: mode, ty: parse_ty(st, conv) });\n     }\n     st.pos += 1u; // eat the ']'\n     let ret_ty = parse_ty(st, conv);"}, {"sha": "04e833d812bd725154a1d10c25dc5987321c2582", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -13,8 +13,8 @@\n \n use core::prelude::*;\n \n+use middle::ty::{Vid, param_ty};\n use middle::ty;\n-use middle::ty::Vid;\n \n use core::io::WriterUtil;\n use core::io;\n@@ -301,7 +301,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n       ty::ty_infer(_) => {\n         cx.diag.handler().bug(~\"Cannot encode inference variable types\");\n       }\n-      ty::ty_param({idx: id, def_id: did}) => {\n+      ty::ty_param(param_ty {idx: id, def_id: did}) => {\n         w.write_char('p');\n         w.write_str((cx.ds)(did));\n         w.write_char('|');"}, {"sha": "bdb889b68f116046577a85f375f4a065474ed786", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -20,7 +20,7 @@\n use core::prelude::*;\n \n use middle::borrowck::{Loan, bckerr, borrowck_ctxt, cmt, inherent_mutability};\n-use middle::borrowck::{req_maps, save_and_restore};\n+use middle::borrowck::{req_maps, root_map_key, save_and_restore};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n use middle::mem_categorization::{cat_local, cat_rvalue, cat_self};\n use middle::mem_categorization::{cat_special, gc_ptr, loan_path, lp_arg};\n@@ -396,7 +396,10 @@ impl check_loan_ctxt {\n \n                 match ptr_kind {\n                     gc_ptr(ast::m_mutbl) => {\n-                        let key = { id: base.id, derefs: deref_count };\n+                        let key = root_map_key {\n+                            id: base.id,\n+                            derefs: deref_count\n+                        };\n                         self.bccx.write_guard_map.insert(key, ());\n                     }\n                     _ => {}"}, {"sha": "6f913f99e11fd7f1c8d4ed6bb56b33d8cf2ca4c5", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -19,7 +19,8 @@\n use core::prelude::*;\n \n use middle::borrowck::preserve::{preserve_condition, pc_ok, pc_if_pure};\n-use middle::borrowck::{Loan, bckres, borrowck_ctxt, err_mutbl, req_maps};\n+use middle::borrowck::{Loan, bckerr, bckres, borrowck_ctxt, err_mutbl};\n+use middle::borrowck::{req_maps};\n use middle::mem_categorization::{cat_binding, cat_discr, cmt, comp_variant};\n use middle::mem_categorization::{mem_categorization_ctxt};\n use middle::mem_categorization::{opt_deref_kind};\n@@ -452,8 +453,7 @@ impl gather_loan_ctxt {\n             debug!(\"required is const or they are the same\");\n             Ok(pc_ok)\n         } else {\n-            let e = {cmt: cmt,\n-                     code: err_mutbl(req_mutbl)};\n+            let e = bckerr { cmt: cmt, code: err_mutbl(req_mutbl) };\n             if req_mutbl == m_imm {\n                 // if this is an @mut box, then it's generally OK to borrow as\n                 // &imm; this will result in a write guard"}, {"sha": "48cc0502f6c87b4e1d844375d2d66e6704cfdeec", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -43,7 +43,7 @@ XXX --- much more needed, don't have time to write this all up now\n \n use core::prelude::*;\n \n-use middle::borrowck::{Loan, bckres, borrowck_ctxt, cmt, err_mutbl};\n+use middle::borrowck::{Loan, bckerr, bckres, borrowck_ctxt, cmt, err_mutbl};\n use middle::borrowck::{err_out_of_scope};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_discr, cat_comp};\n use middle::mem_categorization::{cat_deref, cat_discr, cat_local, cat_self};\n@@ -309,8 +309,10 @@ impl LoanContext {\n                     // We do not allow non-mutable data to be loaned\n                     // out as mutable under any circumstances.\n                     if cmt.mutbl != m_mutbl {\n-                        return Err({cmt:cmt,\n-                                    code:err_mutbl(req_mutbl)});\n+                        return Err(bckerr {\n+                            cmt:cmt,\n+                            code:err_mutbl(req_mutbl)\n+                        });\n                     }\n                 }\n                 m_const | m_imm => {\n@@ -332,9 +334,10 @@ impl LoanContext {\n         } else {\n             // The loan being requested lives longer than the data\n             // being loaned out!\n-            return Err({cmt:cmt,\n-                        code:err_out_of_scope(scope_ub,\n-                                              self.scope_region)});\n+            return Err(bckerr {\n+                cmt:cmt,\n+                code:err_out_of_scope(scope_ub, self.scope_region)\n+            });\n         }\n     }\n }"}, {"sha": "2afdcc9d47d530c3947bdfe740a060b2c9232625", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -344,7 +344,11 @@ type root_map = HashMap<root_map_key, RootInfo>;\n // if you have an expression `x.f` and x has type ~@T, we could add an\n // entry {id:x, derefs:0} to refer to `x` itself, `{id:x, derefs:1}`\n // to refer to the deref of the unique pointer, and so on.\n-type root_map_key = {id: ast::node_id, derefs: uint};\n+#[deriving_eq]\n+struct root_map_key {\n+    id: ast::node_id,\n+    derefs: uint\n+}\n \n // set of ids of local vars / formal arguments that are modified / moved.\n // this is used in trans for optimization purposes.\n@@ -411,13 +415,10 @@ impl bckerr_code : cmp::Eq {\n \n // Combination of an error code and the categorization of the expression\n // that caused it\n-type bckerr = {cmt: cmt, code: bckerr_code};\n-\n-impl bckerr : cmp::Eq {\n-    pure fn eq(&self, other: &bckerr) -> bool {\n-        (*self).cmt == (*other).cmt && (*self).code == (*other).code\n-    }\n-    pure fn ne(&self, other: &bckerr) -> bool { !(*self).eq(other) }\n+#[deriving_eq]\n+struct bckerr {\n+    cmt: cmt,\n+    code: bckerr_code\n }\n \n // shorthand for something that fails with `bckerr` or succeeds with `T`\n@@ -446,15 +447,6 @@ fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T, f: fn() -> U) -> U {\n \n /// Creates and returns a new root_map\n \n-impl root_map_key : cmp::Eq {\n-    pure fn eq(&self, other: &root_map_key) -> bool {\n-        (*self).id == (*other).id && (*self).derefs == (*other).derefs\n-    }\n-    pure fn ne(&self, other: &root_map_key) -> bool {\n-        ! ((*self) == (*other))\n-    }\n-}\n-\n impl root_map_key : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n@@ -501,7 +493,7 @@ impl borrowck_ctxt {\n     }\n \n     fn cat_discr(cmt: cmt, match_id: ast::node_id) -> cmt {\n-        return @{cat:cat_discr(cmt, match_id),.. *cmt};\n+        return @cmt_ { cat: cat_discr(cmt, match_id),.. *cmt };\n     }\n \n     fn mc_ctxt() -> mem_categorization_ctxt {"}, {"sha": "5edfd294d8477692574498edaa0bcbe645bc95b8", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -18,7 +18,7 @@ use core::prelude::*;\n use middle::borrowck::{RootInfo, bckerr, bckerr_code, bckres, borrowck_ctxt};\n use middle::borrowck::{cmt, err_mut_uniq, err_mut_variant};\n use middle::borrowck::{err_out_of_root_scope, err_out_of_scope};\n-use middle::borrowck::{err_root_not_permitted};\n+use middle::borrowck::{err_root_not_permitted, root_map_key};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n use middle::mem_categorization::{cat_discr, cat_local, cat_self, cat_special};\n use middle::mem_categorization::{cat_stack_upvar, comp_field, comp_index};\n@@ -291,7 +291,7 @@ priv impl &preserve_ctxt {\n           Ok(pc_ok) => {\n             match cmt_base.mutbl {\n               m_mutbl | m_const => {\n-                Ok(pc_if_pure({cmt:cmt, code:code}))\n+                Ok(pc_if_pure(bckerr { cmt: cmt, code: code }))\n               }\n               m_imm => {\n                 Ok(pc_ok)\n@@ -318,8 +318,10 @@ priv impl &preserve_ctxt {\n         if self.bccx.is_subregion_of(self.scope_region, scope_ub) {\n             Ok(pc_ok)\n         } else {\n-            Err({cmt:cmt, code:err_out_of_scope(scope_ub,\n-                                                self.scope_region)})\n+            Err(bckerr {\n+                cmt:cmt,\n+                code:err_out_of_scope(scope_ub, self.scope_region)\n+            })\n         }\n     }\n \n@@ -345,7 +347,7 @@ priv impl &preserve_ctxt {\n             // would be sort of pointless to avoid rooting the inner\n             // box by rooting an outer box, as it would just keep more\n             // memory live than necessary, so we set root_ub to none.\n-            return Err({cmt:cmt, code:err_root_not_permitted});\n+            return Err(bckerr { cmt: cmt, code: err_root_not_permitted });\n         }\n \n         let root_region = ty::re_scope(self.root_ub);\n@@ -359,7 +361,7 @@ priv impl &preserve_ctxt {\n                    derefs, scope_id, self.root_ub);\n             if self.bccx.is_subregion_of(self.scope_region, root_region) {\n                 debug!(\"Elected to root\");\n-                let rk = {id: base.id, derefs: derefs};\n+                let rk = root_map_key { id: base.id, derefs: derefs };\n                 // This code could potentially lead cause boxes to be frozen\n                 // for longer than necessarily at runtime. It prevents an\n                 // ICE in trans; the fundamental problem is that it's hard\n@@ -389,17 +391,20 @@ priv impl &preserve_ctxt {\n                 return Ok(pc_ok);\n             } else {\n                 debug!(\"Unable to root\");\n-                return Err({cmt:cmt,\n-                            code:err_out_of_root_scope(root_region,\n-                                                       self.scope_region)});\n+                return Err(bckerr {\n+                    cmt: cmt,\n+                    code: err_out_of_root_scope(root_region,\n+                                                self.scope_region)\n+                });\n             }\n           }\n \n           // we won't be able to root long enough\n           _ => {\n-              return Err({cmt:cmt,\n-                          code:err_out_of_root_scope(root_region,\n-                                                     self.scope_region)});\n+              return Err(bckerr {\n+                cmt:cmt,\n+                code:err_out_of_root_scope(root_region, self.scope_region)\n+              });\n           }\n \n         }"}, {"sha": "9ea03440ad6b43db9da8399d0cbdf89d6af11ff1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 145, "deletions": 75, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -113,27 +113,18 @@ enum special_kind {\n // which the value is stored.\n //\n // note: cmt stands for \"categorized mutable type\".\n-type cmt_ = {id: ast::node_id,        // id of expr/pat producing this value\n-             span: span,              // span of same expr/pat\n-             cat: categorization,     // categorization of expr\n-             lp: Option<@loan_path>,  // loan path for expr, if any\n-             mutbl: ast::mutability,  // mutability of expr as lvalue\n-             ty: ty::t};              // type of the expr\n+#[deriving_eq]\n+struct cmt_ {\n+    id: ast::node_id,        // id of expr/pat producing this value\n+    span: span,              // span of same expr/pat\n+    cat: categorization,     // categorization of expr\n+    lp: Option<@loan_path>,  // loan path for expr, if any\n+    mutbl: ast::mutability,  // mutability of expr as lvalue\n+    ty: ty::t                // type of the expr\n+}\n \n type cmt = @cmt_;\n \n-impl cmt_ : cmp::Eq {\n-    pure fn eq(&self, other: &cmt_) -> bool {\n-        (*self).id == (*other).id &&\n-        (*self).span == (*other).span &&\n-        (*self).cat == (*other).cat &&\n-        (*self).lp == (*other).lp &&\n-        (*self).mutbl == (*other).mutbl &&\n-        (*self).ty == (*other).ty\n-    }\n-    pure fn ne(&self, other: &cmt_) -> bool { !(*self).eq(other) }\n-}\n-\n // a loan path is like a category, but it exists only when the data is\n // interior to the stack frame.  loan paths are used as the key to a\n // map indicating what is borrowed at any point in time.\n@@ -423,9 +414,14 @@ impl &mem_categorization_ctxt {\n           ast::def_ty_param(*) | ast::def_struct(*) |\n           ast::def_typaram_binder(*) | ast::def_region(_) |\n           ast::def_label(_) | ast::def_self_ty(*) => {\n-            @{id:id, span:span,\n-              cat:cat_special(sk_static_item), lp:None,\n-              mutbl:m_imm, ty:expr_ty}\n+            @cmt_ {\n+                id:id,\n+                span:span,\n+                cat:cat_special(sk_static_item),\n+                lp:None,\n+                mutbl:m_imm,\n+                ty:expr_ty\n+            }\n           }\n \n           ast::def_arg(vid, mode, mutbl) => {\n@@ -451,9 +447,14 @@ impl &mem_categorization_ctxt {\n                 None\n               }\n             };\n-            @{id:id, span:span,\n-              cat:cat_arg(vid), lp:lp,\n-              mutbl:m, ty:expr_ty}\n+            @cmt_ {\n+                id:id,\n+                span:span,\n+                cat:cat_arg(vid),\n+                lp:lp,\n+                mutbl:m,\n+                ty:expr_ty\n+            }\n           }\n \n           ast::def_self(self_id, is_implicit) => {\n@@ -466,9 +467,14 @@ impl &mem_categorization_ctxt {\n                 loan_path = Some(@lp_self);\n             };\n \n-            @{id:id, span:span,\n-              cat:cat, lp:loan_path,\n-              mutbl:m_imm, ty:expr_ty}\n+            @cmt_ {\n+                id:id,\n+                span:span,\n+                cat:cat,\n+                lp:loan_path,\n+                mutbl:m_imm,\n+                ty:expr_ty\n+            }\n           }\n \n           ast::def_upvar(_, inner, fn_node_id, _) => {\n@@ -477,15 +483,25 @@ impl &mem_categorization_ctxt {\n             match proto {\n                 ast::ProtoBorrowed => {\n                     let upcmt = self.cat_def(id, span, expr_ty, *inner);\n-                    @{id:id, span:span,\n-                      cat:cat_stack_upvar(upcmt), lp:upcmt.lp,\n-                      mutbl:upcmt.mutbl, ty:upcmt.ty}\n+                    @cmt_ {\n+                        id:id,\n+                        span:span,\n+                        cat:cat_stack_upvar(upcmt),\n+                        lp:upcmt.lp,\n+                        mutbl:upcmt.mutbl,\n+                        ty:upcmt.ty\n+                    }\n                 }\n                 ast::ProtoUniq | ast::ProtoBox => {\n                     // FIXME #2152 allow mutation of moved upvars\n-                    @{id:id, span:span,\n-                      cat:cat_special(sk_heap_upvar), lp:None,\n-                      mutbl:m_imm, ty:expr_ty}\n+                    @cmt_ {\n+                        id:id,\n+                        span:span,\n+                        cat:cat_special(sk_heap_upvar),\n+                        lp:None,\n+                        mutbl:m_imm,\n+                        ty:expr_ty\n+                    }\n                 }\n                 ast::ProtoBare => {\n                     self.tcx.sess.span_bug(\n@@ -497,34 +513,52 @@ impl &mem_categorization_ctxt {\n \n           ast::def_local(vid, mutbl) => {\n             let m = if mutbl {m_mutbl} else {m_imm};\n-            @{id:id, span:span,\n-              cat:cat_local(vid), lp:Some(@lp_local(vid)),\n-              mutbl:m, ty:expr_ty}\n+            @cmt_ {\n+                id:id,\n+                span:span,\n+                cat:cat_local(vid),\n+                lp:Some(@lp_local(vid)),\n+                mutbl:m,\n+                ty:expr_ty\n+            }\n           }\n \n           ast::def_binding(vid, _) => {\n             // by-value/by-ref bindings are local variables\n-            @{id:id, span:span,\n-              cat:cat_local(vid), lp:Some(@lp_local(vid)),\n-              mutbl:m_imm, ty:expr_ty}\n+            @cmt_ {\n+                id:id,\n+                span:span,\n+                cat:cat_local(vid),\n+                lp:Some(@lp_local(vid)),\n+                mutbl:m_imm,\n+                ty:expr_ty\n+            }\n           }\n         }\n     }\n \n     fn cat_variant<N: ast_node>(arg: N,\n                                 enum_did: ast::def_id,\n                                 cmt: cmt) -> cmt {\n-        @{id: arg.id(), span: arg.span(),\n-          cat: cat_comp(cmt, comp_variant(enum_did)),\n-          lp: cmt.lp.map(|l| @lp_comp(*l, comp_variant(enum_did)) ),\n-          mutbl: cmt.mutbl, // imm iff in an immutable context\n-          ty: self.tcx.ty(arg)}\n+        @cmt_ {\n+            id: arg.id(),\n+            span: arg.span(),\n+            cat: cat_comp(cmt, comp_variant(enum_did)),\n+            lp: cmt.lp.map(|l| @lp_comp(*l, comp_variant(enum_did)) ),\n+            mutbl: cmt.mutbl, // imm iff in an immutable context\n+            ty: self.tcx.ty(arg)\n+        }\n     }\n \n     fn cat_rvalue<N: ast_node>(elt: N, expr_ty: ty::t) -> cmt {\n-        @{id:elt.id(), span:elt.span(),\n-          cat:cat_rvalue, lp:None,\n-          mutbl:m_imm, ty:expr_ty}\n+        @cmt_ {\n+            id:elt.id(),\n+            span:elt.span(),\n+            cat:cat_rvalue,\n+            lp:None,\n+            mutbl:m_imm,\n+            ty:expr_ty\n+        }\n     }\n \n     /// inherited mutability: used in cases where the mutability of a\n@@ -559,9 +593,14 @@ impl &mem_categorization_ctxt {\n         let m = self.inherited_mutability(base_cmt.mutbl, f_mutbl);\n         let f_comp = comp_field(f_name, f_mutbl);\n         let lp = base_cmt.lp.map(|lp| @lp_comp(*lp, f_comp) );\n-        @{id: node.id(), span: node.span(),\n-          cat: cat_comp(base_cmt, f_comp), lp:lp,\n-          mutbl: m, ty: self.tcx.ty(node)}\n+        @cmt_ {\n+            id: node.id(),\n+            span: node.span(),\n+            cat: cat_comp(base_cmt, f_comp),\n+            lp:lp,\n+            mutbl: m,\n+            ty: self.tcx.ty(node)\n+        }\n     }\n \n     fn cat_deref_fn<N:ast_node>(node: N,\n@@ -628,17 +667,27 @@ impl &mem_categorization_ctxt {\n                     }\n                 };\n \n-                @{id:node.id(), span:node.span(),\n-                  cat:cat_deref(base_cmt, deref_cnt, ptr), lp:lp,\n-                  mutbl:m, ty:mt.ty}\n+                @cmt_ {\n+                    id:node.id(),\n+                    span:node.span(),\n+                    cat:cat_deref(base_cmt, deref_cnt, ptr),\n+                    lp:lp,\n+                    mutbl:m,\n+                    ty:mt.ty\n+                }\n             }\n \n             deref_comp(comp) => {\n                 let lp = base_cmt.lp.map(|l| @lp_comp(*l, comp) );\n                 let m = self.inherited_mutability(base_cmt.mutbl, mt.mutbl);\n-                @{id:node.id(), span:node.span(),\n-                  cat:cat_comp(base_cmt, comp), lp:lp,\n-                  mutbl:m, ty:mt.ty}\n+                @cmt_ {\n+                    id:node.id(),\n+                    span:node.span(),\n+                    cat:cat_comp(base_cmt, comp),\n+                    lp:lp,\n+                    mutbl:m,\n+                    ty:mt.ty\n+                }\n             }\n         }\n     }\n@@ -675,9 +724,14 @@ impl &mem_categorization_ctxt {\n             };\n \n             // (c) the deref is explicit in the resulting cmt\n-            let deref_cmt = @{id:elt.id(), span:elt.span(),\n-              cat:cat_deref(base_cmt, 0u, ptr), lp:deref_lp,\n-              mutbl:m, ty:mt.ty};\n+            let deref_cmt = @cmt_ {\n+                id:elt.id(),\n+                span:elt.span(),\n+                cat:cat_deref(base_cmt, 0u, ptr),\n+                lp:deref_lp,\n+                mutbl:m,\n+                ty:mt.ty\n+            };\n \n             comp(elt, deref_cmt, base_cmt.ty, m, mt.ty)\n           }\n@@ -695,32 +749,48 @@ impl &mem_categorization_ctxt {\n         {\n             let comp = comp_index(vect, mutbl);\n             let index_lp = of_cmt.lp.map(|lp| @lp_comp(*lp, comp) );\n-            @{id:elt.id(), span:elt.span(),\n-              cat:cat_comp(of_cmt, comp), lp:index_lp,\n-              mutbl:mutbl, ty:ty}\n+            @cmt_ {\n+                id:elt.id(),\n+                span:elt.span(),\n+                cat:cat_comp(of_cmt, comp),\n+                lp:index_lp,\n+                mutbl:mutbl,\n+                ty:ty\n+            }\n         }\n     }\n \n     fn cat_tuple_elt<N: ast_node>(elt: N, cmt: cmt) -> cmt {\n-        @{id: elt.id(), span: elt.span(),\n-          cat: cat_comp(cmt, comp_tuple),\n-          lp: cmt.lp.map(|l| @lp_comp(*l, comp_tuple) ),\n-          mutbl: cmt.mutbl, // imm iff in an immutable context\n-          ty: self.tcx.ty(elt)}\n+        @cmt_ {\n+            id: elt.id(),\n+            span: elt.span(),\n+            cat: cat_comp(cmt, comp_tuple),\n+            lp: cmt.lp.map(|l| @lp_comp(*l, comp_tuple) ),\n+            mutbl: cmt.mutbl, // imm iff in an immutable context\n+            ty: self.tcx.ty(elt)\n+        }\n     }\n \n     fn cat_anon_struct_field<N: ast_node>(elt: N, cmt: cmt) -> cmt {\n-        @{id: elt.id(), span: elt.span(),\n-          cat: cat_comp(cmt, comp_anon_field),\n-          lp: cmt.lp.map(|l| @lp_comp(*l, comp_anon_field)),\n-          mutbl: cmt.mutbl, // imm iff in an immutable context\n-          ty: self.tcx.ty(elt)}\n+        @cmt_ {\n+            id: elt.id(),\n+            span: elt.span(),\n+            cat: cat_comp(cmt, comp_anon_field),\n+            lp: cmt.lp.map(|l| @lp_comp(*l, comp_anon_field)),\n+            mutbl: cmt.mutbl, // imm iff in an immutable context\n+            ty: self.tcx.ty(elt)\n+        }\n     }\n \n     fn cat_method_ref(expr: @ast::expr, expr_ty: ty::t) -> cmt {\n-        @{id:expr.id, span:expr.span,\n-          cat:cat_special(sk_method), lp:None,\n-          mutbl:m_imm, ty:expr_ty}\n+        @cmt_ {\n+            id:expr.id,\n+            span:expr.span,\n+            cat:cat_special(sk_method),\n+            lp:None,\n+            mutbl:m_imm,\n+            ty:expr_ty\n+        }\n     }\n \n     fn cat_pattern(cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {"}, {"sha": "ac3a16b07a0b16dbc5f66e2a237f4d01138557d6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -397,17 +397,15 @@ fn resolve_crate(sess: Session, def_map: resolve::DefMap,\n // dependencies until a fixed point is reached.\n \n type region_paramd_items = HashMap<ast::node_id, region_variance>;\n-type region_dep = {ambient_variance: region_variance, id: ast::node_id};\n-type dep_map = HashMap<ast::node_id, @DVec<region_dep>>;\n \n-impl region_dep : cmp::Eq {\n-    pure fn eq(&self, other: &region_dep) -> bool {\n-        (*self).ambient_variance == (*other).ambient_variance &&\n-        (*self).id == (*other).id\n-    }\n-    pure fn ne(&self, other: &region_dep) -> bool { !(*self).eq(other) }\n+#[deriving_eq]\n+struct region_dep {\n+    ambient_variance: region_variance,\n+    id: ast::node_id\n }\n \n+type dep_map = HashMap<ast::node_id, @DVec<region_dep>>;\n+\n type determine_rp_ctxt_ = {\n     sess: Session,\n     ast_map: ast_map::map,\n@@ -511,7 +509,10 @@ impl determine_rp_ctxt {\n                 vec\n             }\n         };\n-        let dep = {ambient_variance: self.ambient_variance, id: self.item_id};\n+        let dep = region_dep {\n+            ambient_variance: self.ambient_variance,\n+            id: self.item_id\n+        };\n         if !vec.contains(&dep) { vec.push(dep); }\n     }\n "}, {"sha": "084f0ba421e085558f83dbf2158ccfc3ad57cfc9", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -910,7 +910,8 @@ fn root_pats_as_necessary(bcx: block,\n     for vec::each(m) |br| {\n         let pat_id = br.pats[col].id;\n \n-        match bcx.ccx().maps.root_map.find({id:pat_id, derefs:0u}) {\n+        let key = root_map_key {id: pat_id, derefs: 0u };\n+        match bcx.ccx().maps.root_map.find(key) {\n             None => (),\n             Some(root_info) => {\n                 // Note: the scope_id will always be the id of the match.  See"}, {"sha": "f4814b4657b9787a2d56ee7be4f750629c762e7b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -61,6 +61,7 @@ use middle::trans::reachable;\n use middle::trans::shape::*;\n use middle::trans::tvec;\n use middle::trans::type_of::*;\n+use middle::ty::arg;\n use util::common::indenter;\n use util::ppaux::{ty_to_str, ty_to_short_str};\n use util::ppaux;\n@@ -2198,9 +2199,12 @@ fn create_main_wrapper(ccx: @crate_ctxt, _sp: span, main_llfn: ValueRef) {\n     fn create_main(ccx: @crate_ctxt, main_llfn: ValueRef) -> ValueRef {\n         let unit_ty = ty::mk_estr(ccx.tcx, ty::vstore_uniq);\n         let vecarg_ty: ty::arg =\n-            {mode: ast::expl(ast::by_val),\n-             ty: ty::mk_evec(ccx.tcx, ty::mt {ty: unit_ty, mutbl: ast::m_imm},\n-                             ty::vstore_uniq)};\n+            arg {\n+                mode: ast::expl(ast::by_val),\n+                ty: ty::mk_evec(ccx.tcx,\n+                    ty::mt {ty: unit_ty, mutbl: ast::m_imm},\n+                    ty::vstore_uniq)\n+            };\n         let nt = ty::mk_nil(ccx.tcx);\n         let llfty = type_of_fn(ccx, ~[vecarg_ty], nt);\n         let llfdecl = decl_fn(ccx.llmod, ~\"_rust_main\","}, {"sha": "3babfbd8285fd1d48e8830be08c4385ee932fe21", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -39,6 +39,7 @@ use middle::trans::reachable;\n use middle::trans::shape;\n use middle::trans::type_of;\n use middle::trans::type_use;\n+use middle::ty::substs;\n use middle::ty;\n use middle::typeck;\n use util::ppaux::{expr_repr, ty_to_str};\n@@ -1459,9 +1460,11 @@ fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n }\n \n fn dummy_substs(+tps: ~[ty::t]) -> ty::substs {\n-    {self_r: Some(ty::re_bound(ty::br_self)),\n-     self_ty: None,\n-     tps: tps}\n+    substs {\n+        self_r: Some(ty::re_bound(ty::br_self)),\n+        self_ty: None,\n+        tps: tps\n+    }\n }\n \n fn struct_field(index: uint) -> [uint * 3] {"}, {"sha": "94145be2a1e317c4110196990a430931c1f7d27e", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -98,7 +98,7 @@\n use core::prelude::*;\n \n use lib::llvm::ValueRef;\n-use middle::borrowck::RootInfo;\n+use middle::borrowck::{RootInfo, root_map_key};\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -652,7 +652,7 @@ impl Datum {\n         // root the autoderef'd value, if necessary:\n         //\n         // (Note: root'd values are always boxes)\n-        let key = {id:expr_id, derefs:derefs};\n+        let key = root_map_key { id: expr_id, derefs: derefs };\n         let bcx = match ccx.maps.root_map.find(key) {\n             None => bcx,\n             Some(root_info) => self.root(bcx, root_info)"}, {"sha": "24d8e94abbdbaecb5a70f4d4284c1ef4fd97df37", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -114,6 +114,7 @@ lvalues are *never* stored by value.\n use core::prelude::*;\n \n use lib::llvm::ValueRef;\n+use middle::borrowck::root_map_key;\n use middle::resolve;\n use middle::trans::base::*;\n use middle::trans::callee::{AutorefArg, DoAutorefArg, DontAutorefArg};\n@@ -757,7 +758,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     // If the lvalue must remain rooted, create a scratch datum, copy\n     // the lvalue in there, and then arrange for it to be cleaned up\n     // at the end of the scope with id `scope_id`:\n-    let root_key = {id:expr.id, derefs:0u};\n+    let root_key = root_map_key { id: expr.id, derefs: 0u };\n     for bcx.ccx().maps.root_map.find(root_key).each |&root_info| {\n         bcx = unrooted_datum.root(bcx, root_info);\n     }"}, {"sha": "317a64ea5287502aa48aba72122b24dee9cb287b", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -31,7 +31,7 @@ use middle::trans::machine;\n use middle::trans::shape;\n use middle::trans::type_of::*;\n use middle::trans::type_of;\n-use middle::ty::{FnTyBase, FnMeta, FnSig};\n+use middle::ty::{FnTyBase, FnMeta, FnSig, arg};\n use util::ppaux::ty_to_str;\n \n use core::libc::c_uint;\n@@ -546,8 +546,8 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n                               onceness: ast::Many,\n                               region: ty::re_bound(ty::br_anon(0)),\n                               bounds: @~[]},\n-                sig: FnSig {inputs: ~[{mode: ast::expl(ast::by_val),\n-                                       ty: star_u8}],\n+                sig: FnSig {inputs: ~[arg {mode: ast::expl(ast::by_val),\n+                                           ty: star_u8}],\n                             output: ty::mk_nil(bcx.tcx())}\n             });\n             let datum = Datum {val: get_param(decl, first_real_arg),"}, {"sha": "7af3b7a06834a310fc87a27b0b0ac40c0234b95c", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -13,6 +13,7 @@\n \n use middle::trans::common::*;\n use middle::trans::type_of;\n+use middle::ty::field;\n use middle::ty;\n \n use syntax::parse::token::special_idents;\n@@ -44,13 +45,17 @@ pub fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           ty::ty_struct(did, ref substs) => {\n             let simpl_fields = (if ty::ty_dtor(tcx, did).is_present() {\n                 // remember the drop flag\n-                  ~[{ident: special_idents::dtor,\n-                     mt: ty::mt {ty: ty::mk_u8(tcx), mutbl: ast::m_mutbl}}] }\n+                  ~[field {\n+                    ident: special_idents::dtor,\n+                    mt: ty::mt {ty: ty::mk_u8(tcx), mutbl: ast::m_mutbl}\n+                   }] }\n                 else { ~[] }) +\n                 do ty::lookup_struct_fields(tcx, did).map |f| {\n                  let t = ty::lookup_field_type(tcx, did, f.id, substs);\n-                 {ident: f.ident,\n-                  mt: ty::mt {ty: simplify_type(tcx, t), mutbl: ast::m_const}}\n+                 field {\n+                    ident: f.ident,\n+                    mt: ty::mt {ty: simplify_type(tcx, t), mutbl: ast::m_const\n+                 }}\n             };\n             ty::mk_rec(tcx, simpl_fields)\n           }"}, {"sha": "a90c25abf3dd65c14cd4236804018f10c7f1b6b8", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -28,6 +28,7 @@ use middle::trans::glue;\n use middle::trans::inline;\n use middle::trans::monomorphize;\n use middle::trans::type_of::*;\n+use middle::ty::arg;\n use middle::typeck;\n use util::ppaux::{ty_to_str, tys_to_str};\n \n@@ -154,8 +155,10 @@ fn trans_self_arg(bcx: block,\n     let mut temp_cleanups = ~[];\n \n     // Compute the mode and type of self.\n-    let self_arg = {mode: mentry.self_arg.mode,\n-                    ty: monomorphize_type(bcx, mentry.self_arg.ty)};\n+    let self_arg = arg {\n+        mode: mentry.self_arg.mode,\n+        ty: monomorphize_type(bcx, mentry.self_arg.ty)\n+    };\n \n     let result = trans_arg_expr(bcx, self_arg, base,\n                                 &mut temp_cleanups, None, DontAutorefArg);"}, {"sha": "002e04ca475e4f817ecf70c75707c03ee6733f25", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 61, "deletions": 70, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -242,14 +242,23 @@ export AutoRefKind, AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn;\n export iter_bound_traits_and_supertraits;\n export count_traits_and_supertraits;\n export IntVarValue, IntType, UintType;\n+export creader_cache_key;\n \n // Data types\n \n // Note: after typeck, you should use resolved_mode() to convert this mode\n // into an rmode, which will take into account the results of mode inference.\n-type arg = {mode: ast::mode, ty: t};\n+#[deriving_eq]\n+struct arg {\n+    mode: ast::mode,\n+    ty: t\n+}\n \n-type field = {ident: ast::ident, mt: mt};\n+#[deriving_eq]\n+struct field {\n+    ident: ast::ident,\n+    mt: mt\n+}\n \n type param_bounds = @~[param_bound];\n \n@@ -292,35 +301,38 @@ pub enum ValueMode {\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-type creader_cache_key = {cnum: int, pos: uint, len: uint};\n-type creader_cache = HashMap<creader_cache_key, t>;\n-\n-impl creader_cache_key : cmp::Eq {\n-    pure fn eq(&self, other: &creader_cache_key) -> bool {\n-        (*self).cnum == (*other).cnum &&\n-            (*self).pos == (*other).pos &&\n-            (*self).len == (*other).len\n-    }\n-    pure fn ne(&self, other: &creader_cache_key) -> bool {\n-        !((*self) == (*other))\n-    }\n+#[deriving_eq]\n+struct creader_cache_key {\n+    cnum: int,\n+    pos: uint,\n+    len: uint\n }\n \n+type creader_cache = HashMap<creader_cache_key, t>;\n+\n impl creader_cache_key : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n     }\n }\n \n-type intern_key = {sty: *sty, o_def_id: Option<ast::def_id>};\n+struct intern_key {\n+    sty: *sty,\n+    o_def_id: Option<ast::def_id>\n+}\n \n+// NB: Do not replace this with #[deriving_eq]. The automatically-derived\n+// implementation will not recurse through sty and you will get stack\n+// exhaustion.\n impl intern_key : cmp::Eq {\n     pure fn eq(&self, other: &intern_key) -> bool {\n         unsafe {\n             *self.sty == *other.sty && self.o_def_id == other.o_def_id\n         }\n     }\n-    pure fn ne(&self, other: &intern_key) -> bool { !(*self).eq(other) }\n+    pure fn ne(&self, other: &intern_key) -> bool {\n+        !self.eq(other)\n+    }\n }\n \n impl intern_key : to_bytes::IterBytes {\n@@ -570,13 +582,10 @@ impl<M: to_bytes::IterBytes> FnTyBase<M> : to_bytes::IterBytes {\n \n type FnTy = FnTyBase<FnMeta>;\n \n-type param_ty = {idx: uint, def_id: def_id};\n-\n-impl param_ty : cmp::Eq {\n-    pure fn eq(&self, other: &param_ty) -> bool {\n-        (*self).idx == (*other).idx && (*self).def_id == (*other).def_id\n-    }\n-    pure fn ne(&self, other: &param_ty) -> bool { !(*self).eq(other) }\n+#[deriving_eq]\n+struct param_ty {\n+    idx: uint,\n+    def_id: def_id\n }\n \n impl param_ty : to_bytes::IterBytes {\n@@ -662,11 +671,12 @@ type opt_region = Option<Region>;\n  * - `self_ty` is the type to which `self` should be remapped, if any.  The\n  *   `self` type is rather funny in that it can only appear on traits and is\n  *   always substituted away to the implementing type for a trait. */\n-type substs = {\n+#[deriving_eq]\n+struct substs {\n     self_r: opt_region,\n     self_ty: Option<ty::t>,\n     tps: ~[t]\n-};\n+}\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n@@ -1051,7 +1061,7 @@ fn mk_t(cx: ctxt, +st: sty) -> t { mk_t_with_id(cx, st, None) }\n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n-    let key = {sty: to_unsafe_ptr(&st), o_def_id: o_def_id};\n+    let key = intern_key { sty: to_unsafe_ptr(&st), o_def_id: o_def_id };\n     match cx.interner.find(key) {\n       Some(t) => unsafe { return cast::reinterpret_cast(&t); },\n       _ => ()\n@@ -1110,7 +1120,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n \n     let t = @{sty: move st, id: cx.next_id, flags: flags, o_def_id: o_def_id};\n \n-    let key = {sty: to_unsafe_ptr(&t.sty), o_def_id: o_def_id};\n+    let key = intern_key {sty: to_unsafe_ptr(&t.sty), o_def_id: o_def_id};\n     cx.interner.insert(move key, t);\n \n     cx.next_id += 1u;\n@@ -1243,7 +1253,7 @@ fn mk_infer(cx: ctxt, +it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n fn mk_self(cx: ctxt) -> t { mk_t(cx, ty_self) }\n \n fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n-    mk_t(cx, ty_param({idx: n, def_id: k}))\n+    mk_t(cx, ty_param(param_ty { idx: n, def_id: k }))\n }\n \n fn mk_type(cx: ctxt) -> t { mk_t(cx, ty_type) }\n@@ -1359,7 +1369,7 @@ fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: fn(t) -> t) -> t {\n \n fn fold_sig(sig: &FnSig, fldop: fn(t) -> t) -> FnSig {\n     let args = do sig.inputs.map |arg| {\n-        { mode: arg.mode, ty: fldop(arg.ty) }\n+        arg { mode: arg.mode, ty: fldop(arg.ty) }\n     };\n \n     FnSig {\n@@ -1370,9 +1380,9 @@ fn fold_sig(sig: &FnSig, fldop: fn(t) -> t) -> FnSig {\n \n fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n     fn fold_substs(substs: &substs, fldop: fn(t) -> t) -> substs {\n-        {self_r: substs.self_r,\n-         self_ty: substs.self_ty.map(|t| fldop(*t)),\n-         tps: substs.tps.map(|t| fldop(*t))}\n+        substs {self_r: substs.self_r,\n+                self_ty: substs.self_ty.map(|t| fldop(*t)),\n+                tps: substs.tps.map(|t| fldop(*t))}\n     }\n \n     match /*bad*/copy *sty {\n@@ -1400,8 +1410,8 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n         ty_rec(fields) => {\n             let new_fields = do vec::map(fields) |fl| {\n                 let new_ty = fldop(fl.mt.ty);\n-                let new_mt = mt {ty: new_ty, mutbl: fl.mt.mutbl};\n-                {ident: fl.ident, mt: new_mt}\n+                let new_mt = mt { ty: new_ty, mutbl: fl.mt.mutbl };\n+                field { ident: fl.ident, mt: new_mt }\n             };\n             ty_rec(new_fields)\n         }\n@@ -1458,11 +1468,13 @@ fn fold_regions_and_ty(\n     fn fold_substs(\n         substs: &substs,\n         fldr: fn(r: Region) -> Region,\n-        fldt: fn(t: t) -> t) -> substs\n-    {\n-        {self_r: substs.self_r.map(|r| fldr(*r)),\n-         self_ty: substs.self_ty.map(|t| fldt(*t)),\n-         tps: substs.tps.map(|t| fldt(*t))}\n+        fldt: fn(t: t) -> t)\n+     -> substs {\n+        substs {\n+            self_r: substs.self_r.map(|r| fldr(*r)),\n+            self_ty: substs.self_ty.map(|t| fldt(*t)),\n+            tps: substs.tps.map(|t| fldt(*t))\n+        }\n     }\n \n     let tb = ty::get(ty);\n@@ -1678,7 +1690,7 @@ fn subst(cx: ctxt,\n // Performs substitutions on a set of substitutions (result = sup(sub)) to\n // yield a new set of substitutions. This is used in trait inheritance.\n fn subst_substs(cx: ctxt, sup: &substs, sub: &substs) -> substs {\n-    {\n+    substs {\n         self_r: sup.self_r,\n         self_ty: sup.self_ty.map(|typ| subst(cx, sub, *typ)),\n         tps: sup.tps.map(|typ| subst(cx, sub, *typ))\n@@ -4159,7 +4171,7 @@ fn struct_item_fields(cx:ctxt,\n     do lookup_struct_fields(cx, did).map |f| {\n        // consider all instance vars mut, because the\n        // constructor may mutate all vars\n-       {\n+       field {\n            ident: f.ident,\n             mt: mt {\n                 ty: lookup_field_type(cx, did, f.id, substs),\n@@ -4288,9 +4300,11 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n                 Some(_) =>\n                     // Use re_static since trans doesn't care about regions\n                     mk_enum(cx, did,\n-                     {self_r: Some(ty::re_static),\n-                      self_ty: None,\n-                      tps: /*bad*/copy (*r).tps}),\n+                     substs {\n+                        self_r: Some(ty::re_static),\n+                        self_ty: None,\n+                        tps: /*bad*/copy (*r).tps\n+                     }),\n                 None =>\n                     t\n             },\n@@ -4299,9 +4313,9 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n             match (*r).self_r {\n               Some(_) =>\n                 // Ditto.\n-                mk_struct(cx, did, {self_r: Some(ty::re_static),\n-                                    self_ty: None,\n-                                    tps: /*bad*/copy (*r).tps}),\n+                mk_struct(cx, did, substs {self_r: Some(ty::re_static),\n+                                           self_ty: None,\n+                                           tps: /*bad*/copy (*r).tps}),\n               None =>\n                 t\n             },\n@@ -4421,20 +4435,6 @@ impl mt : cmp::Eq {\n     pure fn ne(&self, other: &mt) -> bool { !(*self).eq(other) }\n }\n \n-impl arg : cmp::Eq {\n-    pure fn eq(&self, other: &arg) -> bool {\n-        (*self).mode == (*other).mode && (*self).ty == (*other).ty\n-    }\n-    pure fn ne(&self, other: &arg) -> bool { !(*self).eq(other) }\n-}\n-\n-impl field : cmp::Eq {\n-    pure fn eq(&self, other: &field) -> bool {\n-        (*self).ident == (*other).ident && (*self).mt == (*other).mt\n-    }\n-    pure fn ne(&self, other: &field) -> bool { !(*self).eq(other) }\n-}\n-\n impl vstore : cmp::Eq {\n     pure fn eq(&self, other: &vstore) -> bool {\n         match (*self) {\n@@ -4543,15 +4543,6 @@ impl bound_region : cmp::Eq {\n     pure fn ne(&self, other: &bound_region) -> bool { !(*self).eq(other) }\n }\n \n-impl substs : cmp::Eq {\n-    pure fn eq(&self, other: &substs) -> bool {\n-        (*self).self_r == (*other).self_r &&\n-        (*self).self_ty == (*other).self_ty &&\n-        (*self).tps == (*other).tps\n-    }\n-    pure fn ne(&self, other: &substs) -> bool { !(*self).eq(other) }\n-}\n-\n impl sty : cmp::Eq {\n     pure fn eq(&self, other: &sty) -> bool {\n         match (/*bad*/copy *self) {"}, {"sha": "e845904956d9540b5a98482aa0a28dc4c8a0b28f", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -55,7 +55,8 @@\n use core::prelude::*;\n \n use middle::pat_util::pat_id_map;\n-use middle::ty::{FnTyBase, FnMeta, FnSig, ty_param_substs_and_ty};\n+use middle::ty::{FnTyBase, FnMeta, FnSig, arg, field, substs};\n+use middle::ty::{ty_param_substs_and_ty};\n use middle::ty;\n use middle::typeck::check::fn_ctxt;\n use middle::typeck::collect;\n@@ -151,7 +152,7 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n     }\n     let tps = path.types.map(|a_t| ast_ty_to_ty(self, rscope, *a_t));\n \n-    let substs = {self_r:self_r, self_ty:None, tps:tps};\n+    let substs = substs {self_r:self_r, self_ty:None, tps:tps};\n     let ty = ty::subst(tcx, &substs, decl_ty);\n     {substs: substs, ty: ty}\n }\n@@ -315,7 +316,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n       ast::ty_rec(ref fields) => {\n         let flds = do (*fields).map |f| {\n             let tm = ast_mt_to_mt(self, rscope, f.node.mt);\n-            {ident: f.node.ident, mt: tm}\n+            field {ident: f.node.ident, mt: tm}\n         };\n         ty::mk_rec(tcx, flds)\n       }\n@@ -447,7 +448,7 @@ fn ty_of_arg<AC: ast_conv, RS: region_scope Copy Durable>(\n         }\n     };\n \n-    {mode: mode, ty: ty}\n+    arg {mode: mode, ty: ty}\n }\n \n type expected_tys = Option<{inputs: ~[ty::arg],"}, {"sha": "543adbd53aac819f9776b8310eae52b9321465a1", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -295,7 +295,11 @@ impl LookupContext {\n                     let self_did = self.fcx.self_info.expect(\n                         ~\"self_impl_def_id is undefined (`self` may not \\\n                           be in scope here\").def_id;\n-                    let substs = {self_r: None, self_ty: None, tps: ~[]};\n+                    let substs = substs {\n+                        self_r: None,\n+                        self_ty: None,\n+                        tps: ~[]\n+                    };\n                     self.push_inherent_candidates_from_self(\n                         self_ty, self_did, &substs);\n                 }\n@@ -392,7 +396,10 @@ impl LookupContext {\n             // impl or class (where the self type is not permitted),\n             // or from a trait type (in which case methods that refer\n             // to self are not permitted).\n-            let init_substs = {self_ty: Some(rcvr_ty), ..init_substs};\n+            let init_substs = substs {\n+                self_ty: Some(rcvr_ty),\n+                ..init_substs\n+            };\n \n             worklist.push((init_trait_ty, init_substs));\n \n@@ -416,7 +423,10 @@ impl LookupContext {\n                         &init_substs);\n \n                     // Again replacing the self type\n-                    let new_substs = {self_ty: Some(rcvr_ty), ..new_substs};\n+                    let new_substs = substs {\n+                        self_ty: Some(rcvr_ty),\n+                        ..new_substs\n+                    };\n \n                     worklist.push((supertrait.tpt.ty, new_substs));\n                 }\n@@ -506,7 +516,10 @@ impl LookupContext {\n         // `trait_ty` for `self` here, because it allows the compiler\n         // to soldier on.  An error will be reported should this\n         // candidate be selected if the method refers to `self`.\n-        let rcvr_substs = {self_ty: Some(self_ty), ../*bad*/copy *substs};\n+        let rcvr_substs = substs {\n+            self_ty: Some(self_ty),\n+            ../*bad*/copy *substs\n+        };\n \n         let (rcvr_ty, rcvr_substs) =\n             self.create_rcvr_ty_and_substs_for_method(method.self_ty,\n@@ -537,7 +550,10 @@ impl LookupContext {\n         }\n         let method = &methods[index];\n \n-        let rcvr_substs = { self_ty: Some(self_ty), ../*bad*/copy *substs };\n+        let rcvr_substs = substs {\n+            self_ty: Some(self_ty),\n+            ../*bad*/copy *substs\n+        };\n         let (rcvr_ty, rcvr_substs) =\n             self.create_rcvr_ty_and_substs_for_method(\n                 method.self_ty,\n@@ -628,7 +644,11 @@ impl LookupContext {\n                     candidate\");\n \n             // XXX: Needs to support generics.\n-            let dummy_substs = { self_r: None, self_ty: None, tps: ~[] };\n+            let dummy_substs = substs {\n+                self_r: None,\n+                self_ty: None,\n+                tps: ~[]\n+            };\n             let (impl_ty, impl_substs) =\n                 self.create_rcvr_ty_and_substs_for_method(\n                     provided_method_info.method_info.self_type,\n@@ -673,11 +693,13 @@ impl LookupContext {\n                     move self_substs\n                 }\n                 sty_region(_) => {\n-                    {self_r:\n-                         Some(self.infcx().next_region_var(\n-                             self.expr.span,\n-                             self.expr.id)),\n-                     ..self_substs}\n+                    substs {\n+                        self_r:\n+                             Some(self.infcx().next_region_var(\n+                                 self.expr.span,\n+                                 self.expr.id)),\n+                        ..self_substs\n+                    }\n                 }\n             }\n         };\n@@ -1058,15 +1080,15 @@ impl LookupContext {\n \n         // Construct the full set of type parameters for the method,\n         // which is equal to the class tps + the method tps.\n-        let all_substs = {\n+        let all_substs = substs {\n             tps: vec::append(/*bad*/copy candidate.rcvr_substs.tps,\n                              m_substs),\n             ../*bad*/copy candidate.rcvr_substs\n         };\n \n         self.fcx.write_ty_substs(self.callee_id, fty, all_substs);\n         method_map_entry {\n-            self_arg: {\n+            self_arg: arg {\n                 mode: ast::expl(candidate.self_mode),\n                 ty: candidate.rcvr_ty,\n             },"}, {"sha": "3d5f6e9d303d90d13162ef7add79162c478750db", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -84,7 +84,7 @@ use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::ty::{TyVid, Vid, FnTyBase, FnMeta, FnSig, VariantInfo_, field};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n-use middle::ty::{re_bound, br_cap_avoid};\n+use middle::ty::{re_bound, br_cap_avoid, substs, arg, param_ty};\n use middle::ty;\n use middle::typeck::astconv::{ast_conv, ast_path_to_ty};\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n@@ -1059,9 +1059,11 @@ pub fn impl_self_ty(vcx: &VtableContext,\n               {n_tps: ts.len(),\n                region_param: region_param,\n                raw_ty: ty::mk_struct(tcx, local_def(class_id),\n-                      {self_r: rscope::bound_self_region(region_param),\n-                       self_ty: None,\n-                       tps: ty::ty_params_to_tys(tcx, /*bad*/copy *ts)})}\n+                      substs {\n+                        self_r: rscope::bound_self_region(region_param),\n+                        self_ty: None,\n+                        tps: ty::ty_params_to_tys(tcx, /*bad*/copy *ts)\n+                      })}\n           }\n           _ => { tcx.sess.bug(~\"impl_self_ty: unbound item or item that \\\n                doesn't have a self_ty\"); }\n@@ -1081,7 +1083,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n     };\n     let tps = vcx.infcx.next_ty_vars(n_tps);\n \n-    let substs = {self_r: self_r, self_ty: None, tps: tps};\n+    let substs = substs { self_r: self_r, self_ty: None, tps: tps };\n     let substd_ty = ty::subst(tcx, &substs, raw_ty);\n     {substs: substs, ty: substd_ty}\n }\n@@ -1814,7 +1816,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     let self_region =\n                         bound_self_region(region_parameterized);\n \n-                    raw_type = ty::mk_struct(tcx, class_id, {\n+                    raw_type = ty::mk_struct(tcx, class_id, substs {\n                         self_r: self_region,\n                         self_ty: None,\n                         tps: ty::ty_params_to_tys(\n@@ -1840,7 +1842,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                             span,\n                                             ty::re_scope(id));\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n-        let substitutions = {\n+        let substitutions = substs {\n             self_r: self_region,\n             self_ty: None,\n             tps: type_parameters\n@@ -1897,7 +1899,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     let self_region =\n                         bound_self_region(region_parameterized);\n \n-                    raw_type = ty::mk_enum(tcx, enum_id, {\n+                    raw_type = ty::mk_enum(tcx, enum_id, substs {\n                         self_r: self_region,\n                         self_ty: None,\n                         tps: ty::ty_params_to_tys(\n@@ -1923,7 +1925,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                             span,\n                                             ty::re_scope(id));\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n-        let substitutions = {\n+        let substitutions = substs {\n             self_r: self_region,\n             self_ty: None,\n             tps: type_parameters\n@@ -2434,7 +2436,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             let expr_mt = ty::mt {ty: expr_t, mutbl: f.node.mutbl};\n             // for the most precise error message,\n             // should be f.node.expr.span, not f.span\n-            respan(f.node.expr.span, {ident: f.node.ident, mt: expr_mt})\n+            respan(f.node.expr.span, field {ident: f.node.ident, mt: expr_mt})\n         });\n         match base {\n           None => {\n@@ -2951,7 +2953,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n         pth.types.map(|aty| fcx.to_ty(*aty))\n     };\n \n-    let substs = {self_r: self_r, self_ty: None, tps: tps};\n+    let substs = substs { self_r: self_r, self_ty: None, tps: tps };\n     fcx.write_ty_substs(node_id, tpt.ty, substs);\n \n     debug!(\"<<<\");\n@@ -3050,7 +3052,7 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n         |_r| {},\n         |t| {\n             match ty::get(t).sty {\n-              ty::ty_param({idx, _}) => {\n+              ty::ty_param(param_ty {idx, _}) => {\n                   debug!(\"Found use of ty param #%u\", idx);\n                   tps_used[idx] = true;\n               }\n@@ -3073,7 +3075,7 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n         ty::mk_param(ccx.tcx, n, local_def(0))\n     }\n     fn arg(m: ast::rmode, ty: ty::t) -> ty::arg {\n-        {mode: ast::expl(m), ty: ty}\n+        arg {mode: ast::expl(m), ty: ty}\n     }\n     let tcx = ccx.tcx;\n     let (n_tps, inputs, output) = match ccx.tcx.sess.str_of(it.ident) {\n@@ -3136,12 +3138,14 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n                           onceness: ast::Once,\n                           region: ty::re_bound(ty::br_anon(0)),\n                           bounds: @~[]},\n-            sig: FnSig {inputs: ~[{mode: ast::expl(ast::by_val),\n-                                   ty: ty::mk_imm_ptr(\n-                                       ccx.tcx,\n-                                       ty::mk_mach_uint(ccx.tcx, ast::ty_u8))\n-                                  }],\n-                        output: ty::mk_nil(ccx.tcx)}\n+            sig: FnSig {\n+                inputs: ~[arg {\n+                    mode: ast::expl(ast::by_val),\n+                    ty: ty::mk_imm_ptr(\n+                        ccx.tcx,\n+                        ty::mk_mach_uint(ccx.tcx, ast::ty_u8))\n+                }],\n+                output: ty::mk_nil(ccx.tcx)}\n         });\n         (0u, ~[arg(ast::by_ref, fty)], ty::mk_nil(tcx))\n       }"}, {"sha": "9f6cc6835b715543e7ad985fd4b0d2202c2d1cf6", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -11,6 +11,7 @@\n use core::prelude::*;\n \n use middle::resolve;\n+use middle::ty::{param_ty, substs};\n use middle::ty;\n use middle::typeck::check::{fn_ctxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n@@ -103,7 +104,10 @@ fn lookup_vtables(vcx: &VtableContext,\n                    ppaux::ty_to_str(tcx, trait_ty),\n                    ty::substs_to_str(tcx, substs));\n \n-            let new_substs = {self_ty: Some(*ty), ../*bad*/copy *substs};\n+            let new_substs = substs {\n+                self_ty: Some(*ty),\n+                ../*bad*/copy *substs\n+            };\n             let trait_ty = ty::subst(tcx, &new_substs, trait_ty);\n \n             debug!(\"after subst: %?\",\n@@ -189,7 +193,7 @@ fn lookup_vtable(vcx: &VtableContext,\n     };\n \n     match ty::get(ty).sty {\n-        ty::ty_param({idx: n, def_id: did}) => {\n+        ty::ty_param(param_ty {idx: n, def_id: did}) => {\n             let mut n_bound = 0;\n             let bounds = tcx.ty_param_bounds.get(did.node);\n             for ty::iter_bound_traits_and_supertraits("}, {"sha": "c5374af2dd060c4e046b5ac0dd8d903082b80315", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -15,6 +15,7 @@\n use core::prelude::*;\n \n use middle::pat_util;\n+use middle::ty::arg;\n use middle::ty;\n use middle::typeck::check::{fn_ctxt, self_info};\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n@@ -65,7 +66,7 @@ fn resolve_method_map_entry(fcx: @fn_ctxt, sp: span, id: ast::node_id)\n                 fcx.ccx.method_map.insert(\n                     id,\n                     method_map_entry {\n-                        self_arg: {mode: mme.self_arg.mode, ty: *t},\n+                        self_arg: arg {mode: mme.self_arg.mode, ty: *t},\n                         .. *mme\n                     }\n                 );"}, {"sha": "4cd2eaaf003c9f9ffff08bc34f40b136badc67a4", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 64, "deletions": 65, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -25,15 +25,16 @@ use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n use middle::ty::{ProvidedMethodSource, ProvidedMethodInfo, bound_copy, get};\n use middle::ty::{kind_can_be_copied, lookup_item_type, param_bounds, subst};\n-use middle::ty::{t, ty_bool, ty_bot, ty_box, ty_enum, ty_err, ty_estr};\n-use middle::ty::{ty_evec, ty_float, ty_fn, ty_infer, ty_int, ty_nil};\n+use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n+use middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};\n use middle::ty::{ty_rec, ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_type, ty_uint, ty_uniq};\n use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_kind_ext};\n use middle::ty::{type_is_ty_var};\n use middle::ty;\n use middle::typeck::crate_ctxt;\n+use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::{InferCtxt, can_mk_subty};\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar};\n use middle::typeck::infer::{resolve_nested_tvar, resolve_type};\n@@ -286,8 +287,8 @@ impl CoherenceChecker {\n         }\n \n         // Add the implementation to the mapping from implementation to base\n-        // type def ID, if there is a base type for this implementation.\n-\n+        // type def ID, if there is a base type for this implementation and\n+        // the implementation does not have any associated traits.\n         match get_base_type_def_id(self.inference_context,\n                                    item.span,\n                                    self_type.ty) {\n@@ -296,16 +297,19 @@ impl CoherenceChecker {\n             }\n             Some(base_type_def_id) => {\n                 // XXX: Gather up default methods?\n-                let implementation;\n-                match implementation_opt {\n-                    None => {\n-                        implementation = self.create_impl_from_item(item);\n-                    }\n-                    Some(copy existing_implementation) => {\n-                        implementation = existing_implementation;\n+                if associated_traits.len() == 0 {\n+                    let implementation;\n+                    match implementation_opt {\n+                        None => {\n+                            implementation = self.create_impl_from_item(item);\n+                        }\n+                        Some(copy existing_implementation) => {\n+                            implementation = existing_implementation;\n+                        }\n                     }\n+                    self.add_inherent_method(base_type_def_id,\n+                                             implementation);\n                 }\n-                self.add_inherent_method(base_type_def_id, implementation);\n \n                 self.base_type_def_ids.insert(local_def(item.id),\n                                               base_type_def_id);\n@@ -510,7 +514,7 @@ impl CoherenceChecker {\n         let type_parameters =\n             self.inference_context.next_ty_vars(bounds_count);\n \n-        let substitutions = {\n+        let substitutions = substs {\n             self_r: self_region,\n             self_ty: None,\n             tps: type_parameters\n@@ -520,7 +524,8 @@ impl CoherenceChecker {\n                              polytype.ty);\n \n         // Get our type parameters back.\n-        let { self_r: _, self_ty: _, tps: type_parameters } = substitutions;\n+        let substs { self_r: _, self_ty: _, tps: type_parameters } =\n+            substitutions;\n \n         UniversalQuantificationResult {\n             monotype: monotype,\n@@ -597,6 +602,7 @@ impl CoherenceChecker {\n                         visit_mod(module_, item.span, item.id, (), visitor);\n                     }\n                     item_impl(_, opt_trait, _, _) => {\n+                        let mut ok = false;\n                         match self.base_type_def_ids.find(\n                             local_def(item.id)) {\n \n@@ -611,57 +617,50 @@ impl CoherenceChecker {\n                                     // Record that this implementation is OK.\n                                     self.privileged_implementations.insert\n                                         (item.id, ());\n-                                } else {\n-                                    // This implementation is not in scope of\n-                                    // its base type. This still might be OK\n-                                    // if the traits are defined in the same\n-                                    // crate.\n-\n-                                  match opt_trait {\n-                                    None => {\n-                                        // There is no trait to implement, so\n-                                        // this is an error.\n-\n-                                        let session =\n-                                            self.crate_context.tcx.sess;\n-                                        session.span_err(item.span,\n-                                                         ~\"cannot implement \\\n-                                                          inherent methods \\\n-                                                          for a type outside \\\n-                                                          the crate the type \\\n-                                                          was defined in; \\\n-                                                          define and \\\n-                                                          implement a trait \\\n-                                                          or new type \\\n-                                                          instead\");\n-                                    }\n-                                    _ => ()\n-                                  }\n-\n-                                  do opt_trait.iter() |trait_ref| {\n-                                        // This is OK if and only if the\n-                                        // trait was defined in this\n-                                        // crate.\n-\n-                                        let trait_def_id =\n-                                            self.trait_ref_to_trait_def_id(\n-                                                *trait_ref);\n-\n-                                        if trait_def_id.crate != local_crate {\n-                                            let session =\n-                                                self.crate_context.tcx.sess;\n-                                            session.span_err(item.span,\n-                                                             ~\"cannot \\\n-                                                               provide an \\\n-                                                               extension \\\n-                                                               implementa\\\n-                                                                  tion \\\n-                                                               for a trait \\\n-                                                               not defined \\\n-                                                               in this \\\n-                                                               crate\");\n-                                        }\n-                                    }\n+                                    ok = true;\n+                                }\n+                            }\n+                        }\n+\n+                        if !ok {\n+                            // This implementation is not in scope of its base\n+                            // type. This still might be OK if the trait is\n+                            // defined in the same crate.\n+\n+                            match opt_trait {\n+                                None => {\n+                                    // There is no trait to implement, so\n+                                    // this is an error.\n+\n+                                    let session = self.crate_context.tcx.sess;\n+                                    session.span_err(item.span,\n+                                                     ~\"cannot implement \\\n+                                                      inherent methods for a \\\n+                                                      type outside the crate \\\n+                                                      the type was defined \\\n+                                                      in; define and \\\n+                                                      implement a trait or \\\n+                                                      new type instead\");\n+                                }\n+                                _ => ()\n+                          }\n+\n+                          do opt_trait.iter() |trait_ref| {\n+                                // This is OK if and only if the trait was\n+                                // defined in this crate.\n+\n+                                let trait_def_id =\n+                                    self.trait_ref_to_trait_def_id(\n+                                        *trait_ref);\n+\n+                                if trait_def_id.crate != local_crate {\n+                                    let session = self.crate_context.tcx.sess;\n+                                    session.span_err(item.span,\n+                                                     ~\"cannot provide an \\\n+                                                       extension \\\n+                                                       implementation for a \\\n+                                                       trait not defined in \\\n+                                                       this crate\");\n                                 }\n                             }\n                         }"}, {"sha": "ce0c7a94c7cc0907f18472f87ed892b0e6af544d", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -33,8 +33,8 @@ are represented as `ty_param()` instances.\n use core::prelude::*;\n \n use metadata::csearch;\n-use middle::ty::{FnMeta, FnSig, FnTyBase, InstantiatedTraitRef};\n-use middle::ty::{ty_param_substs_and_ty};\n+use middle::ty::{FnMeta, FnSig, FnTyBase, InstantiatedTraitRef, arg};\n+use middle::ty::{substs, ty_param_substs_and_ty};\n use middle::ty;\n use middle::typeck::astconv::{ast_conv, ty_of_fn_decl, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty};\n@@ -75,7 +75,11 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n                 for m.items.each |intrinsic_item| {\n                     let def_id = ast::def_id { crate: ast::local_crate,\n                                                node: intrinsic_item.id };\n-                    let substs = {self_r: None, self_ty: None, tps: ~[]};\n+                    let substs = substs {\n+                        self_r: None,\n+                        self_ty: None,\n+                        tps: ~[]\n+                    };\n \n                     match intrinsic_item.node {\n                       ast::item_trait(*) => {\n@@ -164,7 +168,7 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n                 let rs = type_rscope(rp);\n                 let args = args.map(|va| {\n                     let arg_ty = ccx.to_ty(rs, va.ty);\n-                    {mode: ast::expl(ast::by_copy), ty: arg_ty}\n+                    arg { mode: ast::expl(ast::by_copy), ty: arg_ty }\n                 });\n                 result_ty = Some(ty::mk_fn(tcx, FnTyBase {\n                     meta: FnMeta {purity: ast::pure_fn,\n@@ -195,8 +199,9 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n                     variant.node.id);\n                 // Compute the ctor arg types from the struct fields\n                 let struct_fields = do struct_def.fields.map |struct_field| {\n-                    {mode: ast::expl(ast::by_val),\n-                     ty: ty::node_id_to_type(ccx.tcx, (*struct_field).node.id)\n+                    arg {\n+                        mode: ast::expl(ast::by_val),\n+                        ty: ty::node_id_to_type(ccx.tcx, struct_field.node.id)\n                     }\n                 };\n                 result_ty = Some(ty::mk_fn(tcx, FnTyBase {\n@@ -265,8 +270,11 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n             ty::mk_param(ccx.tcx, i + 1, dummy_defid)\n         };\n \n-        let substs = { self_r: None, self_ty: Some(self_param),\n-                       tps: non_shifted_trait_tps + shifted_method_tps };\n+        let substs = substs {\n+            self_r: None,\n+            self_ty: Some(self_param),\n+            tps: non_shifted_trait_tps + shifted_method_tps\n+        };\n         let ty = ty::subst(ccx.tcx,\n                            &substs,\n                            ty::mk_fn(ccx.tcx, /*bad*/copy m.fty));\n@@ -462,7 +470,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n         };\n         let trait_tps = trait_substs.tps.map(\n             |t| replace_bound_self(tcx, *t, dummy_self_r));\n-        let substs = {\n+        let substs = substs {\n             self_r: Some(dummy_self_r),\n             self_ty: Some(self_ty),\n             tps: vec::append(trait_tps, dummy_tps)\n@@ -705,7 +713,7 @@ fn convert_struct(ccx: @crate_ctxt,\n                     },\n                     sig: FnSig {\n                         inputs: do struct_def.fields.map |field| {\n-                            {\n+                            arg {\n                                 mode: ast::expl(ast::by_copy),\n                                 ty: ccx.tcx.tcache.get\n                                         (local_def(field.node.id)).ty\n@@ -1002,5 +1010,8 @@ fn mk_substs(ccx: @crate_ctxt,\n           -> {bounds: @~[ty::param_bounds], substs: ty::substs} {\n     let {bounds, params} = mk_ty_params(ccx, atps);\n     let self_r = rscope::bound_self_region(rp);\n-    {bounds: bounds, substs: {self_r: self_r, self_ty: None, tps: params}}\n+    {\n+        bounds: bounds,\n+        substs: substs { self_r: self_r, self_ty: None, tps: params }\n+    }\n }"}, {"sha": "d1c57a21a3b2f7a4706439d8198eaed0dba67944", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -57,7 +57,7 @@\n use core::prelude::*;\n \n use middle::ty::{FloatVar, FnTyBase, FnMeta, FnSig, IntVar, TyVar};\n-use middle::ty::{IntType, UintType};\n+use middle::ty::{IntType, UintType, arg, substs};\n use middle::ty;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n@@ -233,7 +233,11 @@ fn super_substs<C:Combine>(\n             do relate_region_param(self, did,\n                                    a.self_r, b.self_r).chain |self_r|\n             {\n-                Ok({self_r: self_r, self_ty: self_ty, tps: /*bad*/copy tps})\n+                Ok(substs {\n+                    self_r: self_r,\n+                    self_ty: self_ty,\n+                    tps: /*bad*/copy tps\n+                })\n             }\n         }\n     }\n@@ -295,7 +299,7 @@ fn super_flds<C:Combine>(\n \n     if a.ident == b.ident {\n         self.mts(a.mt, b.mt)\n-            .chain(|mt| Ok({ident: a.ident, mt: mt}) )\n+            .chain(|mt| Ok(ty::field {ident: a.ident, mt: mt}) )\n             .chain_err(|e| Err(ty::terr_in_field(@e, a.ident)) )\n     } else {\n         Err(ty::terr_record_fields(\n@@ -317,7 +321,7 @@ fn super_args<C:Combine>(\n \n     do self.modes(a.mode, b.mode).chain |m| {\n         do self.contratys(a.ty, b.ty).chain |t| {\n-            Ok({mode: m, ty: t})\n+            Ok(arg {mode: m, ty: t})\n         }\n     }\n }\n@@ -587,4 +591,4 @@ fn super_tys<C:Combine>(\n         if_ok!(self.infcx().simple_var_t(vid_is_expected, vid, val));\n         Ok(ty::mk_mach_float(tcx, val))\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "cab40ce21b154903b65a3c4c43d247c3c3808fd8", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -255,7 +255,7 @@ use middle::ty::IntVarValue;\n use middle::ty;\n use middle::typeck::check::regionmanip::{replace_bound_regions_in_fn_sig};\n use middle::typeck::infer::coercion::Coerce;\n-use middle::typeck::infer::combine::{CombineFields, eq_tys};\n+use middle::typeck::infer::combine::{Combine, CombineFields, eq_tys};\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::region_inference::{RegionVarBindings};"}, {"sha": "fb9e0f36c2f2504c632885c57394be2a1764d3d3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -17,7 +17,7 @@ use middle::ty::{bound_copy, bound_const, bound_durable, bound_owned,\n use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid,\n                  br_fresh};\n use middle::ty::{ctxt, field, method};\n-use middle::ty::{mt, t, param_bound};\n+use middle::ty::{mt, t, param_bound, param_ty};\n use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region};\n use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{ty_bool, ty_bot, ty_box, ty_struct, ty_enum};\n@@ -292,9 +292,8 @@ fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n }\n \n fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n-    fn fn_input_to_str(cx: ctxt, input: {mode: ast::mode, ty: t}) ->\n-       ~str {\n-        let {mode, ty} = input;\n+    fn fn_input_to_str(cx: ctxt, input: ty::arg) -> ~str {\n+        let ty::arg {mode: mode, ty: ty} = input;\n         let modestr = match canon_mode(cx, mode) {\n           ast::infer(_) => ~\"\",\n           ast::expl(m) => {\n@@ -423,7 +422,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_err => ~\"[type error]\",\n-      ty_param({idx: id, _}) => {\n+      ty_param(param_ty {idx: id, _}) => {\n         ~\"'\" + str::from_bytes(~[('a' as u8) + (id as u8)])\n       }\n       ty_self => ~\"self\","}, {"sha": "bc332615eaa0e498371418acb9890da2db800825", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -155,9 +155,9 @@ fn build_error_handlers(\n     codemap: @codemap::CodeMap\n ) -> ErrorHandlers {\n \n-    type DiagnosticHandler = {\n+    struct DiagnosticHandler {\n         inner: diagnostic::handler,\n-    };\n+    }\n \n     impl DiagnosticHandler: diagnostic::handler {\n         fn fatal(msg: &str) -> ! { self.inner.fatal(msg) }\n@@ -182,7 +182,7 @@ fn build_error_handlers(\n         diagnostic::emit(cmsp, msg, lvl);\n     };\n     let inner_handler = diagnostic::mk_handler(Some(emitter));\n-    let handler = {\n+    let handler = DiagnosticHandler {\n         inner: inner_handler,\n     };\n     let span_handler = diagnostic::mk_span_handler("}, {"sha": "39a893a4076cb179b315a3f4b3d4c6c567084faf", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -69,9 +69,9 @@ fn fold_crate(\n         attr_parser::parse_crate(attrs)\n     };\n \n-    {\n-        topmod: doc::ModDoc_({\n-            item: {\n+    doc::CrateDoc {\n+        topmod: doc::ModDoc_(doc::ModDoc_ {\n+            item: doc::ItemDoc {\n                 name: option::get_or_default(attrs.name, doc.topmod.name()),\n                 .. doc.topmod.item\n             },\n@@ -103,7 +103,7 @@ fn fold_item(\n         parse_item_attrs(srv, doc.id, attr_parser::parse_desc)\n     };\n \n-    {\n+    doc::ItemDoc {\n         desc: desc,\n         .. doc\n     }\n@@ -162,7 +162,7 @@ fn fold_enum(\n     let doc_id = doc.id();\n     let doc = fold::default_seq_fold_enum(fold, doc);\n \n-    {\n+    doc::EnumDoc {\n         variants: do par::map(doc.variants) |variant| {\n             let variant = *variant;\n             let desc = do astsrv::exec(srv) |ctxt| {\n@@ -182,7 +182,7 @@ fn fold_enum(\n                 }\n             };\n \n-            {\n+            doc::VariantDoc {\n                 desc: desc,\n                 .. variant\n             }\n@@ -211,7 +211,7 @@ fn fold_trait(\n     let srv = fold.ctxt;\n     let doc = fold::default_seq_fold_trait(fold, doc);\n \n-    {\n+    doc::TraitDoc {\n         methods: merge_method_attrs(srv, doc.id(), doc.methods),\n         .. doc\n     }\n@@ -256,7 +256,7 @@ fn merge_method_attrs(\n         assert doc.name == attrs.first();\n         let desc = attrs.second();\n \n-        {\n+        doc::MethodDoc {\n             desc: desc,\n             ..*doc\n         }\n@@ -287,7 +287,7 @@ fn fold_impl(\n     let srv = fold.ctxt;\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n-    {\n+    doc::ImplDoc {\n         methods: merge_method_attrs(srv, doc.id(), doc.methods),\n         .. doc\n     }"}, {"sha": "0ad048d49bb4cce4637034a3795315870619fc7b", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -50,13 +50,13 @@ impl OutputStyle : cmp::Eq {\n }\n \n /// The configuration for a rustdoc session\n-pub type Config = {\n+pub struct Config {\n     input_crate: Path,\n     output_dir: Path,\n     output_format: OutputFormat,\n     output_style: OutputStyle,\n     pandoc_cmd: Option<~str>\n-};\n+}\n \n pub impl Config: Clone {\n     fn clone(&self) -> Config { copy *self }\n@@ -95,7 +95,7 @@ pub fn usage() {\n }\n \n pub fn default_config(input_crate: &Path) -> Config {\n-    {\n+    Config {\n         input_crate: *input_crate,\n         output_dir: Path(\".\"),\n         output_format: PandocHtml,\n@@ -155,7 +155,7 @@ fn config_from_opts(\n     let result = do result::chain(result) |config| {\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n         let output_dir = output_dir.map(|s| Path(*s));\n-        result::Ok({\n+        result::Ok(Config {\n             output_dir: output_dir.get_or_default(config.output_dir),\n             .. config\n         })\n@@ -168,7 +168,7 @@ fn config_from_opts(\n             do result::chain(parse_output_format(*output_format))\n                 |output_format| {\n \n-                result::Ok({\n+                result::Ok(Config {\n                     output_format: output_format,\n                     .. config\n                 })\n@@ -182,7 +182,7 @@ fn config_from_opts(\n             |output_style| {\n             do result::chain(parse_output_style(*output_style))\n                 |output_style| {\n-                result::Ok({\n+                result::Ok(Config {\n                     output_style: output_style,\n                     .. config\n                 })\n@@ -195,7 +195,7 @@ fn config_from_opts(\n         let pandoc_cmd = maybe_find_pandoc(\n             &config, pandoc_cmd, move program_output.take());\n         do result::chain(pandoc_cmd) |pandoc_cmd| {\n-            result::Ok({\n+            result::Ok(Config {\n                 pandoc_cmd: pandoc_cmd,\n                 .. config\n             })"}, {"sha": "93f4be10a5c36c103dc479ec6b426ce9fcef5300", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -51,7 +51,7 @@ pub fn run(\n fn fold_item(fold: &fold::Fold<()>, +doc: doc::ItemDoc) -> doc::ItemDoc {\n     let doc = fold::default_seq_fold_item(fold, doc);\n \n-    {\n+    doc::ItemDoc {\n         brief: extract(doc.desc),\n         .. doc\n     }\n@@ -60,8 +60,8 @@ fn fold_item(fold: &fold::Fold<()>, +doc: doc::ItemDoc) -> doc::ItemDoc {\n fn fold_trait(fold: &fold::Fold<()>, +doc: doc::TraitDoc) -> doc::TraitDoc {\n     let doc =fold::default_seq_fold_trait(fold, doc);\n \n-    {\n-        methods: par::map(doc.methods, |doc| {\n+    doc::TraitDoc {\n+        methods: par::map(doc.methods, |doc| doc::MethodDoc {\n             brief: extract(doc.desc),\n             .. *doc\n         }),\n@@ -72,8 +72,8 @@ fn fold_trait(fold: &fold::Fold<()>, +doc: doc::TraitDoc) -> doc::TraitDoc {\n fn fold_impl(fold: &fold::Fold<()>, +doc: doc::ImplDoc) -> doc::ImplDoc {\n     let doc =fold::default_seq_fold_impl(fold, doc);\n \n-    {\n-        methods: par::map(doc.methods, |doc| {\n+    doc::ImplDoc {\n+        methods: par::map(doc.methods, |doc| doc::MethodDoc {\n             brief: extract(doc.desc),\n             .. *doc\n         }),"}, {"sha": "247694fb26a50cf9948ee5d82ea844e95931a0df", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 36, "deletions": 247, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -21,94 +21,47 @@ use core::vec;\n \n pub type AstId = int;\n \n-pub type Doc_ = {\n+#[deriving_eq]\n+pub struct Doc_ {\n     pages: ~[Page]\n-};\n-\n-impl Doc_ : cmp::Eq {\n-    pure fn eq(&self, other: &Doc_) -> bool {\n-        (*self).pages == (*other).pages\n-    }\n-    pure fn ne(&self, other: &Doc_) -> bool { !(*self).eq(other) }\n }\n \n+#[deriving_eq]\n pub enum Doc {\n     Doc_(Doc_)\n }\n \n-impl Doc : cmp::Eq {\n-    pure fn eq(&self, other: &Doc) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &Doc) -> bool { *(*self) != *(*other) }\n-}\n-\n+#[deriving_eq]\n pub enum Page {\n     CratePage(CrateDoc),\n     ItemPage(ItemTag)\n }\n \n-impl Page : cmp::Eq {\n-    pure fn eq(&self, other: &Page) -> bool {\n-        match (*self) {\n-            CratePage(e0a) => {\n-                match (*other) {\n-                    CratePage(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ItemPage(e0a) => {\n-                match (*other) {\n-                    ItemPage(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &Page) -> bool { !(*self).eq(other) }\n-}\n-\n+#[deriving_eq]\n pub enum Implementation {\n     Required,\n     Provided,\n }\n \n-impl Implementation : cmp::Eq {\n-    pure fn eq(&self, other: &Implementation) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &Implementation) -> bool { !(*self).eq(other) }\n-}\n-\n-\n /**\n  * Most rustdocs can be parsed into 'sections' according to their markdown\n  * headers\n  */\n-pub type Section = {\n+#[deriving_eq]\n+pub struct Section {\n     header: ~str,\n     body: ~str\n-};\n-\n-impl Section : cmp::Eq {\n-    pure fn eq(&self, other: &Section) -> bool {\n-        (*self).header == (*other).header && (*self).body == (*other).body\n-    }\n-    pure fn ne(&self, other: &Section) -> bool { !(*self).eq(other) }\n }\n \n // FIXME (#2596): We currently give topmod the name of the crate.  There\n // would probably be fewer special cases if the crate had its own name\n // and topmod's name was the empty string.\n-pub type CrateDoc = {\n-    topmod: ModDoc,\n-};\n-\n-impl CrateDoc : cmp::Eq {\n-    pure fn eq(&self, other: &CrateDoc) -> bool {\n-        (*self).topmod == (*other).topmod\n-    }\n-    pure fn ne(&self, other: &CrateDoc) -> bool { !(*self).eq(other) }\n+#[deriving_eq]\n+pub struct CrateDoc {\n+    topmod: ModDoc\n }\n \n+#[deriving_eq]\n pub enum ItemTag {\n     ModTag(ModDoc),\n     NmodTag(NmodDoc),\n@@ -121,69 +74,8 @@ pub enum ItemTag {\n     StructTag(StructDoc)\n }\n \n-impl ItemTag : cmp::Eq {\n-    pure fn eq(&self, other: &ItemTag) -> bool {\n-        match (*self) {\n-            ModTag(e0a) => {\n-                match (*other) {\n-                    ModTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            NmodTag(e0a) => {\n-                match (*other) {\n-                    NmodTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ConstTag(e0a) => {\n-                match (*other) {\n-                    ConstTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            FnTag(e0a) => {\n-                match (*other) {\n-                    FnTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            EnumTag(e0a) => {\n-                match (*other) {\n-                    EnumTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            TraitTag(e0a) => {\n-                match (*other) {\n-                    TraitTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ImplTag(e0a) => {\n-                match (*other) {\n-                    ImplTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            TyTag(e0a) => {\n-                match (*other) {\n-                    TyTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            StructTag(e0a) => {\n-                match (*other) {\n-                    StructTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &ItemTag) -> bool { !(*self).eq(other) }\n-}\n-\n-pub type ItemDoc = {\n+#[deriving_eq]\n+pub struct ItemDoc {\n     id: AstId,\n     name: ~str,\n     path: ~[~str],\n@@ -192,179 +84,86 @@ pub type ItemDoc = {\n     sections: ~[Section],\n     // Indicates that this node is a reexport of a different item\n     reexport: bool\n-};\n-\n-impl ItemDoc : cmp::Eq {\n-    pure fn eq(&self, other: &ItemDoc) -> bool {\n-        (*self).id == (*other).id &&\n-        (*self).name == (*other).name &&\n-        (*self).path == (*other).path &&\n-        (*self).brief == (*other).brief &&\n-        (*self).desc == (*other).desc &&\n-        (*self).sections == (*other).sections &&\n-        (*self).reexport == (*other).reexport\n-    }\n-    pure fn ne(&self, other: &ItemDoc) -> bool { !(*self).eq(other) }\n }\n \n-pub type SimpleItemDoc = {\n+#[deriving_eq]\n+pub struct SimpleItemDoc {\n     item: ItemDoc,\n     sig: Option<~str>\n-};\n-\n-impl SimpleItemDoc : cmp::Eq {\n-    pure fn eq(&self, other: &SimpleItemDoc) -> bool {\n-        (*self).item == (*other).item && (*self).sig == (*other).sig\n-    }\n-    pure fn ne(&self, other: &SimpleItemDoc) -> bool { !(*self).eq(other) }\n }\n \n-pub type ModDoc_ = {\n+#[deriving_eq]\n+pub struct ModDoc_ {\n     item: ItemDoc,\n     items: ~[ItemTag],\n     index: Option<Index>\n-};\n-\n-impl ModDoc_ : cmp::Eq {\n-    pure fn eq(&self, other: &ModDoc_) -> bool {\n-        (*self).item == (*other).item &&\n-        (*self).items == (*other).items &&\n-        (*self).index == (*other).index\n-    }\n-    pure fn ne(&self, other: &ModDoc_) -> bool { !(*self).eq(other) }\n }\n \n+#[deriving_eq]\n pub enum ModDoc {\n     ModDoc_(ModDoc_)\n }\n \n-impl ModDoc : cmp::Eq {\n-    pure fn eq(&self, other: &ModDoc) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &ModDoc) -> bool { *(*self) != *(*other) }\n-}\n-\n-pub type NmodDoc = {\n+#[deriving_eq]\n+pub struct NmodDoc {\n     item: ItemDoc,\n     fns: ~[FnDoc],\n     index: Option<Index>\n-};\n-\n-impl NmodDoc : cmp::Eq {\n-    pure fn eq(&self, other: &NmodDoc) -> bool {\n-        (*self).item == (*other).item &&\n-        (*self).fns == (*other).fns &&\n-        (*self).index == (*other).index\n-    }\n-    pure fn ne(&self, other: &NmodDoc) -> bool { !(*self).eq(other) }\n }\n \n pub type ConstDoc = SimpleItemDoc;\n \n pub type FnDoc = SimpleItemDoc;\n \n-pub type EnumDoc = {\n+#[deriving_eq]\n+pub struct EnumDoc {\n     item: ItemDoc,\n     variants: ~[VariantDoc]\n-};\n-\n-impl EnumDoc : cmp::Eq {\n-    pure fn eq(&self, other: &EnumDoc) -> bool {\n-        (*self).item == (*other).item && (*self).variants == (*other).variants\n-    }\n-    pure fn ne(&self, other: &EnumDoc) -> bool { !(*self).eq(other) }\n }\n \n-pub type VariantDoc = {\n+#[deriving_eq]\n+pub struct VariantDoc {\n     name: ~str,\n     desc: Option<~str>,\n     sig: Option<~str>\n-};\n-\n-impl VariantDoc : cmp::Eq {\n-    pure fn eq(&self, other: &VariantDoc) -> bool {\n-        (*self).name == (*other).name &&\n-        (*self).desc == (*other).desc &&\n-        (*self).sig == (*other).sig\n-    }\n-    pure fn ne(&self, other: &VariantDoc) -> bool { !(*self).eq(other) }\n }\n \n-pub type TraitDoc = {\n+#[deriving_eq]\n+pub struct TraitDoc {\n     item: ItemDoc,\n     methods: ~[MethodDoc]\n-};\n-\n-impl TraitDoc : cmp::Eq {\n-    pure fn eq(&self, other: &TraitDoc) -> bool {\n-        (*self).item == (*other).item && (*self).methods == (*other).methods\n-    }\n-    pure fn ne(&self, other: &TraitDoc) -> bool { !(*self).eq(other) }\n }\n \n-pub type MethodDoc = {\n+#[deriving_eq]\n+pub struct MethodDoc {\n     name: ~str,\n     brief: Option<~str>,\n     desc: Option<~str>,\n     sections: ~[Section],\n     sig: Option<~str>,\n     implementation: Implementation,\n-};\n-\n-impl MethodDoc : cmp::Eq {\n-    pure fn eq(&self, other: &MethodDoc) -> bool {\n-        (*self).name == (*other).name &&\n-        (*self).brief == (*other).brief &&\n-        (*self).desc == (*other).desc &&\n-        (*self).sections == (*other).sections &&\n-        (*self).sig == (*other).sig &&\n-        (*self).implementation == (*other).implementation\n-    }\n-    pure fn ne(&self, other: &MethodDoc) -> bool { !(*self).eq(other) }\n }\n \n-pub type ImplDoc = {\n+#[deriving_eq]\n+pub struct ImplDoc {\n     item: ItemDoc,\n     trait_types: ~[~str],\n     self_ty: Option<~str>,\n     methods: ~[MethodDoc]\n-};\n-\n-impl ImplDoc : cmp::Eq {\n-    pure fn eq(&self, other: &ImplDoc) -> bool {\n-        (*self).item == (*other).item &&\n-        (*self).trait_types == (*other).trait_types &&\n-        (*self).self_ty == (*other).self_ty &&\n-        (*self).methods == (*other).methods\n-    }\n-    pure fn ne(&self, other: &ImplDoc) -> bool { !(*self).eq(other) }\n }\n \n pub type TyDoc = SimpleItemDoc;\n \n-pub type StructDoc = {\n+#[deriving_eq]\n+pub struct StructDoc {\n     item: ItemDoc,\n     fields: ~[~str],\n     sig: Option<~str>\n-};\n-\n-impl StructDoc : cmp::Eq {\n-    pure fn eq(&self, other: &StructDoc) -> bool {\n-        return (*self).item == other.item\n-            && (*self).fields == other.fields\n-            && (*self).sig == other.sig;\n-    }\n-    pure fn ne(&self, other: &StructDoc) -> bool { !(*self).eq(other) }\n }\n \n-pub type Index = {\n+#[deriving_eq]\n+pub struct Index {\n     entries: ~[IndexEntry]\n-};\n-\n-impl Index : cmp::Eq {\n-    pure fn eq(&self, other: &Index) -> bool {\n-        (*self).entries == (*other).entries\n-    }\n-    pure fn ne(&self, other: &Index) -> bool { !(*self).eq(other) }\n }\n \n /**\n@@ -377,21 +176,12 @@ impl Index : cmp::Eq {\n  * * brief - The brief description\n  * * link - A format-specific string representing the link target\n  */\n-pub type IndexEntry = {\n+#[deriving_eq]\n+pub struct IndexEntry {\n     kind: ~str,\n     name: ~str,\n     brief: Option<~str>,\n     link: ~str\n-};\n-\n-impl IndexEntry : cmp::Eq {\n-    pure fn eq(&self, other: &IndexEntry) -> bool {\n-        (*self).kind == (*other).kind &&\n-        (*self).name == (*other).name &&\n-        (*self).brief == (*other).brief &&\n-        (*self).link == (*other).link\n-    }\n-    pure fn ne(&self, other: &IndexEntry) -> bool { !(*self).eq(other) }\n }\n \n impl Doc {\n@@ -411,7 +201,6 @@ impl Doc {\n \n /// Some helper methods on ModDoc, mostly for testing\n impl ModDoc {\n-\n     fn mods() -> ~[ModDoc] {\n         do vec::filter_map(self.items) |itemtag| {\n             match *itemtag {"}, {"sha": "93226cb5ed8c8ab633e3be466b4362b7266a1811", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -57,9 +57,9 @@ pub fn extract(\n     crate: @ast::crate,\n     +default_name: ~str\n ) -> doc::Doc {\n-    doc::Doc_({\n+    doc::Doc_(doc::Doc_ {\n         pages: ~[\n-            doc::CratePage({\n+            doc::CratePage(doc::CrateDoc {\n                 topmod: top_moddoc_from_crate(crate, default_name),\n             })\n         ]\n@@ -75,7 +75,7 @@ fn top_moddoc_from_crate(\n }\n \n fn mk_itemdoc(id: ast::node_id, +name: ~str) -> doc::ItemDoc {\n-    {\n+    doc::ItemDoc {\n         id: id,\n         name: name,\n         path: ~[],\n@@ -90,7 +90,7 @@ fn moddoc_from_mod(\n     +itemdoc: doc::ItemDoc,\n     module_: ast::_mod\n ) -> doc::ModDoc {\n-    doc::ModDoc_({\n+    doc::ModDoc_(doc::ModDoc_ {\n         item: itemdoc,\n         items: do vec::filter_map(module_.items) |item| {\n             let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n@@ -161,22 +161,22 @@ fn nmoddoc_from_mod(\n           ast::foreign_item_const(*) => {} // XXX: Not implemented.\n         }\n     }\n-    {\n+    doc:: NmodDoc {\n         item: itemdoc,\n         fns: fns,\n         index: None\n     }\n }\n \n fn fndoc_from_fn(+itemdoc: doc::ItemDoc) -> doc::FnDoc {\n-    {\n+    doc::SimpleItemDoc {\n         item: itemdoc,\n         sig: None\n     }\n }\n \n fn constdoc_from_const(+itemdoc: doc::ItemDoc) -> doc::ConstDoc {\n-    {\n+    doc::SimpleItemDoc {\n         item: itemdoc,\n         sig: None\n     }\n@@ -193,7 +193,7 @@ fn enumdoc_from_enum(\n     +itemdoc: doc::ItemDoc,\n     +variants: ~[ast::variant]\n ) -> doc::EnumDoc {\n-    {\n+    doc::EnumDoc {\n         item: itemdoc,\n         variants: variantdocs_from_variants(variants)\n     }\n@@ -206,8 +206,7 @@ fn variantdocs_from_variants(\n }\n \n fn variantdoc_from_variant(variant: &ast::variant) -> doc::VariantDoc {\n-\n-    {\n+    doc::VariantDoc {\n         name: to_str(variant.node.name),\n         desc: None,\n         sig: None\n@@ -231,12 +230,12 @@ fn traitdoc_from_trait(\n     +itemdoc: doc::ItemDoc,\n     +methods: ~[ast::trait_method]\n ) -> doc::TraitDoc {\n-    {\n+    doc::TraitDoc {\n         item: itemdoc,\n         methods: do vec::map(methods) |method| {\n             match *method {\n               ast::required(ty_m) => {\n-                {\n+                doc::MethodDoc {\n                     name: to_str(ty_m.ident),\n                     brief: None,\n                     desc: None,\n@@ -246,7 +245,7 @@ fn traitdoc_from_trait(\n                 }\n               }\n               ast::provided(m) => {\n-                {\n+                doc::MethodDoc {\n                     name: to_str(m.ident),\n                     brief: None,\n                     desc: None,\n@@ -276,12 +275,12 @@ fn impldoc_from_impl(\n     +itemdoc: doc::ItemDoc,\n     methods: ~[@ast::method]\n ) -> doc::ImplDoc {\n-    {\n+    doc::ImplDoc {\n         item: itemdoc,\n         trait_types: ~[],\n         self_ty: None,\n         methods: do vec::map(methods) |method| {\n-            {\n+            doc::MethodDoc {\n                 name: to_str(method.ident),\n                 brief: None,\n                 desc: None,\n@@ -302,7 +301,7 @@ fn should_extract_impl_methods() {\n fn tydoc_from_ty(\n     +itemdoc: doc::ItemDoc\n ) -> doc::TyDoc {\n-    {\n+    doc::SimpleItemDoc {\n         item: itemdoc,\n         sig: None\n     }\n@@ -318,7 +317,7 @@ fn structdoc_from_struct(\n     +itemdoc: doc::ItemDoc,\n     struct_def: @ast::struct_def\n ) -> doc::StructDoc {\n-    {\n+    doc::StructDoc {\n         item: itemdoc,\n         fields: do struct_def.fields.map |field| {\n             match field.node.kind {"}, {"sha": "f352ed7f7e7c39ae02c2a102cf8fdf34721578f7", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -158,7 +158,7 @@ pub fn default_par_fold<T:Owned Clone>(+ctxt: T) -> Fold<T> {\n }\n \n pub fn default_seq_fold_doc<T>(fold: &Fold<T>, +doc: doc::Doc) -> doc::Doc {\n-    doc::Doc_({\n+    doc::Doc_(doc::Doc_ {\n         pages: do vec::map(doc.pages) |page| {\n             match *page {\n               doc::CratePage(doc) => {\n@@ -177,7 +177,7 @@ pub fn default_seq_fold_crate<T>(\n     fold: &Fold<T>,\n     +doc: doc::CrateDoc\n ) -> doc::CrateDoc {\n-    {\n+    doc::CrateDoc {\n         topmod: (fold.fold_mod)(fold, doc.topmod)\n     }\n }\n@@ -194,7 +194,7 @@ pub fn default_any_fold_mod<T:Owned Clone>(\n     +doc: doc::ModDoc\n ) -> doc::ModDoc {\n     let fold_copy = fold.clone();\n-    doc::ModDoc_({\n+    doc::ModDoc_(doc::ModDoc_ {\n         item: (fold.fold_item)(fold, doc.item),\n         items: par::map(doc.items, |ItemTag, move fold_copy| {\n             fold_ItemTag(&fold_copy, *ItemTag)\n@@ -207,7 +207,7 @@ pub fn default_seq_fold_mod<T>(\n     fold: &Fold<T>,\n     +doc: doc::ModDoc\n ) -> doc::ModDoc {\n-    doc::ModDoc_({\n+    doc::ModDoc_(doc::ModDoc_ {\n         item: (fold.fold_item)(fold, doc.item),\n         items: vec::map(doc.items, |ItemTag| {\n             fold_ItemTag(fold, *ItemTag)\n@@ -221,7 +221,7 @@ pub fn default_par_fold_mod<T:Owned Clone>(\n     +doc: doc::ModDoc\n ) -> doc::ModDoc {\n     let fold_copy = fold.clone();\n-    doc::ModDoc_({\n+    doc::ModDoc_(doc::ModDoc_ {\n         item: (fold.fold_item)(fold, doc.item),\n         items: par::map(doc.items, |ItemTag, move fold_copy| {\n             fold_ItemTag(&fold_copy, *ItemTag)\n@@ -235,7 +235,7 @@ pub fn default_any_fold_nmod<T:Owned Clone>(\n     +doc: doc::NmodDoc\n ) -> doc::NmodDoc {\n     let fold_copy = fold.clone();\n-    {\n+    doc::NmodDoc {\n         item: (fold.fold_item)(fold, doc.item),\n         fns: par::map(doc.fns, |FnDoc, move fold_copy| {\n             (fold_copy.fold_fn)(&fold_copy, *FnDoc)\n@@ -248,7 +248,7 @@ pub fn default_seq_fold_nmod<T>(\n     fold: &Fold<T>,\n     +doc: doc::NmodDoc\n ) -> doc::NmodDoc {\n-    {\n+    doc::NmodDoc {\n         item: (fold.fold_item)(fold, doc.item),\n         fns: vec::map(doc.fns, |FnDoc| {\n             (fold.fold_fn)(fold, *FnDoc)\n@@ -262,7 +262,7 @@ pub fn default_par_fold_nmod<T:Owned Clone>(\n     +doc: doc::NmodDoc\n ) -> doc::NmodDoc {\n     let fold_copy = fold.clone();\n-    {\n+    doc::NmodDoc {\n         item: (fold.fold_item)(fold, doc.item),\n         fns: par::map(doc.fns, |FnDoc, move fold_copy| {\n             (fold_copy.fold_fn)(&fold_copy, *FnDoc)\n@@ -307,7 +307,7 @@ pub fn default_seq_fold_fn<T>(\n     fold: &Fold<T>,\n     +doc: doc::FnDoc\n ) -> doc::FnDoc {\n-    {\n+    doc::SimpleItemDoc {\n         item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n@@ -317,7 +317,7 @@ pub fn default_seq_fold_const<T>(\n     fold: &Fold<T>,\n     +doc: doc::ConstDoc\n ) -> doc::ConstDoc {\n-    {\n+    doc::SimpleItemDoc {\n         item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n@@ -327,7 +327,7 @@ pub fn default_seq_fold_enum<T>(\n     fold: &Fold<T>,\n     +doc: doc::EnumDoc\n ) -> doc::EnumDoc {\n-    {\n+    doc::EnumDoc {\n         item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n@@ -337,7 +337,7 @@ pub fn default_seq_fold_trait<T>(\n     fold: &Fold<T>,\n     +doc: doc::TraitDoc\n ) -> doc::TraitDoc {\n-    {\n+    doc::TraitDoc {\n         item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n@@ -347,7 +347,7 @@ pub fn default_seq_fold_impl<T>(\n     fold: &Fold<T>,\n     +doc: doc::ImplDoc\n ) -> doc::ImplDoc {\n-    {\n+    doc::ImplDoc {\n         item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n@@ -357,7 +357,7 @@ pub fn default_seq_fold_type<T>(\n     fold: &Fold<T>,\n     +doc: doc::TyDoc\n ) -> doc::TyDoc {\n-    {\n+    doc::SimpleItemDoc {\n         item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n@@ -367,7 +367,7 @@ pub fn default_seq_fold_struct<T>(\n     fold: &Fold<T>,\n     +doc: doc::StructDoc\n ) -> doc::StructDoc {\n-    {\n+    doc::StructDoc {\n         item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }"}, {"sha": "b0b4278a91e0a5f82a00f0aa749b1736f2fe9607", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -54,7 +54,7 @@ fn fold_mod(\n \n     let doc = fold::default_any_fold_mod(fold, doc);\n \n-    doc::ModDoc_({\n+    doc::ModDoc_(doc::ModDoc_ {\n         index: Some(build_mod_index(doc, fold.ctxt)),\n         .. *doc\n     })\n@@ -67,7 +67,7 @@ fn fold_nmod(\n \n     let doc = fold::default_any_fold_nmod(fold, doc);\n \n-    {\n+    doc::NmodDoc {\n         index: Some(build_nmod_index(doc, fold.ctxt)),\n         .. doc\n     }\n@@ -77,7 +77,7 @@ fn build_mod_index(\n     +doc: doc::ModDoc,\n     +config: config::Config\n ) -> doc::Index {\n-    {\n+    doc::Index {\n         entries: par::map(doc.items, |doc| {\n             item_to_entry(*doc, config)\n         })\n@@ -88,7 +88,7 @@ fn build_nmod_index(\n     +doc: doc::NmodDoc,\n     +config: config::Config\n ) -> doc::Index {\n-    {\n+    doc::Index {\n         entries: par::map(doc.fns, |doc| {\n             item_to_entry(doc::FnTag(*doc), config)\n         })\n@@ -109,7 +109,7 @@ fn item_to_entry(\n       }\n     };\n \n-    {\n+    doc::IndexEntry {\n         kind: markdown_pass::header_kind(doc),\n         name: markdown_pass::header_name(doc),\n         brief: doc.brief(),"}, {"sha": "d121d7e84789306dce40a460fe244b58a6f22a0a", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -76,7 +76,7 @@ fn make_doc_from_pages(page_port: PagePort) -> doc::Doc {\n             break;\n         }\n     }\n-    doc::Doc_({\n+    doc::Doc_(doc::Doc_ {\n         pages: pages\n     })\n }\n@@ -100,7 +100,7 @@ fn fold_crate(\n \n     let doc = fold::default_seq_fold_crate(fold, doc);\n \n-    let page = doc::CratePage({\n+    let page = doc::CratePage(doc::CrateDoc {\n         topmod: strip_mod(doc.topmod),\n         .. doc\n     });\n@@ -128,7 +128,7 @@ fn fold_mod(\n }\n \n fn strip_mod(doc: doc::ModDoc) -> doc::ModDoc {\n-    doc::ModDoc_({\n+    doc::ModDoc_(doc::ModDoc_ {\n         items: do doc.items.filtered |item| {\n             match *item {\n               doc::ModTag(_) => false,"}, {"sha": "bc69ea7ed5a8d7bd13b384178c4510fb76ed8817", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -54,7 +54,7 @@ fn run(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc {\n }\n \n fn fold_item(fold: &fold::Fold<Ctxt>, +doc: doc::ItemDoc) -> doc::ItemDoc {\n-    {\n+    doc::ItemDoc {\n         path: fold.ctxt.path,\n         .. doc\n     }\n@@ -68,7 +68,7 @@ fn fold_mod(fold: &fold::Fold<Ctxt>, +doc: doc::ModDoc) -> doc::ModDoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n     if !is_topmod { fold.ctxt.path.pop(); }\n \n-    doc::ModDoc_({\n+    doc::ModDoc_(doc::ModDoc_ {\n         item: (fold.fold_item)(fold, doc.item),\n         .. *doc\n     })\n@@ -79,7 +79,7 @@ fn fold_nmod(fold: &fold::Fold<Ctxt>, +doc: doc::NmodDoc) -> doc::NmodDoc {\n     let doc = fold::default_seq_fold_nmod(fold, doc);\n     fold.ctxt.path.pop();\n \n-    {\n+    doc::NmodDoc {\n         item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }"}, {"sha": "c3d31d4a5b0ad9db53743802eb76163526c23379", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -42,7 +42,7 @@ fn fold_mod(\n ) -> doc::ModDoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n-    doc::ModDoc_({\n+    doc::ModDoc_(doc::ModDoc_ {\n         items: do doc.items.filtered |ItemTag| {\n             !is_hidden(fold.ctxt, ItemTag.item())\n         },"}, {"sha": "a18530a74603a49e616733f804df82fb995ee276", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -48,7 +48,7 @@ fn fold_mod(\n ) -> doc::ModDoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n-    doc::ModDoc_({\n+    doc::ModDoc_(doc::ModDoc_ {\n         items: doc.items.filtered(|ItemTag| {\n             is_visible(fold.ctxt, ItemTag.item())\n         }),"}, {"sha": "706aecf49b95b5c50a66acf75547cf55b69abaec", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -46,7 +46,7 @@ fn fold_item(fold: &fold::Fold<()>, +doc: doc::ItemDoc) -> doc::ItemDoc {\n     let doc = fold::default_seq_fold_item(fold, doc);\n     let (desc, sections) = sectionalize(doc.desc);\n \n-    {\n+    doc::ItemDoc {\n         desc: desc,\n         sections: sections,\n         .. doc\n@@ -56,11 +56,11 @@ fn fold_item(fold: &fold::Fold<()>, +doc: doc::ItemDoc) -> doc::ItemDoc {\n fn fold_trait(fold: &fold::Fold<()>, +doc: doc::TraitDoc) -> doc::TraitDoc {\n     let doc = fold::default_seq_fold_trait(fold, doc);\n \n-    {\n+    doc::TraitDoc {\n         methods: do par::map(doc.methods) |method| {\n             let (desc, sections) = sectionalize(method.desc);\n \n-            {\n+            doc::MethodDoc {\n                 desc: desc,\n                 sections: sections,\n                 .. *method\n@@ -73,11 +73,11 @@ fn fold_trait(fold: &fold::Fold<()>, +doc: doc::TraitDoc) -> doc::TraitDoc {\n fn fold_impl(fold: &fold::Fold<()>, +doc: doc::ImplDoc) -> doc::ImplDoc {\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n-    {\n+    doc::ImplDoc {\n         methods: do par::map(doc.methods) |method| {\n             let (desc, sections) = sectionalize(method.desc);\n \n-            {\n+            doc::MethodDoc {\n                 desc: desc,\n                 sections: sections,\n                 .. *method\n@@ -121,15 +121,15 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n             if current_section.is_some() {\n                 sections += ~[current_section.get()];\n             }\n-            current_section = Some({\n+            current_section = Some(doc::Section {\n                 header: header,\n                 body: ~\"\"\n             });\n           }\n           None => {\n             match copy current_section {\n               Some(section) => {\n-                current_section = Some({\n+                current_section = Some(doc::Section {\n                     body: section.body + ~\"\\n\" + *line,\n                     .. section\n                 });"}, {"sha": "42759be68ad325d68e712e5cdad3ec43a14b103e", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -55,7 +55,7 @@ fn fold_mod(\n     +doc: doc::ModDoc\n ) -> doc::ModDoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n-    doc::ModDoc_({\n+    doc::ModDoc_(doc::ModDoc_ {\n         items: sort::merge_sort(doc.items, fold.ctxt.op),\n         .. *doc\n     })"}, {"sha": "fb55641b764f44d2b3a016572a030a71fb2cd74e", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -62,7 +62,7 @@ fn fold_item(\n ) -> doc::ItemDoc {\n     let doc = fold::default_seq_fold_item(fold, doc);\n \n-    {\n+    doc::ItemDoc {\n         brief: maybe_apply_op(fold.ctxt, doc.brief),\n         desc: maybe_apply_op(fold.ctxt, doc.desc),\n         sections: apply_to_sections(fold.ctxt, doc.sections),\n@@ -74,7 +74,7 @@ fn apply_to_sections(\n     op: NominalOp<Op>,\n     sections: ~[doc::Section]\n ) -> ~[doc::Section] {\n-    par::map(sections, |section, copy op| {\n+    par::map(sections, |section, copy op| doc::Section {\n         header: (op.op)(section.header),\n         body: (op.op)(section.body)\n     })\n@@ -86,9 +86,9 @@ fn fold_enum(\n     let doc = fold::default_seq_fold_enum(fold, doc);\n     let fold_copy = copy *fold;\n \n-    {\n+    doc::EnumDoc {\n         variants: do par::map(doc.variants) |variant, copy fold_copy| {\n-            {\n+            doc::VariantDoc {\n                 desc: maybe_apply_op(fold_copy.ctxt, variant.desc),\n                 .. *variant\n             }\n@@ -103,7 +103,7 @@ fn fold_trait(\n ) -> doc::TraitDoc {\n     let doc = fold::default_seq_fold_trait(fold, doc);\n \n-    {\n+    doc::TraitDoc {\n         methods: apply_to_methods(fold.ctxt, doc.methods),\n         .. doc\n     }\n@@ -114,7 +114,7 @@ fn apply_to_methods(\n     docs: ~[doc::MethodDoc]\n ) -> ~[doc::MethodDoc] {\n     do par::map(docs) |doc, copy op| {\n-        {\n+        doc::MethodDoc {\n             brief: maybe_apply_op(op, doc.brief),\n             desc: maybe_apply_op(op, doc.desc),\n             sections: apply_to_sections(op, doc.sections),\n@@ -129,7 +129,7 @@ fn fold_impl(\n ) -> doc::ImplDoc {\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n-    {\n+    doc::ImplDoc {\n         methods: apply_to_methods(fold.ctxt, doc.methods),\n         .. doc\n     }"}, {"sha": "3b9991d18274e46a4a10d034191742cfceef3054", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -59,7 +59,7 @@ fn fold_fn(\n \n     let srv = fold.ctxt;\n \n-    {\n+    doc::SimpleItemDoc {\n         sig: get_fn_sig(srv, doc.id()),\n         .. doc\n     }\n@@ -101,7 +101,7 @@ fn fold_const(\n ) -> doc::ConstDoc {\n     let srv = fold.ctxt;\n \n-    {\n+    doc::SimpleItemDoc {\n         sig: Some(do astsrv::exec(srv) |ctxt| {\n             match ctxt.ast_map.get(doc.id()) {\n               ast_map::node_item(@ast::item {\n@@ -129,7 +129,7 @@ fn fold_enum(\n     let doc_id = doc.id();\n     let srv = fold.ctxt;\n \n-    {\n+    doc::EnumDoc {\n         variants: do par::map(doc.variants) |variant| {\n             let variant = *variant;\n             let sig = do astsrv::exec(srv) |ctxt| {\n@@ -148,7 +148,7 @@ fn fold_enum(\n                 }\n             };\n \n-            {\n+            doc::VariantDoc {\n                 sig: Some(sig),\n                 .. variant\n             }\n@@ -167,7 +167,7 @@ fn fold_trait(\n     fold: &fold::Fold<astsrv::Srv>,\n     +doc: doc::TraitDoc\n ) -> doc::TraitDoc {\n-    {\n+    doc::TraitDoc {\n         methods: merge_methods(fold.ctxt, doc.id(), doc.methods),\n         .. doc\n     }\n@@ -179,7 +179,7 @@ fn merge_methods(\n     docs: ~[doc::MethodDoc]\n ) -> ~[doc::MethodDoc] {\n     do par::map(docs) |doc| {\n-        {\n+        doc::MethodDoc {\n             sig: get_method_sig(srv, item_id, doc.name),\n             .. *doc\n         }\n@@ -276,7 +276,7 @@ fn fold_impl(\n         }\n     };\n \n-    {\n+    doc::ImplDoc {\n         trait_types: trait_types,\n         self_ty: self_ty,\n         methods: merge_methods(fold.ctxt, doc.id(), doc.methods),\n@@ -316,7 +316,7 @@ fn fold_type(\n \n     let srv = fold.ctxt;\n \n-    {\n+    doc::SimpleItemDoc {\n         sig: do astsrv::exec(srv) |ctxt| {\n             match ctxt.ast_map.get(doc.id()) {\n               ast_map::node_item(@ast::item {\n@@ -349,7 +349,7 @@ fn fold_struct(\n ) -> doc::StructDoc {\n     let srv = fold.ctxt;\n \n-    {\n+    doc::StructDoc {\n         sig: do astsrv::exec(srv) |ctxt| {\n             match ctxt.ast_map.get(doc.id()) {\n                 ast_map::node_item(item, _) => {"}, {"sha": "4283a7e402bcee4ef7346d89a3021b8d76166398", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -17,7 +17,7 @@ A BigInt is a combination of BigUint and Sign.\n */\n \n use core::cmp::{Eq, Ord};\n-use core::num::{Num, Zero, One};\n+use core::num::{IntConvertible, Zero, One};\n use core::*;\n \n /**\n@@ -121,7 +121,7 @@ impl BigUint : One {\n     static pub pure fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n-impl BigUint : Num {\n+impl BigUint : Add<BigUint, BigUint> {\n     pure fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n@@ -138,7 +138,9 @@ impl BigUint : Num {\n         if carry == 0 { return BigUint::new(sum) };\n         return BigUint::new(sum + [carry]);\n     }\n+}\n \n+impl BigUint : Sub<BigUint, BigUint> {\n     pure fn sub(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n@@ -161,7 +163,9 @@ impl BigUint : Num {\n         assert borrow == 0;     // <=> assert (self >= other);\n         return BigUint::new(diff);\n     }\n+}\n \n+impl BigUint : Mul<BigUint, BigUint> {\n     pure fn mul(&self, other: &BigUint) -> BigUint {\n         if self.is_zero() || other.is_zero() { return Zero::zero(); }\n \n@@ -224,18 +228,27 @@ impl BigUint : Num {\n             }\n         }\n     }\n+}\n \n+impl BigUint : Div<BigUint, BigUint> {\n     pure fn div(&self, other: &BigUint) -> BigUint {\n         let (d, _) = self.divmod(other);\n         return d;\n     }\n+}\n+\n+impl BigUint : Modulo<BigUint, BigUint> {\n     pure fn modulo(&self, other: &BigUint) -> BigUint {\n         let (_, m) = self.divmod(other);\n         return m;\n     }\n+}\n \n+impl BigUint : Neg<BigUint> {\n     pure fn neg(&self) -> BigUint { fail }\n+}\n \n+impl BigUint : IntConvertible {\n     pure fn to_int(&self) -> int {\n         uint::min(self.to_uint(), int::max_value as uint) as int\n     }\n@@ -625,7 +638,7 @@ impl BigInt : One {\n     }\n }\n \n-impl BigInt : Num {\n+impl BigInt : Add<BigInt, BigInt> {\n     pure fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)      => copy *other,\n@@ -637,6 +650,9 @@ impl BigInt : Num {\n             (Minus, Minus) => -((-self) + (-*other))\n         }\n     }\n+}\n+\n+impl BigInt : Sub<BigInt, BigInt> {\n     pure fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)    => -other,\n@@ -654,6 +670,9 @@ impl BigInt : Num {\n             (Minus, Minus) => (-other) - (-*self)\n         }\n     }\n+}\n+\n+impl BigInt : Mul<BigInt, BigInt> {\n     pure fn mul(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)     | (_,     Zero)  => Zero::zero(),\n@@ -665,18 +684,29 @@ impl BigInt : Num {\n             }\n         }\n     }\n+}\n+\n+impl BigInt : Div<BigInt, BigInt> {\n     pure fn div(&self, other: &BigInt) -> BigInt {\n         let (d, _) = self.divmod(other);\n         return d;\n     }\n+}\n+\n+impl BigInt : Modulo<BigInt, BigInt> {\n     pure fn modulo(&self, other: &BigInt) -> BigInt {\n         let (_, m) = self.divmod(other);\n         return m;\n     }\n+}\n+\n+impl BigInt : Neg<BigInt> {\n     pure fn neg(&self) -> BigInt {\n         BigInt::from_biguint(self.sign.neg(), copy self.data)\n     }\n+}\n \n+impl BigInt : IntConvertible {\n     pure fn to_int(&self) -> int {\n         match self.sign {\n             Plus  => uint::min(self.to_uint(), int::max_value as uint) as int,\n@@ -834,7 +864,7 @@ pub impl BigInt {\n mod biguint_tests {\n \n     use core::*;\n-    use core::num::{Num, Zero, One};\n+    use num::{IntConvertible, Zero, One};\n     use super::{BigInt, BigUint, BigDigit};\n \n     #[test]\n@@ -974,7 +1004,7 @@ mod biguint_tests {\n     fn test_convert_int() {\n         fn check(v: ~[BigDigit], i: int) {\n             let b = BigUint::new(v);\n-            assert b == Num::from_int(i);\n+            assert b == IntConvertible::from_int(i);\n             assert b.to_int() == i;\n         }\n \n@@ -1244,7 +1274,7 @@ mod bigint_tests {\n     use super::{BigInt, BigUint, BigDigit, Sign, Minus, Zero, Plus};\n \n     use core::*;\n-    use core::num::{Num, Zero, One};\n+    use core::num::{IntConvertible, Zero, One};\n \n     #[test]\n     fn test_from_biguint() {\n@@ -1303,7 +1333,7 @@ mod bigint_tests {\n     #[test]\n     fn test_convert_int() {\n         fn check(b: BigInt, i: int) {\n-            assert b == Num::from_int(i);\n+            assert b == IntConvertible::from_int(i);\n             assert b.to_int() == i;\n         }\n \n@@ -1563,7 +1593,8 @@ mod bigint_tests {\n     #[test]\n     fn test_to_str_radix() {\n         fn check(n: int, ans: &str) {\n-            assert ans == Num::from_int::<BigInt>(n).to_str_radix(10);\n+            assert ans == IntConvertible::from_int::<BigInt>(\n+                n).to_str_radix(10);\n         }\n         check(10, \"10\");\n         check(1, \"1\");\n@@ -1576,7 +1607,7 @@ mod bigint_tests {\n     #[test]\n     fn test_from_str_radix() {\n         fn check(s: &str, ans: Option<int>) {\n-            let ans = ans.map(|&n| Num::from_int(n));\n+            let ans = ans.map(|&n| IntConvertible::from_int(n));\n             assert BigInt::from_str_radix(s, 10) == ans;\n         }\n         check(\"10\", Some(10));"}, {"sha": "2abd59523a1046fe77c2e5c8e8e88bf22dd5370e", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 4, "deletions": 54, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -249,69 +249,19 @@ mod tests {\n         assert deq.get(3) == d;\n     }\n \n+    #[deriving_eq]\n     enum Taggy { One(int), Two(int, int), Three(int, int, int), }\n \n+    #[deriving_eq]\n     enum Taggypar<T> {\n         Onepar(int), Twopar(int, int), Threepar(int, int, int),\n     }\n \n+    #[deriving_eq]\n     struct RecCy {\n         x: int,\n         y: int,\n-        t: Taggy,\n-    }\n-\n-    impl Taggy : Eq {\n-        pure fn eq(&self, other: &Taggy) -> bool {\n-            match (*self) {\n-              One(a1) => match (*other) {\n-                One(b1) => return a1 == b1,\n-                _ => return false\n-              },\n-              Two(a1, a2) => match (*other) {\n-                Two(b1, b2) => return a1 == b1 && a2 == b2,\n-                _ => return false\n-              },\n-              Three(a1, a2, a3) => match (*other) {\n-                Three(b1, b2, b3) => return a1 == b1 && a2 == b2 && a3 == b3,\n-                _ => return false\n-              }\n-            }\n-        }\n-        pure fn ne(&self, other: &Taggy) -> bool { !(*self).eq(other) }\n-    }\n-\n-    impl Taggypar<int> : Eq {\n-        //let eq4: EqFn<Taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n-        pure fn eq(&self, other: &Taggypar<int>) -> bool {\n-                  match (*self) {\n-                    Onepar::<int>(a1) => match (*other) {\n-                      Onepar::<int>(b1) => return a1 == b1,\n-                      _ => return false\n-                    },\n-                    Twopar::<int>(a1, a2) => match (*other) {\n-                      Twopar::<int>(b1, b2) => return a1 == b1 && a2 == b2,\n-                      _ => return false\n-                    },\n-                    Threepar::<int>(a1, a2, a3) => match (*other) {\n-                      Threepar::<int>(b1, b2, b3) => {\n-                          return a1 == b1 && a2 == b2 && a3 == b3\n-                      }\n-                      _ => return false\n-                    }\n-                  }\n-        }\n-        pure fn ne(&self, other: &Taggypar<int>) -> bool {\n-            !(*self).eq(other)\n-        }\n-    }\n-\n-    impl RecCy : Eq {\n-        pure fn eq(&self, other: &RecCy) -> bool {\n-          return (*self).x == (*other).x && (*self).y == (*other).y &&\n-                 (*self).t == (*other).t;\n-        }\n-        pure fn ne(&self, other: &RecCy) -> bool { !(*self).eq(other) }\n+        t: Taggy\n     }\n \n     #[test]"}, {"sha": "f93705c0c62b6a9466319a25923720a5ee354db0", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -676,6 +676,7 @@ pub mod writer {\n mod tests {\n     use ebml::reader;\n     use ebml::writer;\n+    use serialize::Encodable;\n     use serialize;\n \n     use core::io;"}, {"sha": "1361d8647b574140fa88307aa9fc3822b4b8aff2", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -15,6 +15,7 @@\n \n //! json serialization\n \n+use serialize::Encodable;\n use serialize;\n use sort::Sort;\n "}, {"sha": "f3016e9df21a8a9b44e2b38658381e55d914bf89", "filename": "src/libstd/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -28,7 +28,7 @@ pub type Set<K:Eq IterBytes Hash> = HashMap<K, ()>;\n \n pub type HashMap<K:Eq IterBytes Hash, V> = chained::T<K, V>;\n \n-pub trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n+pub trait StdMap<K:Eq IterBytes Hash Copy, V: Copy> {\n     /// Return the number of elements in the map\n     pure fn size() -> uint;\n \n@@ -124,7 +124,7 @@ pub mod util {\n // FIXME (#2344): package this up and export it as a datatype usable for\n // external code that doesn't want to pay the cost of a box.\n pub mod chained {\n-    use map::{Map, util};\n+    use map::{StdMap, util};\n \n     use core::io;\n     use core::ops;\n@@ -239,7 +239,7 @@ pub mod chained {\n         }\n     }\n \n-    impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V>: Map<K, V> {\n+    impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V>: StdMap<K, V> {\n         pure fn size() -> uint { self.count }\n \n         pure fn contains_key(k: K) -> bool {"}, {"sha": "f17fce28ea93b1d449e3c16f42eb03e5e655c14a", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -15,7 +15,7 @@\n #[forbid(deprecated_mode)];\n \n use map;\n-use map::Map;\n+use map::StdMap;\n \n use core::dvec::DVec;\n use core::ops;\n@@ -81,7 +81,7 @@ pub pure fn contains_key<T: Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n }\n \n /// Implements the map::map interface for smallintmap\n-impl<V: Copy> SmallIntMap<V>: map::Map<uint, V> {\n+impl<V: Copy> SmallIntMap<V>: map::StdMap<uint, V> {\n     pure fn size() -> uint {\n         let mut sz = 0u;\n         for self.v.each |item| {\n@@ -165,8 +165,8 @@ impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n }\n \n /// Cast the given smallintmap to a map::map\n-pub fn as_map<V: Copy>(s: SmallIntMap<V>) -> map::Map<uint, V> {\n-    s as map::Map::<uint, V>\n+pub fn as_map<V: Copy>(s: SmallIntMap<V>) -> map::StdMap<uint, V> {\n+    s as map::StdMap::<uint, V>\n }\n \n #[cfg(test)]"}, {"sha": "201d53c0c3f360ef883ff37a4aa13f20fa7f228a", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -12,7 +12,7 @@ use core::prelude::*;\n \n use ast::*;\n use ast;\n-use ast_util::{path_to_ident, stmt_id};\n+use ast_util::{inlined_item_utils, path_to_ident, stmt_id};\n use ast_util;\n use attr;\n use codemap;"}, {"sha": "7b134a8db2424ec85cf312145cf106654513a670", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -376,7 +376,7 @@ pure fn struct_field_visibility(field: ast::struct_field) -> visibility {\n     }\n }\n \n-trait inlined_item_utils {\n+pub trait inlined_item_utils {\n     fn ident() -> ident;\n     fn id() -> ast::node_id;\n     fn accept<E>(e: E, v: visit::vt<E>);"}, {"sha": "7e3cbd18f5273a0f7fff9951a2f858a6f858527e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -33,7 +33,7 @@ use core::uint;\n use core::vec;\n use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-trait Pos {\n+pub trait Pos {\n     static pure fn from_uint(n: uint) -> self;\n     pure fn to_uint(&self) -> uint;\n }"}, {"sha": "4c0cc161fdd03580122132b22283054d447024ab", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -10,7 +10,7 @@\n \n use core::prelude::*;\n \n-use codemap::span;\n+use codemap::{Pos, span};\n use codemap;\n \n use core::cmp;"}, {"sha": "8a5b8a127d035cd284b1af0afe9c5945342a2c73", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -66,7 +66,7 @@ impl @ast::path: append_types {\n     }\n }\n \n-trait ext_ctxt_ast_builder {\n+pub trait ext_ctxt_ast_builder {\n     fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n         -> ast::ty_param;\n     fn arg(name: ident, ty: @ast::Ty) -> ast::arg;"}, {"sha": "f91ec1ea48f85bb1615416d02eda6dd8af408ae9", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -49,6 +49,7 @@ use codemap::span;\n use ext::base;\n use ext::base::ext_ctxt;\n use ext::pipes::parse_proto::proto_parser;\n+use ext::pipes::pipec::gen_init;\n use ext::pipes::proto::{visit, protocol};\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;"}, {"sha": "774a5596258280966c1631a7f5494ed74c036a8d", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -13,7 +13,8 @@\n use ast::ident;\n use ast_util::dummy_sp;\n use ext::base::ext_ctxt;\n-use ext::pipes::ast_builder::{append_types, path, path_global};\n+use ext::pipes::ast_builder::{append_types, ext_ctxt_ast_builder, path};\n+use ext::pipes::ast_builder::{path_global};\n use ext::pipes::proto::*;\n use ext::quote::rt::*;\n use parse::*;\n@@ -35,7 +36,7 @@ trait to_type_decls {\n     fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> ~[@ast::item];\n }\n \n-trait gen_init {\n+pub trait gen_init {\n     fn gen_init(cx: ext_ctxt) -> @ast::item;\n     fn compile(cx: ext_ctxt) -> @ast::item;\n     fn buffer_ty_path(cx: ext_ctxt) -> @ast::Ty;"}, {"sha": "9d24b3db72437ac3ebdc270e8b389457b95f1b72", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -13,7 +13,7 @@ use core::prelude::*;\n use ast;\n use codemap::span;\n use ext::base::ext_ctxt;\n-use ext::pipes::ast_builder::{path, append_types};\n+use ext::pipes::ast_builder::{append_types, ext_ctxt_ast_builder, path};\n \n use core::cmp;\n use core::dvec::DVec;"}, {"sha": "7605e01fbf0248000b0cc4ae03e70e5eca733f49", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -10,7 +10,7 @@\n \n use ast;\n use attr;\n-use codemap::{span, BytePos};\n+use codemap::{BytePos, Pos, span};\n use ext::base::ext_ctxt;\n use ext::base;\n use ext::build;"}, {"sha": "4ecbbdc9760babf56909cc06e209b462f1f7385c", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use codemap;\n-use codemap::{span, Loc, FileMap};\n+use codemap::{FileMap, Loc, Pos, span};\n use ext::base::*;\n use ext::base;\n use ext::build::{mk_base_vec_e, mk_uint, mk_u8, mk_base_str};"}, {"sha": "fbe258852e2736ec6629dea824d4f37c7041142d", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -11,7 +11,7 @@\n use core::prelude::*;\n \n use ast;\n-use codemap::{BytePos, CharPos, CodeMap, FileMap};\n+use codemap::{BytePos, CharPos, CodeMap, FileMap, Pos};\n use diagnostic;\n use parse::lexer::{is_whitespace, get_str_from, reader};\n use parse::lexer::{string_reader, bump, is_eof, nextch};"}, {"sha": "5a0f40f3c12f58ba043458c3f243450ebbd3b033", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -12,7 +12,7 @@ use core::prelude::*;\n \n use ast;\n use ast_util;\n-use codemap::{span, CodeMap, CharPos, BytePos};\n+use codemap::{BytePos, CharPos, CodeMap, Pos, span};\n use codemap;\n use diagnostic::span_handler;\n use ext::tt::transcribe::{tt_next_token};"}, {"sha": "73ec1f47230fe3ecf099ad57ca09cbaa29c8057e", "filename": "src/test/auxiliary/issue_2242_b.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f1e78c6dd7dc41a9937c466a7af5d0efc779909f/src%2Ftest%2Fauxiliary%2Fissue_2242_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e78c6dd7dc41a9937c466a7af5d0efc779909f/src%2Ftest%2Fauxiliary%2Fissue_2242_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_b.rs?ref=f1e78c6dd7dc41a9937c466a7af5d0efc779909f", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[link(name = \"b\", vers = \"0.1\")];\n-#[crate_type = \"lib\"];\n-\n-extern mod a;\n-use a::to_strz;\n-\n-impl int: to_strz {\n-    fn to_strz() -> ~str { fmt!(\"%?\", self) }\n-}"}, {"sha": "6988027235074e7c4c24f7ff1a29f558337128e3", "filename": "src/test/compile-fail/drop-on-non-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -11,6 +11,7 @@\n type Foo = @[u8];\n \n impl Foo : Drop {   //~ ERROR the Drop trait may only be implemented\n+//~^ ERROR cannot provide an extension implementation\n     fn finalize(&self) {\n         io::println(\"kaboom\");\n     }"}, {"sha": "7161e854447923276a53f02a330dbb093fc4218d", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -11,12 +11,13 @@\n extern mod std;\n use std::map;\n use std::map::HashMap;\n-use std::map::Map;\n+use std::map::StdMap;\n \n // Test that trait types printed in error msgs include the type arguments.\n \n fn main() {\n-    let x: Map<~str,~str> = map::HashMap::<~str,~str>() as Map::<~str,~str>;\n-    let y: Map<uint,~str> = x;\n-    //~^ ERROR mismatched types: expected `@std::map::Map<uint,~str>`\n+    let x: StdMap<~str,~str> = map::HashMap::<~str,~str>() as\n+        StdMap::<~str,~str>;\n+    let y: StdMap<uint,~str> = x;\n+    //~^ ERROR mismatched types: expected `@std::map::StdMap<uint,~str>`\n }"}, {"sha": "ec73704ca27bab5ed49d508707a7914f001e9cca", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -128,19 +128,16 @@ impl CLike : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n struct Spanned<T> {\n     lo: uint,\n     hi: uint,\n     node: T,\n }\n \n-impl<T:cmp::Eq> Spanned<T> : cmp::Eq {\n-    pure fn eq(&self, other: &Spanned<T>) -> bool {\n-        self.lo == other.lo &&\n-        self.hi == other.hi &&\n-        self.node == other.node\n-    }\n-    pure fn ne(&self, other: &Spanned<T>) -> bool { !self.eq(other) }\n+enum AnEnum {\n+    AVariant,\n+    AnotherVariant\n }\n \n #[auto_encode]"}, {"sha": "6bc881884522a744253d7815d381de34fc0fb276", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4d39e1fef918242a5dba2a09d7b9faa437b911/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=eb4d39e1fef918242a5dba2a09d7b9faa437b911", "patch": "@@ -51,7 +51,7 @@ impl<T: Copy> cat<T> {\n   }\n }\n \n-impl<T: Copy> cat<T> : Map<int, T> {\n+impl<T: Copy> cat<T> : StdMap<int, T> {\n   pure fn size() -> uint { self.meows as uint }\n   fn insert(+k: int, +_v: T) -> bool {\n     self.meows += k;"}, {"sha": "006a33ebb65ed2c17626ef14735d8c404a082e1b", "filename": "src/test/run-pass/issue-2242-d.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1e78c6dd7dc41a9937c466a7af5d0efc779909f/src%2Ftest%2Frun-pass%2Fissue-2242-d.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e78c6dd7dc41a9937c466a7af5d0efc779909f/src%2Ftest%2Frun-pass%2Fissue-2242-d.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2242-d.rs?ref=f1e78c6dd7dc41a9937c466a7af5d0efc779909f", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast (aux-build)\n-// aux-build:issue_2242_a.rs\n-// aux-build:issue_2242_b.rs\n-// aux-build:issue_2242_c.rs\n-\n-extern mod a;\n-extern mod b;\n-extern mod c;\n-\n-use a::to_strz;\n-\n-fn main() {\n-    io::println((~\"foo\").to_strz());\n-    io::println(1.to_strz());\n-    io::println(true.to_strz());\n-}"}]}