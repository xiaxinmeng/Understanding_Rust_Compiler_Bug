{"sha": "a5c16e58924249bdb6f6f530345dd08495c09dfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YzE2ZTU4OTI0MjQ5YmRiNmY2ZjUzMDM0NWRkMDg0OTVjMDlkZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-21T09:36:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-21T09:36:13Z"}, "message": "Auto merge of #3789 - bzzzzzz:needless_range_loop_bugfix, r=oli-obk\n\nMake needless_range_loop not applicable to structures without iter method\n\nFixes https://github.com/rust-lang/rust-clippy/issues/3788\n\nNow we will start lint indexed structure only if it has known iter or iter_mut method implemented.", "tree": {"sha": "554e87b6d22ecd02058141fe7310244287000bc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/554e87b6d22ecd02058141fe7310244287000bc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5c16e58924249bdb6f6f530345dd08495c09dfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5c16e58924249bdb6f6f530345dd08495c09dfc", "html_url": "https://github.com/rust-lang/rust/commit/a5c16e58924249bdb6f6f530345dd08495c09dfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5c16e58924249bdb6f6f530345dd08495c09dfc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "027dde92e22b9058c2bd6efa4b3e47b78d991dc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/027dde92e22b9058c2bd6efa4b3e47b78d991dc7", "html_url": "https://github.com/rust-lang/rust/commit/027dde92e22b9058c2bd6efa4b3e47b78d991dc7"}, {"sha": "7767b3a08172abaabd8e047a8468b7c8e934cd4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7767b3a08172abaabd8e047a8468b7c8e934cd4f", "html_url": "https://github.com/rust-lang/rust/commit/7767b3a08172abaabd8e047a8468b7c8e934cd4f"}], "stats": {"total": 136, "additions": 90, "deletions": 46}, "files": [{"sha": "fcf6a879b91574d1c553f5dcc55e62ed5f533632", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5c16e58924249bdb6f6f530345dd08495c09dfc/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c16e58924249bdb6f6f530345dd08495c09dfc/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=a5c16e58924249bdb6f6f530345dd08495c09dfc", "patch": "@@ -27,7 +27,7 @@ use syntax_pos::BytePos;\n \n use crate::utils::paths;\n use crate::utils::{\n-    get_enclosing_block, get_parent_expr, higher, is_integer_literal, is_refutable, last_path_segment,\n+    get_enclosing_block, get_parent_expr, has_iter_method, higher, is_integer_literal, is_refutable, last_path_segment,\n     match_trait_method, match_type, match_var, multispan_sugg, snippet, snippet_opt, snippet_with_applicability,\n     span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, SpanlessEq,\n };\n@@ -1118,6 +1118,12 @@ fn check_for_loop_range<'a, 'tcx>(\n                     }\n                 }\n \n+                // don't lint if the container that is indexed does not have .iter() method\n+                let has_iter = has_iter_method(cx, indexed_ty);\n+                if has_iter.is_none() {\n+                    return;\n+                }\n+\n                 // don't lint if the container that is indexed into is also used without\n                 // indexing\n                 if visitor.referenced.contains(&indexed) {"}, {"sha": "4b147cf82a68c90fe36bab937923f20f5eb8fb75", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 21, "deletions": 45, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a5c16e58924249bdb6f6f530345dd08495c09dfc/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c16e58924249bdb6f6f530345dd08495c09dfc/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=a5c16e58924249bdb6f6f530345dd08495c09dfc", "patch": "@@ -1,11 +1,11 @@\n use crate::utils::paths;\n use crate::utils::sugg;\n use crate::utils::{\n-    get_arg_name, get_parent_expr, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of, is_self,\n-    is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n-    match_type, match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path,\n-    snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n+    get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, in_macro, is_copy, is_expn_of,\n+    is_self, is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath,\n+    match_trait_method, match_type, match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys,\n+    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n+    span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n };\n use if_chain::if_chain;\n use matches::matches;\n@@ -2237,47 +2237,23 @@ fn ty_has_iter_method(\n     cx: &LateContext<'_, '_>,\n     self_ref_ty: ty::Ty<'_>,\n ) -> Option<(&'static Lint, &'static str, &'static str)> {\n-    // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n-    // exists and has the desired signature. Unfortunately FnCtxt is not exported\n-    // so we can't use its `lookup_method` method.\n-    static INTO_ITER_COLLECTIONS: [(&Lint, &[&str]); 13] = [\n-        (INTO_ITER_ON_REF, &paths::VEC),\n-        (INTO_ITER_ON_REF, &paths::OPTION),\n-        (INTO_ITER_ON_REF, &paths::RESULT),\n-        (INTO_ITER_ON_REF, &paths::BTREESET),\n-        (INTO_ITER_ON_REF, &paths::BTREEMAP),\n-        (INTO_ITER_ON_REF, &paths::VEC_DEQUE),\n-        (INTO_ITER_ON_REF, &paths::LINKED_LIST),\n-        (INTO_ITER_ON_REF, &paths::BINARY_HEAP),\n-        (INTO_ITER_ON_REF, &paths::HASHSET),\n-        (INTO_ITER_ON_REF, &paths::HASHMAP),\n-        (INTO_ITER_ON_ARRAY, &[\"std\", \"path\", \"PathBuf\"]),\n-        (INTO_ITER_ON_REF, &[\"std\", \"path\", \"Path\"]),\n-        (INTO_ITER_ON_REF, &[\"std\", \"sync\", \"mpsc\", \"Receiver\"]),\n-    ];\n-\n-    let (self_ty, mutbl) = match self_ref_ty.sty {\n-        ty::Ref(_, self_ty, mutbl) => (self_ty, mutbl),\n-        _ => unreachable!(),\n-    };\n-    let method_name = match mutbl {\n-        hir::MutImmutable => \"iter\",\n-        hir::MutMutable => \"iter_mut\",\n-    };\n-\n-    let def_id = match self_ty.sty {\n-        ty::Array(..) => return Some((INTO_ITER_ON_ARRAY, \"array\", method_name)),\n-        ty::Slice(..) => return Some((INTO_ITER_ON_REF, \"slice\", method_name)),\n-        ty::Adt(adt, _) => adt.did,\n-        _ => return None,\n-    };\n-\n-    for (lint, path) in &INTO_ITER_COLLECTIONS {\n-        if match_def_path(cx.tcx, def_id, path) {\n-            return Some((lint, path.last().unwrap(), method_name));\n-        }\n+    if let Some(ty_name) = has_iter_method(cx, self_ref_ty) {\n+        let lint = match ty_name {\n+            \"array\" | \"PathBuf\" => INTO_ITER_ON_ARRAY,\n+            _ => INTO_ITER_ON_REF,\n+        };\n+        let mutbl = match self_ref_ty.sty {\n+            ty::Ref(_, _, mutbl) => mutbl,\n+            _ => unreachable!(),\n+        };\n+        let method_name = match mutbl {\n+            hir::MutImmutable => \"iter\",\n+            hir::MutMutable => \"iter_mut\",\n+        };\n+        Some((lint, ty_name, method_name))\n+    } else {\n+        None\n     }\n-    None\n }\n \n fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: ty::Ty<'_>, method_span: Span) {"}, {"sha": "d959d7490ebcbc6d3fb2a48ad03869db8eaf80c4", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a5c16e58924249bdb6f6f530345dd08495c09dfc/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c16e58924249bdb6f6f530345dd08495c09dfc/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=a5c16e58924249bdb6f6f530345dd08495c09dfc", "patch": "@@ -1155,6 +1155,47 @@ pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_, '_, '_>, node: NodeId\n     false\n }\n \n+/// Returns true if ty has `iter` or `iter_mut` methods\n+pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: ty::Ty<'_>) -> Option<&'static str> {\n+    // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n+    // exists and has the desired signature. Unfortunately FnCtxt is not exported\n+    // so we can't use its `lookup_method` method.\n+    static INTO_ITER_COLLECTIONS: [&[&str]; 13] = [\n+        &paths::VEC,\n+        &paths::OPTION,\n+        &paths::RESULT,\n+        &paths::BTREESET,\n+        &paths::BTREEMAP,\n+        &paths::VEC_DEQUE,\n+        &paths::LINKED_LIST,\n+        &paths::BINARY_HEAP,\n+        &paths::HASHSET,\n+        &paths::HASHMAP,\n+        &paths::PATH_BUF,\n+        &paths::PATH,\n+        &paths::RECEIVER,\n+    ];\n+\n+    let ty_to_check = match probably_ref_ty.sty {\n+        ty::Ref(_, ty_to_check, _) => ty_to_check,\n+        _ => probably_ref_ty,\n+    };\n+\n+    let def_id = match ty_to_check.sty {\n+        ty::Array(..) => return Some(\"array\"),\n+        ty::Slice(..) => return Some(\"slice\"),\n+        ty::Adt(adt, _) => adt.did,\n+        _ => return None,\n+    };\n+\n+    for path in &INTO_ITER_COLLECTIONS {\n+        if match_def_path(cx.tcx, def_id, path) {\n+            return Some(path.last().unwrap());\n+        }\n+    }\n+    None\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::{trim_multiline, without_block_comments};"}, {"sha": "9ee25aaea5ead2ff86481be069d65e4f7ad3c240", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5c16e58924249bdb6f6f530345dd08495c09dfc/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c16e58924249bdb6f6f530345dd08495c09dfc/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=a5c16e58924249bdb6f6f530345dd08495c09dfc", "patch": "@@ -62,6 +62,7 @@ pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n pub const OS_STRING: [&str; 4] = [\"std\", \"ffi\", \"os_str\", \"OsString\"];\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n pub const PARTIAL_ORD: [&str; 3] = [\"core\", \"cmp\", \"PartialOrd\"];\n+pub const PATH: [&str; 3] = [\"std\", \"path\", \"Path\"];\n pub const PATH_BUF: [&str; 3] = [\"std\", \"path\", \"PathBuf\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n pub const PTR_NULL: [&str; 2] = [\"ptr\", \"null\"];\n@@ -80,6 +81,7 @@ pub const RANGE_TO_INCLUSIVE: [&str; 3] = [\"core\", \"ops\", \"RangeToInclusive\"];\n pub const RANGE_TO_INCLUSIVE_STD: [&str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n pub const RANGE_TO_STD: [&str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n+pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n pub const REGEX: [&str; 3] = [\"regex\", \"re_unicode\", \"Regex\"];\n pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"bytes\", \"RegexBuilder\", \"new\"];"}, {"sha": "70ad6eac65f6d59dced91a7ad969c50b4d472adc", "filename": "tests/ui/needless_range_loop.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a5c16e58924249bdb6f6f530345dd08495c09dfc/tests%2Fui%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c16e58924249bdb6f6f530345dd08495c09dfc/tests%2Fui%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_range_loop.rs?ref=a5c16e58924249bdb6f6f530345dd08495c09dfc", "patch": "@@ -85,4 +85,23 @@ fn main() {\n     for i in 0..vec.len() {\n         vec[i] = Some(1).unwrap_or_else(|| panic!(\"error on {}\", i));\n     }\n+\n+    // #3788\n+    let test = Test {\n+        inner: vec![1, 2, 3, 4],\n+    };\n+    for i in 0..2 {\n+        println!(\"{}\", test[i]);\n+    }\n+}\n+\n+struct Test {\n+    inner: Vec<usize>,\n+}\n+\n+impl std::ops::Index<usize> for Test {\n+    type Output = usize;\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self.inner[index]\n+    }\n }"}]}