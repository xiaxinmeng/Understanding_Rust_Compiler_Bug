{"sha": "d6dd65620e932eacb408b5b2825baf833e560719", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZGQ2NTYyMGU5MzJlYWNiNDA4YjViMjgyNWJhZjgzM2U1NjA3MTk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-01-04T23:32:57Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-01-04T23:50:54Z"}, "message": "Rustup to rustc 1.16.0-nightly (468227129 2017-01-03): Fix self type", "tree": {"sha": "dd81861b087c962a54865a03152b31bd187542cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd81861b087c962a54865a03152b31bd187542cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6dd65620e932eacb408b5b2825baf833e560719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6dd65620e932eacb408b5b2825baf833e560719", "html_url": "https://github.com/rust-lang/rust/commit/d6dd65620e932eacb408b5b2825baf833e560719", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6dd65620e932eacb408b5b2825baf833e560719/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "571369af1be0c0a7cc09ac3cf2cd6cfc7da65cff", "url": "https://api.github.com/repos/rust-lang/rust/commits/571369af1be0c0a7cc09ac3cf2cd6cfc7da65cff", "html_url": "https://github.com/rust-lang/rust/commit/571369af1be0c0a7cc09ac3cf2cd6cfc7da65cff"}], "stats": {"total": 68, "additions": 43, "deletions": 25}, "files": [{"sha": "9f2cecebca1978150250ff171c940f988a40faba", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d6dd65620e932eacb408b5b2825baf833e560719/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dd65620e932eacb408b5b2825baf833e560719/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=d6dd65620e932eacb408b5b2825baf833e560719", "patch": "@@ -11,7 +11,7 @@ use syntax::codemap::Span;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path, match_trait_method,\n             match_type, method_chain_args, return_ty, same_tys, snippet, span_lint, span_lint_and_then,\n             span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, last_path_segment, single_segment_path,\n-            match_def_path, is_self, iter_input_pats};\n+            match_def_path, is_self, is_self_ty, iter_input_pats};\n use utils::paths;\n use utils::sugg;\n \n@@ -637,15 +637,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         let item = cx.tcx.map.expect_item(parent);\n         if_let_chain! {[\n             let hir::ImplItemKind::Method(ref sig, id) = implitem.node,\n+            let Some(first_arg_ty) = sig.decl.inputs.get(0),\n             let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.map.body(id)).next(),\n-            let hir::ItemImpl(_, _, _, None, _, _) = item.node,\n+            let hir::ItemImpl(_, _, _, None, ref self_ty, _) = item.node,\n         ], {\n             // check missing trait implementations\n             for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n                 if &*name.as_str() == method_name &&\n                    sig.decl.inputs.len() == n_args &&\n                    out_type.matches(&sig.decl.output) &&\n-                   self_kind.matches(&first_arg, false) {\n+                   self_kind.matches(&first_arg_ty, &first_arg, &self_ty, false) {\n                     span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n                         \"defining a method called `{}` on this type; consider implementing \\\n                          the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n@@ -658,7 +659,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n                     conv.check(&name.as_str()),\n-                    !self_kinds.iter().any(|k| k.matches(&first_arg, is_copy)),\n+                    !self_kinds.iter().any(|k| k.matches(&first_arg_ty, &first_arg, &self_ty, is_copy)),\n                 ], {\n                     let lint = if item.vis == hir::Visibility::Public {\n                         WRONG_PUB_SELF_CONVENTION\n@@ -752,7 +753,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n         // FIXME: can we `expect` here instead of match?\n         let promotable = cx.tcx.rvalue_promotable_to_static.borrow()\n                              .get(&arg.id).cloned().unwrap_or(true);\n-        if !promotable {\n+        if promotable {\n             return;\n         }\n \n@@ -1346,34 +1347,40 @@ enum SelfKind {\n }\n \n impl SelfKind {\n-    fn matches(self, slf: &hir::Arg, allow_value_for_ref: bool) -> bool {\n-        if is_self(slf) {\n-           match (self, &slf.pat.node) {\n-                (SelfKind::Value, &hir::PatKind::Binding(hir::BindingMode::BindByValue(_), ..)) |\n-                (SelfKind::Ref, &hir::PatKind::Ref(_, hir::Mutability::MutImmutable)) |\n-                (SelfKind::RefMut, &hir::PatKind::Ref(_, hir::Mutability::MutMutable)) => true,\n-                (SelfKind::Ref, &hir::PatKind::Binding(hir::BindingMode::BindByRef(hir::Mutability::MutImmutable), ..)) |\n-                (SelfKind::RefMut, &hir::PatKind::Binding(hir::BindingMode::BindByRef(hir::Mutability::MutMutable), ..)) => allow_value_for_ref,\n-//                (_, &hir::PatKind::Explicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n+    fn matches(self, ty: &hir::Ty, arg: &hir::Arg, self_ty: &hir::Ty, allow_value_for_ref: bool) -> bool {\n+        // Self types in the HIR are desugared to explicit self types. So it will always be `self: SomeType`,\n+        // where SomeType can be `Self` or an explicit impl self type (e.g. `Foo` if the impl is on `Foo`)\n+        // Thus, we only need to test equality against the impl self type or if it is an explicit\n+        // `Self`. Furthermore, the only possible types for `self: ` are `&Self`, `Self`, `&mut Self`,\n+        // and `Box<Self>`, including the equivalent types with `Foo`.\n+        let is_actually_self = |ty| {\n+            is_self_ty(ty) || ty == self_ty\n+        };\n+        if is_self(arg) {\n+           match self {\n+                SelfKind::Value => is_actually_self(ty),\n+                SelfKind::Ref | SelfKind::RefMut if allow_value_for_ref => is_actually_self(ty),\n+                SelfKind::Ref | SelfKind::RefMut=> {\n+                    match ty.node {\n+                        hir::TyRptr(_, ref mt_ty) => {\n+                            let mutability_match = if self == SelfKind::Ref {\n+                                mt_ty.mutbl == hir::MutImmutable\n+                            } else {\n+                                mt_ty.mutbl == hir::MutMutable\n+                            };\n+                            is_actually_self(&mt_ty.ty) && mutability_match\n \n+                        }\n+                        _ => false\n+                    }\n+                }\n                 _ => false,\n             }\n         } else {\n             self == SelfKind::No\n         }\n     }\n \n-    fn matches_explicit_type(self, ty: &hir::Ty, allow_value_for_ref: bool) -> bool {\n-        match (self, &ty.node) {\n-            (SelfKind::Value, &hir::TyPath(..)) |\n-            (SelfKind::Ref, &hir::TyRptr(_, hir::MutTy { mutbl: hir::Mutability::MutImmutable, .. })) |\n-            (SelfKind::RefMut, &hir::TyRptr(_, hir::MutTy { mutbl: hir::Mutability::MutMutable, .. })) => true,\n-            (SelfKind::Ref, &hir::TyPath(..)) |\n-            (SelfKind::RefMut, &hir::TyPath(..)) => allow_value_for_ref,\n-            _ => false,\n-        }\n-    }\n-\n     fn description(&self) -> &'static str {\n         match *self {\n             SelfKind::Value => \"self by value\","}, {"sha": "7ef2e89cdaae2f4690be08ecc455f27bf14bd896", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6dd65620e932eacb408b5b2825baf833e560719/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dd65620e932eacb408b5b2825baf833e560719/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d6dd65620e932eacb408b5b2825baf833e560719", "patch": "@@ -906,6 +906,17 @@ pub fn is_self(slf: &Arg) -> bool {\n     }\n }\n \n+pub fn is_self_ty(slf: &Ty) -> bool {\n+    if_let_chain! {[\n+        let TyPath(ref qp) = slf.node,\n+        let QPath::Resolved(None, ref path) = *qp,\n+        let Def::SelfTy(..) = path.def,\n+    ], {\n+        return true\n+    }}\n+    false\n+}\n+\n pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body) -> impl Iterator<Item=&'tcx Arg> {\n     (0..decl.inputs.len()).map(move |i| &body.arguments[i])\n }\n\\ No newline at end of file"}]}