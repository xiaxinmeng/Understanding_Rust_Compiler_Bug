{"sha": "dee7c5af6991b02c86e6a84b57551fd5cc71caaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZTdjNWFmNjk5MWIwMmM4NmU2YTg0YjU3NTUxZmQ1Y2M3MWNhYWY=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-06-03T03:19:37Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-06-03T03:19:37Z"}, "message": "Add traits for concat and connect methods", "tree": {"sha": "3aa30be1b0a9c189719f9210ac1f3f796786f05a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3aa30be1b0a9c189719f9210ac1f3f796786f05a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dee7c5af6991b02c86e6a84b57551fd5cc71caaf", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dee7c5af6991b02c86e6a84b57551fd5cc71caaf", "html_url": "https://github.com/rust-lang/rust/commit/dee7c5af6991b02c86e6a84b57551fd5cc71caaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dee7c5af6991b02c86e6a84b57551fd5cc71caaf/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c40baf68cb3306f1beaf1d5443bb2433043b7da7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c40baf68cb3306f1beaf1d5443bb2433043b7da7", "html_url": "https://github.com/rust-lang/rust/commit/c40baf68cb3306f1beaf1d5443bb2433043b7da7"}], "stats": {"total": 294, "additions": 204, "deletions": 90}, "files": [{"sha": "87430e3390a3cb21f6a295d6c49e8b2b9b305f48", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dee7c5af6991b02c86e6a84b57551fd5cc71caaf/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee7c5af6991b02c86e6a84b57551fd5cc71caaf/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=dee7c5af6991b02c86e6a84b57551fd5cc71caaf", "patch": "@@ -45,7 +45,7 @@ pub use path::PosixPath;\n pub use path::WindowsPath;\n pub use ptr::Ptr;\n pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr};\n-pub use str::{StrSlice, OwnedStr, StrUtil};\n+pub use str::{StrVector, StrSlice, OwnedStr, StrUtil};\n pub use from_str::{FromStr};\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};\n@@ -56,7 +56,7 @@ pub use tuple::{CloneableTuple10, CloneableTuple11, CloneableTuple12};\n pub use tuple::{ImmutableTuple2, ImmutableTuple3, ImmutableTuple4, ImmutableTuple5};\n pub use tuple::{ImmutableTuple6, ImmutableTuple7, ImmutableTuple8, ImmutableTuple9};\n pub use tuple::{ImmutableTuple10, ImmutableTuple11, ImmutableTuple12};\n-pub use vec::{CopyableVector, ImmutableVector};\n+pub use vec::{VectorVector, CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n pub use vec::{OwnedVector, OwnedCopyableVector, MutableVector};\n pub use io::{Reader, ReaderUtil, Writer, WriterUtil};"}, {"sha": "961d93823add935048adf5cc937182388981d7d6", "filename": "src/libstd/str.rs", "status": "modified", "additions": 141, "deletions": 71, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/dee7c5af6991b02c86e6a84b57551fd5cc71caaf/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee7c5af6991b02c86e6a84b57551fd5cc71caaf/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=dee7c5af6991b02c86e6a84b57551fd5cc71caaf", "patch": "@@ -241,110 +241,165 @@ pub fn append(lhs: ~str, rhs: &str) -> ~str {\n }\n \n /// Concatenate a vector of strings\n-pub fn concat(v: &[~str]) -> ~str {\n-    if v.is_empty() { return ~\"\"; }\n+pub fn concat(v: &[~str]) -> ~str { v.concat() }\n \n-    let mut len = 0;\n-    for v.each |ss| {\n-        len += ss.len();\n-    }\n-    let mut s = ~\"\";\n-\n-    reserve(&mut s, len);\n+/// Concatenate a vector of strings\n+pub fn concat_slices(v: &[&str]) -> ~str { v.concat() }\n \n-    unsafe {\n-        do as_buf(s) |buf, _len| {\n-            let mut buf = ::cast::transmute_mut_unsafe(buf);\n-            for v.each |ss| {\n-                do as_buf(*ss) |ssbuf, sslen| {\n-                    let sslen = sslen - 1;\n-                    ptr::copy_memory(buf, ssbuf, sslen);\n-                    buf = buf.offset(sslen);\n-                }\n-            }\n-        }\n-        raw::set_len(&mut s, len);\n-    }\n-    s\n-}\n+/// Concatenate a vector of strings, placing a given separator between each\n+pub fn connect(v: &[~str], sep: &str) -> ~str { v.connect(sep) }\n \n /// Concatenate a vector of strings, placing a given separator between each\n-pub fn connect(v: &[~str], sep: &str) -> ~str {\n-    if v.is_empty() { return ~\"\"; }\n+pub fn connect_slices(v: &[&str], sep: &str) -> ~str { v.connect(sep) }\n \n-    // concat is faster\n-    if sep.is_empty() { return concat(v); }\n+#[allow(missing_doc)]\n+pub trait StrVector {\n+    pub fn concat(&self) -> ~str;\n+    pub fn connect(&self, sep: &str) -> ~str;\n+}\n \n-    // this is wrong without the guarantee that v is non-empty\n-    let mut len = sep.len() * (v.len() - 1);\n-    for v.each |ss| {\n-        len += ss.len();\n-    }\n-    let mut s = ~\"\", first = true;\n+impl<'self> StrVector for &'self [~str] {\n+    /// Concatenate a vector of strings.\n+    pub fn concat(&self) -> ~str {\n+        if self.is_empty() { return ~\"\"; }\n+\n+        let mut len = 0;\n+        for self.each |ss| {\n+            len += ss.len();\n+        }\n+        let mut s = ~\"\";\n \n-    reserve(&mut s, len);\n+        reserve(&mut s, len);\n \n-    unsafe {\n-        do as_buf(s) |buf, _len| {\n-            do as_buf(sep) |sepbuf, seplen| {\n-                let seplen = seplen - 1;\n+        unsafe {\n+            do as_buf(s) |buf, _| {\n                 let mut buf = ::cast::transmute_mut_unsafe(buf);\n-                for v.each |ss| {\n+                for self.each |ss| {\n                     do as_buf(*ss) |ssbuf, sslen| {\n                         let sslen = sslen - 1;\n-                        if first {\n-                            first = false;\n-                        } else {\n-                            ptr::copy_memory(buf, sepbuf, seplen);\n-                            buf = buf.offset(seplen);\n-                        }\n                         ptr::copy_memory(buf, ssbuf, sslen);\n                         buf = buf.offset(sslen);\n                     }\n                 }\n             }\n+            raw::set_len(&mut s, len);\n         }\n-        raw::set_len(&mut s, len);\n+        s\n     }\n-    s\n-}\n \n-/// Concatenate a vector of strings, placing a given separator between each\n-pub fn connect_slices(v: &[&str], sep: &str) -> ~str {\n-    if v.is_empty() { return ~\"\"; }\n+    /// Concatenate a vector of strings, placing a given separator between each.\n+    pub fn connect(&self, sep: &str) -> ~str {\n+        if self.is_empty() { return ~\"\"; }\n+\n+        // concat is faster\n+        if sep.is_empty() { return self.concat(); }\n \n-    // this is wrong without the guarantee that v is non-empty\n-    let mut len = sep.len() * (v.len() - 1);\n-    for v.each |ss| {\n-        len += ss.len();\n+        // this is wrong without the guarantee that `self` is non-empty\n+        let mut len = sep.len() * (self.len() - 1);\n+        for self.each |ss| {\n+            len += ss.len();\n+        }\n+        let mut s = ~\"\";\n+        let mut first = true;\n+\n+        reserve(&mut s, len);\n+\n+        unsafe {\n+            do as_buf(s) |buf, _| {\n+                do as_buf(sep) |sepbuf, seplen| {\n+                    let seplen = seplen - 1;\n+                    let mut buf = ::cast::transmute_mut_unsafe(buf);\n+                    for self.each |ss| {\n+                        do as_buf(*ss) |ssbuf, sslen| {\n+                            let sslen = sslen - 1;\n+                            if first {\n+                                first = false;\n+                            } else {\n+                                ptr::copy_memory(buf, sepbuf, seplen);\n+                                buf = buf.offset(seplen);\n+                            }\n+                            ptr::copy_memory(buf, ssbuf, sslen);\n+                            buf = buf.offset(sslen);\n+                        }\n+                    }\n+                }\n+            }\n+            raw::set_len(&mut s, len);\n+        }\n+        s\n     }\n-    let mut s = ~\"\", first = true;\n+}\n \n-    reserve(&mut s, len);\n+impl<'self> StrVector for &'self [&'self str] {\n+    /// Concatenate a vector of strings.\n+    pub fn concat(&self) -> ~str {\n+        if self.is_empty() { return ~\"\"; }\n \n-    unsafe {\n-        do as_buf(s) |buf, _len| {\n-            do as_buf(sep) |sepbuf, seplen| {\n-                let seplen = seplen - 1;\n+        let mut len = 0;\n+        for self.each |ss| {\n+            len += ss.len();\n+        }\n+        let mut s = ~\"\";\n+\n+        reserve(&mut s, len);\n+\n+        unsafe {\n+            do as_buf(s) |buf, _| {\n                 let mut buf = ::cast::transmute_mut_unsafe(buf);\n-                for v.each |ss| {\n+                for self.each |ss| {\n                     do as_buf(*ss) |ssbuf, sslen| {\n                         let sslen = sslen - 1;\n-                        if first {\n-                            first = false;\n-                        } else if seplen > 0 {\n-                            ptr::copy_memory(buf, sepbuf, seplen);\n-                            buf = buf.offset(seplen);\n-                        }\n                         ptr::copy_memory(buf, ssbuf, sslen);\n                         buf = buf.offset(sslen);\n                     }\n                 }\n             }\n+            raw::set_len(&mut s, len);\n         }\n-        raw::set_len(&mut s, len);\n+        s\n+    }\n+\n+    /// Concatenate a vector of strings, placing a given separator between each.\n+    pub fn connect(&self, sep: &str) -> ~str {\n+        if self.is_empty() { return ~\"\"; }\n+\n+        // concat is faster\n+        if sep.is_empty() { return self.concat(); }\n+\n+        // this is wrong without the guarantee that `self` is non-empty\n+        let mut len = sep.len() * (self.len() - 1);\n+        for self.each |ss| {\n+            len += ss.len();\n+        }\n+        let mut s = ~\"\";\n+        let mut first = true;\n+\n+        reserve(&mut s, len);\n+\n+        unsafe {\n+            do as_buf(s) |buf, _| {\n+                do as_buf(sep) |sepbuf, seplen| {\n+                    let seplen = seplen - 1;\n+                    let mut buf = ::cast::transmute_mut_unsafe(buf);\n+                    for self.each |ss| {\n+                        do as_buf(*ss) |ssbuf, sslen| {\n+                            let sslen = sslen - 1;\n+                            if first {\n+                                first = false;\n+                            } else {\n+                                ptr::copy_memory(buf, sepbuf, seplen);\n+                                buf = buf.offset(seplen);\n+                            }\n+                            ptr::copy_memory(buf, ssbuf, sslen);\n+                            buf = buf.offset(sslen);\n+                        }\n+                    }\n+                }\n+            }\n+            raw::set_len(&mut s, len);\n+        }\n+        s\n     }\n-    s\n }\n \n /// Given a string, make a new string with repeated copies of it\n@@ -3184,6 +3239,7 @@ mod tests {\n     fn test_concat() {\n         fn t(v: &[~str], s: &str) {\n             assert_eq!(concat(v), s.to_str());\n+            assert_eq!(v.concat(), s.to_str());\n         }\n         t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], \"youknowI'mnogood\");\n         let v: &[~str] = [];\n@@ -3195,6 +3251,7 @@ mod tests {\n     fn test_connect() {\n         fn t(v: &[~str], sep: &str, s: &str) {\n             assert_eq!(connect(v, sep), s.to_str());\n+            assert_eq!(v.connect(sep), s.to_str());\n         }\n         t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"],\n           \" \", \"you know I'm no good\");\n@@ -3203,10 +3260,23 @@ mod tests {\n         t([~\"hi\"], \" \", \"hi\");\n     }\n \n+    #[test]\n+    fn test_concat_slices() {\n+        fn t(v: &[&str], s: &str) {\n+            assert_eq!(concat_slices(v), s.to_str());\n+            assert_eq!(v.concat(), s.to_str());\n+        }\n+        t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n+        let v: &[&str] = [];\n+        t(v, \"\");\n+        t([\"hi\"], \"hi\");\n+    }\n+\n     #[test]\n     fn test_connect_slices() {\n         fn t(v: &[&str], sep: &str, s: &str) {\n             assert_eq!(connect_slices(v, sep), s.to_str());\n+            assert_eq!(v.connect(sep), s.to_str());\n         }\n         t([\"you\", \"know\", \"I'm\", \"no\", \"good\"],\n           \" \", \"you know I'm no good\");"}, {"sha": "b748ca54cf425255a2afd16edc3b5a5638659a7c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 61, "deletions": 17, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/dee7c5af6991b02c86e6a84b57551fd5cc71caaf/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee7c5af6991b02c86e6a84b57551fd5cc71caaf/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=dee7c5af6991b02c86e6a84b57551fd5cc71caaf", "patch": "@@ -1011,26 +1011,58 @@ pub fn retain<T>(v: &mut ~[T], f: &fn(t: &T) -> bool) {\n     }\n }\n \n-/**\n- * Concatenate a vector of vectors.\n- *\n- * Flattens a vector of vectors of T into a single vector of T.\n- */\n-pub fn concat<T:Copy>(v: &[~[T]]) -> ~[T] {\n-    let mut r = ~[];\n-    for each(v) |inner| { r.push_all(*inner); }\n-    r\n-}\n+/// Flattens a vector of vectors of T into a single vector of T.\n+pub fn concat<T:Copy>(v: &[~[T]]) -> ~[T] { v.concat() }\n+\n+/// Concatenate a vector of vectors, placing a given separator between each\n+pub fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] { v.connect(sep) }\n+\n+/// Flattens a vector of vectors of T into a single vector of T.\n+pub fn concat_slices<T:Copy>(v: &[&[T]]) -> ~[T] { v.concat() }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n-pub fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n-    let mut r: ~[T] = ~[];\n-    let mut first = true;\n-    for each(v) |inner| {\n-        if first { first = false; } else { r.push(*sep); }\n-        r.push_all(*inner);\n+pub fn connect_slices<T:Copy>(v: &[&[T]], sep: &T) -> ~[T] { v.connect(sep) }\n+\n+#[allow(missing_doc)]\n+pub trait VectorVector<T> {\n+    pub fn concat(&self) -> ~[T];\n+    pub fn connect(&self, sep: &T) -> ~[T];\n+}\n+\n+impl<'self, T:Copy> VectorVector<T> for &'self [~[T]] {\n+    /// Flattens a vector of slices of T into a single vector of T.\n+    pub fn concat(&self) -> ~[T] {\n+        self.flat_map(|&inner| inner)\n+    }\n+\n+    /// Concatenate a vector of vectors, placing a given separator between each.\n+    pub fn connect(&self, sep: &T) -> ~[T] {\n+        let mut r = ~[];\n+        let mut first = true;\n+        for self.each |&inner| {\n+            if first { first = false; } else { r.push(*sep); }\n+            r.push_all(inner);\n+        }\n+        r\n+    }\n+}\n+\n+impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n+    /// Flattens a vector of slices of T into a single vector of T.\n+    pub fn concat(&self) -> ~[T] {\n+        self.flat_map(|&inner| inner.to_owned())\n+    }\n+\n+    /// Concatenate a vector of slices, placing a given separator between each.\n+    pub fn connect(&self, sep: &T) -> ~[T] {\n+        let mut r = ~[];\n+        let mut first = true;\n+        for self.each |&inner| {\n+            if first { first = false; } else { r.push(*sep); }\n+            r.push_all(inner);\n+        }\n+        r\n     }\n-    r\n }\n \n /**\n@@ -3941,13 +3973,25 @@ mod tests {\n     #[test]\n     fn test_concat() {\n         assert_eq!(concat([~[1], ~[2,3]]), ~[1, 2, 3]);\n+        assert_eq!([~[1], ~[2,3]].concat(), ~[1, 2, 3]);\n+\n+        assert_eq!(concat_slices([&[1], &[2,3]]), ~[1, 2, 3]);\n+        assert_eq!([&[1], &[2,3]].concat(), ~[1, 2, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n         assert_eq!(connect([], &0), ~[]);\n         assert_eq!(connect([~[1], ~[2, 3]], &0), ~[1, 0, 2, 3]);\n         assert_eq!(connect([~[1], ~[2], ~[3]], &0), ~[1, 0, 2, 0, 3]);\n+        assert_eq!([~[1], ~[2, 3]].connect(&0), ~[1, 0, 2, 3]);\n+        assert_eq!([~[1], ~[2], ~[3]].connect(&0), ~[1, 0, 2, 0, 3]);\n+\n+        assert_eq!(connect_slices([], &0), ~[]);\n+        assert_eq!(connect_slices([&[1], &[2, 3]], &0), ~[1, 0, 2, 3]);\n+        assert_eq!(connect_slices([&[1], &[2], &[3]], &0), ~[1, 0, 2, 0, 3]);\n+        assert_eq!([&[1], &[2, 3]].connect(&0), ~[1, 0, 2, 3]);\n+        assert_eq!([&[1], &[2], &[3]].connect(&0), ~[1, 0, 2, 0, 3]);\n     }\n \n     #[test]"}]}