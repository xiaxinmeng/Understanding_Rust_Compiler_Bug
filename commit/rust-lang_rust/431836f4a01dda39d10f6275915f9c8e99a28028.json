{"sha": "431836f4a01dda39d10f6275915f9c8e99a28028", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMTgzNmY0YTAxZGRhMzlkMTBmNjI3NTkxNWY5YzhlOTlhMjgwMjg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-06T20:59:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-06T20:59:51Z"}, "message": "Merge #2489\n\n2489: Implement `format_args` r=flodiebold a=flodiebold\n\nThis fixes a huge amount of type mismatches (because every format call was a type mismatch so far); I also hoped to get go to def working within `format!` etc., and the test says it should, but in practice it still doesn't seem to...\r\n\r\nAlso remove the `len` parameter from `Name::new_inline_ascii`, which I'm assuming was only there because of `const fn` limitations?\r\n\r\ncc @edwin0cheng \n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "0cb8ceaa2e07b30da2f841d792e505df6b460d41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cb8ceaa2e07b30da2f841d792e505df6b460d41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/431836f4a01dda39d10f6275915f9c8e99a28028", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd6sFHCRBK7hj4Ov3rIwAAdHIIACRaiUJ8sY/djTK4QYWr6d67\nGKdz6LkPwZGOhrufZ8ftnjFmZ0MGNqQQGZQe97OfHkYvvs7lf1UVXSAG9U5l+3vJ\nVmCDjnu30jAdrvg6jEnBx/FzV5Xr3GNtE9y5IYc16W9ZolwkLP8tJLy1aTJ/6joz\nXVnwswWx4EaRtEn8zO6wREohKMGJCffy5gxy0CzDVl4iTIrs16T9wPn9zcNvwuAx\n+BB9qCKvl8SffmVRvyh7w/4hrNYB2c3I+lLp4feb1bWWmED9aE8+s0qk0YXojBW1\nD+PCdLMnI8Id2gVPbLUWINCc24+MTBnyS3f1i8dWBob9c5x6hW+G0IbFFXQiRe4=\n=8axg\n-----END PGP SIGNATURE-----\n", "payload": "tree 0cb8ceaa2e07b30da2f841d792e505df6b460d41\nparent f18b7e18c479144325ec150be00837aae3329ae2\nparent b2c01f446edcbc12b5dd870064cbfc6c1a47eb8b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575665991 +0000\ncommitter GitHub <noreply@github.com> 1575665991 +0000\n\nMerge #2489\n\n2489: Implement `format_args` r=flodiebold a=flodiebold\n\nThis fixes a huge amount of type mismatches (because every format call was a type mismatch so far); I also hoped to get go to def working within `format!` etc., and the test says it should, but in practice it still doesn't seem to...\r\n\r\nAlso remove the `len` parameter from `Name::new_inline_ascii`, which I'm assuming was only there because of `const fn` limitations?\r\n\r\ncc @edwin0cheng \n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/431836f4a01dda39d10f6275915f9c8e99a28028", "html_url": "https://github.com/rust-lang/rust/commit/431836f4a01dda39d10f6275915f9c8e99a28028", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/431836f4a01dda39d10f6275915f9c8e99a28028/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f18b7e18c479144325ec150be00837aae3329ae2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f18b7e18c479144325ec150be00837aae3329ae2", "html_url": "https://github.com/rust-lang/rust/commit/f18b7e18c479144325ec150be00837aae3329ae2"}, {"sha": "b2c01f446edcbc12b5dd870064cbfc6c1a47eb8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c01f446edcbc12b5dd870064cbfc6c1a47eb8b", "html_url": "https://github.com/rust-lang/rust/commit/b2c01f446edcbc12b5dd870064cbfc6c1a47eb8b"}], "stats": {"total": 259, "additions": 194, "deletions": 65}, "files": [{"sha": "0e136b90498a7bce38ef110560fc865757fcfa22", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/431836f4a01dda39d10f6275915f9c8e99a28028/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/431836f4a01dda39d10f6275915f9c8e99a28028/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=431836f4a01dda39d10f6275915f9c8e99a28028", "patch": "@@ -76,12 +76,13 @@ fn def_with_body_from_child_node(\n     db: &impl HirDatabase,\n     child: InFile<&SyntaxNode>,\n ) -> Option<DefWithBody> {\n-    child.value.ancestors().find_map(|node| {\n+    child.cloned().ancestors_with_macros(db).find_map(|node| {\n+        let n = &node.value;\n         match_ast! {\n-            match node {\n-                ast::FnDef(def)  => { return Function::from_source(db, child.with_value(def)).map(DefWithBody::from); },\n-                ast::ConstDef(def) => { return Const::from_source(db, child.with_value(def)).map(DefWithBody::from); },\n-                ast::StaticDef(def) => { return Static::from_source(db, child.with_value(def)).map(DefWithBody::from); },\n+            match n {\n+                ast::FnDef(def)  => { return Function::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n+                ast::ConstDef(def) => { return Const::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n+                ast::StaticDef(def) => { return Static::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n                 _ => { None },\n             }\n         }\n@@ -135,6 +136,7 @@ pub struct ReferenceDescriptor {\n     pub name: String,\n }\n \n+#[derive(Debug)]\n pub struct Expansion {\n     macro_file_kind: MacroFileKind,\n     macro_call_id: MacroCallId,"}, {"sha": "99303188bf23a5f8efe873082fd77e85bd8df09f", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/431836f4a01dda39d10f6275915f9c8e99a28028/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/431836f4a01dda39d10f6275915f9c8e99a28028/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=431836f4a01dda39d10f6275915f9c8e99a28028", "patch": "@@ -49,7 +49,11 @@ register_builtin! {\n     (COMPILE_ERROR_MACRO, CompileError) => compile_error_expand,\n     (FILE_MACRO, File) => file_expand,\n     (LINE_MACRO, Line) => line_expand,\n-    (STRINGIFY_MACRO, Stringify) => stringify_expand\n+    (STRINGIFY_MACRO, Stringify) => stringify_expand,\n+    (FORMAT_ARGS_MACRO, FormatArgs) => format_args_expand,\n+    // format_args_nl only differs in that it adds a newline in the end,\n+    // so we use the same stub expansion for now\n+    (FORMAT_ARGS_NL_MACRO, FormatArgsNl) => format_args_expand\n }\n \n fn to_line_number(db: &dyn AstDatabase, file: HirFileId, pos: TextUnit) -> usize {\n@@ -200,6 +204,41 @@ fn compile_error_expand(\n     Err(mbe::ExpandError::BindingError(\"Must be a string\".into()))\n }\n \n+fn format_args_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    // We expand `format_args!(\"\", arg1, arg2)` to\n+    // `std::fmt::Arguments::new_v1(&[], &[&arg1, &arg2])`,\n+    // which is still not really correct, but close enough for now\n+    let mut args = Vec::new();\n+    let mut current = Vec::new();\n+    for tt in tt.token_trees.iter().cloned() {\n+        match tt {\n+            tt::TokenTree::Leaf(tt::Leaf::Punct(p)) if p.char == ',' => {\n+                args.push(tt::Subtree { delimiter: tt::Delimiter::None, token_trees: current });\n+                current = Vec::new();\n+            }\n+            _ => {\n+                current.push(tt);\n+            }\n+        }\n+    }\n+    if !current.is_empty() {\n+        args.push(tt::Subtree { delimiter: tt::Delimiter::None, token_trees: current });\n+    }\n+    if args.is_empty() {\n+        return Err(mbe::ExpandError::NoMatchingRule);\n+    }\n+    let _format_string = args.remove(0);\n+    let arg_tts = args.into_iter().flat_map(|arg| (quote! { & #arg , }).token_trees);\n+    let expanded = quote! {\n+        std::fmt::Arguments::new_v1(&[], &[##arg_tts])\n+    };\n+    Ok(expanded)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -307,4 +346,21 @@ mod tests {\n \n         assert_eq!(expanded, r#\"loop{\"error!\"}\"#);\n     }\n+\n+    #[test]\n+    fn test_format_args_expand() {\n+        let expanded = expand_builtin_macro(\n+            r#\"\n+        #[rustc_builtin_macro]\n+        macro_rules! format_args {\n+            ($fmt:expr) => ({ /* compiler built-in */ });\n+            ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+        }\n+        format_args!(\"{} {:?}\", arg1(a, b, c), arg2);\n+\"#,\n+            BuiltinFnLikeExpander::FormatArgs,\n+        );\n+\n+        assert_eq!(expanded, r#\"std::fmt::Arguments::new_v1(&[] ,&[&arg1(a,b,c),&arg2,])\"#);\n+    }\n }"}, {"sha": "013a6c8ba958f434baa4bbb3bfb3729fd9a5f6cf", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/431836f4a01dda39d10f6275915f9c8e99a28028/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/431836f4a01dda39d10f6275915f9c8e99a28028/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=431836f4a01dda39d10f6275915f9c8e99a28028", "patch": "@@ -45,8 +45,8 @@ impl TokenExpander {\n     pub fn map_id_up(&self, id: tt::TokenId) -> (tt::TokenId, mbe::Origin) {\n         match self {\n             TokenExpander::MacroRules(it) => it.map_id_up(id),\n-            TokenExpander::Builtin(..) => (id, mbe::Origin::Def),\n-            TokenExpander::BuiltinDerive(..) => (id, mbe::Origin::Def),\n+            TokenExpander::Builtin(..) => (id, mbe::Origin::Call),\n+            TokenExpander::BuiltinDerive(..) => (id, mbe::Origin::Call),\n         }\n     }\n }"}, {"sha": "0a5da7e54795c132479640dcf8a4befc5f1ed5bf", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/431836f4a01dda39d10f6275915f9c8e99a28028/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/431836f4a01dda39d10f6275915f9c8e99a28028/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=431836f4a01dda39d10f6275915f9c8e99a28028", "patch": "@@ -76,6 +76,17 @@ impl HirFileId {\n         }\n     }\n \n+    /// If this is a macro call, returns the syntax node of the call.\n+    pub fn call_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n+        match self.0 {\n+            HirFileIdRepr::FileId(_) => None,\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                Some(loc.kind.node(db))\n+            }\n+        }\n+    }\n+\n     /// Return expansion information if it is a macro-expansion file\n     pub fn expansion_info(self, db: &dyn db::AstDatabase) -> Option<ExpansionInfo> {\n         match self.0 {\n@@ -176,6 +187,13 @@ impl MacroCallKind {\n         }\n     }\n \n+    pub fn node(&self, db: &dyn db::AstDatabase) -> InFile<SyntaxNode> {\n+        match self {\n+            MacroCallKind::FnLike(ast_id) => ast_id.with_value(ast_id.to_node(db).syntax().clone()),\n+            MacroCallKind::Attr(ast_id) => ast_id.with_value(ast_id.to_node(db).syntax().clone()),\n+        }\n+    }\n+\n     pub fn arg(&self, db: &dyn db::AstDatabase) -> Option<SyntaxNode> {\n         match self {\n             MacroCallKind::FnLike(ast_id) => {\n@@ -283,3 +301,24 @@ impl<T> InFile<T> {\n         db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n     }\n }\n+\n+impl<T: Clone> InFile<&T> {\n+    pub fn cloned(&self) -> InFile<T> {\n+        self.with_value(self.value.clone())\n+    }\n+}\n+\n+impl InFile<SyntaxNode> {\n+    pub fn ancestors_with_macros<'a>(\n+        self,\n+        db: &'a impl crate::db::AstDatabase,\n+    ) -> impl Iterator<Item = InFile<SyntaxNode>> + 'a {\n+        std::iter::successors(Some(self), move |node| match node.value.parent() {\n+            Some(parent) => Some(node.with_value(parent)),\n+            None => {\n+                let parent_node = node.file_id.call_node(db)?;\n+                Some(parent_node)\n+            }\n+        })\n+    }\n+}"}, {"sha": "4f2f702c01f39626b33d4cc1342eafe764023319", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/431836f4a01dda39d10f6275915f9c8e99a28028/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/431836f4a01dda39d10f6275915f9c8e99a28028/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=431836f4a01dda39d10f6275915f9c8e99a28028", "patch": "@@ -38,8 +38,8 @@ impl Name {\n     }\n \n     /// Shortcut to create inline plain text name\n-    const fn new_inline_ascii(len: usize, text: &[u8]) -> Name {\n-        Name::new_text(SmolStr::new_inline_from_ascii(len, text))\n+    const fn new_inline_ascii(text: &[u8]) -> Name {\n+        Name::new_text(SmolStr::new_inline_from_ascii(text.len(), text))\n     }\n \n     /// Resolve a name from the text of token.\n@@ -105,68 +105,70 @@ impl AsName for ra_db::Dependency {\n }\n \n // Primitives\n-pub const ISIZE: Name = Name::new_inline_ascii(5, b\"isize\");\n-pub const I8: Name = Name::new_inline_ascii(2, b\"i8\");\n-pub const I16: Name = Name::new_inline_ascii(3, b\"i16\");\n-pub const I32: Name = Name::new_inline_ascii(3, b\"i32\");\n-pub const I64: Name = Name::new_inline_ascii(3, b\"i64\");\n-pub const I128: Name = Name::new_inline_ascii(4, b\"i128\");\n-pub const USIZE: Name = Name::new_inline_ascii(5, b\"usize\");\n-pub const U8: Name = Name::new_inline_ascii(2, b\"u8\");\n-pub const U16: Name = Name::new_inline_ascii(3, b\"u16\");\n-pub const U32: Name = Name::new_inline_ascii(3, b\"u32\");\n-pub const U64: Name = Name::new_inline_ascii(3, b\"u64\");\n-pub const U128: Name = Name::new_inline_ascii(4, b\"u128\");\n-pub const F32: Name = Name::new_inline_ascii(3, b\"f32\");\n-pub const F64: Name = Name::new_inline_ascii(3, b\"f64\");\n-pub const BOOL: Name = Name::new_inline_ascii(4, b\"bool\");\n-pub const CHAR: Name = Name::new_inline_ascii(4, b\"char\");\n-pub const STR: Name = Name::new_inline_ascii(3, b\"str\");\n+pub const ISIZE: Name = Name::new_inline_ascii(b\"isize\");\n+pub const I8: Name = Name::new_inline_ascii(b\"i8\");\n+pub const I16: Name = Name::new_inline_ascii(b\"i16\");\n+pub const I32: Name = Name::new_inline_ascii(b\"i32\");\n+pub const I64: Name = Name::new_inline_ascii(b\"i64\");\n+pub const I128: Name = Name::new_inline_ascii(b\"i128\");\n+pub const USIZE: Name = Name::new_inline_ascii(b\"usize\");\n+pub const U8: Name = Name::new_inline_ascii(b\"u8\");\n+pub const U16: Name = Name::new_inline_ascii(b\"u16\");\n+pub const U32: Name = Name::new_inline_ascii(b\"u32\");\n+pub const U64: Name = Name::new_inline_ascii(b\"u64\");\n+pub const U128: Name = Name::new_inline_ascii(b\"u128\");\n+pub const F32: Name = Name::new_inline_ascii(b\"f32\");\n+pub const F64: Name = Name::new_inline_ascii(b\"f64\");\n+pub const BOOL: Name = Name::new_inline_ascii(b\"bool\");\n+pub const CHAR: Name = Name::new_inline_ascii(b\"char\");\n+pub const STR: Name = Name::new_inline_ascii(b\"str\");\n \n // Special names\n-pub const SELF_PARAM: Name = Name::new_inline_ascii(4, b\"self\");\n-pub const SELF_TYPE: Name = Name::new_inline_ascii(4, b\"Self\");\n-pub const MACRO_RULES: Name = Name::new_inline_ascii(11, b\"macro_rules\");\n+pub const SELF_PARAM: Name = Name::new_inline_ascii(b\"self\");\n+pub const SELF_TYPE: Name = Name::new_inline_ascii(b\"Self\");\n+pub const MACRO_RULES: Name = Name::new_inline_ascii(b\"macro_rules\");\n \n // Components of known path (value or mod name)\n-pub const STD: Name = Name::new_inline_ascii(3, b\"std\");\n-pub const ITER: Name = Name::new_inline_ascii(4, b\"iter\");\n-pub const OPS: Name = Name::new_inline_ascii(3, b\"ops\");\n-pub const FUTURE: Name = Name::new_inline_ascii(6, b\"future\");\n-pub const RESULT: Name = Name::new_inline_ascii(6, b\"result\");\n-pub const BOXED: Name = Name::new_inline_ascii(5, b\"boxed\");\n+pub const STD: Name = Name::new_inline_ascii(b\"std\");\n+pub const ITER: Name = Name::new_inline_ascii(b\"iter\");\n+pub const OPS: Name = Name::new_inline_ascii(b\"ops\");\n+pub const FUTURE: Name = Name::new_inline_ascii(b\"future\");\n+pub const RESULT: Name = Name::new_inline_ascii(b\"result\");\n+pub const BOXED: Name = Name::new_inline_ascii(b\"boxed\");\n \n // Components of known path (type name)\n-pub const INTO_ITERATOR_TYPE: Name = Name::new_inline_ascii(12, b\"IntoIterator\");\n-pub const ITEM_TYPE: Name = Name::new_inline_ascii(4, b\"Item\");\n-pub const TRY_TYPE: Name = Name::new_inline_ascii(3, b\"Try\");\n-pub const OK_TYPE: Name = Name::new_inline_ascii(2, b\"Ok\");\n-pub const FUTURE_TYPE: Name = Name::new_inline_ascii(6, b\"Future\");\n-pub const RESULT_TYPE: Name = Name::new_inline_ascii(6, b\"Result\");\n-pub const OUTPUT_TYPE: Name = Name::new_inline_ascii(6, b\"Output\");\n-pub const TARGET_TYPE: Name = Name::new_inline_ascii(6, b\"Target\");\n-pub const BOX_TYPE: Name = Name::new_inline_ascii(3, b\"Box\");\n-pub const RANGE_FROM_TYPE: Name = Name::new_inline_ascii(9, b\"RangeFrom\");\n-pub const RANGE_FULL_TYPE: Name = Name::new_inline_ascii(9, b\"RangeFull\");\n-pub const RANGE_INCLUSIVE_TYPE: Name = Name::new_inline_ascii(14, b\"RangeInclusive\");\n-pub const RANGE_TO_INCLUSIVE_TYPE: Name = Name::new_inline_ascii(16, b\"RangeToInclusive\");\n-pub const RANGE_TO_TYPE: Name = Name::new_inline_ascii(7, b\"RangeTo\");\n-pub const RANGE_TYPE: Name = Name::new_inline_ascii(5, b\"Range\");\n+pub const INTO_ITERATOR_TYPE: Name = Name::new_inline_ascii(b\"IntoIterator\");\n+pub const ITEM_TYPE: Name = Name::new_inline_ascii(b\"Item\");\n+pub const TRY_TYPE: Name = Name::new_inline_ascii(b\"Try\");\n+pub const OK_TYPE: Name = Name::new_inline_ascii(b\"Ok\");\n+pub const FUTURE_TYPE: Name = Name::new_inline_ascii(b\"Future\");\n+pub const RESULT_TYPE: Name = Name::new_inline_ascii(b\"Result\");\n+pub const OUTPUT_TYPE: Name = Name::new_inline_ascii(b\"Output\");\n+pub const TARGET_TYPE: Name = Name::new_inline_ascii(b\"Target\");\n+pub const BOX_TYPE: Name = Name::new_inline_ascii(b\"Box\");\n+pub const RANGE_FROM_TYPE: Name = Name::new_inline_ascii(b\"RangeFrom\");\n+pub const RANGE_FULL_TYPE: Name = Name::new_inline_ascii(b\"RangeFull\");\n+pub const RANGE_INCLUSIVE_TYPE: Name = Name::new_inline_ascii(b\"RangeInclusive\");\n+pub const RANGE_TO_INCLUSIVE_TYPE: Name = Name::new_inline_ascii(b\"RangeToInclusive\");\n+pub const RANGE_TO_TYPE: Name = Name::new_inline_ascii(b\"RangeTo\");\n+pub const RANGE_TYPE: Name = Name::new_inline_ascii(b\"Range\");\n \n // Builtin Macros\n-pub const FILE_MACRO: Name = Name::new_inline_ascii(4, b\"file\");\n-pub const COLUMN_MACRO: Name = Name::new_inline_ascii(6, b\"column\");\n-pub const COMPILE_ERROR_MACRO: Name = Name::new_inline_ascii(13, b\"compile_error\");\n-pub const LINE_MACRO: Name = Name::new_inline_ascii(4, b\"line\");\n-pub const STRINGIFY_MACRO: Name = Name::new_inline_ascii(9, b\"stringify\");\n+pub const FILE_MACRO: Name = Name::new_inline_ascii(b\"file\");\n+pub const COLUMN_MACRO: Name = Name::new_inline_ascii(b\"column\");\n+pub const COMPILE_ERROR_MACRO: Name = Name::new_inline_ascii(b\"compile_error\");\n+pub const LINE_MACRO: Name = Name::new_inline_ascii(b\"line\");\n+pub const STRINGIFY_MACRO: Name = Name::new_inline_ascii(b\"stringify\");\n+pub const FORMAT_ARGS_MACRO: Name = Name::new_inline_ascii(b\"format_args\");\n+pub const FORMAT_ARGS_NL_MACRO: Name = Name::new_inline_ascii(b\"format_args_nl\");\n \n // Builtin derives\n-pub const COPY_TRAIT: Name = Name::new_inline_ascii(4, b\"Copy\");\n-pub const CLONE_TRAIT: Name = Name::new_inline_ascii(5, b\"Clone\");\n-pub const DEFAULT_TRAIT: Name = Name::new_inline_ascii(7, b\"Default\");\n-pub const DEBUG_TRAIT: Name = Name::new_inline_ascii(5, b\"Debug\");\n-pub const HASH_TRAIT: Name = Name::new_inline_ascii(4, b\"Hash\");\n-pub const ORD_TRAIT: Name = Name::new_inline_ascii(3, b\"Ord\");\n-pub const PARTIAL_ORD_TRAIT: Name = Name::new_inline_ascii(10, b\"PartialOrd\");\n-pub const EQ_TRAIT: Name = Name::new_inline_ascii(2, b\"Eq\");\n-pub const PARTIAL_EQ_TRAIT: Name = Name::new_inline_ascii(9, b\"PartialEq\");\n+pub const COPY_TRAIT: Name = Name::new_inline_ascii(b\"Copy\");\n+pub const CLONE_TRAIT: Name = Name::new_inline_ascii(b\"Clone\");\n+pub const DEFAULT_TRAIT: Name = Name::new_inline_ascii(b\"Default\");\n+pub const DEBUG_TRAIT: Name = Name::new_inline_ascii(b\"Debug\");\n+pub const HASH_TRAIT: Name = Name::new_inline_ascii(b\"Hash\");\n+pub const ORD_TRAIT: Name = Name::new_inline_ascii(b\"Ord\");\n+pub const PARTIAL_ORD_TRAIT: Name = Name::new_inline_ascii(b\"PartialOrd\");\n+pub const EQ_TRAIT: Name = Name::new_inline_ascii(b\"Eq\");\n+pub const PARTIAL_EQ_TRAIT: Name = Name::new_inline_ascii(b\"PartialEq\");"}, {"sha": "d3c1988132e5bcab7931955c90c96ab9cad3e45e", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/431836f4a01dda39d10f6275915f9c8e99a28028/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/431836f4a01dda39d10f6275915f9c8e99a28028/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=431836f4a01dda39d10f6275915f9c8e99a28028", "patch": "@@ -689,8 +689,38 @@ mod tests {\n                     fo<|>o();\n                 }\n             }\n+            mod confuse_index { fn foo(); }\n             \",\n             \"foo FN_DEF FileId(1) [52; 63) [55; 58)\",\n         );\n     }\n+\n+    #[should_panic] // currently failing because of expr mapping problems\n+    #[test]\n+    fn goto_through_format() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            #[macro_export]\n+            macro_rules! format {\n+                ($($arg:tt)*) => ($crate::fmt::format($crate::__export::format_args!($($arg)*)))\n+            }\n+            #[rustc_builtin_macro]\n+            #[macro_export]\n+            macro_rules! format_args {\n+                ($fmt:expr) => ({ /* compiler built-in */ });\n+                ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+            }\n+            pub mod __export {\n+                pub use crate::format_args;\n+                fn foo() {} // for index confusion\n+            }\n+            fn foo() -> i8 {}\n+            fn test() {\n+                format!(\\\"{}\\\", fo<|>o())\n+            }\n+            \",\n+            \"foo FN_DEF FileId(1) [359; 376) [362; 365)\",\n+        );\n+    }\n }"}]}