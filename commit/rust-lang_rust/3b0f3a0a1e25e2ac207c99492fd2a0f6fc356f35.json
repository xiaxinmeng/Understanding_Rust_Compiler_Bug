{"sha": "3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMGYzYTBhMWUyNWUyYWMyMDdjOTk0OTJmZDJhMGY2ZmMzNTZmMzU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-08-30T11:02:53Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-08-30T11:15:53Z"}, "message": "Optimize SwitchInt for bools", "tree": {"sha": "1c59f3a2519db5debf3bed878c955aa018d57a58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c59f3a2519db5debf3bed878c955aa018d57a58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35", "html_url": "https://github.com/rust-lang/rust/commit/3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8e3f592c9ccbc49bf95c33dec8c2d4852a3faee", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e3f592c9ccbc49bf95c33dec8c2d4852a3faee", "html_url": "https://github.com/rust-lang/rust/commit/a8e3f592c9ccbc49bf95c33dec8c2d4852a3faee"}], "stats": {"total": 126, "additions": 119, "deletions": 7}, "files": [{"sha": "01f7ecd86f49fb9c89bdaa86f8f56f50b3641961", "filename": "src/base.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35", "patch": "@@ -110,6 +110,7 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n     context.compute_cfg();\n     context.compute_domtree();\n     context.eliminate_unreachable_code(cx.module.isa()).unwrap();\n+    context.dce(cx.module.isa()).unwrap();\n \n     // Define function\n     let module = &mut cx.module;\n@@ -315,18 +316,45 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n \n             TerminatorKind::SwitchInt {\n                 discr,\n-                switch_ty: _,\n+                switch_ty,\n                 values,\n                 targets,\n             } => {\n                 let discr = trans_operand(fx, discr).load_scalar(fx);\n-                let mut switch = ::cranelift_frontend::Switch::new();\n-                for (i, value) in values.iter().enumerate() {\n-                    let block = fx.get_block(targets[i]);\n-                    switch.set_entry(*value, block);\n+\n+                if switch_ty.kind == fx.tcx.types.bool.kind {\n+                    assert_eq!(targets.len(), 2);\n+                    let then_block = fx.get_block(targets[0]);\n+                    let else_block = fx.get_block(targets[1]);\n+                    let test_zero = match **values {\n+                        [0] => true,\n+                        [1] => false,\n+                        _ => unreachable!(\"{:?}\", values),\n+                    };\n+\n+                    let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n+                    let (discr, is_inverted) =\n+                        crate::optimize::peephole::maybe_unwrap_bool_not(&mut fx.bcx, discr);\n+                    let test_zero = if is_inverted { !test_zero } else { test_zero };\n+                    let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n+                    let discr =\n+                        crate::optimize::peephole::make_branchable_value(&mut fx.bcx, discr);\n+                    if test_zero {\n+                        fx.bcx.ins().brz(discr, then_block, &[]);\n+                        fx.bcx.ins().jump(else_block, &[]);\n+                    } else {\n+                        fx.bcx.ins().brnz(discr, then_block, &[]);\n+                        fx.bcx.ins().jump(else_block, &[]);\n+                    }\n+                } else {\n+                    let mut switch = ::cranelift_frontend::Switch::new();\n+                    for (i, value) in values.iter().enumerate() {\n+                        let block = fx.get_block(targets[i]);\n+                        switch.set_entry(*value, block);\n+                    }\n+                    let otherwise_block = fx.get_block(targets[targets.len() - 1]);\n+                    switch.emit(&mut fx.bcx, discr, otherwise_block);\n                 }\n-                let otherwise_block = fx.get_block(targets[targets.len() - 1]);\n-                switch.emit(&mut fx.bcx, discr, otherwise_block);\n             }\n             TerminatorKind::Call {\n                 func,"}, {"sha": "ae9692790896cf619b86029ebb4afdd0bf44b5ac", "filename": "src/optimize/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35/src%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35/src%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fmod.rs?ref=3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35", "patch": "@@ -1,6 +1,7 @@\n use crate::prelude::*;\n \n mod code_layout;\n+pub(crate) mod peephole;\n mod stack2reg;\n \n pub(crate) fn optimize_function<'tcx>("}, {"sha": "f8e0f3af3d0ad08587559bebef6972e540ea684f", "filename": "src/optimize/peephole.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35/src%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35/src%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fpeephole.rs?ref=3b0f3a0a1e25e2ac207c99492fd2a0f6fc356f35", "patch": "@@ -0,0 +1,83 @@\n+//! Peephole optimizations that can be performed while creating clif ir.\n+\n+use cranelift_codegen::ir::{\n+    condcodes::IntCC, types, InstBuilder, InstructionData, Opcode, Value, ValueDef,\n+};\n+use cranelift_frontend::FunctionBuilder;\n+\n+/// If the given value was produced by a `bint` instruction, return it's input, otherwise return the\n+/// given value.\n+pub(crate) fn maybe_unwrap_bint(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n+    if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n+        match bcx.func.dfg[arg_inst] {\n+            InstructionData::Unary {\n+                opcode: Opcode::Bint,\n+                arg,\n+            } => arg,\n+            _ => arg,\n+        }\n+    } else {\n+        arg\n+    }\n+}\n+\n+/// If the given value was produced by the lowering of `Rvalue::Not` return the input and true,\n+/// otherwise return the given value and false.\n+pub(crate) fn maybe_unwrap_bool_not(bcx: &mut FunctionBuilder<'_>, arg: Value) -> (Value, bool) {\n+    if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n+        match bcx.func.dfg[arg_inst] {\n+            // This is the lowering of `Rvalue::Not`\n+            InstructionData::IntCompareImm {\n+                opcode: Opcode::IcmpImm,\n+                cond: IntCC::Equal,\n+                arg,\n+                imm,\n+            } if imm.bits() == 0 => (arg, true),\n+            _ => (arg, false),\n+        }\n+    } else {\n+        (arg, false)\n+    }\n+}\n+\n+pub(crate) fn make_branchable_value(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n+    if bcx.func.dfg.value_type(arg).is_bool() {\n+        return arg;\n+    }\n+\n+    (|| {\n+        let arg_inst = if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n+            arg_inst\n+        } else {\n+            return None;\n+        };\n+\n+        match bcx.func.dfg[arg_inst] {\n+            // This is the lowering of Rvalue::Not\n+            InstructionData::Load {\n+                opcode: Opcode::Load,\n+                arg: ptr,\n+                flags,\n+                offset,\n+            } => {\n+                // Using `load.i8 + uextend.i32` would legalize to `uload8 + ireduce.i8 +\n+                // uextend.i32`. Just `uload8` is much faster.\n+                match bcx.func.dfg.ctrl_typevar(arg_inst) {\n+                    types::I8 => Some(bcx.ins().uload8(types::I32, flags, ptr, offset)),\n+                    types::I16 => Some(bcx.ins().uload16(types::I32, flags, ptr, offset)),\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        }\n+    })()\n+    .unwrap_or_else(|| {\n+        match bcx.func.dfg.value_type(arg) {\n+            types::I8 | types::I32 => {\n+                // WORKAROUND for brz.i8 and brnz.i8 not yet being implemented\n+                bcx.ins().uextend(types::I32, arg)\n+            }\n+            _ => arg,\n+        }\n+    })\n+}"}]}