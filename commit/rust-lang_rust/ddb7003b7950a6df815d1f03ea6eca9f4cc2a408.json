{"sha": "ddb7003b7950a6df815d1f03ea6eca9f4cc2a408", "node_id": "C_kwDOAAsO6NoAKGRkYjcwMDNiNzk1MGE2ZGY4MTVkMWYwM2VhNmVjYTlmNGNjMmE0MDg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-10T21:59:31Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-14T23:29:03Z"}, "message": "Add support for APIT and RPIT callables in label_fn_like", "tree": {"sha": "07e74addfb8f65b008d8223c7c45f66422b5fd3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07e74addfb8f65b008d8223c7c45f66422b5fd3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408", "html_url": "https://github.com/rust-lang/rust/commit/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2f428d2f3340a0e7d995f4726223db91b93704c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2f428d2f3340a0e7d995f4726223db91b93704c", "html_url": "https://github.com/rust-lang/rust/commit/c2f428d2f3340a0e7d995f4726223db91b93704c"}], "stats": {"total": 255, "additions": 195, "deletions": 60}, "files": [{"sha": "3dd63d74c3fd76c1b245440944d99a8615b3d509", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 98, "deletions": 40, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=ddb7003b7950a6df815d1f03ea6eca9f4cc2a408", "patch": "@@ -25,7 +25,7 @@ use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, IsSuggestable, Ty, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 args_no_rcvr,\n                 false,\n                 tuple_arguments,\n-                None,\n+                method.ok().map(|method| method.def_id),\n             );\n             return self.tcx.ty_error();\n         }\n@@ -458,6 +458,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 c_variadic,\n                 err_code,\n                 fn_def_id,\n+                call_expr,\n             );\n         }\n     }\n@@ -474,6 +475,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         c_variadic: bool,\n         err_code: &str,\n         fn_def_id: Option<DefId>,\n+        call_expr: &hir::Expr<'tcx>,\n     ) {\n         // Don't print if it has error types or is just plain `_`\n         fn has_error_or_infer<'tcx>(tys: impl IntoIterator<Item = Ty<'tcx>>) -> bool {\n@@ -495,6 +497,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (self.resolve_vars_if_possible(ty), expr.span)\n             })\n             .collect();\n+        let callee_expr = match &call_expr.peel_blocks().kind {\n+            hir::ExprKind::Call(callee, _) => Some(*callee),\n+            hir::ExprKind::MethodCall(_, callee, _) => {\n+                if let Some((DefKind::AssocFn, def_id)) =\n+                    self.typeck_results.borrow().type_dependent_def(call_expr.hir_id)\n+                    && let Some(assoc) = tcx.opt_associated_item(def_id)\n+                    && assoc.fn_has_self_parameter\n+                {\n+                    Some(&callee[0])\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        };\n+        let callee_ty = callee_expr\n+            .and_then(|callee_expr| self.typeck_results.borrow().expr_ty_adjusted_opt(callee_expr));\n \n         // A \"softer\" version of the `demand_compatible`, which checks types without persisting them,\n         // and treats error types differently\n@@ -631,7 +650,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             Applicability::MachineApplicable,\n                         );\n                     };\n-                    label_fn_like(tcx, &mut err, fn_def_id);\n+                    self.label_fn_like(&mut err, fn_def_id, callee_ty);\n                     err.emit();\n                     return;\n                 }\n@@ -721,7 +740,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 format!(\"arguments to this {} are incorrect\", call_name),\n             );\n             // Call out where the function is defined\n-            label_fn_like(tcx, &mut err, fn_def_id);\n+            self.label_fn_like(&mut err, fn_def_id, callee_ty);\n             err.emit();\n             return;\n         }\n@@ -1003,7 +1022,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         // Call out where the function is defined\n-        label_fn_like(tcx, &mut err, fn_def_id);\n+        self.label_fn_like(&mut err, fn_def_id, callee_ty);\n \n         // And add a suggestion block for all of the parameters\n         let suggestion_text = match suggestion_text {\n@@ -1795,47 +1814,86 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n     }\n-}\n \n-fn label_fn_like<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    err: &mut rustc_errors::DiagnosticBuilder<'tcx, rustc_errors::ErrorGuaranteed>,\n-    def_id: Option<DefId>,\n-) {\n-    let Some(def_id) = def_id else {\n-        return;\n-    };\n-\n-    if let Some(def_span) = tcx.def_ident_span(def_id) {\n-        let mut spans: MultiSpan = def_span.into();\n-\n-        let params = tcx\n-            .hir()\n-            .get_if_local(def_id)\n-            .and_then(|node| node.body_id())\n-            .into_iter()\n-            .flat_map(|id| tcx.hir().body(id).params);\n-\n-        for param in params {\n-            spans.push_span_label(param.span, \"\");\n+    fn label_fn_like(\n+        &self,\n+        err: &mut rustc_errors::DiagnosticBuilder<'tcx, rustc_errors::ErrorGuaranteed>,\n+        def_id: Option<DefId>,\n+        callee_ty: Option<Ty<'tcx>>,\n+    ) {\n+        let Some(mut def_id) = def_id else {\n+            return;\n+        };\n+\n+        if let Some(assoc_item) = self.tcx.opt_associated_item(def_id)\n+            && let trait_def_id = assoc_item.trait_item_def_id.unwrap_or_else(|| self.tcx.parent(def_id))\n+            // Just an easy way to check \"trait_def_id == Fn/FnMut/FnOnce\"\n+            && ty::ClosureKind::from_def_id(self.tcx, trait_def_id).is_some()\n+            && let Some(callee_ty) = callee_ty\n+        {\n+            let callee_ty = callee_ty.peel_refs();\n+            match *callee_ty.kind() {\n+                ty::Param(param) => {\n+                    let param =\n+                        self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx);\n+                    if param.kind.is_synthetic() {\n+                        // if it's `impl Fn() -> ..` then just fall down to the def-id based logic\n+                        def_id = param.def_id;\n+                    } else {\n+                        // Otherwise, find the predicate that makes this generic callable,\n+                        // and point at that.\n+                        let instantiated = self\n+                            .tcx\n+                            .explicit_predicates_of(self.body_id.owner)\n+                            .instantiate_identity(self.tcx);\n+                        // FIXME(compiler-errors): This could be problematic if something has two\n+                        // fn-like predicates with different args, but callable types really never\n+                        // do that, so it's OK.\n+                        for (predicate, span) in\n+                            std::iter::zip(instantiated.predicates, instantiated.spans)\n+                        {\n+                            if let ty::PredicateKind::Trait(pred) = predicate.kind().skip_binder()\n+                                && pred.self_ty() == callee_ty\n+                                && ty::ClosureKind::from_def_id(self.tcx, pred.def_id()).is_some()\n+                            {\n+                                err.span_note(span, \"callable defined here\");\n+                                return;\n+                            }\n+                        }\n+                    }\n+                }\n+                ty::Opaque(new_def_id, _) | ty::Closure(new_def_id, _) | ty::FnDef(new_def_id, _) => {\n+                    def_id = new_def_id;\n+                }\n+                _ => {\n+                    return;\n+                }\n+            }\n         }\n \n-        let def_kind = tcx.def_kind(def_id);\n-        err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n-    } else {\n-        match tcx.hir().get_if_local(def_id) {\n-            Some(hir::Node::Expr(hir::Expr {\n-                kind: hir::ExprKind::Closure(hir::Closure { fn_decl_span, .. }),\n-                ..\n-            })) => {\n-                let spans: MultiSpan = (*fn_decl_span).into();\n+        if let Some(def_span) = self.tcx.def_ident_span(def_id) && !def_span.is_dummy() {\n+            let mut spans: MultiSpan = def_span.into();\n \n-                // Note: We don't point to param spans here because they overlap\n-                // with the closure span itself\n+            let params = self\n+                .tcx\n+                .hir()\n+                .get_if_local(def_id)\n+                .and_then(|node| node.body_id())\n+                .into_iter()\n+                .flat_map(|id| self.tcx.hir().body(id).params);\n \n-                err.span_note(spans, \"closure defined here\");\n+            for param in params {\n+                spans.push_span_label(param.span, \"\");\n             }\n-            _ => {}\n+\n+            let def_kind = self.tcx.def_kind(def_id);\n+            err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n+        } else if let def_kind @ (DefKind::Closure | DefKind::OpaqueTy) = self.tcx.def_kind(def_id)\n+        {\n+            err.span_note(\n+                self.tcx.def_span(def_id),\n+                &format!(\"{} defined here\", def_kind.descr(def_id)),\n+            );\n         }\n     }\n }"}, {"sha": "a18e967668deff0d7180d45d3731d240900e0252", "filename": "src/test/ui/argument-suggestions/exotic-calls.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.rs?ref=ddb7003b7950a6df815d1f03ea6eca9f4cc2a408", "patch": "@@ -0,0 +1,26 @@\n+fn foo<T: Fn()>(t: T) {\n+    t(1i32);\n+    //~^ ERROR this function takes 0 arguments but 1 argument was supplied\n+}\n+\n+fn bar(t: impl Fn()) {\n+    t(1i32);\n+    //~^ ERROR this function takes 0 arguments but 1 argument was supplied\n+}\n+\n+fn baz() -> impl Fn() {\n+    || {}\n+}\n+\n+fn baz2() {\n+    baz()(1i32)\n+    //~^ ERROR this function takes 0 arguments but 1 argument was supplied\n+}\n+\n+fn qux() {\n+    let x = || {};\n+    x(1i32);\n+    //~^ ERROR this function takes 0 arguments but 1 argument was supplied\n+}\n+\n+fn main() {}"}, {"sha": "ca93ecc4e381a9407d27f2b5d2c923e51025cc89", "filename": "src/test/ui/argument-suggestions/exotic-calls.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.stderr?ref=ddb7003b7950a6df815d1f03ea6eca9f4cc2a408", "patch": "@@ -0,0 +1,67 @@\n+error[E0057]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/exotic-calls.rs:2:5\n+   |\n+LL |     t(1i32);\n+   |     ^ ---- argument of type `i32` unexpected\n+   |\n+note: callable defined here\n+  --> $DIR/exotic-calls.rs:1:11\n+   |\n+LL | fn foo<T: Fn()>(t: T) {\n+   |           ^^^^\n+help: remove the extra argument\n+   |\n+LL |     t();\n+   |     ~~~\n+\n+error[E0057]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/exotic-calls.rs:7:5\n+   |\n+LL |     t(1i32);\n+   |     ^ ---- argument of type `i32` unexpected\n+   |\n+note: type parameter defined here\n+  --> $DIR/exotic-calls.rs:6:11\n+   |\n+LL | fn bar(t: impl Fn()) {\n+   |           ^^^^^^^^^\n+help: remove the extra argument\n+   |\n+LL |     t();\n+   |     ~~~\n+\n+error[E0057]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/exotic-calls.rs:16:5\n+   |\n+LL |     baz()(1i32)\n+   |     ^^^^^ ---- argument of type `i32` unexpected\n+   |\n+note: opaque type defined here\n+  --> $DIR/exotic-calls.rs:11:13\n+   |\n+LL | fn baz() -> impl Fn() {\n+   |             ^^^^^^^^^\n+help: remove the extra argument\n+   |\n+LL |     baz()()\n+   |\n+\n+error[E0057]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/exotic-calls.rs:22:5\n+   |\n+LL |     x(1i32);\n+   |     ^ ---- argument of type `i32` unexpected\n+   |\n+note: closure defined here\n+  --> $DIR/exotic-calls.rs:21:13\n+   |\n+LL |     let x = || {};\n+   |             ^^\n+help: remove the extra argument\n+   |\n+LL |     x();\n+   |     ~~~\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0057`."}, {"sha": "aaa3c49b3d83ea468b98434656856502c29b824d", "filename": "src/test/ui/issues/issue-16939.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408/src%2Ftest%2Fui%2Fissues%2Fissue-16939.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408/src%2Ftest%2Fui%2Fissues%2Fissue-16939.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16939.stderr?ref=ddb7003b7950a6df815d1f03ea6eca9f4cc2a408", "patch": "@@ -4,11 +4,11 @@ error[E0057]: this function takes 0 arguments but 1 argument was supplied\n LL |     |t| f(t);\n    |         ^ - argument unexpected\n    |\n-note: associated function defined here\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n+note: callable defined here\n+  --> $DIR/issue-16939.rs:4:12\n    |\n-LL |     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n-   |                           ^^^^\n+LL | fn _foo<F: Fn()> (f: F) {\n+   |            ^^^^\n help: remove the extra argument\n    |\n LL |     |t| f();"}, {"sha": "5ed15468fd64a458cb3e4e920b23453bbca81204", "filename": "src/test/ui/mismatched_types/overloaded-calls-bad.stderr", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr?ref=ddb7003b7950a6df815d1f03ea6eca9f4cc2a408", "patch": "@@ -5,24 +5,13 @@ LL |     let ans = s(\"what\");\n    |               - ^^^^^^ expected `isize`, found `&str`\n    |               |\n    |               arguments to this function are incorrect\n-   |\n-note: associated function defined here\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-   |                           ^^^^^^^^\n \n error[E0057]: this function takes 1 argument but 0 arguments were supplied\n   --> $DIR/overloaded-calls-bad.rs:29:15\n    |\n LL |     let ans = s();\n    |               ^-- an argument of type `isize` is missing\n    |\n-note: associated function defined here\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-   |                           ^^^^^^^^\n help: provide the argument\n    |\n LL |     let ans = s(/* isize */);\n@@ -36,11 +25,6 @@ LL |     let ans = s(\"burma\", \"shave\");\n    |                 |\n    |                 expected `isize`, found `&str`\n    |\n-note: associated function defined here\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-   |                           ^^^^^^^^\n help: remove the extra argument\n    |\n LL |     let ans = s(/* isize */);"}]}