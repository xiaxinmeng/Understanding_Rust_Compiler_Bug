{"sha": "cdcf28dd30d0f8505deae147e1dfe21120a3b8f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkY2YyOGRkMzBkMGY4NTA1ZGVhZTE0N2UxZGZlMjExMjBhM2I4ZjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-06T03:31:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-06T03:31:53Z"}, "message": "auto merge of #11270 : lkuper/rust/trait-docs, r=cmr\n\nI've been wanting to explain default methods in the tutorial for ages.  While I was at it I tried to clarify some other parts of the traits section.  I'm sure this could be improved further; suggestions welcome.", "tree": {"sha": "5b32c5e7bab6f3ef67723ab3c689c08a92249b58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b32c5e7bab6f3ef67723ab3c689c08a92249b58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdcf28dd30d0f8505deae147e1dfe21120a3b8f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdcf28dd30d0f8505deae147e1dfe21120a3b8f3", "html_url": "https://github.com/rust-lang/rust/commit/cdcf28dd30d0f8505deae147e1dfe21120a3b8f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdcf28dd30d0f8505deae147e1dfe21120a3b8f3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8adbb383c456f2040e6d0cc3b487cdf6a70a7e13", "url": "https://api.github.com/repos/rust-lang/rust/commits/8adbb383c456f2040e6d0cc3b487cdf6a70a7e13", "html_url": "https://github.com/rust-lang/rust/commit/8adbb383c456f2040e6d0cc3b487cdf6a70a7e13"}, {"sha": "8224816a34f805d312e9c7cdd740940ddcef815a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8224816a34f805d312e9c7cdd740940ddcef815a", "html_url": "https://github.com/rust-lang/rust/commit/8224816a34f805d312e9c7cdd740940ddcef815a"}], "stats": {"total": 157, "additions": 114, "deletions": 43}, "files": [{"sha": "b5eba8a113c09a6e54cb5e559fdbb9a5af9dfd90", "filename": "doc/tutorial.md", "status": "modified", "additions": 114, "deletions": 43, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/cdcf28dd30d0f8505deae147e1dfe21120a3b8f3/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdcf28dd30d0f8505deae147e1dfe21120a3b8f3/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=cdcf28dd30d0f8505deae147e1dfe21120a3b8f3", "patch": "@@ -2035,28 +2035,30 @@ C++ templates.\n \n ## Traits\n \n-Within a generic function the operations available on generic types\n-are very limited. After all, since the function doesn't know what\n-types it is operating on, it can't safely modify or query their\n-values. This is where _traits_ come into play. Traits are Rust's most\n-powerful tool for writing polymorphic code. Java developers will see\n-them as similar to Java interfaces, and Haskellers will notice their\n-similarities to type classes. Rust's traits are a form of *bounded\n-polymorphism*: a trait is a way of limiting the set of possible types\n-that a type parameter could refer to.\n-\n-As motivation, let us consider copying in Rust.\n-The `clone` method is not defined for all Rust types.\n-One reason is user-defined destructors:\n-copying a type that has a destructor\n-could result in the destructor running multiple times.\n-Therefore, types with destructors cannot be copied\n-unless you explicitly implement `Clone` for them.\n+Within a generic function -- that is, a function parameterized by a\n+type parameter, say, `T` -- the operations we can do on arguments of\n+type `T` are quite limited.  After all, since we don't know what type\n+`T` will be instantiated with, we can't safely modify or query values\n+of type `T`.  This is where _traits_ come into play. Traits are Rust's\n+most powerful tool for writing polymorphic code. Java developers will\n+see them as similar to Java interfaces, and Haskellers will notice\n+their similarities to type classes. Rust's traits give us a way to\n+express *bounded polymorphism*: by limiting the set of possible types\n+that a type parameter could refer to, they expand the number of\n+operations we can safely perform on arguments of that type.\n+\n+As motivation, let us consider copying of values in Rust.  The `clone`\n+method is not defined for values of every type.  One reason is\n+user-defined destructors: copying a value of a type that has a\n+destructor could result in the destructor running multiple times.\n+Therefore, values of types that have destructors cannot be copied\n+unless we explicitly implement `clone` for them.\n \n This complicates handling of generic functions.\n-If you have a type parameter `T`, can you copy values of that type?\n-In Rust, you can't,\n-and if you try to run the following code the compiler will complain.\n+If we have a function with a type parameter `T`,\n+can we copy values of type `T` inside that function?\n+In Rust, we can't,\n+and if we try to run the following code the compiler will complain.\n \n ~~~~ {.xfail-test}\n // This does not compile\n@@ -2066,11 +2068,10 @@ fn head_bad<T>(v: &[T]) -> T {\n ~~~~\n \n However, we can tell the compiler\n-that the `head` function is only for copyable types:\n-that is, those that implement the `Clone` trait.\n-In that case,\n-we can explicitly create a second copy of the value we are returning\n-using the `clone` keyword:\n+that the `head` function is only for copyable types.\n+In Rust, copyable types are those that _implement the `Clone` trait_.  \n+We can then explicitly create a second copy of the value we are returning\n+by calling the `clone` method:\n \n ~~~~\n // This does\n@@ -2079,12 +2080,14 @@ fn head<T: Clone>(v: &[T]) -> T {\n }\n ~~~~\n \n-This says that we can call `head` on any type `T`\n-as long as that type implements the `Clone` trait.\n+The bounded type parameter `T: Clone` says that `head`\n+can be called on an argument of type `&[T]` for any `T`,\n+so long as there is an implementation of the\n+`Clone` trait for `T`.\n When instantiating a generic function,\n-you can only instantiate it with types\n+we can only instantiate it with types\n that implement the correct trait,\n-so you could not apply `head` to a type\n+so we could not apply `head` to a vector whose elements are of some type\n that does not implement `Clone`.\n \n While most traits can be defined and implemented by user code,\n@@ -2110,7 +2113,7 @@ have the `'static` lifetime.\n > iterations of the language, and often still are.\n \n Additionally, the `Drop` trait is used to define destructors. This\n-trait defines one method called `drop`, which is automatically\n+trait provides one method called `drop`, which is automatically\n called when a value of the type that implements this trait is\n destroyed, either because the value went out of scope or because the\n garbage collector reclaimed it.\n@@ -2134,29 +2137,36 @@ may call it.\n \n ## Declaring and implementing traits\n \n-A trait consists of a set of methods without bodies,\n-or may be empty, as is the case with `Send` and `Freeze`.\n+At its simplest, a trait is a set of zero or more _method signatures_.\n For example, we could declare the trait\n `Printable` for things that can be printed to the console,\n-with a single method:\n+with a single method signature:\n \n ~~~~\n trait Printable {\n     fn print(&self);\n }\n ~~~~\n \n-Traits may be implemented for specific types with [impls]. An impl\n-that implements a trait includes the name of the trait at the start of\n-the definition, as in the following impls of `Printable` for `int`\n-and `~str`.\n+We say that the `Printable` trait _provides_ a `print` method with the\n+given signature.  This means that we can call `print` on an argument\n+of any type that implements the `Printable` trait.\n+\n+Rust's built-in `Send` and `Freeze` types are examples of traits that\n+don't provide any methods.\n+\n+Traits may be implemented for specific types with [impls]. An impl for\n+a particular trait gives an implementation of the methods that\n+trait provides.  For instance, the following impls of\n+`Printable` for `int` and `~str` give implementations of the `print`\n+method.\n \n [impls]: #methods\n \n ~~~~\n # trait Printable { fn print(&self); }\n impl Printable for int {\n-    fn print(&self) { println!(\"{}\", *self) }\n+    fn print(&self) { println!(\"{:?}\", *self) }\n }\n \n impl Printable for ~str {\n@@ -2167,10 +2177,71 @@ impl Printable for ~str {\n # (~\"foo\").print();\n ~~~~\n \n-Methods defined in an implementation of a trait may be called just like\n-any other method, using dot notation, as in `1.print()`. Traits may\n-themselves contain type parameters. A trait for generalized sequence\n-types might look like the following:\n+Methods defined in an impl for a trait may be called just like\n+any other method, using dot notation, as in `1.print()`.\n+\n+## Default method implementations in trait definitions\n+\n+Sometimes, a method that a trait provides will have the same\n+implementation for most or all of the types that implement that trait.\n+For instance, suppose that we wanted `bool`s and `f32`s to be\n+printable, and that we wanted the implementation of `print` for those\n+types to be exactly as it is for `int`, above:\n+\n+~~~~\n+# trait Printable { fn print(&self); }\n+impl Printable for f32 {\n+    fn print(&self) { println!(\"{:?}\", *self) }\n+}\n+\n+impl Printable for bool {\n+    fn print(&self) { println!(\"{:?}\", *self) }\n+}\n+\n+# true.print();\n+# 3.14159.print();\n+~~~~\n+\n+This works fine, but we've now repeated the same definition of `print`\n+in three places.  Instead of doing that, we can simply include the\n+definition of `print` right in the trait definition, instead of just\n+giving its signature.  That is, we can write the following:\n+\n+~~~~\n+trait Printable {\n+\t// Default method implementation\n+    fn print(&self) { println!(\"{:?}\", *self) }\n+}\n+\n+impl Printable for int {}\n+\n+impl Printable for ~str {\n+    fn print(&self) { println(*self) }\n+}\n+\n+impl Printable for bool {}\n+\n+impl Printable for f32 {}\n+\n+# 1.print();\n+# (~\"foo\").print();\n+# true.print();\n+# 3.14159.print();\n+~~~~\n+\n+Here, the impls of `Printable` for `int`, `bool`, and `f32` don't\n+need to provide an implementation of `print`, because in the absence\n+of a specific implementation, Rust just uses the _default method_\n+provided in the trait definition.  Depending on the trait, default\n+methods can save a great deal of boilerplate code from having to be\n+written in impls.  Of course, individual impls can still override the\n+default method for `print`, as is being done above in the impl for\n+`~str`.\n+\n+## Type-parameterized traits\n+\n+Traits may be parameterized by type variables.  For example, a trait\n+for generalized sequence types might look like the following:\n \n ~~~~\n trait Seq<T> {\n@@ -3023,7 +3094,7 @@ they model most closely what people expect to shadow.\n \n ## Package ids\n \n-If you use `extern mod`, per default `rustc` will look for libraries in the the library search path (which you can\n+If you use `extern mod`, per default `rustc` will look for libraries in the library search path (which you can\n extend with the `-L` switch).\n \n However, Rust also ships with rustpkg, a package manager that is able to automatically download and build"}]}