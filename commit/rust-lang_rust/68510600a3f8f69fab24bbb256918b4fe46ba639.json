{"sha": "68510600a3f8f69fab24bbb256918b4fe46ba639", "node_id": "C_kwDOAAsO6NoAKDY4NTEwNjAwYTNmOGY2OWZhYjI0YmJiMjU2OTE4YjRmZTQ2YmE2Mzk", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-17T14:19:29Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-17T14:19:29Z"}, "message": "use PlaceTy visitor", "tree": {"sha": "d65a8808b58f13e7bcba02191b03e1e400b5eda1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d65a8808b58f13e7bcba02191b03e1e400b5eda1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68510600a3f8f69fab24bbb256918b4fe46ba639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68510600a3f8f69fab24bbb256918b4fe46ba639", "html_url": "https://github.com/rust-lang/rust/commit/68510600a3f8f69fab24bbb256918b4fe46ba639", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68510600a3f8f69fab24bbb256918b4fe46ba639/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "416cddb2516dea056bf6269eaaa5ba4d24ad0832", "url": "https://api.github.com/repos/rust-lang/rust/commits/416cddb2516dea056bf6269eaaa5ba4d24ad0832", "html_url": "https://github.com/rust-lang/rust/commit/416cddb2516dea056bf6269eaaa5ba4d24ad0832"}], "stats": {"total": 34, "additions": 15, "deletions": 19}, "files": [{"sha": "d1e9ae1c57044f3ec6a7ec23450ecd71e4831997", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/68510600a3f8f69fab24bbb256918b4fe46ba639/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68510600a3f8f69fab24bbb256918b4fe46ba639/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=68510600a3f8f69fab24bbb256918b4fe46ba639", "patch": "@@ -1037,17 +1037,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Raw pointers need to be enabled.\n                 ty::RawPtr(tym) if kind == RetagKind::Raw =>\n                     Some((RefKind::Raw { mutable: tym.mutbl == Mutability::Mut }, false)),\n-                // Boxes are handled separately due to that allocator situation.\n+                // Boxes are handled separately due to that allocator situation,\n+                // see the visitor below.\n                 _ => None,\n             }\n         }\n \n-        // We need a visitor to visit all references. However, that requires\n-        // a `MPlaceTy` (or `OpTy`), so we have a fast path for reference types that\n-        // avoids allocating.\n-\n+        // For some types we can do the work without starting up the visitor infrastructure.\n         if let Some((ref_kind, protector)) = qualify(place.layout.ty, kind) {\n-            // Fast path.\n             let val = this.read_immediate(&this.place_to_op(place)?)?;\n             let val = this.retag_reference(&val, ref_kind, protector)?;\n             this.write_immediate(*val, place)?;\n@@ -1077,11 +1074,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         ) {\n             return Ok(());\n         }\n-        // Now go visit this thing.\n-        let place = this.force_allocation(place)?;\n \n+        // Now go visit this thing.\n         let mut visitor = RetagVisitor { ecx: this, kind };\n-        return visitor.visit_value(&place);\n+        return visitor.visit_value(place);\n \n         // The actual visitor.\n         struct RetagVisitor<'ecx, 'mir, 'tcx> {\n@@ -1091,36 +1087,36 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         impl<'ecx, 'mir, 'tcx> MutValueVisitor<'mir, 'tcx, Evaluator<'mir, 'tcx>>\n             for RetagVisitor<'ecx, 'mir, 'tcx>\n         {\n-            type V = MPlaceTy<'tcx, Tag>;\n+            type V = PlaceTy<'tcx, Tag>;\n \n             #[inline(always)]\n             fn ecx(&mut self) -> &mut MiriEvalContext<'mir, 'tcx> {\n                 self.ecx\n             }\n \n-            fn visit_box(&mut self, place: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+            fn visit_box(&mut self, place: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n                 // Boxes do not get a protector: protectors reflect that references outlive the call\n                 // they were passed in to; that's just not the case for boxes.\n                 let (ref_kind, protector) = (RefKind::Unique { two_phase: false }, false);\n-\n-                let val = self.ecx.read_immediate(&place.into())?;\n+                let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n                 let val = self.ecx.retag_reference(&val, ref_kind, protector)?;\n-                self.ecx.write_immediate(*val, &place.into())?;\n+                self.ecx.write_immediate(*val, place)?;\n                 Ok(())\n             }\n \n-            fn visit_value(&mut self, place: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+            fn visit_value(&mut self, place: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n                 if let Some((ref_kind, protector)) = qualify(place.layout.ty, self.kind) {\n-                    let val = self.ecx.read_immediate(&place.into())?;\n+                    let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n                     let val = self.ecx.retag_reference(&val, ref_kind, protector)?;\n-                    self.ecx.write_immediate(*val, &place.into())?;\n+                    self.ecx.write_immediate(*val, place)?;\n                 } else if matches!(place.layout.ty.kind(), ty::RawPtr(..)) {\n                     // Wide raw pointers *do* have fields and their types are strange.\n                     // vtables have a type like `&[*const (); 3]` or so!\n                     // Do *not* recurse into them.\n-                    // (No need to worry about wide references or boxes, those always \"qualify\".)\n+                    // (No need to worry about wide references, those always \"qualify\". And Boxes\n+                    // are handles specially by the visitor anyway.)\n                 } else {\n-                    // Maybe we need to go deeper.\n+                    // Recurse deeper.\n                     self.walk_value(place)?;\n                 }\n                 Ok(())"}]}