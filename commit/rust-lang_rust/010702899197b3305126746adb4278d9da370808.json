{"sha": "010702899197b3305126746adb4278d9da370808", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMDcwMjg5OTE5N2IzMzA1MTI2NzQ2YWRiNDI3OGQ5ZGEzNzA4MDg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-11T17:06:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-16T14:29:49Z"}, "message": "Resume inlining globals across crates\n\nIn #8185 cross-crate condition handlers were fixed by ensuring that globals\ndidn't start appearing in different crates with different addressed. An\nunfortunate side effect of that pull request is that constants weren't inlined\nacross crates (uint::bits is unknown to everything but libstd).\n\nThis commit fixes this inlining by using the `available_eternally` linkage\nprovided by LLVM. It partially reverts #8185, and then adds support for this\nlinkage type. The main caveat is that not all statics could be inlined into\nother crates. Before this patch, all statics were considered \"inlineable items\",\nbut an unfortunate side effect of how we deal with `&static` and `&[static]`\nmeans that these two cases cannot be inlined across crates. The translation of\nconstants was modified to propogate this condition of whether a constant\nshould be considered inlineable into other crates.\n\nCloses #9036", "tree": {"sha": "25e5d9026efde46f5af5091bf95f84e2ff92a58a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25e5d9026efde46f5af5091bf95f84e2ff92a58a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/010702899197b3305126746adb4278d9da370808", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/010702899197b3305126746adb4278d9da370808", "html_url": "https://github.com/rust-lang/rust/commit/010702899197b3305126746adb4278d9da370808", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/010702899197b3305126746adb4278d9da370808/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e1803f3af1adc1b2e5595650f6920f40bbedc2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e1803f3af1adc1b2e5595650f6920f40bbedc2e", "html_url": "https://github.com/rust-lang/rust/commit/3e1803f3af1adc1b2e5595650f6920f40bbedc2e"}], "stats": {"total": 216, "additions": 157, "deletions": 59}, "files": [{"sha": "9e65e4ec18a97685311070f4239efe2c9cd23e9a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=010702899197b3305126746adb4278d9da370808", "patch": "@@ -60,6 +60,7 @@ pub struct EncodeParams<'self> {\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'self HashMap<ast::NodeId, ~str>,\n     discrim_symbols: &'self HashMap<ast::NodeId, @str>,\n+    non_inlineable_statics: &'self HashSet<ast::NodeId>,\n     link_meta: &'self LinkMeta,\n     cstore: @mut cstore::CStore,\n     encode_inlined_item: encode_inlined_item<'self>,\n@@ -89,6 +90,7 @@ pub struct EncodeContext<'self> {\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'self HashMap<ast::NodeId, ~str>,\n     discrim_symbols: &'self HashMap<ast::NodeId, @str>,\n+    non_inlineable_statics: &'self HashSet<ast::NodeId>,\n     link_meta: &'self LinkMeta,\n     cstore: &'self cstore::CStore,\n     encode_inlined_item: encode_inlined_item<'self>,\n@@ -907,7 +909,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         let elt = ast_map::path_pretty_name(item.ident, item.id as u64);\n         encode_path(ecx, ebml_w, path, elt);\n-        (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n+        if !ecx.non_inlineable_statics.contains(&item.id) {\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n+        }\n         ebml_w.end_tag();\n       }\n       item_fn(_, purity, _, ref generics, _) => {\n@@ -1728,6 +1732,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         encode_inlined_item,\n         link_meta,\n         reachable,\n+        non_inlineable_statics,\n         _\n     } = parms;\n     let type_abbrevs = @mut HashMap::new();\n@@ -1739,6 +1744,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         reexports2: reexports2,\n         item_symbols: item_symbols,\n         discrim_symbols: discrim_symbols,\n+        non_inlineable_statics: non_inlineable_statics,\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: encode_inlined_item,"}, {"sha": "d27bcde20649cf8fda14d52b1ebd5c928b0a526e", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=010702899197b3305126746adb4278d9da370808", "patch": "@@ -324,15 +324,16 @@ fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n             return single_result(datumblock.to_result(bcx));\n         }\n         lit(ConstLit(lit_id)) => {\n-            let llval = consts::get_const_val(bcx.ccx(), lit_id);\n+            let (llval, _) = consts::get_const_val(bcx.ccx(), lit_id);\n             return single_result(rslt(bcx, llval));\n         }\n         var(disr_val, repr) => {\n             return adt::trans_case(bcx, repr, disr_val);\n         }\n         range(l1, l2) => {\n-            return range_result(rslt(bcx, consts::const_expr(ccx, l1)),\n-                                rslt(bcx, consts::const_expr(ccx, l2)));\n+            let (l1, _) = consts::const_expr(ccx, l1);\n+            let (l2, _) = consts::const_expr(ccx, l2);\n+            return range_result(rslt(bcx, l1), rslt(bcx, l2));\n         }\n         vec_len(n, vec_len_eq, _) => {\n             return single_result(rslt(bcx, C_int(ccx, n as int)));"}, {"sha": "823825b519ee136fad9c212328494f667867b55f", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=010702899197b3305126746adb4278d9da370808", "patch": "@@ -2494,12 +2494,29 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                     let sym = exported_name(ccx, my_path, ty, i.attrs);\n \n                     let v = match i.node {\n-                        ast::item_static(_, m, expr) => {\n+                        ast::item_static(_, _, expr) => {\n+                            // If this static came from an external crate, then\n+                            // we need to get the symbol from csearch instead of\n+                            // using the current crate's name/version\n+                            // information in the hash of the symbol\n+                            debug!(\"making %s\", sym);\n+                            let sym = match ccx.external_srcs.find(&i.id) {\n+                                Some(&did) => {\n+                                    debug!(\"but found in other crate...\");\n+                                    csearch::get_symbol(ccx.sess.cstore, did)\n+                                }\n+                                None => sym\n+                            };\n+\n                             // We need the translated value here, because for enums the\n                             // LLVM type is not fully determined by the Rust type.\n-                            let v = consts::const_expr(ccx, expr);\n+                            let (v, inlineable) = consts::const_expr(ccx, expr);\n                             ccx.const_values.insert(id, v);\n-                            exprt = (m == ast::MutMutable || i.vis == ast::public);\n+                            if !inlineable {\n+                                debug!(\"%s not inlined\", sym);\n+                                ccx.non_inlineable_statics.insert(id);\n+                            }\n+                            exprt = true;\n \n                             unsafe {\n                                 let llty = llvm::LLVMTypeOf(v);\n@@ -2950,6 +2967,7 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_\n             reexports2: cx.exp_map2,\n             item_symbols: item_symbols,\n             discrim_symbols: discrim_symbols,\n+            non_inlineable_statics: &cx.non_inlineable_statics,\n             link_meta: link_meta,\n             cstore: cx.sess.cstore,\n             encode_inlined_item: ie,"}, {"sha": "a7a04627981a97d0cf0955fa9bebb9c286f1de52", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 72, "deletions": 49, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=010702899197b3305126746adb4278d9da370808", "patch": "@@ -84,21 +84,21 @@ pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: Type) -> ValueRef {\n }\n \n pub fn const_vec(cx: @mut CrateContext, e: &ast::Expr, es: &[@ast::Expr])\n-    -> (ValueRef, ValueRef, Type) {\n+    -> (ValueRef, ValueRef, Type, bool) {\n     unsafe {\n         let vec_ty = ty::expr_ty(cx.tcx, e);\n         let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n         let llunitty = type_of::type_of(cx, unit_ty);\n         let unit_sz = machine::llsize_of(cx, llunitty);\n         let sz = llvm::LLVMConstMul(C_uint(cx, es.len()), unit_sz);\n-        let vs = es.map(|e| const_expr(cx, *e));\n+        let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e)));\n         // If the vector contains enums, an LLVM array won't work.\n         let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n             C_struct(vs)\n         } else {\n             C_array(llunitty, vs)\n         };\n-        return (v, sz, llunitty);\n+        return (v, sz, llunitty, inlineable.iter().fold(true, |a, &b| a && b));\n     }\n }\n \n@@ -157,7 +157,8 @@ fn const_deref(cx: &mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     }\n }\n \n-pub fn get_const_val(cx: @mut CrateContext, mut def_id: ast::DefId) -> ValueRef {\n+pub fn get_const_val(cx: @mut CrateContext,\n+                     mut def_id: ast::DefId) -> (ValueRef, bool) {\n     let contains_key = cx.const_values.contains_key(&def_id.node);\n     if !ast_util::is_local(def_id) || !contains_key {\n         if !ast_util::is_local(def_id) {\n@@ -172,11 +173,14 @@ pub fn get_const_val(cx: @mut CrateContext, mut def_id: ast::DefId) -> ValueRef\n             _ => cx.tcx.sess.bug(\"expected a const to be an item\")\n         }\n     }\n-    cx.const_values.get_copy(&def_id.node)\n+    (cx.const_values.get_copy(&def_id.node),\n+     !cx.non_inlineable_statics.contains(&def_id.node))\n }\n \n-pub fn const_expr(cx: @mut CrateContext, e: @ast::Expr) -> ValueRef {\n-    let mut llconst = const_expr_unadjusted(cx, e);\n+pub fn const_expr(cx: @mut CrateContext, e: @ast::Expr) -> (ValueRef, bool) {\n+    let (llconst, inlineable) = const_expr_unadjusted(cx, e);\n+    let mut llconst = llconst;\n+    let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx, e);\n     let adjustment = cx.tcx.adjustments.find_copy(&e.id);\n     match adjustment {\n@@ -204,7 +208,10 @@ pub fn const_expr(cx: @mut CrateContext, e: @ast::Expr) -> ValueRef {\n                     // Don't copy data to do a deref+ref.\n                     let llptr = match maybe_ptr {\n                         Some(ptr) => ptr,\n-                        None => const_addr_of(cx, llconst)\n+                        None => {\n+                            inlineable = false;\n+                            const_addr_of(cx, llconst)\n+                        }\n                     };\n                     match *autoref {\n                         ty::AutoUnsafe(m) |\n@@ -250,17 +257,27 @@ pub fn const_expr(cx: @mut CrateContext, e: @ast::Expr) -> ValueRef {\n                          e.repr(cx.tcx), ty_to_str(cx.tcx, ety),\n                          csize, tsize));\n     }\n-    llconst\n+    (llconst, inlineable)\n }\n \n-fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n+// the bool returned is whether this expression can be inlined into other crates\n+// if it's assigned to a static.\n+fn const_expr_unadjusted(cx: @mut CrateContext,\n+                         e: &ast::Expr) -> (ValueRef, bool) {\n+    fn map_list(cx: @mut CrateContext,\n+                exprs: &[@ast::Expr]) -> (~[ValueRef], bool) {\n+        exprs.iter().map(|&e| const_expr(cx, e))\n+             .fold((~[], true), |(L, all_inlineable), (val, inlineable)| {\n+                    (vec::append_one(L, val), all_inlineable && inlineable)\n+             })\n+    }\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n-          ast::ExprLit(lit) => consts::const_lit(cx, e, *lit),\n+          ast::ExprLit(lit) => (consts::const_lit(cx, e, *lit), true),\n           ast::ExprBinary(_, b, e1, e2) => {\n-            let te1 = const_expr(cx, e1);\n-            let te2 = const_expr(cx, e2);\n+            let (te1, _) = const_expr(cx, e1);\n+            let (te2, _) = const_expr(cx, e2);\n \n             let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n@@ -269,7 +286,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n             let ty = ty::expr_ty(cx.tcx, e1);\n             let is_float = ty::type_is_fp(ty);\n             let signed = ty::type_is_signed(ty);\n-            return match b {\n+            return (match b {\n               ast::BiAdd   => {\n                 if is_float { llvm::LLVMConstFAdd(te1, te2) }\n                 else        { llvm::LLVMConstAdd(te1, te2) }\n@@ -338,13 +355,13 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n                       else      { ConstICmp(IntUGT, te1, te2) }\n                   }\n               },\n-            };\n+            }, true)\n           },\n           ast::ExprUnary(_, u, e) => {\n-            let te = const_expr(cx, e);\n+            let (te, _) = const_expr(cx, e);\n             let ty = ty::expr_ty(cx.tcx, e);\n             let is_float = ty::type_is_fp(ty);\n-            return match u {\n+            return (match u {\n               ast::UnBox(_)  |\n               ast::UnUniq |\n               ast::UnDeref  => {\n@@ -367,21 +384,21 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n                 if is_float { llvm::LLVMConstFNeg(te) }\n                 else        { llvm::LLVMConstNeg(te) }\n               }\n-            }\n+            }, true)\n           }\n           ast::ExprField(base, field, _) => {\n               let bt = ty::expr_ty_adjusted(cx.tcx, base);\n               let brepr = adt::represent_type(cx, bt);\n-              let bv = const_expr(cx, base);\n+              let (bv, inlineable) = const_expr(cx, base);\n               do expr::with_field_tys(cx.tcx, bt, None) |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx, field.name, field_tys);\n-                  adt::const_get_field(cx, brepr, bv, discr, ix)\n+                  (adt::const_get_field(cx, brepr, bv, discr, ix), inlineable)\n               }\n           }\n \n           ast::ExprIndex(_, base, index) => {\n               let bt = ty::expr_ty_adjusted(cx.tcx, base);\n-              let bv = const_expr(cx, base);\n+              let (bv, inlineable) = const_expr(cx, base);\n               let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n@@ -422,15 +439,15 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n                   cx.sess.span_err(e.span,\n                                    \"const index-expr is out of bounds\");\n               }\n-              const_get_elt(cx, arr, [iv as c_uint])\n+              (const_get_elt(cx, arr, [iv as c_uint]), inlineable)\n           }\n           ast::ExprCast(base, _) => {\n             let ety = ty::expr_ty(cx.tcx, e);\n             let llty = type_of::type_of(cx, ety);\n             let basety = ty::expr_ty(cx.tcx, base);\n-            let v = const_expr(cx, base);\n-            match (expr::cast_type_kind(basety),\n-                   expr::cast_type_kind(ety)) {\n+            let (v, inlineable) = const_expr(cx, base);\n+            return (match (expr::cast_type_kind(basety),\n+                           expr::cast_type_kind(ety)) {\n \n               (expr::cast_integral, expr::cast_integral) => {\n                 let s = ty::type_is_signed(basety) as Bool;\n@@ -476,17 +493,17 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n                 cx.sess.impossible_case(e.span,\n                                         \"bad combination of types for cast\")\n               }\n-            }\n+            }, inlineable)\n           }\n           ast::ExprAddrOf(ast::MutImmutable, sub) => {\n-              let e = const_expr(cx, sub);\n-              const_addr_of(cx, e)\n+              let (e, _) = const_expr(cx, sub);\n+              (const_addr_of(cx, e), false)\n           }\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n-              let vals = es.map(|&e| const_expr(cx, e));\n-              adt::trans_const(cx, repr, 0, vals)\n+              let (vals, inlineable) = map_list(cx, *es);\n+              (adt::trans_const(cx, repr, 0, vals), inlineable)\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n@@ -500,24 +517,29 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n \n               do expr::with_field_tys(tcx, ety, Some(e.id))\n                   |discr, field_tys| {\n-                  let cs: ~[ValueRef] = field_tys.iter().enumerate()\n+                  let cs = field_tys.iter().enumerate()\n                       .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.ident.name == f.ident.name) {\n                           Some(f) => const_expr(cx, (*f).expr),\n                           None => {\n                               match base_val {\n-                                Some(bv) => adt::const_get_field(cx, repr, bv, discr, ix),\n+                                Some((bv, inlineable)) => {\n+                                    (adt::const_get_field(cx, repr, bv, discr, ix),\n+                                     inlineable)\n+                                }\n                                 None => cx.tcx.sess.span_bug(e.span, \"missing struct field\")\n                               }\n                           }\n                       }\n-                  }).collect();\n-                  adt::trans_const(cx, repr, discr, cs)\n+                  }).to_owned_vec();\n+                  let (cs, inlineable) = vec::unzip(cs.move_iter());\n+                  (adt::trans_const(cx, repr, discr, cs),\n+                   inlineable.iter().fold(true, |a, &b| a && b))\n               }\n           }\n           ast::ExprVec(ref es, ast::MutImmutable) => {\n-            let (v, _, _) = const_vec(cx, e, *es);\n-            v\n+            let (v, _, _, inlineable) = const_vec(cx, e, *es);\n+            (v, inlineable)\n           }\n           ast::ExprVstore(sub, ast::ExprVstoreSlice) => {\n             match sub.node {\n@@ -528,7 +550,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n                 }\n               }\n               ast::ExprVec(ref es, ast::MutImmutable) => {\n-                let (cv, sz, llunitty) = const_vec(cx, e, *es);\n+                let (cv, sz, llunitty, _) = const_vec(cx, e, *es);\n                 let llty = val_ty(cv);\n                 let gv = do \"const\".with_c_str |name| {\n                     llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n@@ -537,7 +559,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n                 llvm::LLVMSetGlobalConstant(gv, True);\n                 SetLinkage(gv, PrivateLinkage);\n                 let p = const_ptrcast(cx, gv, llunitty);\n-                C_struct([p, sz])\n+                (C_struct([p, sz]), false)\n               }\n               _ => cx.sess.span_bug(e.span, \"bad const-slice expr\")\n             }\n@@ -551,13 +573,13 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess.span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = vec::from_elem(n, const_expr(cx, elem));\n+            let vs = vec::from_elem(n, const_expr(cx, elem).first());\n             let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(vs)\n             } else {\n                 C_array(llunitty, vs)\n             };\n-            v\n+            (v, true)\n           }\n           ast::ExprPath(ref pth) => {\n             // Assert that there are no type parameters in this path.\n@@ -568,10 +590,10 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n                 Some(&ast::DefFn(def_id, _purity)) => {\n                     if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx, def_id).ty;\n-                        base::trans_external_path(cx, def_id, ty)\n+                        (base::trans_external_path(cx, def_id, ty), true)\n                     } else {\n                         assert!(ast_util::is_local(def_id));\n-                        base::get_item_val(cx, def_id.node)\n+                        (base::get_item_val(cx, def_id.node), true)\n                     }\n                 }\n                 Some(&ast::DefStatic(def_id, false)) => {\n@@ -583,12 +605,12 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n                     let vinfo = ty::enum_variant_with_id(cx.tcx,\n                                                          enum_did,\n                                                          variant_did);\n-                    adt::trans_const(cx, repr, vinfo.disr_val, [])\n+                    (adt::trans_const(cx, repr, vinfo.disr_val, []), true)\n                 }\n                 Some(&ast::DefStruct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n                     let llty = type_of::type_of(cx, ety);\n-                    C_null(llty)\n+                    (C_null(llty), true)\n                 }\n                 _ => {\n                     cx.sess.span_bug(e.span, \"expected a const, fn, struct, or variant def\")\n@@ -601,22 +623,23 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n                   Some(&ast::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let arg_vals = args.map(|a| const_expr(cx, *a));\n-                      adt::trans_const(cx, repr, 0, arg_vals)\n+                      let (arg_vals, inlineable) = map_list(cx, *args);\n+                      (adt::trans_const(cx, repr, 0, arg_vals), inlineable)\n                   }\n                   Some(&ast::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx,\n                                                            enum_did,\n                                                            variant_did);\n-                      let arg_vals = args.map(|a| const_expr(cx, *a));\n-                      adt::trans_const(cx, repr, vinfo.disr_val, arg_vals)\n+                      let (arg_vals, inlineable) = map_list(cx, *args);\n+                      (adt::trans_const(cx, repr, vinfo.disr_val, arg_vals),\n+                       inlineable)\n                   }\n                   _ => cx.sess.span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::ExprParen(e) => { return const_expr(cx, e); }\n+          ast::ExprParen(e) => { const_expr(cx, e) }\n           _ => cx.sess.span_bug(e.span,\n                   \"bad constant expression type in consts::const_expr\")\n         };"}, {"sha": "9ee7f09253b545f825511864e4c20d44d02be520", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=010702899197b3305126746adb4278d9da370808", "patch": "@@ -61,6 +61,13 @@ pub struct CrateContext {\n      finished_tydescs: bool,\n      // Track mapping of external ids to local items imported for inlining\n      external: HashMap<ast::DefId, Option<ast::NodeId>>,\n+     // Backwards version of the `external` map (inlined items to where they\n+     // came from)\n+     external_srcs: HashMap<ast::NodeId, ast::DefId>,\n+     // A set of static items which cannot be inlined into other crates. This\n+     // will pevent in ii_item() structures from being encoded into the metadata\n+     // that is generated\n+     non_inlineable_statics: HashSet<ast::NodeId>,\n      // Cache instances of monomorphized functions\n      monomorphized: HashMap<mono_id, ValueRef>,\n      monomorphizing: HashMap<ast::DefId, uint>,\n@@ -189,6 +196,8 @@ impl CrateContext {\n                   tydescs: HashMap::new(),\n                   finished_tydescs: false,\n                   external: HashMap::new(),\n+                  external_srcs: HashMap::new(),\n+                  non_inlineable_statics: HashSet::new(),\n                   monomorphized: HashMap::new(),\n                   monomorphizing: HashMap::new(),\n                   type_use_cache: HashMap::new(),"}, {"sha": "0a5578697583261f0fc5bb1fd75e235e36c6fa02", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=010702899197b3305126746adb4278d9da370808", "patch": "@@ -116,7 +116,7 @@ return type, such as `while` loops or assignments (`a = b`).\n \n use back::abi;\n use back::link;\n-use lib::llvm::{ValueRef, llvm, SetLinkage, ExternalLinkage, False};\n+use lib::llvm::{ValueRef, llvm, SetLinkage, False};\n use lib;\n use metadata::csearch;\n use middle::trans::_match;\n@@ -135,6 +135,7 @@ use middle::trans::datum::*;\n use middle::trans::debuginfo;\n use middle::trans::machine;\n use middle::trans::meth;\n+use middle::trans::inline;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::ty::struct_fields;\n@@ -987,6 +988,15 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n             ast::DefStatic(did, _) => {\n                 let const_ty = expr_ty(bcx, ref_expr);\n \n+                fn get_did(ccx: @mut CrateContext, did: ast::DefId)\n+                    -> ast::DefId {\n+                    if did.crate != ast::LOCAL_CRATE {\n+                        inline::maybe_instantiate_inline(ccx, did)\n+                    } else {\n+                        did\n+                    }\n+                }\n+\n                 fn get_val(bcx: @mut Block, did: ast::DefId, const_ty: ty::t)\n                            -> ValueRef {\n                     // For external constants, we don't inline.\n@@ -1018,14 +1028,14 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n                                                     llty.to_ref(),\n                                                     buf)\n                             };\n-                            SetLinkage(llval, ExternalLinkage);\n                             let extern_const_values = &mut bcx.ccx().extern_const_values;\n                             extern_const_values.insert(did, llval);\n                             llval\n                         }\n                     }\n                 }\n \n+                let did = get_did(bcx.ccx(), did);\n                 let val = get_val(bcx, did, const_ty);\n                 DatumBlock {\n                     bcx: bcx,"}, {"sha": "a571e56a48ec06be63f121505e77cf8cb2b7079f", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010702899197b3305126746adb4278d9da370808/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=010702899197b3305126746adb4278d9da370808", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use lib::llvm::{AvailableExternallyLinkage, SetLinkage};\n use metadata::csearch;\n use middle::astencode;\n use middle::trans::base::{push_ctxt, impl_self, no_self};\n@@ -53,16 +53,36 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n         }\n         csearch::found(ast::ii_item(item)) => {\n             ccx.external.insert(fn_id, Some(item.id));\n+            ccx.external_srcs.insert(item.id, fn_id);\n             ccx.stats.n_inlines += 1;\n             trans_item(ccx, item);\n+\n+            // We're bringing an external global into this crate, but we don't\n+            // want to create two copies of the global. If we do this, then if\n+            // you take the address of the global in two separate crates you get\n+            // two different addresses. This is bad for things like conditions,\n+            // but it could possibly have other adverse side effects. We still\n+            // want to achieve the optimizations related to this global,\n+            // however, so we use the available_externally linkage which llvm\n+            // provides\n+            match item.node {\n+                ast::item_static(*) => {\n+                    let g = get_item_val(ccx, item.id);\n+                    SetLinkage(g, AvailableExternallyLinkage);\n+                }\n+                _ => {}\n+            }\n+\n             local_def(item.id)\n         }\n         csearch::found(ast::ii_foreign(item)) => {\n           ccx.external.insert(fn_id, Some(item.id));\n+          ccx.external_srcs.insert(item.id, fn_id);\n           local_def(item.id)\n         }\n         csearch::found_parent(parent_id, ast::ii_item(item)) => {\n           ccx.external.insert(parent_id, Some(item.id));\n+          ccx.external_srcs.insert(item.id, parent_id);\n           let mut my_id = 0;\n           match item.node {\n             ast::item_enum(_, _) => {\n@@ -86,6 +106,7 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n         csearch::found(ast::ii_method(impl_did, is_provided, mth)) => {\n           ccx.stats.n_inlines += 1;\n           ccx.external.insert(fn_id, Some(mth.id));\n+          ccx.external_srcs.insert(mth.id, fn_id);\n           // If this is a default method, we can't look up the\n           // impl type. But we aren't going to translate anyways, so don't.\n           if is_provided { return local_def(mth.id); }"}, {"sha": "f0df2b1e71edebff076623cce8d1208cb876325b", "filename": "src/test/auxiliary/xcrate_static_addresses.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/010702899197b3305126746adb4278d9da370808/src%2Ftest%2Fauxiliary%2Fxcrate_static_addresses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010702899197b3305126746adb4278d9da370808/src%2Ftest%2Fauxiliary%2Fxcrate_static_addresses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_static_addresses.rs?ref=010702899197b3305126746adb4278d9da370808", "patch": "@@ -10,12 +10,21 @@\n \n pub static global: int = 3;\n \n+static global0: int = 4;\n+pub static global2: &'static int = &global0;\n+\n pub fn verify_same(a: &'static int) {\n     let a = a as *int as uint;\n     let b = &global as *int as uint;\n     assert_eq!(a, b);\n }\n \n+pub fn verify_same2(a: &'static int) {\n+    let a = a as *int as uint;\n+    let b = global2 as *int as uint;\n+    assert_eq!(a, b);\n+}\n+\n condition!{ pub test: int -> (); }\n \n pub fn raise() {"}, {"sha": "7eb4adfd0675755a456d106406787d5a42389a52", "filename": "src/test/run-pass/xcrate-static-addresses.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/010702899197b3305126746adb4278d9da370808/src%2Ftest%2Frun-pass%2Fxcrate-static-addresses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010702899197b3305126746adb4278d9da370808/src%2Ftest%2Frun-pass%2Fxcrate-static-addresses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-static-addresses.rs?ref=010702899197b3305126746adb4278d9da370808", "patch": "@@ -17,6 +17,7 @@ use other = xcrate_static_addresses;\n \n pub fn main() {\n     other::verify_same(&other::global);\n+    other::verify_same2(other::global2);\n \n     // Previously this fail'd because there were two addresses that were being\n     // used when declaring constants."}]}