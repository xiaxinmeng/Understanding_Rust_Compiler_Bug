{"sha": "a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZmU0YTA4ZmI5YjZlNWRmNGY5YWExNDgxZmI2MmY2OTM4ODk3YWY=", "commit": {"author": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-01-30T20:36:49Z"}, "committer": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-01-30T22:01:01Z"}, "message": "Some improvements to introduce_variable.", "tree": {"sha": "cf3ff7b55f2d730124c7580bc18bf67ac4b5967f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf3ff7b55f2d730124c7580bc18bf67ac4b5967f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af", "html_url": "https://github.com/rust-lang/rust/commit/a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af/comments", "author": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a1494ced5d762cdebf590619fc3326c4a876a7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a1494ced5d762cdebf590619fc3326c4a876a7b", "html_url": "https://github.com/rust-lang/rust/commit/7a1494ced5d762cdebf590619fc3326c4a876a7b"}], "stats": {"total": 189, "additions": 181, "deletions": 8}, "files": [{"sha": "8905b041913ec2360318523ee476b780e7c3e10a", "filename": "crates/ra_ide_api_light/src/assists.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs?ref=a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af", "patch": "@@ -196,6 +196,14 @@ fn check_assist(assist: fn(AssistCtx) -> Option<Assist>, before: &str, after: &s\n     })\n }\n \n+#[cfg(test)]\n+fn check_assist_not_applicable(assist: fn(AssistCtx) -> Option<Assist>, text: &str) {\n+    crate::test_utils::check_action_not_applicable(text, |file, off| {\n+        let range = TextRange::offset_len(off, 0.into());\n+        AssistCtx::new(file, range).apply(assist)\n+    })\n+}\n+\n #[cfg(test)]\n fn check_assist_range(assist: fn(AssistCtx) -> Option<Assist>, before: &str, after: &str) {\n     crate::test_utils::check_action_range(before, after, |file, range| {"}, {"sha": "ed13bddc48eee1b3ea8eefa21326b4abdedd9ed7", "filename": "crates/ra_ide_api_light/src/assists/introduce_variable.rs", "status": "modified", "additions": 161, "deletions": 8, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af/crates%2Fra_ide_api_light%2Fsrc%2Fassists%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af/crates%2Fra_ide_api_light%2Fsrc%2Fassists%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fassists%2Fintroduce_variable.rs?ref=a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af", "patch": "@@ -1,15 +1,18 @@\n use ra_syntax::{\n     ast::{self, AstNode},\n-    SyntaxKind::WHITESPACE, SyntaxKind::MATCH_ARM, SyntaxKind::LAMBDA_EXPR,\n-    SyntaxNode, TextUnit,\n+    SyntaxKind::{\n+        WHITESPACE, MATCH_ARM, LAMBDA_EXPR, PATH_EXPR, BREAK_EXPR, LOOP_EXPR, RETURN_EXPR, COMMENT\n+    }, SyntaxNode, TextUnit,\n };\n \n use crate::assists::{AssistCtx, Assist};\n \n pub fn introduce_variable<'a>(ctx: AssistCtx) -> Option<Assist> {\n     let node = ctx.covering_node();\n-    let expr = node.ancestors().filter_map(ast::Expr::cast).next()?;\n-\n+    if !valid_covering_node(node) {\n+        return None;\n+    }\n+    let expr = node.ancestors().filter_map(valid_target_expr).next()?;\n     let (anchor_stmt, wrap_in_block) = anchor_stmt(expr)?;\n     let indent = anchor_stmt.prev_sibling()?;\n     if indent.kind() != WHITESPACE {\n@@ -51,6 +54,21 @@ pub fn introduce_variable<'a>(ctx: AssistCtx) -> Option<Assist> {\n     })\n }\n \n+fn valid_covering_node(node: &SyntaxNode) -> bool {\n+    node.kind() != COMMENT\n+}\n+/// Check wether the node is a valid expression which can be extracted to a variable.\n+/// In general that's true for any expression, but in some cases that would produce invalid code.\n+fn valid_target_expr(node: &SyntaxNode) -> Option<&ast::Expr> {\n+    return match node.kind() {\n+        PATH_EXPR => None,\n+        BREAK_EXPR => ast::BreakExpr::cast(node).and_then(|e| e.expr()),\n+        RETURN_EXPR => ast::ReturnExpr::cast(node).and_then(|e| e.expr()),\n+        LOOP_EXPR => ast::ReturnExpr::cast(node).and_then(|e| e.expr()),\n+        _ => ast::Expr::cast(node),\n+    };\n+}\n+\n /// Returns the syntax node which will follow the freshly introduced var\n /// and a boolean indicating whether we have to wrap it within a { } block\n /// to produce correct code.\n@@ -73,9 +91,7 @@ fn anchor_stmt(expr: &ast::Expr) -> Option<(&SyntaxNode, bool)> {\n         }\n \n         if let Some(parent) = node.parent() {\n-            if parent.kind() == MATCH_ARM\n-                || parent.kind() == LAMBDA_EXPR\n-            {\n+            if parent.kind() == MATCH_ARM || parent.kind() == LAMBDA_EXPR {\n                 return Some((node, true));\n             }\n         }\n@@ -87,7 +103,7 @@ fn anchor_stmt(expr: &ast::Expr) -> Option<(&SyntaxNode, bool)> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::assists::check_assist_range;\n+    use crate::assists::{ check_assist, check_assist_not_applicable, check_assist_range };\n \n     #[test]\n     fn test_introduce_var_simple() {\n@@ -272,6 +288,143 @@ fn main() {\n fn main() {\n     let lambda = |x: u32| { let <|>var_name = x * 2; var_name };\n }\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_path_simple() {\n+        check_assist(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let o = S<|>ome(true);\n+}\n+\",\n+            \"\n+fn main() {\n+    let <|>var_name = Some(true);\n+    let o = var_name;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_path_method() {\n+        check_assist(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let v = b<|>ar.foo();\n+}\n+\",\n+            \"\n+fn main() {\n+    let <|>var_name = bar.foo();\n+    let v = var_name;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_return() {\n+        check_assist(\n+            introduce_variable,\n+            \"\n+fn foo() -> u32 {\n+    r<|>eturn 2 + 2;\n+}\n+\",\n+            \"\n+fn foo() -> u32 {\n+    let <|>var_name = 2 + 2;\n+    return var_name;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_break() {\n+        check_assist(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let result = loop {\n+        b<|>reak 2 + 2;\n+    };\n+}\n+\",\n+            \"\n+fn main() {\n+    let result = loop {\n+        let <|>var_name = 2 + 2;\n+        break var_name;\n+    };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_for_cast() {\n+        check_assist(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let v = 0f32 a<|>s u32;\n+}\n+\",\n+            \"\n+fn main() {\n+    let <|>var_name = 0f32 as u32;\n+    let v = var_name;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_for_return_not_applicable() {\n+        check_assist_not_applicable(\n+            introduce_variable,\n+            \"\n+fn foo() {\n+    r<|>eturn;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_for_break_not_applicable() {\n+        check_assist_not_applicable(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    loop {\n+        b<|>reak;\n+    };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_in_comment_not_applicable() {\n+        check_assist_not_applicable(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        // c<|>omment\n+        true => (2 + 2, true)\n+        _ => (0, false)\n+    };\n+}\n \",\n         );\n     }"}, {"sha": "22ded243553b9a49bec97d4dbd260f4505a42313", "filename": "crates/ra_ide_api_light/src/test_utils.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af/crates%2Fra_ide_api_light%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af/crates%2Fra_ide_api_light%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Ftest_utils.rs?ref=a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af", "patch": "@@ -23,6 +23,18 @@ pub fn check_action<F: Fn(&SourceFile, TextUnit) -> Option<LocalEdit>>(\n     assert_eq_text!(after, &actual);\n }\n \n+pub fn check_action_not_applicable<F: Fn(&SourceFile, TextUnit) -> Option<LocalEdit>>(\n+    text: &str,\n+    f: F,\n+) {\n+    let (text_cursor_pos, text) = extract_offset(text);\n+    let file = SourceFile::parse(&text);\n+    assert!(\n+        f(&file, text_cursor_pos).is_none(),\n+        \"code action is applicable but it shouldn't\"\n+    );\n+}\n+\n pub fn check_action_range<F: Fn(&SourceFile, TextRange) -> Option<LocalEdit>>(\n     before: &str,\n     after: &str,"}]}