{"sha": "aa223304dc130c5ace18d48c53b192b14088862e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMjIzMzA0ZGMxMzBjNWFjZTE4ZDQ4YzUzYjE5MmIxNDA4ODg2MmU=", "commit": {"author": {"name": "Stefan Lankes", "email": "stlankes@users.noreply.github.com", "date": "2020-04-04T05:41:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-04T05:41:05Z"}, "message": "Merge branch 'master' into abi", "tree": {"sha": "1971ea5717f0e2ef2dc9468b3a0e96c209d481fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1971ea5717f0e2ef2dc9468b3a0e96c209d481fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa223304dc130c5ace18d48c53b192b14088862e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeiB3xCRBK7hj4Ov3rIwAAdHIIAD7YDEI4c1hQ6w28DCQL1uhV\nq4W6ZElAu8jObTiSNUn8X78Y73VWXmbfR2XXVooUoOevtQo0h2wTB99r2HDpaz7a\nYBV3JiOYCh1d1xN20ZBhE/x93HNizdCzQcAYbgb9/QEh+k+8UApBqZ0Ac0NXqnYq\nwUWE9F1dCgDxZ26lmkLRxYyrOorDCbVLO6rgLK+Lu4E99+n0gFXrgHIPKyVZakEI\ndOoprRQSRAouX7zz+SaoR0wABslEofIKBFG7GcjFOH6oFyCSNdmyJJWxOM33WXAA\nrXQn9bo0oLElNTwZZNEWv4PTPkDKGYnDDDVqEL9Ag1a2evEAyOx6Fv4ldg7U/9s=\n=uZjM\n-----END PGP SIGNATURE-----\n", "payload": "tree 1971ea5717f0e2ef2dc9468b3a0e96c209d481fe\nparent 9f6b96e461003853bf36052cfaf79b12e1c35413\nparent 9e55101bb681010c82c3c827305e2665fc8f2aa0\nauthor Stefan Lankes <stlankes@users.noreply.github.com> 1585978865 +0200\ncommitter GitHub <noreply@github.com> 1585978865 +0200\n\nMerge branch 'master' into abi"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa223304dc130c5ace18d48c53b192b14088862e", "html_url": "https://github.com/rust-lang/rust/commit/aa223304dc130c5ace18d48c53b192b14088862e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa223304dc130c5ace18d48c53b192b14088862e/comments", "author": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f6b96e461003853bf36052cfaf79b12e1c35413", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f6b96e461003853bf36052cfaf79b12e1c35413", "html_url": "https://github.com/rust-lang/rust/commit/9f6b96e461003853bf36052cfaf79b12e1c35413"}, {"sha": "9e55101bb681010c82c3c827305e2665fc8f2aa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e55101bb681010c82c3c827305e2665fc8f2aa0", "html_url": "https://github.com/rust-lang/rust/commit/9e55101bb681010c82c3c827305e2665fc8f2aa0"}], "stats": {"total": 21532, "additions": 11512, "deletions": 10020}, "files": [{"sha": "03bc4bab45137c76d85bdd644f76d8640a614ab3", "filename": ".github/ISSUE_TEMPLATE/ice.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -14,7 +14,7 @@ http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n \n ### Code\n \n-```\n+```Rust\n <code>\n ```\n "}, {"sha": "fd3da15a21bbb543ce04e3db5c686f16299d806b", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -63,7 +63,7 @@ jobs:\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:\n           github_token: \"${{ secrets.github_token }}\"\n-        if: success() && !env.SKIP_JOB\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: add extra environment variables\n         run: src/ci/scripts/setup-environment.sh\n         env:\n@@ -196,7 +196,7 @@ jobs:\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:\n           github_token: \"${{ secrets.github_token }}\"\n-        if: success() && !env.SKIP_JOB\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: add extra environment variables\n         run: src/ci/scripts/setup-environment.sh\n         env:\n@@ -626,7 +626,7 @@ jobs:\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:\n           github_token: \"${{ secrets.github_token }}\"\n-        if: success() && !env.SKIP_JOB\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: add extra environment variables\n         run: src/ci/scripts/setup-environment.sh\n         env:"}, {"sha": "5b07f4b549202187d24a127cf00c68394fa14980", "filename": "Cargo.lock", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2522,9 +2522,9 @@ checksum = \"05da548ad6865900e60eaba7f589cc0783590a92e940c26953ff81ddbab2d677\"\n \n [[package]]\n name = \"polonius-engine\"\n-version = \"0.12.0\"\n+version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"04d8ef65e3f89ecaec9ca7cb0e0911b4617352d4494018bcf934992f03f2024c\"\n+checksum = \"ef2558a4b464e185b36ee08a2937ebb62ea5464c38856cfb1465c97cb38db52d\"\n dependencies = [\n  \"datafrog\",\n  \"log\",\n@@ -3132,39 +3132,6 @@ dependencies = [\n  \"rustc-workspace-hack\",\n ]\n \n-[[package]]\n-name = \"rustc\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"arena\",\n- \"backtrace\",\n- \"bitflags\",\n- \"byteorder\",\n- \"jobserver\",\n- \"log\",\n- \"measureme\",\n- \"parking_lot 0.10.0\",\n- \"polonius-engine\",\n- \"rustc-rayon\",\n- \"rustc-rayon-core\",\n- \"rustc_apfloat\",\n- \"rustc_ast\",\n- \"rustc_attr\",\n- \"rustc_data_structures\",\n- \"rustc_errors\",\n- \"rustc_feature\",\n- \"rustc_hir\",\n- \"rustc_index\",\n- \"rustc_macros\",\n- \"rustc_query_system\",\n- \"rustc_session\",\n- \"rustc_span\",\n- \"rustc_target\",\n- \"scoped-tls\",\n- \"serialize\",\n- \"smallvec 1.0.0\",\n-]\n-\n [[package]]\n name = \"rustc-ap-arena\"\n version = \"642.0.0\"\n@@ -3603,7 +3570,6 @@ dependencies = [\n  \"libc\",\n  \"log\",\n  \"measureme\",\n- \"rustc\",\n  \"rustc-demangle\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3616,6 +3582,7 @@ dependencies = [\n  \"rustc_incremental\",\n  \"rustc_index\",\n  \"rustc_llvm\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3634,7 +3601,6 @@ dependencies = [\n  \"log\",\n  \"memmap\",\n  \"num_cpus\",\n- \"rustc\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3645,6 +3611,7 @@ dependencies = [\n  \"rustc_incremental\",\n  \"rustc_index\",\n  \"rustc_metadata\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n@@ -3685,7 +3652,6 @@ dependencies = [\n  \"env_logger 0.7.1\",\n  \"lazy_static 1.4.0\",\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_codegen_ssa\",\n@@ -3698,6 +3664,7 @@ dependencies = [\n  \"rustc_interface\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n+ \"rustc_middle\",\n  \"rustc_mir\",\n  \"rustc_parse\",\n  \"rustc_plugin_impl\",\n@@ -3797,11 +3764,11 @@ dependencies = [\n  \"graphviz\",\n  \"log\",\n  \"rand 0.7.3\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n  \"rustc_hir\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"serialize\",\n@@ -3821,13 +3788,13 @@ version = \"0.0.0\"\n dependencies = [\n  \"graphviz\",\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3840,7 +3807,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"log\",\n  \"once_cell\",\n- \"rustc\",\n  \"rustc-rayon\",\n  \"rustc_ast\",\n  \"rustc_ast_lowering\",\n@@ -3857,6 +3823,7 @@ dependencies = [\n  \"rustc_infer\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n+ \"rustc_middle\",\n  \"rustc_mir\",\n  \"rustc_mir_build\",\n  \"rustc_parse\",\n@@ -3890,7 +3857,6 @@ name = \"rustc_lint\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_attr\",\n@@ -3900,6 +3866,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3933,7 +3900,6 @@ dependencies = [\n  \"flate2\",\n  \"log\",\n  \"memmap\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -3942,6 +3908,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n  \"rustc_index\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3951,6 +3918,39 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"rustc_middle\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena\",\n+ \"backtrace\",\n+ \"bitflags\",\n+ \"byteorder\",\n+ \"jobserver\",\n+ \"log\",\n+ \"measureme\",\n+ \"parking_lot 0.10.0\",\n+ \"polonius-engine\",\n+ \"rustc-rayon\",\n+ \"rustc-rayon-core\",\n+ \"rustc_apfloat\",\n+ \"rustc_ast\",\n+ \"rustc_attr\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_feature\",\n+ \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n+ \"rustc_query_system\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"scoped-tls\",\n+ \"serialize\",\n+ \"smallvec 1.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_mir\"\n version = \"0.0.0\"\n@@ -3961,7 +3961,6 @@ dependencies = [\n  \"log\",\n  \"log_settings\",\n  \"polonius-engine\",\n- \"rustc\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n@@ -3973,6 +3972,7 @@ dependencies = [\n  \"rustc_infer\",\n  \"rustc_lexer\",\n  \"rustc_macros\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3987,7 +3987,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena\",\n  \"log\",\n- \"rustc\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3997,6 +3996,7 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_macros\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4028,7 +4028,6 @@ name = \"rustc_passes\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -4037,6 +4036,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4047,12 +4047,12 @@ dependencies = [\n name = \"rustc_plugin_impl\"\n version = \"0.0.0\"\n dependencies = [\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n ]\n@@ -4062,12 +4062,12 @@ name = \"rustc_privacy\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_typeck\",\n@@ -4096,7 +4096,6 @@ dependencies = [\n  \"arena\",\n  \"bitflags\",\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_ast_lowering\",\n  \"rustc_ast_pretty\",\n@@ -4107,6 +4106,7 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_metadata\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"smallvec 1.0.0\",\n@@ -4119,12 +4119,12 @@ dependencies = [\n  \"log\",\n  \"rls-data\",\n  \"rls-span\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n+ \"rustc_middle\",\n  \"rustc_parse\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4169,12 +4169,12 @@ version = \"0.0.0\"\n dependencies = [\n  \"log\",\n  \"punycode\",\n- \"rustc\",\n  \"rustc-demangle\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n  \"rustc_metadata\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4209,7 +4209,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"fmt_macros\",\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -4218,6 +4217,7 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_macros\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4229,12 +4229,12 @@ name = \"rustc_traits\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n  \"rustc_infer\",\n  \"rustc_macros\",\n+ \"rustc_middle\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n@@ -4246,10 +4246,10 @@ name = \"rustc_ty\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n- \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n  \"rustc_infer\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4262,14 +4262,14 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena\",\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\","}, {"sha": "6f184e252182a80dc25e7ed953df8542488e4bac", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -256,7 +256,7 @@ Also, you may find the [rustdocs for the compiler itself][rustdocs] useful.\n \n [rust-discord]: https://discord.gg/rust-lang\n [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/about-this-guide.html\n-[rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/\n+[rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/\n \n ## License\n "}, {"sha": "b14352d7f4ba0ddd25e4232d3e32f7aa2d3f1f51", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1022,8 +1022,13 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_HOST_CRT_STATIC\", x.to_string());\n         }\n \n-        if let Some(map) = self.build.debuginfo_map(GitRepo::Rustc) {\n+        if let Some(map_to) = self.build.debuginfo_map_to(GitRepo::Rustc) {\n+            let map = format!(\"{}={}\", self.build.src.display(), map_to);\n             cargo.env(\"RUSTC_DEBUGINFO_MAP\", map);\n+\n+            // `rustc` needs to know the virtual `/rustc/$hash` we're mapping to,\n+            // in order to opportunistically reverse it later.\n+            cargo.env(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\", map_to);\n         }\n \n         // Enable usage of unstable features"}, {"sha": "32ce170a5a1fe173d751eeb10cd5196d34b0f71f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -22,7 +22,7 @@ use serde::Deserialize;\n use crate::builder::Cargo;\n use crate::dist;\n use crate::native;\n-use crate::util::{exe, is_dylib};\n+use crate::util::{exe, is_dylib, symlink_dir};\n use crate::{Compiler, GitRepo, Mode};\n \n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n@@ -633,6 +633,30 @@ impl Step for Sysroot {\n         };\n         let _ = fs::remove_dir_all(&sysroot);\n         t!(fs::create_dir_all(&sysroot));\n+\n+        // Symlink the source root into the same location inside the sysroot,\n+        // where `rust-src` component would go (`$sysroot/lib/rustlib/src/rust`),\n+        // so that any tools relying on `rust-src` also work for local builds,\n+        // and also for translating the virtual `/rustc/$hash` back to the real\n+        // directory (for running tests with `rust.remap-debuginfo = true`).\n+        let sysroot_lib_rustlib_src = sysroot.join(\"lib/rustlib/src\");\n+        t!(fs::create_dir_all(&sysroot_lib_rustlib_src));\n+        let sysroot_lib_rustlib_src_rust = sysroot_lib_rustlib_src.join(\"rust\");\n+        if let Err(e) = symlink_dir(&builder.config, &builder.src, &sysroot_lib_rustlib_src_rust) {\n+            eprintln!(\n+                \"warning: creating symbolic link `{}` to `{}` failed with {}\",\n+                sysroot_lib_rustlib_src_rust.display(),\n+                builder.src.display(),\n+                e,\n+            );\n+            if builder.config.rust_remap_debuginfo {\n+                eprintln!(\n+                    \"warning: some `src/test/ui` tests will fail when lacking `{}`\",\n+                    sysroot_lib_rustlib_src_rust.display(),\n+                );\n+            }\n+        }\n+\n         INTERNER.intern_path(sysroot)\n     }\n }\n@@ -911,7 +935,11 @@ pub fn stream_cargo(\n     }\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n-    let mut message_format = String::from(\"json-render-diagnostics\");\n+    let mut message_format = if builder.config.json_output {\n+        String::from(\"json\")\n+    } else {\n+        String::from(\"json-render-diagnostics\")\n+    };\n     if let Some(s) = &builder.config.rustc_error_format {\n         message_format.push_str(\",json-diagnostic-\");\n         message_format.push_str(s);"}, {"sha": "133709421a5cdeaa5291887ab0e3f5175eb5dca1", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -48,6 +48,7 @@ pub struct Config {\n     pub ignore_git: bool,\n     pub exclude: Vec<PathBuf>,\n     pub rustc_error_format: Option<String>,\n+    pub json_output: bool,\n     pub test_compare_mode: bool,\n     pub llvm_libunwind: bool,\n \n@@ -415,6 +416,7 @@ impl Config {\n         let mut config = Config::default_opts();\n         config.exclude = flags.exclude;\n         config.rustc_error_format = flags.rustc_error_format;\n+        config.json_output = flags.json_output;\n         config.on_fail = flags.on_fail;\n         config.stage = flags.stage;\n         config.jobs = flags.jobs.map(threads_from_config);"}, {"sha": "5d6e401d5b3fb0b46ef6369acc92eaa5526499b5", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -31,6 +31,7 @@ pub struct Flags {\n     pub incremental: bool,\n     pub exclude: Vec<PathBuf>,\n     pub rustc_error_format: Option<String>,\n+    pub json_output: bool,\n     pub dry_run: bool,\n \n     // This overrides the deny-warnings configuration option,\n@@ -156,6 +157,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             \"VALUE\",\n         );\n         opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n+        opts.optflag(\"\", \"json-output\", \"use message-format=json\");\n         opts.optopt(\n             \"\",\n             \"llvm-skip-rebuild\",\n@@ -503,6 +505,7 @@ Arguments:\n             dry_run: matches.opt_present(\"dry-run\"),\n             on_fail: matches.opt_str(\"on-fail\"),\n             rustc_error_format: matches.opt_str(\"error-format\"),\n+            json_output: matches.opt_present(\"json-output\"),\n             keep_stage: matches\n                 .opt_strs(\"keep-stage\")\n                 .into_iter()"}, {"sha": "31bbd92cd620511e5bc06819f791856be534f416", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -740,19 +740,18 @@ impl Build {\n         self.config.jobs.unwrap_or_else(|| num_cpus::get() as u32)\n     }\n \n-    fn debuginfo_map(&self, which: GitRepo) -> Option<String> {\n+    fn debuginfo_map_to(&self, which: GitRepo) -> Option<String> {\n         if !self.config.rust_remap_debuginfo {\n             return None;\n         }\n \n-        let path = match which {\n+        match which {\n             GitRepo::Rustc => {\n                 let sha = self.rust_sha().unwrap_or(channel::CFG_RELEASE_NUM);\n-                format!(\"/rustc/{}\", sha)\n+                Some(format!(\"/rustc/{}\", sha))\n             }\n-            GitRepo::Llvm => String::from(\"/rustc/llvm\"),\n-        };\n-        Some(format!(\"{}={}\", self.src.display(), path))\n+            GitRepo::Llvm => Some(String::from(\"/rustc/llvm\")),\n+        }\n     }\n \n     /// Returns the path to the C compiler for the target specified.\n@@ -787,7 +786,8 @@ impl Build {\n             base.push(\"-fno-omit-frame-pointer\".into());\n         }\n \n-        if let Some(map) = self.debuginfo_map(which) {\n+        if let Some(map_to) = self.debuginfo_map_to(which) {\n+            let map = format!(\"{}={}\", self.src.display(), map_to);\n             let cc = self.cc(target);\n             if cc.ends_with(\"clang\") || cc.ends_with(\"gcc\") {\n                 base.push(format!(\"-fdebug-prefix-map={}\", map));"}, {"sha": "2499856235f100b6b03a9bed6fcf2f8624d87eac", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -21,7 +21,7 @@ use crate::flags::Subcommand;\n use crate::native;\n use crate::tool::{self, SourceType, Tool};\n use crate::toolstate::ToolState;\n-use crate::util::{self, dylib_path, dylib_path_var};\n+use crate::util::{self, add_link_lib_path, dylib_path, dylib_path_var};\n use crate::Crate as CargoCrate;\n use crate::{envify, DocTests, GitRepo, Mode};\n \n@@ -1178,6 +1178,15 @@ impl Step for Compiletest {\n                 cmd.arg(\"--system-llvm\");\n             }\n \n+            // Tests that use compiler libraries may inherit the `-lLLVM` link\n+            // requirement, but the `-L` library path is not propagated across\n+            // separate compilations. We can add LLVM's library path to the\n+            // platform-specific environment variable as a workaround.\n+            if !builder.config.dry_run && suite.ends_with(\"fulldeps\") {\n+                let llvm_libdir = output(Command::new(&llvm_config).arg(\"--libdir\"));\n+                add_link_lib_path(vec![llvm_libdir.trim().into()], &mut cmd);\n+            }\n+\n             // Only pass correct values for these flags for the `run-make` suite as it\n             // requires that a C++ compiler was configured which isn't always the case.\n             if !builder.config.dry_run && suite == \"run-make-fulldeps\" {"}, {"sha": "95936d65432fabfaaed0d3a050977db75ea10cbf", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -138,33 +138,31 @@ $category > $option = $value -- $comment\n For targets: `arm-unknown-linux-gnueabi`\n \n - Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n-- Path and misc options > Patches origin = Bundled, then local\n-- Path and misc options > Local patch directory = /tmp/patches\n+- Path and misc options > Patches origin = Bundled only\n - Target options > Target Architecture = arm\n - Target options > Architecture level = armv6 -- (+)\n - Target options > Floating point = software (no FPU) -- (\\*)\n - Operating System > Target OS = linux\n-- Operating System > Linux kernel version = 3.2.72 -- Precise kernel\n-- C-library > glibc version = 2.16.0\n-- C compiler > gcc version = 5.2.0\n+- Operating System > Linux kernel version = 3.2.101\n+- C-library > glibc version = 2.17.0\n+- C compiler > gcc version = 8.3.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n ### `arm-linux-gnueabihf.config`\n \n For targets: `arm-unknown-linux-gnueabihf`\n \n - Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n-- Path and misc options > Patches origin = Bundled, then local\n-- Path and misc options > Local patch directory = /tmp/patches\n+- Path and misc options > Patches origin = Bundled only\n - Target options > Target Architecture = arm\n - Target options > Architecture level = armv6 -- (+)\n - Target options > Use specific FPU = vfp -- (+)\n - Target options > Floating point = hardware (FPU) -- (\\*)\n - Target options > Default instruction set mode = arm -- (+)\n - Operating System > Target OS = linux\n-- Operating System > Linux kernel version = 3.2.72 -- Precise kernel\n-- C-library > glibc version = 2.16.0\n-- C compiler > gcc version = 5.2.0\n+- Operating System > Linux kernel version = 3.2.101\n+- C-library > glibc version = 2.17.0\n+- C compiler > gcc version = 8.3.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n ### `armv7-linux-gnueabihf.config`"}, {"sha": "50f7ca74e545a69254dfc40a44ce5be283f240e5", "filename": "src/ci/docker/dist-arm-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -3,20 +3,14 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n+COPY scripts/crosstool-ng-1.24.sh /scripts/\n+RUN sh /scripts/crosstool-ng-1.24.sh\n \n COPY scripts/rustbuild-setup.sh /scripts/\n RUN sh /scripts/rustbuild-setup.sh\n USER rustbuild\n WORKDIR /tmp\n \n-COPY dist-arm-linux/patches/ /tmp/patches/\n COPY dist-arm-linux/arm-linux-gnueabi.config dist-arm-linux/build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n "}, {"sha": "1dcdbd1a9008be2eb76c7f5f8c781e8e234e953c", "filename": "src/ci/docker/dist-arm-linux/arm-linux-gnueabi.config", "status": "modified", "additions": 510, "deletions": 309, "changes": 819, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-arm-linux%2Farm-linux-gnueabi.config", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-arm-linux%2Farm-linux-gnueabi.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2Farm-linux-gnueabi.config?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,9 +1,29 @@\n #\n # Automatically generated file; DO NOT EDIT.\n-# Crosstool-NG Configuration\n-#\n-CT_CONFIGURE_has_make381=y\n-CT_CONFIGURE_has_xz=y\n+# crosstool-NG  Configuration\n+#\n+CT_CONFIGURE_has_static_link=y\n+CT_CONFIGURE_has_cxx11=y\n+CT_CONFIGURE_has_wget=y\n+CT_CONFIGURE_has_curl=y\n+CT_CONFIGURE_has_make_3_81_or_newer=y\n+CT_CONFIGURE_has_make_4_0_or_newer=y\n+CT_CONFIGURE_has_libtool_2_4_or_newer=y\n+CT_CONFIGURE_has_libtoolize_2_4_or_newer=y\n+CT_CONFIGURE_has_autoconf_2_65_or_newer=y\n+CT_CONFIGURE_has_autoreconf_2_65_or_newer=y\n+CT_CONFIGURE_has_automake_1_15_or_newer=y\n+CT_CONFIGURE_has_gnu_m4_1_4_12_or_newer=y\n+CT_CONFIGURE_has_bison_2_7_or_newer=y\n+CT_CONFIGURE_has_python=y\n+CT_CONFIGURE_has_git=y\n+CT_CONFIGURE_has_md5sum=y\n+CT_CONFIGURE_has_sha1sum=y\n+CT_CONFIGURE_has_sha256sum=y\n+CT_CONFIGURE_has_sha512sum=y\n+CT_CONFIGURE_has_install_with_strip_program=y\n+CT_CONFIG_VERSION_CURRENT=\"3\"\n+CT_CONFIG_VERSION=\"3\"\n CT_MODULES=y\n \n #\n@@ -20,41 +40,48 @@ CT_MODULES=y\n #\n # Paths\n #\n-CT_LOCAL_TARBALLS_DIR=\"\"\n+CT_LOCAL_TARBALLS_DIR=\"${HOME}/src\"\n+CT_SAVE_TARBALLS=y\n+# CT_TARBALLS_BUILDROOT_LAYOUT is not set\n CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_BUILD_TOP_DIR=\"${CT_WORK_DIR:-${CT_TOP_DIR}/.build}/${CT_HOST:+HOST-${CT_HOST}/}${CT_TARGET}\"\n CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n-CT_INSTALL_DIR=\"${CT_PREFIX_DIR}\"\n CT_RM_RF_PREFIX_DIR=y\n CT_REMOVE_DOCS=y\n-CT_INSTALL_DIR_RO=y\n+CT_INSTALL_LICENSES=y\n+CT_PREFIX_DIR_RO=y\n CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n # CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n \n #\n # Downloading\n #\n+CT_DOWNLOAD_AGENT_WGET=y\n+# CT_DOWNLOAD_AGENT_CURL is not set\n+# CT_DOWNLOAD_AGENT_NONE is not set\n # CT_FORBID_DOWNLOAD is not set\n # CT_FORCE_DOWNLOAD is not set\n CT_CONNECT_TIMEOUT=10\n+CT_DOWNLOAD_WGET_OPTIONS=\"--passive-ftp --tries=3 -nc --progress=dot:binary\"\n # CT_ONLY_DOWNLOAD is not set\n # CT_USE_MIRROR is not set\n+CT_VERIFY_DOWNLOAD_DIGEST=y\n+CT_VERIFY_DOWNLOAD_DIGEST_SHA512=y\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA256 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA1 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_MD5 is not set\n+CT_VERIFY_DOWNLOAD_DIGEST_ALG=\"sha512\"\n+# CT_VERIFY_DOWNLOAD_SIGNATURE is not set\n \n #\n # Extracting\n #\n # CT_FORCE_EXTRACT is not set\n-CT_OVERIDE_CONFIG_GUESS_SUB=y\n+CT_OVERRIDE_CONFIG_GUESS_SUB=y\n # CT_ONLY_EXTRACT is not set\n-# CT_PATCH_BUNDLED is not set\n-# CT_PATCH_LOCAL is not set\n-CT_PATCH_BUNDLED_LOCAL=y\n-# CT_PATCH_LOCAL_BUNDLED is not set\n-# CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n-# CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n-# CT_PATCH_NONE is not set\n-CT_PATCH_ORDER=\"bundled,local\"\n-CT_PATCH_USE_LOCAL=y\n-CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n+CT_PATCH_BUNDLED=y\n+# CT_PATCH_BUNDLED_LOCAL is not set\n+CT_PATCH_ORDER=\"bundled\"\n \n #\n # Build behavior\n@@ -77,11 +104,11 @@ CT_CONFIG_SHELL=\"${bash}\"\n #\n # CT_LOG_ERROR is not set\n # CT_LOG_WARN is not set\n-CT_LOG_INFO=y\n-# CT_LOG_EXTRA is not set\n+# CT_LOG_INFO is not set\n+CT_LOG_EXTRA=y\n # CT_LOG_ALL is not set\n # CT_LOG_DEBUG is not set\n-CT_LOG_LEVEL_MAX=\"INFO\"\n+CT_LOG_LEVEL_MAX=\"EXTRA\"\n # CT_LOG_SEE_TOOLS_WARN is not set\n CT_LOG_PROGRESS_BAR=y\n CT_LOG_TO_FILE=y\n@@ -90,85 +117,86 @@ CT_LOG_FILE_COMPRESS=y\n #\n # Target options\n #\n+# CT_ARCH_ALPHA is not set\n+# CT_ARCH_ARC is not set\n+CT_ARCH_ARM=y\n+# CT_ARCH_AVR is not set\n+# CT_ARCH_M68K is not set\n+# CT_ARCH_MIPS is not set\n+# CT_ARCH_NIOS2 is not set\n+# CT_ARCH_POWERPC is not set\n+# CT_ARCH_S390 is not set\n+# CT_ARCH_SH is not set\n+# CT_ARCH_SPARC is not set\n+# CT_ARCH_X86 is not set\n+# CT_ARCH_XTENSA is not set\n CT_ARCH=\"arm\"\n-CT_ARCH_SUPPORTS_BOTH_MMU=y\n-CT_ARCH_SUPPORTS_BOTH_ENDIAN=y\n-CT_ARCH_SUPPORTS_32=y\n-CT_ARCH_SUPPORTS_64=y\n-CT_ARCH_SUPPORTS_WITH_ARCH=y\n-CT_ARCH_SUPPORTS_WITH_CPU=y\n-CT_ARCH_SUPPORTS_WITH_TUNE=y\n-CT_ARCH_SUPPORTS_WITH_FLOAT=y\n-CT_ARCH_SUPPORTS_WITH_FPU=y\n-CT_ARCH_SUPPORTS_SOFTFP=y\n-CT_ARCH_DEFAULT_HAS_MMU=y\n-CT_ARCH_DEFAULT_LE=y\n-CT_ARCH_DEFAULT_32=y\n-CT_ARCH_ARCH=\"armv6\"\n+CT_ARCH_CHOICE_KSYM=\"ARM\"\n+# CT_ARCH_ALPHA_EV4 is not set\n+# CT_ARCH_ALPHA_EV45 is not set\n+# CT_ARCH_ALPHA_EV5 is not set\n+# CT_ARCH_ALPHA_EV56 is not set\n+# CT_ARCH_ALPHA_EV6 is not set\n+# CT_ARCH_ALPHA_EV67 is not set\n CT_ARCH_CPU=\"\"\n CT_ARCH_TUNE=\"\"\n-CT_ARCH_FPU=\"\"\n-# CT_ARCH_BE is not set\n-CT_ARCH_LE=y\n-CT_ARCH_32=y\n-# CT_ARCH_64 is not set\n-CT_ARCH_BITNESS=32\n-# CT_ARCH_FLOAT_HW is not set\n-CT_ARCH_FLOAT_SW=y\n-CT_TARGET_CFLAGS=\"\"\n-CT_TARGET_LDFLAGS=\"\"\n-# CT_ARCH_alpha is not set\n-CT_ARCH_arm=y\n-# CT_ARCH_avr is not set\n-# CT_ARCH_m68k is not set\n-# CT_ARCH_mips is not set\n-# CT_ARCH_nios2 is not set\n-# CT_ARCH_powerpc is not set\n-# CT_ARCH_s390 is not set\n-# CT_ARCH_sh is not set\n-# CT_ARCH_sparc is not set\n-# CT_ARCH_x86 is not set\n-# CT_ARCH_xtensa is not set\n-CT_ARCH_alpha_AVAILABLE=y\n-CT_ARCH_arm_AVAILABLE=y\n-CT_ARCH_avr_AVAILABLE=y\n-CT_ARCH_m68k_AVAILABLE=y\n-CT_ARCH_microblaze_AVAILABLE=y\n-CT_ARCH_mips_AVAILABLE=y\n-CT_ARCH_nios2_AVAILABLE=y\n-CT_ARCH_powerpc_AVAILABLE=y\n-CT_ARCH_s390_AVAILABLE=y\n-CT_ARCH_sh_AVAILABLE=y\n-CT_ARCH_sparc_AVAILABLE=y\n-CT_ARCH_x86_AVAILABLE=y\n-CT_ARCH_xtensa_AVAILABLE=y\n+CT_ARCH_ARM_SHOW=y\n+\n+#\n+# Options for arm\n+#\n+CT_ARCH_ARM_PKG_KSYM=\"\"\n+CT_ARCH_ARM_MODE=\"arm\"\n+CT_ARCH_ARM_MODE_ARM=y\n+# CT_ARCH_ARM_MODE_THUMB is not set\n+# CT_ARCH_ARM_INTERWORKING is not set\n+CT_ARCH_ARM_EABI_FORCE=y\n+CT_ARCH_ARM_EABI=y\n+CT_ALL_ARCH_CHOICES=\"ALPHA ARC ARM AVR M68K MICROBLAZE MIPS MOXIE MSP430 NIOS2 POWERPC RISCV S390 SH SPARC X86 XTENSA\"\n CT_ARCH_SUFFIX=\"\"\n+# CT_OMIT_TARGET_VENDOR is not set\n \n #\n # Generic target options\n #\n # CT_MULTILIB is not set\n+CT_DEMULTILIB=y\n+CT_ARCH_SUPPORTS_BOTH_MMU=y\n+CT_ARCH_DEFAULT_HAS_MMU=y\n CT_ARCH_USE_MMU=y\n+CT_ARCH_SUPPORTS_FLAT_FORMAT=y\n+CT_ARCH_SUPPORTS_EITHER_ENDIAN=y\n+CT_ARCH_DEFAULT_LE=y\n+# CT_ARCH_BE is not set\n+CT_ARCH_LE=y\n CT_ARCH_ENDIAN=\"little\"\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_BITNESS=32\n+CT_ARCH_32=y\n+# CT_ARCH_64 is not set\n \n #\n # Target optimisations\n #\n+CT_ARCH_SUPPORTS_WITH_ARCH=y\n+CT_ARCH_SUPPORTS_WITH_CPU=y\n+CT_ARCH_SUPPORTS_WITH_TUNE=y\n+CT_ARCH_SUPPORTS_WITH_FLOAT=y\n+CT_ARCH_SUPPORTS_WITH_FPU=y\n+CT_ARCH_SUPPORTS_SOFTFP=y\n CT_ARCH_EXCLUSIVE_WITH_CPU=y\n+CT_ARCH_ARCH=\"armv6\"\n+CT_ARCH_FPU=\"\"\n # CT_ARCH_FLOAT_AUTO is not set\n+# CT_ARCH_FLOAT_HW is not set\n # CT_ARCH_FLOAT_SOFTFP is not set\n+CT_ARCH_FLOAT_SW=y\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n CT_ARCH_FLOAT=\"soft\"\n \n-#\n-# arm other options\n-#\n-CT_ARCH_ARM_MODE=\"arm\"\n-CT_ARCH_ARM_MODE_ARM=y\n-# CT_ARCH_ARM_MODE_THUMB is not set\n-# CT_ARCH_ARM_INTERWORKING is not set\n-CT_ARCH_ARM_EABI_FORCE=y\n-CT_ARCH_ARM_EABI=y\n-\n #\n # Toolchain options\n #\n@@ -181,7 +209,9 @@ CT_USE_SYSROOT=y\n CT_SYSROOT_NAME=\"sysroot\"\n CT_SYSROOT_DIR_PREFIX=\"\"\n CT_WANTS_STATIC_LINK=y\n+CT_WANTS_STATIC_LINK_CXX=y\n # CT_STATIC_TOOLCHAIN is not set\n+CT_SHOW_CT_VERSION=y\n CT_TOOLCHAIN_PKGVERSION=\"\"\n CT_TOOLCHAIN_BUGURL=\"\"\n \n@@ -215,227 +245,287 @@ CT_BUILD_SUFFIX=\"\"\n # Operating System\n #\n CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+# CT_KERNEL_BARE_METAL is not set\n+CT_KERNEL_LINUX=y\n CT_KERNEL=\"linux\"\n-CT_KERNEL_VERSION=\"3.2.72\"\n-# CT_KERNEL_bare_metal is not set\n-CT_KERNEL_linux=y\n-CT_KERNEL_bare_metal_AVAILABLE=y\n-CT_KERNEL_linux_AVAILABLE=y\n-# CT_KERNEL_V_4_3 is not set\n-# CT_KERNEL_V_4_2 is not set\n-# CT_KERNEL_V_4_1 is not set\n-# CT_KERNEL_V_3_18 is not set\n-# CT_KERNEL_V_3_14 is not set\n-# CT_KERNEL_V_3_12 is not set\n-# CT_KERNEL_V_3_10 is not set\n-# CT_KERNEL_V_3_4 is not set\n-CT_KERNEL_V_3_2=y\n-# CT_KERNEL_V_2_6_32 is not set\n-# CT_KERNEL_LINUX_CUSTOM is not set\n-CT_KERNEL_windows_AVAILABLE=y\n-\n-#\n-# Common kernel options\n-#\n-CT_SHARED_LIBS=y\n-\n-#\n-# linux other options\n-#\n+CT_KERNEL_CHOICE_KSYM=\"LINUX\"\n+CT_KERNEL_LINUX_SHOW=y\n+\n+#\n+# Options for linux\n+#\n+CT_KERNEL_LINUX_PKG_KSYM=\"LINUX\"\n+CT_LINUX_DIR_NAME=\"linux\"\n+CT_LINUX_PKG_NAME=\"linux\"\n+CT_LINUX_SRC_RELEASE=y\n+CT_LINUX_PATCH_ORDER=\"global\"\n+# CT_LINUX_V_4_20 is not set\n+# CT_LINUX_V_4_19 is not set\n+# CT_LINUX_V_4_18 is not set\n+# CT_LINUX_V_4_17 is not set\n+# CT_LINUX_V_4_16 is not set\n+# CT_LINUX_V_4_15 is not set\n+# CT_LINUX_V_4_14 is not set\n+# CT_LINUX_V_4_13 is not set\n+# CT_LINUX_V_4_12 is not set\n+# CT_LINUX_V_4_11 is not set\n+# CT_LINUX_V_4_10 is not set\n+# CT_LINUX_V_4_9 is not set\n+# CT_LINUX_V_4_4 is not set\n+# CT_LINUX_V_4_1 is not set\n+# CT_LINUX_V_3_16 is not set\n+# CT_LINUX_V_3_13 is not set\n+# CT_LINUX_V_3_12 is not set\n+# CT_LINUX_V_3_10 is not set\n+# CT_LINUX_V_3_4 is not set\n+CT_LINUX_V_3_2=y\n+# CT_LINUX_V_2_6_32 is not set\n+# CT_LINUX_NO_VERSIONS is not set\n+CT_LINUX_VERSION=\"3.2.101\"\n+CT_LINUX_MIRRORS=\"$(CT_Mirrors kernel.org linux ${CT_LINUX_VERSION})\"\n+CT_LINUX_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_LINUX_SIGNATURE_FORMAT=\"unpacked/.sign\"\n+CT_LINUX_4_8_or_older=y\n+CT_LINUX_older_than_4_8=y\n+CT_LINUX_3_7_or_older=y\n+CT_LINUX_older_than_3_7=y\n+CT_LINUX_later_than_3_2=y\n+CT_LINUX_3_2_or_later=y\n CT_KERNEL_LINUX_VERBOSITY_0=y\n # CT_KERNEL_LINUX_VERBOSITY_1 is not set\n # CT_KERNEL_LINUX_VERBOSITY_2 is not set\n CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n CT_KERNEL_LINUX_INSTALL_CHECK=y\n+CT_ALL_KERNEL_CHOICES=\"BARE_METAL LINUX WINDOWS\"\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n \n #\n # Binary utilities\n #\n CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS_BINUTILS=y\n CT_BINUTILS=\"binutils\"\n-CT_BINUTILS_binutils=y\n+CT_BINUTILS_CHOICE_KSYM=\"BINUTILS\"\n+CT_BINUTILS_BINUTILS_SHOW=y\n+\n+#\n+# Options for binutils\n+#\n+CT_BINUTILS_BINUTILS_PKG_KSYM=\"BINUTILS\"\n+CT_BINUTILS_DIR_NAME=\"binutils\"\n+CT_BINUTILS_USE_GNU=y\n+CT_BINUTILS_USE=\"BINUTILS\"\n+CT_BINUTILS_PKG_NAME=\"binutils\"\n+CT_BINUTILS_SRC_RELEASE=y\n+CT_BINUTILS_PATCH_ORDER=\"global\"\n+CT_BINUTILS_V_2_32=y\n+# CT_BINUTILS_V_2_31 is not set\n+# CT_BINUTILS_V_2_30 is not set\n+# CT_BINUTILS_V_2_29 is not set\n+# CT_BINUTILS_V_2_28 is not set\n+# CT_BINUTILS_V_2_27 is not set\n+# CT_BINUTILS_V_2_26 is not set\n+# CT_BINUTILS_NO_VERSIONS is not set\n+CT_BINUTILS_VERSION=\"2.32\"\n+CT_BINUTILS_MIRRORS=\"$(CT_Mirrors GNU binutils) $(CT_Mirrors sourceware binutils/releases)\"\n+CT_BINUTILS_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_BINUTILS_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_BINUTILS_later_than_2_30=y\n+CT_BINUTILS_2_30_or_later=y\n+CT_BINUTILS_later_than_2_27=y\n+CT_BINUTILS_2_27_or_later=y\n+CT_BINUTILS_later_than_2_25=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_later_than_2_23=y\n+CT_BINUTILS_2_23_or_later=y\n \n #\n # GNU binutils\n #\n-# CT_CC_BINUTILS_SHOW_LINARO is not set\n-CT_BINUTILS_V_2_25_1=y\n-# CT_BINUTILS_V_2_25 is not set\n-# CT_BINUTILS_V_2_24 is not set\n-# CT_BINUTILS_V_2_23_2 is not set\n-# CT_BINUTILS_V_2_23_1 is not set\n-# CT_BINUTILS_V_2_22 is not set\n-# CT_BINUTILS_V_2_21_53 is not set\n-# CT_BINUTILS_V_2_21_1a is not set\n-# CT_BINUTILS_V_2_20_1a is not set\n-# CT_BINUTILS_V_2_19_1a is not set\n-# CT_BINUTILS_V_2_18a is not set\n-CT_BINUTILS_VERSION=\"2.25.1\"\n-CT_BINUTILS_2_25_1_or_later=y\n-CT_BINUTILS_2_25_or_later=y\n-CT_BINUTILS_2_24_or_later=y\n-CT_BINUTILS_2_23_or_later=y\n-CT_BINUTILS_2_22_or_later=y\n-CT_BINUTILS_2_21_or_later=y\n-CT_BINUTILS_2_20_or_later=y\n-CT_BINUTILS_2_19_or_later=y\n-CT_BINUTILS_2_18_or_later=y\n CT_BINUTILS_HAS_HASH_STYLE=y\n CT_BINUTILS_HAS_GOLD=y\n-CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n-CT_BINUTILS_GOLD_SUPPORT=y\n CT_BINUTILS_HAS_PLUGINS=y\n CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n-CT_BINUTILS_FORCE_LD_BFD=y\n+CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n+CT_BINUTILS_GOLD_SUPPORT=y\n+CT_BINUTILS_FORCE_LD_BFD_DEFAULT=y\n CT_BINUTILS_LINKER_LD=y\n # CT_BINUTILS_LINKER_LD_GOLD is not set\n-# CT_BINUTILS_LINKER_GOLD_LD is not set\n CT_BINUTILS_LINKERS_LIST=\"ld\"\n CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n # CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_RELRO=m\n CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n # CT_BINUTILS_FOR_TARGET is not set\n-\n-#\n-# binutils other options\n-#\n+CT_ALL_BINUTILS_CHOICES=\"BINUTILS\"\n \n #\n # C-library\n #\n+CT_LIBC_GLIBC=y\n+# CT_LIBC_NEWLIB is not set\n+# CT_LIBC_NONE is not set\n+# CT_LIBC_UCLIBC is not set\n CT_LIBC=\"glibc\"\n-CT_LIBC_VERSION=\"2.16.0\"\n-CT_LIBC_glibc=y\n-# CT_LIBC_musl is not set\n-# CT_LIBC_uClibc is not set\n-CT_LIBC_avr_libc_AVAILABLE=y\n-CT_LIBC_glibc_AVAILABLE=y\n+CT_LIBC_CHOICE_KSYM=\"GLIBC\"\n CT_THREADS=\"nptl\"\n-# CT_CC_GLIBC_SHOW_LINARO is not set\n-# CT_LIBC_GLIBC_V_2_22 is not set\n-# CT_LIBC_GLIBC_V_2_21 is not set\n-# CT_LIBC_GLIBC_V_2_20 is not set\n-# CT_LIBC_GLIBC_V_2_19 is not set\n-# CT_LIBC_GLIBC_V_2_18 is not set\n-# CT_LIBC_GLIBC_V_2_17 is not set\n-CT_LIBC_GLIBC_V_2_16_0=y\n-# CT_LIBC_GLIBC_V_2_15 is not set\n-# CT_LIBC_GLIBC_V_2_14_1 is not set\n-# CT_LIBC_GLIBC_V_2_14 is not set\n-# CT_LIBC_GLIBC_V_2_13 is not set\n-# CT_LIBC_GLIBC_V_2_12_2 is not set\n-# CT_LIBC_GLIBC_V_2_12_1 is not set\n-# CT_LIBC_GLIBC_V_2_11_1 is not set\n-# CT_LIBC_GLIBC_V_2_11 is not set\n-# CT_LIBC_GLIBC_V_2_10_1 is not set\n-# CT_LIBC_GLIBC_V_2_9 is not set\n-# CT_LIBC_GLIBC_V_2_8 is not set\n-CT_LIBC_mingw_AVAILABLE=y\n-CT_LIBC_musl_AVAILABLE=y\n-CT_LIBC_newlib_AVAILABLE=y\n-CT_LIBC_none_AVAILABLE=y\n-CT_LIBC_uClibc_AVAILABLE=y\n+CT_LIBC_GLIBC_SHOW=y\n+\n+#\n+# Options for glibc\n+#\n+CT_LIBC_GLIBC_PKG_KSYM=\"GLIBC\"\n+CT_GLIBC_DIR_NAME=\"glibc\"\n+CT_GLIBC_USE_GNU=y\n+CT_GLIBC_USE=\"GLIBC\"\n+CT_GLIBC_PKG_NAME=\"glibc\"\n+CT_GLIBC_SRC_RELEASE=y\n+CT_GLIBC_PATCH_ORDER=\"global\"\n+# CT_GLIBC_V_2_28 is not set\n+# CT_GLIBC_V_2_27 is not set\n+# CT_GLIBC_V_2_26 is not set\n+# CT_GLIBC_V_2_25 is not set\n+# CT_GLIBC_V_2_24 is not set\n+# CT_GLIBC_V_2_23 is not set\n+# CT_GLIBC_V_2_19 is not set\n+CT_GLIBC_V_2_17=y\n+# CT_GLIBC_V_2_12_1 is not set\n+# CT_GLIBC_NO_VERSIONS is not set\n+CT_GLIBC_VERSION=\"2.17\"\n+CT_GLIBC_MIRRORS=\"$(CT_Mirrors GNU glibc)\"\n+CT_GLIBC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_GLIBC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GLIBC_2_29_or_older=y\n+CT_GLIBC_older_than_2_29=y\n+CT_GLIBC_REQUIRE_older_than_2_29=y\n+CT_GLIBC_2_27_or_older=y\n+CT_GLIBC_older_than_2_27=y\n+CT_GLIBC_2_26_or_older=y\n+CT_GLIBC_older_than_2_26=y\n+CT_GLIBC_2_25_or_older=y\n+CT_GLIBC_older_than_2_25=y\n+CT_GLIBC_2_24_or_older=y\n+CT_GLIBC_older_than_2_24=y\n+CT_GLIBC_2_23_or_older=y\n+CT_GLIBC_older_than_2_23=y\n+CT_GLIBC_2_20_or_older=y\n+CT_GLIBC_older_than_2_20=y\n+CT_GLIBC_2_17_or_later=y\n+CT_GLIBC_2_17_or_older=y\n+CT_GLIBC_later_than_2_14=y\n+CT_GLIBC_2_14_or_later=y\n+CT_GLIBC_DEP_KERNEL_HEADERS_VERSION=y\n+CT_GLIBC_DEP_BINUTILS=y\n+CT_GLIBC_DEP_GCC=y\n+CT_GLIBC_DEP_PYTHON=y\n+CT_GLIBC_HAS_NPTL_ADDON=y\n+CT_GLIBC_HAS_PORTS_ADDON=y\n+CT_GLIBC_HAS_LIBIDN_ADDON=y\n+CT_GLIBC_USE_PORTS_ADDON=y\n+CT_GLIBC_USE_NPTL_ADDON=y\n+# CT_GLIBC_USE_LIBIDN_ADDON is not set\n+CT_GLIBC_HAS_OBSOLETE_RPC=y\n+CT_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_GLIBC_CONFIGPARMS=\"\"\n+CT_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_GLIBC_ENABLE_OBSOLETE_RPC=y\n+# CT_GLIBC_DISABLE_VERSIONING is not set\n+CT_GLIBC_OLDEST_ABI=\"\"\n+CT_GLIBC_FORCE_UNWIND=y\n+# CT_GLIBC_LOCALES is not set\n+# CT_GLIBC_KERNEL_VERSION_NONE is not set\n+CT_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n+# CT_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_GLIBC_MIN_KERNEL=\"3.2.101\"\n+# CT_GLIBC_SSP_DEFAULT is not set\n+# CT_GLIBC_SSP_NO is not set\n+# CT_GLIBC_SSP_YES is not set\n+# CT_GLIBC_SSP_ALL is not set\n+# CT_GLIBC_SSP_STRONG is not set\n+# CT_NEWLIB_USE_REDHAT is not set\n+CT_ALL_LIBC_CHOICES=\"AVR_LIBC BIONIC GLIBC MINGW_W64 MOXIEBOX MUSL NEWLIB NONE UCLIBC\"\n CT_LIBC_SUPPORT_THREADS_ANY=y\n CT_LIBC_SUPPORT_THREADS_NATIVE=y\n \n #\n # Common C library options\n #\n CT_THREADS_NATIVE=y\n+# CT_CREATE_LDSO_CONF is not set\n CT_LIBC_XLDD=y\n \n-#\n-# glibc other options\n-#\n-CT_LIBC_GLIBC_PORTS_EXTERNAL=y\n-CT_LIBC_GLIBC_MAY_FORCE_PORTS=y\n-CT_LIBC_glibc_familly=y\n-CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_LIBC_GLIBC_CONFIGPARMS=\"\"\n-CT_LIBC_GLIBC_EXTRA_CFLAGS=\"\"\n-CT_LIBC_EXTRA_CC_ARGS=\"\"\n-# CT_LIBC_DISABLE_VERSIONING is not set\n-CT_LIBC_OLDEST_ABI=\"\"\n-CT_LIBC_GLIBC_FORCE_UNWIND=y\n-CT_LIBC_GLIBC_USE_PORTS=y\n-CT_LIBC_ADDONS_LIST=\"\"\n-\n-#\n-# WARNING !!!                                            \n-#\n-\n-#\n-#   For glibc >= 2.8, it can happen that the tarballs    \n-#\n-\n-#\n-#   for the addons are not available for download.       \n-#\n-\n-#\n-#   If that happens, bad luck... Try a previous version  \n-#\n-\n-#\n-#   or try again later... :-(                            \n-#\n-# CT_LIBC_LOCALES is not set\n-# CT_LIBC_GLIBC_KERNEL_VERSION_NONE is not set\n-CT_LIBC_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n-# CT_LIBC_GLIBC_KERNEL_VERSION_CHOSEN is not set\n-CT_LIBC_GLIBC_MIN_KERNEL=\"3.2.72\"\n-\n #\n # C compiler\n #\n-CT_CC=\"gcc\"\n CT_CC_CORE_PASSES_NEEDED=y\n CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n-CT_CC_gcc=y\n-# CT_CC_GCC_SHOW_LINARO is not set\n-CT_CC_GCC_V_5_2_0=y\n-# CT_CC_GCC_V_4_9_3 is not set\n-# CT_CC_GCC_V_4_8_5 is not set\n-# CT_CC_GCC_V_4_7_4 is not set\n-# CT_CC_GCC_V_4_6_4 is not set\n-# CT_CC_GCC_V_4_5_4 is not set\n-# CT_CC_GCC_V_4_4_7 is not set\n-# CT_CC_GCC_V_4_3_6 is not set\n-# CT_CC_GCC_V_4_2_4 is not set\n-CT_CC_GCC_4_2_or_later=y\n-CT_CC_GCC_4_3_or_later=y\n-CT_CC_GCC_4_4_or_later=y\n-CT_CC_GCC_4_5_or_later=y\n-CT_CC_GCC_4_6_or_later=y\n-CT_CC_GCC_4_7_or_later=y\n-CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9_or_later=y\n-CT_CC_GCC_5=y\n-CT_CC_GCC_5_or_later=y\n-CT_CC_GCC_HAS_GRAPHITE=y\n-CT_CC_GCC_USE_GRAPHITE=y\n-CT_CC_GCC_HAS_LTO=y\n-CT_CC_GCC_USE_LTO=y\n-CT_CC_GCC_HAS_PKGVERSION_BUGURL=y\n-CT_CC_GCC_HAS_BUILD_ID=y\n-CT_CC_GCC_HAS_LNK_HASH_STYLE=y\n-CT_CC_GCC_USE_GMP_MPFR=y\n-CT_CC_GCC_USE_MPC=y\n-CT_CC_GCC_HAS_LIBQUADMATH=y\n-CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"5.2.0\"\n-# CT_CC_LANG_FORTRAN is not set\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+CT_CC_GCC=y\n+CT_CC=\"gcc\"\n+CT_CC_CHOICE_KSYM=\"GCC\"\n+CT_CC_GCC_SHOW=y\n+\n+#\n+# Options for gcc\n+#\n+CT_CC_GCC_PKG_KSYM=\"GCC\"\n+CT_GCC_DIR_NAME=\"gcc\"\n+CT_GCC_USE_GNU=y\n+CT_GCC_USE=\"GCC\"\n+CT_GCC_PKG_NAME=\"gcc\"\n+CT_GCC_SRC_RELEASE=y\n+CT_GCC_PATCH_ORDER=\"global\"\n+CT_GCC_V_8=y\n+# CT_GCC_V_7 is not set\n+# CT_GCC_V_6 is not set\n+# CT_GCC_V_5 is not set\n+# CT_GCC_V_4_9 is not set\n+# CT_GCC_NO_VERSIONS is not set\n+CT_GCC_VERSION=\"8.3.0\"\n+CT_GCC_MIRRORS=\"$(CT_Mirrors GNU gcc/gcc-${CT_GCC_VERSION}) $(CT_Mirrors sourceware gcc/releases/gcc-${CT_GCC_VERSION})\"\n+CT_GCC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_GCC_SIGNATURE_FORMAT=\"\"\n+CT_GCC_later_than_7=y\n+CT_GCC_7_or_later=y\n+CT_GCC_later_than_6=y\n+CT_GCC_6_or_later=y\n+CT_GCC_later_than_5=y\n+CT_GCC_5_or_later=y\n+CT_GCC_later_than_4_9=y\n+CT_GCC_4_9_or_later=y\n+CT_GCC_later_than_4_8=y\n+CT_GCC_4_8_or_later=y\n+CT_CC_GCC_HAS_LIBMPX=y\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_CC_GCC_EXTRA_ENV_ARRAY=\"\"\n CT_CC_GCC_STATIC_LIBSTDCXX=y\n # CT_CC_GCC_SYSTEM_ZLIB is not set\n+CT_CC_GCC_CONFIG_TLS=m\n \n #\n # Optimisation features\n #\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_USE_LTO=y\n \n #\n # Settings for libraries running on target\n@@ -464,97 +554,208 @@ CT_CC_GCC_DEC_FLOAT_AUTO=y\n # CT_CC_GCC_DEC_FLOAT_BID is not set\n # CT_CC_GCC_DEC_FLOAT_DPD is not set\n # CT_CC_GCC_DEC_FLOATS_NO is not set\n-CT_CC_SUPPORT_CXX=y\n-CT_CC_SUPPORT_FORTRAN=y\n-CT_CC_SUPPORT_JAVA=y\n-CT_CC_SUPPORT_ADA=y\n-CT_CC_SUPPORT_OBJC=y\n-CT_CC_SUPPORT_OBJCXX=y\n-CT_CC_SUPPORT_GOLANG=y\n+CT_ALL_CC_CHOICES=\"GCC\"\n \n #\n # Additional supported languages:\n #\n CT_CC_LANG_CXX=y\n-# CT_CC_LANG_JAVA is not set\n+# CT_CC_LANG_FORTRAN is not set\n \n #\n # Debug facilities\n #\n-# CT_DEBUG_dmalloc is not set\n-# CT_DEBUG_duma is not set\n-# CT_DEBUG_gdb is not set\n-# CT_DEBUG_ltrace is not set\n-# CT_DEBUG_strace is not set\n+# CT_DEBUG_DUMA is not set\n+# CT_DEBUG_GDB is not set\n+# CT_DEBUG_LTRACE is not set\n+# CT_DEBUG_STRACE is not set\n+CT_ALL_DEBUG_CHOICES=\"DUMA GDB LTRACE STRACE\"\n \n #\n # Companion libraries\n #\n-CT_COMPLIBS_NEEDED=y\n+# CT_COMPLIBS_CHECK is not set\n+# CT_COMP_LIBS_CLOOG is not set\n+# CT_COMP_LIBS_EXPAT is not set\n+CT_COMP_LIBS_GETTEXT=y\n+CT_COMP_LIBS_GETTEXT_PKG_KSYM=\"GETTEXT\"\n+CT_GETTEXT_DIR_NAME=\"gettext\"\n+CT_GETTEXT_PKG_NAME=\"gettext\"\n+CT_GETTEXT_SRC_RELEASE=y\n+CT_GETTEXT_PATCH_ORDER=\"global\"\n+CT_GETTEXT_V_0_19_8_1=y\n+# CT_GETTEXT_NO_VERSIONS is not set\n+CT_GETTEXT_VERSION=\"0.19.8.1\"\n+CT_GETTEXT_MIRRORS=\"$(CT_Mirrors GNU gettext)\"\n+CT_GETTEXT_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.gz\"\n+CT_GETTEXT_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_GMP=y\n+CT_COMP_LIBS_GMP_PKG_KSYM=\"GMP\"\n+CT_GMP_DIR_NAME=\"gmp\"\n+CT_GMP_PKG_NAME=\"gmp\"\n+CT_GMP_SRC_RELEASE=y\n+CT_GMP_PATCH_ORDER=\"global\"\n+CT_GMP_V_6_1=y\n+# CT_GMP_NO_VERSIONS is not set\n+CT_GMP_VERSION=\"6.1.2\"\n+CT_GMP_MIRRORS=\"https://gmplib.org/download/gmp https://gmplib.org/download/gmp/archive $(CT_Mirrors GNU gmp)\"\n+CT_GMP_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.bz2\"\n+CT_GMP_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GMP_later_than_5_1_0=y\n+CT_GMP_5_1_0_or_later=y\n+CT_GMP_later_than_5_0_0=y\n+CT_GMP_5_0_0_or_later=y\n+CT_GMP_REQUIRE_5_0_0_or_later=y\n+CT_COMP_LIBS_ISL=y\n+CT_COMP_LIBS_ISL_PKG_KSYM=\"ISL\"\n+CT_ISL_DIR_NAME=\"isl\"\n+CT_ISL_PKG_NAME=\"isl\"\n+CT_ISL_SRC_RELEASE=y\n+CT_ISL_PATCH_ORDER=\"global\"\n+CT_ISL_V_0_20=y\n+# CT_ISL_V_0_19 is not set\n+# CT_ISL_V_0_18 is not set\n+# CT_ISL_V_0_17 is not set\n+# CT_ISL_V_0_16 is not set\n+# CT_ISL_V_0_15 is not set\n+# CT_ISL_NO_VERSIONS is not set\n+CT_ISL_VERSION=\"0.20\"\n+CT_ISL_MIRRORS=\"http://isl.gforge.inria.fr\"\n+CT_ISL_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_ISL_SIGNATURE_FORMAT=\"\"\n+CT_ISL_later_than_0_18=y\n+CT_ISL_0_18_or_later=y\n+CT_ISL_later_than_0_15=y\n+CT_ISL_0_15_or_later=y\n+CT_ISL_REQUIRE_0_15_or_later=y\n+CT_ISL_later_than_0_14=y\n+CT_ISL_0_14_or_later=y\n+CT_ISL_REQUIRE_0_14_or_later=y\n+CT_ISL_later_than_0_13=y\n+CT_ISL_0_13_or_later=y\n+CT_ISL_later_than_0_12=y\n+CT_ISL_0_12_or_later=y\n+CT_ISL_REQUIRE_0_12_or_later=y\n+# CT_COMP_LIBS_LIBELF is not set\n+CT_COMP_LIBS_LIBICONV=y\n+CT_COMP_LIBS_LIBICONV_PKG_KSYM=\"LIBICONV\"\n+CT_LIBICONV_DIR_NAME=\"libiconv\"\n+CT_LIBICONV_PKG_NAME=\"libiconv\"\n+CT_LIBICONV_SRC_RELEASE=y\n+CT_LIBICONV_PATCH_ORDER=\"global\"\n+CT_LIBICONV_V_1_15=y\n+# CT_LIBICONV_NO_VERSIONS is not set\n+CT_LIBICONV_VERSION=\"1.15\"\n+CT_LIBICONV_MIRRORS=\"$(CT_Mirrors GNU libiconv)\"\n+CT_LIBICONV_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_LIBICONV_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_MPC=y\n+CT_COMP_LIBS_MPC_PKG_KSYM=\"MPC\"\n+CT_MPC_DIR_NAME=\"mpc\"\n+CT_MPC_PKG_NAME=\"mpc\"\n+CT_MPC_SRC_RELEASE=y\n+CT_MPC_PATCH_ORDER=\"global\"\n+CT_MPC_V_1_1=y\n+# CT_MPC_V_1_0 is not set\n+# CT_MPC_NO_VERSIONS is not set\n+CT_MPC_VERSION=\"1.1.0\"\n+CT_MPC_MIRRORS=\"http://www.multiprecision.org/downloads $(CT_Mirrors GNU mpc)\"\n+CT_MPC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_MPC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_MPC_1_1_0_or_later=y\n+CT_MPC_1_1_0_or_older=y\n+CT_COMP_LIBS_MPFR=y\n+CT_COMP_LIBS_MPFR_PKG_KSYM=\"MPFR\"\n+CT_MPFR_DIR_NAME=\"mpfr\"\n+CT_MPFR_PKG_NAME=\"mpfr\"\n+CT_MPFR_SRC_RELEASE=y\n+CT_MPFR_PATCH_ORDER=\"global\"\n+CT_MPFR_V_4_0=y\n+# CT_MPFR_V_3_1 is not set\n+# CT_MPFR_NO_VERSIONS is not set\n+CT_MPFR_VERSION=\"4.0.2\"\n+CT_MPFR_MIRRORS=\"http://www.mpfr.org/mpfr-${CT_MPFR_VERSION} $(CT_Mirrors GNU mpfr)\"\n+CT_MPFR_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz .zip\"\n+CT_MPFR_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_MPFR_later_than_4_0_0=y\n+CT_MPFR_4_0_0_or_later=y\n+CT_MPFR_later_than_3_0_0=y\n+CT_MPFR_3_0_0_or_later=y\n+CT_MPFR_REQUIRE_3_0_0_or_later=y\n+CT_COMP_LIBS_NCURSES=y\n+CT_COMP_LIBS_NCURSES_PKG_KSYM=\"NCURSES\"\n+CT_NCURSES_DIR_NAME=\"ncurses\"\n+CT_NCURSES_PKG_NAME=\"ncurses\"\n+CT_NCURSES_SRC_RELEASE=y\n+CT_NCURSES_PATCH_ORDER=\"global\"\n+CT_NCURSES_V_6_1=y\n+# CT_NCURSES_V_6_0 is not set\n+# CT_NCURSES_NO_VERSIONS is not set\n+CT_NCURSES_VERSION=\"6.1\"\n+CT_NCURSES_MIRRORS=\"ftp://invisible-island.net/ncurses $(CT_Mirrors GNU ncurses)\"\n+CT_NCURSES_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_NCURSES_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_NCURSES_HOST_CONFIG_ARGS=\"\"\n+CT_NCURSES_HOST_DISABLE_DB=y\n+CT_NCURSES_HOST_FALLBACKS=\"linux,xterm,xterm-color,xterm-256color,vt100\"\n+CT_NCURSES_TARGET_CONFIG_ARGS=\"\"\n+# CT_NCURSES_TARGET_DISABLE_DB is not set\n+CT_NCURSES_TARGET_FALLBACKS=\"\"\n+CT_COMP_LIBS_ZLIB=y\n+CT_COMP_LIBS_ZLIB_PKG_KSYM=\"ZLIB\"\n+CT_ZLIB_DIR_NAME=\"zlib\"\n+CT_ZLIB_PKG_NAME=\"zlib\"\n+CT_ZLIB_SRC_RELEASE=y\n+CT_ZLIB_PATCH_ORDER=\"global\"\n+CT_ZLIB_V_1_2_11=y\n+# CT_ZLIB_NO_VERSIONS is not set\n+CT_ZLIB_VERSION=\"1.2.11\"\n+CT_ZLIB_MIRRORS=\"http://downloads.sourceforge.net/project/libpng/zlib/${CT_ZLIB_VERSION}\"\n+CT_ZLIB_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_ZLIB_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_ALL_COMP_LIBS_CHOICES=\"CLOOG EXPAT GETTEXT GMP ISL LIBELF LIBICONV MPC MPFR NCURSES ZLIB\"\n CT_LIBICONV_NEEDED=y\n CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n CT_MPC_NEEDED=y\n-CT_COMPLIBS=y\n+CT_NCURSES_NEEDED=y\n+CT_ZLIB_NEEDED=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n CT_MPC=y\n-CT_LIBICONV_V_1_14=y\n-CT_LIBICONV_VERSION=\"1.14\"\n-CT_GETTEXT_V_0_19_6=y\n-CT_GETTEXT_VERSION=\"0.19.6\"\n-CT_GMP_V_6_0_0=y\n-# CT_GMP_V_5_1_3 is not set\n-# CT_GMP_V_5_1_1 is not set\n-# CT_GMP_V_5_0_2 is not set\n-# CT_GMP_V_5_0_1 is not set\n-# CT_GMP_V_4_3_2 is not set\n-# CT_GMP_V_4_3_1 is not set\n-# CT_GMP_V_4_3_0 is not set\n-CT_GMP_5_0_2_or_later=y\n-CT_GMP_VERSION=\"6.0.0a\"\n-CT_MPFR_V_3_1_3=y\n-# CT_MPFR_V_3_1_2 is not set\n-# CT_MPFR_V_3_1_0 is not set\n-# CT_MPFR_V_3_0_1 is not set\n-# CT_MPFR_V_3_0_0 is not set\n-# CT_MPFR_V_2_4_2 is not set\n-# CT_MPFR_V_2_4_1 is not set\n-# CT_MPFR_V_2_4_0 is not set\n-CT_MPFR_VERSION=\"3.1.3\"\n-CT_ISL_V_0_14=y\n-# CT_ISL_V_0_12_2 is not set\n-CT_ISL_V_0_14_or_later=y\n-CT_ISL_V_0_12_or_later=y\n-CT_ISL_VERSION=\"0.14\"\n-# CT_CLOOG_V_0_18_4 is not set\n-# CT_CLOOG_V_0_18_1 is not set\n-# CT_CLOOG_V_0_18_0 is not set\n-CT_MPC_V_1_0_3=y\n-# CT_MPC_V_1_0_2 is not set\n-# CT_MPC_V_1_0_1 is not set\n-# CT_MPC_V_1_0 is not set\n-# CT_MPC_V_0_9 is not set\n-# CT_MPC_V_0_8_2 is not set\n-# CT_MPC_V_0_8_1 is not set\n-# CT_MPC_V_0_7 is not set\n-CT_MPC_VERSION=\"1.0.3\"\n-\n-#\n-# Companion libraries common options\n-#\n-# CT_COMPLIBS_CHECK is not set\n+CT_NCURSES=y\n+CT_ZLIB=y\n \n #\n # Companion tools\n #\n-\n-#\n-# READ HELP before you say 'Y' below !!!\n-#\n-# CT_COMP_TOOLS is not set\n+# CT_COMP_TOOLS_FOR_HOST is not set\n+# CT_COMP_TOOLS_AUTOCONF is not set\n+# CT_COMP_TOOLS_AUTOMAKE is not set\n+# CT_COMP_TOOLS_BISON is not set\n+# CT_COMP_TOOLS_DTC is not set\n+# CT_COMP_TOOLS_LIBTOOL is not set\n+# CT_COMP_TOOLS_M4 is not set\n+# CT_COMP_TOOLS_MAKE is not set\n+CT_ALL_COMP_TOOLS_CHOICES=\"AUTOCONF AUTOMAKE BISON DTC LIBTOOL M4 MAKE\""}, {"sha": "871d5225c0f714e035a0d97c7c2d841acfa09431", "filename": "src/ci/docker/dist-arm-linux/patches/glibc/ports-2.16.0/001-arm-libgcc_s_resume-used.patch", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9f6b96e461003853bf36052cfaf79b12e1c35413/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "raw_url": "https://github.com/rust-lang/rust/raw/9f6b96e461003853bf36052cfaf79b12e1c35413/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch?ref=9f6b96e461003853bf36052cfaf79b12e1c35413", "patch": "@@ -1,48 +0,0 @@\n-commit bdb24c2851fd5f0ad9b82d7ea1db911d334b02d2\n-Author: Joseph Myers <joseph@codesourcery.com>\n-Date:   Tue May 20 21:27:13 2014 +0000\n-\n-    Fix ARM build with GCC trunk.\n-    \n-    sysdeps/unix/sysv/linux/arm/unwind-resume.c and\n-    sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c have static\n-    variables that are written in C code but only read from toplevel asms.\n-    Current GCC trunk now optimizes away such apparently write-only static\n-    variables, so causing a build failure.  This patch marks those\n-    variables with __attribute_used__ to avoid that optimization.\n-    \n-    Tested that this fixes the build for ARM.\n-    \n-            * sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c\n-            (libgcc_s_resume): Use __attribute_used__.\n-            * sysdeps/unix/sysv/linux/arm/unwind-resume.c (libgcc_s_resume):\n-            Likewise.\n-\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-index 29e2c2b00b04..e848bfeffdcb 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-@@ -22,7 +22,8 @@\n- #include <pthreadP.h>\n- \n- static void *libgcc_s_handle;\n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- static _Unwind_Reason_Code (*libgcc_s_forcedunwind)\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-index 285b99b5ed0d..48d00fc83641 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-@@ -20,7 +20,8 @@\n- #include <stdio.h>\n- #include <unwind.h>\n- \n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- "}, {"sha": "209b6c166ebb7289dc32adc63ca86c2d546ac12c", "filename": "src/ci/docker/dist-armhf-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -3,20 +3,14 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n+COPY scripts/crosstool-ng-1.24.sh /scripts/\n+RUN sh /scripts/crosstool-ng-1.24.sh\n \n COPY scripts/rustbuild-setup.sh /scripts/\n RUN sh /scripts/rustbuild-setup.sh\n USER rustbuild\n WORKDIR /tmp\n \n-COPY dist-armhf-linux/patches/ /tmp/patches/\n COPY dist-armhf-linux/arm-linux-gnueabihf.config dist-armhf-linux/build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n "}, {"sha": "a3dcff1c9363538d11ca2ad8967d948405d998eb", "filename": "src/ci/docker/dist-armhf-linux/arm-linux-gnueabihf.config", "status": "modified", "additions": 511, "deletions": 310, "changes": 821, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,9 +1,29 @@\n #\n # Automatically generated file; DO NOT EDIT.\n-# Crosstool-NG Configuration\n-#\n-CT_CONFIGURE_has_make381=y\n-CT_CONFIGURE_has_xz=y\n+# crosstool-NG  Configuration\n+#\n+CT_CONFIGURE_has_static_link=y\n+CT_CONFIGURE_has_cxx11=y\n+CT_CONFIGURE_has_wget=y\n+CT_CONFIGURE_has_curl=y\n+CT_CONFIGURE_has_make_3_81_or_newer=y\n+CT_CONFIGURE_has_make_4_0_or_newer=y\n+CT_CONFIGURE_has_libtool_2_4_or_newer=y\n+CT_CONFIGURE_has_libtoolize_2_4_or_newer=y\n+CT_CONFIGURE_has_autoconf_2_65_or_newer=y\n+CT_CONFIGURE_has_autoreconf_2_65_or_newer=y\n+CT_CONFIGURE_has_automake_1_15_or_newer=y\n+CT_CONFIGURE_has_gnu_m4_1_4_12_or_newer=y\n+CT_CONFIGURE_has_bison_2_7_or_newer=y\n+CT_CONFIGURE_has_python=y\n+CT_CONFIGURE_has_git=y\n+CT_CONFIGURE_has_md5sum=y\n+CT_CONFIGURE_has_sha1sum=y\n+CT_CONFIGURE_has_sha256sum=y\n+CT_CONFIGURE_has_sha512sum=y\n+CT_CONFIGURE_has_install_with_strip_program=y\n+CT_CONFIG_VERSION_CURRENT=\"3\"\n+CT_CONFIG_VERSION=\"3\"\n CT_MODULES=y\n \n #\n@@ -20,41 +40,48 @@ CT_MODULES=y\n #\n # Paths\n #\n-CT_LOCAL_TARBALLS_DIR=\"\"\n+CT_LOCAL_TARBALLS_DIR=\"${HOME}/src\"\n+CT_SAVE_TARBALLS=y\n+# CT_TARBALLS_BUILDROOT_LAYOUT is not set\n CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_BUILD_TOP_DIR=\"${CT_WORK_DIR:-${CT_TOP_DIR}/.build}/${CT_HOST:+HOST-${CT_HOST}/}${CT_TARGET}\"\n CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n-CT_INSTALL_DIR=\"${CT_PREFIX_DIR}\"\n CT_RM_RF_PREFIX_DIR=y\n CT_REMOVE_DOCS=y\n-CT_INSTALL_DIR_RO=y\n+CT_INSTALL_LICENSES=y\n+CT_PREFIX_DIR_RO=y\n CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n # CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n \n #\n # Downloading\n #\n+CT_DOWNLOAD_AGENT_WGET=y\n+# CT_DOWNLOAD_AGENT_CURL is not set\n+# CT_DOWNLOAD_AGENT_NONE is not set\n # CT_FORBID_DOWNLOAD is not set\n # CT_FORCE_DOWNLOAD is not set\n CT_CONNECT_TIMEOUT=10\n+CT_DOWNLOAD_WGET_OPTIONS=\"--passive-ftp --tries=3 -nc --progress=dot:binary\"\n # CT_ONLY_DOWNLOAD is not set\n # CT_USE_MIRROR is not set\n+CT_VERIFY_DOWNLOAD_DIGEST=y\n+CT_VERIFY_DOWNLOAD_DIGEST_SHA512=y\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA256 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA1 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_MD5 is not set\n+CT_VERIFY_DOWNLOAD_DIGEST_ALG=\"sha512\"\n+# CT_VERIFY_DOWNLOAD_SIGNATURE is not set\n \n #\n # Extracting\n #\n # CT_FORCE_EXTRACT is not set\n-CT_OVERIDE_CONFIG_GUESS_SUB=y\n+CT_OVERRIDE_CONFIG_GUESS_SUB=y\n # CT_ONLY_EXTRACT is not set\n-# CT_PATCH_BUNDLED is not set\n-# CT_PATCH_LOCAL is not set\n-CT_PATCH_BUNDLED_LOCAL=y\n-# CT_PATCH_LOCAL_BUNDLED is not set\n-# CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n-# CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n-# CT_PATCH_NONE is not set\n-CT_PATCH_ORDER=\"bundled,local\"\n-CT_PATCH_USE_LOCAL=y\n-CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n+CT_PATCH_BUNDLED=y\n+# CT_PATCH_BUNDLED_LOCAL is not set\n+CT_PATCH_ORDER=\"bundled\"\n \n #\n # Build behavior\n@@ -77,11 +104,11 @@ CT_CONFIG_SHELL=\"${bash}\"\n #\n # CT_LOG_ERROR is not set\n # CT_LOG_WARN is not set\n-CT_LOG_INFO=y\n-# CT_LOG_EXTRA is not set\n+# CT_LOG_INFO is not set\n+CT_LOG_EXTRA=y\n # CT_LOG_ALL is not set\n # CT_LOG_DEBUG is not set\n-CT_LOG_LEVEL_MAX=\"INFO\"\n+CT_LOG_LEVEL_MAX=\"EXTRA\"\n # CT_LOG_SEE_TOOLS_WARN is not set\n CT_LOG_PROGRESS_BAR=y\n CT_LOG_TO_FILE=y\n@@ -90,86 +117,87 @@ CT_LOG_FILE_COMPRESS=y\n #\n # Target options\n #\n+# CT_ARCH_ALPHA is not set\n+# CT_ARCH_ARC is not set\n+CT_ARCH_ARM=y\n+# CT_ARCH_AVR is not set\n+# CT_ARCH_M68K is not set\n+# CT_ARCH_MIPS is not set\n+# CT_ARCH_NIOS2 is not set\n+# CT_ARCH_POWERPC is not set\n+# CT_ARCH_S390 is not set\n+# CT_ARCH_SH is not set\n+# CT_ARCH_SPARC is not set\n+# CT_ARCH_X86 is not set\n+# CT_ARCH_XTENSA is not set\n CT_ARCH=\"arm\"\n-CT_ARCH_SUPPORTS_BOTH_MMU=y\n-CT_ARCH_SUPPORTS_BOTH_ENDIAN=y\n-CT_ARCH_SUPPORTS_32=y\n-CT_ARCH_SUPPORTS_64=y\n-CT_ARCH_SUPPORTS_WITH_ARCH=y\n-CT_ARCH_SUPPORTS_WITH_CPU=y\n-CT_ARCH_SUPPORTS_WITH_TUNE=y\n-CT_ARCH_SUPPORTS_WITH_FLOAT=y\n-CT_ARCH_SUPPORTS_WITH_FPU=y\n-CT_ARCH_SUPPORTS_SOFTFP=y\n-CT_ARCH_DEFAULT_HAS_MMU=y\n-CT_ARCH_DEFAULT_LE=y\n-CT_ARCH_DEFAULT_32=y\n-CT_ARCH_ARCH=\"armv6\"\n+CT_ARCH_CHOICE_KSYM=\"ARM\"\n+# CT_ARCH_ALPHA_EV4 is not set\n+# CT_ARCH_ALPHA_EV45 is not set\n+# CT_ARCH_ALPHA_EV5 is not set\n+# CT_ARCH_ALPHA_EV56 is not set\n+# CT_ARCH_ALPHA_EV6 is not set\n+# CT_ARCH_ALPHA_EV67 is not set\n CT_ARCH_CPU=\"\"\n CT_ARCH_TUNE=\"\"\n-CT_ARCH_FPU=\"vfp\"\n-# CT_ARCH_BE is not set\n-CT_ARCH_LE=y\n-CT_ARCH_32=y\n-# CT_ARCH_64 is not set\n-CT_ARCH_BITNESS=32\n-CT_ARCH_FLOAT_HW=y\n-# CT_ARCH_FLOAT_SW is not set\n-CT_TARGET_CFLAGS=\"\"\n-CT_TARGET_LDFLAGS=\"\"\n-# CT_ARCH_alpha is not set\n-CT_ARCH_arm=y\n-# CT_ARCH_avr is not set\n-# CT_ARCH_m68k is not set\n-# CT_ARCH_mips is not set\n-# CT_ARCH_nios2 is not set\n-# CT_ARCH_powerpc is not set\n-# CT_ARCH_s390 is not set\n-# CT_ARCH_sh is not set\n-# CT_ARCH_sparc is not set\n-# CT_ARCH_x86 is not set\n-# CT_ARCH_xtensa is not set\n-CT_ARCH_alpha_AVAILABLE=y\n-CT_ARCH_arm_AVAILABLE=y\n-CT_ARCH_avr_AVAILABLE=y\n-CT_ARCH_m68k_AVAILABLE=y\n-CT_ARCH_microblaze_AVAILABLE=y\n-CT_ARCH_mips_AVAILABLE=y\n-CT_ARCH_nios2_AVAILABLE=y\n-CT_ARCH_powerpc_AVAILABLE=y\n-CT_ARCH_s390_AVAILABLE=y\n-CT_ARCH_sh_AVAILABLE=y\n-CT_ARCH_sparc_AVAILABLE=y\n-CT_ARCH_x86_AVAILABLE=y\n-CT_ARCH_xtensa_AVAILABLE=y\n+CT_ARCH_ARM_SHOW=y\n+\n+#\n+# Options for arm\n+#\n+CT_ARCH_ARM_PKG_KSYM=\"\"\n+CT_ARCH_ARM_MODE=\"arm\"\n+CT_ARCH_ARM_MODE_ARM=y\n+# CT_ARCH_ARM_MODE_THUMB is not set\n+# CT_ARCH_ARM_INTERWORKING is not set\n+CT_ARCH_ARM_EABI_FORCE=y\n+CT_ARCH_ARM_EABI=y\n+CT_ARCH_ARM_TUPLE_USE_EABIHF=y\n+CT_ALL_ARCH_CHOICES=\"ALPHA ARC ARM AVR M68K MICROBLAZE MIPS MOXIE MSP430 NIOS2 POWERPC RISCV S390 SH SPARC X86 XTENSA\"\n CT_ARCH_SUFFIX=\"\"\n+# CT_OMIT_TARGET_VENDOR is not set\n \n #\n # Generic target options\n #\n # CT_MULTILIB is not set\n+CT_DEMULTILIB=y\n+CT_ARCH_SUPPORTS_BOTH_MMU=y\n+CT_ARCH_DEFAULT_HAS_MMU=y\n CT_ARCH_USE_MMU=y\n+CT_ARCH_SUPPORTS_FLAT_FORMAT=y\n+CT_ARCH_SUPPORTS_EITHER_ENDIAN=y\n+CT_ARCH_DEFAULT_LE=y\n+# CT_ARCH_BE is not set\n+CT_ARCH_LE=y\n CT_ARCH_ENDIAN=\"little\"\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_BITNESS=32\n+CT_ARCH_32=y\n+# CT_ARCH_64 is not set\n \n #\n # Target optimisations\n #\n+CT_ARCH_SUPPORTS_WITH_ARCH=y\n+CT_ARCH_SUPPORTS_WITH_CPU=y\n+CT_ARCH_SUPPORTS_WITH_TUNE=y\n+CT_ARCH_SUPPORTS_WITH_FLOAT=y\n+CT_ARCH_SUPPORTS_WITH_FPU=y\n+CT_ARCH_SUPPORTS_SOFTFP=y\n CT_ARCH_EXCLUSIVE_WITH_CPU=y\n+CT_ARCH_ARCH=\"armv6\"\n+CT_ARCH_FPU=\"vfp\"\n # CT_ARCH_FLOAT_AUTO is not set\n+CT_ARCH_FLOAT_HW=y\n # CT_ARCH_FLOAT_SOFTFP is not set\n+# CT_ARCH_FLOAT_SW is not set\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n CT_ARCH_FLOAT=\"hard\"\n \n-#\n-# arm other options\n-#\n-CT_ARCH_ARM_MODE=\"arm\"\n-CT_ARCH_ARM_MODE_ARM=y\n-# CT_ARCH_ARM_MODE_THUMB is not set\n-# CT_ARCH_ARM_INTERWORKING is not set\n-CT_ARCH_ARM_EABI_FORCE=y\n-CT_ARCH_ARM_EABI=y\n-CT_ARCH_ARM_TUPLE_USE_EABIHF=y\n-\n #\n # Toolchain options\n #\n@@ -182,7 +210,9 @@ CT_USE_SYSROOT=y\n CT_SYSROOT_NAME=\"sysroot\"\n CT_SYSROOT_DIR_PREFIX=\"\"\n CT_WANTS_STATIC_LINK=y\n+CT_WANTS_STATIC_LINK_CXX=y\n # CT_STATIC_TOOLCHAIN is not set\n+CT_SHOW_CT_VERSION=y\n CT_TOOLCHAIN_PKGVERSION=\"\"\n CT_TOOLCHAIN_BUGURL=\"\"\n \n@@ -216,227 +246,287 @@ CT_BUILD_SUFFIX=\"\"\n # Operating System\n #\n CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+# CT_KERNEL_BARE_METAL is not set\n+CT_KERNEL_LINUX=y\n CT_KERNEL=\"linux\"\n-CT_KERNEL_VERSION=\"3.2.72\"\n-# CT_KERNEL_bare_metal is not set\n-CT_KERNEL_linux=y\n-CT_KERNEL_bare_metal_AVAILABLE=y\n-CT_KERNEL_linux_AVAILABLE=y\n-# CT_KERNEL_V_4_3 is not set\n-# CT_KERNEL_V_4_2 is not set\n-# CT_KERNEL_V_4_1 is not set\n-# CT_KERNEL_V_3_18 is not set\n-# CT_KERNEL_V_3_14 is not set\n-# CT_KERNEL_V_3_12 is not set\n-# CT_KERNEL_V_3_10 is not set\n-# CT_KERNEL_V_3_4 is not set\n-CT_KERNEL_V_3_2=y\n-# CT_KERNEL_V_2_6_32 is not set\n-# CT_KERNEL_LINUX_CUSTOM is not set\n-CT_KERNEL_windows_AVAILABLE=y\n-\n-#\n-# Common kernel options\n-#\n-CT_SHARED_LIBS=y\n-\n-#\n-# linux other options\n-#\n+CT_KERNEL_CHOICE_KSYM=\"LINUX\"\n+CT_KERNEL_LINUX_SHOW=y\n+\n+#\n+# Options for linux\n+#\n+CT_KERNEL_LINUX_PKG_KSYM=\"LINUX\"\n+CT_LINUX_DIR_NAME=\"linux\"\n+CT_LINUX_PKG_NAME=\"linux\"\n+CT_LINUX_SRC_RELEASE=y\n+CT_LINUX_PATCH_ORDER=\"global\"\n+# CT_LINUX_V_4_20 is not set\n+# CT_LINUX_V_4_19 is not set\n+# CT_LINUX_V_4_18 is not set\n+# CT_LINUX_V_4_17 is not set\n+# CT_LINUX_V_4_16 is not set\n+# CT_LINUX_V_4_15 is not set\n+# CT_LINUX_V_4_14 is not set\n+# CT_LINUX_V_4_13 is not set\n+# CT_LINUX_V_4_12 is not set\n+# CT_LINUX_V_4_11 is not set\n+# CT_LINUX_V_4_10 is not set\n+# CT_LINUX_V_4_9 is not set\n+# CT_LINUX_V_4_4 is not set\n+# CT_LINUX_V_4_1 is not set\n+# CT_LINUX_V_3_16 is not set\n+# CT_LINUX_V_3_13 is not set\n+# CT_LINUX_V_3_12 is not set\n+# CT_LINUX_V_3_10 is not set\n+# CT_LINUX_V_3_4 is not set\n+CT_LINUX_V_3_2=y\n+# CT_LINUX_V_2_6_32 is not set\n+# CT_LINUX_NO_VERSIONS is not set\n+CT_LINUX_VERSION=\"3.2.101\"\n+CT_LINUX_MIRRORS=\"$(CT_Mirrors kernel.org linux ${CT_LINUX_VERSION})\"\n+CT_LINUX_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_LINUX_SIGNATURE_FORMAT=\"unpacked/.sign\"\n+CT_LINUX_4_8_or_older=y\n+CT_LINUX_older_than_4_8=y\n+CT_LINUX_3_7_or_older=y\n+CT_LINUX_older_than_3_7=y\n+CT_LINUX_later_than_3_2=y\n+CT_LINUX_3_2_or_later=y\n CT_KERNEL_LINUX_VERBOSITY_0=y\n # CT_KERNEL_LINUX_VERBOSITY_1 is not set\n # CT_KERNEL_LINUX_VERBOSITY_2 is not set\n CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n CT_KERNEL_LINUX_INSTALL_CHECK=y\n+CT_ALL_KERNEL_CHOICES=\"BARE_METAL LINUX WINDOWS\"\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n \n #\n # Binary utilities\n #\n CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS_BINUTILS=y\n CT_BINUTILS=\"binutils\"\n-CT_BINUTILS_binutils=y\n+CT_BINUTILS_CHOICE_KSYM=\"BINUTILS\"\n+CT_BINUTILS_BINUTILS_SHOW=y\n+\n+#\n+# Options for binutils\n+#\n+CT_BINUTILS_BINUTILS_PKG_KSYM=\"BINUTILS\"\n+CT_BINUTILS_DIR_NAME=\"binutils\"\n+CT_BINUTILS_USE_GNU=y\n+CT_BINUTILS_USE=\"BINUTILS\"\n+CT_BINUTILS_PKG_NAME=\"binutils\"\n+CT_BINUTILS_SRC_RELEASE=y\n+CT_BINUTILS_PATCH_ORDER=\"global\"\n+CT_BINUTILS_V_2_32=y\n+# CT_BINUTILS_V_2_31 is not set\n+# CT_BINUTILS_V_2_30 is not set\n+# CT_BINUTILS_V_2_29 is not set\n+# CT_BINUTILS_V_2_28 is not set\n+# CT_BINUTILS_V_2_27 is not set\n+# CT_BINUTILS_V_2_26 is not set\n+# CT_BINUTILS_NO_VERSIONS is not set\n+CT_BINUTILS_VERSION=\"2.32\"\n+CT_BINUTILS_MIRRORS=\"$(CT_Mirrors GNU binutils) $(CT_Mirrors sourceware binutils/releases)\"\n+CT_BINUTILS_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_BINUTILS_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_BINUTILS_later_than_2_30=y\n+CT_BINUTILS_2_30_or_later=y\n+CT_BINUTILS_later_than_2_27=y\n+CT_BINUTILS_2_27_or_later=y\n+CT_BINUTILS_later_than_2_25=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_later_than_2_23=y\n+CT_BINUTILS_2_23_or_later=y\n \n #\n # GNU binutils\n #\n-# CT_CC_BINUTILS_SHOW_LINARO is not set\n-CT_BINUTILS_V_2_25_1=y\n-# CT_BINUTILS_V_2_25 is not set\n-# CT_BINUTILS_V_2_24 is not set\n-# CT_BINUTILS_V_2_23_2 is not set\n-# CT_BINUTILS_V_2_23_1 is not set\n-# CT_BINUTILS_V_2_22 is not set\n-# CT_BINUTILS_V_2_21_53 is not set\n-# CT_BINUTILS_V_2_21_1a is not set\n-# CT_BINUTILS_V_2_20_1a is not set\n-# CT_BINUTILS_V_2_19_1a is not set\n-# CT_BINUTILS_V_2_18a is not set\n-CT_BINUTILS_VERSION=\"2.25.1\"\n-CT_BINUTILS_2_25_1_or_later=y\n-CT_BINUTILS_2_25_or_later=y\n-CT_BINUTILS_2_24_or_later=y\n-CT_BINUTILS_2_23_or_later=y\n-CT_BINUTILS_2_22_or_later=y\n-CT_BINUTILS_2_21_or_later=y\n-CT_BINUTILS_2_20_or_later=y\n-CT_BINUTILS_2_19_or_later=y\n-CT_BINUTILS_2_18_or_later=y\n CT_BINUTILS_HAS_HASH_STYLE=y\n CT_BINUTILS_HAS_GOLD=y\n-CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n-CT_BINUTILS_GOLD_SUPPORT=y\n CT_BINUTILS_HAS_PLUGINS=y\n CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n-CT_BINUTILS_FORCE_LD_BFD=y\n+CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n+CT_BINUTILS_GOLD_SUPPORT=y\n+CT_BINUTILS_FORCE_LD_BFD_DEFAULT=y\n CT_BINUTILS_LINKER_LD=y\n # CT_BINUTILS_LINKER_LD_GOLD is not set\n-# CT_BINUTILS_LINKER_GOLD_LD is not set\n CT_BINUTILS_LINKERS_LIST=\"ld\"\n CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n # CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_RELRO=m\n CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n # CT_BINUTILS_FOR_TARGET is not set\n-\n-#\n-# binutils other options\n-#\n+CT_ALL_BINUTILS_CHOICES=\"BINUTILS\"\n \n #\n # C-library\n #\n+CT_LIBC_GLIBC=y\n+# CT_LIBC_NEWLIB is not set\n+# CT_LIBC_NONE is not set\n+# CT_LIBC_UCLIBC is not set\n CT_LIBC=\"glibc\"\n-CT_LIBC_VERSION=\"2.16.0\"\n-CT_LIBC_glibc=y\n-# CT_LIBC_musl is not set\n-# CT_LIBC_uClibc is not set\n-CT_LIBC_avr_libc_AVAILABLE=y\n-CT_LIBC_glibc_AVAILABLE=y\n+CT_LIBC_CHOICE_KSYM=\"GLIBC\"\n CT_THREADS=\"nptl\"\n-# CT_CC_GLIBC_SHOW_LINARO is not set\n-# CT_LIBC_GLIBC_V_2_22 is not set\n-# CT_LIBC_GLIBC_V_2_21 is not set\n-# CT_LIBC_GLIBC_V_2_20 is not set\n-# CT_LIBC_GLIBC_V_2_19 is not set\n-# CT_LIBC_GLIBC_V_2_18 is not set\n-# CT_LIBC_GLIBC_V_2_17 is not set\n-CT_LIBC_GLIBC_V_2_16_0=y\n-# CT_LIBC_GLIBC_V_2_15 is not set\n-# CT_LIBC_GLIBC_V_2_14_1 is not set\n-# CT_LIBC_GLIBC_V_2_14 is not set\n-# CT_LIBC_GLIBC_V_2_13 is not set\n-# CT_LIBC_GLIBC_V_2_12_2 is not set\n-# CT_LIBC_GLIBC_V_2_12_1 is not set\n-# CT_LIBC_GLIBC_V_2_11_1 is not set\n-# CT_LIBC_GLIBC_V_2_11 is not set\n-# CT_LIBC_GLIBC_V_2_10_1 is not set\n-# CT_LIBC_GLIBC_V_2_9 is not set\n-# CT_LIBC_GLIBC_V_2_8 is not set\n-CT_LIBC_mingw_AVAILABLE=y\n-CT_LIBC_musl_AVAILABLE=y\n-CT_LIBC_newlib_AVAILABLE=y\n-CT_LIBC_none_AVAILABLE=y\n-CT_LIBC_uClibc_AVAILABLE=y\n+CT_LIBC_GLIBC_SHOW=y\n+\n+#\n+# Options for glibc\n+#\n+CT_LIBC_GLIBC_PKG_KSYM=\"GLIBC\"\n+CT_GLIBC_DIR_NAME=\"glibc\"\n+CT_GLIBC_USE_GNU=y\n+CT_GLIBC_USE=\"GLIBC\"\n+CT_GLIBC_PKG_NAME=\"glibc\"\n+CT_GLIBC_SRC_RELEASE=y\n+CT_GLIBC_PATCH_ORDER=\"global\"\n+# CT_GLIBC_V_2_28 is not set\n+# CT_GLIBC_V_2_27 is not set\n+# CT_GLIBC_V_2_26 is not set\n+# CT_GLIBC_V_2_25 is not set\n+# CT_GLIBC_V_2_24 is not set\n+# CT_GLIBC_V_2_23 is not set\n+# CT_GLIBC_V_2_19 is not set\n+CT_GLIBC_V_2_17=y\n+# CT_GLIBC_V_2_12_1 is not set\n+# CT_GLIBC_NO_VERSIONS is not set\n+CT_GLIBC_VERSION=\"2.17\"\n+CT_GLIBC_MIRRORS=\"$(CT_Mirrors GNU glibc)\"\n+CT_GLIBC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_GLIBC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GLIBC_2_29_or_older=y\n+CT_GLIBC_older_than_2_29=y\n+CT_GLIBC_REQUIRE_older_than_2_29=y\n+CT_GLIBC_2_27_or_older=y\n+CT_GLIBC_older_than_2_27=y\n+CT_GLIBC_2_26_or_older=y\n+CT_GLIBC_older_than_2_26=y\n+CT_GLIBC_2_25_or_older=y\n+CT_GLIBC_older_than_2_25=y\n+CT_GLIBC_2_24_or_older=y\n+CT_GLIBC_older_than_2_24=y\n+CT_GLIBC_2_23_or_older=y\n+CT_GLIBC_older_than_2_23=y\n+CT_GLIBC_2_20_or_older=y\n+CT_GLIBC_older_than_2_20=y\n+CT_GLIBC_2_17_or_later=y\n+CT_GLIBC_2_17_or_older=y\n+CT_GLIBC_later_than_2_14=y\n+CT_GLIBC_2_14_or_later=y\n+CT_GLIBC_DEP_KERNEL_HEADERS_VERSION=y\n+CT_GLIBC_DEP_BINUTILS=y\n+CT_GLIBC_DEP_GCC=y\n+CT_GLIBC_DEP_PYTHON=y\n+CT_GLIBC_HAS_NPTL_ADDON=y\n+CT_GLIBC_HAS_PORTS_ADDON=y\n+CT_GLIBC_HAS_LIBIDN_ADDON=y\n+CT_GLIBC_USE_PORTS_ADDON=y\n+CT_GLIBC_USE_NPTL_ADDON=y\n+# CT_GLIBC_USE_LIBIDN_ADDON is not set\n+CT_GLIBC_HAS_OBSOLETE_RPC=y\n+CT_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_GLIBC_CONFIGPARMS=\"\"\n+CT_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_GLIBC_ENABLE_OBSOLETE_RPC=y\n+# CT_GLIBC_DISABLE_VERSIONING is not set\n+CT_GLIBC_OLDEST_ABI=\"\"\n+CT_GLIBC_FORCE_UNWIND=y\n+# CT_GLIBC_LOCALES is not set\n+# CT_GLIBC_KERNEL_VERSION_NONE is not set\n+CT_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n+# CT_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_GLIBC_MIN_KERNEL=\"3.2.101\"\n+# CT_GLIBC_SSP_DEFAULT is not set\n+# CT_GLIBC_SSP_NO is not set\n+# CT_GLIBC_SSP_YES is not set\n+# CT_GLIBC_SSP_ALL is not set\n+# CT_GLIBC_SSP_STRONG is not set\n+# CT_NEWLIB_USE_REDHAT is not set\n+CT_ALL_LIBC_CHOICES=\"AVR_LIBC BIONIC GLIBC MINGW_W64 MOXIEBOX MUSL NEWLIB NONE UCLIBC\"\n CT_LIBC_SUPPORT_THREADS_ANY=y\n CT_LIBC_SUPPORT_THREADS_NATIVE=y\n \n #\n # Common C library options\n #\n CT_THREADS_NATIVE=y\n+# CT_CREATE_LDSO_CONF is not set\n CT_LIBC_XLDD=y\n \n-#\n-# glibc other options\n-#\n-CT_LIBC_GLIBC_PORTS_EXTERNAL=y\n-CT_LIBC_GLIBC_MAY_FORCE_PORTS=y\n-CT_LIBC_glibc_familly=y\n-CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_LIBC_GLIBC_CONFIGPARMS=\"\"\n-CT_LIBC_GLIBC_EXTRA_CFLAGS=\"\"\n-CT_LIBC_EXTRA_CC_ARGS=\"\"\n-# CT_LIBC_DISABLE_VERSIONING is not set\n-CT_LIBC_OLDEST_ABI=\"\"\n-CT_LIBC_GLIBC_FORCE_UNWIND=y\n-CT_LIBC_GLIBC_USE_PORTS=y\n-CT_LIBC_ADDONS_LIST=\"\"\n-\n-#\n-# WARNING !!!                                            \n-#\n-\n-#\n-#   For glibc >= 2.8, it can happen that the tarballs    \n-#\n-\n-#\n-#   for the addons are not available for download.       \n-#\n-\n-#\n-#   If that happens, bad luck... Try a previous version  \n-#\n-\n-#\n-#   or try again later... :-(                            \n-#\n-# CT_LIBC_LOCALES is not set\n-# CT_LIBC_GLIBC_KERNEL_VERSION_NONE is not set\n-CT_LIBC_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n-# CT_LIBC_GLIBC_KERNEL_VERSION_CHOSEN is not set\n-CT_LIBC_GLIBC_MIN_KERNEL=\"3.2.72\"\n-\n #\n # C compiler\n #\n-CT_CC=\"gcc\"\n CT_CC_CORE_PASSES_NEEDED=y\n CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n-CT_CC_gcc=y\n-# CT_CC_GCC_SHOW_LINARO is not set\n-CT_CC_GCC_V_5_2_0=y\n-# CT_CC_GCC_V_4_9_3 is not set\n-# CT_CC_GCC_V_4_8_5 is not set\n-# CT_CC_GCC_V_4_7_4 is not set\n-# CT_CC_GCC_V_4_6_4 is not set\n-# CT_CC_GCC_V_4_5_4 is not set\n-# CT_CC_GCC_V_4_4_7 is not set\n-# CT_CC_GCC_V_4_3_6 is not set\n-# CT_CC_GCC_V_4_2_4 is not set\n-CT_CC_GCC_4_2_or_later=y\n-CT_CC_GCC_4_3_or_later=y\n-CT_CC_GCC_4_4_or_later=y\n-CT_CC_GCC_4_5_or_later=y\n-CT_CC_GCC_4_6_or_later=y\n-CT_CC_GCC_4_7_or_later=y\n-CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9_or_later=y\n-CT_CC_GCC_5=y\n-CT_CC_GCC_5_or_later=y\n-CT_CC_GCC_HAS_GRAPHITE=y\n-CT_CC_GCC_USE_GRAPHITE=y\n-CT_CC_GCC_HAS_LTO=y\n-CT_CC_GCC_USE_LTO=y\n-CT_CC_GCC_HAS_PKGVERSION_BUGURL=y\n-CT_CC_GCC_HAS_BUILD_ID=y\n-CT_CC_GCC_HAS_LNK_HASH_STYLE=y\n-CT_CC_GCC_USE_GMP_MPFR=y\n-CT_CC_GCC_USE_MPC=y\n-CT_CC_GCC_HAS_LIBQUADMATH=y\n-CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"5.2.0\"\n-# CT_CC_LANG_FORTRAN is not set\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+CT_CC_GCC=y\n+CT_CC=\"gcc\"\n+CT_CC_CHOICE_KSYM=\"GCC\"\n+CT_CC_GCC_SHOW=y\n+\n+#\n+# Options for gcc\n+#\n+CT_CC_GCC_PKG_KSYM=\"GCC\"\n+CT_GCC_DIR_NAME=\"gcc\"\n+CT_GCC_USE_GNU=y\n+CT_GCC_USE=\"GCC\"\n+CT_GCC_PKG_NAME=\"gcc\"\n+CT_GCC_SRC_RELEASE=y\n+CT_GCC_PATCH_ORDER=\"global\"\n+CT_GCC_V_8=y\n+# CT_GCC_V_7 is not set\n+# CT_GCC_V_6 is not set\n+# CT_GCC_V_5 is not set\n+# CT_GCC_V_4_9 is not set\n+# CT_GCC_NO_VERSIONS is not set\n+CT_GCC_VERSION=\"8.3.0\"\n+CT_GCC_MIRRORS=\"$(CT_Mirrors GNU gcc/gcc-${CT_GCC_VERSION}) $(CT_Mirrors sourceware gcc/releases/gcc-${CT_GCC_VERSION})\"\n+CT_GCC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_GCC_SIGNATURE_FORMAT=\"\"\n+CT_GCC_later_than_7=y\n+CT_GCC_7_or_later=y\n+CT_GCC_later_than_6=y\n+CT_GCC_6_or_later=y\n+CT_GCC_later_than_5=y\n+CT_GCC_5_or_later=y\n+CT_GCC_later_than_4_9=y\n+CT_GCC_4_9_or_later=y\n+CT_GCC_later_than_4_8=y\n+CT_GCC_4_8_or_later=y\n+CT_CC_GCC_HAS_LIBMPX=y\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_CC_GCC_EXTRA_ENV_ARRAY=\"\"\n CT_CC_GCC_STATIC_LIBSTDCXX=y\n # CT_CC_GCC_SYSTEM_ZLIB is not set\n+CT_CC_GCC_CONFIG_TLS=m\n \n #\n # Optimisation features\n #\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_USE_LTO=y\n \n #\n # Settings for libraries running on target\n@@ -465,97 +555,208 @@ CT_CC_GCC_DEC_FLOAT_AUTO=y\n # CT_CC_GCC_DEC_FLOAT_BID is not set\n # CT_CC_GCC_DEC_FLOAT_DPD is not set\n # CT_CC_GCC_DEC_FLOATS_NO is not set\n-CT_CC_SUPPORT_CXX=y\n-CT_CC_SUPPORT_FORTRAN=y\n-CT_CC_SUPPORT_JAVA=y\n-CT_CC_SUPPORT_ADA=y\n-CT_CC_SUPPORT_OBJC=y\n-CT_CC_SUPPORT_OBJCXX=y\n-CT_CC_SUPPORT_GOLANG=y\n+CT_ALL_CC_CHOICES=\"GCC\"\n \n #\n # Additional supported languages:\n #\n CT_CC_LANG_CXX=y\n-# CT_CC_LANG_JAVA is not set\n+# CT_CC_LANG_FORTRAN is not set\n \n #\n # Debug facilities\n #\n-# CT_DEBUG_dmalloc is not set\n-# CT_DEBUG_duma is not set\n-# CT_DEBUG_gdb is not set\n-# CT_DEBUG_ltrace is not set\n-# CT_DEBUG_strace is not set\n+# CT_DEBUG_DUMA is not set\n+# CT_DEBUG_GDB is not set\n+# CT_DEBUG_LTRACE is not set\n+# CT_DEBUG_STRACE is not set\n+CT_ALL_DEBUG_CHOICES=\"DUMA GDB LTRACE STRACE\"\n \n #\n # Companion libraries\n #\n-CT_COMPLIBS_NEEDED=y\n+# CT_COMPLIBS_CHECK is not set\n+# CT_COMP_LIBS_CLOOG is not set\n+# CT_COMP_LIBS_EXPAT is not set\n+CT_COMP_LIBS_GETTEXT=y\n+CT_COMP_LIBS_GETTEXT_PKG_KSYM=\"GETTEXT\"\n+CT_GETTEXT_DIR_NAME=\"gettext\"\n+CT_GETTEXT_PKG_NAME=\"gettext\"\n+CT_GETTEXT_SRC_RELEASE=y\n+CT_GETTEXT_PATCH_ORDER=\"global\"\n+CT_GETTEXT_V_0_19_8_1=y\n+# CT_GETTEXT_NO_VERSIONS is not set\n+CT_GETTEXT_VERSION=\"0.19.8.1\"\n+CT_GETTEXT_MIRRORS=\"$(CT_Mirrors GNU gettext)\"\n+CT_GETTEXT_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.gz\"\n+CT_GETTEXT_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_GMP=y\n+CT_COMP_LIBS_GMP_PKG_KSYM=\"GMP\"\n+CT_GMP_DIR_NAME=\"gmp\"\n+CT_GMP_PKG_NAME=\"gmp\"\n+CT_GMP_SRC_RELEASE=y\n+CT_GMP_PATCH_ORDER=\"global\"\n+CT_GMP_V_6_1=y\n+# CT_GMP_NO_VERSIONS is not set\n+CT_GMP_VERSION=\"6.1.2\"\n+CT_GMP_MIRRORS=\"https://gmplib.org/download/gmp https://gmplib.org/download/gmp/archive $(CT_Mirrors GNU gmp)\"\n+CT_GMP_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.bz2\"\n+CT_GMP_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GMP_later_than_5_1_0=y\n+CT_GMP_5_1_0_or_later=y\n+CT_GMP_later_than_5_0_0=y\n+CT_GMP_5_0_0_or_later=y\n+CT_GMP_REQUIRE_5_0_0_or_later=y\n+CT_COMP_LIBS_ISL=y\n+CT_COMP_LIBS_ISL_PKG_KSYM=\"ISL\"\n+CT_ISL_DIR_NAME=\"isl\"\n+CT_ISL_PKG_NAME=\"isl\"\n+CT_ISL_SRC_RELEASE=y\n+CT_ISL_PATCH_ORDER=\"global\"\n+CT_ISL_V_0_20=y\n+# CT_ISL_V_0_19 is not set\n+# CT_ISL_V_0_18 is not set\n+# CT_ISL_V_0_17 is not set\n+# CT_ISL_V_0_16 is not set\n+# CT_ISL_V_0_15 is not set\n+# CT_ISL_NO_VERSIONS is not set\n+CT_ISL_VERSION=\"0.20\"\n+CT_ISL_MIRRORS=\"http://isl.gforge.inria.fr\"\n+CT_ISL_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_ISL_SIGNATURE_FORMAT=\"\"\n+CT_ISL_later_than_0_18=y\n+CT_ISL_0_18_or_later=y\n+CT_ISL_later_than_0_15=y\n+CT_ISL_0_15_or_later=y\n+CT_ISL_REQUIRE_0_15_or_later=y\n+CT_ISL_later_than_0_14=y\n+CT_ISL_0_14_or_later=y\n+CT_ISL_REQUIRE_0_14_or_later=y\n+CT_ISL_later_than_0_13=y\n+CT_ISL_0_13_or_later=y\n+CT_ISL_later_than_0_12=y\n+CT_ISL_0_12_or_later=y\n+CT_ISL_REQUIRE_0_12_or_later=y\n+# CT_COMP_LIBS_LIBELF is not set\n+CT_COMP_LIBS_LIBICONV=y\n+CT_COMP_LIBS_LIBICONV_PKG_KSYM=\"LIBICONV\"\n+CT_LIBICONV_DIR_NAME=\"libiconv\"\n+CT_LIBICONV_PKG_NAME=\"libiconv\"\n+CT_LIBICONV_SRC_RELEASE=y\n+CT_LIBICONV_PATCH_ORDER=\"global\"\n+CT_LIBICONV_V_1_15=y\n+# CT_LIBICONV_NO_VERSIONS is not set\n+CT_LIBICONV_VERSION=\"1.15\"\n+CT_LIBICONV_MIRRORS=\"$(CT_Mirrors GNU libiconv)\"\n+CT_LIBICONV_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_LIBICONV_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_MPC=y\n+CT_COMP_LIBS_MPC_PKG_KSYM=\"MPC\"\n+CT_MPC_DIR_NAME=\"mpc\"\n+CT_MPC_PKG_NAME=\"mpc\"\n+CT_MPC_SRC_RELEASE=y\n+CT_MPC_PATCH_ORDER=\"global\"\n+CT_MPC_V_1_1=y\n+# CT_MPC_V_1_0 is not set\n+# CT_MPC_NO_VERSIONS is not set\n+CT_MPC_VERSION=\"1.1.0\"\n+CT_MPC_MIRRORS=\"http://www.multiprecision.org/downloads $(CT_Mirrors GNU mpc)\"\n+CT_MPC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_MPC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_MPC_1_1_0_or_later=y\n+CT_MPC_1_1_0_or_older=y\n+CT_COMP_LIBS_MPFR=y\n+CT_COMP_LIBS_MPFR_PKG_KSYM=\"MPFR\"\n+CT_MPFR_DIR_NAME=\"mpfr\"\n+CT_MPFR_PKG_NAME=\"mpfr\"\n+CT_MPFR_SRC_RELEASE=y\n+CT_MPFR_PATCH_ORDER=\"global\"\n+CT_MPFR_V_4_0=y\n+# CT_MPFR_V_3_1 is not set\n+# CT_MPFR_NO_VERSIONS is not set\n+CT_MPFR_VERSION=\"4.0.2\"\n+CT_MPFR_MIRRORS=\"http://www.mpfr.org/mpfr-${CT_MPFR_VERSION} $(CT_Mirrors GNU mpfr)\"\n+CT_MPFR_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz .zip\"\n+CT_MPFR_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_MPFR_later_than_4_0_0=y\n+CT_MPFR_4_0_0_or_later=y\n+CT_MPFR_later_than_3_0_0=y\n+CT_MPFR_3_0_0_or_later=y\n+CT_MPFR_REQUIRE_3_0_0_or_later=y\n+CT_COMP_LIBS_NCURSES=y\n+CT_COMP_LIBS_NCURSES_PKG_KSYM=\"NCURSES\"\n+CT_NCURSES_DIR_NAME=\"ncurses\"\n+CT_NCURSES_PKG_NAME=\"ncurses\"\n+CT_NCURSES_SRC_RELEASE=y\n+CT_NCURSES_PATCH_ORDER=\"global\"\n+CT_NCURSES_V_6_1=y\n+# CT_NCURSES_V_6_0 is not set\n+# CT_NCURSES_NO_VERSIONS is not set\n+CT_NCURSES_VERSION=\"6.1\"\n+CT_NCURSES_MIRRORS=\"ftp://invisible-island.net/ncurses $(CT_Mirrors GNU ncurses)\"\n+CT_NCURSES_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_NCURSES_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_NCURSES_HOST_CONFIG_ARGS=\"\"\n+CT_NCURSES_HOST_DISABLE_DB=y\n+CT_NCURSES_HOST_FALLBACKS=\"linux,xterm,xterm-color,xterm-256color,vt100\"\n+CT_NCURSES_TARGET_CONFIG_ARGS=\"\"\n+# CT_NCURSES_TARGET_DISABLE_DB is not set\n+CT_NCURSES_TARGET_FALLBACKS=\"\"\n+CT_COMP_LIBS_ZLIB=y\n+CT_COMP_LIBS_ZLIB_PKG_KSYM=\"ZLIB\"\n+CT_ZLIB_DIR_NAME=\"zlib\"\n+CT_ZLIB_PKG_NAME=\"zlib\"\n+CT_ZLIB_SRC_RELEASE=y\n+CT_ZLIB_PATCH_ORDER=\"global\"\n+CT_ZLIB_V_1_2_11=y\n+# CT_ZLIB_NO_VERSIONS is not set\n+CT_ZLIB_VERSION=\"1.2.11\"\n+CT_ZLIB_MIRRORS=\"http://downloads.sourceforge.net/project/libpng/zlib/${CT_ZLIB_VERSION}\"\n+CT_ZLIB_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_ZLIB_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_ALL_COMP_LIBS_CHOICES=\"CLOOG EXPAT GETTEXT GMP ISL LIBELF LIBICONV MPC MPFR NCURSES ZLIB\"\n CT_LIBICONV_NEEDED=y\n CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n CT_MPC_NEEDED=y\n-CT_COMPLIBS=y\n+CT_NCURSES_NEEDED=y\n+CT_ZLIB_NEEDED=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n CT_MPC=y\n-CT_LIBICONV_V_1_14=y\n-CT_LIBICONV_VERSION=\"1.14\"\n-CT_GETTEXT_V_0_19_6=y\n-CT_GETTEXT_VERSION=\"0.19.6\"\n-CT_GMP_V_6_0_0=y\n-# CT_GMP_V_5_1_3 is not set\n-# CT_GMP_V_5_1_1 is not set\n-# CT_GMP_V_5_0_2 is not set\n-# CT_GMP_V_5_0_1 is not set\n-# CT_GMP_V_4_3_2 is not set\n-# CT_GMP_V_4_3_1 is not set\n-# CT_GMP_V_4_3_0 is not set\n-CT_GMP_5_0_2_or_later=y\n-CT_GMP_VERSION=\"6.0.0a\"\n-CT_MPFR_V_3_1_3=y\n-# CT_MPFR_V_3_1_2 is not set\n-# CT_MPFR_V_3_1_0 is not set\n-# CT_MPFR_V_3_0_1 is not set\n-# CT_MPFR_V_3_0_0 is not set\n-# CT_MPFR_V_2_4_2 is not set\n-# CT_MPFR_V_2_4_1 is not set\n-# CT_MPFR_V_2_4_0 is not set\n-CT_MPFR_VERSION=\"3.1.3\"\n-CT_ISL_V_0_14=y\n-# CT_ISL_V_0_12_2 is not set\n-CT_ISL_V_0_14_or_later=y\n-CT_ISL_V_0_12_or_later=y\n-CT_ISL_VERSION=\"0.14\"\n-# CT_CLOOG_V_0_18_4 is not set\n-# CT_CLOOG_V_0_18_1 is not set\n-# CT_CLOOG_V_0_18_0 is not set\n-CT_MPC_V_1_0_3=y\n-# CT_MPC_V_1_0_2 is not set\n-# CT_MPC_V_1_0_1 is not set\n-# CT_MPC_V_1_0 is not set\n-# CT_MPC_V_0_9 is not set\n-# CT_MPC_V_0_8_2 is not set\n-# CT_MPC_V_0_8_1 is not set\n-# CT_MPC_V_0_7 is not set\n-CT_MPC_VERSION=\"1.0.3\"\n-\n-#\n-# Companion libraries common options\n-#\n-# CT_COMPLIBS_CHECK is not set\n+CT_NCURSES=y\n+CT_ZLIB=y\n \n #\n # Companion tools\n #\n-\n-#\n-# READ HELP before you say 'Y' below !!!\n-#\n-# CT_COMP_TOOLS is not set\n+# CT_COMP_TOOLS_FOR_HOST is not set\n+# CT_COMP_TOOLS_AUTOCONF is not set\n+# CT_COMP_TOOLS_AUTOMAKE is not set\n+# CT_COMP_TOOLS_BISON is not set\n+# CT_COMP_TOOLS_DTC is not set\n+# CT_COMP_TOOLS_LIBTOOL is not set\n+# CT_COMP_TOOLS_M4 is not set\n+# CT_COMP_TOOLS_MAKE is not set\n+CT_ALL_COMP_TOOLS_CHOICES=\"AUTOCONF AUTOMAKE BISON DTC LIBTOOL M4 MAKE\""}, {"sha": "871d5225c0f714e035a0d97c7c2d841acfa09431", "filename": "src/ci/docker/dist-armhf-linux/patches/glibc/ports-2.16.0/001-arm-libgcc_s_resume-used.patch", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9f6b96e461003853bf36052cfaf79b12e1c35413/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "raw_url": "https://github.com/rust-lang/rust/raw/9f6b96e461003853bf36052cfaf79b12e1c35413/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch?ref=9f6b96e461003853bf36052cfaf79b12e1c35413", "patch": "@@ -1,48 +0,0 @@\n-commit bdb24c2851fd5f0ad9b82d7ea1db911d334b02d2\n-Author: Joseph Myers <joseph@codesourcery.com>\n-Date:   Tue May 20 21:27:13 2014 +0000\n-\n-    Fix ARM build with GCC trunk.\n-    \n-    sysdeps/unix/sysv/linux/arm/unwind-resume.c and\n-    sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c have static\n-    variables that are written in C code but only read from toplevel asms.\n-    Current GCC trunk now optimizes away such apparently write-only static\n-    variables, so causing a build failure.  This patch marks those\n-    variables with __attribute_used__ to avoid that optimization.\n-    \n-    Tested that this fixes the build for ARM.\n-    \n-            * sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c\n-            (libgcc_s_resume): Use __attribute_used__.\n-            * sysdeps/unix/sysv/linux/arm/unwind-resume.c (libgcc_s_resume):\n-            Likewise.\n-\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-index 29e2c2b00b04..e848bfeffdcb 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-@@ -22,7 +22,8 @@\n- #include <pthreadP.h>\n- \n- static void *libgcc_s_handle;\n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- static _Unwind_Reason_Code (*libgcc_s_forcedunwind)\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-index 285b99b5ed0d..48d00fc83641 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-@@ -20,7 +20,8 @@\n- #include <stdio.h>\n- #include <unwind.h>\n- \n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- "}, {"sha": "f42a2bd8122d7702e164a74e0b05981bf8457d4e", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -3,8 +3,8 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-COPY dist-armv7-linux/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n+COPY scripts/crosstool-ng-1.24.sh /scripts/\n+RUN sh /scripts/crosstool-ng-1.24.sh\n \n COPY scripts/rustbuild-setup.sh /scripts/\n RUN sh /scripts/rustbuild-setup.sh"}, {"sha": "4ac5e23d683eb3eb6cf2541e7928b5b69e78780d", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -72,6 +72,9 @@ RUN ./install-mips-musl.sh\n COPY dist-various-1/install-mipsel-musl.sh /build\n RUN ./install-mipsel-musl.sh\n \n+COPY dist-various-1/install-aarch64-none-elf.sh /build\n+RUN ./install-aarch64-none-elf.sh\n+\n # Suppress some warnings in the openwrt toolchains we downloaded\n ENV STAGING_DIR=/tmp\n \n@@ -140,6 +143,8 @@ ENV TARGETS=$TARGETS,armv5te-unknown-linux-gnueabi\n ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n+ENV TARGETS=$TARGETS,aarch64-unknown-none\n+ENV TARGETS=$TARGETS,aarch64-unknown-none-softfloat\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n ENV TARGETS=$TARGETS,x86_64-unknown-redox\n ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n@@ -178,6 +183,10 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_armv7a_none_eabihf=arm-none-eabi-gcc \\\n     CFLAGS_armv7a_none_eabi=-march=armv7-a \\\n     CFLAGS_armv7a_none_eabihf=-march=armv7-a+vfpv3 \\\n+    CC_aarch64_unknown_none_softfloat=aarch64-none-elf-gcc \\\n+    CFLAGS_aarch64_unknown_none_softfloat=-mstrict-align -march=armv8-a+nofp+nosimd \\\n+    CC_aarch64_unknown_none=aarch64-none-elf-gcc \\\n+    CFLAGS_aarch64_unknown_none=-mstrict-align -march=armv8-a+fp+simd \\\n     CC_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-gcc \\\n     AR_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-ar \\\n     CXX_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-g++ \\"}, {"sha": "d72976c28584225902eeed7ede849610ce3ee586", "filename": "src/ci/docker/dist-various-1/install-aarch64-none-elf.sh", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-aarch64-none-elf.sh", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-aarch64-none-elf.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-aarch64-none-elf.sh?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -0,0 +1,6 @@\n+#!/usr/bin/env bash\n+\n+set -ex\n+\n+curl -L https://developer.arm.com/-/media/Files/downloads/gnu-a/9.2-2019.12/binrel/gcc-arm-9.2-2019.12-x86_64-aarch64-none-elf.tar.xz \\\n+| tar --extract --xz --strip 1 --directory /usr/local"}, {"sha": "fb067a79a5c85c93691cdf5244394982d465289f", "filename": "src/ci/docker/scripts/crosstool-ng-1.24.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fscripts%2Fcrosstool-ng-1.24.sh", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fdocker%2Fscripts%2Fcrosstool-ng-1.24.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fcrosstool-ng-1.24.sh?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/ci/docker/dist-armv7-linux/crosstool-ng.sh"}, {"sha": "813c35cb9d50229a1ae80bb8d421d40a1660c3b7", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -103,6 +103,7 @@ x--expand-yaml-anchors--remove:\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:\n           github_token: \"${{ secrets.github_token }}\"\n+        if: success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\n         <<: *step\n \n       - name: add extra environment variables"}, {"sha": "c8841f2841a2d26124319ddadd1b6a245f9a1856", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1 +1 @@\n-Subproject commit 6fb3705e5230311b096d47f7e2c91f9ce24393d0\n+Subproject commit c8841f2841a2d26124319ddadd1b6a245f9a1856"}, {"sha": "411197b0e77590c967e37e8f6ec681abd359afe8", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1 +1 @@\n-Subproject commit 9f797e65e6bcc79419975b17aff8e21c9adc039f\n+Subproject commit 411197b0e77590c967e37e8f6ec681abd359afe8"}, {"sha": "89dd146154474559536d5d4049a03831c501deea", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1 +1 @@\n-Subproject commit e2f11fe4d6a5ecb471c70323197da43c70cb96b6\n+Subproject commit 89dd146154474559536d5d4049a03831c501deea"}, {"sha": "edd2a7e687358712608896730c083cb76c7b401a", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1 +1 @@\n-Subproject commit cb369ae95ca36b841960182d26f6d5d9b2e3cc18\n+Subproject commit edd2a7e687358712608896730c083cb76c7b401a"}, {"sha": "8dc6257ce2e58b23278046cbc538d96f4adb809c", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -257,9 +257,8 @@ them in parallel. Increasing parallelism may speed up compile times, but may\n also produce slower code. Setting this to 1 may improve the performance of\n generated code, but may be slower to compile.\n \n-The default, if not specified, is 16. This flag is ignored if\n-[incremental](#incremental) is enabled, in which case an internal heuristic is\n-used to split the crate.\n+The default, if not specified, is 16 for non-incremental builds. For\n+incremental builds the default is 256 which allows caching to be more granular.\n \n ## remark\n "}, {"sha": "0cd56d0940451ab40a0391c193c685e7b333342c", "filename": "src/doc/unstable-book/book.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fdoc%2Funstable-book%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fdoc%2Funstable-book%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fbook.toml?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,3 +1,6 @@\n [book]\n title = \"The Rust Unstable Book\"\n author = \"The Rust Community\"\n+\n+[output.html]\n+git-repository-url = \"https://github.com/rust-lang/rust/tree/master/src/doc/unstable-book\""}, {"sha": "7ebd8054ba0b0d19361365675332ba55b1d32eb2", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 150, "deletions": 86, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -6,73 +6,78 @@ The tracking issue for this feature is: [#39699](https://github.com/rust-lang/ru\n \n This feature allows for use of one of following sanitizers:\n \n-* [AddressSanitizer][clang-asan] a faster memory error detector. Can\n-  detect out-of-bounds access to heap, stack, and globals, use after free, use\n-  after return, double free, invalid free, memory leaks.\n+* [AddressSanitizer][clang-asan] a fast memory error detector.\n * [LeakSanitizer][clang-lsan] a run-time memory leak detector.\n * [MemorySanitizer][clang-msan] a detector of uninitialized reads.\n * [ThreadSanitizer][clang-tsan] a fast data race detector.\n \n-To enable a sanitizer compile with `-Zsanitizer=...` option, where value is one\n-of `address`, `leak`, `memory` or `thread`.\n+To enable a sanitizer compile with `-Zsanitizer=address`, `-Zsanitizer=leak`,\n+`-Zsanitizer=memory` or `-Zsanitizer=thread`. Only a single sanitizer can be\n+enabled at a time.\n \n-# Examples\n+# AddressSanitizer\n \n-This sections show various issues that can be detected with sanitizers.  For\n-simplicity, the examples are prepared under assumption that optimization level\n-used is zero.\n+AddressSanitizer is a memory error detector. It can detect the following types\n+of bugs:\n \n-## AddressSanitizer\n+* Out of bound accesses to heap, stack and globals\n+* Use after free\n+* Use after return (runtime flag `ASAN_OPTIONS=detect_stack_use_after_return=1`)\n+* Use after scope\n+* Double-free, invalid free\n+* Memory leaks\n+\n+AddressSanitizer is supported on the following targets:\n+\n+* `x86_64-apple-darwin`\n+* `x86_64-unknown-linux-gnu`\n+\n+AddressSanitizer works with non-instrumented code although it will impede its\n+ability to detect some bugs.  It is not expected to produce false positive\n+reports.\n+\n+## Examples\n \n Stack buffer overflow:\n \n-```shell\n-$ cat a.rs\n+```rust\n fn main() {\n     let xs = [0, 1, 2, 3];\n     let _y = unsafe { *xs.as_ptr().offset(4) };\n }\n-$ rustc -Zsanitizer=address a.rs\n-$ ./a\n-=================================================================\n-==10029==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffcc15f43d0 at pc 0x55f77dc015c5 bp 0x7ffcc15f4390 sp 0x7ffcc15f4388\n-READ of size 4 at 0x7ffcc15f43d0 thread T0\n-    #0 0x55f77dc015c4 in a::main::hab3bd2a745c2d0ac (/tmp/a+0xa5c4)\n-    #1 0x55f77dc01cdb in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::haa8c76d1faa7b7ca (/tmp/a+0xacdb)\n-    #2 0x55f77dc90f02 in std::rt::lang_start_internal::_$u7b$$u7b$closure$u7d$$u7d$::hfeb9a1aef9ac820d /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/rt.rs:48:12\n-    #3 0x55f77dc90f02 in std::panicking::try::do_call::h12f0919717b8e0a6 /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panicking.rs:288:39\n-    #4 0x55f77dc926c9 in __rust_maybe_catch_panic /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libpanic_unwind/lib.rs:80:7\n-    #5 0x55f77dc9197c in std::panicking::try::h413b21cdcd6cfd86 /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panicking.rs:267:12\n-    #6 0x55f77dc9197c in std::panic::catch_unwind::hc5cc8ef2fd73424d /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panic.rs:396:8\n-    #7 0x55f77dc9197c in std::rt::lang_start_internal::h2039f418ab92218f /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/rt.rs:47:24\n-    #8 0x55f77dc01c61 in std::rt::lang_start::ha905d28f6b61d691 (/tmp/a+0xac61)\n-    #9 0x55f77dc0163a in main (/tmp/a+0xa63a)\n-    #10 0x7f9b3cf5bbba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)\n-    #11 0x55f77dc01289 in _start (/tmp/a+0xa289)\n-\n-Address 0x7ffcc15f43d0 is located in stack of thread T0 at offset 48 in frame\n-    #0 0x55f77dc0135f in a::main::hab3bd2a745c2d0ac (/tmp/a+0xa35f)\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n+==37882==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe400e6250 at pc 0x5609a841fb20 bp 0x7ffe400e6210 sp 0x7ffe400e6208\n+READ of size 4 at 0x7ffe400e6250 thread T0\n+    #0 0x5609a841fb1f in example::main::h628ffc6626ed85b2 /.../src/main.rs:3:23\n+    ...\n+\n+Address 0x7ffe400e6250 is located in stack of thread T0 at offset 48 in frame\n+    #0 0x5609a841f8af in example::main::h628ffc6626ed85b2 /.../src/main.rs:1\n \n   This frame has 1 object(s):\n-    [32, 48) 'xs' <== Memory access at offset 48 overflows this variable\n+    [32, 48) 'xs' (line 2) <== Memory access at offset 48 overflows this variable\n HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n       (longjmp and C++ exceptions *are* supported)\n-SUMMARY: AddressSanitizer: stack-buffer-overflow (/tmp/a+0xa5c4) in a::main::hab3bd2a745c2d0ac\n+SUMMARY: AddressSanitizer: stack-buffer-overflow /.../src/main.rs:3:23 in example::main::h628ffc6626ed85b2\n Shadow bytes around the buggy address:\n-  0x1000182b6820: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6830: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6840: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6850: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6860: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-=>0x1000182b6870: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00\n-  0x1000182b6880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6890: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014bf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+=>0x100048014c40: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00\n+  0x100048014c50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c70: f1 f1 f1 f1 00 00 f3 f3 00 00 00 00 00 00 00 00\n+  0x100048014c80: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x100048014c90: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n Shadow byte legend (one shadow byte represents 8 application bytes):\n   Addressable:           00\n-  Partially addressable: 01 02 03 04 05 06 07 \n+  Partially addressable: 01 02 03 04 05 06 07\n   Heap left redzone:       fa\n   Freed heap region:       fd\n   Stack left redzone:      f1\n@@ -90,13 +95,12 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n   Left alloca redzone:     ca\n   Right alloca redzone:    cb\n   Shadow gap:              cc\n-==10029==ABORTING\n+==37882==ABORTING\n ```\n \n Use of a stack object after its scope has already ended:\n \n-```shell\n-$ cat b.rs\n+```rust\n static mut P: *mut usize = std::ptr::null_mut();\n \n fn main() {\n@@ -108,42 +112,38 @@ fn main() {\n         std::ptr::write_volatile(P, 123);\n     }\n }\n-$ rustc -Zsanitizer=address b.rs\n-$./b\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n =================================================================\n-==424427==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7fff67be6be0 at pc 0x5647a3ea4658 bp 0x7fff67be6b90 sp 0x7fff67be6b88\n-WRITE of size 8 at 0x7fff67be6be0 thread T0\n-    #0 0x5647a3ea4657 in core::ptr::write_volatile::h4b04601757d0376d (/tmp/b+0xb8657)\n-    #1 0x5647a3ea4432 in b::main::h5574a756e615c9cf (/tmp/b+0xb8432)\n-    #2 0x5647a3ea480b in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::hd57e7ee01866077e (/tmp/b+0xb880b)\n-    #3 0x5647a3eab412 in std::panicking::try::do_call::he0421ca82dd11ba3 (.llvm.8083791802951296215) (/tmp/b+0xbf412)\n-    #4 0x5647a3eacb26 in __rust_maybe_catch_panic (/tmp/b+0xc0b26)\n-    #5 0x5647a3ea5b66 in std::rt::lang_start_internal::h19bc96b28f670a64 (/tmp/b+0xb9b66)\n-    #6 0x5647a3ea4788 in std::rt::lang_start::h642d10b4b6965fb8 (/tmp/b+0xb8788)\n-    #7 0x5647a3ea449a in main (/tmp/b+0xb849a)\n-    #8 0x7fd1d18b3bba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)\n-    #9 0x5647a3df7299 in _start (/tmp/b+0xb299)\n-\n-Address 0x7fff67be6be0 is located in stack of thread T0 at offset 32 in frame\n-    #0 0x5647a3ea433f in b::main::h5574a756e615c9cf (/tmp/b+0xb833f)\n+==39249==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7ffc7ed3e1a0 at pc 0x55c98b262a8e bp 0x7ffc7ed3e050 sp 0x7ffc7ed3e048\n+WRITE of size 8 at 0x7ffc7ed3e1a0 thread T0\n+    #0 0x55c98b262a8d in core::ptr::write_volatile::he21f1df5a82f329a /.../src/rust/src/libcore/ptr/mod.rs:1048:5\n+    #1 0x55c98b262cd2 in example::main::h628ffc6626ed85b2 /.../src/main.rs:9:9\n+    ...\n+\n+Address 0x7ffc7ed3e1a0 is located in stack of thread T0 at offset 32 in frame\n+    #0 0x55c98b262bdf in example::main::h628ffc6626ed85b2 /.../src/main.rs:3\n \n   This frame has 1 object(s):\n-    [32, 40) 'x' <== Memory access at offset 32 is inside this variable\n+    [32, 40) 'x' (line 6) <== Memory access at offset 32 is inside this variable\n HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n       (longjmp and C++ exceptions *are* supported)\n-SUMMARY: AddressSanitizer: stack-use-after-scope (/tmp/b+0xb8657) in core::ptr::write_volatile::h4b04601757d0376d\n+SUMMARY: AddressSanitizer: stack-use-after-scope /.../src/rust/src/libcore/ptr/mod.rs:1048:5 in core::ptr::write_volatile::he21f1df5a82f329a\n Shadow bytes around the buggy address:\n-  0x10006cf74d20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-=>0x10006cf74d70: 00 00 00 00 00 00 00 00 f1 f1 f1 f1[f8]f3 f3 f3\n-  0x10006cf74d80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74da0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74db0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74dc0: f1 f1 f1 f1 00 f3 f3 f3 00 00 00 00 00 00 00 00\n+  0x10000fd9fbe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fbf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc00: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x10000fd9fc10: f8 f8 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+=>0x10000fd9fc30: f1 f1 f1 f1[f8]f3 f3 f3 00 00 00 00 00 00 00 00\n+  0x10000fd9fc40: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x10000fd9fc50: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc60: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3\n+  0x10000fd9fc70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc80: 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3 00 00 00 00\n Shadow byte legend (one shadow byte represents 8 application bytes):\n   Addressable:           00\n   Partially addressable: 01 02 03 04 05 06 07\n@@ -164,17 +164,26 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n   Left alloca redzone:     ca\n   Right alloca redzone:    cb\n   Shadow gap:              cc\n-==424427==ABORTING\n+==39249==ABORTING\n ```\n \n-## MemorySanitizer\n+# MemorySanitizer\n+\n+MemorySanitizer is detector of uninitialized reads. It is only supported on the\n+`x86_64-unknown-linux-gnu` target.\n+\n+MemorySanitizer requires all program code to be instrumented. C/C++ dependencies\n+need to be recompiled using Clang with `-fsanitize=memory` option. Failing to\n+achieve that will result in false positive reports.\n+\n+## Example\n \n-Use of uninitialized memory. Note that we are using `-Zbuild-std` to instrument\n-the standard library, and passing `-Zsanitizer-track-origins` to track the\n+Detecting the use of uninitialized memory. The `-Zbuild-std` flag rebuilds and\n+instruments the standard library, and is strictly necessary for the correct\n+operation of the tool. The `-Zsanitizer-track-origins` enables tracking of the\n origins of uninitialized memory:\n \n-```shell\n-$ cat src/main.rs\n+```rust\n use std::mem::MaybeUninit;\n \n fn main() {\n@@ -184,7 +193,9 @@ fn main() {\n         println!(\"{}\", a[2]);\n     }\n }\n+```\n \n+```shell\n $ export \\\n   CC=clang \\\n   CXX=clang++ \\\n@@ -193,7 +204,7 @@ $ export \\\n   RUSTFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins' \\\n   RUSTDOCFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins'\n $ cargo clean\n-$ cargo -Zbuild-std run --target x86_64-unknown-linux-gnu\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n ==9416==WARNING: MemorySanitizer: use-of-uninitialized-value\n     #0 0x560c04f7488a in core::fmt::num::imp::fmt_u64::haa293b0b098501ca $RUST/build/x86_64-unknown-linux-gnu/stage1/lib/rustlib/src/rust/src/libcore/fmt/num.rs:202:16\n ...\n@@ -205,6 +216,55 @@ $ cargo -Zbuild-std run --target x86_64-unknown-linux-gnu\n     #0 0x560c04b2bc50 in memory::main::hd2333c1899d997f5 $CWD/src/main.rs:3\n ```\n \n+# ThreadSanitizer\n+\n+ThreadSanitizer is a data race detection tool. It is supported on the following\n+targets:\n+\n+* `x86_64-apple-darwin`\n+* `x86_64-unknown-linux-gnu`\n+\n+To work correctly ThreadSanitizer needs to be \"aware\" of all synchronization\n+operations in a program. It generally achieves that through combination of\n+library interception (for example synchronization performed through\n+`pthread_mutex_lock` / `pthread_mutex_unlock`) and compile time instrumentation\n+(e.g. atomic operations). Using it without instrumenting all the program code\n+can lead to false positive reports.\n+\n+ThreadSanitizer does not support atomic fences `std::sync::atomic::fence`,\n+nor synchronization performed using inline assembly code.\n+\n+## Example\n+\n+```rust\n+static mut A: usize = 0;\n+\n+fn main() {\n+    let t = std::thread::spawn(|| {\n+        unsafe { A += 1 };\n+    });\n+    unsafe { A += 1 };\n+\n+    t.join().unwrap();\n+}\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=thread RUSTDOCFLAGS=-Zsanitizer=thread\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n+==================\n+WARNING: ThreadSanitizer: data race (pid=10574)\n+  Read of size 8 at 0x5632dfe3d030 by thread T1:\n+    #0 example::main::_$u7b$$u7b$closure$u7d$$u7d$::h23f64b0b2f8c9484 ../src/main.rs:5:18 (example+0x86cec)\n+    ...\n+\n+  Previous write of size 8 at 0x5632dfe3d030 by main thread:\n+    #0 example::main::h628ffc6626ed85b2 /.../src/main.rs:7:14 (example+0x868c8)\n+    ...\n+    #11 main <null> (example+0x86a1a)\n+\n+  Location is global 'example::A::h43ac149ddf992709' of size 8 at 0x5632dfe3d030 (example+0x000000bd9030)\n+```\n \n # Instrumentation of external dependencies and std\n \n@@ -231,6 +291,10 @@ In more practical terms when using cargo always remember to pass `--target`\n flag, so that rustflags will not be applied to build scripts and procedural\n macros.\n \n+# Symbolizing the Reports\n+\n+Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PATH`.\n+\n # Additional Information\n \n * [Sanitizers project page](https://github.com/google/sanitizers/wiki/)"}, {"sha": "7b865c9c679bc0f27d2de2d04eb5380f7365a937", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -87,7 +87,7 @@ Feedback on the design and usage is always appreciated!\n \n The `Generator` trait in `std::ops` currently looks like:\n \n-```\n+```rust\n # #![feature(arbitrary_self_types, generator_trait)]\n # use std::ops::GeneratorState;\n # use std::pin::Pin;\n@@ -107,7 +107,7 @@ point for executing the `Generator` itself.\n \n The return value of `resume`, `GeneratorState`, looks like:\n \n-```\n+```rust\n pub enum GeneratorState<Y, R> {\n     Yielded(Y),\n     Complete(R),"}, {"sha": "da01d9228f14e0ff12177e7694205a4f9a6ed095", "filename": "src/doc/unstable-book/src/library-features/llvm-asm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fllvm-asm.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fllvm-asm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fllvm-asm.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -86,7 +86,7 @@ llvm_asm!(\"xor %eax, %eax\" ::: \"eax\");\n \n Input and output operands follow the same format: `:\n \"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n-expressions must be mutable lvalues, or not yet assigned:\n+expressions must be mutable place, or not yet assigned:\n \n ```rust\n # #![feature(llvm_asm)]"}, {"sha": "a0ba47e1dbe313d1fd7683c4d73766d0dcce0b6a", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -15,9 +15,6 @@\n     os.path.join(os.path.dirname(__file__), '../test/ui/derives/'))\n \n TEMPLATE = \"\"\"\\\n-// FIXME: missing sysroot spans (#53081)\n-// ignore-i586-unknown-linux-gnu\n-// ignore-i586-unknown-linux-musl\n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n {error_deriving}"}, {"sha": "66575e3ef55170ae0e2ab5497a11287ea3f527d6", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2,7 +2,7 @@\n \n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n-use core::intrinsics::{min_align_of_val, size_of_val};\n+use core::intrinsics::{self, min_align_of_val, size_of_val};\n use core::ptr::{NonNull, Unique};\n use core::usize;\n \n@@ -165,11 +165,19 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        if layout.size() == 0 {\n-            Ok((layout.dangling(), 0))\n-        } else {\n-            unsafe { NonNull::new(alloc(layout)).ok_or(AllocErr).map(|p| (p, layout.size())) }\n+    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n+        unsafe {\n+            let size = layout.size();\n+            if size == 0 {\n+                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n+            } else {\n+                let raw_ptr = match init {\n+                    AllocInit::Uninitialized => alloc(layout),\n+                    AllocInit::Zeroed => alloc_zeroed(layout),\n+                };\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                Ok(MemoryBlock { ptr, size })\n+            }\n         }\n     }\n \n@@ -181,32 +189,71 @@ unsafe impl AllocRef for Global {\n     }\n \n     #[inline]\n-    unsafe fn realloc(\n+    unsafe fn grow(\n         &mut self,\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        match (layout.size(), new_size) {\n-            (0, 0) => Ok((layout.dangling(), 0)),\n-            (0, _) => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n-            (_, 0) => {\n-                self.dealloc(ptr, layout);\n-                Ok((layout.dangling(), 0))\n+        placement: ReallocPlacement,\n+        init: AllocInit,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        let size = layout.size();\n+        debug_assert!(\n+            new_size >= size,\n+            \"`new_size` must be greater than or equal to `memory.size()`\"\n+        );\n+\n+        if size == new_size {\n+            return Ok(MemoryBlock { ptr, size });\n+        }\n+\n+        match placement {\n+            ReallocPlacement::InPlace => Err(AllocErr),\n+            ReallocPlacement::MayMove if layout.size() == 0 => {\n+                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                self.alloc(new_layout, init)\n+            }\n+            ReallocPlacement::MayMove => {\n+                // `realloc` probably checks for `new_size > size` or something similar.\n+                intrinsics::assume(new_size > size);\n+                let ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                let memory =\n+                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n+                init.init_offset(memory, size);\n+                Ok(memory)\n             }\n-            (_, _) => NonNull::new(realloc(ptr.as_ptr(), layout, new_size))\n-                .ok_or(AllocErr)\n-                .map(|p| (p, new_size)),\n         }\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        if layout.size() == 0 {\n-            Ok((layout.dangling(), 0))\n-        } else {\n-            unsafe {\n-                NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n+    unsafe fn shrink(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+        placement: ReallocPlacement,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        let size = layout.size();\n+        debug_assert!(\n+            new_size <= size,\n+            \"`new_size` must be smaller than or equal to `memory.size()`\"\n+        );\n+\n+        if size == new_size {\n+            return Ok(MemoryBlock { ptr, size });\n+        }\n+\n+        match placement {\n+            ReallocPlacement::InPlace => Err(AllocErr),\n+            ReallocPlacement::MayMove if new_size == 0 => {\n+                self.dealloc(ptr, layout);\n+                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n+            }\n+            ReallocPlacement::MayMove => {\n+                // `realloc` probably checks for `new_size < size` or something similar.\n+                intrinsics::assume(new_size < size);\n+                let ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n             }\n         }\n     }\n@@ -218,14 +265,10 @@ unsafe impl AllocRef for Global {\n #[lang = \"exchange_malloc\"]\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n-    if size == 0 {\n-        align as *mut u8\n-    } else {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        match Global.alloc(layout) {\n-            Ok((ptr, _)) => ptr.as_ptr(),\n-            Err(_) => handle_alloc_error(layout),\n-        }\n+    let layout = Layout::from_size_align_unchecked(size, align);\n+    match Global.alloc(layout, AllocInit::Uninitialized) {\n+        Ok(memory) => memory.ptr.as_ptr(),\n+        Err(_) => handle_alloc_error(layout),\n     }\n }\n \n@@ -239,11 +282,8 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n     let size = size_of_val(ptr.as_ref());\n     let align = min_align_of_val(ptr.as_ref());\n-    // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n-    if size != 0 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        Global.dealloc(ptr.cast().into(), layout);\n-    }\n+    let layout = Layout::from_size_align_unchecked(size, align);\n+    Global.dealloc(ptr.cast().into(), layout)\n }\n \n /// Abort on memory allocation error or failure."}, {"sha": "1ad40eca93b69e8c56c9648b3c44a95c9ac7aa9a", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -8,16 +8,17 @@ use test::Bencher;\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let (ptr, _) =\n-            Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let memory = Global\n+            .alloc(layout.clone(), AllocInit::Zeroed)\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n \n-        let mut i = ptr.cast::<u8>().as_ptr();\n+        let mut i = memory.ptr.cast::<u8>().as_ptr();\n         let end = i.add(layout.size());\n         while i < end {\n             assert_eq!(*i, 0);\n             i = i.offset(1);\n         }\n-        Global.dealloc(ptr, layout);\n+        Global.dealloc(memory.ptr, layout);\n     }\n }\n "}, {"sha": "2518506b9b5f3915996f9bc84fbc0f688c1e05af", "filename": "src/liballoc/benches/btree/set.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -62,6 +62,22 @@ pub fn clone_100_and_clear(b: &mut Bencher) {\n     b.iter(|| src.clone().clear())\n }\n \n+#[bench]\n+pub fn clone_100_and_drain_all(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| src.clone().drain_filter(|_| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_100_and_drain_half(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(set.len(), 100 / 2);\n+    })\n+}\n+\n #[bench]\n pub fn clone_100_and_into_iter(b: &mut Bencher) {\n     let src = pos(100);\n@@ -115,6 +131,22 @@ pub fn clone_10k_and_clear(b: &mut Bencher) {\n     b.iter(|| src.clone().clear())\n }\n \n+#[bench]\n+pub fn clone_10k_and_drain_all(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| src.clone().drain_filter(|_| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 10_000 / 2);\n+        assert_eq!(set.len(), 10_000 / 2);\n+    })\n+}\n+\n #[bench]\n pub fn clone_10k_and_into_iter(b: &mut Bencher) {\n     let src = pos(10_000);"}, {"sha": "f31717d9fd517e76b860364f430e7170d2194822", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,3 +1,4 @@\n+#![feature(btree_drain_filter)]\n #![feature(map_first_last)]\n #![feature(repr_simd)]\n #![feature(test)]"}, {"sha": "5406956a5288657a8fd70598d05208d364bd1c78", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -143,10 +143,9 @@ use core::ops::{\n };\n use core::pin::Pin;\n use core::ptr::{self, NonNull, Unique};\n-use core::slice;\n use core::task::{Context, Poll};\n \n-use crate::alloc::{self, AllocRef, Global};\n+use crate::alloc::{self, AllocInit, AllocRef, Global};\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n use crate::vec::Vec;\n@@ -196,14 +195,12 @@ impl<T> Box<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n-        unsafe {\n-            let ptr = if layout.size() == 0 {\n-                NonNull::dangling()\n-            } else {\n-                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).0.cast()\n-            };\n-            Box::from_raw(ptr.as_ptr())\n-        }\n+        let ptr = Global\n+            .alloc(layout, AllocInit::Uninitialized)\n+            .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+            .ptr\n+            .cast();\n+        unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n \n     /// Constructs a new `Box` with uninitialized contents, with the memory\n@@ -226,11 +223,13 @@ impl<T> Box<T> {\n     /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {\n-        unsafe {\n-            let mut uninit = Self::new_uninit();\n-            ptr::write_bytes::<T>(uninit.as_mut_ptr(), 0, 1);\n-            uninit\n-        }\n+        let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = Global\n+            .alloc(layout, AllocInit::Zeroed)\n+            .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+            .ptr\n+            .cast();\n+        unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n \n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n@@ -265,15 +264,7 @@ impl<T> Box<[T]> {\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n-        let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n-        unsafe {\n-            let ptr = if layout.size() == 0 {\n-                NonNull::dangling()\n-            } else {\n-                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).0.cast()\n-            };\n-            Box::from_raw(slice::from_raw_parts_mut(ptr.as_ptr(), len))\n-        }\n+        unsafe { RawVec::with_capacity(len).into_box(len) }\n     }\n }\n \n@@ -778,7 +769,7 @@ impl<T: Copy> From<&[T]> for Box<[T]> {\n         let buf = RawVec::with_capacity(len);\n         unsafe {\n             ptr::copy_nonoverlapping(slice.as_ptr(), buf.ptr(), len);\n-            buf.into_box()\n+            buf.into_box(slice.len()).assume_init()\n         }\n     }\n }"}, {"sha": "bbeced1751d1451830e5c3673f1489a6b6953de3", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 200, "deletions": 10, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1256,6 +1256,48 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         right\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, the element is removed from the map and yielded.\n+    /// If the closure returns false, or panics, the element remains in the map and will not be\n+    /// yielded.\n+    ///\n+    /// Note that `drain_filter` lets you mutate every value in the filter closure, regardless of\n+    /// whether you choose to keep or remove it.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// elements will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more elements will be subjected to the closure\n+    /// if a panic occurs in the closure, or a panic occurs while dropping an element,\n+    /// or if the `DrainFilter` value is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a map into even and odd keys, reusing the original map:\n+    ///\n+    /// ```\n+    /// #![feature(btree_drain_filter)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n+    /// let evens: BTreeMap<_, _> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n+    /// let odds = map;\n+    /// assert_eq!(evens.keys().copied().collect::<Vec<_>>(), vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds.keys().copied().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n+    /// ```\n+    #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        DrainFilter { pred, inner: self.drain_filter_inner() }\n+    }\n+    pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n+        let front = self.root.as_mut().map(|r| r.as_mut().first_leaf_edge());\n+        DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n+    }\n+\n     /// Calculates the number of elements if it is incorrect.\n     fn recalc_length(&mut self) {\n         fn dfs<'a, K, V>(node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>) -> usize\n@@ -1653,6 +1695,124 @@ impl<K, V> Clone for Values<'_, K, V> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on BTreeMap.\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+pub struct DrainFilter<'a, K, V, F>\n+where\n+    K: 'a + Ord, // This Ord bound should be removed before stabilization.\n+    V: 'a,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    pred: F,\n+    inner: DrainFilterInner<'a, K, V>,\n+}\n+pub(super) struct DrainFilterInner<'a, K, V>\n+where\n+    K: 'a + Ord,\n+    V: 'a,\n+{\n+    length: &'a mut usize,\n+    cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, K, V, F> Drop for DrainFilter<'a, K, V, F>\n+where\n+    K: 'a + Ord,\n+    V: 'a,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    fn drop(&mut self) {\n+        self.for_each(drop);\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, K, V, F> fmt::Debug for DrainFilter<'a, K, V, F>\n+where\n+    K: 'a + fmt::Debug + Ord,\n+    V: 'a + fmt::Debug,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\").field(&self.inner.peek()).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, K, V, F> Iterator for DrainFilter<'a, K, V, F>\n+where\n+    K: 'a + Ord,\n+    V: 'a,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    type Item = (K, V);\n+\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next(&mut self.pred)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+impl<'a, K, V> DrainFilterInner<'a, K, V>\n+where\n+    K: 'a + Ord,\n+    V: 'a,\n+{\n+    /// Allow Debug implementations to predict the next element.\n+    pub(super) fn peek(&self) -> Option<(&K, &V)> {\n+        let edge = self.cur_leaf_edge.as_ref()?;\n+        edge.reborrow().next_kv().ok().map(|kv| kv.into_kv())\n+    }\n+\n+    unsafe fn next_kv(\n+        &mut self,\n+    ) -> Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>> {\n+        let edge = self.cur_leaf_edge.as_ref()?;\n+        ptr::read(edge).next_kv().ok()\n+    }\n+\n+    /// Implementation of a typical `DrainFilter::next` method, given the predicate.\n+    pub(super) fn next<F>(&mut self, pred: &mut F) -> Option<(K, V)>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        while let Some(kv) = unsafe { self.next_kv() } {\n+            let (k, v) = unsafe { ptr::read(&kv) }.into_kv_mut();\n+            if pred(k, v) {\n+                *self.length -= 1;\n+                let (k, v, leaf_edge_location) = kv.remove_kv_tracking();\n+                // `remove_kv_tracking` has either preserved or invalidated `self.cur_leaf_edge`\n+                if let Some(node) = leaf_edge_location {\n+                    match search::search_tree(node, &k) {\n+                        search::SearchResult::Found(_) => unreachable!(),\n+                        search::SearchResult::GoDown(leaf) => self.cur_leaf_edge = Some(leaf),\n+                    }\n+                };\n+                return Some((k, v));\n+            }\n+            self.cur_leaf_edge = Some(kv.next_leaf_edge());\n+        }\n+        None\n+    }\n+\n+    /// Implementation of a typical `DrainFilter::size_hint` method.\n+    pub(super) fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(*self.length))\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F>\n+where\n+    K: Ord,\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+}\n+\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n@@ -2531,12 +2691,31 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let (small_leaf, old_key, old_val) = match self.handle.force() {\n+        let (old_key, old_val, _) = self.handle.remove_kv_tracking();\n+        (old_key, old_val)\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n+    /// Removes a key/value-pair from the map, and returns that pair, as well as\n+    /// the whereabouts of the leaf edge corresponding to that former pair:\n+    /// if None is returned, the leaf edge is still the left leaf edge of the KV handle;\n+    /// if a node is returned, it heads the subtree where the leaf edge may be found.\n+    fn remove_kv_tracking(\n+        self,\n+    ) -> (K, V, Option<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>>) {\n+        let mut levels_down_handled: isize;\n+        let (small_leaf, old_key, old_val) = match self.force() {\n             Leaf(leaf) => {\n+                levels_down_handled = 1; // handled at same level, but affects only the right side\n                 let (hole, old_key, old_val) = leaf.remove();\n                 (hole.into_node(), old_key, old_val)\n             }\n             Internal(mut internal) => {\n+                // Replace the location freed in the internal node with the next KV,\n+                // and remove that next KV from its leaf.\n+                levels_down_handled = unsafe { ptr::read(&internal).into_node().height() } as isize;\n+\n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n \n@@ -2556,27 +2735,39 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         let mut cur_node = small_leaf.forget_type();\n         while cur_node.len() < node::MIN_LEN {\n             match handle_underfull_node(cur_node) {\n-                AtRoot => break,\n+                AtRoot(root) => {\n+                    cur_node = root;\n+                    break;\n+                }\n                 EmptyParent(_) => unreachable!(),\n                 Merged(parent) => {\n+                    levels_down_handled -= 1;\n                     if parent.len() == 0 {\n                         // We must be at the root\n-                        parent.into_root_mut().pop_level();\n+                        let root = parent.into_root_mut();\n+                        root.pop_level();\n+                        cur_node = root.as_mut();\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n                     }\n                 }\n-                Stole(_) => break,\n+                Stole(internal_node) => {\n+                    levels_down_handled -= 1;\n+                    cur_node = internal_node.forget_type();\n+                    // This internal node might be underfull, but only if it's the root.\n+                    break;\n+                }\n             }\n         }\n \n-        (old_key, old_val)\n+        let leaf_edge_location = if levels_down_handled > 0 { None } else { Some(cur_node) };\n+        (old_key, old_val, leaf_edge_location)\n     }\n }\n \n enum UnderflowResult<'a, K, V> {\n-    AtRoot,\n+    AtRoot(NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>),\n     EmptyParent(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n     Merged(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n     Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n@@ -2585,10 +2776,9 @@ enum UnderflowResult<'a, K, V> {\n fn handle_underfull_node<K, V>(\n     node: NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal>,\n ) -> UnderflowResult<'_, K, V> {\n-    let parent = if let Ok(parent) = node.ascend() {\n-        parent\n-    } else {\n-        return AtRoot;\n+    let parent = match node.ascend() {\n+        Ok(parent) => parent,\n+        Err(root) => return AtRoot(root),\n     };\n \n     let (is_left, mut handle) = match parent.left_kv() {"}, {"sha": "11c1429957326345ec5bb25215184583a6183359", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1142,7 +1142,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             (*left_node.as_leaf_mut()).len += right_len as u16 + 1;\n \n-            if self.node.height > 1 {\n+            let layout = if self.node.height > 1 {\n                 ptr::copy_nonoverlapping(\n                     right_node.cast_unchecked().as_internal().edges.as_ptr(),\n                     left_node\n@@ -1159,10 +1159,11 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                         .correct_parent_link();\n                 }\n \n-                Global.dealloc(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n+                Layout::new::<InternalNode<K, V>>()\n             } else {\n-                Global.dealloc(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n-            }\n+                Layout::new::<LeafNode<K, V>>()\n+            };\n+            Global.dealloc(right_node.node.cast(), layout);\n \n             Handle::new_edge(self.node, self.idx)\n         }"}, {"sha": "0b02223def4f85dc76c4b894e2cd5c94d222f69a", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 98, "deletions": 3, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -8,8 +8,8 @@ use core::fmt::{self, Debug};\n use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::ops::{BitAnd, BitOr, BitXor, RangeBounds, Sub};\n \n+use super::map::{BTreeMap, Keys};\n use super::Recover;\n-use crate::collections::btree_map::{self, BTreeMap, Keys};\n \n // FIXME(conventions): implement bounded iterators\n \n@@ -102,7 +102,7 @@ impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n-    iter: btree_map::IntoIter<T, ()>,\n+    iter: super::map::IntoIter<T, ()>,\n }\n \n /// An iterator over a sub-range of items in a `BTreeSet`.\n@@ -115,7 +115,7 @@ pub struct IntoIter<T> {\n #[derive(Debug)]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, T: 'a> {\n-    iter: btree_map::Range<'a, T, ()>,\n+    iter: super::map::Range<'a, T, ()>,\n }\n \n /// Core of SymmetricDifference and Union.\n@@ -944,6 +944,41 @@ impl<T: Ord> BTreeSet<T> {\n     {\n         BTreeSet { map: self.map.split_off(key) }\n     }\n+\n+    /// Creates an iterator which uses a closure to determine if a value should be removed.\n+    ///\n+    /// If the closure returns true, then the value is removed and yielded.\n+    /// If the closure returns false, the value will remain in the list and will not be yielded\n+    /// by the iterator.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// values will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more values will be subjected to the closure\n+    /// if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the\n+    /// `DrainFilter` itself is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a set into even and odd values, reusing the original set:\n+    ///\n+    /// ```\n+    /// #![feature(btree_drain_filter)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set: BTreeSet<i32> = (0..8).collect();\n+    /// let evens: BTreeSet<_> = set.drain_filter(|v| v % 2 == 0).collect();\n+    /// let odds = set;\n+    /// assert_eq!(evens.into_iter().collect::<Vec<_>>(), vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n+    /// ```\n+    #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+    pub fn drain_filter<'a, F>(&'a mut self, pred: F) -> DrainFilter<'a, T, F>\n+    where\n+        F: 'a + FnMut(&T) -> bool,\n+    {\n+        DrainFilter { pred, inner: self.map.drain_filter_inner() }\n+    }\n }\n \n impl<T> BTreeSet<T> {\n@@ -1055,6 +1090,66 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on BTreeSet.\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+pub struct DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    pred: F,\n+    inner: super::map::DrainFilterInner<'a, T, ()>,\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, T, F> Drop for DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    fn drop(&mut self) {\n+        self.for_each(drop);\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, T, F> fmt::Debug for DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord + fmt::Debug,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\").field(&self.inner.peek().map(|(k, _)| k)).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, 'f, T, F> Iterator for DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord,\n+    F: 'a + 'f + FnMut(&T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        let pred = &mut self.pred;\n+        let mut mapped_pred = |k: &T, _v: &mut ()| pred(k);\n+        self.inner.next(&mut mapped_pred).map(|(k, _)| k)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, T, F> FusedIterator for DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]"}, {"sha": "94532521a9066150bf3452466625847e5ddcceea", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 153, "deletions": 52, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -959,6 +959,9 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     ///\n+    /// If [`make_contiguous`](#method.make_contiguous) was previously called, all elements\n+    /// of the `VecDeque` will be in the first slice and the second slice will be empty.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -989,6 +992,9 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     ///\n+    /// If [`make_contiguous`](#method.make_contiguous) was previously called, all elements\n+    /// of the `VecDeque` will be in the first slice and the second slice will be empty.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2044,6 +2050,148 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Rearranges the internal storage of this deque so it is one contiguous slice, which is then returned.\n+    ///\n+    /// This method does not allocate and does not change the order of the inserted elements.\n+    /// As it returns a mutable slice, this can be used to sort or binary search a deque.\n+    ///\n+    /// Once the internal storage is contiguous, the [`as_slices`](#method.as_slices) and\n+    /// [`as_mut_slices`](#method.as_mut_slices) methods will return the entire contents of the\n+    /// `VecDeque` in a single slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Sorting the content of a deque.\n+    ///\n+    /// ```\n+    /// #![feature(deque_make_contiguous)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::with_capacity(15);\n+    ///\n+    /// buf.push_back(2);\n+    /// buf.push_back(1);\n+    /// buf.push_front(3);\n+    ///\n+    /// // sorting the deque\n+    /// buf.make_contiguous().sort();\n+    /// assert_eq!(buf.as_slices(), (&[1, 2, 3] as &[_], &[] as &[_]));\n+    ///\n+    /// // sorting it in reverse order\n+    /// buf.make_contiguous().sort_by(|a, b| b.cmp(a));\n+    /// assert_eq!(buf.as_slices(), (&[3, 2, 1] as &[_], &[] as &[_]));\n+    /// ```\n+    ///\n+    /// Getting immutable access to the contiguous slice.\n+    ///\n+    /// ```rust\n+    /// #![feature(deque_make_contiguous)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    ///\n+    /// buf.push_back(2);\n+    /// buf.push_back(1);\n+    /// buf.push_front(3);\n+    ///\n+    /// buf.make_contiguous();\n+    /// if let (slice, &[]) = buf.as_slices() {\n+    ///     // we can now be sure that `slice` contains all elements of the deque,\n+    ///     // while still having immutable access to `buf`.\n+    ///     assert_eq!(buf.len(), slice.len());\n+    ///     assert_eq!(slice, &[3, 2, 1] as &[_]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"deque_make_contiguous\", issue = \"none\")]\n+    pub fn make_contiguous(&mut self) -> &mut [T] {\n+        if self.is_contiguous() {\n+            let tail = self.tail;\n+            let head = self.head;\n+            return unsafe { &mut self.buffer_as_mut_slice()[tail..head] };\n+        }\n+\n+        let buf = self.buf.ptr();\n+        let cap = self.cap();\n+        let len = self.len();\n+\n+        let free = self.tail - self.head;\n+        let tail_len = cap - self.tail;\n+\n+        if free >= tail_len {\n+            // there is enough free space to copy the tail in one go,\n+            // this means that we first shift the head backwards, and then\n+            // copy the tail to the correct position.\n+            //\n+            // from: DEFGH....ABC\n+            // to:   ABCDEFGH....\n+            unsafe {\n+                ptr::copy(buf, buf.add(tail_len), self.head);\n+                // ...DEFGH.ABC\n+                ptr::copy_nonoverlapping(buf.add(self.tail), buf, tail_len);\n+                // ABCDEFGH....\n+\n+                self.tail = 0;\n+                self.head = len;\n+            }\n+        } else if free >= self.head {\n+            // there is enough free space to copy the head in one go,\n+            // this means that we first shift the tail forwards, and then\n+            // copy the head to the correct position.\n+            //\n+            // from: FGH....ABCDE\n+            // to:   ...ABCDEFGH.\n+            unsafe {\n+                ptr::copy(buf.add(self.tail), buf.add(self.head), tail_len);\n+                // FGHABCDE....\n+                ptr::copy_nonoverlapping(buf, buf.add(self.head + tail_len), self.head);\n+                // ...ABCDEFGH.\n+\n+                self.tail = self.head;\n+                self.head = self.tail + len;\n+            }\n+        } else {\n+            // free is smaller than both head and tail,\n+            // this means we have to slowly \"swap\" the tail and the head.\n+            //\n+            // from: EFGHI...ABCD or HIJK.ABCDEFG\n+            // to:   ABCDEFGHI... or ABCDEFGHIJK.\n+            let mut left_edge: usize = 0;\n+            let mut right_edge: usize = self.tail;\n+            unsafe {\n+                // The general problem looks like this\n+                // GHIJKLM...ABCDEF - before any swaps\n+                // ABCDEFM...GHIJKL - after 1 pass of swaps\n+                // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n+                //                  - then restart the algorithm with a new (smaller) store\n+                // Sometimes the temp store is reached when the right edge is at the end\n+                // of the buffer - this means we've hit the right order with fewer swaps!\n+                // E.g\n+                // EF..ABCD\n+                // ABCDEF.. - after four only swaps we've finished\n+                while left_edge < len && right_edge != cap {\n+                    let mut right_offset = 0;\n+                    for i in left_edge..right_edge {\n+                        right_offset = (i - left_edge) % (cap - right_edge);\n+                        let src: isize = (right_edge + right_offset) as isize;\n+                        ptr::swap(buf.add(i), buf.offset(src));\n+                    }\n+                    let n_ops = right_edge - left_edge;\n+                    left_edge += n_ops;\n+                    right_edge += right_offset + 1;\n+                }\n+\n+                self.tail = 0;\n+                self.head = len;\n+            }\n+        }\n+\n+        let tail = self.tail;\n+        let head = self.head;\n+        unsafe { &mut self.buffer_as_mut_slice()[tail..head] }\n+    }\n+\n     /// Rotates the double-ended queue `mid` places to the left.\n     ///\n     /// Equivalently,\n@@ -2803,63 +2951,16 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// assert_eq!(vec, [8, 9, 1, 2, 3, 4]);\n     /// assert_eq!(vec.as_ptr(), ptr);\n     /// ```\n-    fn from(other: VecDeque<T>) -> Self {\n+    fn from(mut other: VecDeque<T>) -> Self {\n+        other.make_contiguous();\n+\n         unsafe {\n             let buf = other.buf.ptr();\n             let len = other.len();\n-            let tail = other.tail;\n-            let head = other.head;\n             let cap = other.cap();\n \n-            // Need to move the ring to the front of the buffer, as vec will expect this.\n-            if other.is_contiguous() {\n-                ptr::copy(buf.add(tail), buf, len);\n-            } else {\n-                if (tail - head) >= cmp::min(cap - tail, head) {\n-                    // There is enough free space in the centre for the shortest block so we can\n-                    // do this in at most three copy moves.\n-                    if (cap - tail) > head {\n-                        // right hand block is the long one; move that enough for the left\n-                        ptr::copy(buf.add(tail), buf.add(tail - head), cap - tail);\n-                        // copy left in the end\n-                        ptr::copy(buf, buf.add(cap - head), head);\n-                        // shift the new thing to the start\n-                        ptr::copy(buf.add(tail - head), buf, len);\n-                    } else {\n-                        // left hand block is the long one, we can do it in two!\n-                        ptr::copy(buf, buf.add(cap - tail), head);\n-                        ptr::copy(buf.add(tail), buf, cap - tail);\n-                    }\n-                } else {\n-                    // Need to use N swaps to move the ring\n-                    // We can use the space at the end of the ring as a temp store\n-\n-                    let mut left_edge: usize = 0;\n-                    let mut right_edge: usize = tail;\n-\n-                    // The general problem looks like this\n-                    // GHIJKLM...ABCDEF - before any swaps\n-                    // ABCDEFM...GHIJKL - after 1 pass of swaps\n-                    // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n-                    //                  - then restart the algorithm with a new (smaller) store\n-                    // Sometimes the temp store is reached when the right edge is at the end\n-                    // of the buffer - this means we've hit the right order with fewer swaps!\n-                    // E.g\n-                    // EF..ABCD\n-                    // ABCDEF.. - after four only swaps we've finished\n-\n-                    while left_edge < len && right_edge != cap {\n-                        let mut right_offset = 0;\n-                        for i in left_edge..right_edge {\n-                            right_offset = (i - left_edge) % (cap - right_edge);\n-                            let src: isize = (right_edge + right_offset) as isize;\n-                            ptr::swap(buf.add(i), buf.offset(src));\n-                        }\n-                        let n_ops = right_edge - left_edge;\n-                        left_edge += n_ops;\n-                        right_edge += right_offset + 1;\n-                    }\n-                }\n+            if other.head != 0 {\n+                ptr::copy(buf.add(other.tail), buf, len);\n             }\n             let out = Vec::from_raw_parts(buf, len, cap);\n             mem::forget(other);"}, {"sha": "8ef5ec78e056e8a2d72b3402a4d73503b0e4f3c2", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,6 +1,6 @@\n use super::*;\n \n-use ::test;\n+use test;\n \n #[bench]\n #[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n@@ -130,6 +130,87 @@ fn test_insert() {\n     }\n }\n \n+#[test]\n+fn make_contiguous_big_tail() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 0..3 {\n+        tester.push_back(i);\n+    }\n+\n+    for i in 3..10 {\n+        tester.push_front(i);\n+    }\n+\n+    // 012......9876543\n+    assert_eq!(tester.capacity(), 15);\n+    assert_eq!((&[9, 8, 7, 6, 5, 4, 3] as &[_], &[0, 1, 2] as &[_]), tester.as_slices());\n+\n+    let expected_start = tester.head;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!((&[9, 8, 7, 6, 5, 4, 3, 0, 1, 2] as &[_], &[] as &[_]), tester.as_slices());\n+}\n+\n+#[test]\n+fn make_contiguous_big_head() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 0..8 {\n+        tester.push_back(i);\n+    }\n+\n+    for i in 8..10 {\n+        tester.push_front(i);\n+    }\n+\n+    // 01234567......98\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!((&[9, 8, 0, 1, 2, 3, 4, 5, 6, 7] as &[_], &[] as &[_]), tester.as_slices());\n+}\n+\n+#[test]\n+fn make_contiguous_small_free() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 'A' as u8..'I' as u8 {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in 'I' as u8..'N' as u8 {\n+        tester.push_front(i as char);\n+    }\n+\n+    // ABCDEFGH...MLKJI\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(\n+        (&['M', 'L', 'K', 'J', 'I', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] as &[_], &[] as &[_]),\n+        tester.as_slices()\n+    );\n+\n+    tester.clear();\n+    for i in 'I' as u8..'N' as u8 {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in 'A' as u8..'I' as u8 {\n+        tester.push_front(i as char);\n+    }\n+\n+    // IJKLM...HGFEDCBA\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(\n+        (&['H', 'G', 'F', 'E', 'D', 'C', 'B', 'A', 'I', 'J', 'K', 'L', 'M'] as &[_], &[] as &[_]),\n+        tester.as_slices()\n+    );\n+}\n+\n #[test]\n fn test_remove() {\n     // This test checks that every single combination of tail position, length, and"}, {"sha": "121c1cde548cbb3746ddeab2061eea6bccd9ace5", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -100,6 +100,7 @@\n #![feature(lang_items)]\n #![feature(libc)]\n #![cfg_attr(not(bootstrap), feature(negative_impls))]\n+#![feature(new_uninit)]\n #![feature(nll)]\n #![feature(optin_builtin_traits)]\n #![feature(pattern)]"}, {"sha": "4bc0c3a079d5ca80451a8a68458206be5d92a10a", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -36,6 +36,9 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable(box_syntax)]\n macro_rules! vec {\n+    () => (\n+        $crate::vec::Vec::new()\n+    );\n     ($elem:expr; $n:expr) => (\n         $crate::vec::from_elem($elem, $n)\n     );\n@@ -51,6 +54,9 @@ macro_rules! vec {\n // NB see the slice::hack module in slice.rs for more information\n #[cfg(test)]\n macro_rules! vec {\n+    () => (\n+        $crate::vec::Vec::new()\n+    );\n     ($elem:expr; $n:expr) => (\n         $crate::vec::from_elem($elem, $n)\n     );"}, {"sha": "2bf40490e78190167af519e93a61ae321469dc9e", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 263, "deletions": 392, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,13 +1,19 @@\n #![unstable(feature = \"raw_vec_internals\", reason = \"implementation detail\", issue = \"none\")]\n #![doc(hidden)]\n \n+use core::alloc::MemoryBlock;\n use core::cmp;\n-use core::mem;\n+use core::mem::{self, MaybeUninit};\n use core::ops::Drop;\n-use core::ptr::{self, NonNull, Unique};\n+use core::ptr::{NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{handle_alloc_error, AllocErr, AllocRef, Global, Layout};\n+use crate::alloc::{\n+    handle_alloc_error, AllocErr,\n+    AllocInit::{self, *},\n+    AllocRef, Global, Layout,\n+    ReallocPlacement::{self, *},\n+};\n use crate::boxed::Box;\n use crate::collections::TryReserveError::{self, *};\n \n@@ -21,81 +27,26 @@ mod tests;\n ///\n /// * Produces `Unique::empty()` on zero-sized types.\n /// * Produces `Unique::empty()` on zero-length allocations.\n+/// * Avoids freeing `Unique::empty()`.\n /// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics).\n /// * Guards against 32-bit systems allocating more than isize::MAX bytes.\n /// * Guards against overflowing your length.\n-/// * Aborts on OOM or calls `handle_alloc_error` as applicable.\n-/// * Avoids freeing `Unique::empty()`.\n+/// * Calls `handle_alloc_error` for fallible allocations.\n /// * Contains a `ptr::Unique` and thus endows the user with all related benefits.\n+/// * Uses the excess returned from the allocator to use the largest available capacity.\n ///\n /// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n /// free its memory, but it *won't* try to drop its contents. It is up to the user of `RawVec`\n /// to handle the actual things *stored* inside of a `RawVec`.\n ///\n-/// Note that a `RawVec` always forces its capacity to be `usize::MAX` for zero-sized types.\n-/// This enables you to use capacity-growing logic catch the overflows in your length\n-/// that might occur with zero-sized types.\n-///\n-/// The above means that you need to be careful when round-tripping this type with a\n-/// `Box<[T]>`, since `capacity()` won't yield the length. However, `with_capacity`,\n-/// `shrink_to_fit`, and `from_box` will actually set `RawVec`'s private capacity\n-/// field. This allows zero-sized types to not be special-cased by consumers of\n-/// this type.\n+/// Note that the excess of a zero-sized types is always infinite, so `capacity()` always returns\n+/// `usize::MAX`. This means that you need to be careful when round-tripping this type with a\n+/// `Box<[T]>`, since `capacity()` won't yield the length.\n #[allow(missing_debug_implementations)]\n pub struct RawVec<T, A: AllocRef = Global> {\n     ptr: Unique<T>,\n     cap: usize,\n-    a: A,\n-}\n-\n-impl<T, A: AllocRef> RawVec<T, A> {\n-    /// Like `new`, but parameterized over the choice of allocator for\n-    /// the returned `RawVec`.\n-    pub const fn new_in(a: A) -> Self {\n-        let cap = if mem::size_of::<T>() == 0 { core::usize::MAX } else { 0 };\n-\n-        // `Unique::empty()` doubles as \"unallocated\" and \"zero-sized allocation\".\n-        RawVec { ptr: Unique::empty(), cap, a }\n-    }\n-\n-    /// Like `with_capacity`, but parameterized over the choice of\n-    /// allocator for the returned `RawVec`.\n-    #[inline]\n-    pub fn with_capacity_in(capacity: usize, a: A) -> Self {\n-        RawVec::allocate_in(capacity, false, a)\n-    }\n-\n-    /// Like `with_capacity_zeroed`, but parameterized over the choice\n-    /// of allocator for the returned `RawVec`.\n-    #[inline]\n-    pub fn with_capacity_zeroed_in(capacity: usize, a: A) -> Self {\n-        RawVec::allocate_in(capacity, true, a)\n-    }\n-\n-    fn allocate_in(mut capacity: usize, zeroed: bool, mut a: A) -> Self {\n-        let elem_size = mem::size_of::<T>();\n-\n-        let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n-        alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n-\n-        // Handles ZSTs and `capacity == 0` alike.\n-        let ptr = if alloc_size == 0 {\n-            NonNull::<T>::dangling()\n-        } else {\n-            let align = mem::align_of::<T>();\n-            let layout = Layout::from_size_align(alloc_size, align).unwrap();\n-            let result = if zeroed { a.alloc_zeroed(layout) } else { a.alloc(layout) };\n-            match result {\n-                Ok((ptr, size)) => {\n-                    capacity = size / elem_size;\n-                    ptr.cast()\n-                }\n-                Err(_) => handle_alloc_error(layout),\n-            }\n-        };\n-\n-        RawVec { ptr: ptr.into(), cap: capacity, a }\n-    }\n+    alloc: A,\n }\n \n impl<T> RawVec<T, Global> {\n@@ -138,39 +89,26 @@ impl<T> RawVec<T, Global> {\n     /// Aborts on OOM.\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n-        RawVec::allocate_in(capacity, false, Global)\n+        Self::with_capacity_in(capacity, Global)\n     }\n \n     /// Like `with_capacity`, but guarantees the buffer is zeroed.\n     #[inline]\n     pub fn with_capacity_zeroed(capacity: usize) -> Self {\n-        RawVec::allocate_in(capacity, true, Global)\n+        Self::with_capacity_zeroed_in(capacity, Global)\n     }\n-}\n \n-impl<T, A: AllocRef> RawVec<T, A> {\n-    /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n-    ///\n-    /// # Undefined Behavior\n-    ///\n-    /// The `ptr` must be allocated (via the given allocator `a`), and with the given `capacity`.\n-    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n-    /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n-    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n-        RawVec { ptr: Unique::new_unchecked(ptr), cap: capacity, a }\n-    }\n-}\n-\n-impl<T> RawVec<T, Global> {\n     /// Reconstitutes a `RawVec` from a pointer and capacity.\n     ///\n-    /// # Undefined Behavior\n+    /// # Safety\n     ///\n     /// The `ptr` must be allocated (on the system heap), and with the given `capacity`.\n-    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n+    /// The `capacity` cannot exceed `isize::MAX` for sized types. (only a concern on 32-bit\n+    /// systems). ZST vectors may have a capacity up to `usize::MAX`.\n     /// If the `ptr` and `capacity` come from a `RawVec`, then this is guaranteed.\n+    #[inline]\n     pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n-        RawVec { ptr: Unique::new_unchecked(ptr), cap: capacity, a: Global }\n+        Self::from_raw_parts_in(ptr, capacity, Global)\n     }\n \n     /// Converts a `Box<[T]>` into a `RawVec<T>`.\n@@ -184,6 +122,56 @@ impl<T> RawVec<T, Global> {\n }\n \n impl<T, A: AllocRef> RawVec<T, A> {\n+    /// Like `new`, but parameterized over the choice of allocator for\n+    /// the returned `RawVec`.\n+    pub const fn new_in(alloc: A) -> Self {\n+        // `cap: 0` means \"unallocated\". zero-sized types are ignored.\n+        Self { ptr: Unique::empty(), cap: 0, alloc }\n+    }\n+\n+    /// Like `with_capacity`, but parameterized over the choice of\n+    /// allocator for the returned `RawVec`.\n+    #[inline]\n+    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n+        Self::allocate_in(capacity, Uninitialized, alloc)\n+    }\n+\n+    /// Like `with_capacity_zeroed`, but parameterized over the choice\n+    /// of allocator for the returned `RawVec`.\n+    #[inline]\n+    pub fn with_capacity_zeroed_in(capacity: usize, alloc: A) -> Self {\n+        Self::allocate_in(capacity, Zeroed, alloc)\n+    }\n+\n+    fn allocate_in(capacity: usize, init: AllocInit, mut alloc: A) -> Self {\n+        if mem::size_of::<T>() == 0 {\n+            Self::new_in(alloc)\n+        } else {\n+            let layout = Layout::array::<T>(capacity).unwrap_or_else(|_| capacity_overflow());\n+            alloc_guard(layout.size()).unwrap_or_else(|_| capacity_overflow());\n+\n+            let memory = alloc.alloc(layout, init).unwrap_or_else(|_| handle_alloc_error(layout));\n+            Self {\n+                ptr: memory.ptr.cast().into(),\n+                cap: Self::capacity_from_bytes(memory.size),\n+                alloc,\n+            }\n+        }\n+    }\n+\n+    /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The `ptr` must be allocated (via the given allocator `a`), and with the given `capacity`.\n+    /// The `capacity` cannot exceed `isize::MAX` for sized types. (only a concern on 32-bit\n+    /// systems). ZST vectors may have a capacity up to `usize::MAX`.\n+    /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n+    #[inline]\n+    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n+        Self { ptr: Unique::new_unchecked(ptr), cap: capacity, alloc: a }\n+    }\n+\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n     /// `Unique::empty()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n     /// be careful.\n@@ -196,29 +184,30 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// This will always be `usize::MAX` if `T` is zero-sized.\n     #[inline(always)]\n     pub fn capacity(&self) -> usize {\n-        if mem::size_of::<T>() == 0 { !0 } else { self.cap }\n+        if mem::size_of::<T>() == 0 { usize::MAX } else { self.cap }\n     }\n \n     /// Returns a shared reference to the allocator backing this `RawVec`.\n     pub fn alloc(&self) -> &A {\n-        &self.a\n+        &self.alloc\n     }\n \n     /// Returns a mutable reference to the allocator backing this `RawVec`.\n     pub fn alloc_mut(&mut self) -> &mut A {\n-        &mut self.a\n+        &mut self.alloc\n     }\n \n-    fn current_layout(&self) -> Option<Layout> {\n-        if self.cap == 0 {\n+    fn current_memory(&self) -> Option<(NonNull<u8>, Layout)> {\n+        if mem::size_of::<T>() == 0 || self.cap == 0 {\n             None\n         } else {\n             // We have an allocated chunk of memory, so we can bypass runtime\n             // checks to get our current layout.\n             unsafe {\n                 let align = mem::align_of::<T>();\n                 let size = mem::size_of::<T>() * self.cap;\n-                Some(Layout::from_size_align_unchecked(size, align))\n+                let layout = Layout::from_size_align_unchecked(size, align);\n+                Some((self.ptr.cast().into(), layout))\n             }\n         }\n     }\n@@ -274,50 +263,10 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     #[inline(never)]\n     #[cold]\n     pub fn double(&mut self) {\n-        unsafe {\n-            let elem_size = mem::size_of::<T>();\n-\n-            // Since we set the capacity to `usize::MAX` when `elem_size` is\n-            // 0, getting to here necessarily means the `RawVec` is overfull.\n-            assert!(elem_size != 0, \"capacity overflow\");\n-\n-            let (ptr, new_cap) = match self.current_layout() {\n-                Some(cur) => {\n-                    // Since we guarantee that we never allocate more than\n-                    // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n-                    // a precondition, so this can't overflow. Additionally the\n-                    // alignment will never be too large as to \"not be\n-                    // satisfiable\", so `Layout::from_size_align` will always\n-                    // return `Some`.\n-                    //\n-                    // TL;DR, we bypass runtime checks due to dynamic assertions\n-                    // in this module, allowing us to use\n-                    // `from_size_align_unchecked`.\n-                    let new_cap = 2 * self.cap;\n-                    let new_size = new_cap * elem_size;\n-                    alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n-                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(), cur, new_size);\n-                    match ptr_res {\n-                        Ok((ptr, new_size)) => (ptr, new_size / elem_size),\n-                        Err(_) => handle_alloc_error(Layout::from_size_align_unchecked(\n-                            new_size,\n-                            cur.align(),\n-                        )),\n-                    }\n-                }\n-                None => {\n-                    // Skip to 4 because tiny `Vec`'s are dumb; but not if that\n-                    // would cause overflow.\n-                    let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n-                    let layout = Layout::array::<T>(new_cap).unwrap();\n-                    match self.a.alloc(layout) {\n-                        Ok((ptr, new_size)) => (ptr, new_size / elem_size),\n-                        Err(_) => handle_alloc_error(layout),\n-                    }\n-                }\n-            };\n-            self.ptr = ptr.cast().into();\n-            self.cap = new_cap;\n+        match self.grow(Double, MayMove, Uninitialized) {\n+            Err(CapacityOverflow) => capacity_overflow(),\n+            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n+            Ok(()) => { /* yay */ }\n         }\n     }\n \n@@ -336,99 +285,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     #[inline(never)]\n     #[cold]\n     pub fn double_in_place(&mut self) -> bool {\n-        unsafe {\n-            let elem_size = mem::size_of::<T>();\n-            let old_layout = match self.current_layout() {\n-                Some(layout) => layout,\n-                None => return false, // nothing to double\n-            };\n-\n-            // Since we set the capacity to `usize::MAX` when `elem_size` is\n-            // 0, getting to here necessarily means the `RawVec` is overfull.\n-            assert!(elem_size != 0, \"capacity overflow\");\n-\n-            // Since we guarantee that we never allocate more than `isize::MAX`\n-            // bytes, `elem_size * self.cap <= isize::MAX` as a precondition, so\n-            // this can't overflow.\n-            //\n-            // Similarly to with `double` above, we can go straight to\n-            // `Layout::from_size_align_unchecked` as we know this won't\n-            // overflow and the alignment is sufficiently small.\n-            let new_cap = 2 * self.cap;\n-            let new_size = new_cap * elem_size;\n-            alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n-            match self.a.grow_in_place(NonNull::from(self.ptr).cast(), old_layout, new_size) {\n-                Ok(_) => {\n-                    // We can't directly divide `size`.\n-                    self.cap = new_cap;\n-                    true\n-                }\n-                Err(_) => false,\n-            }\n-        }\n-    }\n-\n-    /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve_exact(\n-        &mut self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n-    ) -> Result<(), TryReserveError> {\n-        self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Exact)\n-    }\n-\n-    /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already,\n-    /// will reallocate the minimum possible amount of memory necessary.\n-    /// Generally this will be exactly the amount of memory necessary,\n-    /// but in principle the allocator is free to give back more than\n-    /// we asked for.\n-    ///\n-    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n-    /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behavior of this function may break.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    ///\n-    /// # Aborts\n-    ///\n-    /// Aborts on OOM.\n-    pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n-        match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n-            Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocError { .. }) => unreachable!(),\n-            Ok(()) => { /* yay */ }\n-        }\n-    }\n-\n-    /// Calculates the buffer's new size given that it'll hold `used_capacity +\n-    /// needed_extra_capacity` elements. This logic is used in amortized reserve methods.\n-    /// Returns `(new_capacity, new_alloc_size)`.\n-    fn amortized_new_size(\n-        &self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n-    ) -> Result<usize, TryReserveError> {\n-        // Nothing we can really do about these checks, sadly.\n-        let required_cap =\n-            used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n-        // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n-        let double_cap = self.cap * 2;\n-        // `double_cap` guarantees exponential growth.\n-        Ok(cmp::max(double_cap, required_cap))\n-    }\n-\n-    /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve(\n-        &mut self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n-    ) -> Result<(), TryReserveError> {\n-        self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Amortized)\n+        self.grow(Double, InPlace, Uninitialized).is_ok()\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n@@ -484,12 +341,26 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// # }\n     /// ```\n     pub fn reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n-        match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Amortized) {\n+        match self.try_reserve(used_capacity, needed_extra_capacity) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocError { .. }) => unreachable!(),\n+            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n             Ok(()) => { /* yay */ }\n         }\n     }\n+\n+    /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n+    pub fn try_reserve(\n+        &mut self,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n+    ) -> Result<(), TryReserveError> {\n+        if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n+            self.grow(Amortized { used_capacity, needed_extra_capacity }, MayMove, Uninitialized)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     /// Attempts to ensure that the buffer contains at least enough space to hold\n     /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n     /// enough capacity, will reallocate in place enough space plus comfortable slack\n@@ -508,45 +379,54 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n     pub fn reserve_in_place(&mut self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n-        unsafe {\n-            // NOTE: we don't early branch on ZSTs here because we want this\n-            // to actually catch \"asking for more than usize::MAX\" in that case.\n-            // If we make it past the first branch then we are guaranteed to\n-            // panic.\n-\n-            // Don't actually need any more capacity. If the current `cap` is 0, we can't\n-            // reallocate in place.\n-            // Wrapping in case they give a bad `used_capacity`\n-            let old_layout = match self.current_layout() {\n-                Some(layout) => layout,\n-                None => return false,\n-            };\n-            if self.capacity().wrapping_sub(used_capacity) >= needed_extra_capacity {\n-                return false;\n-            }\n+        // This is more readable than putting this in one line:\n+        // `!self.needs_to_grow(...) || self.grow(...).is_ok()`\n+        if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n+            self.grow(Amortized { used_capacity, needed_extra_capacity }, InPlace, Uninitialized)\n+                .is_ok()\n+        } else {\n+            true\n+        }\n+    }\n \n-            let new_cap = self\n-                .amortized_new_size(used_capacity, needed_extra_capacity)\n-                .unwrap_or_else(|_| capacity_overflow());\n-\n-            // Here, `cap < used_capacity + needed_extra_capacity <= new_cap`\n-            // (regardless of whether `self.cap - used_capacity` wrapped).\n-            // Therefore, we can safely call `grow_in_place`.\n-\n-            let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n-            // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size()).unwrap_or_else(|_| capacity_overflow());\n-            match self.a.grow_in_place(\n-                NonNull::from(self.ptr).cast(),\n-                old_layout,\n-                new_layout.size(),\n-            ) {\n-                Ok(_) => {\n-                    self.cap = new_cap;\n-                    true\n-                }\n-                Err(_) => false,\n-            }\n+    /// Ensures that the buffer contains at least enough space to hold\n+    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already,\n+    /// will reallocate the minimum possible amount of memory necessary.\n+    /// Generally this will be exactly the amount of memory necessary,\n+    /// but in principle the allocator is free to give back more than\n+    /// we asked for.\n+    ///\n+    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n+    /// the requested space. This is not really unsafe, but the unsafe\n+    /// code *you* write that relies on the behavior of this function may break.\n+    ///\n+    /// # Panics\n+    ///\n+    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n+    /// * Panics on 32-bit platforms if the requested capacity exceeds\n+    ///   `isize::MAX` bytes.\n+    ///\n+    /// # Aborts\n+    ///\n+    /// Aborts on OOM.\n+    pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n+        match self.try_reserve_exact(used_capacity, needed_extra_capacity) {\n+            Err(CapacityOverflow) => capacity_overflow(),\n+            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n+            Ok(()) => { /* yay */ }\n+        }\n+    }\n+\n+    /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n+    pub fn try_reserve_exact(\n+        &mut self,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n+    ) -> Result<(), TryReserveError> {\n+        if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n+            self.grow(Exact { used_capacity, needed_extra_capacity }, MayMove, Uninitialized)\n+        } else {\n+            Ok(())\n         }\n     }\n \n@@ -561,166 +441,157 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     ///\n     /// Aborts on OOM.\n     pub fn shrink_to_fit(&mut self, amount: usize) {\n-        let elem_size = mem::size_of::<T>();\n-\n-        // Set the `cap` because they might be about to promote to a `Box<[T]>`\n-        if elem_size == 0 {\n-            self.cap = amount;\n-            return;\n-        }\n-\n-        // This check is my waterloo; it's the only thing `Vec` wouldn't have to do.\n-        assert!(self.cap >= amount, \"Tried to shrink to a larger capacity\");\n-\n-        if amount == 0 {\n-            // We want to create a new zero-length vector within the\n-            // same allocator. We use `ptr::write` to avoid an\n-            // erroneous attempt to drop the contents, and we use\n-            // `ptr::read` to sidestep condition against destructuring\n-            // types that implement Drop.\n-\n-            unsafe {\n-                let a = ptr::read(&self.a as *const A);\n-                self.dealloc_buffer();\n-                ptr::write(self, RawVec::new_in(a));\n-            }\n-        } else if self.cap != amount {\n-            unsafe {\n-                // We know here that our `amount` is greater than zero. This\n-                // implies, via the assert above, that capacity is also greater\n-                // than zero, which means that we've got a current layout that\n-                // \"fits\"\n-                //\n-                // We also know that `self.cap` is greater than `amount`, and\n-                // consequently we don't need runtime checks for creating either\n-                // layout.\n-                let old_size = elem_size * self.cap;\n-                let new_size = elem_size * amount;\n-                let align = mem::align_of::<T>();\n-                let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-                match self.a.realloc(NonNull::from(self.ptr).cast(), old_layout, new_size) {\n-                    Ok((ptr, _)) => self.ptr = ptr.cast().into(),\n-                    Err(_) => {\n-                        handle_alloc_error(Layout::from_size_align_unchecked(new_size, align))\n-                    }\n-                }\n-            }\n-            self.cap = amount;\n+        match self.shrink(amount, MayMove) {\n+            Err(CapacityOverflow) => capacity_overflow(),\n+            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n+            Ok(()) => { /* yay */ }\n         }\n     }\n }\n \n-enum Fallibility {\n-    Fallible,\n-    Infallible,\n+#[derive(Copy, Clone)]\n+enum Strategy {\n+    Double,\n+    Amortized { used_capacity: usize, needed_extra_capacity: usize },\n+    Exact { used_capacity: usize, needed_extra_capacity: usize },\n }\n+use Strategy::*;\n \n-use Fallibility::*;\n+impl<T, A: AllocRef> RawVec<T, A> {\n+    /// Returns if the buffer needs to grow to fulfill the needed extra capacity.\n+    /// Mainly used to make inlining reserve-calls possible without inlining `grow`.\n+    fn needs_to_grow(&self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n+        needed_extra_capacity > self.capacity().wrapping_sub(used_capacity)\n+    }\n \n-enum ReserveStrategy {\n-    Exact,\n-    Amortized,\n-}\n+    fn capacity_from_bytes(excess: usize) -> usize {\n+        debug_assert_ne!(mem::size_of::<T>(), 0);\n+        excess / mem::size_of::<T>()\n+    }\n \n-use ReserveStrategy::*;\n+    fn set_memory(&mut self, memory: MemoryBlock) {\n+        self.ptr = memory.ptr.cast().into();\n+        self.cap = Self::capacity_from_bytes(memory.size);\n+    }\n \n-impl<T, A: AllocRef> RawVec<T, A> {\n-    fn reserve_internal(\n+    /// Single method to handle all possibilities of growing the buffer.\n+    fn grow(\n         &mut self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n-        fallibility: Fallibility,\n-        strategy: ReserveStrategy,\n+        strategy: Strategy,\n+        placement: ReallocPlacement,\n+        init: AllocInit,\n     ) -> Result<(), TryReserveError> {\n         let elem_size = mem::size_of::<T>();\n+        if elem_size == 0 {\n+            // Since we return a capacity of `usize::MAX` when `elem_size` is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n+            return Err(CapacityOverflow);\n+        }\n+        let new_layout = match strategy {\n+            Double => unsafe {\n+                // Since we guarantee that we never allocate more than `isize::MAX` bytes,\n+                // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow.\n+                // Additionally the alignment will never be too large as to \"not be satisfiable\",\n+                // so `Layout::from_size_align` will always return `Some`.\n+                //\n+                // TL;DR, we bypass runtime checks due to dynamic assertions in this module,\n+                // allowing us to use `from_size_align_unchecked`.\n+                let cap = if self.cap == 0 {\n+                    // Skip to 4 because tiny `Vec`'s are dumb; but not if that would cause overflow.\n+                    if elem_size > usize::MAX / 8 { 1 } else { 4 }\n+                } else {\n+                    self.cap * 2\n+                };\n+                Layout::from_size_align_unchecked(cap * elem_size, mem::align_of::<T>())\n+            },\n+            Amortized { used_capacity, needed_extra_capacity } => {\n+                // Nothing we can really do about these checks, sadly.\n+                let required_cap =\n+                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n+                // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n+                let double_cap = self.cap * 2;\n+                // `double_cap` guarantees exponential growth.\n+                let cap = cmp::max(double_cap, required_cap);\n+                Layout::array::<T>(cap).map_err(|_| CapacityOverflow)?\n+            }\n+            Exact { used_capacity, needed_extra_capacity } => {\n+                let cap =\n+                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n+                Layout::array::<T>(cap).map_err(|_| CapacityOverflow)?\n+            }\n+        };\n+        alloc_guard(new_layout.size())?;\n \n-        unsafe {\n-            // NOTE: we don't early branch on ZSTs here because we want this\n-            // to actually catch \"asking for more than usize::MAX\" in that case.\n-            // If we make it past the first branch then we are guaranteed to\n-            // panic.\n-\n-            // Don't actually need any more capacity.\n-            // Wrapping in case they gave a bad `used_capacity`.\n-            if self.capacity().wrapping_sub(used_capacity) >= needed_extra_capacity {\n-                return Ok(());\n+        let memory = if let Some((ptr, old_layout)) = self.current_memory() {\n+            debug_assert_eq!(old_layout.align(), new_layout.align());\n+            unsafe {\n+                self.alloc\n+                    .grow(ptr, old_layout, new_layout.size(), placement, init)\n+                    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n+            }\n+        } else {\n+            match placement {\n+                MayMove => self.alloc.alloc(new_layout, init),\n+                InPlace => Err(AllocErr),\n             }\n+            .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n+        };\n+        self.set_memory(memory);\n+        Ok(())\n+    }\n \n-            // Nothing we can really do about these checks, sadly.\n-            let new_cap = match strategy {\n-                Exact => {\n-                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?\n-                }\n-                Amortized => self.amortized_new_size(used_capacity, needed_extra_capacity)?,\n-            };\n-            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n+    fn shrink(\n+        &mut self,\n+        amount: usize,\n+        placement: ReallocPlacement,\n+    ) -> Result<(), TryReserveError> {\n+        assert!(amount <= self.capacity(), \"Tried to shrink to a larger capacity\");\n \n-            alloc_guard(new_layout.size())?;\n+        let (ptr, layout) = if let Some(mem) = self.current_memory() { mem } else { return Ok(()) };\n+        let new_size = amount * mem::size_of::<T>();\n \n-            let res = match self.current_layout() {\n-                Some(layout) => {\n-                    debug_assert!(new_layout.align() == layout.align());\n-                    self.a.realloc(NonNull::from(self.ptr).cast(), layout, new_layout.size())\n-                }\n-                None => self.a.alloc(new_layout),\n-            };\n-\n-            let (ptr, new_cap) = match (res, fallibility) {\n-                (Err(AllocErr), Infallible) => handle_alloc_error(new_layout),\n-                (Err(AllocErr), Fallible) => {\n-                    return Err(TryReserveError::AllocError {\n-                        layout: new_layout,\n-                        non_exhaustive: (),\n-                    });\n+        let memory = unsafe {\n+            self.alloc.shrink(ptr, layout, new_size, placement).map_err(|_| {\n+                TryReserveError::AllocError {\n+                    layout: Layout::from_size_align_unchecked(new_size, layout.align()),\n+                    non_exhaustive: (),\n                 }\n-                (Ok((ptr, new_size)), _) => (ptr, new_size / elem_size),\n-            };\n-\n-            self.ptr = ptr.cast().into();\n-            self.cap = new_cap;\n-\n-            Ok(())\n-        }\n+            })?\n+        };\n+        self.set_memory(memory);\n+        Ok(())\n     }\n }\n \n impl<T> RawVec<T, Global> {\n-    /// Converts the entire buffer into `Box<[T]>`.\n+    /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n     ///\n     /// Note that this will correctly reconstitute any `cap` changes\n     /// that may have been performed. (See description of type for details.)\n     ///\n-    /// # Undefined Behavior\n+    /// # Safety\n     ///\n-    /// All elements of `RawVec<T, Global>` must be initialized. Notice that\n-    /// the rules around uninitialized boxed values are not finalized yet,\n-    /// but until they are, it is advisable to avoid them.\n-    pub unsafe fn into_box(self) -> Box<[T]> {\n+    /// `shrink_to_fit(len)` must be called immediately prior to calling this function. This\n+    /// implies, that `len` must be smaller than or equal to `self.capacity()`.\n+    pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>]> {\n+        debug_assert!(\n+            len <= self.capacity(),\n+            \"`len` must be smaller than or equal to `self.capacity()`\"\n+        );\n+\n         // NOTE: not calling `capacity()` here; actually using the real `cap` field!\n-        let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);\n-        let output: Box<[T]> = Box::from_raw(slice);\n+        let slice = slice::from_raw_parts_mut(self.ptr() as *mut MaybeUninit<T>, len);\n+        let output = Box::from_raw(slice);\n         mem::forget(self);\n         output\n     }\n }\n \n-impl<T, A: AllocRef> RawVec<T, A> {\n-    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n-    pub unsafe fn dealloc_buffer(&mut self) {\n-        let elem_size = mem::size_of::<T>();\n-        if elem_size != 0 {\n-            if let Some(layout) = self.current_layout() {\n-                self.a.dealloc(NonNull::from(self.ptr).cast(), layout);\n-            }\n-        }\n-    }\n-}\n-\n unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n     /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {\n-        unsafe {\n-            self.dealloc_buffer();\n+        if let Some((ptr, layout)) = self.current_memory() {\n+            unsafe { self.alloc.dealloc(ptr, layout) }\n         }\n     }\n }"}, {"sha": "e7ab8a305d2797c83e5cf399dfc007bf581565b5", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -12,6 +12,7 @@ fn allocator_param() {\n     //\n     // Instead, this just checks that the `RawVec` methods do at\n     // least go through the Allocator API when it reserves\n+\n     // storage.\n \n     // A dumb allocator that consumes a fixed amount of fuel\n@@ -20,12 +21,12 @@ fn allocator_param() {\n         fuel: usize,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);\n             }\n-            match Global.alloc(layout) {\n+            match Global.alloc(layout, init) {\n                 ok @ Ok(_) => {\n                     self.fuel -= size;\n                     ok\n@@ -40,9 +41,9 @@ fn allocator_param() {\n \n     let a = BoundedAlloc { fuel: 500 };\n     let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n-    assert_eq!(v.a.fuel, 450);\n+    assert_eq!(v.alloc.fuel, 450);\n     v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n-    assert_eq!(v.a.fuel, 250);\n+    assert_eq!(v.alloc.fuel, 250);\n }\n \n #[test]"}, {"sha": "6a78a7398a692814155c9c9513f572cd98b73905", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -252,7 +252,7 @@ use core::ptr::{self, NonNull};\n use core::slice::{self, from_raw_parts_mut};\n use core::usize;\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n use crate::string::String;\n use crate::vec::Vec;\n \n@@ -936,10 +936,12 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n         // Allocate for the layout.\n-        let (mem, _) = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let mem = Global\n+            .alloc(layout, AllocInit::Uninitialized)\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n-        let inner = mem_to_rcbox(mem.as_ptr());\n+        let inner = mem_to_rcbox(mem.ptr.as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, Cell::new(1));"}, {"sha": "2ce5bc8ed2f9db71a570c49fb114f0781308ad86", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -432,7 +432,7 @@ impl<T> [T] {\n     ///\n     /// ```should_panic\n     /// // this will panic at runtime\n-    /// b\"0123456789abcdef\".repeat(usize::max_value());\n+    /// b\"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n     #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n     pub fn repeat(&self, n: usize) -> Vec<T>"}, {"sha": "70860c09a2c31d0b031b753253265b667e391311", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -499,7 +499,7 @@ impl str {\n     ///\n     /// ```should_panic\n     /// // this will panic at runtime\n-    /// \"0123456789abcdef\".repeat(usize::max_value());\n+    /// \"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {"}, {"sha": "1e5fe125c550d3c5724471b229ae5697163fc705", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1849,6 +1849,21 @@ impl<'a, 'b> Pattern<'a> for &'b String {\n     fn is_prefix_of(self, haystack: &'a str) -> bool {\n         self[..].is_prefix_of(haystack)\n     }\n+\n+    #[inline]\n+    fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        self[..].strip_prefix_of(haystack)\n+    }\n+\n+    #[inline]\n+    fn is_suffix_of(self, haystack: &'a str) -> bool {\n+        self[..].is_suffix_of(haystack)\n+    }\n+\n+    #[inline]\n+    fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        self[..].strip_suffix_of(haystack)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "111a7651b5e77c235f4cda5adfd4867a96d8a1f8", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -25,7 +25,7 @@ use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::{isize, usize};\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n use crate::string::String;\n@@ -814,10 +814,12 @@ impl<T: ?Sized> Arc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n-        let (mem, _) = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let mem = Global\n+            .alloc(layout, AllocInit::Uninitialized)\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n-        let inner = mem_to_arcinner(mem.as_ptr());\n+        let inner = mem_to_arcinner(mem.ptr.as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));"}, {"sha": "a64d5d7a63ba0714317565ab1bc84faf3a971545", "filename": "src/liballoc/task.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -12,10 +12,12 @@ use crate::sync::Arc;\n /// to the tasks that are executed on that executor.\n ///\n /// This trait is a memory-safe and ergonomic alternative to constructing a\n-/// [`RawWaker`]. It supports the common executor design in which the data\n-/// used to wake up a task is stored in an [`Arc`]. Some executors (especially\n+/// [`RawWaker`]. It supports the common executor design in which the data used\n+/// to wake up a task is stored in an [`Arc`][arc]. Some executors (especially\n /// those for embedded systems) cannot use this API, which is why [`RawWaker`]\n /// exists as an alternative for those systems.\n+///\n+/// [arc]: ../../std/sync/struct.Arc.html\n #[unstable(feature = \"wake_trait\", issue = \"69912\")]\n pub trait Wake {\n     /// Wake this task."}, {"sha": "14f12ca2d779a453881489ade0410bfc55c05023", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 259, "deletions": 2, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -5,7 +5,7 @@ use std::fmt::Debug;\n use std::iter::FromIterator;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n-use std::panic::catch_unwind;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::rc::Rc;\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n@@ -528,7 +528,7 @@ fn test_range_1000() {\n     #[cfg(not(miri))] // Miri is too slow\n     let size = 1000;\n     #[cfg(miri)]\n-    let size = MIN_INSERTS_HEIGHT_2;\n+    let size = MIN_INSERTS_HEIGHT_2 as u32;\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n@@ -609,6 +609,263 @@ fn test_range_mut() {\n     }\n }\n \n+mod test_drain_filter {\n+    use super::*;\n+\n+    #[test]\n+    fn empty() {\n+        let mut map: BTreeMap<i32, i32> = BTreeMap::new();\n+        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn consuming_nothing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        assert!(map.drain_filter(|_, _| false).eq(std::iter::empty()));\n+    }\n+\n+    #[test]\n+    fn consuming_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+        assert!(map.drain_filter(|_, _| true).eq(pairs));\n+    }\n+\n+    #[test]\n+    fn mutating_and_keeping() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                false\n+            })\n+            .eq(std::iter::empty())\n+        );\n+        assert!(map.keys().copied().eq(0..3));\n+        assert!(map.values().copied().eq(6..9));\n+    }\n+\n+    #[test]\n+    fn mutating_and_removing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                true\n+            })\n+            .eq((0..3).map(|i| (i, i + 6)))\n+        );\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn underfull_keeping_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| false);\n+        assert!(map.keys().copied().eq(0..3));\n+    }\n+\n+    #[test]\n+    fn underfull_removing_one() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        for doomed in 0..3 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), 2);\n+        }\n+    }\n+\n+    #[test]\n+    fn underfull_keeping_one() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        for sacred in 0..3 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[test]\n+    fn underfull_removing_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn height_0_keeping_all() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| false);\n+        assert!(map.keys().copied().eq(0..NODE_CAPACITY));\n+    }\n+\n+    #[test]\n+    fn height_0_removing_one() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        for doomed in 0..NODE_CAPACITY {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), NODE_CAPACITY - 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn height_0_keeping_one() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        for sacred in 0..NODE_CAPACITY {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[test]\n+    fn height_0_removing_all() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn height_0_keeping_half() {\n+        let mut map: BTreeMap<_, _> = (0..16).map(|i| (i, i)).collect();\n+        assert_eq!(map.drain_filter(|i, _| *i % 2 == 0).count(), 8);\n+        assert_eq!(map.len(), 8);\n+    }\n+\n+    #[test]\n+    fn height_1_removing_all() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn height_1_removing_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n+        for doomed in 0..MIN_INSERTS_HEIGHT_1 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), MIN_INSERTS_HEIGHT_1 - 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn height_1_keeping_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n+        for sacred in 0..MIN_INSERTS_HEIGHT_1 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[cfg(not(miri))] // Miri is too slow\n+    #[test]\n+    fn height_2_removing_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+        for doomed in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+        }\n+    }\n+\n+    #[cfg(not(miri))] // Miri is too slow\n+    #[test]\n+    fn height_2_keeping_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+        for sacred in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[test]\n+    fn height_2_removing_all() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn drop_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                    panic!(\"panic in `drop`\");\n+                }\n+            }\n+        }\n+\n+        let mut map = BTreeMap::new();\n+        map.insert(0, D);\n+        map.insert(4, D);\n+        map.insert(8, D);\n+\n+        catch_unwind(move || {\n+            drop(map.drain_filter(|i, _| {\n+                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                true\n+            }))\n+        })\n+        .ok();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+    }\n+\n+    #[test]\n+    fn pred_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                DROPS.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let mut map = BTreeMap::new();\n+        map.insert(0, D);\n+        map.insert(4, D);\n+        map.insert(8, D);\n+\n+        catch_unwind(AssertUnwindSafe(|| {\n+            drop(map.drain_filter(|i, _| {\n+                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                match i {\n+                    0 => true,\n+                    _ => panic!(),\n+                }\n+            }))\n+        }))\n+        .ok();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(map.len(), 2);\n+        assert_eq!(map.first_entry().unwrap().key(), &4);\n+        assert_eq!(map.last_entry().unwrap().key(), &8);\n+    }\n+}\n+\n #[test]\n fn test_borrow() {\n     // make sure these compile -- using the Borrow trait"}, {"sha": "136018b9f7df53e1f44985883524fca60aac293f", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,5 +1,7 @@\n use std::collections::BTreeSet;\n use std::iter::FromIterator;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::sync::atomic::{AtomicU32, Ordering};\n \n use super::DeterministicRng;\n \n@@ -302,6 +304,85 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[99, 100], &large), false);\n }\n \n+#[test]\n+fn test_drain_filter() {\n+    let mut x: BTreeSet<_> = [1].iter().copied().collect();\n+    let mut y: BTreeSet<_> = [1].iter().copied().collect();\n+\n+    x.drain_filter(|_| true);\n+    y.drain_filter(|_| false);\n+    assert_eq!(x.len(), 0);\n+    assert_eq!(y.len(), 1);\n+}\n+\n+#[test]\n+fn test_drain_filter_drop_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    struct D(i32);\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut set = BTreeSet::new();\n+    set.insert(D(0));\n+    set.insert(D(4));\n+    set.insert(D(8));\n+\n+    catch_unwind(move || {\n+        drop(set.drain_filter(|d| {\n+            PREDS.fetch_add(1u32 << d.0, Ordering::SeqCst);\n+            true\n+        }))\n+    })\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+}\n+\n+#[test]\n+fn test_drain_filter_pred_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    struct D(i32);\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            DROPS.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let mut set = BTreeSet::new();\n+    set.insert(D(0));\n+    set.insert(D(4));\n+    set.insert(D(8));\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        drop(set.drain_filter(|d| {\n+            PREDS.fetch_add(1u32 << d.0, Ordering::SeqCst);\n+            match d.0 {\n+                0 => true,\n+                _ => panic!(),\n+            }\n+        }))\n+    }))\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+    assert_eq!(set.len(), 2);\n+    assert_eq!(set.first().unwrap().0, 4);\n+    assert_eq!(set.last().unwrap().0, 8);\n+}\n+\n #[test]\n fn test_clear() {\n     let mut x = BTreeSet::new();"}, {"sha": "62f062b83d75d77c5e34dfc62b2b347501716236", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,4 +1,4 @@\n-use std::alloc::{AllocRef, Global, Layout, System};\n+use std::alloc::{AllocInit, AllocRef, Global, Layout, System};\n \n /// Issue #45955 and #62251.\n #[test]\n@@ -20,7 +20,13 @@ fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n             unsafe {\n                 let pointers: Vec<_> = (0..iterations)\n                     .map(|_| {\n-                        allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap().0\n+                        allocator\n+                            .alloc(\n+                                Layout::from_size_align(size, align).unwrap(),\n+                                AllocInit::Uninitialized,\n+                            )\n+                            .unwrap()\n+                            .ptr\n                     })\n                     .collect();\n                 for &ptr in &pointers {"}, {"sha": "ad6feaeebc67f884208e0fd4721935579fd8f662", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,5 +1,6 @@\n #![feature(allocator_api)]\n #![feature(box_syntax)]\n+#![feature(btree_drain_filter)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(map_first_last)]"}, {"sha": "96a6399d0518b8f9bc7251a12c677723b0c81cf2", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -679,8 +679,9 @@ impl<T> Vec<T> {\n         unsafe {\n             self.shrink_to_fit();\n             let buf = ptr::read(&self.buf);\n+            let len = self.len();\n             mem::forget(self);\n-            buf.into_box()\n+            buf.into_box(len).assume_init()\n         }\n     }\n "}, {"sha": "be20a1cde3694fe0fd89285a91cacfe601c19340", "filename": "src/libcore/alloc.rs", "status": "removed", "additions": 0, "deletions": 1043, "changes": 1043, "blob_url": "https://github.com/rust-lang/rust/blob/9f6b96e461003853bf36052cfaf79b12e1c35413/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f6b96e461003853bf36052cfaf79b12e1c35413/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=9f6b96e461003853bf36052cfaf79b12e1c35413", "patch": "@@ -1,1043 +0,0 @@\n-//! Memory allocation APIs\n-\n-// ignore-tidy-undocumented-unsafe\n-\n-#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n-\n-use crate::cmp;\n-use crate::fmt;\n-use crate::mem;\n-use crate::num::NonZeroUsize;\n-use crate::ptr::{self, NonNull};\n-use crate::usize;\n-\n-const fn size_align<T>() -> (usize, usize) {\n-    (mem::size_of::<T>(), mem::align_of::<T>())\n-}\n-\n-/// Layout of a block of memory.\n-///\n-/// An instance of `Layout` describes a particular layout of memory.\n-/// You build a `Layout` up as an input to give to an allocator.\n-///\n-/// All layouts have an associated non-negative size and a\n-/// power-of-two alignment.\n-///\n-/// (Note however that layouts are *not* required to have positive\n-/// size, even though many allocators require that all memory\n-/// requests have positive size. A caller to the `AllocRef::alloc`\n-/// method must either ensure that conditions like this are met, or\n-/// use specific allocators with looser requirements.)\n-#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-#[lang = \"alloc_layout\"]\n-pub struct Layout {\n-    // size of the requested block of memory, measured in bytes.\n-    size_: usize,\n-\n-    // alignment of the requested block of memory, measured in bytes.\n-    // we ensure that this is always a power-of-two, because API's\n-    // like `posix_memalign` require it and it is a reasonable\n-    // constraint to impose on Layout constructors.\n-    //\n-    // (However, we do not analogously require `align >= sizeof(void*)`,\n-    //  even though that is *also* a requirement of `posix_memalign`.)\n-    align_: NonZeroUsize,\n-}\n-\n-impl Layout {\n-    /// Constructs a `Layout` from a given `size` and `align`,\n-    /// or returns `LayoutErr` if any of the following conditions\n-    /// are not met:\n-    ///\n-    /// * `align` must not be zero,\n-    ///\n-    /// * `align` must be a power of two,\n-    ///\n-    /// * `size`, when rounded up to the nearest multiple of `align`,\n-    ///    must not overflow (i.e., the rounded value must be less than\n-    ///    `usize::MAX`).\n-    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n-    #[inline]\n-    pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n-        if !align.is_power_of_two() {\n-            return Err(LayoutErr { private: () });\n-        }\n-\n-        // (power-of-two implies align != 0.)\n-\n-        // Rounded up size is:\n-        //   size_rounded_up = (size + align - 1) & !(align - 1);\n-        //\n-        // We know from above that align != 0. If adding (align - 1)\n-        // does not overflow, then rounding up will be fine.\n-        //\n-        // Conversely, &-masking with !(align - 1) will subtract off\n-        // only low-order-bits. Thus if overflow occurs with the sum,\n-        // the &-mask cannot subtract enough to undo that overflow.\n-        //\n-        // Above implies that checking for summation overflow is both\n-        // necessary and sufficient.\n-        if size > usize::MAX - (align - 1) {\n-            return Err(LayoutErr { private: () });\n-        }\n-\n-        unsafe { Ok(Layout::from_size_align_unchecked(size, align)) }\n-    }\n-\n-    /// Creates a layout, bypassing all checks.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe as it does not verify the preconditions from\n-    /// [`Layout::from_size_align`](#method.from_size_align).\n-    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[inline]\n-    pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n-        Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n-    }\n-\n-    /// The minimum size in bytes for a memory block of this layout.\n-    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n-    #[inline]\n-    pub const fn size(&self) -> usize {\n-        self.size_\n-    }\n-\n-    /// The minimum byte alignment for a memory block of this layout.\n-    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n-    #[inline]\n-    pub const fn align(&self) -> usize {\n-        self.align_.get()\n-    }\n-\n-    /// Constructs a `Layout` suitable for holding a value of type `T`.\n-    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_stable(feature = \"alloc_layout_const_new\", since = \"1.42.0\")]\n-    #[inline]\n-    pub const fn new<T>() -> Self {\n-        let (size, align) = size_align::<T>();\n-        // Note that the align is guaranteed by rustc to be a power of two and\n-        // the size+align combo is guaranteed to fit in our address space. As a\n-        // result use the unchecked constructor here to avoid inserting code\n-        // that panics if it isn't optimized well enough.\n-        unsafe { Layout::from_size_align_unchecked(size, align) }\n-    }\n-\n-    /// Produces layout describing a record that could be used to\n-    /// allocate backing structure for `T` (which could be a trait\n-    /// or other unsized type like a slice).\n-    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[inline]\n-    pub fn for_value<T: ?Sized>(t: &T) -> Self {\n-        let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n-        // See rationale in `new` for why this is using an unsafe variant below\n-        debug_assert!(Layout::from_size_align(size, align).is_ok());\n-        unsafe { Layout::from_size_align_unchecked(size, align) }\n-    }\n-\n-    /// Produces layout describing a record that could be used to\n-    /// allocate backing structure for `T` (which could be a trait\n-    /// or other unsized type like a slice).\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is only safe to call if the following conditions hold:\n-    ///\n-    /// - If `T` is `Sized`, this function is always safe to call.\n-    /// - If the unsized tail of `T` is:\n-    ///     - a [slice], then the length of the slice tail must be an intialized\n-    ///       integer, and the size of the *entire value*\n-    ///       (dynamic tail length + statically sized prefix) must fit in `isize`.\n-    ///     - a [trait object], then the vtable part of the pointer must point\n-    ///       to a valid vtable acquired by an unsizing coersion, and the size\n-    ///       of the *entire value* (dynamic tail length + statically sized prefix)\n-    ///       must fit in `isize`.\n-    ///     - an (unstable) [extern type], then this function is always safe to\n-    ///       call, but may panic or otherwise return the wrong value, as the\n-    ///       extern type's layout is not known. This is the same behavior as\n-    ///       [`Layout::for_value`] on a reference to an extern type tail.\n-    ///     - otherwise, it is conservatively not allowed to call this function.\n-    ///\n-    /// [slice]: ../../std/primitive.slice.html\n-    /// [trait object]: ../../book/ch17-02-trait-objects.html\n-    /// [extern type]: ../../unstable-book/language-features/extern-types.html\n-    #[inline]\n-    #[cfg(not(bootstrap))]\n-    #[unstable(feature = \"layout_for_ptr\", issue = \"69835\")]\n-    pub unsafe fn for_value_raw<T: ?Sized>(t: *const T) -> Self {\n-        let (size, align) = (mem::size_of_val_raw(t), mem::align_of_val_raw(t));\n-        // See rationale in `new` for why this is using an unsafe variant below\n-        debug_assert!(Layout::from_size_align(size, align).is_ok());\n-        Layout::from_size_align_unchecked(size, align)\n-    }\n-\n-    /// Creates a `NonNull` that is dangling, but well-aligned for this Layout.\n-    ///\n-    /// Note that the pointer value may potentially represent a valid pointer,\n-    /// which means this must not be used as a \"not yet initialized\"\n-    /// sentinel value. Types that lazily allocate must track initialization by\n-    /// some other means.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    pub const fn dangling(&self) -> NonNull<u8> {\n-        // align is non-zero and a power of two\n-        unsafe { NonNull::new_unchecked(self.align() as *mut u8) }\n-    }\n-\n-    /// Creates a layout describing the record that can hold a value\n-    /// of the same layout as `self`, but that also is aligned to\n-    /// alignment `align` (measured in bytes).\n-    ///\n-    /// If `self` already meets the prescribed alignment, then returns\n-    /// `self`.\n-    ///\n-    /// Note that this method does not add any padding to the overall\n-    /// size, regardless of whether the returned layout has a different\n-    /// alignment. In other words, if `K` has size 16, `K.align_to(32)`\n-    /// will *still* have size 16.\n-    ///\n-    /// Returns an error if the combination of `self.size()` and the given\n-    /// `align` violates the conditions listed in\n-    /// [`Layout::from_size_align`](#method.from_size_align).\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn align_to(&self, align: usize) -> Result<Self, LayoutErr> {\n-        Layout::from_size_align(self.size(), cmp::max(self.align(), align))\n-    }\n-\n-    /// Returns the amount of padding we must insert after `self`\n-    /// to ensure that the following address will satisfy `align`\n-    /// (measured in bytes).\n-    ///\n-    /// e.g., if `self.size()` is 9, then `self.padding_needed_for(4)`\n-    /// returns 3, because that is the minimum number of bytes of\n-    /// padding required to get a 4-aligned address (assuming that the\n-    /// corresponding memory block starts at a 4-aligned address).\n-    ///\n-    /// The return value of this function has no meaning if `align` is\n-    /// not a power-of-two.\n-    ///\n-    /// Note that the utility of the returned value requires `align`\n-    /// to be less than or equal to the alignment of the starting\n-    /// address for the whole allocated block of memory. One way to\n-    /// satisfy this constraint is to ensure `align <= self.align()`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n-    #[inline]\n-    pub const fn padding_needed_for(&self, align: usize) -> usize {\n-        let len = self.size();\n-\n-        // Rounded up value is:\n-        //   len_rounded_up = (len + align - 1) & !(align - 1);\n-        // and then we return the padding difference: `len_rounded_up - len`.\n-        //\n-        // We use modular arithmetic throughout:\n-        //\n-        // 1. align is guaranteed to be > 0, so align - 1 is always\n-        //    valid.\n-        //\n-        // 2. `len + align - 1` can overflow by at most `align - 1`,\n-        //    so the &-mask with `!(align - 1)` will ensure that in the\n-        //    case of overflow, `len_rounded_up` will itself be 0.\n-        //    Thus the returned padding, when added to `len`, yields 0,\n-        //    which trivially satisfies the alignment `align`.\n-        //\n-        // (Of course, attempts to allocate blocks of memory whose\n-        // size and padding overflow in the above manner should cause\n-        // the allocator to yield an error anyway.)\n-\n-        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);\n-        len_rounded_up.wrapping_sub(len)\n-    }\n-\n-    /// Creates a layout by rounding the size of this layout up to a multiple\n-    /// of the layout's alignment.\n-    ///\n-    /// This is equivalent to adding the result of `padding_needed_for`\n-    /// to the layout's current size.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn pad_to_align(&self) -> Layout {\n-        let pad = self.padding_needed_for(self.align());\n-        // This cannot overflow. Quoting from the invariant of Layout:\n-        // > `size`, when rounded up to the nearest multiple of `align`,\n-        // > must not overflow (i.e., the rounded value must be less than\n-        // > `usize::MAX`)\n-        let new_size = self.size() + pad;\n-\n-        Layout::from_size_align(new_size, self.align()).unwrap()\n-    }\n-\n-    /// Creates a layout describing the record for `n` instances of\n-    /// `self`, with a suitable amount of padding between each to\n-    /// ensure that each instance is given its requested size and\n-    /// alignment. On success, returns `(k, offs)` where `k` is the\n-    /// layout of the array and `offs` is the distance between the start\n-    /// of each element in the array.\n-    ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n-        // This cannot overflow. Quoting from the invariant of Layout:\n-        // > `size`, when rounded up to the nearest multiple of `align`,\n-        // > must not overflow (i.e., the rounded value must be less than\n-        // > `usize::MAX`)\n-        let padded_size = self.size() + self.padding_needed_for(self.align());\n-        let alloc_size = padded_size.checked_mul(n).ok_or(LayoutErr { private: () })?;\n-\n-        unsafe {\n-            // self.align is already known to be valid and alloc_size has been\n-            // padded already.\n-            Ok((Layout::from_size_align_unchecked(alloc_size, self.align()), padded_size))\n-        }\n-    }\n-\n-    /// Creates a layout describing the record for `self` followed by\n-    /// `next`, including any necessary padding to ensure that `next`\n-    /// will be properly aligned. Note that the resulting layout will\n-    /// satisfy the alignment properties of both `self` and `next`.\n-    ///\n-    /// The resulting layout will be the same as that of a C struct containing\n-    /// two fields with the layouts of `self` and `next`, in that order.\n-    ///\n-    /// Returns `Some((k, offset))`, where `k` is layout of the concatenated\n-    /// record and `offset` is the relative location, in bytes, of the\n-    /// start of the `next` embedded within the concatenated record\n-    /// (assuming that the record itself starts at offset 0).\n-    ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n-        let new_align = cmp::max(self.align(), next.align());\n-        let pad = self.padding_needed_for(next.align());\n-\n-        let offset = self.size().checked_add(pad).ok_or(LayoutErr { private: () })?;\n-        let new_size = offset.checked_add(next.size()).ok_or(LayoutErr { private: () })?;\n-\n-        let layout = Layout::from_size_align(new_size, new_align)?;\n-        Ok((layout, offset))\n-    }\n-\n-    /// Creates a layout describing the record for `n` instances of\n-    /// `self`, with no padding between each instance.\n-    ///\n-    /// Note that, unlike `repeat`, `repeat_packed` does not guarantee\n-    /// that the repeated instances of `self` will be properly\n-    /// aligned, even if a given instance of `self` is properly\n-    /// aligned. In other words, if the layout returned by\n-    /// `repeat_packed` is used to allocate an array, it is not\n-    /// guaranteed that all elements in the array will be properly\n-    /// aligned.\n-    ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutErr> {\n-        let size = self.size().checked_mul(n).ok_or(LayoutErr { private: () })?;\n-        Layout::from_size_align(size, self.align())\n-    }\n-\n-    /// Creates a layout describing the record for `self` followed by\n-    /// `next` with no additional padding between the two. Since no\n-    /// padding is inserted, the alignment of `next` is irrelevant,\n-    /// and is not incorporated *at all* into the resulting layout.\n-    ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutErr> {\n-        let new_size = self.size().checked_add(next.size()).ok_or(LayoutErr { private: () })?;\n-        Layout::from_size_align(new_size, self.align())\n-    }\n-\n-    /// Creates a layout describing the record for a `[T; n]`.\n-    ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n-        Layout::new::<T>().repeat(n).map(|(k, offs)| {\n-            debug_assert!(offs == mem::size_of::<T>());\n-            k\n-        })\n-    }\n-}\n-\n-/// The parameters given to `Layout::from_size_align`\n-/// or some other `Layout` constructor\n-/// do not satisfy its documented constraints.\n-#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct LayoutErr {\n-    private: (),\n-}\n-\n-// (we need this for downstream impl of trait Error)\n-#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-impl fmt::Display for LayoutErr {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"invalid parameters to Layout::from_size_align\")\n-    }\n-}\n-\n-/// The `AllocErr` error indicates an allocation failure\n-/// that may be due to resource exhaustion or to\n-/// something wrong when combining the given input arguments with this\n-/// allocator.\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct AllocErr;\n-\n-// (we need this for downstream impl of trait Error)\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-impl fmt::Display for AllocErr {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"memory allocation failed\")\n-    }\n-}\n-\n-/// The `CannotReallocInPlace` error is used when [`grow_in_place`] or\n-/// [`shrink_in_place`] were unable to reuse the given memory block for\n-/// a requested layout.\n-///\n-/// [`grow_in_place`]: ./trait.AllocRef.html#method.grow_in_place\n-/// [`shrink_in_place`]: ./trait.AllocRef.html#method.shrink_in_place\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct CannotReallocInPlace;\n-\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-impl CannotReallocInPlace {\n-    pub fn description(&self) -> &str {\n-        \"cannot reallocate allocator's memory in place\"\n-    }\n-}\n-\n-// (we need this for downstream impl of trait Error)\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-impl fmt::Display for CannotReallocInPlace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", self.description())\n-    }\n-}\n-\n-/// A memory allocator that can be registered as the standard library\u2019s default\n-/// through the `#[global_allocator]` attribute.\n-///\n-/// Some of the methods require that a memory block be *currently\n-/// allocated* via an allocator. This means that:\n-///\n-/// * the starting address for that memory block was previously\n-///   returned by a previous call to an allocation method\n-///   such as `alloc`, and\n-///\n-/// * the memory block has not been subsequently deallocated, where\n-///   blocks are deallocated either by being passed to a deallocation\n-///   method such as `dealloc` or by being\n-///   passed to a reallocation method that returns a non-null pointer.\n-///\n-///\n-/// # Example\n-///\n-/// ```no_run\n-/// use std::alloc::{GlobalAlloc, Layout, alloc};\n-/// use std::ptr::null_mut;\n-///\n-/// struct MyAllocator;\n-///\n-/// unsafe impl GlobalAlloc for MyAllocator {\n-///     unsafe fn alloc(&self, _layout: Layout) -> *mut u8 { null_mut() }\n-///     unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}\n-/// }\n-///\n-/// #[global_allocator]\n-/// static A: MyAllocator = MyAllocator;\n-///\n-/// fn main() {\n-///     unsafe {\n-///         assert!(alloc(Layout::new::<u32>()).is_null())\n-///     }\n-/// }\n-/// ```\n-///\n-/// # Safety\n-///\n-/// The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and\n-/// implementors must ensure that they adhere to these contracts:\n-///\n-/// * It's undefined behavior if global allocators unwind. This restriction may\n-///   be lifted in the future, but currently a panic from any of these\n-///   functions may lead to memory unsafety.\n-///\n-/// * `Layout` queries and calculations in general must be correct. Callers of\n-///   this trait are allowed to rely on the contracts defined on each method,\n-///   and implementors must ensure such contracts remain true.\n-#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n-pub unsafe trait GlobalAlloc {\n-    /// Allocate memory as described by the given `layout`.\n-    ///\n-    /// Returns a pointer to newly-allocated memory,\n-    /// or null to indicate allocation failure.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure that `layout` has non-zero size.\n-    ///\n-    /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g., guarantee a sentinel address or a null pointer\n-    /// in response to a zero-size allocation request.)\n-    ///\n-    /// The allocated block of memory may or may not be initialized.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning a null pointer indicates that either memory is exhausted\n-    /// or `layout` does not meet this allocator's size or alignment constraints.\n-    ///\n-    /// Implementations are encouraged to return null on memory\n-    /// exhaustion rather than aborting, but this is not\n-    /// a strict requirement. (Specifically: it is *legal* to\n-    /// implement this trait atop an underlying native allocation\n-    /// library that aborts on memory exhaustion.)\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n-    unsafe fn alloc(&self, layout: Layout) -> *mut u8;\n-\n-    /// Deallocate the block of memory at the given `ptr` pointer with the given `layout`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via\n-    ///   this allocator,\n-    ///\n-    /// * `layout` must be the same layout that was used\n-    ///   to allocate that block of memory,\n-    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n-    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);\n-\n-    /// Behaves like `alloc`, but also ensures that the contents\n-    /// are set to zero before being returned.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `alloc` is.\n-    /// However the allocated block of memory is guaranteed to be initialized.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning a null pointer indicates that either memory is exhausted\n-    /// or `layout` does not meet allocator's size or alignment constraints,\n-    /// just as in `alloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        let size = layout.size();\n-        let ptr = self.alloc(layout);\n-        if !ptr.is_null() {\n-            ptr::write_bytes(ptr, 0, size);\n-        }\n-        ptr\n-    }\n-\n-    /// Shrink or grow a block of memory to the given `new_size`.\n-    /// The block is described by the given `ptr` pointer and `layout`.\n-    ///\n-    /// If this returns a non-null pointer, then ownership of the memory block\n-    /// referenced by `ptr` has been transferred to this allocator.\n-    /// The memory may or may not have been deallocated,\n-    /// and should be considered unusable (unless of course it was\n-    /// transferred back to the caller again via the return value of\n-    /// this method). The new memory block is allocated with `layout`, but\n-    /// with the `size` updated to `new_size`.\n-    ///\n-    /// If this method returns null, then ownership of the memory\n-    /// block has not been transferred to this allocator, and the\n-    /// contents of the memory block are unaltered.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * `layout` must be the same layout that was used\n-    ///   to allocate that block of memory,\n-    ///\n-    /// * `new_size` must be greater than zero.\n-    ///\n-    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n-    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n-    ///\n-    /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g., guarantee a sentinel address or a null pointer\n-    /// in response to a zero-size allocation request.)\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returns null if the new layout does not meet the size\n-    /// and alignment constraints of the allocator, or if reallocation\n-    /// otherwise fails.\n-    ///\n-    /// Implementations are encouraged to return null on memory\n-    /// exhaustion rather than panicking or aborting, but this is not\n-    /// a strict requirement. (Specifically: it is *legal* to\n-    /// implement this trait atop an underlying native allocation\n-    /// library that aborts on memory exhaustion.)\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n-    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let new_ptr = self.alloc(new_layout);\n-        if !new_ptr.is_null() {\n-            ptr::copy_nonoverlapping(ptr, new_ptr, cmp::min(layout.size(), new_size));\n-            self.dealloc(ptr, layout);\n-        }\n-        new_ptr\n-    }\n-}\n-\n-/// An implementation of `AllocRef` can allocate, reallocate, and\n-/// deallocate arbitrary blocks of data described via `Layout`.\n-///\n-/// `AllocRef` is designed to be implemented on ZSTs, references, or\n-/// smart pointers because having an allocator like `MyAlloc([u8; N])`\n-/// cannot be moved, without updating the pointers to the allocated\n-/// memory.\n-///\n-/// Some of the methods require that a memory block be *currently\n-/// allocated* via an allocator. This means that:\n-///\n-/// * the starting address for that memory block was previously\n-///   returned by a previous call to an allocation method (`alloc`,\n-///   `alloc_zeroed`) or reallocation method (`realloc`), and\n-///\n-/// * the memory block has not been subsequently deallocated, where\n-///   blocks are deallocated either by being passed to a deallocation\n-///   method (`dealloc`) or by being passed to a reallocation method\n-///  (see above) that returns `Ok`.\n-///\n-/// Unlike [`GlobalAlloc`], zero-sized allocations are allowed in\n-/// `AllocRef`. If an underlying allocator does not support this (like\n-/// jemalloc) or return a null pointer (such as `libc::malloc`), this case\n-/// must be caught. In this case [`Layout::dangling()`] can be used to\n-/// create a dangling, but aligned `NonNull<u8>`.\n-///\n-/// Some of the methods require that a layout *fit* a memory block.\n-/// What it means for a layout to \"fit\" a memory block means (or\n-/// equivalently, for a memory block to \"fit\" a layout) is that the\n-/// following two conditions must hold:\n-///\n-/// 1. The block's starting address must be aligned to `layout.align()`.\n-///\n-/// 2. The block's size must fall in the range `[use_min, use_max]`, where:\n-///\n-///    * `use_min` is `layout.size()`, and\n-///\n-///    * `use_max` is the capacity that was returned.\n-///\n-/// Note that:\n-///\n-///  * the size of the layout most recently used to allocate the block\n-///    is guaranteed to be in the range `[use_min, use_max]`, and\n-///\n-///  * a lower-bound on `use_max` can be safely approximated by a call to\n-///    `usable_size`.\n-///\n-///  * if a layout `k` fits a memory block (denoted by `ptr`)\n-///    currently allocated via an allocator `a`, then it is legal to\n-///    use that layout to deallocate it, i.e., `a.dealloc(ptr, k);`.\n-///\n-///  * if an allocator does not support overallocating, it is fine to\n-///    simply return `layout.size()` as the allocated size.\n-///\n-/// [`GlobalAlloc`]: self::GlobalAlloc\n-/// [`Layout::dangling()`]: self::Layout::dangling\n-///\n-/// # Safety\n-///\n-/// The `AllocRef` trait is an `unsafe` trait for a number of reasons, and\n-/// implementors must ensure that they adhere to these contracts:\n-///\n-/// * Pointers returned from allocation functions must point to valid memory and\n-///   retain their validity until at least one instance of `AllocRef` is dropped\n-///   itself.\n-///\n-/// * Cloning or moving the allocator must not invalidate pointers returned\n-///   from this allocator. Cloning must return a reference to the same allocator.\n-///\n-/// * `Layout` queries and calculations in general must be correct. Callers of\n-///   this trait are allowed to rely on the contracts defined on each method,\n-///   and implementors must ensure such contracts remain true.\n-///\n-/// Note that this list may get tweaked over time as clarifications are made in\n-/// the future.\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub unsafe trait AllocRef {\n-    /// On success, returns a pointer meeting the size and alignment\n-    /// guarantees of `layout` and the actual size of the allocated block,\n-    /// which must be greater than or equal to `layout.size()`.\n-    ///\n-    /// If this method returns an `Ok(addr)`, then the `addr` returned\n-    /// will be non-null address pointing to a block of storage\n-    /// suitable for holding an instance of `layout`.\n-    ///\n-    /// The returned block of storage may or may not have its contents\n-    /// initialized. (Extension subtraits might restrict this\n-    /// behavior, e.g., to ensure initialization to particular sets of\n-    /// bit patterns.)\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// Implementations are encouraged to return `Err` on memory\n-    /// exhaustion rather than panicking or aborting, but this is not\n-    /// a strict requirement. (Specifically: it is *legal* to\n-    /// implement this trait atop an underlying native allocation\n-    /// library that aborts on memory exhaustion.)\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr>;\n-\n-    /// Deallocate the memory referenced by `ptr`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via\n-    ///   this allocator,\n-    ///\n-    /// * `layout` must *fit* that block of memory,\n-    ///\n-    /// * In addition to fitting the block of memory `layout`, the\n-    ///   alignment of the `layout` must match the alignment used\n-    ///   to allocate that block of memory.\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n-\n-    /// Behaves like `alloc`, but also ensures that the contents\n-    /// are set to zero before being returned.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints, just as in `alloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let size = layout.size();\n-        let result = self.alloc(layout);\n-        if let Ok((p, _)) = result {\n-            unsafe { ptr::write_bytes(p.as_ptr(), 0, size) }\n-        }\n-        result\n-    }\n-\n-    // == METHODS FOR MEMORY REUSE ==\n-    // realloc, realloc_zeroed, grow_in_place, grow_in_place_zeroed, shrink_in_place\n-\n-    /// Returns a pointer suitable for holding data described by\n-    /// a new layout with `layout`\u2019s alignment and a size given\n-    /// by `new_size` and the actual size of the allocated block.\n-    /// The latter is greater than or equal to `layout.size()`.\n-    /// To accomplish this, the allocator may extend or shrink\n-    /// the allocation referenced by `ptr` to fit the new layout.\n-    ///\n-    /// If this returns `Ok`, then ownership of the memory block\n-    /// referenced by `ptr` has been transferred to this\n-    /// allocator. The memory may or may not have been freed, and\n-    /// should be considered unusable (unless of course it was\n-    /// transferred back to the caller again via the return value of\n-    /// this method).\n-    ///\n-    /// If this method returns `Err`, then ownership of the memory\n-    /// block has not been transferred to this allocator, and the\n-    /// contents of the memory block are unaltered.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * `layout` must *fit* the `ptr` (see above). (The `new_size`\n-    ///   argument need not fit it.)\n-    ///\n-    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n-    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n-    ///\n-    /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g., guarantee a sentinel address or a null pointer\n-    /// in response to a zero-size allocation request.)\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returns `Err` only if the new layout\n-    /// does not meet the allocator's size\n-    /// and alignment constraints of the allocator, or if reallocation\n-    /// otherwise fails.\n-    ///\n-    /// Implementations are encouraged to return `Err` on memory\n-    /// exhaustion rather than panicking or aborting, but this is not\n-    /// a strict requirement. (Specifically: it is *legal* to\n-    /// implement this trait atop an underlying native allocation\n-    /// library that aborts on memory exhaustion.)\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let old_size = layout.size();\n-\n-        if new_size > old_size {\n-            if let Ok(size) = self.grow_in_place(ptr, layout, new_size) {\n-                return Ok((ptr, size));\n-            }\n-        } else if new_size < old_size {\n-            if let Ok(size) = self.shrink_in_place(ptr, layout, new_size) {\n-                return Ok((ptr, size));\n-            }\n-        } else {\n-            return Ok((ptr, new_size));\n-        }\n-\n-        // otherwise, fall back on alloc + copy + dealloc.\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let result = self.alloc(new_layout);\n-        if let Ok((new_ptr, _)) = result {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n-            self.dealloc(ptr, layout);\n-        }\n-        result\n-    }\n-\n-    /// Behaves like `realloc`, but also ensures that the new contents\n-    /// are set to zero before being returned.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `realloc` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returns `Err` only if the new layout\n-    /// does not meet the allocator's size\n-    /// and alignment constraints of the allocator, or if reallocation\n-    /// otherwise fails.\n-    ///\n-    /// Implementations are encouraged to return `Err` on memory\n-    /// exhaustion rather than panicking or aborting, but this is not\n-    /// a strict requirement. (Specifically: it is *legal* to\n-    /// implement this trait atop an underlying native allocation\n-    /// library that aborts on memory exhaustion.)\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_zeroed(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let old_size = layout.size();\n-\n-        if new_size > old_size {\n-            if let Ok(size) = self.grow_in_place_zeroed(ptr, layout, new_size) {\n-                return Ok((ptr, size));\n-            }\n-        } else if new_size < old_size {\n-            if let Ok(size) = self.shrink_in_place(ptr, layout, new_size) {\n-                return Ok((ptr, size));\n-            }\n-        } else {\n-            return Ok((ptr, new_size));\n-        }\n-\n-        // otherwise, fall back on alloc + copy + dealloc.\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let result = self.alloc_zeroed(new_layout);\n-        if let Ok((new_ptr, _)) = result {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n-            self.dealloc(ptr, layout);\n-        }\n-        result\n-    }\n-\n-    /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n-    ///\n-    /// If this returns `Ok`, then the allocator has asserted that the\n-    /// memory block referenced by `ptr` now fits `new_size`, and thus can\n-    /// be used to carry data of a layout of that size and same alignment as\n-    /// `layout`. The returned value is the new size of the allocated block.\n-    /// (The allocator is allowed to expend effort to accomplish this, such\n-    /// as extending the memory block to include successor blocks, or virtual\n-    /// memory tricks.)\n-    ///\n-    /// Regardless of what this method returns, ownership of the\n-    /// memory block referenced by `ptr` has not been transferred, and\n-    /// the contents of the memory block are unaltered.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * `layout` must *fit* the `ptr` (see above); note the\n-    ///   `new_size` argument need not fit it,\n-    ///\n-    /// * `new_size` must not be less than `layout.size()`,\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n-    /// unable to assert that the memory block referenced by `ptr`\n-    /// could fit `layout`.\n-    ///\n-    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n-    /// function; clients are expected either to be able to recover from\n-    /// `grow_in_place` failures without aborting, or to fall back on\n-    /// another reallocation method before resorting to an abort.\n-    #[inline]\n-    unsafe fn grow_in_place(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<usize, CannotReallocInPlace> {\n-        let _ = ptr;\n-        let _ = layout;\n-        let _ = new_size;\n-        Err(CannotReallocInPlace)\n-    }\n-\n-    /// Behaves like `grow_in_place`, but also ensures that the new\n-    /// contents are set to zero before being returned.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `grow_in_place` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n-    /// unable to assert that the memory block referenced by `ptr`\n-    /// could fit `layout`.\n-    ///\n-    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n-    /// function; clients are expected either to be able to recover from\n-    /// `grow_in_place` failures without aborting, or to fall back on\n-    /// another reallocation method before resorting to an abort.\n-    unsafe fn grow_in_place_zeroed(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<usize, CannotReallocInPlace> {\n-        let size = self.grow_in_place(ptr, layout, new_size)?;\n-        ptr.as_ptr().add(layout.size()).write_bytes(0, new_size - layout.size());\n-        Ok(size)\n-    }\n-\n-    /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n-    ///\n-    /// If this returns `Ok`, then the allocator has asserted that the\n-    /// memory block referenced by `ptr` now fits `new_size`, and\n-    /// thus can only be used to carry data of that smaller\n-    /// layout. The returned value is the new size the allocated block.\n-    /// (The allocator is allowed to take advantage of this,\n-    /// carving off portions of the block for reuse elsewhere.) The\n-    /// truncated contents of the block within the smaller layout are\n-    /// unaltered, and ownership of block has not been transferred.\n-    ///\n-    /// If this returns `Err`, then the memory block is considered to\n-    /// still represent the original (larger) `layout`. None of the\n-    /// block has been carved off for reuse elsewhere, ownership of\n-    /// the memory block has not been transferred, and the contents of\n-    /// the memory block are unaltered.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * `layout` must *fit* the `ptr` (see above); note the\n-    ///   `new_size` argument need not fit it,\n-    ///\n-    /// * `new_size` must not be greater than `layout.size()`,\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n-    /// unable to assert that the memory block referenced by `ptr`\n-    /// could fit `layout`.\n-    ///\n-    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n-    /// function; clients are expected either to be able to recover from\n-    /// `shrink_in_place` failures without aborting, or to fall back\n-    /// on another reallocation method before resorting to an abort.\n-    #[inline]\n-    unsafe fn shrink_in_place(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<usize, CannotReallocInPlace> {\n-        let _ = ptr;\n-        let _ = layout;\n-        let _ = new_size;\n-        Err(CannotReallocInPlace)\n-    }\n-}"}, {"sha": "147fe696ac02fb2433f1071705f15c6882d0c37f", "filename": "src/libcore/alloc/global.rs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Falloc%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Falloc%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fglobal.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -0,0 +1,198 @@\n+use crate::alloc::Layout;\n+use crate::cmp;\n+use crate::ptr;\n+\n+/// A memory allocator that can be registered as the standard library\u2019s default\n+/// through the `#[global_allocator]` attribute.\n+///\n+/// Some of the methods require that a memory block be *currently\n+/// allocated* via an allocator. This means that:\n+///\n+/// * the starting address for that memory block was previously\n+///   returned by a previous call to an allocation method\n+///   such as `alloc`, and\n+///\n+/// * the memory block has not been subsequently deallocated, where\n+///   blocks are deallocated either by being passed to a deallocation\n+///   method such as `dealloc` or by being\n+///   passed to a reallocation method that returns a non-null pointer.\n+///\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// use std::alloc::{GlobalAlloc, Layout, alloc};\n+/// use std::ptr::null_mut;\n+///\n+/// struct MyAllocator;\n+///\n+/// unsafe impl GlobalAlloc for MyAllocator {\n+///     unsafe fn alloc(&self, _layout: Layout) -> *mut u8 { null_mut() }\n+///     unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}\n+/// }\n+///\n+/// #[global_allocator]\n+/// static A: MyAllocator = MyAllocator;\n+///\n+/// fn main() {\n+///     unsafe {\n+///         assert!(alloc(Layout::new::<u32>()).is_null())\n+///     }\n+/// }\n+/// ```\n+///\n+/// # Safety\n+///\n+/// The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and\n+/// implementors must ensure that they adhere to these contracts:\n+///\n+/// * It's undefined behavior if global allocators unwind. This restriction may\n+///   be lifted in the future, but currently a panic from any of these\n+///   functions may lead to memory unsafety.\n+///\n+/// * `Layout` queries and calculations in general must be correct. Callers of\n+///   this trait are allowed to rely on the contracts defined on each method,\n+///   and implementors must ensure such contracts remain true.\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+pub unsafe trait GlobalAlloc {\n+    /// Allocate memory as described by the given `layout`.\n+    ///\n+    /// Returns a pointer to newly-allocated memory,\n+    /// or null to indicate allocation failure.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure that `layout` has non-zero size.\n+    ///\n+    /// (Extension subtraits might provide more specific bounds on\n+    /// behavior, e.g., guarantee a sentinel address or a null pointer\n+    /// in response to a zero-size allocation request.)\n+    ///\n+    /// The allocated block of memory may or may not be initialized.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning a null pointer indicates that either memory is exhausted\n+    /// or `layout` does not meet this allocator's size or alignment constraints.\n+    ///\n+    /// Implementations are encouraged to return null on memory\n+    /// exhaustion rather than aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8;\n+\n+    /// Deallocate the block of memory at the given `ptr` pointer with the given `layout`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must denote a block of memory currently allocated via\n+    ///   this allocator,\n+    ///\n+    /// * `layout` must be the same layout that was used\n+    ///   to allocate that block of memory,\n+    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);\n+\n+    /// Behaves like `alloc`, but also ensures that the contents\n+    /// are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    /// However the allocated block of memory is guaranteed to be initialized.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning a null pointer indicates that either memory is exhausted\n+    /// or `layout` does not meet allocator's size or alignment constraints,\n+    /// just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        let size = layout.size();\n+        let ptr = self.alloc(layout);\n+        if !ptr.is_null() {\n+            ptr::write_bytes(ptr, 0, size);\n+        }\n+        ptr\n+    }\n+\n+    /// Shrink or grow a block of memory to the given `new_size`.\n+    /// The block is described by the given `ptr` pointer and `layout`.\n+    ///\n+    /// If this returns a non-null pointer, then ownership of the memory block\n+    /// referenced by `ptr` has been transferred to this allocator.\n+    /// The memory may or may not have been deallocated,\n+    /// and should be considered unusable (unless of course it was\n+    /// transferred back to the caller again via the return value of\n+    /// this method). The new memory block is allocated with `layout`, but\n+    /// with the `size` updated to `new_size`.\n+    ///\n+    /// If this method returns null, then ownership of the memory\n+    /// block has not been transferred to this allocator, and the\n+    /// contents of the memory block are unaltered.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must be currently allocated via this allocator,\n+    ///\n+    /// * `layout` must be the same layout that was used\n+    ///   to allocate that block of memory,\n+    ///\n+    /// * `new_size` must be greater than zero.\n+    ///\n+    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n+    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n+    ///\n+    /// (Extension subtraits might provide more specific bounds on\n+    /// behavior, e.g., guarantee a sentinel address or a null pointer\n+    /// in response to a zero-size allocation request.)\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns null if the new layout does not meet the size\n+    /// and alignment constraints of the allocator, or if reallocation\n+    /// otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return null on memory\n+    /// exhaustion rather than panicking or aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let new_ptr = self.alloc(new_layout);\n+        if !new_ptr.is_null() {\n+            ptr::copy_nonoverlapping(ptr, new_ptr, cmp::min(layout.size(), new_size));\n+            self.dealloc(ptr, layout);\n+        }\n+        new_ptr\n+    }\n+}"}, {"sha": "fa644cfe99ed63572cdb8d0fbe034e368300aca3", "filename": "src/libcore/alloc/layout.rs", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Flayout.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -0,0 +1,346 @@\n+// ignore-tidy-undocumented-unsafe\n+\n+use crate::cmp;\n+use crate::fmt;\n+use crate::mem;\n+use crate::num::NonZeroUsize;\n+use crate::ptr::NonNull;\n+\n+const fn size_align<T>() -> (usize, usize) {\n+    (mem::size_of::<T>(), mem::align_of::<T>())\n+}\n+\n+/// Layout of a block of memory.\n+///\n+/// An instance of `Layout` describes a particular layout of memory.\n+/// You build a `Layout` up as an input to give to an allocator.\n+///\n+/// All layouts have an associated size and a power-of-two alignment.\n+///\n+/// (Note that layouts are *not* required to have non-zero size,\n+/// even though `GlobalAlloc` requires that all memory requests\n+/// be non-zero in size. A caller must either ensure that conditions\n+/// like this are met, use specific allocators with looser\n+/// requirements, or use the more lenient `AllocRef` interface.)\n+#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[lang = \"alloc_layout\"]\n+pub struct Layout {\n+    // size of the requested block of memory, measured in bytes.\n+    size_: usize,\n+\n+    // alignment of the requested block of memory, measured in bytes.\n+    // we ensure that this is always a power-of-two, because API's\n+    // like `posix_memalign` require it and it is a reasonable\n+    // constraint to impose on Layout constructors.\n+    //\n+    // (However, we do not analogously require `align >= sizeof(void*)`,\n+    //  even though that is *also* a requirement of `posix_memalign`.)\n+    align_: NonZeroUsize,\n+}\n+\n+impl Layout {\n+    /// Constructs a `Layout` from a given `size` and `align`,\n+    /// or returns `LayoutErr` if any of the following conditions\n+    /// are not met:\n+    ///\n+    /// * `align` must not be zero,\n+    ///\n+    /// * `align` must be a power of two,\n+    ///\n+    /// * `size`, when rounded up to the nearest multiple of `align`,\n+    ///    must not overflow (i.e., the rounded value must be less than\n+    ///    or equal to `usize::MAX`).\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n+    #[inline]\n+    pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n+        if !align.is_power_of_two() {\n+            return Err(LayoutErr { private: () });\n+        }\n+\n+        // (power-of-two implies align != 0.)\n+\n+        // Rounded up size is:\n+        //   size_rounded_up = (size + align - 1) & !(align - 1);\n+        //\n+        // We know from above that align != 0. If adding (align - 1)\n+        // does not overflow, then rounding up will be fine.\n+        //\n+        // Conversely, &-masking with !(align - 1) will subtract off\n+        // only low-order-bits. Thus if overflow occurs with the sum,\n+        // the &-mask cannot subtract enough to undo that overflow.\n+        //\n+        // Above implies that checking for summation overflow is both\n+        // necessary and sufficient.\n+        if size > usize::MAX - (align - 1) {\n+            return Err(LayoutErr { private: () });\n+        }\n+\n+        unsafe { Ok(Layout::from_size_align_unchecked(size, align)) }\n+    }\n+\n+    /// Creates a layout, bypassing all checks.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe as it does not verify the preconditions from\n+    /// [`Layout::from_size_align`](#method.from_size_align).\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[inline]\n+    pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n+        Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n+    }\n+\n+    /// The minimum size in bytes for a memory block of this layout.\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n+    #[inline]\n+    pub const fn size(&self) -> usize {\n+        self.size_\n+    }\n+\n+    /// The minimum byte alignment for a memory block of this layout.\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n+    #[inline]\n+    pub const fn align(&self) -> usize {\n+        self.align_.get()\n+    }\n+\n+    /// Constructs a `Layout` suitable for holding a value of type `T`.\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_stable(feature = \"alloc_layout_const_new\", since = \"1.42.0\")]\n+    #[inline]\n+    pub const fn new<T>() -> Self {\n+        let (size, align) = size_align::<T>();\n+        // Note that the align is guaranteed by rustc to be a power of two and\n+        // the size+align combo is guaranteed to fit in our address space. As a\n+        // result use the unchecked constructor here to avoid inserting code\n+        // that panics if it isn't optimized well enough.\n+        unsafe { Layout::from_size_align_unchecked(size, align) }\n+    }\n+\n+    /// Produces layout describing a record that could be used to\n+    /// allocate backing structure for `T` (which could be a trait\n+    /// or other unsized type like a slice).\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[inline]\n+    pub fn for_value<T: ?Sized>(t: &T) -> Self {\n+        let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n+        // See rationale in `new` for why this is using an unsafe variant below\n+        debug_assert!(Layout::from_size_align(size, align).is_ok());\n+        unsafe { Layout::from_size_align_unchecked(size, align) }\n+    }\n+\n+    /// Creates a `NonNull` that is dangling, but well-aligned for this Layout.\n+    ///\n+    /// Note that the pointer value may potentially represent a valid pointer,\n+    /// which means this must not be used as a \"not yet initialized\"\n+    /// sentinel value. Types that lazily allocate must track initialization by\n+    /// some other means.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub const fn dangling(&self) -> NonNull<u8> {\n+        // align is non-zero and a power of two\n+        unsafe { NonNull::new_unchecked(self.align() as *mut u8) }\n+    }\n+\n+    /// Creates a layout describing the record that can hold a value\n+    /// of the same layout as `self`, but that also is aligned to\n+    /// alignment `align` (measured in bytes).\n+    ///\n+    /// If `self` already meets the prescribed alignment, then returns\n+    /// `self`.\n+    ///\n+    /// Note that this method does not add any padding to the overall\n+    /// size, regardless of whether the returned layout has a different\n+    /// alignment. In other words, if `K` has size 16, `K.align_to(32)`\n+    /// will *still* have size 16.\n+    ///\n+    /// Returns an error if the combination of `self.size()` and the given\n+    /// `align` violates the conditions listed in\n+    /// [`Layout::from_size_align`](#method.from_size_align).\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub fn align_to(&self, align: usize) -> Result<Self, LayoutErr> {\n+        Layout::from_size_align(self.size(), cmp::max(self.align(), align))\n+    }\n+\n+    /// Returns the amount of padding we must insert after `self`\n+    /// to ensure that the following address will satisfy `align`\n+    /// (measured in bytes).\n+    ///\n+    /// e.g., if `self.size()` is 9, then `self.padding_needed_for(4)`\n+    /// returns 3, because that is the minimum number of bytes of\n+    /// padding required to get a 4-aligned address (assuming that the\n+    /// corresponding memory block starts at a 4-aligned address).\n+    ///\n+    /// The return value of this function has no meaning if `align` is\n+    /// not a power-of-two.\n+    ///\n+    /// Note that the utility of the returned value requires `align`\n+    /// to be less than or equal to the alignment of the starting\n+    /// address for the whole allocated block of memory. One way to\n+    /// satisfy this constraint is to ensure `align <= self.align()`.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n+    #[inline]\n+    pub const fn padding_needed_for(&self, align: usize) -> usize {\n+        let len = self.size();\n+\n+        // Rounded up value is:\n+        //   len_rounded_up = (len + align - 1) & !(align - 1);\n+        // and then we return the padding difference: `len_rounded_up - len`.\n+        //\n+        // We use modular arithmetic throughout:\n+        //\n+        // 1. align is guaranteed to be > 0, so align - 1 is always\n+        //    valid.\n+        //\n+        // 2. `len + align - 1` can overflow by at most `align - 1`,\n+        //    so the &-mask with `!(align - 1)` will ensure that in the\n+        //    case of overflow, `len_rounded_up` will itself be 0.\n+        //    Thus the returned padding, when added to `len`, yields 0,\n+        //    which trivially satisfies the alignment `align`.\n+        //\n+        // (Of course, attempts to allocate blocks of memory whose\n+        // size and padding overflow in the above manner should cause\n+        // the allocator to yield an error anyway.)\n+\n+        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);\n+        len_rounded_up.wrapping_sub(len)\n+    }\n+\n+    /// Creates a layout by rounding the size of this layout up to a multiple\n+    /// of the layout's alignment.\n+    ///\n+    /// This is equivalent to adding the result of `padding_needed_for`\n+    /// to the layout's current size.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub fn pad_to_align(&self) -> Layout {\n+        let pad = self.padding_needed_for(self.align());\n+        // This cannot overflow. Quoting from the invariant of Layout:\n+        // > `size`, when rounded up to the nearest multiple of `align`,\n+        // > must not overflow (i.e., the rounded value must be less than\n+        // > `usize::MAX`)\n+        let new_size = self.size() + pad;\n+\n+        Layout::from_size_align(new_size, self.align()).unwrap()\n+    }\n+\n+    /// Creates a layout describing the record for `n` instances of\n+    /// `self`, with a suitable amount of padding between each to\n+    /// ensure that each instance is given its requested size and\n+    /// alignment. On success, returns `(k, offs)` where `k` is the\n+    /// layout of the array and `offs` is the distance between the start\n+    /// of each element in the array.\n+    ///\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n+        // This cannot overflow. Quoting from the invariant of Layout:\n+        // > `size`, when rounded up to the nearest multiple of `align`,\n+        // > must not overflow (i.e., the rounded value must be less than\n+        // > `usize::MAX`)\n+        let padded_size = self.size() + self.padding_needed_for(self.align());\n+        let alloc_size = padded_size.checked_mul(n).ok_or(LayoutErr { private: () })?;\n+\n+        unsafe {\n+            // self.align is already known to be valid and alloc_size has been\n+            // padded already.\n+            Ok((Layout::from_size_align_unchecked(alloc_size, self.align()), padded_size))\n+        }\n+    }\n+\n+    /// Creates a layout describing the record for `self` followed by\n+    /// `next`, including any necessary padding to ensure that `next`\n+    /// will be properly aligned. Note that the resulting layout will\n+    /// satisfy the alignment properties of both `self` and `next`.\n+    ///\n+    /// The resulting layout will be the same as that of a C struct containing\n+    /// two fields with the layouts of `self` and `next`, in that order.\n+    ///\n+    /// Returns `Some((k, offset))`, where `k` is layout of the concatenated\n+    /// record and `offset` is the relative location, in bytes, of the\n+    /// start of the `next` embedded within the concatenated record\n+    /// (assuming that the record itself starts at offset 0).\n+    ///\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n+        let new_align = cmp::max(self.align(), next.align());\n+        let pad = self.padding_needed_for(next.align());\n+\n+        let offset = self.size().checked_add(pad).ok_or(LayoutErr { private: () })?;\n+        let new_size = offset.checked_add(next.size()).ok_or(LayoutErr { private: () })?;\n+\n+        let layout = Layout::from_size_align(new_size, new_align)?;\n+        Ok((layout, offset))\n+    }\n+\n+    /// Creates a layout describing the record for `n` instances of\n+    /// `self`, with no padding between each instance.\n+    ///\n+    /// Note that, unlike `repeat`, `repeat_packed` does not guarantee\n+    /// that the repeated instances of `self` will be properly\n+    /// aligned, even if a given instance of `self` is properly\n+    /// aligned. In other words, if the layout returned by\n+    /// `repeat_packed` is used to allocate an array, it is not\n+    /// guaranteed that all elements in the array will be properly\n+    /// aligned.\n+    ///\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutErr> {\n+        let size = self.size().checked_mul(n).ok_or(LayoutErr { private: () })?;\n+        Layout::from_size_align(size, self.align())\n+    }\n+\n+    /// Creates a layout describing the record for `self` followed by\n+    /// `next` with no additional padding between the two. Since no\n+    /// padding is inserted, the alignment of `next` is irrelevant,\n+    /// and is not incorporated *at all* into the resulting layout.\n+    ///\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutErr> {\n+        let new_size = self.size().checked_add(next.size()).ok_or(LayoutErr { private: () })?;\n+        Layout::from_size_align(new_size, self.align())\n+    }\n+\n+    /// Creates a layout describing the record for a `[T; n]`.\n+    ///\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n+        Layout::new::<T>().repeat(n).map(|(k, offs)| {\n+            debug_assert!(offs == mem::size_of::<T>());\n+            k\n+        })\n+    }\n+}\n+\n+/// The parameters given to `Layout::from_size_align`\n+/// or some other `Layout` constructor\n+/// do not satisfy its documented constraints.\n+#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct LayoutErr {\n+    private: (),\n+}\n+\n+// (we need this for downstream impl of trait Error)\n+#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+impl fmt::Display for LayoutErr {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"invalid parameters to Layout::from_size_align\")\n+    }\n+}"}, {"sha": "e1892edb7c7f3014852ecf9bbfcbd58d1fb30b2f", "filename": "src/libcore/alloc/mod.rs", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -0,0 +1,367 @@\n+//! Memory allocation APIs\n+\n+#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n+\n+mod global;\n+mod layout;\n+\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+pub use self::global::GlobalAlloc;\n+#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+pub use self::layout::{Layout, LayoutErr};\n+\n+use crate::fmt;\n+use crate::ptr::{self, NonNull};\n+\n+/// The `AllocErr` error indicates an allocation failure\n+/// that may be due to resource exhaustion or to\n+/// something wrong when combining the given input arguments with this\n+/// allocator.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct AllocErr;\n+\n+// (we need this for downstream impl of trait Error)\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+impl fmt::Display for AllocErr {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"memory allocation failed\")\n+    }\n+}\n+\n+/// A desired initial state for allocated memory.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+pub enum AllocInit {\n+    /// The contents of the new memory are uninitialized.\n+    Uninitialized,\n+    /// The new memory is guaranteed to be zeroed.\n+    Zeroed,\n+}\n+\n+impl AllocInit {\n+    /// Initialize the specified memory block.\n+    ///\n+    /// This behaves like calling [`AllocInit::init_offset(memory, 0)`][off].\n+    ///\n+    /// [off]: AllocInit::init_offset\n+    ///\n+    /// # Safety\n+    ///\n+    /// * `memory.ptr` must be [valid] for writes of `memory.size` bytes.\n+    ///\n+    /// [valid]: ../../core/ptr/index.html#safety\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub unsafe fn init(self, memory: MemoryBlock) {\n+        self.init_offset(memory, 0)\n+    }\n+\n+    /// Initialize the memory block like specified by `init` at the specified `offset`.\n+    ///\n+    /// This is a no-op for [`AllocInit::Uninitialized`][] and writes zeroes for\n+    /// [`AllocInit::Zeroed`][] at `ptr + offset` until `ptr + layout.size()`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// * `memory.ptr` must be [valid] for writes of `memory.size` bytes.\n+    /// * `offset` must be smaller than or equal to `memory.size`\n+    ///\n+    /// [valid]: ../../core/ptr/index.html#safety\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub unsafe fn init_offset(self, memory: MemoryBlock, offset: usize) {\n+        debug_assert!(\n+            offset <= memory.size,\n+            \"`offset` must be smaller than or equal to `memory.size`\"\n+        );\n+        match self {\n+            AllocInit::Uninitialized => (),\n+            AllocInit::Zeroed => {\n+                memory.ptr.as_ptr().add(offset).write_bytes(0, memory.size - offset)\n+            }\n+        }\n+    }\n+}\n+\n+/// Represents a block of allocated memory returned by an allocator.\n+#[derive(Debug, Copy, Clone)]\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+pub struct MemoryBlock {\n+    pub ptr: NonNull<u8>,\n+    pub size: usize,\n+}\n+\n+/// A placement constraint when growing or shrinking an existing allocation.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+pub enum ReallocPlacement {\n+    /// The allocator is allowed to move the allocation to a different memory address.\n+    // FIXME(wg-allocators#46): Add a section to the module documentation \"What is a legal\n+    //                          allocator\" and link it at \"valid location\".\n+    ///\n+    /// If the allocation _does_ move, it's the responsibility of the allocator\n+    /// to also move the data from the previous location to the new location.\n+    MayMove,\n+    /// The address of the new memory must not change.\n+    ///\n+    /// If the allocation would have to be moved to a new location to fit, the\n+    /// reallocation request will fail.\n+    InPlace,\n+}\n+\n+/// An implementation of `AllocRef` can allocate, grow, shrink, and deallocate arbitrary blocks of\n+/// data described via [`Layout`][].\n+///\n+/// `AllocRef` is designed to be implemented on ZSTs, references, or smart pointers because having\n+/// an allocator like `MyAlloc([u8; N])` cannot be moved, without updating the pointers to the\n+/// allocated memory.\n+///\n+/// Unlike [`GlobalAlloc`][], zero-sized allocations are allowed in `AllocRef`. If an underlying\n+/// allocator does not support this (like jemalloc) or return a null pointer (such as\n+/// `libc::malloc`), this must be caught by the implementation.\n+///\n+/// ### Currently allocated memory\n+///\n+/// Some of the methods require that a memory block be *currently allocated* via an allocator. This\n+/// means that:\n+///\n+/// * the starting address for that memory block was previously returned by [`alloc`], [`grow`], or\n+///   [`shrink`], and\n+///\n+/// * the memory block has not been subsequently deallocated, where blocks are either deallocated\n+///   directly by being passed to [`dealloc`] or were changed by being passed to [`grow`] or\n+///   [`shrink`] that returns `Ok`. If `grow` or `shrink` have returned `Err`, the passed pointer\n+///   remains valid.\n+///\n+/// [`alloc`]: AllocRef::alloc\n+/// [`grow`]: AllocRef::grow\n+/// [`shrink`]: AllocRef::shrink\n+/// [`dealloc`]: AllocRef::dealloc\n+///\n+/// ### Memory fitting\n+///\n+/// Some of the methods require that a layout *fit* a memory block. What it means for a layout to\n+/// \"fit\" a memory block means (or equivalently, for a memory block to \"fit\" a layout) is that the\n+/// following conditions must hold:\n+///\n+/// * The block must be allocated with the same alignment as [`layout.align()`], and\n+///\n+/// * The provided [`layout.size()`] must fall in the range `min ..= max`, where:\n+///   - `min` is the size of the layout most recently used to allocate the block, and\n+///   - `max` is the latest actual size returned from [`alloc`], [`grow`], or [`shrink`].\n+///\n+/// [`layout.align()`]: Layout::align\n+/// [`layout.size()`]: Layout::size\n+///\n+/// # Safety\n+///\n+/// * Memory blocks returned from an allocator must point to valid memory and retain their validity\n+///   until the instance and all of its clones are dropped,\n+///\n+/// * cloning or moving the allocator must not invalidate memory blocks returned from this\n+///   allocator. A cloned allocator must behave like the same allocator, and\n+///\n+/// * any pointer to a memory block which is [*currently allocated*] may be passed to any other\n+///   method of the allocator.\n+///\n+/// [*currently allocated*]: #currently-allocated-memory\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+pub unsafe trait AllocRef {\n+    /// Attempts to allocate a block of memory.\n+    ///\n+    /// On success, returns a [`MemoryBlock`][] meeting the size and alignment guarantees of `layout`.\n+    ///\n+    /// The returned block may have a larger size than specified by `layout.size()` and is\n+    /// initialized as specified by [`init`], all the way up to the returned size of the block.\n+    ///\n+    /// [`init`]: AllocInit\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or `layout` does not meet\n+    /// allocator's size or alignment constraints.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n+    /// aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n+    /// this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an allocation error are encouraged to\n+    /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr>;\n+\n+    /// Deallocates the memory referenced by `ptr`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator, and\n+    /// * `layout` must [*fit*] that block of memory.\n+    ///\n+    /// [*currently allocated*]: #currently-allocated-memory\n+    /// [*fit*]: #memory-fitting\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n+\n+    /// Attempts to extend the memory block.\n+    ///\n+    /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n+    /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n+    /// alignment and a size given by `new_size`. To accomplish this, the allocator may extend the\n+    /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n+    /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n+    ///\n+    /// If [`MayMove`] is used then ownership of the memory block referenced by `ptr`\n+    /// is transferred to this allocator. The memory may or may not be freed, and should be\n+    /// considered unusable (unless of course it is transferred back to the caller again via the\n+    /// return value of this method).\n+    ///\n+    /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n+    /// this allocator, and the contents of the memory block are unaltered.\n+    ///\n+    /// The memory block will contain the following contents after a successful call to `grow`:\n+    ///   * Bytes `0..layout.size()` are preserved from the original allocation.\n+    ///   * Bytes `layout.size()..old_size` will either be preserved or initialized according to\n+    ///     [`init`], depending on the allocator implementation. `old_size` refers to the size of\n+    ///     the `MemoryBlock` prior to the `grow` call, which may be larger than the size\n+    ///     that was originally requested when it was allocated.\n+    ///   * Bytes `old_size..new_size` are initialized according to [`init`]. `new_size` refers to\n+    ///     the size of the `MemoryBlock` returned by the `grow` call.\n+    ///\n+    /// [`InPlace`]: ReallocPlacement::InPlace\n+    /// [`MayMove`]: ReallocPlacement::MayMove\n+    /// [`placement`]: ReallocPlacement\n+    /// [`init`]: AllocInit\n+    ///\n+    /// # Safety\n+    ///\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.),\n+    // We can't require that `new_size` is strictly greater than `memory.size` because of ZSTs.\n+    // An alternative would be\n+    // * `new_size must be strictly greater than `memory.size` or both are zero\n+    /// * `new_size` must be greater than or equal to `layout.size()`, and\n+    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n+    ///   (i.e., the rounded value must be less than or equal to `usize::MAX`).\n+    ///\n+    /// [*currently allocated*]: #currently-allocated-memory\n+    /// [*fit*]: #memory-fitting\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err` if the new layout does not meet the allocator's size and alignment\n+    /// constraints of the allocator, or if growing otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n+    /// aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n+    /// this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an allocation error are encouraged to\n+    /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn grow(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+        placement: ReallocPlacement,\n+        init: AllocInit,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        match placement {\n+            ReallocPlacement::InPlace => Err(AllocErr),\n+            ReallocPlacement::MayMove => {\n+                let size = layout.size();\n+                debug_assert!(\n+                    new_size >= size,\n+                    \"`new_size` must be greater than or equal to `layout.size()`\"\n+                );\n+\n+                if new_size == size {\n+                    return Ok(MemoryBlock { ptr, size });\n+                }\n+\n+                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_memory = self.alloc(new_layout, init)?;\n+                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n+                self.dealloc(ptr, layout);\n+                Ok(new_memory)\n+            }\n+        }\n+    }\n+\n+    /// Attempts to shrink the memory block.\n+    ///\n+    /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n+    /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n+    /// alignment and a size given by `new_size`. To accomplish this, the allocator may shrink the\n+    /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n+    /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n+    ///\n+    /// If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n+    /// transferred to this allocator. The memory may or may not have been freed, and should be\n+    /// considered unusable unless it was transferred back to the caller again via the\n+    /// return value of this method.\n+    ///\n+    /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n+    /// this allocator, and the contents of the memory block are unaltered.\n+    ///\n+    /// The behavior of how the allocator tries to shrink the memory is specified by [`placement`].\n+    ///\n+    /// [`InPlace`]: ReallocPlacement::InPlace\n+    /// [`placement`]: ReallocPlacement\n+    ///\n+    /// # Safety\n+    ///\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.), and\n+    // We can't require that `new_size` is strictly smaller than `memory.size` because of ZSTs.\n+    // An alternative would be\n+    // * `new_size must be strictly smaller than `memory.size` or both are zero\n+    /// * `new_size` must be smaller than or equal to `layout.size()`.\n+    ///\n+    /// [*currently allocated*]: #currently-allocated-memory\n+    /// [*fit*]: #memory-fitting\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err` if the new layout does not meet the allocator's size and alignment\n+    /// constraints of the allocator, or if shrinking otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n+    /// aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n+    /// this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an allocation error are encouraged to\n+    /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn shrink(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+        placement: ReallocPlacement,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        match placement {\n+            ReallocPlacement::InPlace => Err(AllocErr),\n+            ReallocPlacement::MayMove => {\n+                let size = layout.size();\n+                debug_assert!(\n+                    new_size <= size,\n+                    \"`new_size` must be smaller than or equal to `layout.size()`\"\n+                );\n+\n+                if new_size == size {\n+                    return Ok(MemoryBlock { ptr, size });\n+                }\n+\n+                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_memory = self.alloc(new_layout, AllocInit::Uninitialized)?;\n+                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), new_size);\n+                self.dealloc(ptr, layout);\n+                Ok(new_memory)\n+            }\n+        }\n+    }\n+}"}, {"sha": "f6b8d4ba081467647534044fe3dbbfe4428f4d3d", "filename": "src/libcore/array/iter.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -39,7 +39,7 @@ where\n     alive: Range<usize>,\n }\n \n-impl<T, const N: usize> IntoIter<T, { N }>\n+impl<T, const N: usize> IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -99,7 +99,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> Iterator for IntoIter<T, { N }>\n+impl<T, const N: usize> Iterator for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -146,7 +146,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, { N }>\n+impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -182,7 +182,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> Drop for IntoIter<T, { N }>\n+impl<T, const N: usize> Drop for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -195,7 +195,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> ExactSizeIterator for IntoIter<T, { N }>\n+impl<T, const N: usize> ExactSizeIterator for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -210,17 +210,17 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> FusedIterator for IntoIter<T, { N }> where [T; N]: LengthAtMost32 {}\n+impl<T, const N: usize> FusedIterator for IntoIter<T, N> where [T; N]: LengthAtMost32 {}\n \n // The iterator indeed reports the correct length. The number of \"alive\"\n // elements (that will still be yielded) is the length of the range `alive`.\n // This range is decremented in length in either `next` or `next_back`. It is\n // always decremented by 1 in those methods, but only if `Some(_)` is returned.\n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, { N }> where [T; N]: LengthAtMost32 {}\n+unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, N> where [T; N]: LengthAtMost32 {}\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T: Clone, const N: usize> Clone for IntoIter<T, { N }>\n+impl<T: Clone, const N: usize> Clone for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -249,7 +249,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, { N }>\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {"}, {"sha": "6165941eb3dae0e68d8aefe1a90ddb682ccce41c", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -169,7 +169,8 @@ pub struct AssertParamIsCopy<T: Copy + ?Sized> {\n /// Implementations of `Clone` for primitive types.\n ///\n /// Implementations that cannot be described in Rust\n-/// are implemented in `SelectionContext::copy_clone_conditions()` in librustc.\n+/// are implemented in `traits::SelectionContext::copy_clone_conditions()`\n+/// in `rustc_trait_selection`.\n mod impls {\n \n     use super::Clone;"}, {"sha": "8c542136a7fa6523a804a2a97f82ae6d2ee9b00e", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -817,7 +817,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// When comparison is impossible:\n     ///\n     /// ```\n-    /// let result = std::f64::NAN.partial_cmp(&1.0);\n+    /// let result = f64::NAN.partial_cmp(&1.0);\n     /// assert_eq!(result, None);\n     /// ```\n     #[must_use]"}, {"sha": "eef9ee7cb0093d811e92c6d3f5b9034e6ffc83e8", "filename": "src/libcore/convert/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -41,6 +41,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;\n+use crate::hash::{Hash, Hasher};\n \n mod num;\n \n@@ -746,3 +747,10 @@ impl From<!> for Infallible {\n         x\n     }\n }\n+\n+#[stable(feature = \"convert_infallible_hash\", since = \"1.44.0\")]\n+impl Hash for Infallible {\n+    fn hash<H: Hasher>(&self, _: &mut H) {\n+        match *self {}\n+    }\n+}"}, {"sha": "66ae760fc1f791b6a57eea66c117416e122c1572", "filename": "src/libcore/convert/num.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -13,9 +13,9 @@ mod private {\n /// Typically doesn\u2019t need to be used directly.\n #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n pub trait FloatToInt<Int>: private::Sealed + Sized {\n-    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n     #[doc(hidden)]\n-    unsafe fn approx_unchecked(self) -> Int;\n+    unsafe fn to_int_unchecked(self) -> Int;\n }\n \n macro_rules! impl_float_to_int {\n@@ -27,8 +27,15 @@ macro_rules! impl_float_to_int {\n             impl FloatToInt<$Int> for $Float {\n                 #[doc(hidden)]\n                 #[inline]\n-                unsafe fn approx_unchecked(self) -> $Int {\n-                    crate::intrinsics::float_to_int_approx_unchecked(self)\n+                unsafe fn to_int_unchecked(self) -> $Int {\n+                    #[cfg(bootstrap)]\n+                    {\n+                        crate::intrinsics::float_to_int_approx_unchecked(self)\n+                    }\n+                    #[cfg(not(bootstrap))]\n+                    {\n+                        crate::intrinsics::float_to_int_unchecked(self)\n+                    }\n                 }\n             }\n         )+"}, {"sha": "95411b525d0db3934f1dd40d703be0c505455f83", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -852,7 +852,7 @@ pub trait LowerHex {\n ///     }\n /// }\n ///\n-/// let l = Length(i32::max_value());\n+/// let l = Length(i32::MAX);\n ///\n /// assert_eq!(format!(\"l as hex is: {:X}\", l), \"l as hex is: 7FFFFFFF\");\n ///"}, {"sha": "d406b3ce6ef6e88c0c1e54155e88b1eb57f7dded", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -43,7 +43,7 @@ use crate::intrinsics;\n ///\n /// assert_eq!(div_1(7, 0), 7);\n /// assert_eq!(div_1(9, 1), 4);\n-/// assert_eq!(div_1(11, std::u32::MAX), 0);\n+/// assert_eq!(div_1(11, u32::MAX), 0);\n /// ```\n #[inline]\n #[stable(feature = \"unreachable\", since = \"1.27.0\")]"}, {"sha": "4a11fb393899f26acccfe05b13f9d23f33c0394e", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1582,8 +1582,16 @@ extern \"rust-intrinsic\" {\n     /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n     /// (<https://github.com/rust-lang/rust/issues/10184>)\n     /// This is under stabilization at <https://github.com/rust-lang/rust/issues/67058>\n+    #[cfg(bootstrap)]\n     pub fn float_to_int_approx_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n \n+    /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n+    /// (<https://github.com/rust-lang/rust/issues/10184>)\n+    ///\n+    /// Stabilized as `f32::to_int_unchecked` and `f64::to_int_unchecked`.\n+    #[cfg(not(bootstrap))]\n+    pub fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+\n     /// Returns the number of bits set in an integer type `T`\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n@@ -1731,19 +1739,19 @@ extern \"rust-intrinsic\" {\n     pub fn mul_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs an exact division, resulting in undefined behavior where\n-    /// `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n+    /// `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`\n     pub fn exact_div<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked division, resulting in undefined behavior\n-    /// where y = 0 or x = `T::min_value()` and y = -1\n+    /// where y = 0 or x = `T::MIN` and y = -1\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_div` method. For example,\n     /// [`std::u32::checked_div`](../../std/primitive.u32.html#method.checked_div)\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n-    /// undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n+    /// undefined behavior where y = 0 or x = `T::MIN` and y = -1\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_rem` method. For example,\n@@ -1769,17 +1777,17 @@ extern \"rust-intrinsic\" {\n     pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked addition, resulting in\n-    /// undefined behavior when `x + y > T::max_value()` or `x + y < T::min_value()`.\n+    /// undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_add<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked subtraction, resulting in\n-    /// undefined behavior when `x - y > T::max_value()` or `x - y < T::min_value()`.\n+    /// undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_sub<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked multiplication, resulting in\n-    /// undefined behavior when `x * y > T::max_value()` or `x * y < T::min_value()`.\n+    /// undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_mul<T: Copy>(x: T, y: T) -> T;\n "}, {"sha": "c8829817e190cbdd00e516c68fcd6a53461bec94", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -198,7 +198,7 @@ pub trait Iterator {\n     /// // and the maximum possible lower bound\n     /// let iter = 0..;\n     ///\n-    /// assert_eq!((usize::max_value(), None), iter.size_hint());\n+    /// assert_eq!((usize::MAX, None), iter.size_hint());\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2920,7 +2920,7 @@ pub trait Iterator {\n     /// assert_eq!([1.].iter().partial_cmp([1., 2.].iter()), Some(Ordering::Less));\n     /// assert_eq!([1., 2.].iter().partial_cmp([1.].iter()), Some(Ordering::Greater));\n     ///\n-    /// assert_eq!([std::f64::NAN].iter().partial_cmp([1.].iter()), None);\n+    /// assert_eq!([f64::NAN].iter().partial_cmp([1.].iter()), None);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn partial_cmp<I>(self, other: I) -> Option<Ordering>\n@@ -3170,7 +3170,7 @@ pub trait Iterator {\n     /// assert!(![1, 3, 2, 4].iter().is_sorted());\n     /// assert!([0].iter().is_sorted());\n     /// assert!(std::iter::empty::<i32>().is_sorted());\n-    /// assert!(![0.0, 1.0, std::f32::NAN].iter().is_sorted());\n+    /// assert!(![0.0, 1.0, f32::NAN].iter().is_sorted());\n     /// ```\n     #[inline]\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n@@ -3197,7 +3197,7 @@ pub trait Iterator {\n     /// assert!(![1, 3, 2, 4].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n     /// assert!([0].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n     /// assert!(std::iter::empty::<i32>().is_sorted_by(|a, b| a.partial_cmp(b)));\n-    /// assert!(![0.0, 1.0, std::f32::NAN].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(![0.0, 1.0, f32::NAN].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n     /// ```\n     ///\n     /// [`is_sorted`]: trait.Iterator.html#method.is_sorted"}, {"sha": "9c885ef99a980010b97d0d37fd4ddad7b1c34a72", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1070,8 +1070,10 @@ pub(crate) mod builtin {\n \n     /// Includes a utf8-encoded file as a string.\n     ///\n-    /// The file is located relative to the current file. (similarly to how\n-    /// modules are found)\n+    /// The file is located relative to the current file (similarly to how\n+    /// modules are found). The provided path is interpreted in a platform-specific\n+    /// way at compile time. So, for instance, an invocation with a Windows path\n+    /// containing backslashes `\\` would not compile correctly on Unix.\n     ///\n     /// This macro will yield an expression of type `&'static str` which is the\n     /// contents of the file.\n@@ -1108,8 +1110,10 @@ pub(crate) mod builtin {\n \n     /// Includes a file as a reference to a byte array.\n     ///\n-    /// The file is located relative to the current file. (similarly to how\n-    /// modules are found)\n+    /// The file is located relative to the current file (similarly to how\n+    /// modules are found). The provided path is interpreted in a platform-specific\n+    /// way at compile time. So, for instance, an invocation with a Windows path\n+    /// containing backslashes `\\` would not compile correctly on Unix.\n     ///\n     /// This macro will yield an expression of type `&'static [u8; N]` which is\n     /// the contents of the file.\n@@ -1202,7 +1206,9 @@ pub(crate) mod builtin {\n     /// Parses a file as an expression or an item according to the context.\n     ///\n     /// The file is located relative to the current file (similarly to how\n-    /// modules are found).\n+    /// modules are found). The provided path is interpreted in a platform-specific\n+    /// way at compile time. So, for instance, an invocation with a Windows path\n+    /// containing backslashes `\\` would not compile correctly on Unix.\n     ///\n     /// Using this macro is often a bad idea, because if the file is\n     /// parsed as an expression, it is going to be placed in the"}, {"sha": "35bceaa25c36e8dc8fce428a30d37695aa994331", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -759,7 +759,8 @@ impl<T: ?Sized> Unpin for *mut T {}\n /// Implementations of `Copy` for primitive types.\n ///\n /// Implementations that cannot be described in Rust\n-/// are implemented in `SelectionContext::copy_clone_conditions()` in librustc.\n+/// are implemented in `traits::SelectionContext::copy_clone_conditions()`\n+/// in `rustc_trait_selection`.\n mod copy_impls {\n \n     use super::Copy;"}, {"sha": "4ab82add32b533825feca583522dcb6f0fd7c2b4", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -464,15 +464,13 @@ impl f32 {\n     /// assuming that the value is finite and fits in that type.\n     ///\n     /// ```\n-    /// #![feature(float_approx_unchecked_to)]\n-    ///\n     /// let value = 4.6_f32;\n-    /// let rounded = unsafe { value.approx_unchecked_to::<u16>() };\n+    /// let rounded = unsafe { value.to_int_unchecked::<u16>() };\n     /// assert_eq!(rounded, 4);\n     ///\n     /// let value = -128.9_f32;\n-    /// let rounded = unsafe { value.approx_unchecked_to::<i8>() };\n-    /// assert_eq!(rounded, std::i8::MIN);\n+    /// let rounded = unsafe { value.to_int_unchecked::<i8>() };\n+    /// assert_eq!(rounded, i8::MIN);\n     /// ```\n     ///\n     /// # Safety\n@@ -482,13 +480,13 @@ impl f32 {\n     /// * Not be `NaN`\n     /// * Not be infinite\n     /// * Be representable in the return type `Int`, after truncating off its fractional part\n-    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[stable(feature = \"float_approx_unchecked_to\", since = \"1.44.0\")]\n     #[inline]\n-    pub unsafe fn approx_unchecked_to<Int>(self) -> Int\n+    pub unsafe fn to_int_unchecked<Int>(self) -> Int\n     where\n         Self: FloatToInt<Int>,\n     {\n-        FloatToInt::<Int>::approx_unchecked(self)\n+        FloatToInt::<Int>::to_int_unchecked(self)\n     }\n \n     /// Raw transmutation to `u32`."}, {"sha": "20818a9b750f4c8d3c2678d4f82b96933256d6bb", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -478,15 +478,13 @@ impl f64 {\n     /// assuming that the value is finite and fits in that type.\n     ///\n     /// ```\n-    /// #![feature(float_approx_unchecked_to)]\n-    ///\n     /// let value = 4.6_f32;\n-    /// let rounded = unsafe { value.approx_unchecked_to::<u16>() };\n+    /// let rounded = unsafe { value.to_int_unchecked::<u16>() };\n     /// assert_eq!(rounded, 4);\n     ///\n     /// let value = -128.9_f32;\n-    /// let rounded = unsafe { value.approx_unchecked_to::<i8>() };\n-    /// assert_eq!(rounded, std::i8::MIN);\n+    /// let rounded = unsafe { value.to_int_unchecked::<i8>() };\n+    /// assert_eq!(rounded, i8::MIN);\n     /// ```\n     ///\n     /// # Safety\n@@ -496,13 +494,13 @@ impl f64 {\n     /// * Not be `NaN`\n     /// * Not be infinite\n     /// * Be representable in the return type `Int`, after truncating off its fractional part\n-    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[stable(feature = \"float_approx_unchecked_to\", since = \"1.44.0\")]\n     #[inline]\n-    pub unsafe fn approx_unchecked_to<Int>(self) -> Int\n+    pub unsafe fn to_int_unchecked<Int>(self) -> Int\n     where\n         Self: FloatToInt<Int>,\n     {\n-        FloatToInt::<Int>::approx_unchecked(self)\n+        FloatToInt::<Int>::to_int_unchecked(self)\n     }\n \n     /// Raw transmutation to `u64`."}, {"sha": "7ba4004d8609c0ad5d7d743845240e30e98db765", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -174,7 +174,7 @@ NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize }\n /// let zero = Wrapping(0u32);\n /// let one = Wrapping(1u32);\n ///\n-/// assert_eq!(std::u32::MAX, (zero - one).0);\n+/// assert_eq!(u32::MAX, (zero - one).0);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\n@@ -4376,7 +4376,7 @@ impl u8 {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> u8 {\n-        // Unset the fith bit if this is a lowercase letter\n+        // Unset the fifth bit if this is a lowercase letter\n         *self & !((self.is_ascii_lowercase() as u8) << 5)\n     }\n \n@@ -4399,7 +4399,7 @@ impl u8 {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> u8 {\n-        // Set the fith bit if this is an uppercase letter\n+        // Set the fifth bit if this is an uppercase letter\n         *self | ((self.is_ascii_uppercase() as u8) << 5)\n     }\n "}, {"sha": "946a765e18f3ba5bdf043ee0261ee32e21104cf2", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -139,10 +139,9 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// ```\n     /// #![feature(range_is_empty)]\n     ///\n-    /// use std::f32::NAN;\n     /// assert!(!(3.0..5.0).is_empty());\n-    /// assert!( (3.0..NAN).is_empty());\n-    /// assert!( (NAN..5.0).is_empty());\n+    /// assert!( (3.0..f32::NAN).is_empty());\n+    /// assert!( (f32::NAN..5.0).is_empty());\n     /// ```\n     #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n     pub fn is_empty(&self) -> bool {\n@@ -496,10 +495,9 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// ```\n     /// #![feature(range_is_empty)]\n     ///\n-    /// use std::f32::NAN;\n     /// assert!(!(3.0..=5.0).is_empty());\n-    /// assert!( (3.0..=NAN).is_empty());\n-    /// assert!( (NAN..=5.0).is_empty());\n+    /// assert!( (3.0..=f32::NAN).is_empty());\n+    /// assert!( (f32::NAN..=5.0).is_empty());\n     /// ```\n     ///\n     /// This method returns `true` after iteration has finished:"}, {"sha": "52e224d2a026f218b0f86d2c734b6c1f159468ce", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -659,8 +659,8 @@ impl<T: ?Sized> *const T {\n     /// `align`.\n     ///\n     /// If it is not possible to align the pointer, the implementation returns\n-    /// `usize::max_value()`. It is permissible for the implementation to *always*\n-    /// return `usize::max_value()`. Only your algorithm's performance can depend\n+    /// `usize::MAX`. It is permissible for the implementation to *always*\n+    /// return `usize::MAX`. Only your algorithm's performance can depend\n     /// on getting a usable offset here, not its correctness.\n     ///\n     /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be"}, {"sha": "9f85d781d698a5b7b88414b29eda74a1e10736ee", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -847,8 +847,8 @@ impl<T: ?Sized> *mut T {\n     /// `align`.\n     ///\n     /// If it is not possible to align the pointer, the implementation returns\n-    /// `usize::max_value()`. It is permissible for the implementation to *always*\n-    /// return `usize::max_value()`. Only your algorithm's performance can depend\n+    /// `usize::MAX`. It is permissible for the implementation to *always*\n+    /// return `usize::MAX`. Only your algorithm's performance can depend\n     /// on getting a usable offset here, not its correctness.\n     ///\n     /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be"}, {"sha": "cb0fb8795e581edbd5dd7c6acdae66e4758e65f1", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -6,7 +6,8 @@\n //! They can be used as targets of transmutes in unsafe code for manipulating\n //! the raw representations directly.\n //!\n-//! Their definition should always match the ABI defined in `rustc::back::abi`.\n+//! Their definition should always match the ABI defined in\n+//! `rustc_middle::ty::layout`.\n \n /// The representation of a trait object like `&SomeTrait`.\n ///"}, {"sha": "9be52e2dfb06b25cf4e3d41dfaab6e691b22873b", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2588,7 +2588,7 @@ impl<T> [T] {\n     /// assert!(![1, 3, 2, 4].is_sorted());\n     /// assert!([0].is_sorted());\n     /// assert!(empty.is_sorted());\n-    /// assert!(![0.0, 1.0, std::f32::NAN].is_sorted());\n+    /// assert!(![0.0, 1.0, f32::NAN].is_sorted());\n     /// ```\n     #[inline]\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]"}, {"sha": "dc7637cfdb934121c6f8cd80e948aeae8ce4097f", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -9,7 +9,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::pattern::Pattern;\n-use self::pattern::{DoubleEndedSearcher, ReverseSearcher, SearchStep, Searcher};\n+use self::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n \n use crate::char;\n use crate::fmt::{self, Write};\n@@ -2642,7 +2642,7 @@ impl str {\n     /// # Panics\n     ///\n     /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n-    /// beyond the last code point of the string slice.\n+    /// past the end of the last code point of the string slice.\n     ///\n     /// # Examples\n     ///\n@@ -2683,7 +2683,7 @@ impl str {\n     /// # Panics\n     ///\n     /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n-    /// beyond the last code point of the string slice.\n+    /// past the end of the last code point of the string slice.\n     ///\n     /// # Examples\n     ///\n@@ -3986,26 +3986,15 @@ impl str {\n     /// ```\n     /// #![feature(str_strip)]\n     ///\n-    /// assert_eq!(\"foobar\".strip_prefix(\"foo\"), Some(\"bar\"));\n-    /// assert_eq!(\"foobar\".strip_prefix(\"bar\"), None);\n+    /// assert_eq!(\"foo:bar\".strip_prefix(\"foo:\"), Some(\"bar\"));\n+    /// assert_eq!(\"foo:bar\".strip_prefix(\"bar\"), None);\n     /// assert_eq!(\"foofoo\".strip_prefix(\"foo\"), Some(\"foo\"));\n     /// ```\n     #[must_use = \"this returns the remaining substring as a new slice, \\\n                   without modifying the original\"]\n     #[unstable(feature = \"str_strip\", reason = \"newly added\", issue = \"67302\")]\n     pub fn strip_prefix<'a, P: Pattern<'a>>(&'a self, prefix: P) -> Option<&'a str> {\n-        let mut matcher = prefix.into_searcher(self);\n-        if let SearchStep::Match(start, len) = matcher.next() {\n-            debug_assert_eq!(\n-                start, 0,\n-                \"The first search step from Searcher \\\n-                 must include the first character\"\n-            );\n-            // SAFETY: `Searcher` is known to return valid indices.\n-            unsafe { Some(self.get_unchecked(len..)) }\n-        } else {\n-            None\n-        }\n+        prefix.strip_prefix_of(self)\n     }\n \n     /// Returns a string slice with the suffix removed.\n@@ -4020,8 +4009,8 @@ impl str {\n     ///\n     /// ```\n     /// #![feature(str_strip)]\n-    /// assert_eq!(\"barfoo\".strip_suffix(\"foo\"), Some(\"bar\"));\n-    /// assert_eq!(\"barfoo\".strip_suffix(\"bar\"), None);\n+    /// assert_eq!(\"bar:foo\".strip_suffix(\":foo\"), Some(\"bar\"));\n+    /// assert_eq!(\"bar:foo\".strip_suffix(\"bar\"), None);\n     /// assert_eq!(\"foofoo\".strip_suffix(\"foo\"), Some(\"foo\"));\n     /// ```\n     #[must_use = \"this returns the remaining substring as a new slice, \\\n@@ -4032,19 +4021,7 @@ impl str {\n         P: Pattern<'a>,\n         <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>,\n     {\n-        let mut matcher = suffix.into_searcher(self);\n-        if let SearchStep::Match(start, end) = matcher.next_back() {\n-            debug_assert_eq!(\n-                end,\n-                self.len(),\n-                \"The first search step from ReverseSearcher \\\n-                 must include the last character\"\n-            );\n-            // SAFETY: `Searcher` is known to return valid indices.\n-            unsafe { Some(self.get_unchecked(..start)) }\n-        } else {\n-            None\n-        }\n+        suffix.strip_suffix_of(self)\n     }\n \n     /// Returns a string slice with all suffixes that match a pattern"}, {"sha": "30fd55f7b7f646f35fcb31aba5d0e4f5035f7f80", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -47,6 +47,22 @@ pub trait Pattern<'a>: Sized {\n         matches!(self.into_searcher(haystack).next(), SearchStep::Match(0, _))\n     }\n \n+    /// Removes the pattern from the front of haystack, if it matches.\n+    #[inline]\n+    fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        if let SearchStep::Match(start, len) = self.into_searcher(haystack).next() {\n+            debug_assert_eq!(\n+                start, 0,\n+                \"The first search step from Searcher \\\n+                 must include the first character\"\n+            );\n+            // SAFETY: `Searcher` is known to return valid indices.\n+            unsafe { Some(haystack.get_unchecked(len..)) }\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Checks whether the pattern matches at the back of the haystack\n     #[inline]\n     fn is_suffix_of(self, haystack: &'a str) -> bool\n@@ -55,6 +71,26 @@ pub trait Pattern<'a>: Sized {\n     {\n         matches!(self.into_searcher(haystack).next_back(), SearchStep::Match(_, j) if haystack.len() == j)\n     }\n+\n+    /// Removes the pattern from the back of haystack, if it matches.\n+    #[inline]\n+    fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str>\n+    where\n+        Self::Searcher: ReverseSearcher<'a>,\n+    {\n+        if let SearchStep::Match(start, end) = self.into_searcher(haystack).next_back() {\n+            debug_assert_eq!(\n+                end,\n+                haystack.len(),\n+                \"The first search step from ReverseSearcher \\\n+                 must include the last character\"\n+            );\n+            // SAFETY: `Searcher` is known to return valid indices.\n+            unsafe { Some(haystack.get_unchecked(..start)) }\n+        } else {\n+            None\n+        }\n+    }\n }\n \n // Searcher\n@@ -448,13 +484,26 @@ impl<'a> Pattern<'a> for char {\n         self.encode_utf8(&mut [0u8; 4]).is_prefix_of(haystack)\n     }\n \n+    #[inline]\n+    fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        self.encode_utf8(&mut [0u8; 4]).strip_prefix_of(haystack)\n+    }\n+\n     #[inline]\n     fn is_suffix_of(self, haystack: &'a str) -> bool\n     where\n         Self::Searcher: ReverseSearcher<'a>,\n     {\n         self.encode_utf8(&mut [0u8; 4]).is_suffix_of(haystack)\n     }\n+\n+    #[inline]\n+    fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str>\n+    where\n+        Self::Searcher: ReverseSearcher<'a>,\n+    {\n+        self.encode_utf8(&mut [0u8; 4]).strip_suffix_of(haystack)\n+    }\n }\n \n /////////////////////////////////////////////////////////////////////////////\n@@ -569,13 +618,26 @@ macro_rules! pattern_methods {\n             ($pmap)(self).is_prefix_of(haystack)\n         }\n \n+        #[inline]\n+        fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n+            ($pmap)(self).strip_prefix_of(haystack)\n+        }\n+\n         #[inline]\n         fn is_suffix_of(self, haystack: &'a str) -> bool\n         where\n             $t: ReverseSearcher<'a>,\n         {\n             ($pmap)(self).is_suffix_of(haystack)\n         }\n+\n+        #[inline]\n+        fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str>\n+        where\n+            $t: ReverseSearcher<'a>,\n+        {\n+            ($pmap)(self).strip_suffix_of(haystack)\n+        }\n     };\n }\n \n@@ -715,11 +777,34 @@ impl<'a, 'b> Pattern<'a> for &'b str {\n         haystack.as_bytes().starts_with(self.as_bytes())\n     }\n \n+    /// Removes the pattern from the front of haystack, if it matches.\n+    #[inline]\n+    fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        if self.is_prefix_of(haystack) {\n+            // SAFETY: prefix was just verified to exist.\n+            unsafe { Some(haystack.get_unchecked(self.as_bytes().len()..)) }\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Checks whether the pattern matches at the back of the haystack\n     #[inline]\n     fn is_suffix_of(self, haystack: &'a str) -> bool {\n         haystack.as_bytes().ends_with(self.as_bytes())\n     }\n+\n+    /// Removes the pattern from the back of haystack, if it matches.\n+    #[inline]\n+    fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        if self.is_suffix_of(haystack) {\n+            let i = haystack.len() - self.as_bytes().len();\n+            // SAFETY: suffix was just verified to exist.\n+            unsafe { Some(haystack.get_unchecked(..i)) }\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "924a64847a794fa568ecba9f0e556c5faa361cbb", "filename": "src/libcore/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -389,7 +389,7 @@ impl Duration {\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)), Some(Duration::new(0, 1)));\n-    /// assert_eq!(Duration::new(1, 0).checked_add(Duration::new(std::u64::MAX, 0)), None);\n+    /// assert_eq!(Duration::new(1, 0).checked_add(Duration::new(u64::MAX, 0)), None);\n     /// ```\n     #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n     #[inline]\n@@ -460,7 +460,7 @@ impl Duration {\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(0, 500_000_001).checked_mul(2), Some(Duration::new(1, 2)));\n-    /// assert_eq!(Duration::new(std::u64::MAX - 1, 0).checked_mul(2), None);\n+    /// assert_eq!(Duration::new(u64::MAX - 1, 0).checked_mul(2), None);\n     /// ```\n     #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n     #[inline]"}, {"sha": "ae542cec170a3ee7146142a057373b4744fde8f1", "filename": "src/librustc/arena.rs", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/9f6b96e461003853bf36052cfaf79b12e1c35413/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f6b96e461003853bf36052cfaf79b12e1c35413/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=9f6b96e461003853bf36052cfaf79b12e1c35413", "patch": "@@ -1,132 +0,0 @@\n-/// This declares a list of types which can be allocated by `Arena`.\n-///\n-/// The `few` modifier will cause allocation to use the shared arena and recording the destructor.\n-/// This is faster and more memory efficient if there's only a few allocations of the type.\n-/// Leaving `few` out will cause the type to get its own dedicated `TypedArena` which is\n-/// faster and more memory efficient if there is lots of allocations.\n-///\n-/// Specifying the `decode` modifier will add decode impls for &T and &[T] where T is the type\n-/// listed. These impls will appear in the implement_ty_decoder! macro.\n-#[macro_export]\n-macro_rules! arena_types {\n-    ($macro:path, $args:tt, $tcx:lifetime) => (\n-        $macro!($args, [\n-            [] layouts: rustc::ty::layout::Layout,\n-            [] generics: rustc::ty::Generics,\n-            [] trait_def: rustc::ty::TraitDef,\n-            [] adt_def: rustc::ty::AdtDef,\n-            [] steal_mir: rustc::ty::steal::Steal<rustc::mir::BodyAndCache<$tcx>>,\n-            [] mir: rustc::mir::BodyAndCache<$tcx>,\n-            [] steal_promoted: rustc::ty::steal::Steal<\n-                rustc_index::vec::IndexVec<\n-                    rustc::mir::Promoted,\n-                    rustc::mir::BodyAndCache<$tcx>\n-                >\n-            >,\n-            [] promoted: rustc_index::vec::IndexVec<\n-                rustc::mir::Promoted,\n-                rustc::mir::BodyAndCache<$tcx>\n-            >,\n-            [decode] tables: rustc::ty::TypeckTables<$tcx>,\n-            [decode] borrowck_result: rustc::mir::BorrowCheckResult<$tcx>,\n-            [] const_allocs: rustc::mir::interpret::Allocation,\n-            [] vtable_method: Option<(\n-                rustc_hir::def_id::DefId,\n-                rustc::ty::subst::SubstsRef<$tcx>\n-            )>,\n-            [few, decode] mir_keys: rustc_hir::def_id::DefIdSet,\n-            [decode] specialization_graph: rustc::traits::specialization_graph::Graph,\n-            [] region_scope_tree: rustc::middle::region::ScopeTree,\n-            [] item_local_set: rustc_hir::ItemLocalSet,\n-            [decode] mir_const_qualif: rustc_index::bit_set::BitSet<rustc::mir::Local>,\n-            [] trait_impls_of: rustc::ty::trait_def::TraitImpls,\n-            [] associated_items: rustc::ty::AssociatedItems,\n-            [] dropck_outlives:\n-                rustc::infer::canonical::Canonical<'tcx,\n-                    rustc::infer::canonical::QueryResponse<'tcx,\n-                        rustc::traits::query::DropckOutlivesResult<'tcx>\n-                    >\n-                >,\n-            [] normalize_projection_ty:\n-                rustc::infer::canonical::Canonical<'tcx,\n-                    rustc::infer::canonical::QueryResponse<'tcx,\n-                        rustc::traits::query::NormalizationResult<'tcx>\n-                    >\n-                >,\n-            [] implied_outlives_bounds:\n-                rustc::infer::canonical::Canonical<'tcx,\n-                    rustc::infer::canonical::QueryResponse<'tcx,\n-                        Vec<rustc::traits::query::OutlivesBound<'tcx>>\n-                    >\n-                >,\n-            [] type_op_subtype:\n-                rustc::infer::canonical::Canonical<'tcx,\n-                    rustc::infer::canonical::QueryResponse<'tcx, ()>\n-                >,\n-            [] type_op_normalize_poly_fn_sig:\n-                rustc::infer::canonical::Canonical<'tcx,\n-                    rustc::infer::canonical::QueryResponse<'tcx, rustc::ty::PolyFnSig<'tcx>>\n-                >,\n-            [] type_op_normalize_fn_sig:\n-                rustc::infer::canonical::Canonical<'tcx,\n-                    rustc::infer::canonical::QueryResponse<'tcx, rustc::ty::FnSig<'tcx>>\n-                >,\n-            [] type_op_normalize_predicate:\n-                rustc::infer::canonical::Canonical<'tcx,\n-                    rustc::infer::canonical::QueryResponse<'tcx, rustc::ty::Predicate<'tcx>>\n-                >,\n-            [] type_op_normalize_ty:\n-                rustc::infer::canonical::Canonical<'tcx,\n-                    rustc::infer::canonical::QueryResponse<'tcx, rustc::ty::Ty<'tcx>>\n-                >,\n-            [few] crate_inherent_impls: rustc::ty::CrateInherentImpls,\n-            [few] upstream_monomorphizations:\n-                rustc_hir::def_id::DefIdMap<\n-                    rustc_data_structures::fx::FxHashMap<\n-                        rustc::ty::subst::SubstsRef<'tcx>,\n-                        rustc_hir::def_id::CrateNum\n-                    >\n-                >,\n-            [few] diagnostic_items: rustc_data_structures::fx::FxHashMap<\n-                rustc_span::symbol::Symbol,\n-                rustc_hir::def_id::DefId,\n-            >,\n-            [few] resolve_lifetimes: rustc::middle::resolve_lifetime::ResolveLifetimes,\n-            [few] lint_levels: rustc::lint::LintLevelMap,\n-            [few] stability_index: rustc::middle::stability::Index<'tcx>,\n-            [few] features: rustc_feature::Features,\n-            [few] all_traits: Vec<rustc_hir::def_id::DefId>,\n-            [few] privacy_access_levels: rustc::middle::privacy::AccessLevels,\n-            [few] target_features_whitelist: rustc_data_structures::fx::FxHashMap<\n-                String,\n-                Option<rustc_span::symbol::Symbol>\n-            >,\n-            [few] wasm_import_module_map: rustc_data_structures::fx::FxHashMap<\n-                rustc_hir::def_id::DefId,\n-                String\n-            >,\n-            [few] get_lib_features: rustc::middle::lib_features::LibFeatures,\n-            [few] defined_lib_features: rustc::middle::lang_items::LanguageItems,\n-            [few] visible_parent_map: rustc_hir::def_id::DefIdMap<rustc_hir::def_id::DefId>,\n-            [few] foreign_module: rustc::middle::cstore::ForeignModule,\n-            [few] foreign_modules: Vec<rustc::middle::cstore::ForeignModule>,\n-            [few] reachable_non_generics: rustc_hir::def_id::DefIdMap<\n-                rustc::middle::exported_symbols::SymbolExportLevel\n-            >,\n-            [few] crate_variances: rustc::ty::CrateVariancesMap<'tcx>,\n-            [few] inferred_outlives_crate: rustc::ty::CratePredicatesMap<'tcx>,\n-            [] upvars: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n-\n-            // Interned types\n-            [] tys: rustc::ty::TyS<$tcx>,\n-\n-            // HIR query types\n-            [few] indexed_hir: rustc::hir::map::IndexedHir<$tcx>,\n-            [few] hir_definitions: rustc_hir::definitions::Definitions,\n-            [] hir_owner: rustc::hir::Owner<$tcx>,\n-            [] hir_owner_nodes: rustc::hir::OwnerNodes<$tcx>,\n-        ], $tcx);\n-    )\n-}\n-\n-arena_types!(arena::declare_arena, [], 'tcx);"}, {"sha": "90d417a45fd93a30dca670d22a15fb563e88ec4a", "filename": "src/librustc_ast/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fentry.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -10,7 +10,7 @@ pub enum EntryPointType {\n     OtherMain, // Not an entry point, but some other function named main\n }\n \n-// Beware, this is duplicated in librustc/middle/entry.rs, make sure to keep\n+// Beware, this is duplicated in librustc_middle/middle/entry.rs, make sure to keep\n // them in sync.\n pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n     match item.kind {"}, {"sha": "3c634ff40ccb1a524182b1b4dbc046888e77a9f9", "filename": "src/librustc_ast/expand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast%2Fexpand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast%2Fexpand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fexpand%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,4 +1,4 @@\n-//! Definitions shared by macros / syntax extensions and e.g. librustc.\n+//! Definitions shared by macros / syntax extensions and e.g. librustc_middle.\n \n use crate::ast::Attribute;\n use rustc_span::symbol::sym;"}, {"sha": "1687f828f240f904ac780c4347cdba8bfb58a258", "filename": "src/librustc_ast/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -54,7 +54,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n /// Requirements for a `StableHashingContext` to be used in this crate.\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n-/// instead of implementing everything in librustc.\n+/// instead of implementing everything in librustc_middle.\n pub trait HashStableContext: rustc_span::HashStableContext {\n     fn hash_attr(&mut self, _: &ast::Attribute, hasher: &mut StableHasher);\n }"}, {"sha": "6005b607026fb4d006f32ecc26639c072d606157", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -972,8 +972,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         f: impl FnOnce(&mut Self) -> (&'hir [hir::Param<'hir>], hir::Expr<'hir>),\n     ) -> hir::BodyId {\n         let prev_gen_kind = self.generator_kind.take();\n+        let task_context = self.task_context.take();\n         let (parameters, result) = f(self);\n         let body_id = self.record_body(parameters, result);\n+        self.task_context = task_context;\n         self.generator_kind = prev_gen_kind;\n         body_id\n     }\n@@ -1332,17 +1334,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                         self.resolver.definitions().as_local_node_id(def_id)\n                                     {\n                                         for param in &generics.params {\n-                                            match param.kind {\n-                                                GenericParamKind::Type { .. } => {\n-                                                    if node_id == param.id {\n-                                                        add_bounds\n-                                                            .entry(param.id)\n-                                                            .or_default()\n-                                                            .push(bound.clone());\n-                                                        continue 'next_bound;\n-                                                    }\n+                                            if let GenericParamKind::Type { .. } = param.kind {\n+                                                if node_id == param.id {\n+                                                    add_bounds\n+                                                        .entry(param.id)\n+                                                        .or_default()\n+                                                        .push(bound.clone());\n+                                                    continue 'next_bound;\n                                                 }\n-                                                _ => {}\n                                             }\n                                         }\n                                     }"}, {"sha": "9028edc73a031fc91f079550c9058e5a1983ab6d", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -97,7 +97,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     /// HACK(Centril): there is a cyclic dependency between the parser and lowering\n     /// if we don't have this function pointer. To avoid that dependency so that\n-    /// librustc is independent of the parser, we use dynamic dispatch here.\n+    /// librustc_middle is independent of the parser, we use dynamic dispatch here.\n     nt_to_tokenstream: NtToTokenstream,\n \n     /// Used to allocate HIR nodes"}, {"sha": "76c790f80b86bd7503f34664bcefad167723b488", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -516,27 +516,25 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n-        match param.kind {\n-            GenericParamKind::Const { .. } => gate_feature_post!(\n+        if let GenericParamKind::Const { .. } = param.kind {\n+            gate_feature_post!(\n                 &self,\n                 const_generics,\n                 param.ident.span,\n                 \"const generics are unstable\"\n-            ),\n-            _ => {}\n+            )\n         }\n         visit::walk_generic_param(self, param)\n     }\n \n     fn visit_assoc_ty_constraint(&mut self, constraint: &'a AssocTyConstraint) {\n-        match constraint.kind {\n-            AssocTyConstraintKind::Bound { .. } => gate_feature_post!(\n+        if let AssocTyConstraintKind::Bound { .. } = constraint.kind {\n+            gate_feature_post!(\n                 &self,\n                 associated_type_bounds,\n                 constraint.span,\n                 \"associated type bounds are unstable\"\n-            ),\n-            _ => {}\n+            )\n         }\n         visit::walk_assoc_ty_constraint(self, constraint)\n     }"}, {"sha": "6541ac156b48705db81f700d716f9eb8bb5203eb", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -637,9 +637,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         match tt {\n             TokenTree::Token(ref token) => {\n                 self.word(token_to_string_ext(&token, convert_dollar_crate));\n-                match token.kind {\n-                    token::DocComment(..) => self.hardbreak(),\n-                    _ => {}\n+                if let token::DocComment(..) = token.kind {\n+                    self.hardbreak()\n                 }\n             }\n             TokenTree::Delimited(dspan, delim, tts) => {\n@@ -1390,13 +1389,10 @@ impl<'a> State<'a> {\n         self.print_visibility(&v.vis);\n         let generics = ast::Generics::default();\n         self.print_struct(&v.data, &generics, v.ident, v.span, false);\n-        match v.disr_expr {\n-            Some(ref d) => {\n-                self.s.space();\n-                self.word_space(\"=\");\n-                self.print_expr(&d.value)\n-            }\n-            _ => {}\n+        if let Some(ref d) = v.disr_expr {\n+            self.s.space();\n+            self.word_space(\"=\");\n+            self.print_expr(&d.value)\n         }\n     }\n \n@@ -2082,12 +2078,10 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::Yield(ref e) => {\n                 self.s.word(\"yield\");\n-                match *e {\n-                    Some(ref expr) => {\n-                        self.s.space();\n-                        self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                    }\n-                    _ => (),\n+\n+                if let Some(ref expr) = *e {\n+                    self.s.space();\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n             ast::ExprKind::Try(ref e) => {\n@@ -2139,9 +2133,8 @@ impl<'a> State<'a> {\n         self.s.word(\"::\");\n         let item_segment = path.segments.last().unwrap();\n         self.print_ident(item_segment.ident);\n-        match item_segment.args {\n-            Some(ref args) => self.print_generic_args(args, colons_before_params),\n-            None => {}\n+        if let Some(ref args) = item_segment.args {\n+            self.print_generic_args(args, colons_before_params)\n         }\n     }\n "}, {"sha": "ab5a844e58f7a18d9aa8496d77c1022cb2c0b3ed", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -870,7 +870,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                     let parse_alignment = |node: &ast::LitKind| -> Result<u32, &'static str> {\n                         if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n                             if literal.is_power_of_two() {\n-                                // rustc::ty::layout::Align restricts align to <= 2^29\n+                                // rustc_middle::ty::layout::Align restricts align to <= 2^29\n                                 if *literal <= 1 << 29 {\n                                     Ok(*literal as u32)\n                                 } else {"}, {"sha": "6b0c9f1018b6c3973154307b08d761848135b2b4", "filename": "src/librustc_builtin_macros/format_foreign.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_builtin_macros%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_builtin_macros%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat_foreign.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -27,11 +27,8 @@ pub mod printf {\n         }\n \n         pub fn set_position(&mut self, start: usize, end: usize) {\n-            match self {\n-                Substitution::Format(ref mut fmt) => {\n-                    fmt.position = InnerSpan::new(start, end);\n-                }\n-                _ => {}\n+            if let Substitution::Format(ref mut fmt) = self {\n+                fmt.position = InnerSpan::new(start, end);\n             }\n         }\n \n@@ -311,9 +308,8 @@ pub mod printf {\n \n         let at = {\n             let start = s.find('%')?;\n-            match s[start + 1..].chars().next()? {\n-                '%' => return Some((Substitution::Escape, &s[start + 2..])),\n-                _ => { /* fall-through */ }\n+            if let '%' = s[start + 1..].chars().next()? {\n+                return Some((Substitution::Escape, &s[start + 2..]));\n             }\n \n             Cur::new_at(&s[..], start)"}, {"sha": "64e66595d92d9feaacb5cbb5ee4739bc60e58239", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -16,7 +16,7 @@ flate2 = \"1.0\"\n libc = \"0.2\"\n measureme = \"0.7.1\"\n log = \"0.4\"\n-rustc = { path = \"../librustc\" }\n+rustc_middle = { path = \"../librustc_middle\" }\n rustc-demangle = \"0.1\"\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }"}, {"sha": "afec60d017ee626eba22f99e93047f8d25ac891d", "filename": "src/librustc_codegen_llvm/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FREADME.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -4,4 +4,4 @@ that runs towards the end of the compilation process.\n \n For more information about how codegen works, see the [rustc dev guide].\n \n-[rustc dev guide]: https://rustc-dev-guide.rust-lang.org/codegen.html\n+[rustc dev guide]: https://rustc-dev-guide.rust-lang.org/backend/codegen.html"}, {"sha": "8e9c5f25ccb7115d44791af943b113abcd4f7db0", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -5,22 +5,20 @@ use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n \n-use rustc::bug;\n-use rustc::ty::layout::{self};\n-use rustc::ty::Ty;\n use rustc_codegen_ssa::mir::operand::OperandValue;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::MemFlags;\n+use rustc_middle::bug;\n+pub use rustc_middle::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n+use rustc_middle::ty::Ty;\n use rustc_target::abi::call::ArgAbi;\n-use rustc_target::abi::{HasDataLayout, LayoutOf};\n-\n-use libc::c_uint;\n-\n-pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n pub use rustc_target::abi::call::*;\n+use rustc_target::abi::{self, HasDataLayout, Int, LayoutOf};\n pub use rustc_target::spec::abi::Abi;\n \n+use libc::c_uint;\n+\n macro_rules! for_each_kind {\n     ($flags: ident, $f: ident, $($kind: ident),+) => ({\n         $(if $flags.contains(ArgAttribute::$kind) { $f(llvm::Attribute::$kind) })+\n@@ -396,6 +394,11 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, llfn);\n         }\n \n+        // FIXME(eddyb, wesleywiser): apply this to callsites as well?\n+        if !self.can_unwind {\n+            llvm::Attribute::NoUnwind.apply_llfn(llvm::AttributePlace::Function, llfn);\n+        }\n+\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes, ty: Option<&Type>| {\n             attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn, ty);\n@@ -431,6 +434,8 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     }\n \n     fn apply_attrs_callsite(&self, bx: &mut Builder<'a, 'll, 'tcx>, callsite: &'ll Value) {\n+        // FIXME(wesleywiser, eddyb): We should apply `nounwind` and `noreturn` as appropriate to this callsite.\n+\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes, ty: Option<&Type>| {\n             attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite, ty);\n@@ -443,11 +448,11 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             PassMode::Indirect(ref attrs, _) => apply(attrs, Some(self.ret.layout.llvm_type(bx))),\n             _ => {}\n         }\n-        if let layout::Abi::Scalar(ref scalar) = self.ret.layout.abi {\n+        if let abi::Abi::Scalar(ref scalar) = self.ret.layout.abi {\n             // If the value is a boolean, the range is 0..2 and that ultimately\n             // become 0..0 when the type becomes i1, which would be rejected\n             // by the LLVM verifier.\n-            if let layout::Int(..) = scalar.value {\n+            if let Int(..) = scalar.value {\n                 if !scalar.is_bool() {\n                     let range = scalar.valid_range_exclusive(bx);\n                     if range.start != range.end {"}, {"sha": "a78546571e2919b5c412586ea328e54e4d540b42", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,8 +1,8 @@\n use crate::attributes;\n use libc::c_uint;\n-use rustc::bug;\n-use rustc::ty::TyCtxt;\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use rustc_middle::bug;\n+use rustc_middle::ty::TyCtxt;\n \n use crate::llvm::{self, False, True};\n use crate::ModuleLlvm;"}, {"sha": "784a3a87e98852980b52d304ee927e2f85a6b620", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 5, "deletions": 59, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2,21 +2,18 @@\n \n use std::ffi::CString;\n \n-use rustc::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc::ty::layout::HasTyCtxt;\n-use rustc::ty::query::Providers;\n-use rustc::ty::{self, Ty, TyCtxt};\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::const_cstr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::ty::layout::HasTyCtxt;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::config::{OptLevel, Sanitizer};\n use rustc_session::Session;\n-use rustc_target::abi::call::Conv;\n-use rustc_target::spec::PanicStrategy;\n \n-use crate::abi::FnAbi;\n use crate::attributes;\n use crate::llvm::AttributePlace::Function;\n use crate::llvm::{self, Attribute};\n@@ -77,12 +74,6 @@ pub fn emit_uwtable(val: &'ll Value, emit: bool) {\n     Attribute::UWTable.toggle_llfn(Function, val, emit);\n }\n \n-/// Tell LLVM whether the function can or cannot unwind.\n-#[inline]\n-fn unwind(val: &'ll Value, can_unwind: bool) {\n-    Attribute::NoUnwind.toggle_llfn(Function, val, !can_unwind);\n-}\n-\n /// Tell LLVM if this function should be 'naked', i.e., skip the epilogue and prologue.\n #[inline]\n fn naked(val: &'ll Value, is_naked: bool) {\n@@ -246,12 +237,7 @@ pub(crate) fn default_optimisation_attrs(sess: &Session, llfn: &'ll Value) {\n \n /// Composite function which sets LLVM attributes for function depending on its AST (`#[attribute]`)\n /// attributes.\n-pub fn from_fn_attrs(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    llfn: &'ll Value,\n-    instance: ty::Instance<'tcx>,\n-    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n-) {\n+pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::Instance<'tcx>) {\n     let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n \n     match codegen_fn_attrs.optimize {\n@@ -315,46 +301,6 @@ pub fn from_fn_attrs(\n     }\n     sanitize(cx, codegen_fn_attrs.flags, llfn);\n \n-    unwind(\n-        llfn,\n-        if cx.tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n-            // In panic=abort mode we assume nothing can unwind anywhere, so\n-            // optimize based on this!\n-            false\n-        } else if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::UNWIND) {\n-            // If a specific #[unwind] attribute is present, use that.\n-            true\n-        } else if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND) {\n-            // Special attribute for allocator functions, which can't unwind.\n-            false\n-        } else {\n-            if fn_abi.conv == Conv::Rust {\n-                // Any Rust method (or `extern \"Rust\" fn` or `extern\n-                // \"rust-call\" fn`) is explicitly allowed to unwind\n-                // (unless it has no-unwind attribute, handled above).\n-                true\n-            } else {\n-                // Anything else is either:\n-                //\n-                //  1. A foreign item using a non-Rust ABI (like `extern \"C\" { fn foo(); }`), or\n-                //\n-                //  2. A Rust item using a non-Rust ABI (like `extern \"C\" fn foo() { ... }`).\n-                //\n-                // Foreign items (case 1) are assumed to not unwind; it is\n-                // UB otherwise. (At least for now; see also\n-                // rust-lang/rust#63909 and Rust RFC 2753.)\n-                //\n-                // Items defined in Rust with non-Rust ABIs (case 2) are also\n-                // not supposed to unwind. Whether this should be enforced\n-                // (versus stating it is UB) and *how* it would be enforced\n-                // is currently under discussion; see rust-lang/rust#58794.\n-                //\n-                // In either case, we mark item as explicitly nounwind.\n-                false\n-            }\n-        },\n-    );\n-\n     // Always annotate functions with the target-cpu they are compiled for.\n     // Without this, ThinLTO won't inline Rust functions into Clang generated\n     // functions (because Clang annotates functions this way too)."}, {"sha": "816329e06c7a52f8bb639a292a70f72098cd359d", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -6,9 +6,6 @@ use crate::llvm::archive_ro::ArchiveRO;\n use crate::llvm::{self, False, True};\n use crate::{LlvmCodegenBackend, ModuleLlvm};\n use log::{debug, info};\n-use rustc::bug;\n-use rustc::dep_graph::WorkProduct;\n-use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n@@ -17,6 +14,9 @@ use rustc_codegen_ssa::{ModuleCodegen, ModuleKind, RLIB_BYTECODE_EXTENSION};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{FatalError, Handler};\n use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_middle::bug;\n+use rustc_middle::dep_graph::WorkProduct;\n+use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{self, Lto};\n "}, {"sha": "5708cb4e654184e2fbd45b69fc8a3008bc952d8c", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -14,15 +14,15 @@ use crate::type_::Type;\n use crate::LlvmCodegenBackend;\n use crate::ModuleLlvm;\n use log::debug;\n-use rustc::bug;\n-use rustc::ty::TyCtxt;\n use rustc_codegen_ssa::back::write::{BitcodeSection, CodegenContext, EmitObj, ModuleConfig};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen, RLIB_BYTECODE_EXTENSION};\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_errors::{FatalError, Handler};\n use rustc_fs_util::{link_or_copy, path_to_c_string};\n use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_middle::bug;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, Lto, OutputType, Passes, Sanitizer, SwitchWithOptPath};\n use rustc_session::Session;\n "}, {"sha": "e5f73473b72a6159aab9f926c9f1fa9e0bb73157", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -23,17 +23,17 @@ use crate::llvm;\n use crate::metadata;\n use crate::value::Value;\n \n-use rustc::dep_graph;\n-use rustc::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n-use rustc::middle::cstore::EncodedMetadata;\n-use rustc::middle::exported_symbols;\n-use rustc::mir::mono::{Linkage, Visibility};\n-use rustc::ty::TyCtxt;\n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n use rustc_codegen_ssa::mono_item::MonoItemExt;\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc_middle::dep_graph;\n+use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n+use rustc_middle::middle::cstore::EncodedMetadata;\n+use rustc_middle::middle::exported_symbols;\n+use rustc_middle::mir::mono::{Linkage, Visibility};\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::config::DebugInfo;\n use rustc_span::symbol::Symbol;\n "}, {"sha": "da9060f043f811aef7a5c3efea8cecb21ce49e85", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -7,8 +7,6 @@ use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n use libc::{c_char, c_uint};\n use log::debug;\n-use rustc::ty::layout::{self, Align, Size, TyLayout};\n-use rustc::ty::{self, Ty, TyCtxt};\n use rustc_codegen_ssa::base::to_immediate;\n use rustc_codegen_ssa::common::{IntPredicate, RealPredicate, TypeKind};\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n@@ -18,7 +16,10 @@ use rustc_codegen_ssa::MemFlags;\n use rustc_data_structures::const_cstr;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::config::{self, Sanitizer};\n+use rustc_target::abi::{self, Align, Size};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n use std::ffi::CStr;\n@@ -60,8 +61,8 @@ impl BackendTypes for Builder<'_, 'll, 'tcx> {\n     type DIVariable = <CodegenCx<'ll, 'tcx> as BackendTypes>::DIVariable;\n }\n \n-impl ty::layout::HasDataLayout for Builder<'_, '_, '_> {\n-    fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n+impl abi::HasDataLayout for Builder<'_, '_, '_> {\n+    fn data_layout(&self) -> &abi::TargetDataLayout {\n         self.cx.data_layout()\n     }\n }\n@@ -84,11 +85,11 @@ impl HasTargetSpec for Builder<'_, '_, 'tcx> {\n     }\n }\n \n-impl ty::layout::LayoutOf for Builder<'_, '_, 'tcx> {\n+impl abi::LayoutOf for Builder<'_, '_, 'tcx> {\n     type Ty = Ty<'tcx>;\n-    type TyLayout = TyLayout<'tcx>;\n+    type TyAndLayout = TyAndLayout<'tcx>;\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.cx.layout_of(ty)\n     }\n }\n@@ -302,9 +303,9 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         lhs: Self::Value,\n         rhs: Self::Value,\n     ) -> (Self::Value, Self::Value) {\n-        use rustc::ty::{Int, Uint};\n         use rustc_ast::ast::IntTy::*;\n         use rustc_ast::ast::UintTy::*;\n+        use rustc_middle::ty::{Int, Uint};\n \n         let new_kind = match ty.kind {\n             Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.ptr_width)),\n@@ -435,17 +436,17 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         fn scalar_load_metadata<'a, 'll, 'tcx>(\n             bx: &mut Builder<'a, 'll, 'tcx>,\n             load: &'ll Value,\n-            scalar: &layout::Scalar,\n+            scalar: &abi::Scalar,\n         ) {\n             let vr = scalar.valid_range.clone();\n             match scalar.value {\n-                layout::Int(..) => {\n+                abi::Int(..) => {\n                     let range = scalar.valid_range_exclusive(bx);\n                     if range.start != range.end {\n                         bx.range_metadata(load, range);\n                     }\n                 }\n-                layout::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n+                abi::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}\n@@ -465,16 +466,16 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n             let llval = const_llval.unwrap_or_else(|| {\n                 let load = self.load(place.llval, place.align);\n-                if let layout::Abi::Scalar(ref scalar) = place.layout.abi {\n+                if let abi::Abi::Scalar(ref scalar) = place.layout.abi {\n                     scalar_load_metadata(self, load, scalar);\n                 }\n                 load\n             });\n             OperandValue::Immediate(to_immediate(self, llval, place.layout))\n-        } else if let layout::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n+        } else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n             let b_offset = a.value.size(self).align_to(b.value.align(self).abi);\n \n-            let mut load = |i, scalar: &layout::Scalar, align| {\n+            let mut load = |i, scalar: &abi::Scalar, align| {\n                 let llptr = self.struct_gep(place.llval, i as u64);\n                 let load = self.load(llptr, align);\n                 scalar_load_metadata(self, load, scalar);"}, {"sha": "a36314448b170b82734ee9fb8ad58101598d2d43", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -12,8 +12,8 @@ use crate::value::Value;\n use log::debug;\n use rustc_codegen_ssa::traits::*;\n \n-use rustc::ty::layout::{FnAbiExt, HasTyCtxt};\n-use rustc::ty::{Instance, TypeFoldable};\n+use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n+use rustc_middle::ty::{Instance, TypeFoldable};\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n@@ -78,7 +78,7 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n         let llfn = cx.declare_fn(&sym, &fn_abi);\n         debug!(\"get_fn: not casting pointer!\");\n \n-        attributes::from_fn_attrs(cx, llfn, instance, &fn_abi);\n+        attributes::from_fn_attrs(cx, llfn, instance);\n \n         let instance_def_id = instance.def_id();\n "}, {"sha": "1415fedf11a275161d72330c9962634c08b51f48", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2,26 +2,24 @@\n \n //! Code that is useful in various codegen modules.\n \n-use crate::consts;\n+use crate::consts::{self, const_alloc_to_llvm};\n+pub use crate::context::CodegenCx;\n use crate::llvm::{self, BasicBlock, Bool, ConstantInt, False, OperandBundleDef, True};\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n-use log::debug;\n-use rustc::bug;\n-use rustc_codegen_ssa::traits::*;\n-\n-use crate::consts::const_alloc_to_llvm;\n-use rustc::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n-use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size, TyLayout};\n-use rustc_codegen_ssa::mir::place::PlaceRef;\n-\n-use libc::{c_char, c_uint};\n \n use rustc_ast::ast::Mutability;\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::traits::*;\n+use rustc_middle::bug;\n+use rustc_middle::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n+use rustc_middle::ty::layout::TyAndLayout;\n use rustc_span::symbol::Symbol;\n+use rustc_target::abi::{self, HasDataLayout, LayoutOf, Pointer, Size};\n \n-pub use crate::context::CodegenCx;\n+use libc::{c_char, c_uint};\n+use log::debug;\n \n /*\n * A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n@@ -229,12 +227,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         })\n     }\n \n-    fn scalar_to_backend(\n-        &self,\n-        cv: Scalar,\n-        layout: &layout::Scalar,\n-        llty: &'ll Type,\n-    ) -> &'ll Value {\n+    fn scalar_to_backend(&self, cv: Scalar, layout: &abi::Scalar, llty: &'ll Type) -> &'ll Value {\n         let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n         match cv {\n             Scalar::Raw { size: 0, .. } => {\n@@ -244,7 +237,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, layout.value.size(self).bytes());\n                 let llval = self.const_uint_big(self.type_ix(bitsize), data);\n-                if layout.value == layout::Pointer {\n+                if layout.value == Pointer {\n                     unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n                 } else {\n                     self.const_bitcast(llval, llty)\n@@ -278,7 +271,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         1,\n                     )\n                 };\n-                if layout.value != layout::Pointer {\n+                if layout.value != Pointer {\n                     unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n                 } else {\n                     self.const_bitcast(llval, llty)\n@@ -289,7 +282,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n     fn from_const_alloc(\n         &self,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n         alloc: &Allocation,\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {"}, {"sha": "9fd22c8b07bddf2b6961aa72e0ab0817efbd92d0", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -7,19 +7,20 @@ use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n use libc::c_uint;\n use log::debug;\n-use rustc::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n-use rustc::mir::interpret::{read_target_uint, Allocation, ConstValue, ErrorHandled, Pointer};\n-use rustc::mir::mono::MonoItem;\n-use rustc::ty::layout::{self, Align, LayoutOf, Size};\n-use rustc::ty::{self, Instance, Ty};\n-use rustc::{bug, span_bug};\n use rustc_codegen_ssa::traits::*;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n+use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n+use rustc_middle::mir::interpret::{\n+    read_target_uint, Allocation, ConstValue, ErrorHandled, Pointer,\n+};\n+use rustc_middle::mir::mono::MonoItem;\n+use rustc_middle::ty::{self, Instance, Ty};\n+use rustc_middle::{bug, span_bug};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n-use rustc_target::abi::HasDataLayout;\n+use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n \n use std::ffi::CStr;\n \n@@ -54,7 +55,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n             as u64;\n         llvals.push(cx.scalar_to_backend(\n             Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n-            &layout::Scalar { value: layout::Primitive::Pointer, valid_range: 0..=!0 },\n+            &Scalar { value: Primitive::Pointer, valid_range: 0..=!0 },\n             cx.type_i8p(),\n         ));\n         next_offset = offset + pointer_size;\n@@ -435,24 +436,21 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 //\n                 // We could remove this hack whenever we decide to drop macOS 10.10 support.\n                 if self.tcx.sess.target.target.options.is_like_osx {\n-                    assert_eq!(alloc.relocations().len(), 0);\n-\n-                    let is_zeroed = {\n-                        // Treats undefined bytes as if they were defined with the byte value that\n-                        // happens to be currently assigned in mir. This is valid since reading\n-                        // undef bytes may yield arbitrary values.\n-                        //\n-                        // FIXME: ignore undef bytes even with representation `!= 0`.\n-                        //\n-                        // The `inspect` method is okay here because we checked relocations, and\n-                        // because we are doing this access to inspect the final interpreter state\n-                        // (not as part of the interpreter execution).\n-                        alloc\n+                    // The `inspect` method is okay here because we checked relocations, and\n+                    // because we are doing this access to inspect the final interpreter state\n+                    // (not as part of the interpreter execution).\n+                    //\n+                    // FIXME: This check requires that the (arbitrary) value of undefined bytes\n+                    // happens to be zero. Instead, we should only check the value of defined bytes\n+                    // and set all undefined bytes to zero if this allocation is headed for the\n+                    // BSS.\n+                    let all_bytes_are_zero = alloc.relocations().is_empty()\n+                        && alloc\n                             .inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len())\n                             .iter()\n-                            .all(|b| *b == 0)\n-                    };\n-                    let sect_name = if is_zeroed {\n+                            .all(|&byte| byte == 0);\n+\n+                    let sect_name = if all_bytes_are_zero {\n                         CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_bss\\0\")\n                     } else {\n                         CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_data\\0\")"}, {"sha": "99a825823c3cdf582e753951ee216f6f10919b74", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -6,22 +6,21 @@ use crate::llvm_util;\n use crate::type_::Type;\n use crate::value::Value;\n \n-use rustc::bug;\n-use rustc::mir::mono::CodegenUnit;\n-use rustc::ty::layout::{\n-    HasParamEnv, LayoutError, LayoutOf, PointeeInfo, Size, TyLayout, VariantIdx,\n-};\n-use rustc::ty::{self, Instance, Ty, TyCtxt};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::base_n;\n use rustc_data_structures::const_cstr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc_middle::bug;\n+use rustc_middle::mir::mono::CodegenUnit;\n+use rustc_middle::ty::layout::{HasParamEnv, LayoutError, TyAndLayout};\n+use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_session::config::{self, CFGuard, DebugInfo};\n use rustc_session::Session;\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::Symbol;\n+use rustc_target::abi::{HasDataLayout, LayoutOf, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n use std::cell::{Cell, RefCell};\n@@ -817,8 +816,8 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n     }\n }\n \n-impl ty::layout::HasDataLayout for CodegenCx<'ll, 'tcx> {\n-    fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n+impl HasDataLayout for CodegenCx<'ll, 'tcx> {\n+    fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n@@ -837,13 +836,13 @@ impl ty::layout::HasTyCtxt<'tcx> for CodegenCx<'ll, 'tcx> {\n \n impl LayoutOf for CodegenCx<'ll, 'tcx> {\n     type Ty = Ty<'tcx>;\n-    type TyLayout = TyLayout<'tcx>;\n+    type TyAndLayout = TyAndLayout<'tcx>;\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.spanned_layout_of(ty, DUMMY_SP)\n     }\n \n-    fn spanned_layout_of(&self, ty: Ty<'tcx>, span: Span) -> Self::TyLayout {\n+    fn spanned_layout_of(&self, ty: Ty<'tcx>, span: Span) -> Self::TyAndLayout {\n         self.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty)).unwrap_or_else(|e| {\n             if let LayoutError::SizeOverflow(_) = e {\n                 self.sess().span_fatal(span, &e.to_string())"}, {"sha": "e2eae4ac427e5c7a6eb75bca6489e9eb56a4bca4", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -6,7 +6,7 @@ use rustc_codegen_ssa::traits::*;\n use crate::common::CodegenCx;\n use crate::llvm;\n use crate::llvm::debuginfo::{DIScope, DISubprogram};\n-use rustc::mir::{Body, SourceScope};\n+use rustc_middle::mir::{Body, SourceScope};\n use rustc_session::config::DebugInfo;\n \n use rustc_index::bit_set::BitSet;"}, {"sha": "64d4076cbf0dbd37738d1510b230b4db56990f92", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -5,8 +5,8 @@ use crate::llvm;\n use crate::builder::Builder;\n use crate::common::CodegenCx;\n use crate::value::Value;\n-use rustc::bug;\n use rustc_codegen_ssa::traits::*;\n+use rustc_middle::bug;\n use rustc_session::config::DebugInfo;\n \n use rustc_ast::attr;"}, {"sha": "a9e21c056a3eba4fbcac2c5a8fdefd043248cee9", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 45, "deletions": 57, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -20,17 +20,6 @@ use crate::llvm_util;\n use crate::value::Value;\n \n use log::debug;\n-use rustc::ich::NodeIdHashingMode;\n-use rustc::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc::mir::interpret::truncate;\n-use rustc::mir::{self, Field, GeneratorLayout};\n-use rustc::ty::layout::{\n-    self, Align, Integer, IntegerExt, LayoutOf, PrimitiveExt, Size, TyLayout, VariantIdx,\n-};\n-use rustc::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc::ty::Instance;\n-use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n-use rustc::{bug, span_bug};\n use rustc_ast::ast;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::const_cstr;\n@@ -41,10 +30,21 @@ use rustc_fs_util::path_to_c_string;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::ich::NodeIdHashingMode;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::mir::interpret::truncate;\n+use rustc_middle::mir::{self, Field, GeneratorLayout};\n+use rustc_middle::ty::layout::{self, IntegerExt, PrimitiveExt, TyAndLayout};\n+use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n+use rustc_middle::ty::Instance;\n+use rustc_middle::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n+use rustc_middle::{bug, span_bug};\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::{Interner, Symbol};\n use rustc_span::{self, FileName, Span};\n-use rustc_target::abi::HasDataLayout;\n+use rustc_target::abi::{Abi, Align, DiscriminantKind, HasDataLayout, Integer, LayoutOf};\n+use rustc_target::abi::{Int, Pointer, F32, F64};\n+use rustc_target::abi::{Primitive, Size, VariantIdx, Variants};\n \n use libc::{c_longlong, c_uint};\n use std::collections::hash_map::Entry;\n@@ -1203,7 +1203,7 @@ fn prepare_tuple_metadata(\n //=-----------------------------------------------------------------------------\n \n struct UnionMemberDescriptionFactory<'tcx> {\n-    layout: TyLayout<'tcx>,\n+    layout: TyAndLayout<'tcx>,\n     variant: &'tcx ty::VariantDef,\n     span: Span,\n }\n@@ -1325,7 +1325,7 @@ fn generator_layout_and_saved_local_names(\n /// offset of zero bytes).\n struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     enum_type: Ty<'tcx>,\n-    layout: TyLayout<'tcx>,\n+    layout: TyAndLayout<'tcx>,\n     discriminant_type_metadata: Option<&'ll DIType>,\n     containing_scope: &'ll DIScope,\n     span: Span,\n@@ -1364,7 +1364,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n         };\n \n         match self.layout.variants {\n-            layout::Variants::Single { index } => {\n+            Variants::Single { index } => {\n                 if let ty::Adt(adt, _) = &self.enum_type.kind {\n                     if adt.variants.is_empty() {\n                         return vec![];\n@@ -1399,8 +1399,8 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     discriminant: None,\n                 }]\n             }\n-            layout::Variants::Multiple {\n-                discr_kind: layout::DiscriminantKind::Tag,\n+            Variants::Multiple {\n+                discr_kind: DiscriminantKind::Tag,\n                 discr_index,\n                 ref variants,\n                 ..\n@@ -1457,9 +1457,9 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     })\n                     .collect()\n             }\n-            layout::Variants::Multiple {\n+            Variants::Multiple {\n                 discr_kind:\n-                    layout::DiscriminantKind::Niche { ref niche_variants, niche_start, dataful_variant },\n+                    DiscriminantKind::Niche { ref niche_variants, niche_start, dataful_variant },\n                 ref discr,\n                 ref variants,\n                 discr_index,\n@@ -1494,7 +1494,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     fn compute_field_path<'a, 'tcx>(\n                         cx: &CodegenCx<'a, 'tcx>,\n                         name: &mut String,\n-                        layout: TyLayout<'tcx>,\n+                        layout: TyAndLayout<'tcx>,\n                         offset: Size,\n                         size: Size,\n                     ) {\n@@ -1592,7 +1592,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n // Creates `MemberDescription`s for the fields of a single enum variant.\n struct VariantMemberDescriptionFactory<'ll, 'tcx> {\n     /// Cloned from the `layout::Struct` describing the variant.\n-    offsets: Vec<layout::Size>,\n+    offsets: Vec<Size>,\n     args: Vec<(String, Ty<'tcx>)>,\n     discriminant_type_metadata: Option<&'ll DIType>,\n     span: Span,\n@@ -1695,7 +1695,7 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n /// `RecursiveTypeDescription`.\n fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n-    layout: layout::TyLayout<'tcx>,\n+    layout: layout::TyAndLayout<'tcx>,\n     variant: VariantInfo<'_, 'tcx>,\n     discriminant_info: EnumDiscriminantInfo<'ll>,\n     containing_scope: &'ll DIScope,\n@@ -1777,7 +1777,7 @@ fn prepare_enum_metadata(\n     // <unknown>\n     let file_metadata = unknown_file_metadata(cx);\n \n-    let discriminant_type_metadata = |discr: layout::Primitive| {\n+    let discriminant_type_metadata = |discr: Primitive| {\n         let enumerators_metadata: Vec<_> = match enum_type.kind {\n             ty::Adt(def, _) => def\n                 .discriminants(cx.tcx)\n@@ -1869,30 +1869,21 @@ fn prepare_enum_metadata(\n \n     let layout = cx.layout_of(enum_type);\n \n-    match (&layout.abi, &layout.variants) {\n-        (\n-            &layout::Abi::Scalar(_),\n-            &layout::Variants::Multiple {\n-                discr_kind: layout::DiscriminantKind::Tag,\n-                ref discr,\n-                ..\n-            },\n-        ) => return FinalMetadata(discriminant_type_metadata(discr.value)),\n-        _ => {}\n+    if let (\n+        &Abi::Scalar(_),\n+        &Variants::Multiple { discr_kind: DiscriminantKind::Tag, ref discr, .. },\n+    ) = (&layout.abi, &layout.variants)\n+    {\n+        return FinalMetadata(discriminant_type_metadata(discr.value));\n     }\n \n     if use_enum_fallback(cx) {\n         let discriminant_type_metadata = match layout.variants {\n-            layout::Variants::Single { .. }\n-            | layout::Variants::Multiple {\n-                discr_kind: layout::DiscriminantKind::Niche { .. },\n-                ..\n-            } => None,\n-            layout::Variants::Multiple {\n-                discr_kind: layout::DiscriminantKind::Tag,\n-                ref discr,\n-                ..\n-            } => Some(discriminant_type_metadata(discr.value)),\n+            Variants::Single { .. }\n+            | Variants::Multiple { discr_kind: DiscriminantKind::Niche { .. }, .. } => None,\n+            Variants::Multiple { discr_kind: DiscriminantKind::Tag, ref discr, .. } => {\n+                Some(discriminant_type_metadata(discr.value))\n+            }\n         };\n \n         let enum_metadata = {\n@@ -1940,10 +1931,10 @@ fn prepare_enum_metadata(\n     };\n     let discriminator_metadata = match layout.variants {\n         // A single-variant enum has no discriminant.\n-        layout::Variants::Single { .. } => None,\n+        Variants::Single { .. } => None,\n \n-        layout::Variants::Multiple {\n-            discr_kind: layout::DiscriminantKind::Niche { .. },\n+        Variants::Multiple {\n+            discr_kind: DiscriminantKind::Niche { .. },\n             ref discr,\n             discr_index,\n             ..\n@@ -1953,10 +1944,10 @@ fn prepare_enum_metadata(\n             let align = discr.value.align(cx);\n \n             let discr_type = match discr.value {\n-                layout::Int(t, _) => t,\n-                layout::F32 => Integer::I32,\n-                layout::F64 => Integer::I64,\n-                layout::Pointer => cx.data_layout().ptr_sized_integer(),\n+                Int(t, _) => t,\n+                F32 => Integer::I32,\n+                F64 => Integer::I64,\n+                Pointer => cx.data_layout().ptr_sized_integer(),\n             }\n             .to_ty(cx.tcx, false);\n \n@@ -1978,11 +1969,8 @@ fn prepare_enum_metadata(\n             }\n         }\n \n-        layout::Variants::Multiple {\n-            discr_kind: layout::DiscriminantKind::Tag,\n-            ref discr,\n-            discr_index,\n-            ..\n+        Variants::Multiple {\n+            discr_kind: DiscriminantKind::Tag, ref discr, discr_index, ..\n         } => {\n             let discr_type = discr.value.to_ty(cx.tcx);\n             let (size, align) = cx.size_and_align_of(discr_type);\n@@ -2007,8 +1995,8 @@ fn prepare_enum_metadata(\n     };\n \n     let mut outer_fields = match layout.variants {\n-        layout::Variants::Single { .. } => vec![],\n-        layout::Variants::Multiple { .. } => {\n+        Variants::Single { .. } => vec![],\n+        Variants::Multiple { .. } => {\n             let tuple_mdf = TupleMemberDescriptionFactory {\n                 ty: enum_type,\n                 component_types: outer_field_tys,"}, {"sha": "f04ac586504111817ddf6b774e76b35999c24d1b", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -8,35 +8,35 @@ use self::namespace::mangled_name_of_instance;\n use self::type_names::compute_debuginfo_type_name;\n use self::utils::{create_DIArray, is_node_local_to_unit, DIB};\n \n+use crate::abi::FnAbi;\n+use crate::builder::Builder;\n+use crate::common::CodegenCx;\n use crate::llvm;\n use crate::llvm::debuginfo::{\n     DIArray, DIBuilder, DIFile, DIFlags, DILexicalBlock, DISPFlags, DIScope, DIType, DIVariable,\n };\n-use rustc::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LOCAL_CRATE};\n-\n-use crate::abi::FnAbi;\n-use crate::builder::Builder;\n-use crate::common::CodegenCx;\n use crate::value::Value;\n-use rustc::mir;\n-use rustc::ty::{self, Instance, ParamEnv, Ty};\n+\n+use rustc_ast::ast;\n use rustc_codegen_ssa::debuginfo::type_names;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext, VariableKind};\n+use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LOCAL_CRATE};\n use rustc_index::vec::IndexVec;\n+use rustc_middle::mir;\n+use rustc_middle::ty::layout::HasTyCtxt;\n+use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n+use rustc_middle::ty::{self, Instance, ParamEnv, Ty};\n use rustc_session::config::{self, DebugInfo};\n+use rustc_span::symbol::Symbol;\n+use rustc_span::{self, BytePos, Span};\n+use rustc_target::abi::{LayoutOf, Primitive, Size};\n \n use libc::c_uint;\n use log::debug;\n-use std::cell::RefCell;\n-\n-use rustc::ty::layout::{self, HasTyCtxt, LayoutOf, Size};\n-use rustc_ast::ast;\n-use rustc_codegen_ssa::traits::*;\n-use rustc_span::symbol::Symbol;\n-use rustc_span::{self, BytePos, Span};\n use smallvec::SmallVec;\n+use std::cell::RefCell;\n \n mod create_scope_map;\n pub mod gdb;\n@@ -60,7 +60,7 @@ pub struct CrateDebugContext<'a, 'tcx> {\n     llmod: &'a llvm::Module,\n     builder: &'a mut DIBuilder<'a>,\n     created_files: RefCell<FxHashMap<(Option<String>, Option<String>), &'a DIFile>>,\n-    created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Primitive), &'a DIType>>,\n+    created_enum_disr_types: RefCell<FxHashMap<(DefId, Primitive), &'a DIType>>,\n \n     type_map: RefCell<TypeMap<'a, 'tcx>>,\n     namespace_map: RefCell<DefIdMap<&'a DIScope>>,"}, {"sha": "475dea239a765ee07be1e1f0c75684edacbf7689", "filename": "src/librustc_codegen_llvm/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,7 +1,7 @@\n // Namespace Handling.\n \n use super::utils::{debug_context, DIB};\n-use rustc::ty::{self, Instance};\n+use rustc_middle::ty::{self, Instance};\n \n use crate::common::CodegenCx;\n use crate::llvm;"}, {"sha": "ee188e69be11fd7f30f8838de9cbd99eae622fb3", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -3,8 +3,8 @@\n use super::namespace::item_namespace;\n use super::CrateDebugContext;\n \n-use rustc::ty::DefIdTree;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::DefIdTree;\n \n use crate::common::CodegenCx;\n use crate::llvm;"}, {"sha": "26ab46bde3843e1c361985de7807f8fee1f62ec0", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -19,8 +19,8 @@ use crate::llvm::AttributePlace::Function;\n use crate::type_::Type;\n use crate::value::Value;\n use log::debug;\n-use rustc::ty::Ty;\n use rustc_codegen_ssa::traits::*;\n+use rustc_middle::ty::Ty;\n \n /// Declare a function.\n ///"}, {"sha": "5734eae7d5946b480963969ecafa7d5faf6bdb63", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -7,23 +7,22 @@ use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n-use rustc::ty::layout::{self, FnAbiExt, HasTyCtxt, LayoutOf, Primitive};\n-use rustc::ty::{self, Ty};\n-use rustc::{bug, span_bug};\n+\n use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n+use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::MemFlags;\n use rustc_hir as hir;\n-use rustc_target::abi::HasDataLayout;\n-\n-use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n-use rustc_codegen_ssa::traits::*;\n-\n+use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_middle::{bug, span_bug};\n use rustc_span::Span;\n+use rustc_target::abi::{self, HasDataLayout, LayoutOf, Primitive};\n \n use std::cmp::Ordering;\n use std::{i128, iter, u128};\n@@ -145,7 +144,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n             \"va_arg\" => {\n                 match fn_abi.ret.layout.abi {\n-                    layout::Abi::Scalar(ref scalar) => {\n+                    abi::Abi::Scalar(ref scalar) => {\n                         match scalar.value {\n                             Primitive::Int(..) => {\n                                 if self.cx().size_of(ret_ty).bytes() < 4 {\n@@ -544,13 +543,13 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n             }\n \n-            \"float_to_int_approx_unchecked\" => {\n+            \"float_to_int_unchecked\" => {\n                 if float_type_width(arg_tys[0]).is_none() {\n                     span_invalid_monomorphization_error(\n                         tcx.sess,\n                         span,\n                         &format!(\n-                            \"invalid monomorphization of `float_to_int_approx_unchecked` \\\n+                            \"invalid monomorphization of `float_to_int_unchecked` \\\n                                   intrinsic: expected basic float type, \\\n                                   found `{}`\",\n                             arg_tys[0]\n@@ -571,7 +570,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                             tcx.sess,\n                             span,\n                             &format!(\n-                                \"invalid monomorphization of `float_to_int_approx_unchecked` \\\n+                                \"invalid monomorphization of `float_to_int_unchecked` \\\n                                       intrinsic:  expected basic integer type, \\\n                                       found `{}`\",\n                                 ret_ty\n@@ -1390,8 +1389,8 @@ fn generic_simd_intrinsic(\n \n     fn simd_simple_float_intrinsic(\n         name: &str,\n-        in_elem: &::rustc::ty::TyS<'_>,\n-        in_ty: &::rustc::ty::TyS<'_>,\n+        in_elem: &::rustc_middle::ty::TyS<'_>,\n+        in_ty: &::rustc_middle::ty::TyS<'_>,\n         in_len: u64,\n         bx: &mut Builder<'a, 'll, 'tcx>,\n         span: Span,"}, {"sha": "939f9e9c2a0c778a191bd194da48e7dabf247b0f", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -17,17 +17,16 @@\n use back::write::{create_informational_target_machine, create_target_machine};\n \n pub use llvm_util::target_features;\n-use rustc::dep_graph::{DepGraph, WorkProduct};\n-use rustc::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n-use rustc::ty::{self, TyCtxt};\n-use rustc::util::common::ErrorReported;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::ModuleCodegen;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule};\n-use rustc_errors::{FatalError, Handler};\n+use rustc_errors::{ErrorReported, FatalError, Handler};\n+use rustc_middle::dep_graph::{DepGraph, WorkProduct};\n+use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_serialize::json;\n use rustc_session::config::{self, OptLevel, OutputFilenames, PrintRequest};\n use rustc_session::Session;"}, {"sha": "a56c8802f3c00d6525337f0bd09e61bc25819d85", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,9 +1,9 @@\n use crate::back::write::create_informational_target_machine;\n use crate::llvm;\n use libc::c_int;\n-use rustc::bug;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_feature::UnstableFeatures;\n+use rustc_middle::bug;\n use rustc_session::config::PrintRequest;\n use rustc_session::Session;\n use rustc_span::symbol::sym;"}, {"sha": "6d0612ca075d1f9437df938af02d4eb4b72cf113", "filename": "src/librustc_codegen_llvm/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmetadata.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,7 +1,7 @@\n use crate::llvm;\n use crate::llvm::archive_ro::ArchiveRO;\n use crate::llvm::{mk_section_iter, False, ObjectFile};\n-use rustc::middle::cstore::MetadataLoader;\n+use rustc_middle::middle::cstore::MetadataLoader;\n use rustc_target::spec::Target;\n \n use log::debug;"}, {"sha": "29389b44adc27e1d830d82430efc9a55e4ddaf6b", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -5,13 +5,13 @@ use crate::context::CodegenCx;\n use crate::llvm;\n use crate::type_of::LayoutLlvmExt;\n use log::debug;\n-use rustc::mir::mono::{Linkage, Visibility};\n-use rustc::ty::layout::{FnAbiExt, LayoutOf};\n-use rustc::ty::{Instance, TypeFoldable};\n use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-\n-pub use rustc::mir::mono::MonoItem;\n+pub use rustc_middle::mir::mono::MonoItem;\n+use rustc_middle::mir::mono::{Linkage, Visibility};\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_middle::ty::{Instance, TypeFoldable};\n+use rustc_target::abi::LayoutOf;\n \n impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn predefine_static(\n@@ -77,7 +77,7 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         debug!(\"predefine_fn: instance = {:?}\", instance);\n \n-        attributes::from_fn_attrs(self, lldecl, instance, &fn_abi);\n+        attributes::from_fn_attrs(self, lldecl, instance);\n \n         self.instances.borrow_mut().insert(instance, lldecl);\n     }"}, {"sha": "854eff31733805e349062e7876efd4889b756cc9", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,21 +1,21 @@\n pub use crate::llvm::Type;\n \n+use crate::abi::{FnAbiLlvmExt, LlvmType};\n+use crate::common;\n use crate::context::CodegenCx;\n use crate::llvm;\n use crate::llvm::{Bool, False, True};\n-use crate::value::Value;\n-use rustc::bug;\n-use rustc_codegen_ssa::traits::*;\n-\n-use crate::abi::{FnAbiLlvmExt, LlvmType};\n-use crate::common;\n use crate::type_of::LayoutLlvmExt;\n-use rustc::ty::layout::{self, Align, Size, TyLayout};\n-use rustc::ty::Ty;\n+use crate::value::Value;\n use rustc_ast::ast;\n use rustc_codegen_ssa::common::TypeKind;\n+use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc_middle::bug;\n+use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::ty::Ty;\n use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n+use rustc_target::abi::{Align, Integer, Size};\n \n use std::fmt;\n use std::ptr;\n@@ -115,14 +115,14 @@ impl CodegenCx<'ll, 'tcx> {\n \n     crate fn type_pointee_for_align(&self, align: Align) -> &'ll Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n-        let ity = layout::Integer::approximate_align(self, align);\n+        let ity = Integer::approximate_align(self, align);\n         self.type_from_integer(ity)\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n     crate fn type_padding_filler(&self, size: Size, align: Align) -> &'ll Type {\n-        let unit = layout::Integer::approximate_align(self, align);\n+        let unit = Integer::approximate_align(self, align);\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);\n@@ -250,24 +250,24 @@ impl Type {\n }\n \n impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn backend_type(&self, layout: TyLayout<'tcx>) -> &'ll Type {\n+    fn backend_type(&self, layout: TyAndLayout<'tcx>) -> &'ll Type {\n         layout.llvm_type(self)\n     }\n-    fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> &'ll Type {\n+    fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> &'ll Type {\n         layout.immediate_llvm_type(self)\n     }\n-    fn is_backend_immediate(&self, layout: TyLayout<'tcx>) -> bool {\n+    fn is_backend_immediate(&self, layout: TyAndLayout<'tcx>) -> bool {\n         layout.is_llvm_immediate()\n     }\n-    fn is_backend_scalar_pair(&self, layout: TyLayout<'tcx>) -> bool {\n+    fn is_backend_scalar_pair(&self, layout: TyAndLayout<'tcx>) -> bool {\n         layout.is_llvm_scalar_pair()\n     }\n-    fn backend_field_index(&self, layout: TyLayout<'tcx>, index: usize) -> u64 {\n+    fn backend_field_index(&self, layout: TyAndLayout<'tcx>, index: usize) -> u64 {\n         layout.llvm_field_index(index)\n     }\n     fn scalar_pair_element_backend_type(\n         &self,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n         index: usize,\n         immediate: bool,\n     ) -> &'ll Type {"}, {"sha": "f475ea741c893253eea7561579e4dd3363762b9d", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 43, "deletions": 48, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2,23 +2,25 @@ use crate::abi::FnAbi;\n use crate::common::*;\n use crate::type_::Type;\n use log::debug;\n-use rustc::bug;\n-use rustc::ty::layout::{self, Align, FnAbiExt, LayoutOf, PointeeInfo, Size, TyLayout};\n-use rustc::ty::print::obsolete::DefPathBasedNames;\n-use rustc::ty::{self, Ty, TypeFoldable};\n use rustc_codegen_ssa::traits::*;\n-use rustc_target::abi::TyLayoutMethods;\n+use rustc_middle::bug;\n+use rustc_middle::ty::layout::{FnAbiExt, TyAndLayout};\n+use rustc_middle::ty::print::obsolete::DefPathBasedNames;\n+use rustc_middle::ty::{self, Ty, TypeFoldable};\n+use rustc_target::abi::{Abi, Align, FieldsShape};\n+use rustc_target::abi::{Int, Pointer, F32, F64};\n+use rustc_target::abi::{LayoutOf, PointeeInfo, Scalar, Size, TyAndLayoutMethods, Variants};\n \n use std::fmt::Write;\n \n fn uncached_llvm_type<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n-    layout: TyLayout<'tcx>,\n-    defer: &mut Option<(&'a Type, TyLayout<'tcx>)>,\n+    layout: TyAndLayout<'tcx>,\n+    defer: &mut Option<(&'a Type, TyAndLayout<'tcx>)>,\n ) -> &'a Type {\n     match layout.abi {\n-        layout::Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n-        layout::Abi::Vector { ref element, count } => {\n+        Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n+        Abi::Vector { ref element, count } => {\n             // LLVM has a separate type for 64-bit SIMD vectors on X86 called\n             // `x86_mmx` which is needed for some SIMD operations. As a bit of a\n             // hack (all SIMD definitions are super unstable anyway) we\n@@ -37,7 +39,7 @@ fn uncached_llvm_type<'a, 'tcx>(\n                 return cx.type_vector(element, count);\n             }\n         }\n-        layout::Abi::ScalarPair(..) => {\n+        Abi::ScalarPair(..) => {\n             return cx.type_struct(\n                 &[\n                     layout.scalar_pair_element_llvm_type(cx, 0, false),\n@@ -46,7 +48,7 @@ fn uncached_llvm_type<'a, 'tcx>(\n                 false,\n             );\n         }\n-        layout::Abi::Uninhabited | layout::Abi::Aggregate { .. } => {}\n+        Abi::Uninhabited | Abi::Aggregate { .. } => {}\n     }\n \n     let name = match layout.ty.kind {\n@@ -61,14 +63,14 @@ fn uncached_llvm_type<'a, 'tcx>(\n             let mut name = String::with_capacity(32);\n             let printer = DefPathBasedNames::new(cx.tcx, true, true);\n             printer.push_type_name(layout.ty, &mut name, false);\n-            if let (&ty::Adt(def, _), &layout::Variants::Single { index })\n+            if let (&ty::Adt(def, _), &Variants::Single { index })\n                  = (&layout.ty.kind, &layout.variants)\n             {\n                 if def.is_enum() && !def.variants.is_empty() {\n                     write!(&mut name, \"::{}\", def.variants[index].ident).unwrap();\n                 }\n             }\n-            if let (&ty::Generator(_, substs, _), &layout::Variants::Single { index })\n+            if let (&ty::Generator(_, substs, _), &Variants::Single { index })\n                  = (&layout.ty.kind, &layout.variants)\n             {\n                 write!(&mut name, \"::{}\", substs.as_generator().variant_name(index)).unwrap();\n@@ -79,7 +81,7 @@ fn uncached_llvm_type<'a, 'tcx>(\n     };\n \n     match layout.fields {\n-        layout::FieldPlacement::Union(_) => {\n+        FieldsShape::Union(_) => {\n             let fill = cx.type_padding_filler(layout.size, layout.align.abi);\n             let packed = false;\n             match name {\n@@ -91,10 +93,8 @@ fn uncached_llvm_type<'a, 'tcx>(\n                 }\n             }\n         }\n-        layout::FieldPlacement::Array { count, .. } => {\n-            cx.type_array(layout.field(cx, 0).llvm_type(cx), count)\n-        }\n-        layout::FieldPlacement::Arbitrary { .. } => match name {\n+        FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).llvm_type(cx), count),\n+        FieldsShape::Arbitrary { .. } => match name {\n             None => {\n                 let (llfields, packed) = struct_llfields(cx, layout);\n                 cx.type_struct(&llfields, packed)\n@@ -110,7 +110,7 @@ fn uncached_llvm_type<'a, 'tcx>(\n \n fn struct_llfields<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n-    layout: TyLayout<'tcx>,\n+    layout: TyAndLayout<'tcx>,\n ) -> (Vec<&'a Type>, bool) {\n     debug!(\"struct_llfields: {:#?}\", layout);\n     let field_count = layout.fields.count();\n@@ -189,7 +189,7 @@ pub trait LayoutLlvmExt<'tcx> {\n     fn scalar_llvm_type_at<'a>(\n         &self,\n         cx: &CodegenCx<'a, 'tcx>,\n-        scalar: &layout::Scalar,\n+        scalar: &Scalar,\n         offset: Size,\n     ) -> &'a Type;\n     fn scalar_pair_element_llvm_type<'a>(\n@@ -202,26 +202,23 @@ pub trait LayoutLlvmExt<'tcx> {\n     fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size) -> Option<PointeeInfo>;\n }\n \n-impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n+impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n     fn is_llvm_immediate(&self) -> bool {\n         match self.abi {\n-            layout::Abi::Scalar(_) | layout::Abi::Vector { .. } => true,\n-            layout::Abi::ScalarPair(..) => false,\n-            layout::Abi::Uninhabited | layout::Abi::Aggregate { .. } => self.is_zst(),\n+            Abi::Scalar(_) | Abi::Vector { .. } => true,\n+            Abi::ScalarPair(..) => false,\n+            Abi::Uninhabited | Abi::Aggregate { .. } => self.is_zst(),\n         }\n     }\n \n     fn is_llvm_scalar_pair(&self) -> bool {\n         match self.abi {\n-            layout::Abi::ScalarPair(..) => true,\n-            layout::Abi::Uninhabited\n-            | layout::Abi::Scalar(_)\n-            | layout::Abi::Vector { .. }\n-            | layout::Abi::Aggregate { .. } => false,\n+            Abi::ScalarPair(..) => true,\n+            Abi::Uninhabited | Abi::Scalar(_) | Abi::Vector { .. } | Abi::Aggregate { .. } => false,\n         }\n     }\n \n-    /// Gets the LLVM type corresponding to a Rust type, i.e., `rustc::ty::Ty`.\n+    /// Gets the LLVM type corresponding to a Rust type, i.e., `rustc_middle::ty::Ty`.\n     /// The pointee type of the pointer in `PlaceRef` is always this type.\n     /// For sized types, it is also the right LLVM type for an `alloca`\n     /// containing a value of that type, and most immediates (except `bool`).\n@@ -233,7 +230,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n     fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n-        if let layout::Abi::Scalar(ref scalar) = self.abi {\n+        if let Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n             if let Some(&llty) = cx.scalar_lltypes.borrow().get(&self.ty) {\n@@ -255,7 +252,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         // Check the cache.\n         let variant_index = match self.variants {\n-            layout::Variants::Single { index } => Some(index),\n+            Variants::Single { index } => Some(index),\n             _ => None,\n         };\n         if let Some(&llty) = cx.lltypes.borrow().get(&(self.ty, variant_index)) {\n@@ -293,7 +290,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     }\n \n     fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n-        if let layout::Abi::Scalar(ref scalar) = self.abi {\n+        if let Abi::Scalar(ref scalar) = self.abi {\n             if scalar.is_bool() {\n                 return cx.type_i1();\n             }\n@@ -304,14 +301,14 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     fn scalar_llvm_type_at<'a>(\n         &self,\n         cx: &CodegenCx<'a, 'tcx>,\n-        scalar: &layout::Scalar,\n+        scalar: &Scalar,\n         offset: Size,\n     ) -> &'a Type {\n         match scalar.value {\n-            layout::Int(i, _) => cx.type_from_integer(i),\n-            layout::F32 => cx.type_f32(),\n-            layout::F64 => cx.type_f64(),\n-            layout::Pointer => {\n+            Int(i, _) => cx.type_from_integer(i),\n+            F32 => cx.type_f32(),\n+            F64 => cx.type_f64(),\n+            Pointer => {\n                 // If we know the alignment, pick something better than i8.\n                 let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {\n                     cx.type_pointee_for_align(pointee.align)\n@@ -343,8 +340,8 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n \n         let (a, b) = match self.abi {\n-            layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n-            _ => bug!(\"TyLayout::scalar_pair_element_llty({:?}): not applicable\", self),\n+            Abi::ScalarPair(ref a, ref b) => (a, b),\n+            _ => bug!(\"TyAndLayout::scalar_pair_element_llty({:?}): not applicable\", self),\n         };\n         let scalar = [a, b][index];\n \n@@ -365,21 +362,19 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n     fn llvm_field_index(&self, index: usize) -> u64 {\n         match self.abi {\n-            layout::Abi::Scalar(_) | layout::Abi::ScalarPair(..) => {\n-                bug!(\"TyLayout::llvm_field_index({:?}): not applicable\", self)\n+            Abi::Scalar(_) | Abi::ScalarPair(..) => {\n+                bug!(\"TyAndLayout::llvm_field_index({:?}): not applicable\", self)\n             }\n             _ => {}\n         }\n         match self.fields {\n-            layout::FieldPlacement::Union(_) => {\n-                bug!(\"TyLayout::llvm_field_index({:?}): not applicable\", self)\n+            FieldsShape::Union(_) => {\n+                bug!(\"TyAndLayout::llvm_field_index({:?}): not applicable\", self)\n             }\n \n-            layout::FieldPlacement::Array { .. } => index as u64,\n+            FieldsShape::Array { .. } => index as u64,\n \n-            layout::FieldPlacement::Arbitrary { .. } => {\n-                1 + (self.fields.memory_index(index) as u64) * 2\n-            }\n+            FieldsShape::Arbitrary { .. } => 1 + (self.fields.memory_index(index) as u64) * 2,\n         }\n     }\n "}, {"sha": "8bc3579800ea81380214b01e823161a28bb8454b", "filename": "src/librustc_codegen_llvm/va_arg.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fva_arg.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2,12 +2,13 @@ use crate::builder::Builder;\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n-use rustc::ty::layout::{Align, HasDataLayout, HasTyCtxt, LayoutOf, Size};\n-use rustc::ty::Ty;\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::traits::{\n     BaseTypeMethods, BuilderMethods, ConstMethods, DerivedTypeMethods,\n };\n+use rustc_middle::ty::layout::HasTyCtxt;\n+use rustc_middle::ty::Ty;\n+use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size};\n \n #[allow(dead_code)]\n fn round_pointer_up_to_alignment("}, {"sha": "717e32d4a0d8a1e79083d2d7df9762779e2f643f", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -22,7 +22,7 @@ tempfile = \"3.1\"\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n-rustc = { path = \"../librustc\" }\n+rustc_middle = { path = \"../librustc_middle\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_symbol_mangling = { path = \"../librustc_symbol_mangling\" }"}, {"sha": "1e780c5f86771ee3767cf25f99f2852ac35fb7c7", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,8 +1,8 @@\n-use rustc::middle::cstore::{EncodedMetadata, LibSource, NativeLibrary, NativeLibraryKind};\n-use rustc::middle::dependency_format::Linkage;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n+use rustc_middle::middle::cstore::{EncodedMetadata, LibSource, NativeLibrary, NativeLibraryKind};\n+use rustc_middle::middle::dependency_format::Linkage;\n use rustc_session::config::{\n     self, CFGuard, DebugInfo, OutputFilenames, OutputType, PrintRequest, Sanitizer,\n };"}, {"sha": "c0c533524b09861eaf79cbe4fbe9aef1c40b5fa0", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -8,10 +8,10 @@ use std::io::prelude::*;\n use std::io::{self, BufWriter};\n use std::path::{Path, PathBuf};\n \n-use rustc::middle::dependency_format::Linkage;\n-use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc_middle::middle::dependency_format::Linkage;\n+use rustc_middle::ty::TyCtxt;\n use rustc_serialize::{json, Encoder};\n use rustc_session::config::{self, CrateType, DebugInfo, LinkerPluginLto, Lto, OptLevel};\n use rustc_session::Session;"}, {"sha": "c02e4f279b1fbea67e2990c6f0b6db5540372441", "filename": "src/librustc_codegen_ssa/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -3,8 +3,8 @@ use std::env;\n use std::fs;\n use std::path::{Path, PathBuf};\n \n-use rustc::middle::cstore::LibSource;\n use rustc_hir::def_id::CrateNum;\n+use rustc_middle::middle::cstore::LibSource;\n \n pub struct RPathConfig<'a> {\n     pub used_crates: &'a [(CrateNum, LibSource)],"}, {"sha": "39b70a5f2e730527e5011efec2287ab6f0ed8fb0", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,19 +1,21 @@\n use std::collections::hash_map::Entry::*;\n use std::sync::Arc;\n \n-use rustc::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc::middle::exported_symbols::{metadata_symbol_name, ExportedSymbol, SymbolExportLevel};\n-use rustc::ty::query::Providers;\n-use rustc::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc::ty::Instance;\n-use rustc::ty::{SymbolName, TyCtxt};\n use rustc_ast::expand::allocator::ALLOCATOR_METHODS;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::Node;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::middle::exported_symbols::{\n+    metadata_symbol_name, ExportedSymbol, SymbolExportLevel,\n+};\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n+use rustc_middle::ty::Instance;\n+use rustc_middle::ty::{SymbolName, TyCtxt};\n use rustc_session::config::{self, Sanitizer};\n \n pub fn threshold(tcx: TyCtxt<'_>) -> SymbolExportLevel {\n@@ -221,8 +223,8 @@ fn exported_symbols_provider_local(\n     }\n \n     if tcx.sess.opts.share_generics() && tcx.local_crate_exports_generics() {\n-        use rustc::mir::mono::{Linkage, MonoItem, Visibility};\n-        use rustc::ty::InstanceDef;\n+        use rustc_middle::mir::mono::{Linkage, MonoItem, Visibility};\n+        use rustc_middle::ty::InstanceDef;\n \n         // Normally, we require that shared monomorphizations are not hidden,\n         // because if we want to re-use a monomorphization from a Rust dylib, it"}, {"sha": "35c5812e1f3bf138cba1d2bd86c44b43042d6730", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -10,10 +10,6 @@ use crate::{\n \n use crate::traits::*;\n use jobserver::{Acquired, Client};\n-use rustc::dep_graph::{WorkProduct, WorkProductFileKind, WorkProductId};\n-use rustc::middle::cstore::EncodedMetadata;\n-use rustc::middle::exported_symbols::SymbolExportLevel;\n-use rustc::ty::TyCtxt;\n use rustc_ast::attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n@@ -28,6 +24,10 @@ use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_incremental::{\n     copy_cgu_workproducts_to_incr_comp_cache_dir, in_incr_comp_dir, in_incr_comp_dir_sess,\n };\n+use rustc_middle::dep_graph::{WorkProduct, WorkProductFileKind, WorkProductId};\n+use rustc_middle::middle::cstore::EncodedMetadata;\n+use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::cgu_reuse_tracker::CguReuseTracker;\n use rustc_session::config::{\n     self, Lto, OutputFilenames, OutputType, Passes, Sanitizer, SwitchWithOptPath,"}, {"sha": "029741515555362ef6296af869e8224c9421eb56", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -25,28 +25,29 @@ use crate::mir::place::PlaceRef;\n use crate::traits::*;\n use crate::{CachedModuleCodegen, CrateInfo, MemFlags, ModuleCodegen, ModuleKind};\n \n-use rustc::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use rustc::middle::cstore::EncodedMetadata;\n-use rustc::middle::cstore::{self, LinkagePreference};\n-use rustc::middle::lang_items;\n-use rustc::middle::lang_items::StartFnLangItem;\n-use rustc::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, MonoItem};\n-use rustc::ty::layout::{self, Align, HasTyCtxt, LayoutOf, TyLayout, VariantIdx};\n-use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n-use rustc::ty::query::Providers;\n-use rustc::ty::{self, Instance, Ty, TyCtxt};\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::print_time_passes_entry;\n use rustc_data_structures::sync::{par_iter, Lock, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::lang_items::StartFnLangItem;\n use rustc_index::vec::Idx;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n+use rustc_middle::middle::cstore::EncodedMetadata;\n+use rustc_middle::middle::cstore::{self, LinkagePreference};\n+use rustc_middle::middle::lang_items;\n+use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, MonoItem};\n+use rustc_middle::ty::layout::{self, HasTyCtxt, TyAndLayout};\n+use rustc_middle::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{self, EntryFnType, Lto};\n use rustc_session::Session;\n use rustc_span::Span;\n use rustc_symbol_mangling::test as symbol_names_test;\n+use rustc_target::abi::{Abi, Align, LayoutOf, Scalar, VariantIdx};\n \n use std::cmp;\n use std::ops::{Deref, DerefMut};\n@@ -341,9 +342,9 @@ pub fn from_immediate<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n pub fn to_immediate<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     val: Bx::Value,\n-    layout: layout::TyLayout<'_>,\n+    layout: layout::TyAndLayout<'_>,\n ) -> Bx::Value {\n-    if let layout::Abi::Scalar(ref scalar) = layout.abi {\n+    if let Abi::Scalar(ref scalar) = layout.abi {\n         return to_immediate_scalar(bx, val, scalar);\n     }\n     val\n@@ -352,7 +353,7 @@ pub fn to_immediate<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n pub fn to_immediate_scalar<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     val: Bx::Value,\n-    scalar: &layout::Scalar,\n+    scalar: &Scalar,\n ) -> Bx::Value {\n     if scalar.is_bool() {\n         return bx.trunc(val, bx.cx().type_i1());\n@@ -366,7 +367,7 @@ pub fn memcpy_ty<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     dst_align: Align,\n     src: Bx::Value,\n     src_align: Align,\n-    layout: TyLayout<'tcx>,\n+    layout: TyAndLayout<'tcx>,\n     flags: MemFlags,\n ) {\n     let size = layout.size.bytes();\n@@ -557,7 +558,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // one instead. If nothing exists then it's our job to generate the\n     // allocator!\n     let any_dynamic_crate = tcx.dependency_formats(LOCAL_CRATE).iter().any(|(_, list)| {\n-        use rustc::middle::dependency_format::Linkage;\n+        use rustc_middle::middle::dependency_format::Linkage;\n         list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n     });\n     let allocator_module = if any_dynamic_crate {"}, {"sha": "0d0321ec4ae5e5099189a959a3acbb86b8e91adb", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,17 +1,16 @@\n #![allow(non_camel_case_types, non_snake_case)]\n \n-use rustc::ty::{Ty, TyCtxt};\n use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::LangItem;\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_session::Session;\n use rustc_span::Span;\n \n use crate::base;\n-use crate::traits::*;\n-use rustc::middle::lang_items::LangItem;\n-use rustc_hir::def_id::DefId;\n-\n use crate::traits::BuilderMethods;\n-use rustc_hir as hir;\n+use crate::traits::*;\n \n pub enum IntPredicate {\n     IntEQ,"}, {"sha": "6c0e4128e30f5f51e128056a3eb0837c88834605", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,9 +1,9 @@\n // Type Names for Debug Info.\n \n-use rustc::ty::{self, subst::SubstsRef, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{self, subst::SubstsRef, Ty, TyCtxt};\n \n // Compute the name of the type as it should be stored in debuginfo. Does not do\n // any caching, i.e., calling the function twice with the same type will also do"}, {"sha": "5b086bc43ff353ffa0ca75570d0397d2de7f660a", "filename": "src/librustc_codegen_ssa/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fglue.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -5,7 +5,7 @@\n use crate::common::IntPredicate;\n use crate::meth;\n use crate::traits::*;\n-use rustc::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty};\n \n pub fn size_and_align_of_dst<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,"}, {"sha": "bf8441562c55ba207b36d082df3ecec9947c980a", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -15,17 +15,17 @@\n #[macro_use]\n extern crate log;\n #[macro_use]\n-extern crate rustc;\n+extern crate rustc_middle;\n \n-use rustc::dep_graph::WorkProduct;\n-use rustc::middle::cstore::{CrateSource, LibSource, NativeLibrary};\n-use rustc::middle::dependency_format::Dependencies;\n-use rustc::middle::lang_items::LangItem;\n-use rustc::ty::query::Providers;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir::def_id::CrateNum;\n+use rustc_hir::LangItem;\n+use rustc_middle::dep_graph::WorkProduct;\n+use rustc_middle::middle::cstore::{CrateSource, LibSource, NativeLibrary};\n+use rustc_middle::middle::dependency_format::Dependencies;\n+use rustc_middle::ty::query::Providers;\n use rustc_session::config::{OutputFilenames, OutputType, RUST_CGU_EXT};\n use rustc_span::symbol::Symbol;\n use std::path::{Path, PathBuf};\n@@ -144,7 +144,7 @@ pub struct CodegenResults {\n     pub allocator_module: Option<CompiledModule>,\n     pub metadata_module: Option<CompiledModule>,\n     pub crate_hash: Svh,\n-    pub metadata: rustc::middle::cstore::EncodedMetadata,\n+    pub metadata: rustc_middle::middle::cstore::EncodedMetadata,\n     pub windows_subsystem: Option<String>,\n     pub linker_info: back::linker::LinkerInfo,\n     pub crate_info: CrateInfo,"}, {"sha": "199dd8c7df42fd7d0be1e33acb752b6d652b210e", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,6 +1,6 @@\n use crate::traits::*;\n \n-use rustc::ty::{self, Instance, Ty};\n+use rustc_middle::ty::{self, Instance, Ty};\n use rustc_target::abi::call::FnAbi;\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "221f36fed362dab3d03e6a46db9e3861260e8b47", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -3,24 +3,25 @@\n \n use super::FunctionCx;\n use crate::traits::*;\n-use rustc::mir::traversal;\n-use rustc::mir::visit::{\n-    MutatingUseContext, NonMutatingUseContext, NonUseContext, PlaceContext, Visitor,\n-};\n-use rustc::mir::{self, Location, TerminatorKind};\n-use rustc::ty;\n-use rustc::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::mir::traversal;\n+use rustc_middle::mir::visit::{\n+    MutatingUseContext, NonMutatingUseContext, NonUseContext, PlaceContext, Visitor,\n+};\n+use rustc_middle::mir::{self, Location, TerminatorKind};\n+use rustc_middle::ty;\n+use rustc_middle::ty::layout::HasTyCtxt;\n+use rustc_target::abi::LayoutOf;\n \n pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     fx: &FunctionCx<'a, 'tcx, Bx>,\n ) -> BitSet<mir::Local> {\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n-    analyzer.visit_body(mir);\n+    analyzer.visit_body(&mir);\n \n     for (local, decl) in mir.local_decls.iter_enumerated() {\n         let ty = fx.monomorphize(&decl.ty);"}, {"sha": "219d5aa77ea0d9b168ca2af9884fdd85a6410485", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -9,14 +9,15 @@ use crate::meth;\n use crate::traits::*;\n use crate::MemFlags;\n \n-use rustc::middle::lang_items;\n-use rustc::mir;\n-use rustc::mir::AssertKind;\n-use rustc::ty::layout::{self, FnAbiExt, HasTyCtxt, LayoutOf};\n-use rustc::ty::{self, Instance, Ty, TypeFoldable};\n+use rustc_hir::lang_items;\n use rustc_index::vec::Idx;\n+use rustc_middle::mir;\n+use rustc_middle::mir::AssertKind;\n+use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n+use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_span::{source_map::Span, symbol::Symbol};\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n+use rustc_target::abi::{self, LayoutOf};\n use rustc_target::spec::abi::Abi;\n \n use std::borrow::Cow;\n@@ -299,7 +300,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n         mut bx: Bx,\n-        location: &mir::Place<'tcx>,\n+        location: mir::Place<'tcx>,\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n@@ -580,7 +581,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if intrinsic == Some(\"transmute\") {\n             if let Some(destination_ref) = destination.as_ref() {\n-                let &(ref dest, target) = destination_ref;\n+                let &(dest, target) = destination_ref;\n                 self.codegen_transmute(&mut bx, &args[0], dest);\n                 helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n@@ -591,7 +592,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // we can do what we like. Here, we declare that transmuting\n                 // into an uninhabited type is impossible, so anything following\n                 // it must be unreachable.\n-                assert_eq!(fn_abi.ret.layout.abi, layout::Abi::Uninhabited);\n+                assert_eq!(fn_abi.ret.layout.abi, abi::Abi::Uninhabited);\n                 bx.unreachable();\n             }\n             return;\n@@ -619,7 +620,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let mut llargs = Vec::with_capacity(arg_count);\n \n         // Prepare the return value destination\n-        let ret_dest = if let Some((ref dest, _)) = *destination {\n+        let ret_dest = if let Some((dest, _)) = *destination {\n             let is_intrinsic = intrinsic.is_some();\n             self.make_return_dest(&mut bx, dest, &fn_abi.ret, &mut llargs, is_intrinsic)\n         } else {\n@@ -873,7 +874,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx.unreachable();\n             }\n \n-            mir::TerminatorKind::Drop { ref location, target, unwind } => {\n+            mir::TerminatorKind::Drop { location, target, unwind } => {\n                 self.codegen_drop_terminator(helper, bx, location, target, unwind);\n             }\n \n@@ -994,7 +995,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // the load would just produce `OperandValue::Ref` instead\n                 // of the `OperandValue::Immediate` we need for the call.\n                 llval = bx.load(llval, align);\n-                if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n+                if let abi::Abi::Scalar(ref scalar) = arg.layout.abi {\n                     if scalar.is_bool() {\n                         bx.range_metadata(llval, 0..2);\n                     }\n@@ -1123,7 +1124,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn make_return_dest(\n         &mut self,\n         bx: &mut Bx,\n-        dest: &mir::Place<'tcx>,\n+        dest: mir::Place<'tcx>,\n         fn_ret: &ArgAbi<'tcx, Ty<'tcx>>,\n         llargs: &mut Vec<Bx::Value>,\n         is_intrinsic: bool,\n@@ -1184,7 +1185,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    fn codegen_transmute(&mut self, bx: &mut Bx, src: &mir::Operand<'tcx>, dst: &mir::Place<'tcx>) {\n+    fn codegen_transmute(&mut self, bx: &mut Bx, src: &mir::Operand<'tcx>, dst: mir::Place<'tcx>) {\n         if let Some(index) = dst.as_local() {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),"}, {"sha": "298aa25f0321ff27bce6ca96b138e3cd32dcb87f", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,11 +1,12 @@\n use crate::mir::operand::OperandRef;\n use crate::traits::*;\n-use rustc::mir;\n-use rustc::mir::interpret::{ConstValue, ErrorHandled};\n-use rustc::ty::layout::{self, HasTyCtxt};\n-use rustc::ty::{self, Ty};\n use rustc_index::vec::Idx;\n+use rustc_middle::mir;\n+use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n+use rustc_middle::ty::layout::HasTyCtxt;\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Span;\n+use rustc_target::abi::Abi;\n \n use super::FunctionCx;\n \n@@ -87,7 +88,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         if let Some(prim) = field.try_to_scalar() {\n                             let layout = bx.layout_of(field_ty);\n                             let scalar = match layout.abi {\n-                                layout::Abi::Scalar(ref x) => x,\n+                                Abi::Scalar(ref x) => x,\n                                 _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout),\n                             };\n                             bx.scalar_to_backend(prim, scalar, bx.immediate_backend_type(layout))"}, {"sha": "5501ed5128d4d1237789066db5387f4275d6f79e", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,13 +1,12 @@\n use crate::traits::*;\n-use rustc::mir;\n-use rustc::ty;\n-use rustc::ty::layout::{LayoutOf, Size};\n use rustc_hir::def_id::CrateNum;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::mir;\n+use rustc_middle::ty;\n use rustc_session::config::DebugInfo;\n-\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Span};\n+use rustc_target::abi::{LayoutOf, Size};\n \n use super::operand::OperandValue;\n use super::place::PlaceRef;"}, {"sha": "fd20cf5404c666b5247166cf9ae34a74f34ab1d4", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,8 +1,8 @@\n use crate::base;\n use crate::traits::*;\n-use rustc::mir;\n-use rustc::ty::layout::{FnAbiExt, HasTyCtxt, TyLayout};\n-use rustc::ty::{self, Instance, Ty, TypeFoldable};\n+use rustc_middle::mir;\n+use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt, TyAndLayout};\n+use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_target::abi::call::{FnAbi, PassMode};\n \n use std::iter;\n@@ -13,7 +13,7 @@ use rustc_index::vec::IndexVec;\n use self::analyze::CleanupKind;\n use self::debuginfo::{FunctionDebugContext, PerLocalVarDebugInfo};\n use self::place::PlaceRef;\n-use rustc::mir::traversal;\n+use rustc_middle::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n \n@@ -114,7 +114,7 @@ enum LocalRef<'tcx, V> {\n impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n     fn new_operand<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n     ) -> LocalRef<'tcx, V> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which"}, {"sha": "69f11ed57ac5db81e063c85d0b100f0f503ca558", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -6,10 +6,11 @@ use crate::glue;\n use crate::traits::*;\n use crate::MemFlags;\n \n-use rustc::mir;\n-use rustc::mir::interpret::{ConstValue, ErrorHandled, Pointer, Scalar};\n-use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n-use rustc::ty::Ty;\n+use rustc_middle::mir;\n+use rustc_middle::mir::interpret::{ConstValue, ErrorHandled, Pointer, Scalar};\n+use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::ty::Ty;\n+use rustc_target::abi::{Abi, Align, LayoutOf, Size};\n \n use std::fmt;\n \n@@ -43,7 +44,7 @@ pub struct OperandRef<'tcx, V> {\n     pub val: OperandValue<V>,\n \n     // The layout of value, based on its Rust type.\n-    pub layout: TyLayout<'tcx>,\n+    pub layout: TyAndLayout<'tcx>,\n }\n \n impl<V: CodegenObject> fmt::Debug for OperandRef<'tcx, V> {\n@@ -55,7 +56,7 @@ impl<V: CodegenObject> fmt::Debug for OperandRef<'tcx, V> {\n impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n     pub fn new_zst<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n     ) -> OperandRef<'tcx, V> {\n         assert!(layout.is_zst());\n         OperandRef {\n@@ -78,15 +79,15 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n         let val = match val {\n             ConstValue::Scalar(x) => {\n                 let scalar = match layout.abi {\n-                    layout::Abi::Scalar(ref x) => x,\n+                    Abi::Scalar(ref x) => x,\n                     _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout),\n                 };\n                 let llval = bx.scalar_to_backend(x, scalar, bx.immediate_backend_type(layout));\n                 OperandValue::Immediate(llval)\n             }\n             ConstValue::Slice { data, start, end } => {\n                 let a_scalar = match layout.abi {\n-                    layout::Abi::ScalarPair(ref a, _) => a,\n+                    Abi::ScalarPair(ref a, _) => a,\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout),\n                 };\n                 let a = Scalar::from(Pointer::new(\n@@ -159,9 +160,9 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n     pub fn from_immediate_or_packed_pair<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         llval: V,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n     ) -> Self {\n-        let val = if let layout::Abi::ScalarPair(ref a, ref b) = layout.abi {\n+        let val = if let Abi::ScalarPair(ref a, ref b) = layout.abi {\n             debug!(\"Operand::from_immediate_or_packed_pair: unpacking {:?} @ {:?}\", llval, layout);\n \n             // Deconstruct the immediate aggregate.\n@@ -199,7 +200,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             }\n \n             // Extract a scalar component from a pair.\n-            (OperandValue::Pair(a_llval, b_llval), &layout::Abi::ScalarPair(ref a, ref b)) => {\n+            (OperandValue::Pair(a_llval, b_llval), &Abi::ScalarPair(ref a, ref b)) => {\n                 if offset.bytes() == 0 {\n                     assert_eq!(field.size, a.value.size(bx.cx()));\n                     OperandValue::Immediate(a_llval)\n@@ -211,7 +212,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             }\n \n             // `#[repr(simd)]` types are also immediate.\n-            (OperandValue::Immediate(llval), &layout::Abi::Vector { .. }) => {\n+            (OperandValue::Immediate(llval), &Abi::Vector { .. }) => {\n                 OperandValue::Immediate(bx.extract_element(llval, bx.cx().const_usize(i as u64)))\n             }\n \n@@ -305,7 +306,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n             }\n             OperandValue::Pair(a, b) => {\n                 let (a_scalar, b_scalar) = match dest.layout.abi {\n-                    layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n+                    Abi::ScalarPair(ref a, ref b) => (a, b),\n                     _ => bug!(\"store_with_flags: invalid ScalarPair layout: {:#?}\", dest.layout),\n                 };\n                 let b_offset = a_scalar.value.size(bx).align_to(b_scalar.value.align(bx).abi);"}, {"sha": "461695129c2f37d573e0259acca8c10d416f9da6", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -6,10 +6,12 @@ use crate::glue;\n use crate::traits::*;\n use crate::MemFlags;\n \n-use rustc::mir;\n-use rustc::mir::tcx::PlaceTy;\n-use rustc::ty::layout::{self, Align, HasTyCtxt, LayoutOf, TyLayout, VariantIdx};\n-use rustc::ty::{self, Ty};\n+use rustc_middle::mir;\n+use rustc_middle::mir::tcx::PlaceTy;\n+use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_target::abi::{Abi, Align, DiscriminantKind, FieldsShape, Int};\n+use rustc_target::abi::{LayoutOf, VariantIdx, Variants};\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceRef<'tcx, V> {\n@@ -20,19 +22,23 @@ pub struct PlaceRef<'tcx, V> {\n     pub llextra: Option<V>,\n \n     /// The monomorphized type of this place, including variant information.\n-    pub layout: TyLayout<'tcx>,\n+    pub layout: TyAndLayout<'tcx>,\n \n     /// The alignment we know for this place.\n     pub align: Align,\n }\n \n impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n-    pub fn new_sized(llval: V, layout: TyLayout<'tcx>) -> PlaceRef<'tcx, V> {\n+    pub fn new_sized(llval: V, layout: TyAndLayout<'tcx>) -> PlaceRef<'tcx, V> {\n         assert!(!layout.is_unsized());\n         PlaceRef { llval, llextra: None, layout, align: layout.align.abi }\n     }\n \n-    pub fn new_sized_aligned(llval: V, layout: TyLayout<'tcx>, align: Align) -> PlaceRef<'tcx, V> {\n+    pub fn new_sized_aligned(\n+        llval: V,\n+        layout: TyAndLayout<'tcx>,\n+        align: Align,\n+    ) -> PlaceRef<'tcx, V> {\n         assert!(!layout.is_unsized());\n         PlaceRef { llval, llextra: None, layout, align }\n     }\n@@ -41,7 +47,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     // unless LLVM IR names are turned on (e.g. for `--emit=llvm-ir`).\n     pub fn alloca<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n     ) -> Self {\n         assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n         let tmp = bx.alloca(bx.cx().backend_type(layout), layout.align.abi);\n@@ -53,7 +59,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     // unless LLVM IR names are turned on (e.g. for `--emit=llvm-ir`).\n     pub fn alloca_unsized_indirect<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n     ) -> Self {\n         assert!(layout.is_unsized(), \"tried to allocate indirect place for sized values\");\n         let ptr_ty = bx.cx().tcx().mk_mut_ptr(layout.ty);\n@@ -62,7 +68,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     }\n \n     pub fn len<Cx: ConstMethods<'tcx, Value = V>>(&self, cx: &Cx) -> V {\n-        if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n+        if let FieldsShape::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n                 assert_eq!(count, 0);\n                 self.llextra.unwrap()\n@@ -90,7 +96,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             // Unions and newtypes only use an offset of 0.\n             let llval = if offset.bytes() == 0 {\n                 self.llval\n-            } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n+            } else if let Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n                 // Offsets have to match either first or second field.\n                 assert_eq!(offset, a.value.size(bx.cx()).align_to(b.value.align(bx.cx()).abi));\n                 bx.struct_gep(self.llval, 1)\n@@ -194,15 +200,15 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             return bx.cx().const_undef(cast_to);\n         }\n         let (discr_scalar, discr_kind, discr_index) = match self.layout.variants {\n-            layout::Variants::Single { index } => {\n+            Variants::Single { index } => {\n                 let discr_val = self\n                     .layout\n                     .ty\n                     .discriminant_for_variant(bx.cx().tcx(), index)\n                     .map_or(index.as_u32() as u128, |discr| discr.val);\n                 return bx.cx().const_uint_big(cast_to, discr_val);\n             }\n-            layout::Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n+            Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n                 (discr, discr_kind, discr_index)\n             }\n         };\n@@ -213,22 +219,18 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n \n         // Decode the discriminant (specifically if it's niche-encoded).\n         match *discr_kind {\n-            layout::DiscriminantKind::Tag => {\n+            DiscriminantKind::Tag => {\n                 let signed = match discr_scalar.value {\n                     // We use `i1` for bytes that are always `0` or `1`,\n                     // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n                     // let LLVM interpret the `i1` as signed, because\n                     // then `i1 1` (i.e., `E::B`) is effectively `i8 -1`.\n-                    layout::Int(_, signed) => !discr_scalar.is_bool() && signed,\n+                    Int(_, signed) => !discr_scalar.is_bool() && signed,\n                     _ => false,\n                 };\n                 bx.intcast(encoded_discr.immediate(), cast_to, signed)\n             }\n-            layout::DiscriminantKind::Niche {\n-                dataful_variant,\n-                ref niche_variants,\n-                niche_start,\n-            } => {\n+            DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start } => {\n                 // Rebase from niche values to discriminants, and check\n                 // whether the result is in range for the niche variants.\n                 let niche_llty = bx.cx().immediate_backend_type(encoded_discr.layout);\n@@ -307,14 +309,10 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             return;\n         }\n         match self.layout.variants {\n-            layout::Variants::Single { index } => {\n+            Variants::Single { index } => {\n                 assert_eq!(index, variant_index);\n             }\n-            layout::Variants::Multiple {\n-                discr_kind: layout::DiscriminantKind::Tag,\n-                discr_index,\n-                ..\n-            } => {\n+            Variants::Multiple { discr_kind: DiscriminantKind::Tag, discr_index, .. } => {\n                 let ptr = self.project_field(bx, discr_index);\n                 let to =\n                     self.layout.ty.discriminant_for_variant(bx.tcx(), variant_index).unwrap().val;\n@@ -324,9 +322,9 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     ptr.align,\n                 );\n             }\n-            layout::Variants::Multiple {\n+            Variants::Multiple {\n                 discr_kind:\n-                    layout::DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start },\n+                    DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start },\n                 discr_index,\n                 ..\n             } => {"}, {"sha": "33f449ed270bebf7f5cb11a4347cd31de8de7b4c", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -7,14 +7,15 @@ use crate::common::{self, IntPredicate, RealPredicate};\n use crate::traits::*;\n use crate::MemFlags;\n \n-use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n-use rustc::mir;\n-use rustc::ty::cast::{CastTy, IntTy};\n-use rustc::ty::layout::{self, HasTyCtxt, LayoutOf};\n-use rustc::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_apfloat::{ieee, Float, Round, Status};\n+use rustc_hir::lang_items::ExchangeMallocFnLangItem;\n+use rustc_middle::mir;\n+use rustc_middle::ty::cast::{CastTy, IntTy};\n+use rustc_middle::ty::layout::HasTyCtxt;\n+use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::sym;\n+use rustc_target::abi::{Abi, Int, LayoutOf, Variants};\n \n use std::{i128, u128};\n \n@@ -292,7 +293,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let r_t_out = CastTy::from_ty(cast.ty).expect(\"bad output type for cast\");\n                         let ll_t_in = bx.cx().immediate_backend_type(operand.layout);\n                         match operand.layout.variants {\n-                            layout::Variants::Single { index } => {\n+                            Variants::Single { index } => {\n                                 if let Some(discr) =\n                                     operand.layout.ty.discriminant_for_variant(bx.tcx(), index)\n                                 {\n@@ -311,13 +312,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     );\n                                 }\n                             }\n-                            layout::Variants::Multiple { .. } => {}\n+                            Variants::Multiple { .. } => {}\n                         }\n                         let llval = operand.immediate();\n \n                         let mut signed = false;\n-                        if let layout::Abi::Scalar(ref scalar) = operand.layout.abi {\n-                            if let layout::Int(_, s) = scalar.value {\n+                        if let Abi::Scalar(ref scalar) = operand.layout.abi {\n+                            if let Int(_, s) = scalar.value {\n                                 // We use `i1` for bytes that are always `0` or `1`,\n                                 // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n                                 // let LLVM interpret the `i1` as signed, because\n@@ -383,7 +384,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 (bx, OperandRef { val, layout: cast })\n             }\n \n-            mir::Rvalue::Ref(_, bk, ref place) => {\n+            mir::Rvalue::Ref(_, bk, place) => {\n                 let mk_ref = move |tcx: TyCtxt<'tcx>, ty: Ty<'tcx>| {\n                     tcx.mk_ref(\n                         tcx.lifetimes.re_erased,\n@@ -393,14 +394,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 self.codegen_place_to_pointer(bx, place, mk_ref)\n             }\n \n-            mir::Rvalue::AddressOf(mutability, ref place) => {\n+            mir::Rvalue::AddressOf(mutability, place) => {\n                 let mk_ptr = move |tcx: TyCtxt<'tcx>, ty: Ty<'tcx>| {\n                     tcx.mk_ptr(ty::TypeAndMut { ty, mutbl: mutability })\n                 };\n                 self.codegen_place_to_pointer(bx, place, mk_ptr)\n             }\n \n-            mir::Rvalue::Len(ref place) => {\n+            mir::Rvalue::Len(place) => {\n                 let size = self.evaluate_array_len(&mut bx, place);\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(size),\n@@ -537,7 +538,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    fn evaluate_array_len(&mut self, bx: &mut Bx, place: &mir::Place<'tcx>) -> Bx::Value {\n+    fn evaluate_array_len(&mut self, bx: &mut Bx, place: mir::Place<'tcx>) -> Bx::Value {\n         // ZST are passed as operands and require special handling\n         // because codegen_place() panics if Local is operand.\n         if let Some(index) = place.as_local() {\n@@ -557,7 +558,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn codegen_place_to_pointer(\n         &mut self,\n         mut bx: Bx,\n-        place: &mir::Place<'tcx>,\n+        place: mir::Place<'tcx>,\n         mk_ptr_ty: impl FnOnce(TyCtxt<'tcx>, Ty<'tcx>) -> Ty<'tcx>,\n     ) -> (Bx, OperandRef<'tcx, Bx::Value>) {\n         let cg_place = self.codegen_place(&mut bx, place.as_ref());"}, {"sha": "ddd7447406c48cafb710ed6a61cc94621a19e8e4", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,5 +1,5 @@\n-use rustc::mir;\n use rustc_errors::struct_span_err;\n+use rustc_middle::mir;\n \n use super::FunctionCx;\n use super::LocalRef;"}, {"sha": "5994ef2be5467e0301115428398a8006591fff72", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,10 +1,10 @@\n use crate::base;\n use crate::traits::*;\n-use rustc::mir::mono::{Linkage, Visibility};\n-use rustc::ty::layout::HasTyCtxt;\n use rustc_hir as hir;\n+use rustc_middle::mir::mono::{Linkage, Visibility};\n+use rustc_middle::ty::layout::HasTyCtxt;\n \n-use rustc::mir::mono::MonoItem;\n+use rustc_middle::mir::mono::MonoItem;\n \n pub trait MonoItemExt<'a, 'tcx> {\n     fn define<Bx: BuilderMethods<'a, 'tcx>>(&self, cx: &'a Bx::CodegenCx);"}, {"sha": "dd8495850bd5458e88a78f8a53e0ea04f16b2a8d", "filename": "src/librustc_codegen_ssa/traits/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,5 +1,5 @@\n use super::BackendTypes;\n-use rustc::ty::Ty;\n+use rustc_middle::ty::Ty;\n use rustc_target::abi::call::FnAbi;\n \n pub trait AbiBuilderMethods<'tcx>: BackendTypes {"}, {"sha": "91be123beb0bcef36c10312eaca002f95800a3d4", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2,18 +2,19 @@ use super::write::WriteBackendMethods;\n use super::CodegenObject;\n use crate::ModuleCodegen;\n \n-use rustc::dep_graph::DepGraph;\n-use rustc::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n-use rustc::ty::layout::{HasTyCtxt, LayoutOf, TyLayout};\n-use rustc::ty::query::Providers;\n-use rustc::ty::{Ty, TyCtxt};\n-use rustc::util::common::ErrorReported;\n use rustc_ast::expand::allocator::AllocatorKind;\n+use rustc_errors::ErrorReported;\n+use rustc_middle::dep_graph::DepGraph;\n+use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n+use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_session::{\n     config::{self, OutputFilenames, PrintRequest},\n     Session,\n };\n use rustc_span::symbol::Symbol;\n+use rustc_target::abi::LayoutOf;\n \n pub use rustc_data_structures::sync::MetadataRef;\n \n@@ -35,12 +36,12 @@ pub trait BackendTypes {\n }\n \n pub trait Backend<'tcx>:\n-    Sized + BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+    Sized + BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n {\n }\n \n impl<'tcx, T> Backend<'tcx> for T where\n-    Self: BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+    Self: BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n {\n }\n "}, {"sha": "caba7ebef593b3897dc355125d6b4776eec87af1", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -12,8 +12,9 @@ use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n use crate::MemFlags;\n \n-use rustc::ty::layout::{Align, HasParamEnv, Size};\n-use rustc::ty::Ty;\n+use rustc_middle::ty::layout::HasParamEnv;\n+use rustc_middle::ty::Ty;\n+use rustc_target::abi::{Align, Size};\n use rustc_target::spec::HasTargetSpec;\n \n use std::iter::TrustedLen;"}, {"sha": "6b58dea794bcbca7099085b56c6d5ee99af59cb7", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,9 +1,9 @@\n use super::BackendTypes;\n use crate::mir::place::PlaceRef;\n-use rustc::mir::interpret::Allocation;\n-use rustc::mir::interpret::Scalar;\n-use rustc::ty::layout;\n+use rustc_middle::mir::interpret::{Allocation, Scalar};\n+use rustc_middle::ty::layout::TyAndLayout;\n use rustc_span::Symbol;\n+use rustc_target::abi::{self, Size};\n \n pub trait ConstMethods<'tcx>: BackendTypes {\n     // Constant constructors\n@@ -26,17 +26,12 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn const_to_opt_uint(&self, v: Self::Value) -> Option<u64>;\n     fn const_to_opt_u128(&self, v: Self::Value, sign_ext: bool) -> Option<u128>;\n \n-    fn scalar_to_backend(\n-        &self,\n-        cv: Scalar,\n-        layout: &layout::Scalar,\n-        llty: Self::Type,\n-    ) -> Self::Value;\n+    fn scalar_to_backend(&self, cv: Scalar, layout: &abi::Scalar, llty: Self::Type) -> Self::Value;\n     fn from_const_alloc(\n         &self,\n-        layout: layout::TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n         alloc: &Allocation,\n-        offset: layout::Size,\n+        offset: Size,\n     ) -> PlaceRef<'tcx, Self::Value>;\n \n     fn const_ptrcast(&self, val: Self::Value, ty: Self::Type) -> Self::Value;"}, {"sha": "34be1cfdd8844c368d062fd466b3e4048bcfa06e", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,12 +1,12 @@\n use super::BackendTypes;\n use crate::mir::debuginfo::{FunctionDebugContext, VariableKind};\n-use rustc::mir;\n-use rustc::ty::layout::Size;\n-use rustc::ty::{Instance, Ty};\n use rustc_ast::ast::Name;\n use rustc_hir::def_id::CrateNum;\n+use rustc_middle::mir;\n+use rustc_middle::ty::{Instance, Ty};\n use rustc_span::{SourceFile, Span};\n use rustc_target::abi::call::FnAbi;\n+use rustc_target::abi::Size;\n \n pub trait DebugInfoMethods<'tcx>: BackendTypes {\n     fn create_vtable_metadata(&self, ty: Ty<'tcx>, vtable: Self::Value);"}, {"sha": "de63ef796138749db2cb2607e638952177728c91", "filename": "src/librustc_codegen_ssa/traits/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,7 +1,7 @@\n use super::BackendTypes;\n-use rustc::mir::mono::{Linkage, Visibility};\n-use rustc::ty::{Instance, Ty};\n use rustc_hir::def_id::DefId;\n+use rustc_middle::mir::mono::{Linkage, Visibility};\n+use rustc_middle::ty::{Instance, Ty};\n use rustc_target::abi::call::FnAbi;\n \n pub trait DeclareMethods<'tcx>: BackendTypes {"}, {"sha": "9d48e233de6558f251629bdf04641277ebfd61ff", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,6 +1,6 @@\n use super::BackendTypes;\n use crate::mir::operand::OperandRef;\n-use rustc::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n use rustc_target::abi::call::FnAbi;\n "}, {"sha": "beff9eae85929232feadbc2ae3ba5206df23442f", "filename": "src/librustc_codegen_ssa/traits/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,7 +1,7 @@\n use super::BackendTypes;\n-use rustc::mir::mono::CodegenUnit;\n-use rustc::ty::{self, Instance, Ty};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::mir::mono::CodegenUnit;\n+use rustc_middle::ty::{self, Instance, Ty};\n use rustc_session::Session;\n use std::cell::RefCell;\n use std::sync::Arc;"}, {"sha": "f4c09a33285bda34c41af67883a8a509ca4e1f1d", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -42,7 +42,7 @@ pub use self::type_::{\n };\n pub use self::write::{ModuleBufferMethods, ThinBufferMethods, WriteBackendMethods};\n \n-use rustc::ty::layout::{HasParamEnv, HasTyCtxt};\n+use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt};\n use rustc_target::spec::HasTargetSpec;\n \n use std::fmt;"}, {"sha": "a6462b358347b3111a0c009662ac9a10867452f8", "filename": "src/librustc_codegen_ssa/traits/statics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,6 +1,6 @@\n use super::BackendTypes;\n-use rustc::ty::layout::Align;\n use rustc_hir::def_id::DefId;\n+use rustc_target::abi::Align;\n \n pub trait StaticMethods: BackendTypes {\n     fn static_addr_of(&self, cv: Self::Value, align: Align, kind: Option<&str>) -> Self::Value;"}, {"sha": "703479b74bef8a9d9514a8e1c3fb4ddf24a46a6f", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -3,10 +3,11 @@ use super::Backend;\n use super::HasCodegen;\n use crate::common::TypeKind;\n use crate::mir::place::PlaceRef;\n-use rustc::ty::layout::{self, TyLayout};\n-use rustc::ty::{self, Ty};\n+use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::call::{ArgAbi, CastTarget, FnAbi, Reg};\n+use rustc_target::abi::Integer;\n \n // This depends on `Backend` and not `BackendTypes`, because consumers will probably want to use\n // `LayoutOf` or `HasTyCtxt`. This way, they don't have to add a constraint on it themselves.\n@@ -53,8 +54,8 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n         }\n     }\n \n-    fn type_from_integer(&self, i: layout::Integer) -> Self::Type {\n-        use rustc::ty::layout::Integer::*;\n+    fn type_from_integer(&self, i: Integer) -> Self::Type {\n+        use Integer::*;\n         match i {\n             I8 => self.type_i8(),\n             I16 => self.type_i16(),\n@@ -94,17 +95,17 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n impl<T> DerivedTypeMethods<'tcx> for T where Self: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {}\n \n pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n-    fn backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n+    fn backend_type(&self, layout: TyAndLayout<'tcx>) -> Self::Type;\n     fn cast_backend_type(&self, ty: &CastTarget) -> Self::Type;\n     fn fn_ptr_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn reg_backend_type(&self, ty: &Reg) -> Self::Type;\n-    fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n-    fn is_backend_immediate(&self, layout: TyLayout<'tcx>) -> bool;\n-    fn is_backend_scalar_pair(&self, layout: TyLayout<'tcx>) -> bool;\n-    fn backend_field_index(&self, layout: TyLayout<'tcx>, index: usize) -> u64;\n+    fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> Self::Type;\n+    fn is_backend_immediate(&self, layout: TyAndLayout<'tcx>) -> bool;\n+    fn is_backend_scalar_pair(&self, layout: TyAndLayout<'tcx>) -> bool;\n+    fn backend_field_index(&self, layout: TyAndLayout<'tcx>, index: usize) -> u64;\n     fn scalar_pair_element_backend_type(\n         &self,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n         index: usize,\n         immediate: bool,\n     ) -> Self::Type;"}, {"sha": "27d52e9b9c53e8ab524f192c7bee41b70ea77601", "filename": "src/librustc_codegen_ssa/traits/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2,8 +2,8 @@ use crate::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n use crate::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n use crate::{CompiledModule, ModuleCodegen};\n \n-use rustc::dep_graph::WorkProduct;\n use rustc_errors::{FatalError, Handler};\n+use rustc_middle::dep_graph::WorkProduct;\n \n pub trait WriteBackendMethods: 'static + Sized + Clone {\n     type Module: Send + Sync;"}, {"sha": "ba82e58d7a92e6f583254f38552458ade2e4d3b8", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -114,6 +114,6 @@ impl<F: Fn()> Drop for OnDrop<F> {\n     }\n }\n \n-// See comments in src/librustc/lib.rs\n+// See comments in src/librustc_middle/lib.rs\n #[doc(hidden)]\n pub fn __noop_fix_for_27438() {}"}, {"sha": "652f16c2e08285a2c2abc7c5dc6daa59eac486bc", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -13,7 +13,7 @@ crate-type = [\"dylib\"]\n lazy_static = \"1.0\"\n log = \"0.4\"\n env_logger = { version = \"0.7\", default-features = false }\n-rustc = { path = \"../librustc\" }\n+rustc_middle = { path = \"../librustc_middle\" }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_lint = { path = \"../librustc_lint\" }"}, {"sha": "ccbce01d6c12e61b2e2e8b1ae603b7c975483c6e", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -18,23 +18,20 @@ extern crate lazy_static;\n \n pub extern crate rustc_plugin_impl as plugin;\n \n-use rustc::middle::cstore::MetadataLoader;\n-use rustc::ty::TyCtxt;\n-use rustc::util::common::ErrorReported;\n use rustc_ast::ast;\n use rustc_codegen_ssa::{traits::CodegenBackend, CodegenResults};\n use rustc_data_structures::profiling::print_time_passes_entry;\n use rustc_data_structures::sync::SeqCst;\n-use rustc_errors::{\n-    registry::{InvalidErrorCode, Registry},\n-    PResult,\n-};\n+use rustc_errors::registry::{InvalidErrorCode, Registry};\n+use rustc_errors::{ErrorReported, PResult};\n use rustc_feature::{find_gated_cfg, UnstableFeatures};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_interface::util::{collect_crate_types, get_builtin_codegen_backend};\n use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n use rustc_metadata::locator;\n+use rustc_middle::middle::cstore::MetadataLoader;\n+use rustc_middle::ty::TyCtxt;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n use rustc_serialize::json::{self, ToJson};"}, {"sha": "78a271810b2881925e3ae0a8592838b23e9dc316", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,13 +1,13 @@\n //! The various pretty-printing routines.\n \n-use rustc::hir::map as hir_map;\n-use rustc::ty::{self, TyCtxt};\n-use rustc::util::common::ErrorReported;\n use rustc_ast::ast;\n use rustc_ast_pretty::pprust;\n+use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_hir_pretty as pprust_hir;\n+use rustc_middle::hir::map as hir_map;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_mir::util::{write_mir_graphviz, write_mir_pretty};\n use rustc_session::config::{Input, PpMode, PpSourceMode};\n use rustc_session::Session;\n@@ -177,9 +177,8 @@ impl<'hir> PrinterSupport for IdentifiedAnnotation<'hir> {\n \n impl<'hir> pprust::PpAnn for IdentifiedAnnotation<'hir> {\n     fn pre(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) {\n-        match node {\n-            pprust::AnnNode::Expr(_) => s.popen(),\n-            _ => {}\n+        if let pprust::AnnNode::Expr(_) = node {\n+            s.popen();\n         }\n     }\n     fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) {\n@@ -232,9 +231,8 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n         }\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n-        match node {\n-            pprust_hir::AnnNode::Expr(_) => s.popen(),\n-            _ => {}\n+        if let pprust_hir::AnnNode::Expr(_) = node {\n+            s.popen();\n         }\n     }\n     fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n@@ -339,21 +337,17 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n         self.tables.set(old_tables);\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n-        match node {\n-            pprust_hir::AnnNode::Expr(_) => s.popen(),\n-            _ => {}\n+        if let pprust_hir::AnnNode::Expr(_) = node {\n+            s.popen();\n         }\n     }\n     fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n-        match node {\n-            pprust_hir::AnnNode::Expr(expr) => {\n-                s.s.space();\n-                s.s.word(\"as\");\n-                s.s.space();\n-                s.s.word(self.tables.get().expr_ty(expr).to_string());\n-                s.pclose();\n-            }\n-            _ => {}\n+        if let pprust_hir::AnnNode::Expr(expr) = node {\n+            s.s.space();\n+            s.s.word(\"as\");\n+            s.s.space();\n+            s.s.word(self.tables.get().expr_ty(expr).to_string());\n+            s.pclose();\n         }\n     }\n }"}, {"sha": "6e690655f60c57409196d623a9df612a6c511dbf", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -119,6 +119,7 @@ E0222: include_str!(\"./error_codes/E0222.md\"),\n E0223: include_str!(\"./error_codes/E0223.md\"),\n E0224: include_str!(\"./error_codes/E0224.md\"),\n E0225: include_str!(\"./error_codes/E0225.md\"),\n+E0226: include_str!(\"./error_codes/E0226.md\"),\n E0229: include_str!(\"./error_codes/E0229.md\"),\n E0230: include_str!(\"./error_codes/E0230.md\"),\n E0231: include_str!(\"./error_codes/E0231.md\"),\n@@ -475,7 +476,6 @@ E0751: include_str!(\"./error_codes/E0751.md\"),\n //  E0217, // ambiguous associated type, defined in multiple supertraits\n //  E0218, // no associated type defined\n //  E0219, // associated type defined in higher-ranked supertrait\n-    E0226, // only a single explicit lifetime bound is permitted\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required\n     E0228, // explicit lifetime bound required\n //  E0233,"}, {"sha": "4e65132ff0d69742126a1a74c708163925067d00", "filename": "src/librustc_error_codes/error_codes/E0226.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0226.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0226.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0226.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -0,0 +1,21 @@\n+More than one explicit lifetime bound was used on a trait object.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0226\n+trait Foo {}\n+\n+type T<'a, 'b> = dyn Foo + 'a + 'b; // error: Trait object `arg` has two\n+                                    //        lifetime bound, 'a and 'b.\n+```\n+\n+Here `T` is a trait object with two explicit lifetime bounds, 'a and 'b.\n+\n+Only a single explicit lifetime bound is permitted on trait objects.\n+To fix this error, consider removing one of the lifetime bounds:\n+\n+```\n+trait Foo {}\n+\n+type T<'a> = dyn Foo + 'a;\n+```"}, {"sha": "e2a27f7b10672f365669ce0b797b4f9c24f447ce", "filename": "src/librustc_error_codes/error_codes/E0264.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0264.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0264.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0264.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -12,7 +12,7 @@ extern \"C\" {\n ```\n \n A list of available external lang items is available in\n-`src/librustc/middle/weak_lang_items.rs`. Example:\n+`src/librustc_middle/middle/weak_lang_items.rs`. Example:\n \n ```\n #![feature(lang_items)]"}, {"sha": "7aefedbc0875d7dc7412e3b11c25684beb89c96a", "filename": "src/librustc_error_codes/error_codes/E0466.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0466.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0466.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0466.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,4 +1,4 @@\n-Macro import declarations were malformed.\n+Macro import declaration was malformed.\n \n Erroneous code examples:\n "}, {"sha": "cf8664718fa635404a6431a315a36a3b9052aca8", "filename": "src/librustc_error_codes/error_codes/E0468.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0468.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0468.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0468.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,4 +1,4 @@\n-A non-root module attempts to import macros from another crate.\n+A non-root module tried to import macros from another crate.\n \n Example of erroneous code:\n \n@@ -17,7 +17,7 @@ Either move the macro import to crate root or do without the foreign macros.\n This will work:\n \n ```\n-#[macro_use(debug_assert)]\n+#[macro_use(debug_assert)] // ok!\n extern crate core;\n \n mod foo {"}, {"sha": "b90c59f5807379247904c6735e6bda3357f75182", "filename": "src/librustc_error_codes/error_codes/E0502.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,5 +1,4 @@\n-This error indicates that you are trying to borrow a variable as mutable when it\n-has already been borrowed as immutable.\n+A variable already borrowed as immutable was borrowed as mutable.\n \n Erroneous code example:\n "}, {"sha": "c2a71ca5669a130b62c96eb4dd17e59d8e06acf3", "filename": "src/librustc_error_codes/error_codes/E0730.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -7,8 +7,8 @@ Example of erroneous code:\n \n fn is_123<const N: usize>(x: [u32; N]) -> bool {\n     match x {\n-        [1, 2, 3] => true, // error: cannot pattern-match on an\n-                           //        array without a fixed length\n+        [1, 2, ..] => true, // error: cannot pattern-match on an\n+                            //        array without a fixed length\n         _ => false\n     }\n }"}, {"sha": "3a7e108ddafa79e64bbd32bc9b7f29d01da31888", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1719,40 +1719,36 @@ impl EmitterWriter {\n                 if !self.short_message {\n                     for child in children {\n                         let span = child.render_span.as_ref().unwrap_or(&child.span);\n-                        match self.emit_message_default(\n+                        if let Err(err) = self.emit_message_default(\n                             &span,\n                             &child.styled_message(),\n                             &None,\n                             &child.level,\n                             max_line_num_len,\n                             true,\n                         ) {\n-                            Err(e) => panic!(\"failed to emit error: {}\", e),\n-                            _ => (),\n+                            panic!(\"failed to emit error: {}\", err);\n                         }\n                     }\n                     for sugg in suggestions {\n                         if sugg.style == SuggestionStyle::CompletelyHidden {\n                             // do not display this suggestion, it is meant only for tools\n                         } else if sugg.style == SuggestionStyle::HideCodeAlways {\n-                            match self.emit_message_default(\n+                            if let Err(e) = self.emit_message_default(\n                                 &MultiSpan::new(),\n                                 &[(sugg.msg.to_owned(), Style::HeaderMsg)],\n                                 &None,\n                                 &Level::Help,\n                                 max_line_num_len,\n                                 true,\n                             ) {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => (),\n+                                panic!(\"failed to emit error: {}\", e);\n                             }\n-                        } else {\n-                            match self.emit_suggestion_default(sugg, &Level::Help, max_line_num_len)\n-                            {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => (),\n-                            }\n-                        }\n+                        } else if let Err(e) =\n+                            self.emit_suggestion_default(sugg, &Level::Help, max_line_num_len)\n+                        {\n+                            panic!(\"failed to emit error: {}\", e);\n+                        };\n                     }\n                 }\n             }\n@@ -1762,10 +1758,11 @@ impl EmitterWriter {\n         let mut dst = self.dst.writable();\n         match writeln!(dst) {\n             Err(e) => panic!(\"failed to emit error: {}\", e),\n-            _ => match dst.flush() {\n-                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                _ => (),\n-            },\n+            _ => {\n+                if let Err(e) = dst.flush() {\n+                    panic!(\"failed to emit error: {}\", e)\n+                }\n+            }\n         }\n     }\n }\n@@ -2149,11 +2146,8 @@ impl<'a> Write for WritableDst<'a> {\n \n impl<'a> Drop for WritableDst<'a> {\n     fn drop(&mut self) {\n-        match *self {\n-            WritableDst::Buffered(ref mut dst, ref mut buf) => {\n-                drop(dst.print(buf));\n-            }\n-            _ => {}\n+        if let WritableDst::Buffered(ref mut dst, ref mut buf) = self {\n+            drop(dst.print(buf));\n         }\n     }\n }"}, {"sha": "204fea58c955f930305a5970831c31f098eff552", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -425,7 +425,7 @@ impl Handler {\n     }\n \n     // This is here to not allow mutation of flags;\n-    // as of this writing it's only used in tests in librustc.\n+    // as of this writing it's only used in tests in librustc_middle.\n     pub fn can_emit_warnings(&self) -> bool {\n         self.flags.can_emit_warnings\n     }"}, {"sha": "7d2c4fbf7af32ea65cffe9354ea647848fe0ecdb", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -354,20 +354,19 @@ fn generic_extension<'cx>(\n                 mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n                 _ => continue,\n             };\n-            match parse_tt(&mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())), lhs_tt) {\n-                Success(_) => {\n-                    if comma_span.is_dummy() {\n-                        err.note(\"you might be missing a comma\");\n-                    } else {\n-                        err.span_suggestion_short(\n-                            comma_span,\n-                            \"missing comma here\",\n-                            \", \".to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+            if let Success(_) =\n+                parse_tt(&mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())), lhs_tt)\n+            {\n+                if comma_span.is_dummy() {\n+                    err.note(\"you might be missing a comma\");\n+                } else {\n+                    err.span_suggestion_short(\n+                        comma_span,\n+                        \"missing comma here\",\n+                        \", \".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n-                _ => {}\n             }\n         }\n     }"}, {"sha": "e4975aae6b9837e65ec767b56574c0b1601dc461", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -220,7 +220,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ABI, linking, symbols, and FFI\n     ungated!(\n         link, Whitelisted,\n-        template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ cfg = \"...\"\"#),\n+        template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ wasm_import_module = \"...\"\"#),\n     ),\n     ungated!(link_name, Whitelisted, template!(NameValueStr: \"name\")),\n     ungated!(no_link, Normal, template!(Word)),"}, {"sha": "c8f3edcbda0d9d7dea20c73c82d9f42108f64cbc", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -119,7 +119,7 @@ impl<'a> FnKind<'a> {\n     }\n }\n \n-/// An abstract representation of the HIR `rustc::hir::map::Map`.\n+/// An abstract representation of the HIR `rustc_middle::hir::map::Map`.\n pub trait Map<'hir> {\n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     fn find(&self, hir_id: HirId) -> Option<Node<'hir>>;"}, {"sha": "1d3f44a08993aad0cd542c6857ffc9f7e9f5b5a3", "filename": "src/librustc_hir/stable_hash_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_hir%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_hir%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fstable_hash_impls.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -9,7 +9,7 @@ use rustc_span::def_id::{DefPathHash, LocalDefId};\n \n /// Requirements for a `StableHashingContext` to be used in this crate.\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n-/// instead of implementing everything in librustc.\n+/// instead of implementing everything in librustc_middle.\n pub trait HashStableContext:\n     rustc_ast::HashStableContext + rustc_target::HashStableContext\n {"}, {"sha": "8ba14ab5d0b5a7e11e36ee593f13bf1e38317cf7", "filename": "src/librustc_hir_pretty/lib.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2036,13 +2036,10 @@ impl<'a> State<'a> {\n             }\n             GenericParamKind::Type { ref default, .. } => {\n                 self.print_bounds(\":\", param.bounds);\n-                match default {\n-                    Some(default) => {\n-                        self.s.space();\n-                        self.word_space(\"=\");\n-                        self.print_type(&default)\n-                    }\n-                    _ => {}\n+                if let Some(default) = default {\n+                    self.s.space();\n+                    self.word_space(\"=\");\n+                    self.print_type(&default)\n                 }\n             }\n             GenericParamKind::Const { ref ty } => {\n@@ -2145,9 +2142,8 @@ impl<'a> State<'a> {\n         }\n         self.end();\n \n-        match decl.output {\n-            hir::FnRetTy::Return(ref output) => self.maybe_print_comment(output.span.lo()),\n-            _ => {}\n+        if let hir::FnRetTy::Return(ref output) = decl.output {\n+            self.maybe_print_comment(output.span.lo())\n         }\n     }\n \n@@ -2222,12 +2218,9 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_extern_opt_abi(&mut self, opt_abi: Option<Abi>) {\n-        match opt_abi {\n-            Some(abi) => {\n-                self.word_nbsp(\"extern\");\n-                self.word_nbsp(abi.to_string())\n-            }\n-            None => {}\n+        if let Some(abi) = opt_abi {\n+            self.word_nbsp(\"extern\");\n+            self.word_nbsp(abi.to_string())\n         }\n     }\n "}, {"sha": "5caf1d411e637b874335bdb02656af870556bfa5", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -13,7 +13,7 @@ doctest = false\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n rand = \"0.7\"\n-rustc = { path = \"../librustc\" }\n+rustc_middle = { path = \"../librustc_middle\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }"}, {"sha": "5135820ac507f64aab753a539bb114b00e7c3ebd", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -34,16 +34,16 @@\n //! ```\n \n use graphviz as dot;\n-use rustc::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n-use rustc::dep_graph::{DepGraphQuery, DepKind, DepNode, DepNodeExt};\n-use rustc::hir::map::Map;\n-use rustc::ty::TyCtxt;\n use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{Direction, NodeIndex, INCOMING, OUTGOING};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_middle::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n+use rustc_middle::dep_graph::{DepGraphQuery, DepKind, DepNode, DepNodeExt};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n "}, {"sha": "856edb3725a93d13a174c9e818647ff715b992e9", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -21,10 +21,10 @@\n //! allows for doing a more fine-grained check to see if pre- or post-lto data\n //! was re-used.\n \n-use rustc::mir::mono::CodegenUnitNameBuilder;\n-use rustc::ty::TyCtxt;\n use rustc_ast::ast;\n use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_middle::mir::mono::CodegenUnitNameBuilder;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::cgu_reuse_tracker::*;\n use rustc_span::symbol::{sym, Symbol};\n use std::collections::BTreeSet;"}, {"sha": "dd715c6c81d56a94d5a9369d5e9bae0fe73d3f31", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -6,7 +6,7 @@\n #![recursion_limit = \"256\"]\n \n #[macro_use]\n-extern crate rustc;\n+extern crate rustc_middle;\n #[macro_use]\n extern crate log;\n "}, {"sha": "ea0fd4eb7ee737b96d29fd07d9d2d844ecfa782a", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,6 +1,6 @@\n //! The data that we will serialize and deserialize.\n \n-use rustc::dep_graph::{WorkProduct, WorkProductId};\n+use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedWorkProduct {"}, {"sha": "804d1744d687296f874f57442ab33c3d409a56c1", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -13,9 +13,6 @@\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n \n-use rustc::dep_graph::{label_strs, DepNode, DepNodeExt};\n-use rustc::hir::map::Map;\n-use rustc::ty::TyCtxt;\n use rustc_ast::ast::{self, Attribute, NestedMetaItem};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashSet;\n@@ -25,6 +22,9 @@ use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::Node as HirNode;\n use rustc_hir::{ImplItemKind, ItemKind as HirItem, TraitItemKind};\n+use rustc_middle::dep_graph::{label_strs, DepNode, DepNodeExt};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use std::iter::FromIterator;\n@@ -306,7 +306,7 @@ impl DirtyCleanVisitor<'tcx> {\n                     // michaelwoerister and vitiral came up with a possible solution,\n                     // to just do this before every query\n                     // ```\n-                    // ::rustc::ty::query::plumbing::force_from_dep_node(tcx, dep_node)\n+                    // ::rustc_middle::ty::query::plumbing::force_from_dep_node(tcx, dep_node)\n                     // ```\n                     //\n                     // However, this did not seem to work effectively and more bugs were hit."}, {"sha": "b75a428c62a091f15199008d0916628d91232410", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,9 +1,9 @@\n //! Code to save/load the dep-graph from files.\n \n-use rustc::dep_graph::{PreviousDepGraph, SerializedDepGraph, WorkProduct, WorkProductId};\n-use rustc::ty::query::OnDiskCache;\n-use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::dep_graph::{PreviousDepGraph, SerializedDepGraph, WorkProduct, WorkProductId};\n+use rustc_middle::ty::query::OnDiskCache;\n+use rustc_middle::ty::TyCtxt;\n use rustc_serialize::opaque::Decoder;\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_session::Session;"}, {"sha": "6d4ba45c2e6ed8b89e54824aac5f33525710a8ab", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,7 +1,7 @@\n-use rustc::dep_graph::{DepGraph, DepKind, WorkProduct, WorkProductId};\n-use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::join;\n+use rustc_middle::dep_graph::{DepGraph, DepKind, WorkProduct, WorkProductId};\n+use rustc_middle::ty::TyCtxt;\n use rustc_serialize::opaque::Encoder;\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_session::Session;"}, {"sha": "4dd81b1df5759eb94999ef9fad437800d510eb7f", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,8 +1,8 @@\n //! This module contains files for saving intermediate work-products.\n \n use crate::persist::fs::*;\n-use rustc::dep_graph::{WorkProduct, WorkProductFileKind, WorkProductId};\n use rustc_fs_util::link_or_copy;\n+use rustc_middle::dep_graph::{WorkProduct, WorkProductFileKind, WorkProductId};\n use rustc_session::Session;\n use std::fs as std_fs;\n use std::path::PathBuf;"}, {"sha": "bc4080ac6c8de59bb9614566c5c887c4daaa026e", "filename": "src/librustc_infer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2FCargo.toml?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -12,7 +12,7 @@ doctest = false\n [dependencies]\n graphviz = { path = \"../libgraphviz\" }\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n-rustc = { path = \"../librustc\" }\n+rustc_middle = { path = \"../librustc_middle\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }"}, {"sha": "5c62a1298b97b371da3ac53d482dce823e8576b7", "filename": "src/librustc_infer/infer/at.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fat.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -27,8 +27,8 @@\n \n use super::*;\n \n-use rustc::ty::relate::{Relate, TypeRelation};\n-use rustc::ty::Const;\n+use rustc_middle::ty::relate::{Relate, TypeRelation};\n+use rustc_middle::ty::Const;\n \n pub struct At<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,"}, {"sha": "347a5ff6d56a41736a1bcd3d697bf785fa57e28a", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -10,10 +10,10 @@ use crate::infer::canonical::{\n     OriginalQueryValues,\n };\n use crate::infer::InferCtxt;\n-use rustc::ty::flags::FlagComputation;\n-use rustc::ty::fold::{TypeFoldable, TypeFolder};\n-use rustc::ty::subst::GenericArg;\n-use rustc::ty::{self, BoundVar, InferConst, List, Ty, TyCtxt, TypeFlags};\n+use rustc_middle::ty::flags::FlagComputation;\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc_middle::ty::subst::GenericArg;\n+use rustc_middle::ty::{self, BoundVar, InferConst, List, Ty, TyCtxt, TypeFlags};\n use std::sync::atomic::Ordering;\n \n use rustc_data_structures::fx::FxHashMap;"}, {"sha": "b7890cf9e925a8bf6170fc9f234e28b1de7da337", "filename": "src/librustc_infer/infer/canonical/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -23,13 +23,13 @@\n \n use crate::infer::{ConstVariableOrigin, ConstVariableOriginKind};\n use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::GenericArg;\n-use rustc::ty::{self, BoundVar, List};\n use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::subst::GenericArg;\n+use rustc_middle::ty::{self, BoundVar, List};\n use rustc_span::source_map::Span;\n \n-pub use rustc::infer::canonical::*;\n+pub use rustc_middle::infer::canonical::*;\n use substitute::CanonicalExt;\n \n mod canonicalizer;"}, {"sha": "79a0a5076241f96d1ee8b4cc33bfffb70fe0c7f5", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -18,14 +18,14 @@ use crate::infer::{InferCtxt, InferOk, InferResult, NLLRegionVariableOrigin};\n use crate::traits::query::{Fallible, NoSolution};\n use crate::traits::{DomainGoal, TraitEngine};\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n-use rustc::arena::ArenaAllocatable;\n-use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::relate::TypeRelation;\n-use rustc::ty::subst::{GenericArg, GenericArgKind};\n-use rustc::ty::{self, BoundVar, Ty, TyCtxt};\n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::arena::ArenaAllocatable;\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::relate::TypeRelation;\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n+use rustc_middle::ty::{self, BoundVar, Ty, TyCtxt};\n use std::fmt::Debug;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {"}, {"sha": "55609c080acc16a24c25b12300328ce1a0d32557", "filename": "src/librustc_infer/infer/canonical/substitute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -7,9 +7,9 @@\n //! [c]: https://rustc-dev-guide.rust-lang.org/traits/canonicalization.html\n \n use crate::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::GenericArgKind;\n-use rustc::ty::{self, TyCtxt};\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{self, TyCtxt};\n \n pub(super) trait CanonicalExt<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value"}, {"sha": "c630f58abf9855174ba81a26a131560e3fa308d6", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -34,13 +34,13 @@ use super::{InferCtxt, MiscVariable, TypeTrace};\n \n use crate::traits::{Obligation, PredicateObligations};\n \n-use rustc::ty::error::TypeError;\n-use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{self, InferConst, Ty, TyCtxt};\n-use rustc::ty::{IntType, UintType};\n use rustc_ast::ast;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n+use rustc_middle::ty::{IntType, UintType};\n use rustc_span::{Span, DUMMY_SP};\n \n #[derive(Clone)]"}, {"sha": "e05094cda2762a76d20824539f574581bc3e2b42", "filename": "src/librustc_infer/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fequate.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,10 +1,10 @@\n use super::combine::{CombineFields, RelationDir};\n use super::Subtype;\n \n-use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc::ty::subst::SubstsRef;\n-use rustc::ty::TyVar;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::TyVar;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n \n use rustc_hir::def_id::DefId;\n "}, {"sha": "925f92edd7da9cd3e1b0a688728d63db4e213125", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 84, "deletions": 92, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -55,19 +55,19 @@ use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n };\n \n-use rustc::middle::region;\n-use rustc::ty::error::TypeError;\n-use rustc::ty::{\n-    self,\n-    subst::{Subst, SubstsRef},\n-    Region, Ty, TyCtxt, TypeFoldable,\n-};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n+use rustc_middle::middle::region;\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::{\n+    self,\n+    subst::{Subst, SubstsRef},\n+    Region, Ty, TyCtxt, TypeFoldable,\n+};\n use rustc_span::{DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::{cmp, fmt};\n@@ -1386,13 +1386,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         // For some types of errors, expected-found does not make\n         // sense, so just ignore the values we were given.\n-        match terr {\n-            TypeError::CyclicTy(_) => {\n-                values = None;\n-            }\n-            _ => {}\n+        if let TypeError::CyclicTy(_) = terr {\n+            values = None;\n         }\n-\n         struct OpaqueTypesVisitor<'tcx> {\n             types: FxHashMap<TyCategory, FxHashSet<Span>>,\n             expected: FxHashMap<TyCategory, FxHashSet<Span>>,\n@@ -1613,60 +1609,57 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n         diag: &mut DiagnosticBuilder<'tcx>,\n     ) {\n-        match (&exp_found.expected.kind, &exp_found.found.kind) {\n-            (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) => {\n-                if let ty::Adt(found_def, found_substs) = found_ty.kind {\n-                    let path_str = format!(\"{:?}\", exp_def);\n-                    if exp_def == &found_def {\n-                        let opt_msg = \"you can convert from `&Option<T>` to `Option<&T>` using \\\n+        if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n+            (&exp_found.expected.kind, &exp_found.found.kind)\n+        {\n+            if let ty::Adt(found_def, found_substs) = found_ty.kind {\n+                let path_str = format!(\"{:?}\", exp_def);\n+                if exp_def == &found_def {\n+                    let opt_msg = \"you can convert from `&Option<T>` to `Option<&T>` using \\\n                                        `.as_ref()`\";\n-                        let result_msg = \"you can convert from `&Result<T, E>` to \\\n+                    let result_msg = \"you can convert from `&Result<T, E>` to \\\n                                           `Result<&T, &E>` using `.as_ref()`\";\n-                        let have_as_ref = &[\n-                            (\"std::option::Option\", opt_msg),\n-                            (\"core::option::Option\", opt_msg),\n-                            (\"std::result::Result\", result_msg),\n-                            (\"core::result::Result\", result_msg),\n-                        ];\n-                        if let Some(msg) = have_as_ref\n-                            .iter()\n-                            .filter_map(\n-                                |(path, msg)| if &path_str == path { Some(msg) } else { None },\n-                            )\n-                            .next()\n-                        {\n-                            let mut show_suggestion = true;\n-                            for (exp_ty, found_ty) in exp_substs.types().zip(found_substs.types()) {\n-                                match exp_ty.kind {\n-                                    ty::Ref(_, exp_ty, _) => {\n-                                        match (&exp_ty.kind, &found_ty.kind) {\n-                                            (_, ty::Param(_))\n-                                            | (_, ty::Infer(_))\n-                                            | (ty::Param(_), _)\n-                                            | (ty::Infer(_), _) => {}\n-                                            _ if ty::TyS::same_type(exp_ty, found_ty) => {}\n-                                            _ => show_suggestion = false,\n-                                        };\n-                                    }\n-                                    ty::Param(_) | ty::Infer(_) => {}\n-                                    _ => show_suggestion = false,\n+                    let have_as_ref = &[\n+                        (\"std::option::Option\", opt_msg),\n+                        (\"core::option::Option\", opt_msg),\n+                        (\"std::result::Result\", result_msg),\n+                        (\"core::result::Result\", result_msg),\n+                    ];\n+                    if let Some(msg) = have_as_ref\n+                        .iter()\n+                        .filter_map(|(path, msg)| if &path_str == path { Some(msg) } else { None })\n+                        .next()\n+                    {\n+                        let mut show_suggestion = true;\n+                        for (exp_ty, found_ty) in exp_substs.types().zip(found_substs.types()) {\n+                            match exp_ty.kind {\n+                                ty::Ref(_, exp_ty, _) => {\n+                                    match (&exp_ty.kind, &found_ty.kind) {\n+                                        (_, ty::Param(_))\n+                                        | (_, ty::Infer(_))\n+                                        | (ty::Param(_), _)\n+                                        | (ty::Infer(_), _) => {}\n+                                        _ if ty::TyS::same_type(exp_ty, found_ty) => {}\n+                                        _ => show_suggestion = false,\n+                                    };\n                                 }\n-                            }\n-                            if let (Ok(snippet), true) =\n-                                (self.tcx.sess.source_map().span_to_snippet(span), show_suggestion)\n-                            {\n-                                diag.span_suggestion(\n-                                    span,\n-                                    msg,\n-                                    format!(\"{}.as_ref()\", snippet),\n-                                    Applicability::MachineApplicable,\n-                                );\n+                                ty::Param(_) | ty::Infer(_) => {}\n+                                _ => show_suggestion = false,\n                             }\n                         }\n+                        if let (Ok(snippet), true) =\n+                            (self.tcx.sess.source_map().span_to_snippet(span), show_suggestion)\n+                        {\n+                            diag.span_suggestion(\n+                                span,\n+                                msg,\n+                                format!(\"{}.as_ref()\", snippet),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n                     }\n                 }\n             }\n-            _ => {}\n         }\n     }\n \n@@ -1955,42 +1948,41 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             \"...\",\n         );\n \n-        match (&sup_origin, &sub_origin) {\n-            (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) => {\n-                debug!(\"report_sub_sup_conflict: var_origin={:?}\", var_origin);\n-                debug!(\"report_sub_sup_conflict: sub_region={:?}\", sub_region);\n-                debug!(\"report_sub_sup_conflict: sub_origin={:?}\", sub_origin);\n-                debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n-                debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n-                debug!(\"report_sub_sup_conflict: sup_trace={:?}\", sup_trace);\n-                debug!(\"report_sub_sup_conflict: sub_trace={:?}\", sub_trace);\n-                debug!(\"report_sub_sup_conflict: sup_trace.values={:?}\", sup_trace.values);\n-                debug!(\"report_sub_sup_conflict: sub_trace.values={:?}\", sub_trace.values);\n-\n-                if let (Some((sup_expected, sup_found)), Some((sub_expected, sub_found))) =\n-                    (self.values_str(&sup_trace.values), self.values_str(&sub_trace.values))\n-                {\n-                    if sub_expected == sup_expected && sub_found == sup_found {\n-                        note_and_explain_region(\n-                            self.tcx,\n-                            region_scope_tree,\n-                            &mut err,\n-                            \"...but the lifetime must also be valid for \",\n-                            sub_region,\n-                            \"...\",\n-                        );\n-                        err.span_note(\n-                            sup_trace.cause.span,\n-                            &format!(\"...so that the {}\", sup_trace.cause.as_requirement_str()),\n-                        );\n+        if let (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) =\n+            (&sup_origin, &sub_origin)\n+        {\n+            debug!(\"report_sub_sup_conflict: var_origin={:?}\", var_origin);\n+            debug!(\"report_sub_sup_conflict: sub_region={:?}\", sub_region);\n+            debug!(\"report_sub_sup_conflict: sub_origin={:?}\", sub_origin);\n+            debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n+            debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n+            debug!(\"report_sub_sup_conflict: sup_trace={:?}\", sup_trace);\n+            debug!(\"report_sub_sup_conflict: sub_trace={:?}\", sub_trace);\n+            debug!(\"report_sub_sup_conflict: sup_trace.values={:?}\", sup_trace.values);\n+            debug!(\"report_sub_sup_conflict: sub_trace.values={:?}\", sub_trace.values);\n+\n+            if let (Some((sup_expected, sup_found)), Some((sub_expected, sub_found))) =\n+                (self.values_str(&sup_trace.values), self.values_str(&sub_trace.values))\n+            {\n+                if sub_expected == sup_expected && sub_found == sup_found {\n+                    note_and_explain_region(\n+                        self.tcx,\n+                        region_scope_tree,\n+                        &mut err,\n+                        \"...but the lifetime must also be valid for \",\n+                        sub_region,\n+                        \"...\",\n+                    );\n+                    err.span_note(\n+                        sup_trace.cause.span,\n+                        &format!(\"...so that the {}\", sup_trace.cause.as_requirement_str()),\n+                    );\n \n-                        err.note_expected_found(&\"\", sup_expected, &\"\", sup_found);\n-                        err.emit();\n-                        return;\n-                    }\n+                    err.note_expected_found(&\"\", sup_expected, &\"\", sup_found);\n+                    err.emit();\n+                    return;\n                 }\n             }\n-            _ => {}\n         }\n \n         self.note_region_origin(&mut err, &sup_origin);"}, {"sha": "7824855fe057c7360e9f41e101dc1115aadf0893", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,13 +1,13 @@\n use crate::infer::type_variable::TypeVariableOriginKind;\n use crate::infer::InferCtxt;\n-use rustc::hir::map::Map;\n-use rustc::ty::print::Print;\n-use rustc::ty::{self, DefIdTree, Infer, Ty, TyVar};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Body, Expr, ExprKind, FnRetTy, HirId, Local, Pat};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::print::Print;\n+use rustc_middle::ty::{self, DefIdTree, Infer, Ty, TyVar};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::kw;\n use rustc_span::Span;"}, {"sha": "d206a30d526cb7550d352c636160feabd9f1499b", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -5,9 +5,8 @@ use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::SubregionOrigin;\n-use rustc::util::common::ErrorReported;\n \n-use rustc_errors::struct_span_err;\n+use rustc_errors::{struct_span_err, ErrorReported};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous."}, {"sha": "53cab34cd3f176906b331cc49021f2d1ea16f32e", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,10 +1,10 @@\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc::hir::map::Map;\n-use rustc::middle::resolve_lifetime as rl;\n-use rustc::ty::{self, Region, TyCtxt};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::Node;\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::middle::resolve_lifetime as rl;\n+use rustc_middle::ty::{self, Region, TyCtxt};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// This function calls the `visit_ty` method for the parameters"}, {"sha": "2aed3d9a469fb82704b9e120d72c8885e4e2fc79", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,9 +1,8 @@\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError::*;\n use crate::infer::InferCtxt;\n-use rustc::ty::{self, TyCtxt};\n-use rustc::util::common::ErrorReported;\n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::{DiagnosticBuilder, ErrorReported};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::source_map::Span;\n \n mod different_lifetimes;"}, {"sha": "b85a4cae2e47036b3bb967c129ebe5536af581e2", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,9 +1,9 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc::ty;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir::{FnRetTy, TyKind};\n+use rustc_middle::ty;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with parameters containing a named region and"}, {"sha": "70c302710430b607ea413d77e46e88f151ce39f7", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -4,9 +4,9 @@\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n use crate::infer::SubregionOrigin;\n-use rustc::ty::RegionKind;\n-use rustc::util::common::ErrorReported;\n+use rustc_errors::ErrorReported;\n use rustc_hir::{Expr, ExprKind::Closure, Node};\n+use rustc_middle::ty::RegionKind;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when binding escapes a closure."}, {"sha": "2187064ec5ecf9e5b7dc1ca9b77777cd97a328df", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -3,13 +3,13 @@ use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::ValuePairs;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCause, ObligationCauseCode};\n-use rustc::ty::error::ExpectedFound;\n-use rustc::ty::print::{FmtPrinter, Print, RegionHighlightMode};\n-use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{self, TyCtxt};\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::print::{FmtPrinter, Print, RegionHighlightMode};\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{self, TyCtxt};\n \n use std::fmt::{self, Write};\n "}, {"sha": "7f3ec852e41de53ceb3b9f657e3553351d761116", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -3,9 +3,8 @@\n use crate::infer::error_reporting::msg_span_from_free_region;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use rustc::ty::{BoundRegion, FreeRegion, RegionKind};\n-use rustc::util::common::ErrorReported;\n-use rustc_errors::Applicability;\n+use rustc_errors::{Applicability, ErrorReported};\n+use rustc_middle::ty::{BoundRegion, FreeRegion, RegionKind};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait."}, {"sha": "695f3e47fb5d7b18643b6b2e85bb4c903fc1ccb2", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -4,8 +4,8 @@ use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{Subtype, ValuePairs};\n use crate::traits::ObligationCauseCode::CompareImplMethodObligation;\n-use rustc::ty::Ty;\n-use rustc::util::common::ErrorReported;\n+use rustc_errors::ErrorReported;\n+use rustc_middle::ty::Ty;\n use rustc_span::Span;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n@@ -22,26 +22,25 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 _sup,\n             ) = error.clone()\n             {\n-                match (&sup_origin, &sub_origin) {\n-                    (&Subtype(ref sup_trace), &Subtype(ref sub_trace)) => {\n-                        if let (\n-                            ValuePairs::Types(sub_expected_found),\n-                            ValuePairs::Types(sup_expected_found),\n-                            CompareImplMethodObligation { trait_item_def_id, .. },\n-                        ) = (&sub_trace.values, &sup_trace.values, &sub_trace.cause.code)\n-                        {\n-                            if sup_expected_found == sub_expected_found {\n-                                self.emit_err(\n-                                    var_origin.span(),\n-                                    sub_expected_found.expected,\n-                                    sub_expected_found.found,\n-                                    self.tcx().def_span(*trait_item_def_id),\n-                                );\n-                                return Some(ErrorReported);\n-                            }\n+                if let (&Subtype(ref sup_trace), &Subtype(ref sub_trace)) =\n+                    (&sup_origin, &sub_origin)\n+                {\n+                    if let (\n+                        ValuePairs::Types(sub_expected_found),\n+                        ValuePairs::Types(sup_expected_found),\n+                        CompareImplMethodObligation { trait_item_def_id, .. },\n+                    ) = (&sub_trace.values, &sup_trace.values, &sub_trace.cause.code)\n+                    {\n+                        if sup_expected_found == sub_expected_found {\n+                            self.emit_err(\n+                                var_origin.span(),\n+                                sub_expected_found.expected,\n+                                sub_expected_found.found,\n+                                self.tcx().def_span(*trait_item_def_id),\n+                            );\n+                            return Some(ErrorReported);\n                         }\n                     }\n-                    _ => {}\n                 }\n             }\n         }"}, {"sha": "d35a589320badcbe8136922fa909fbe50ddffc1b", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2,9 +2,9 @@\n //! anonymous regions.\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc::ty::{self, DefIdTree, Region, Ty};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{self, DefIdTree, Region, Ty};\n use rustc_span::Span;\n \n // The struct contains the information about the anonymous region"}, {"sha": "81f37831af208222641c35bfbf37b6bc455fcce4", "filename": "src/librustc_infer/infer/error_reporting/note.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,9 +1,9 @@\n use crate::infer::error_reporting::{note_and_explain_region, ObligationCauseExt};\n use crate::infer::{self, InferCtxt, SubregionOrigin};\n-use rustc::middle::region;\n-use rustc::ty::error::TypeError;\n-use rustc::ty::{self, Region};\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n+use rustc_middle::middle::region;\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::{self, Region};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub(super) fn note_region_origin("}, {"sha": "eeaa4c1661e4e205393a8dcf181ae31951131535", "filename": "src/librustc_infer/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -31,8 +31,8 @@\n //! variable only once, and it does so as soon as it can, so it is reasonable to ask what the type\n //! inferencer knows \"so far\".\n \n-use rustc::ty::fold::TypeFolder;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::fold::TypeFolder;\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc_data_structures::fx::FxHashMap;\n "}, {"sha": "1a58e100fb3f4bfffb7233d9bb4b365021d7ce6a", "filename": "src/librustc_infer/infer/fudge.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffudge.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,5 +1,5 @@\n-use rustc::ty::fold::{TypeFoldable, TypeFolder};\n-use rustc::ty::{self, ConstVid, FloatVid, IntVid, RegionVid, Ty, TyCtxt, TyVid};\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc_middle::ty::{self, ConstVid, FloatVid, IntVid, RegionVid, Ty, TyCtxt, TyVid};\n \n use super::type_variable::TypeVariableOrigin;\n use super::InferCtxt;"}, {"sha": "f95d74a9340c9fbd7920f04752795e52ca05f7a6", "filename": "src/librustc_infer/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fglb.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -4,8 +4,8 @@ use super::InferCtxt;\n use super::Subtype;\n \n use crate::traits::ObligationCause;\n-use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'combine, 'infcx, 'tcx> {"}, {"sha": "ef18918c1772f7ddfccdda79da9c630d2abd7a4f", "filename": "src/librustc_infer/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -5,8 +5,8 @@ use super::combine::CombineFields;\n use super::{HigherRankedType, InferCtxt, PlaceholderMap};\n \n use crate::infer::CombinedSnapshot;\n-use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n-use rustc::ty::{self, Binder, TypeFoldable};\n+use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::{self, Binder, TypeFoldable};\n \n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     pub fn higher_ranked_sub<T>("}, {"sha": "c29614b855667b6e4950efada1854b4c58c15406", "filename": "src/librustc_infer/infer/lattice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flattice.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -23,9 +23,9 @@ use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::InferCtxt;\n \n use crate::traits::ObligationCause;\n-use rustc::ty::relate::{RelateResult, TypeRelation};\n-use rustc::ty::TyVar;\n-use rustc::ty::{self, Ty};\n+use rustc_middle::ty::relate::{RelateResult, TypeRelation};\n+use rustc_middle::ty::TyVar;\n+use rustc_middle::ty::{self, Ty};\n \n pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;"}, {"sha": "141424fc0c7819aafbdf62aaa738126eefc85c21", "filename": "src/librustc_infer/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,5 +1,5 @@\n //! This module provides linkage between libgraphviz traits and\n-//! `rustc::middle::typeck::infer::region_constraints`, generating a\n+//! `rustc_trait_selection::infer::region_constraints`, generating a\n //! rendering of the graph represented by the list of `Constraint`\n //! instances (which make up the edges of the graph), as well as the\n //! origin for each constraint (which are attached to the labels on\n@@ -11,11 +11,11 @@ use graphviz as dot;\n use super::Constraint;\n use crate::infer::region_constraints::RegionConstraintData;\n use crate::infer::SubregionOrigin;\n-use rustc::middle::free_region::RegionRelations;\n-use rustc::middle::region;\n-use rustc::ty;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::DefIndex;\n+use rustc_middle::middle::free_region::RegionRelations;\n+use rustc_middle::middle::region;\n+use rustc_middle::ty;\n \n use std::borrow::Cow;\n use std::collections::btree_map::BTreeMap;"}, {"sha": "8a73c8b880ee26b68e5ced3af951d58c9c9df9d1", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -9,17 +9,17 @@ use crate::infer::region_constraints::VerifyBound;\n use crate::infer::RegionVariableOrigin;\n use crate::infer::RegionckMode;\n use crate::infer::SubregionOrigin;\n-use rustc::middle::free_region::RegionRelations;\n-use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n-use rustc::ty::{ReLateBound, RePlaceholder, ReScope, ReVar};\n-use rustc::ty::{Region, RegionVid};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::middle::free_region::RegionRelations;\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n+use rustc_middle::ty::{ReLateBound, RePlaceholder, ReScope, ReVar};\n+use rustc_middle::ty::{Region, RegionVid};\n use rustc_span::Span;\n use std::fmt;\n "}, {"sha": "492f2b229d36d3ace1bc65d2f965d687401201b6", "filename": "src/librustc_infer/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flub.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -4,8 +4,8 @@ use super::InferCtxt;\n use super::Subtype;\n \n use crate::traits::ObligationCause;\n-use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'combine, 'infcx, 'tcx> {"}, {"sha": "edaa7a04b34d02caa60859fab828e727cd41597b", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -8,28 +8,28 @@ pub use self::ValuePairs::*;\n \n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n \n-use rustc::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc::infer::unify_key::{ConstVarValue, ConstVariableValue};\n-use rustc::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n-use rustc::middle::free_region::RegionRelations;\n-use rustc::middle::region;\n-use rustc::mir;\n-use rustc::mir::interpret::ConstEvalResult;\n-use rustc::traits::select;\n-use rustc::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use rustc::ty::fold::{TypeFoldable, TypeFolder};\n-use rustc::ty::relate::RelateResult;\n-use rustc::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n-pub use rustc::ty::IntVarValue;\n-use rustc::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n-use rustc::ty::{ConstVid, FloatVid, IntVid, TyVid};\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::unify as ut;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n+use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n+use rustc_middle::middle::free_region::RegionRelations;\n+use rustc_middle::middle::region;\n+use rustc_middle::mir;\n+use rustc_middle::mir::interpret::ConstEvalResult;\n+use rustc_middle::traits::select;\n+use rustc_middle::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc_middle::ty::relate::RelateResult;\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n+pub use rustc_middle::ty::IntVarValue;\n+use rustc_middle::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n+use rustc_middle::ty::{ConstVid, FloatVid, IntVid, TyVid};\n use rustc_session::config::BorrowckMode;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n@@ -65,7 +65,7 @@ mod sub;\n pub mod type_variable;\n \n use crate::infer::canonical::OriginalQueryValues;\n-pub use rustc::infer::unify_key;\n+pub use rustc_middle::infer::unify_key;\n \n #[must_use]\n #[derive(Debug)]\n@@ -672,8 +672,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn type_is_unconstrained_numeric(&'a self, ty: Ty<'_>) -> UnconstrainedNumeric {\n-        use rustc::ty::error::UnconstrainedNumeric::Neither;\n-        use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n+        use rustc_middle::ty::error::UnconstrainedNumeric::Neither;\n+        use rustc_middle::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n         match ty.kind {\n             ty::Infer(ty::IntVar(vid)) => {\n                 if self.inner.borrow_mut().int_unification_table.probe_value(vid).is_some() {"}, {"sha": "44bacfa80e125671a65f83207a0338ec19a0441d", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -24,12 +24,12 @@\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use crate::traits::DomainGoal;\n-use rustc::ty::error::TypeError;\n-use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n-use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc::ty::subst::GenericArg;\n-use rustc::ty::{self, InferConst, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::fold::{TypeFoldable, TypeVisitor};\n+use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::subst::GenericArg;\n+use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n use std::fmt::Debug;\n \n #[derive(PartialEq)]"}, {"sha": "38c3f0ee6ac1b57ebb48c868b5d1fed131772754", "filename": "src/librustc_infer/infer/outlives/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,9 +1,9 @@\n use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n-use rustc::ty;\n-use rustc::ty::free_region_map::FreeRegionMap;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n+use rustc_middle::ty;\n+use rustc_middle::ty::free_region_map::FreeRegionMap;\n \n use super::explicit_outlives_bounds;\n "}, {"sha": "ed3d86058696802f5fca9cc5017048cd351968ed", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -4,8 +4,8 @@ pub mod env;\n pub mod obligations;\n pub mod verify;\n \n-use rustc::traits::query::OutlivesBound;\n-use rustc::ty;\n+use rustc_middle::traits::query::OutlivesBound;\n+use rustc_middle::ty;\n \n pub fn explicit_outlives_bounds<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "e6feb5e1edcb56902ddd0d353e2f9805d7f02c75", "filename": "src/librustc_infer/infer/outlives/obligations.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fobligations.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -63,9 +63,9 @@ use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::outlives::verify::VerifyBoundCx;\n use crate::infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n use crate::traits::ObligationCause;\n-use rustc::ty::outlives::Component;\n-use rustc::ty::subst::GenericArgKind;\n-use rustc::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::outlives::Component;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;"}, {"sha": "1cd6830b6a241cca0cfefa11e139948e96aa2244", "filename": "src/librustc_infer/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,10 +1,10 @@\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::{GenericKind, VerifyBound};\n use crate::traits;\n-use rustc::ty::subst::{InternalSubsts, Subst};\n-use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::captures::Captures;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n \n use smallvec::smallvec;\n "}, {"sha": "18e86162eb5e40ac1126cb5998389dc571c2fa92", "filename": "src/librustc_infer/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,7 +1,7 @@\n use super::*;\n use crate::infer::{CombinedSnapshot, PlaceholderMap};\n-use rustc::ty::error::TypeError;\n-use rustc::ty::relate::RelateResult;\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::relate::RelateResult;\n \n impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// Searches region constraints created since `snapshot` that"}, {"sha": "e10b0938955affd93e35c732a93bb16ac50a5f8b", "filename": "src/librustc_infer/infer/region_constraints/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -6,15 +6,15 @@ use self::UndoLog::*;\n use super::unify_key;\n use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n \n-use rustc::ty::ReStatic;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::{ReLateBound, ReVar};\n-use rustc::ty::{Region, RegionVid};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::unify as ut;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::ReStatic;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{ReLateBound, ReVar};\n+use rustc_middle::ty::{Region, RegionVid};\n use rustc_span::Span;\n \n use std::collections::BTreeMap;\n@@ -23,7 +23,7 @@ use std::{cmp, fmt, mem};\n \n mod leak_check;\n \n-pub use rustc::infer::MemberConstraint;\n+pub use rustc_middle::infer::MemberConstraint;\n \n #[derive(Default)]\n pub struct RegionConstraintCollector<'tcx> {"}, {"sha": "22b90f2415540c5aa6442dd3a394813a0b589b41", "filename": "src/librustc_infer/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fresolve.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,7 +1,7 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::{FixupError, FixupResult, InferCtxt, Span};\n-use rustc::ty::fold::{TypeFolder, TypeVisitor};\n-use rustc::ty::{self, Const, InferConst, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::fold::{TypeFolder, TypeVisitor};\n+use rustc_middle::ty::{self, Const, InferConst, Ty, TyCtxt, TypeFoldable};\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC VAR RESOLVER"}, {"sha": "080af37492d89a4eb56e50ad9fd56b70fb455ef2", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2,10 +2,10 @@ use super::combine::{CombineFields, RelationDir};\n use super::SubregionOrigin;\n \n use crate::traits::Obligation;\n-use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n-use rustc::ty::TyVar;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::TyVar;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success."}, {"sha": "8e4199f0c263db333bf6c8980f2bfa1d1d5cb43b", "filename": "src/librustc_infer/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,5 +1,5 @@\n-use rustc::ty::{self, Ty, TyVid};\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{self, Ty, TyVid};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n "}, {"sha": "5dd5165b688cff21ade2422aad66fdb451c8f141", "filename": "src/librustc_infer/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -30,7 +30,7 @@ extern crate rustc_data_structures;\n #[macro_use]\n extern crate log;\n #[macro_use]\n-extern crate rustc;\n+extern crate rustc_middle;\n \n pub mod infer;\n pub mod traits;"}, {"sha": "a95257ba6820a0c737a43506ff60f4ee40118ce1", "filename": "src/librustc_infer/traits/engine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fengine.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::InferCtxt;\n use crate::traits::Obligation;\n-use rustc::ty::{self, ToPredicate, Ty, WithConstness};\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{self, ToPredicate, Ty, WithConstness};\n \n use super::FulfillmentError;\n use super::{ObligationCause, PredicateObligation};"}, {"sha": "9206166d0bd67bd6e73434137a373ea3abff6ad9", "filename": "src/librustc_infer/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,12 +1,12 @@\n use super::ObjectSafetyViolation;\n \n use crate::infer::InferCtxt;\n-use rustc::ty::TyCtxt;\n use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::Span;\n use std::fmt;\n "}, {"sha": "758a0b39d43ee21c8c8606c5f6a99c8e3a4cb66b", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -6,11 +6,11 @@ mod engine;\n pub mod error_reporting;\n mod project;\n mod structural_impls;\n-mod util;\n+pub mod util;\n \n-use rustc::ty::error::{ExpectedFound, TypeError};\n-use rustc::ty::{self, Ty};\n use rustc_hir as hir;\n+use rustc_middle::ty::error::{ExpectedFound, TypeError};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n \n pub use self::FulfillmentErrorCode::*;\n@@ -26,7 +26,7 @@ pub use self::project::{\n };\n crate use self::util::elaborate_predicates;\n \n-pub use rustc::traits::*;\n+pub use rustc_middle::traits::*;\n \n /// An `Obligation` represents some trait reference (e.g., `int: Eq`) for\n /// which the vtable must be found. The process of finding a vtable is"}, {"sha": "48375a9ddf418eba274b1d6b1339e1615018b43a", "filename": "src/librustc_infer/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2,11 +2,11 @@\n \n use super::PredicateObligation;\n \n-use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, Ty};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::{self, Ty};\n \n-pub use rustc::traits::Reveal;\n+pub use rustc_middle::traits::Reveal;\n \n #[derive(Clone)]\n pub struct MismatchedProjectionTypes<'tcx> {"}, {"sha": "595a8cd768390e5d4613e2faf211baebb8e73359", "filename": "src/librustc_infer/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,7 +1,7 @@\n use crate::traits;\n use crate::traits::project::Normalized;\n-use rustc::ty;\n-use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use rustc_middle::ty;\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::fmt;\n "}, {"sha": "4fa74f93ddcb05675785a46709636f8f78183abb", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,10 +1,13 @@\n use smallvec::smallvec;\n \n-use rustc::ty::outlives::Component;\n-use rustc::ty::{self, ToPolyTraitRef, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_middle::ty::outlives::Component;\n+use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, TyCtxt, WithConstness};\n \n-fn anonymize_predicate<'tcx>(tcx: TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+pub fn anonymize_predicate<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    pred: &ty::Predicate<'tcx>,\n+) -> ty::Predicate<'tcx> {\n     match *pred {\n         ty::Predicate::Trait(ref data, constness) => {\n             ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data), constness)\n@@ -88,6 +91,21 @@ pub struct Elaborator<'tcx> {\n     visited: PredicateSet<'tcx>,\n }\n \n+pub fn elaborate_trait_ref<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Elaborator<'tcx> {\n+    elaborate_predicates(tcx, vec![trait_ref.without_const().to_predicate()])\n+}\n+\n+pub fn elaborate_trait_refs<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Elaborator<'tcx> {\n+    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate()).collect();\n+    elaborate_predicates(tcx, predicates)\n+}\n+\n pub fn elaborate_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     mut predicates: Vec<ty::Predicate<'tcx>>,\n@@ -98,6 +116,10 @@ pub fn elaborate_predicates<'tcx>(\n }\n \n impl Elaborator<'tcx> {\n+    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n+        FilterToTraits::new(self)\n+    }\n+\n     fn elaborate(&mut self, predicate: &ty::Predicate<'tcx>) {\n         let tcx = self.visited.tcx;\n         match *predicate {\n@@ -223,3 +245,57 @@ impl Iterator for Elaborator<'tcx> {\n         }\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Supertrait iterator\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n+\n+pub fn supertraits<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Supertraits<'tcx> {\n+    elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n+}\n+\n+pub fn transitive_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Supertraits<'tcx> {\n+    elaborate_trait_refs(tcx, bounds).filter_to_traits()\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Other\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// A filter around an iterator of predicates that makes it yield up\n+/// just trait references.\n+pub struct FilterToTraits<I> {\n+    base_iterator: I,\n+}\n+\n+impl<I> FilterToTraits<I> {\n+    fn new(base: I) -> FilterToTraits<I> {\n+        FilterToTraits { base_iterator: base }\n+    }\n+}\n+\n+impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n+    type Item = ty::PolyTraitRef<'tcx>;\n+\n+    fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n+        while let Some(pred) = self.base_iterator.next() {\n+            if let ty::Predicate::Trait(data, _) = pred {\n+                return Some(data.to_poly_trait_ref());\n+            }\n+        }\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.base_iterator.size_hint();\n+        (0, upper)\n+    }\n+}"}, {"sha": "c9d81e51641a8b2f49bb50745992f47cb6c9663b", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -21,7 +21,7 @@ rustc_parse = { path = \"../librustc_parse\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n-rustc = { path = \"../librustc\" }\n+rustc_middle = { path = \"../librustc_middle\" }\n rustc_ast_lowering = { path = \"../librustc_ast_lowering\" }\n rustc_ast_passes = { path = \"../librustc_ast_passes\" }\n rustc_incremental = { path = \"../librustc_incremental\" }"}, {"sha": "88c3d0ec56f6877e773018eb412c9280cdf6996d", "filename": "src/librustc_interface/callbacks.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Fcallbacks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Fcallbacks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fcallbacks.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,6 +1,6 @@\n //! Throughout the compiler tree, there are several places which want to have\n //! access to state or queries while being inside crates that are dependencies\n-//! of librustc. To facilitate this, we have the\n+//! of librustc_middle. To facilitate this, we have the\n //! `rustc_data_structures::AtomicRef` type, which allows us to setup a global\n //! static which can then be set in this file at program startup.\n //!\n@@ -9,12 +9,12 @@\n //! The functions in this file should fall back to the default set in their\n //! origin crate when the `TyCtxt` is not present in TLS.\n \n-use rustc::ty::tls;\n use rustc_errors::{Diagnostic, TRACK_DIAGNOSTICS};\n+use rustc_middle::ty::tls;\n use std::fmt;\n \n /// This is a callback from librustc_ast as it cannot access the implicit state\n-/// in librustc otherwise.\n+/// in librustc_middle otherwise.\n fn span_debug(span: rustc_span::Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n     tls::with_opt(|tcx| {\n         if let Some(tcx) = tcx {\n@@ -26,7 +26,7 @@ fn span_debug(span: rustc_span::Span, f: &mut fmt::Formatter<'_>) -> fmt::Result\n }\n \n /// This is a callback from librustc_ast as it cannot access the implicit state\n-/// in librustc otherwise. It is used to when diagnostic messages are\n+/// in librustc_middle otherwise. It is used to when diagnostic messages are\n /// emitted and stores them in the current query, if there is one.\n fn track_diagnostic(diagnostic: &Diagnostic) {\n     tls::with_context_opt(|icx| {\n@@ -40,7 +40,7 @@ fn track_diagnostic(diagnostic: &Diagnostic) {\n }\n \n /// This is a callback from librustc_hir as it cannot access the implicit state\n-/// in librustc otherwise.\n+/// in librustc_middle otherwise.\n fn def_id_debug(def_id: rustc_hir::def_id::DefId, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n     write!(f, \"DefId({}:{}\", def_id.krate, def_id.index.index())?;\n     tls::with_opt(|opt_tcx| {\n@@ -58,5 +58,5 @@ pub fn setup_callbacks() {\n     rustc_span::SPAN_DEBUG.swap(&(span_debug as fn(_, &mut fmt::Formatter<'_>) -> _));\n     rustc_hir::def_id::DEF_ID_DEBUG.swap(&(def_id_debug as fn(_, &mut fmt::Formatter<'_>) -> _));\n     TRACK_DIAGNOSTICS.swap(&(track_diagnostic as fn(&_)));\n-    rustc::ty::RESOLVE_INSTANCE.swap(&(rustc_ty::instance::resolve_instance as _));\n+    rustc_middle::ty::RESOLVE_INSTANCE.swap(&(rustc_ty::instance::resolve_instance as _));\n }"}, {"sha": "8e929b7daa85000d0e0d77c2e782a9ea6718ce6c", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,16 +1,16 @@\n pub use crate::passes::BoxedResolver;\n use crate::util;\n \n-use rustc::ty;\n-use rustc::util::common::ErrorReported;\n use rustc_ast::ast::{self, MetaItemKind};\n use rustc_ast::token;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::OnDrop;\n use rustc_errors::registry::Registry;\n+use rustc_errors::ErrorReported;\n use rustc_lint::LintStore;\n+use rustc_middle::ty;\n use rustc_parse::new_parser_from_source_str;\n use rustc_session::config::{self, ErrorOutputType, Input, OutputFilenames};\n use rustc_session::early_error;"}, {"sha": "609c80a2b790584577c73ceed2dcd78b7d69cdd2", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -3,25 +3,24 @@ use crate::proc_macro_decls;\n use crate::util;\n \n use log::{info, log_enabled, warn};\n-use rustc::arena::Arena;\n-use rustc::dep_graph::DepGraph;\n-use rustc::middle;\n-use rustc::middle::cstore::{CrateStore, MetadataLoader, MetadataLoaderDyn};\n-use rustc::ty::steal::Steal;\n-use rustc::ty::{self, GlobalCtxt, ResolverOutputs, TyCtxt};\n-use rustc::util::common::ErrorReported;\n use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::{self, ast, visit};\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::sync::{par_iter, Lrc, Once, ParallelIterator, WorkerLocal};\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n-use rustc_errors::PResult;\n+use rustc_errors::{ErrorReported, PResult};\n use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_hir::Crate;\n use rustc_lint::LintStore;\n+use rustc_middle::arena::Arena;\n+use rustc_middle::dep_graph::DepGraph;\n+use rustc_middle::middle;\n+use rustc_middle::middle::cstore::{CrateStore, MetadataLoader, MetadataLoaderDyn};\n+use rustc_middle::ty::steal::Steal;\n+use rustc_middle::ty::{self, GlobalCtxt, ResolverOutputs, TyCtxt};\n use rustc_mir as mir;\n use rustc_mir_build as mir_build;\n use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str};\n@@ -678,7 +677,7 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     providers.analysis = analysis;\n     proc_macro_decls::provide(providers);\n     plugin::build::provide(providers);\n-    rustc::hir::provide(providers);\n+    rustc_middle::hir::provide(providers);\n     mir::provide(providers);\n     mir_build::provide(providers);\n     rustc_privacy::provide(providers);\n@@ -711,7 +710,7 @@ impl<'tcx> QueryContext<'tcx> {\n     }\n \n     pub fn print_stats(&mut self) {\n-        self.enter(|tcx| ty::query::print_stats(tcx))\n+        self.enter(ty::query::print_stats)\n     }\n }\n "}, {"sha": "47b53aeba725d9f42aabcd30b37e21e8568585fd", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,9 +1,9 @@\n-use rustc::ty::query::Providers;\n-use rustc::ty::TyCtxt;\n use rustc_ast::attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n pub fn find(tcx: TyCtxt<'_>) -> Option<DefId> {"}, {"sha": "6a62d754f289169e55d287bb9b94523df0e11bf5", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,18 +1,18 @@\n use crate::interface::{Compiler, Result};\n use crate::passes::{self, BoxedResolver, QueryContext};\n \n-use rustc::arena::Arena;\n-use rustc::dep_graph::DepGraph;\n-use rustc::ty::steal::Steal;\n-use rustc::ty::{GlobalCtxt, ResolverOutputs, TyCtxt};\n-use rustc::util::common::ErrorReported;\n use rustc_ast::{self, ast};\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::sync::{Lrc, Once, WorkerLocal};\n+use rustc_errors::ErrorReported;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_hir::Crate;\n use rustc_incremental::DepGraphFuture;\n use rustc_lint::LintStore;\n+use rustc_middle::arena::Arena;\n+use rustc_middle::dep_graph::DepGraph;\n+use rustc_middle::ty::steal::Steal;\n+use rustc_middle::ty::{GlobalCtxt, ResolverOutputs, TyCtxt};\n use rustc_session::config::{OutputFilenames, OutputType};\n use rustc_session::{output::find_crate_name, Session};\n use rustc_span::symbol::sym;"}, {"sha": "f58c5cc8eeb8a495cc0d0f45a524c2e51cff3b0f", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2,9 +2,9 @@ extern crate getopts;\n \n use crate::interface::parse_cfgspecs;\n \n-use rustc::middle::cstore;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{emitter::HumanReadableErrorType, registry, ColorConfig};\n+use rustc_middle::middle::cstore;\n use rustc_session::config::{build_configuration, build_session_options, to_crate_config};\n use rustc_session::config::{rustc_optgroups, ErrorOutputType, ExternLocation, Options, Passes};\n use rustc_session::config::{ExternEntry, LinkerPluginLto, LtoCli, SwitchWithOptPath};\n@@ -562,6 +562,8 @@ fn test_debugging_options_tracking_hash() {\n     assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n     opts.debugging_opts.dump_mir_graphviz = true;\n     assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.dump_mir_dataflow = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n     // Make sure changing a [TRACKED] option changes the hash\n     opts = reference.clone();"}, {"sha": "a8cc34e185439e9e4afe073482999c211d4d544c", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,5 +1,4 @@\n use log::info;\n-use rustc::ty;\n use rustc_ast::ast::{AttrVec, BlockCheckMode};\n use rustc_ast::mut_visit::{visit_clobber, MutVisitor, *};\n use rustc_ast::ptr::P;\n@@ -14,6 +13,7 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::registry::Registry;\n use rustc_metadata::dynamic_lib::DynamicLibrary;\n+use rustc_middle::ty;\n use rustc_resolve::{self, Resolver};\n use rustc_session as session;\n use rustc_session::config::{ErrorOutputType, Input, OutputFilenames};"}, {"sha": "5ccfc1b276bfa0e1c71372aa4f3c99e588d0eff8", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 131, "deletions": 22, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -17,9 +17,13 @@\n mod cursor;\n pub mod unescape;\n \n+#[cfg(test)]\n+mod tests;\n+\n use self::LiteralKind::*;\n use self::TokenKind::*;\n use crate::cursor::{Cursor, EOF_CHAR};\n+use std::convert::TryInto;\n \n /// Parsed token.\n /// It doesn't contain information about data that has been parsed,\n@@ -132,9 +136,84 @@ pub enum LiteralKind {\n     /// \"b\"abc\"\", \"b\"abc\"\n     ByteStr { terminated: bool },\n     /// \"r\"abc\"\", \"r#\"abc\"#\", \"r####\"ab\"###\"c\"####\", \"r#\"a\"\n-    RawStr { n_hashes: usize, started: bool, terminated: bool },\n+    RawStr(UnvalidatedRawStr),\n     /// \"br\"abc\"\", \"br#\"abc\"#\", \"br####\"ab\"###\"c\"####\", \"br#\"a\"\n-    RawByteStr { n_hashes: usize, started: bool, terminated: bool },\n+    RawByteStr(UnvalidatedRawStr),\n+}\n+\n+/// Represents something that looks like a raw string, but may have some\n+/// problems. Use `.validate()` to convert it into something\n+/// usable.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct UnvalidatedRawStr {\n+    /// The prefix (`r###\"`) is valid\n+    valid_start: bool,\n+\n+    /// The postfix (`\"###`) is valid\n+    valid_end: bool,\n+\n+    /// The number of leading `#`\n+    n_start_hashes: usize,\n+    /// The number of trailing `#`. `n_end_hashes` <= `n_start_hashes`\n+    n_end_hashes: usize,\n+    /// The offset starting at `r` or `br` where the user may have intended to end the string.\n+    /// Currently, it is the longest sequence of pattern `\"#+\"`.\n+    possible_terminator_offset: Option<usize>,\n+}\n+\n+/// Error produced validating a raw string. Represents cases like:\n+/// - `r##~\"abcde\"##`: `LexRawStrError::InvalidStarter`\n+/// - `r###\"abcde\"##`: `LexRawStrError::NoTerminator { expected: 3, found: 2, possible_terminator_offset: Some(11)`\n+/// - Too many `#`s (>65536): `TooManyDelimiters`\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum LexRawStrError {\n+    /// Non `#` characters exist between `r` and `\"` eg. `r#~\"..`\n+    InvalidStarter,\n+    /// The string was never terminated. `possible_terminator_offset` is the number of characters after `r` or `br` where they\n+    /// may have intended to terminate it.\n+    NoTerminator { expected: usize, found: usize, possible_terminator_offset: Option<usize> },\n+    /// More than 65536 `#`s exist.\n+    TooManyDelimiters,\n+}\n+\n+/// Raw String that contains a valid prefix (`#+\"`) and postfix (`\"#+`) where\n+/// there are a matching number of `#` characters in both. Note that this will\n+/// not consume extra trailing `#` characters: `r###\"abcde\"####` is lexed as a\n+/// `ValidatedRawString { n_hashes: 3 }` followed by a `#` token.\n+#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n+pub struct ValidatedRawStr {\n+    n_hashes: u16,\n+}\n+\n+impl ValidatedRawStr {\n+    pub fn num_hashes(&self) -> u16 {\n+        self.n_hashes\n+    }\n+}\n+\n+impl UnvalidatedRawStr {\n+    pub fn validate(self) -> Result<ValidatedRawStr, LexRawStrError> {\n+        if !self.valid_start {\n+            return Err(LexRawStrError::InvalidStarter);\n+        }\n+\n+        // Only up to 65535 `#`s are allowed in raw strings\n+        let n_start_safe: u16 =\n+            self.n_start_hashes.try_into().map_err(|_| LexRawStrError::TooManyDelimiters)?;\n+\n+        if self.n_start_hashes > self.n_end_hashes || !self.valid_end {\n+            Err(LexRawStrError::NoTerminator {\n+                expected: self.n_start_hashes,\n+                found: self.n_end_hashes,\n+                possible_terminator_offset: self.possible_terminator_offset,\n+            })\n+        } else {\n+            // Since the lexer should never produce a literal with n_end > n_start, if n_start <= n_end,\n+            // they must be equal.\n+            debug_assert_eq!(self.n_start_hashes, self.n_end_hashes);\n+            Ok(ValidatedRawStr { n_hashes: n_start_safe })\n+        }\n+    }\n }\n \n /// Base of numeric literal encoding according to its prefix.\n@@ -209,7 +288,7 @@ pub fn is_whitespace(c: char) -> bool {\n         // Dedicated whitespace characters from Unicode\n         | '\\u{2028}' // LINE SEPARATOR\n         | '\\u{2029}' // PARAGRAPH SEPARATOR\n-            => true,\n+        => true,\n         _ => false,\n     }\n }\n@@ -258,12 +337,12 @@ impl Cursor<'_> {\n             'r' => match (self.first(), self.second()) {\n                 ('#', c1) if is_id_start(c1) => self.raw_ident(),\n                 ('#', _) | ('\"', _) => {\n-                    let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n+                    let raw_str_i = self.raw_double_quoted_string(1);\n                     let suffix_start = self.len_consumed();\n-                    if terminated {\n+                    if raw_str_i.n_end_hashes == raw_str_i.n_start_hashes {\n                         self.eat_literal_suffix();\n                     }\n-                    let kind = RawStr { n_hashes, started, terminated };\n+                    let kind = RawStr(raw_str_i);\n                     Literal { kind, suffix_start }\n                 }\n                 _ => self.ident(),\n@@ -293,12 +372,14 @@ impl Cursor<'_> {\n                 }\n                 ('r', '\"') | ('r', '#') => {\n                     self.bump();\n-                    let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n+                    let raw_str_i = self.raw_double_quoted_string(2);\n                     let suffix_start = self.len_consumed();\n+                    let terminated = raw_str_i.n_start_hashes == raw_str_i.n_end_hashes;\n                     if terminated {\n                         self.eat_literal_suffix();\n                     }\n-                    let kind = RawByteStr { n_hashes, started, terminated };\n+\n+                    let kind = RawByteStr(raw_str_i);\n                     Literal { kind, suffix_start }\n                 }\n                 _ => self.ident(),\n@@ -594,37 +675,51 @@ impl Cursor<'_> {\n         false\n     }\n \n-    /// Eats the double-quoted string and returns a tuple of\n-    /// (amount of the '#' symbols, raw string started, raw string terminated)\n-    fn raw_double_quoted_string(&mut self) -> (usize, bool, bool) {\n+    /// Eats the double-quoted string and returns an `UnvalidatedRawStr`.\n+    fn raw_double_quoted_string(&mut self, prefix_len: usize) -> UnvalidatedRawStr {\n         debug_assert!(self.prev() == 'r');\n-        let mut started: bool = false;\n-        let mut finished: bool = false;\n+        let mut valid_start: bool = false;\n+        let start_pos = self.len_consumed();\n+        let (mut possible_terminator_offset, mut max_hashes) = (None, 0);\n \n         // Count opening '#' symbols.\n-        let n_hashes = self.eat_while(|c| c == '#');\n+        let n_start_hashes = self.eat_while(|c| c == '#');\n \n         // Check that string is started.\n         match self.bump() {\n-            Some('\"') => started = true,\n-            _ => return (n_hashes, started, finished),\n+            Some('\"') => valid_start = true,\n+            _ => {\n+                return UnvalidatedRawStr {\n+                    valid_start,\n+                    valid_end: false,\n+                    n_start_hashes,\n+                    n_end_hashes: 0,\n+                    possible_terminator_offset,\n+                };\n+            }\n         }\n \n         // Skip the string contents and on each '#' character met, check if this is\n         // a raw string termination.\n-        while !finished {\n+        loop {\n             self.eat_while(|c| c != '\"');\n \n             if self.is_eof() {\n-                return (n_hashes, started, finished);\n+                return UnvalidatedRawStr {\n+                    valid_start,\n+                    valid_end: false,\n+                    n_start_hashes,\n+                    n_end_hashes: max_hashes,\n+                    possible_terminator_offset,\n+                };\n             }\n \n             // Eat closing double quote.\n             self.bump();\n \n             // Check that amount of closing '#' symbols\n             // is equal to the amount of opening ones.\n-            let mut hashes_left = n_hashes;\n+            let mut hashes_left = n_start_hashes;\n             let is_closing_hash = |c| {\n                 if c == '#' && hashes_left != 0 {\n                     hashes_left -= 1;\n@@ -633,10 +728,24 @@ impl Cursor<'_> {\n                     false\n                 }\n             };\n-            finished = self.eat_while(is_closing_hash) == n_hashes;\n+            let n_end_hashes = self.eat_while(is_closing_hash);\n+\n+            if n_end_hashes == n_start_hashes {\n+                return UnvalidatedRawStr {\n+                    valid_start,\n+                    valid_end: true,\n+                    n_start_hashes,\n+                    n_end_hashes,\n+                    possible_terminator_offset: None,\n+                };\n+            } else if n_end_hashes > max_hashes {\n+                // Keep track of possible terminators to give a hint about where there might be\n+                // a missing terminator\n+                possible_terminator_offset =\n+                    Some(self.len_consumed() - start_pos - n_end_hashes + prefix_len);\n+                max_hashes = n_end_hashes;\n+            }\n         }\n-\n-        (n_hashes, started, finished)\n     }\n \n     fn eat_decimal_digits(&mut self) -> bool {"}, {"sha": "06fc159fe2516a86f5a9e3e54efb1726a12bae4d", "filename": "src/librustc_lexer/src/tests.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -0,0 +1,148 @@\n+#[cfg(test)]\n+mod tests {\n+    use crate::*;\n+\n+    fn check_raw_str(\n+        s: &str,\n+        expected: UnvalidatedRawStr,\n+        validated: Result<ValidatedRawStr, LexRawStrError>,\n+    ) {\n+        let s = &format!(\"r{}\", s);\n+        let mut cursor = Cursor::new(s);\n+        cursor.bump();\n+        let tok = cursor.raw_double_quoted_string(0);\n+        assert_eq!(tok, expected);\n+        assert_eq!(tok.validate(), validated);\n+    }\n+\n+    #[test]\n+    fn test_naked_raw_str() {\n+        check_raw_str(\n+            r#\"\"abc\"\"#,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 0,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                valid_end: true,\n+                possible_terminator_offset: None,\n+            },\n+            Ok(ValidatedRawStr { n_hashes: 0 }),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_raw_no_start() {\n+        check_raw_str(\n+            r##\"\"abc\"#\"##,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 0,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                valid_end: true,\n+                possible_terminator_offset: None,\n+            },\n+            Ok(ValidatedRawStr { n_hashes: 0 }),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_too_many_terminators() {\n+        // this error is handled in the parser later\n+        check_raw_str(\n+            r###\"#\"abc\"##\"###,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 1,\n+                n_end_hashes: 1,\n+                valid_end: true,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Ok(ValidatedRawStr { n_hashes: 1 }),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_unterminated() {\n+        check_raw_str(\n+            r#\"#\"abc\"#,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 1,\n+                n_end_hashes: 0,\n+                valid_end: false,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 1,\n+                found: 0,\n+                possible_terminator_offset: None,\n+            }),\n+        );\n+        check_raw_str(\n+            r###\"##\"abc\"#\"###,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 2,\n+                n_end_hashes: 1,\n+                valid_start: true,\n+                valid_end: false,\n+                possible_terminator_offset: Some(7),\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 2,\n+                found: 1,\n+                possible_terminator_offset: Some(7),\n+            }),\n+        );\n+        // We're looking for \"# not just any #\n+        check_raw_str(\n+            r###\"##\"abc#\"###,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 2,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                valid_end: false,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 2,\n+                found: 0,\n+                possible_terminator_offset: None,\n+            }),\n+        )\n+    }\n+\n+    #[test]\n+    fn test_invalid_start() {\n+        check_raw_str(\n+            r##\"#~\"abc\"#\"##,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 1,\n+                n_end_hashes: 0,\n+                valid_start: false,\n+                valid_end: false,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::InvalidStarter),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_unterminated_no_pound() {\n+        // https://github.com/rust-lang/rust/issues/70677\n+        check_raw_str(\n+            r#\"\"\"#,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 0,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                valid_end: false,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 0,\n+                found: 0,\n+                possible_terminator_offset: None,\n+            }),\n+        );\n+    }\n+}"}, {"sha": "44a5ba3de517c2b310e1e03c014f303df0c05f00", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -11,7 +11,7 @@ path = \"lib.rs\"\n [dependencies]\n log = \"0.4\"\n unicode-security = \"0.0.2\"\n-rustc = { path = \"../librustc\" }\n+rustc_middle = { path = \"../librustc_middle\" }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "3eb587c016acb18c7f9b85b1d82d6738fe10a728", "filename": "src/librustc_lint/array_into_iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Farray_into_iter.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,8 +1,8 @@\n use crate::{LateContext, LateLintPass, LintContext};\n-use rustc::ty;\n-use rustc::ty::adjustment::{Adjust, Adjustment};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_middle::ty;\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_span::symbol::sym;\n "}, {"sha": "cff86e8f2183730296f0dc942fd8074f3d26dc56", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 41, "deletions": 51, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,17 +1,16 @@\n //! Lints in the Rust compiler.\n //!\n //! This contains lints which can feasibly be implemented as their own\n-//! AST visitor. Also see `rustc::lint::builtin`, which contains the\n-//! definitions of lints that are emitted directly inside the main\n-//! compiler.\n+//! AST visitor. Also see `rustc_session::lint::builtin`, which contains the\n+//! definitions of lints that are emitted directly inside the main compiler.\n //!\n //! To add a new lint to rustc, declare it here using `declare_lint!()`.\n //! Then add code to emit the new lint in the appropriate circumstances.\n //! You can do that in an existing `LintPass` if it makes sense, or in a\n //! new `LintPass`, or using `Session::add_lint` elsewhere in the\n //! compiler. Only do the latter if the check can't be written cleanly as a\n //! `LintPass` (also, note that such lints will need to be defined in\n-//! `rustc::lint::builtin`, not here).\n+//! `rustc_session::lint::builtin`, not here).\n //!\n //! If you define a new `EarlyLintPass`, you will also need to add it to the\n //! `add_early_builtin!` or `add_early_builtin_with_new!` invocation in\n@@ -22,8 +21,6 @@\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n-use rustc::lint::LintDiagnosticBuilder;\n-use rustc::ty::{self, layout::VariantIdx, Ty, TyCtxt};\n use rustc_ast::ast::{self, Expr};\n use rustc_ast::attr::{self, HasAttrs};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n@@ -38,19 +35,22 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{GenericParamKind, PatKind};\n use rustc_hir::{HirIdSet, Node};\n+use rustc_middle::lint::LintDiagnosticBuilder;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{BytePos, Span};\n+use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::traits::misc::can_type_implement_copy;\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n \n use log::debug;\n use std::fmt::Write;\n \n-// hardwired lints from librustc\n+// hardwired lints from librustc_middle\n pub use rustc_session::lint::builtin::*;\n \n declare_lint! {\n@@ -646,41 +646,35 @@ declare_lint_pass!(\n \n impl EarlyLintPass for AnonymousParameters {\n     fn check_trait_item(&mut self, cx: &EarlyContext<'_>, it: &ast::AssocItem) {\n-        match it.kind {\n-            ast::AssocItemKind::Fn(_, ref sig, _, _) => {\n-                for arg in sig.decl.inputs.iter() {\n-                    match arg.pat.kind {\n-                        ast::PatKind::Ident(_, ident, None) => {\n-                            if ident.name == kw::Invalid {\n-                                cx.struct_span_lint(ANONYMOUS_PARAMETERS, arg.pat.span, |lint| {\n-                                    let ty_snip = cx.sess.source_map().span_to_snippet(arg.ty.span);\n-\n-                                    let (ty_snip, appl) = if let Ok(ref snip) = ty_snip {\n-                                        (snip.as_str(), Applicability::MachineApplicable)\n-                                    } else {\n-                                        (\"<type>\", Applicability::HasPlaceholders)\n-                                    };\n+        if let ast::AssocItemKind::Fn(_, ref sig, _, _) = it.kind {\n+            for arg in sig.decl.inputs.iter() {\n+                if let ast::PatKind::Ident(_, ident, None) = arg.pat.kind {\n+                    if ident.name == kw::Invalid {\n+                        cx.struct_span_lint(ANONYMOUS_PARAMETERS, arg.pat.span, |lint| {\n+                            let ty_snip = cx.sess.source_map().span_to_snippet(arg.ty.span);\n+\n+                            let (ty_snip, appl) = if let Ok(ref snip) = ty_snip {\n+                                (snip.as_str(), Applicability::MachineApplicable)\n+                            } else {\n+                                (\"<type>\", Applicability::HasPlaceholders)\n+                            };\n \n-                                    lint.build(\n-                                        \"anonymous parameters are deprecated and will be \\\n+                            lint.build(\n+                                \"anonymous parameters are deprecated and will be \\\n                                      removed in the next edition.\",\n-                                    )\n-                                    .span_suggestion(\n-                                        arg.pat.span,\n-                                        \"try naming the parameter or explicitly \\\n+                            )\n+                            .span_suggestion(\n+                                arg.pat.span,\n+                                \"try naming the parameter or explicitly \\\n                                             ignoring it\",\n-                                        format!(\"_: {}\", ty_snip),\n-                                        appl,\n-                                    )\n-                                    .emit();\n-                                })\n-                            }\n-                        }\n-                        _ => (),\n+                                format!(\"_: {}\", ty_snip),\n+                                appl,\n+                            )\n+                            .emit();\n+                        })\n                     }\n                 }\n             }\n-            _ => (),\n         }\n     }\n }\n@@ -888,18 +882,14 @@ declare_lint_pass!(MutableTransmutes => [MUTABLE_TRANSMUTES]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n         use rustc_target::spec::abi::Abi::RustIntrinsic;\n-\n-        match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind)) {\n-            Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n-                if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n-                    let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n+        if let Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) =\n+            get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind))\n+        {\n+            if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n+                let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n                                consider instead using an UnsafeCell\";\n-                    cx.struct_span_lint(MUTABLE_TRANSMUTES, expr.span, |lint| {\n-                        lint.build(msg).emit()\n-                    });\n-                }\n+                cx.struct_span_lint(MUTABLE_TRANSMUTES, expr.span, |lint| lint.build(msg).emit());\n             }\n-            _ => (),\n         }\n \n         fn get_transmute_from_to<'a, 'tcx>(\n@@ -1207,8 +1197,8 @@ declare_lint_pass!(\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'tcx>) {\n-        use rustc::ty::fold::TypeFoldable;\n-        use rustc::ty::Predicate::*;\n+        use rustc_middle::ty::fold::TypeFoldable;\n+        use rustc_middle::ty::Predicate::*;\n \n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n@@ -1558,7 +1548,7 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives: &[ty::Region<'tcx>],\n         infer_static: bool,\n     ) -> Vec<(usize, Span)> {\n-        use rustc::middle::resolve_lifetime::Region;\n+        use rustc_middle::middle::resolve_lifetime::Region;\n \n         bounds\n             .iter()\n@@ -1641,7 +1631,7 @@ impl ExplicitOutlivesRequirements {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n-        use rustc::middle::resolve_lifetime::Region;\n+        use rustc_middle::middle::resolve_lifetime::Region;\n \n         let infer_static = cx.tcx.features().infer_static_outlives_requirements;\n         let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n@@ -1926,7 +1916,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n             ty: Ty<'tcx>,\n             init: InitKind,\n         ) -> Option<InitError> {\n-            use rustc::ty::TyKind::*;\n+            use rustc_middle::ty::TyKind::*;\n             match ty.kind {\n                 // Primitive types that don't like 0 as a value.\n                 Ref(..) => Some((\"references must be non-null\".to_string(), None)),"}, {"sha": "1747a78d36a4c813b53923a2ddee3f7c33a4809a", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -18,11 +18,6 @@ use self::TargetLint::*;\n \n use crate::levels::LintLevelsBuilder;\n use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n-use rustc::lint::LintDiagnosticBuilder;\n-use rustc::middle::privacy::AccessLevels;\n-use rustc::middle::stability;\n-use rustc::ty::layout::{LayoutError, LayoutOf, TyLayout};\n-use rustc::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n use rustc_ast::ast;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::FxHashMap;\n@@ -31,10 +26,16 @@ use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n+use rustc_middle::lint::LintDiagnosticBuilder;\n+use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::stability;\n+use rustc_middle::ty::layout::{LayoutError, TyAndLayout};\n+use rustc_middle::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n use rustc_session::lint::{add_elided_lifetime_in_path_suggestion, BuiltinLintDiagnostics};\n use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use rustc_session::Session;\n use rustc_span::{symbol::Symbol, MultiSpan, Span, DUMMY_SP};\n+use rustc_target::abi::LayoutOf;\n \n use std::slice;\n \n@@ -787,9 +788,8 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n                 let mut path = print_prefix(self)?;\n \n                 // Skip `::{{constructor}}` on tuple/unit structs.\n-                match disambiguated_data.data {\n-                    DefPathData::Ctor => return Ok(path),\n-                    _ => {}\n+                if let DefPathData::Ctor = disambiguated_data.data {\n+                    return Ok(path);\n                 }\n \n                 path.push(disambiguated_data.data.as_symbol());\n@@ -811,9 +811,9 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n \n impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n     type Ty = Ty<'tcx>;\n-    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+    type TyAndLayout = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n     }\n }"}, {"sha": "018e9da243c70a34f1319ef6549f6e8544f2779a", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -104,6 +104,11 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         run_early_pass!(self, check_pat_post, p);\n     }\n \n+    fn visit_anon_const(&mut self, c: &'a ast::AnonConst) {\n+        run_early_pass!(self, check_anon_const, c);\n+        ast_visit::walk_anon_const(self, c);\n+    }\n+\n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         self.with_lint_attrs(e.id, &e.attrs, |cx| {\n             run_early_pass!(cx, check_expr, e);"}, {"sha": "6de8fb45d223d80e6e8eb37f63a4d2789906b282", "filename": "src/librustc_lint/internal.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -175,18 +175,15 @@ fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment<'_>) -> bo\n }\n \n fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty<'_>) -> Option<String> {\n-    match &ty.kind {\n-        TyKind::Path(qpath) => {\n-            if let QPath::Resolved(_, path) = qpath {\n-                let did = path.res.opt_def_id()?;\n-                if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n-                    return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n-                } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n-                    return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n-                }\n+    if let TyKind::Path(qpath) = &ty.kind {\n+        if let QPath::Resolved(_, path) = qpath {\n+            let did = path.res.opt_def_id()?;\n+            if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n+                return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n+            } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n+                return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n             }\n         }\n-        _ => {}\n     }\n \n     None"}, {"sha": "1999a8ec5f60d564a7e913fb43e9bcce7c542e6e", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -15,15 +15,15 @@\n //! for all lint attributes.\n \n use crate::{passes::LateLintPassObject, LateContext, LateLintPass, LintStore};\n-use rustc::hir::map::Map;\n-use rustc::ty::{self, TyCtxt};\n use rustc_ast::ast;\n use rustc_ast::walk_list;\n use rustc_data_structures::sync::{join, par_iter, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit as hir_visit;\n use rustc_hir::intravisit::Visitor;\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::LintPass;\n use rustc_span::Span;\n "}, {"sha": "c78b088fb12617935ee5563ce4f78bb4cb8f62ee", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,10 +1,5 @@\n use crate::context::{CheckLintNameResult, LintStore};\n use crate::late::unerased_lint_store;\n-use rustc::hir::map::Map;\n-use rustc::lint::LintDiagnosticBuilder;\n-use rustc::lint::{struct_lint_level, LintLevelMap, LintLevelSets, LintSet, LintSource};\n-use rustc::ty::query::Providers;\n-use rustc::ty::TyCtxt;\n use rustc_ast::ast;\n use rustc_ast::attr;\n use rustc_ast::unwrap_or;\n@@ -14,6 +9,11 @@ use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::{intravisit, HirId};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::lint::LintDiagnosticBuilder;\n+use rustc_middle::lint::{struct_lint_level, LintLevelMap, LintLevelSets, LintSet, LintSource};\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::{builtin, Level, Lint};\n use rustc_session::parse::feature_err;\n use rustc_session::Session;"}, {"sha": "af1fad2c6608be402f129cfa62f77891c8d869e9", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -19,7 +19,7 @@\n //! example) requires more effort. See `emit_lint` and `GatherNodeLevels`\n //! in `context.rs`.\n //!\n-//! Some code also exists in `rustc_session::lint`, `rustc::lint`.\n+//! Some code also exists in `rustc_session::lint`, `rustc_middle::lint`.\n //!\n //! ## Note\n //!\n@@ -35,7 +35,7 @@\n #![recursion_limit = \"256\"]\n \n #[macro_use]\n-extern crate rustc;\n+extern crate rustc_middle;\n #[macro_use]\n extern crate rustc_session;\n \n@@ -53,11 +53,11 @@ mod redundant_semicolon;\n mod types;\n mod unused;\n \n-use rustc::ty::query::Providers;\n-use rustc::ty::TyCtxt;\n use rustc_ast::ast;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::{\n     BARE_TRAIT_OBJECTS, ELIDED_LIFETIMES_IN_PATHS, EXPLICIT_OUTLIVES_REQUIREMENTS,\n     INTRA_DOC_LINK_RESOLUTION_FAILURE, MISSING_DOC_CODE_EXAMPLES, PRIVATE_DOC_TESTS,\n@@ -104,6 +104,7 @@ macro_rules! early_lint_passes {\n             $args,\n             [\n                 UnusedParens: UnusedParens,\n+                UnusedBraces: UnusedBraces,\n                 UnusedImportBraces: UnusedImportBraces,\n                 UnsafeCode: UnsafeCode,\n                 AnonymousParameters: AnonymousParameters,\n@@ -275,6 +276,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n         UNUSED_FEATURES,\n         UNUSED_LABELS,\n         UNUSED_PARENS,\n+        UNUSED_BRACES,\n         REDUNDANT_SEMICOLONS\n     );\n "}, {"sha": "052b461039b23402e6a90dba452b4f25bbe667d7", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,12 +1,12 @@\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n-use rustc::ty;\n use rustc_ast::ast;\n use rustc_attr as attr;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{GenericParamKind, PatKind};\n+use rustc_middle::ty;\n use rustc_span::symbol::sym;\n use rustc_span::{symbol::Ident, BytePos, Span};\n use rustc_target::spec::abi::Abi;"}, {"sha": "c9e12afedbbab6fd3cf24d1da39fa563b0c79de8", "filename": "src/librustc_lint/passes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fpasses.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -170,6 +170,7 @@ macro_rules! early_lint_methods {\n             fn check_stmt(a: &ast::Stmt);\n             fn check_arm(a: &ast::Arm);\n             fn check_pat(a: &ast::Pat);\n+            fn check_anon_const(a: &ast::AnonConst);\n             fn check_pat_post(a: &ast::Pat);\n             fn check_expr(a: &ast::Expr);\n             fn check_expr_post(a: &ast::Expr);"}, {"sha": "a6e1ed84c87081cfbd01bbacdbcd7d5d24601da7", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,10 +1,6 @@\n #![allow(non_snake_case)]\n \n use crate::{LateContext, LateLintPass, LintContext};\n-use rustc::mir::interpret::{sign_extend, truncate};\n-use rustc::ty::layout::{self, IntegerExt, LayoutOf, SizeSkeleton, VariantIdx};\n-use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc_ast::ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n@@ -13,9 +9,14 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{is_range_literal, ExprKind, Node};\n use rustc_index::vec::Idx;\n+use rustc_middle::mir::interpret::{sign_extend, truncate};\n+use rustc_middle::ty::layout::{IntegerExt, SizeSkeleton};\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use rustc_target::abi::{DiscriminantKind, Integer, LayoutOf, VariantIdx, Variants};\n use rustc_target::spec::abi::Abi;\n \n use log::debug;\n@@ -150,7 +151,7 @@ fn report_bin_hex_error(\n     val: u128,\n     negative: bool,\n ) {\n-    let size = layout::Integer::from_attr(&cx.tcx, ty).size();\n+    let size = Integer::from_attr(&cx.tcx, ty).size();\n     cx.struct_span_lint(OVERFLOWING_LITERALS, expr.span, |lint| {\n         let (t, actually) = match ty {\n             attr::IntType::SignedInt(t) => {\n@@ -919,7 +920,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n \n     fn check_for_opaque_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n-        use crate::rustc::ty::TypeFoldable;\n+        use rustc_middle::ty::TypeFoldable;\n \n         struct ProhibitOpaqueTypes<'tcx> {\n             ty: Option<Ty<'tcx>>,\n@@ -1034,8 +1035,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 | Err(ty::layout::LayoutError::SizeOverflow(_)) => return,\n             };\n             let (variants, tag) = match layout.variants {\n-                layout::Variants::Multiple {\n-                    discr_kind: layout::DiscriminantKind::Tag,\n+                Variants::Multiple {\n+                    discr_kind: DiscriminantKind::Tag,\n                     ref discr,\n                     ref variants,\n                     .."}, {"sha": "c74b399555a8a874ff96bd74e75af1aeb1515019", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 368, "deletions": 137, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,7 +1,7 @@\n+use crate::Lint;\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n-use rustc::ty::adjustment;\n-use rustc::ty::{self, Ty};\n use rustc_ast::ast;\n+use rustc_ast::ast::{ExprKind, StmtKind};\n use rustc_ast::attr;\n use rustc_ast::util::parser;\n use rustc_ast_pretty::pprust;\n@@ -11,6 +11,8 @@ use rustc_feature::{AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::adjustment;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::lint::builtin::UNUSED_ATTRIBUTES;\n use rustc_span::symbol::Symbol;\n use rustc_span::symbol::{kw, sym};\n@@ -285,12 +287,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n         let attr_info = attr.ident().and_then(|ident| self.builtin_attributes.get(&ident.name));\n \n         if let Some(&&(name, ty, ..)) = attr_info {\n-            match ty {\n-                AttributeType::Whitelisted => {\n-                    debug!(\"{:?} is Whitelisted\", name);\n-                    return;\n-                }\n-                _ => (),\n+            if let AttributeType::Whitelisted = ty {\n+                debug!(\"{:?} is Whitelisted\", name);\n+                return;\n             }\n         }\n \n@@ -318,123 +317,108 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n     }\n }\n \n-declare_lint! {\n-    pub(super) UNUSED_PARENS,\n-    Warn,\n-    \"`if`, `match`, `while` and `return` do not need parentheses\"\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum UnusedDelimsCtx {\n+    FunctionArg,\n+    MethodArg,\n+    AssignedValue,\n+    IfCond,\n+    WhileCond,\n+    ForIterExpr,\n+    MatchScrutineeExpr,\n+    ReturnValue,\n+    BlockRetValue,\n+    LetScrutineeExpr,\n+    ArrayLenExpr,\n+    AnonConst,\n }\n \n-declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n+impl From<UnusedDelimsCtx> for &'static str {\n+    fn from(ctx: UnusedDelimsCtx) -> &'static str {\n+        match ctx {\n+            UnusedDelimsCtx::FunctionArg => \"function argument\",\n+            UnusedDelimsCtx::MethodArg => \"method argument\",\n+            UnusedDelimsCtx::AssignedValue => \"assigned value\",\n+            UnusedDelimsCtx::IfCond => \"`if` condition\",\n+            UnusedDelimsCtx::WhileCond => \"`while` condition\",\n+            UnusedDelimsCtx::ForIterExpr => \"`for` iterator expression\",\n+            UnusedDelimsCtx::MatchScrutineeExpr => \"`match` scrutinee expression\",\n+            UnusedDelimsCtx::ReturnValue => \"`return` value\",\n+            UnusedDelimsCtx::BlockRetValue => \"block return value\",\n+            UnusedDelimsCtx::LetScrutineeExpr => \"`let` scrutinee expression\",\n+            UnusedDelimsCtx::ArrayLenExpr | UnusedDelimsCtx::AnonConst => \"const expression\",\n+        }\n+    }\n+}\n \n-impl UnusedParens {\n-    fn is_expr_parens_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n+/// Used by both `UnusedParens` and `UnusedBraces` to prevent code duplication.\n+trait UnusedDelimLint {\n+    const DELIM_STR: &'static str;\n+\n+    // this cannot be a constant is it refers to a static.\n+    fn lint(&self) -> &'static Lint;\n+\n+    fn check_unused_delims_expr(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Expr,\n+        ctx: UnusedDelimsCtx,\n+        followed_by_block: bool,\n+        left_pos: Option<BytePos>,\n+        right_pos: Option<BytePos>,\n+    );\n+\n+    fn is_expr_delims_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n         followed_by_block\n             && match inner.kind {\n                 ast::ExprKind::Ret(_) | ast::ExprKind::Break(..) => true,\n                 _ => parser::contains_exterior_struct_lit(&inner),\n             }\n     }\n \n-    fn check_unused_parens_expr(\n+    fn emit_unused_delims_expr(\n         &self,\n         cx: &EarlyContext<'_>,\n         value: &ast::Expr,\n-        msg: &str,\n-        followed_by_block: bool,\n+        ctx: UnusedDelimsCtx,\n         left_pos: Option<BytePos>,\n         right_pos: Option<BytePos>,\n     ) {\n-        match value.kind {\n-            ast::ExprKind::Paren(ref inner) => {\n-                if !Self::is_expr_parens_necessary(inner, followed_by_block)\n-                    && value.attrs.is_empty()\n-                    && !value.span.from_expansion()\n-                {\n-                    let expr_text =\n-                        if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n-                            snippet\n-                        } else {\n-                            pprust::expr_to_string(value)\n-                        };\n-                    let keep_space = (\n-                        left_pos.map(|s| s >= value.span.lo()).unwrap_or(false),\n-                        right_pos.map(|s| s <= value.span.hi()).unwrap_or(false),\n-                    );\n-                    Self::remove_outer_parens(cx, value.span, &expr_text, msg, keep_space);\n-                }\n-            }\n-            ast::ExprKind::Let(_, ref expr) => {\n-                // FIXME(#60336): Properly handle `let true = (false && true)`\n-                // actually needing the parenthesis.\n-                self.check_unused_parens_expr(\n-                    cx,\n-                    expr,\n-                    \"`let` head expression\",\n-                    followed_by_block,\n-                    None,\n-                    None,\n-                );\n-            }\n-            _ => {}\n-        }\n+        let expr_text = if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n+            snippet\n+        } else {\n+            pprust::expr_to_string(value)\n+        };\n+        let keep_space = (\n+            left_pos.map(|s| s >= value.span.lo()).unwrap_or(false),\n+            right_pos.map(|s| s <= value.span.hi()).unwrap_or(false),\n+        );\n+        self.emit_unused_delims(cx, value.span, &expr_text, ctx.into(), keep_space);\n     }\n \n-    fn check_unused_parens_pat(\n+    fn emit_unused_delims(\n         &self,\n-        cx: &EarlyContext<'_>,\n-        value: &ast::Pat,\n-        avoid_or: bool,\n-        avoid_mut: bool,\n-    ) {\n-        use ast::{BindingMode, Mutability, PatKind};\n-\n-        if let PatKind::Paren(inner) = &value.kind {\n-            match inner.kind {\n-                // The lint visitor will visit each subpattern of `p`. We do not want to lint\n-                // any range pattern no matter where it occurs in the pattern. For something like\n-                // `&(a..=b)`, there is a recursive `check_pat` on `a` and `b`, but we will assume\n-                // that if there are unnecessary parens they serve a purpose of readability.\n-                PatKind::Range(..) => return,\n-                // Avoid `p0 | .. | pn` if we should.\n-                PatKind::Or(..) if avoid_or => return,\n-                // Avoid `mut x` and `mut x @ p` if we should:\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ..) if avoid_mut => return,\n-                // Otherwise proceed with linting.\n-                _ => {}\n-            }\n-\n-            let pattern_text =\n-                if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n-                    snippet\n-                } else {\n-                    pprust::pat_to_string(value)\n-                };\n-            Self::remove_outer_parens(cx, value.span, &pattern_text, \"pattern\", (false, false));\n-        }\n-    }\n-\n-    fn remove_outer_parens(\n         cx: &EarlyContext<'_>,\n         span: Span,\n         pattern: &str,\n         msg: &str,\n         keep_space: (bool, bool),\n     ) {\n-        cx.struct_span_lint(UNUSED_PARENS, span, |lint| {\n-            let span_msg = format!(\"unnecessary parentheses around {}\", msg);\n+        cx.struct_span_lint(self.lint(), span, |lint| {\n+            let span_msg = format!(\"unnecessary {} around {}\", Self::DELIM_STR, msg);\n             let mut err = lint.build(&span_msg);\n             let mut ate_left_paren = false;\n             let mut ate_right_paren = false;\n             let parens_removed = pattern.trim_matches(|c| match c {\n-                '(' => {\n+                '(' | '{' => {\n                     if ate_left_paren {\n                         false\n                     } else {\n                         ate_left_paren = true;\n                         true\n                     }\n                 }\n-                ')' => {\n+                ')' | '}' => {\n                     if ate_right_paren {\n                         false\n                     } else {\n@@ -460,61 +444,51 @@ impl UnusedParens {\n                 replace\n             };\n \n-            err.span_suggestion_short(\n-                span,\n-                \"remove these parentheses\",\n-                replace,\n-                Applicability::MachineApplicable,\n-            );\n+            let suggestion = format!(\"remove these {}\", Self::DELIM_STR);\n+\n+            err.span_suggestion_short(span, &suggestion, replace, Applicability::MachineApplicable);\n             err.emit();\n         });\n     }\n-}\n \n-impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use rustc_ast::ast::ExprKind::*;\n-        let (value, msg, followed_by_block, left_pos, right_pos) = match e.kind {\n-            Let(ref pat, ..) => {\n-                self.check_unused_parens_pat(cx, pat, false, false);\n-                return;\n-            }\n-\n+        let (value, ctx, followed_by_block, left_pos, right_pos) = match e.kind {\n             If(ref cond, ref block, ..) => {\n                 let left = e.span.lo() + rustc_span::BytePos(2);\n                 let right = block.span.lo();\n-                (cond, \"`if` condition\", true, Some(left), Some(right))\n+                (cond, UnusedDelimsCtx::IfCond, true, Some(left), Some(right))\n             }\n \n             While(ref cond, ref block, ..) => {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n                 let right = block.span.lo();\n-                (cond, \"`while` condition\", true, Some(left), Some(right))\n+                (cond, UnusedDelimsCtx::WhileCond, true, Some(left), Some(right))\n             }\n \n-            ForLoop(ref pat, ref cond, ref block, ..) => {\n-                self.check_unused_parens_pat(cx, pat, false, false);\n-                (cond, \"`for` head expression\", true, None, Some(block.span.lo()))\n+            ForLoop(_, ref cond, ref block, ..) => {\n+                (cond, UnusedDelimsCtx::ForIterExpr, true, None, Some(block.span.lo()))\n             }\n \n             Match(ref head, _) => {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n-                (head, \"`match` head expression\", true, Some(left), None)\n+                (head, UnusedDelimsCtx::MatchScrutineeExpr, true, Some(left), None)\n             }\n \n             Ret(Some(ref value)) => {\n                 let left = e.span.lo() + rustc_span::BytePos(3);\n-                (value, \"`return` value\", false, Some(left), None)\n+                (value, UnusedDelimsCtx::ReturnValue, false, Some(left), None)\n             }\n \n-            Assign(_, ref value, _) => (value, \"assigned value\", false, None, None),\n-            AssignOp(.., ref value) => (value, \"assigned value\", false, None, None),\n+            Assign(_, ref value, _) | AssignOp(.., ref value) => {\n+                (value, UnusedDelimsCtx::AssignedValue, false, None, None)\n+            }\n             // either function/method call, or something this lint doesn't care about\n             ref call_or_other => {\n-                let (args_to_check, call_kind) = match *call_or_other {\n-                    Call(_, ref args) => (&args[..], \"function\"),\n-                    // first \"argument\" is self (which sometimes needs parens)\n-                    MethodCall(_, ref args) => (&args[1..], \"method\"),\n+                let (args_to_check, ctx) = match *call_or_other {\n+                    Call(_, ref args) => (&args[..], UnusedDelimsCtx::FunctionArg),\n+                    // first \"argument\" is self (which sometimes needs delims)\n+                    MethodCall(_, ref args) => (&args[1..], UnusedDelimsCtx::MethodArg),\n                     // actual catch-all arm\n                     _ => {\n                         return;\n@@ -527,14 +501,152 @@ impl EarlyLintPass for UnusedParens {\n                 if e.span.ctxt().outer_expn_data().call_site.from_expansion() {\n                     return;\n                 }\n-                let msg = format!(\"{} argument\", call_kind);\n                 for arg in args_to_check {\n-                    self.check_unused_parens_expr(cx, arg, &msg, false, None, None);\n+                    self.check_unused_delims_expr(cx, arg, ctx, false, None, None);\n                 }\n                 return;\n             }\n         };\n-        self.check_unused_parens_expr(cx, &value, msg, followed_by_block, left_pos, right_pos);\n+        self.check_unused_delims_expr(cx, &value, ctx, followed_by_block, left_pos, right_pos);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        match s.kind {\n+            StmtKind::Local(ref local) => {\n+                if let Some(ref value) = local.init {\n+                    self.check_unused_delims_expr(\n+                        cx,\n+                        &value,\n+                        UnusedDelimsCtx::AssignedValue,\n+                        false,\n+                        None,\n+                        None,\n+                    );\n+                }\n+            }\n+            StmtKind::Expr(ref expr) => {\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    &expr,\n+                    UnusedDelimsCtx::BlockRetValue,\n+                    false,\n+                    None,\n+                    None,\n+                );\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        use ast::ItemKind::*;\n+\n+        if let Const(.., Some(expr)) | Static(.., Some(expr)) = &item.kind {\n+            self.check_unused_delims_expr(\n+                cx,\n+                expr,\n+                UnusedDelimsCtx::AssignedValue,\n+                false,\n+                None,\n+                None,\n+            );\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub(super) UNUSED_PARENS,\n+    Warn,\n+    \"`if`, `match`, `while` and `return` do not need parentheses\"\n+}\n+\n+declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n+\n+impl UnusedDelimLint for UnusedParens {\n+    const DELIM_STR: &'static str = \"parentheses\";\n+\n+    fn lint(&self) -> &'static Lint {\n+        UNUSED_PARENS\n+    }\n+\n+    fn check_unused_delims_expr(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Expr,\n+        ctx: UnusedDelimsCtx,\n+        followed_by_block: bool,\n+        left_pos: Option<BytePos>,\n+        right_pos: Option<BytePos>,\n+    ) {\n+        match value.kind {\n+            ast::ExprKind::Paren(ref inner) => {\n+                if !Self::is_expr_delims_necessary(inner, followed_by_block)\n+                    && value.attrs.is_empty()\n+                    && !value.span.from_expansion()\n+                {\n+                    self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n+                }\n+            }\n+            ast::ExprKind::Let(_, ref expr) => {\n+                // FIXME(#60336): Properly handle `let true = (false && true)`\n+                // actually needing the parenthesis.\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    expr,\n+                    UnusedDelimsCtx::LetScrutineeExpr,\n+                    followed_by_block,\n+                    None,\n+                    None,\n+                );\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+impl UnusedParens {\n+    fn check_unused_parens_pat(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Pat,\n+        avoid_or: bool,\n+        avoid_mut: bool,\n+    ) {\n+        use ast::{BindingMode, Mutability, PatKind};\n+\n+        if let PatKind::Paren(inner) = &value.kind {\n+            match inner.kind {\n+                // The lint visitor will visit each subpattern of `p`. We do not want to lint\n+                // any range pattern no matter where it occurs in the pattern. For something like\n+                // `&(a..=b)`, there is a recursive `check_pat` on `a` and `b`, but we will assume\n+                // that if there are unnecessary parens they serve a purpose of readability.\n+                PatKind::Range(..) => return,\n+                // Avoid `p0 | .. | pn` if we should.\n+                PatKind::Or(..) if avoid_or => return,\n+                // Avoid `mut x` and `mut x @ p` if we should:\n+                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ..) if avoid_mut => return,\n+                // Otherwise proceed with linting.\n+                _ => {}\n+            }\n+\n+            let pattern_text =\n+                if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n+                    snippet\n+                } else {\n+                    pprust::pat_to_string(value)\n+                };\n+            self.emit_unused_delims(cx, value.span, &pattern_text, \"pattern\", (false, false));\n+        }\n+    }\n+}\n+\n+impl EarlyLintPass for UnusedParens {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        if let ExprKind::Let(ref pat, ..) | ExprKind::ForLoop(ref pat, ..) = e.kind {\n+            self.check_unused_parens_pat(cx, pat, false, false);\n+        }\n+\n+        <Self as UnusedDelimLint>::check_expr(self, cx, e)\n     }\n \n     fn check_pat(&mut self, cx: &EarlyContext<'_>, p: &ast::Pat) {\n@@ -559,22 +671,16 @@ impl EarlyLintPass for UnusedParens {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n-        use ast::StmtKind::*;\n-\n-        match s.kind {\n-            Local(ref local) => {\n-                self.check_unused_parens_pat(cx, &local.pat, false, false);\n+    fn check_anon_const(&mut self, cx: &EarlyContext<'_>, c: &ast::AnonConst) {\n+        self.check_unused_delims_expr(cx, &c.value, UnusedDelimsCtx::AnonConst, false, None, None);\n+    }\n \n-                if let Some(ref value) = local.init {\n-                    self.check_unused_parens_expr(cx, &value, \"assigned value\", false, None, None);\n-                }\n-            }\n-            Expr(ref expr) => {\n-                self.check_unused_parens_expr(cx, &expr, \"block return value\", false, None, None);\n-            }\n-            _ => {}\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        if let StmtKind::Local(ref local) = s.kind {\n+            self.check_unused_parens_pat(cx, &local.pat, false, false);\n         }\n+\n+        <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n     }\n \n     fn check_param(&mut self, cx: &EarlyContext<'_>, param: &ast::Param) {\n@@ -590,6 +696,16 @@ impl EarlyLintPass for UnusedParens {\n             match &r.kind {\n                 &ast::TyKind::TraitObject(..) => {}\n                 &ast::TyKind::ImplTrait(_, ref bounds) if bounds.len() > 1 => {}\n+                &ast::TyKind::Array(_, ref len) => {\n+                    self.check_unused_delims_expr(\n+                        cx,\n+                        &len.value,\n+                        UnusedDelimsCtx::ArrayLenExpr,\n+                        false,\n+                        None,\n+                        None,\n+                    );\n+                }\n                 _ => {\n                     let pattern_text =\n                         if let Ok(snippet) = cx.sess().source_map().span_to_snippet(ty.span) {\n@@ -598,21 +714,136 @@ impl EarlyLintPass for UnusedParens {\n                             pprust::ty_to_string(ty)\n                         };\n \n-                    Self::remove_outer_parens(cx, ty.span, &pattern_text, \"type\", (false, false));\n+                    self.emit_unused_delims(cx, ty.span, &pattern_text, \"type\", (false, false));\n                 }\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n-        use ast::ItemKind::*;\n+        <Self as UnusedDelimLint>::check_item(self, cx, item)\n+    }\n+}\n \n-        if let Const(.., Some(expr)) | Static(.., Some(expr)) = &item.kind {\n-            self.check_unused_parens_expr(cx, expr, \"assigned value\", false, None, None);\n+declare_lint! {\n+    pub(super) UNUSED_BRACES,\n+    Warn,\n+    \"unnecessary braces around an expression\"\n+}\n+\n+declare_lint_pass!(UnusedBraces => [UNUSED_BRACES]);\n+\n+impl UnusedDelimLint for UnusedBraces {\n+    const DELIM_STR: &'static str = \"braces\";\n+\n+    fn lint(&self) -> &'static Lint {\n+        UNUSED_BRACES\n+    }\n+\n+    fn check_unused_delims_expr(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Expr,\n+        ctx: UnusedDelimsCtx,\n+        followed_by_block: bool,\n+        left_pos: Option<BytePos>,\n+        right_pos: Option<BytePos>,\n+    ) {\n+        match value.kind {\n+            ast::ExprKind::Block(ref inner, None)\n+                if inner.rules == ast::BlockCheckMode::Default =>\n+            {\n+                // emit a warning under the following conditions:\n+                //\n+                // - the block does not have a label\n+                // - the block is not `unsafe`\n+                // - the block contains exactly one expression (do not lint `{ expr; }`)\n+                // - `followed_by_block` is true and the internal expr may contain a `{`\n+                // - the block is not multiline (do not lint multiline match arms)\n+                //      ```\n+                //      match expr {\n+                //          Pattern => {\n+                //              somewhat_long_expression\n+                //          }\n+                //          // ...\n+                //      }\n+                //      ```\n+                // - the block has no attribute and was not created inside a macro\n+                // - if the block is an `anon_const`, the inner expr must be a literal\n+                //      (do not lint `struct A<const N: usize>; let _: A<{ 2 + 3 }>;`)\n+                //\n+                // FIXME(const_generics): handle paths when #67075 is fixed.\n+                if let [stmt] = inner.stmts.as_slice() {\n+                    if let ast::StmtKind::Expr(ref expr) = stmt.kind {\n+                        if !Self::is_expr_delims_necessary(expr, followed_by_block)\n+                            && (ctx != UnusedDelimsCtx::AnonConst\n+                                || matches!(expr.kind, ast::ExprKind::Lit(_)))\n+                            // array length expressions are checked during `check_anon_const` and `check_ty`,\n+                            // once as `ArrayLenExpr` and once as `AnonConst`.\n+                            //\n+                            // As we do not want to lint this twice, we do not emit an error for\n+                            // `ArrayLenExpr` if `AnonConst` would do the same.\n+                            && (ctx != UnusedDelimsCtx::ArrayLenExpr\n+                                || !matches!(expr.kind, ast::ExprKind::Lit(_)))\n+                            && !cx.sess().source_map().is_multiline(value.span)\n+                            && value.attrs.is_empty()\n+                            && !value.span.from_expansion()\n+                        {\n+                            self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n+                        }\n+                    }\n+                }\n+            }\n+            ast::ExprKind::Let(_, ref expr) => {\n+                // FIXME(#60336): Properly handle `let true = (false && true)`\n+                // actually needing the parenthesis.\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    expr,\n+                    UnusedDelimsCtx::LetScrutineeExpr,\n+                    followed_by_block,\n+                    None,\n+                    None,\n+                );\n+            }\n+            _ => {}\n         }\n     }\n }\n \n+impl EarlyLintPass for UnusedBraces {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        <Self as UnusedDelimLint>::check_expr(self, cx, e)\n+    }\n+\n+    fn check_anon_const(&mut self, cx: &EarlyContext<'_>, c: &ast::AnonConst) {\n+        self.check_unused_delims_expr(cx, &c.value, UnusedDelimsCtx::AnonConst, false, None, None);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n+    }\n+\n+    fn check_ty(&mut self, cx: &EarlyContext<'_>, ty: &ast::Ty) {\n+        if let &ast::TyKind::Paren(ref r) = &ty.kind {\n+            if let ast::TyKind::Array(_, ref len) = r.kind {\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    &len.value,\n+                    UnusedDelimsCtx::ArrayLenExpr,\n+                    false,\n+                    None,\n+                    None,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        <Self as UnusedDelimLint>::check_item(self, cx, item)\n+    }\n+}\n+\n declare_lint! {\n     UNUSED_IMPORT_BRACES,\n     Allow,"}, {"sha": "c955c137782764b6c283d46f3c23724842563617", "filename": "src/librustc_macros/src/hash_stable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -115,13 +115,13 @@ pub fn hash_stable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::To\n     s.bound_impl(\n         quote!(\n             ::rustc_data_structures::stable_hasher::HashStable<\n-                ::rustc::ich::StableHashingContext<'__ctx>,\n+                ::rustc_middle::ich::StableHashingContext<'__ctx>,\n             >\n         ),\n         quote! {\n             fn hash_stable(\n                 &self,\n-                __hcx: &mut ::rustc::ich::StableHashingContext<'__ctx>,\n+                __hcx: &mut ::rustc_middle::ich::StableHashingContext<'__ctx>,\n                 __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher) {\n                 #discriminant\n                 match *self { #body }"}, {"sha": "4bf4ce00a4d3826a9cb29ca8cb2096f1bbc3c2ab", "filename": "src/librustc_macros/src/lift.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_macros%2Fsrc%2Flift.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_macros%2Fsrc%2Flift.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flift.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -39,11 +39,11 @@ pub fn lift_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStre\n \n     s.add_impl_generic(newtcx);\n     s.bound_impl(\n-        quote!(::rustc::ty::Lift<'__lifted>),\n+        quote!(::rustc_middle::ty::Lift<'__lifted>),\n         quote! {\n             type Lifted = #lifted;\n \n-            fn lift_to_tcx(&self, __tcx: ::rustc::ty::TyCtxt<'__lifted>) -> Option<#lifted> {\n+            fn lift_to_tcx(&self, __tcx: ::rustc_middle::ty::TyCtxt<'__lifted>) -> Option<#lifted> {\n                 Some(match *self { #body })\n             }\n         },"}, {"sha": "7ed77304a90e1b07a26492ea1b0eb824c1424233", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -356,9 +356,11 @@ fn add_query_description_impl(\n                 quote! { #t }\n             })\n             .unwrap_or(quote! { _ });\n+        // expr is a `Block`, meaning that `{ #expr }` gets expanded\n+        // to `{ { stmts... } }`, which triggers the `unused_braces` lint.\n         quote! {\n             #[inline]\n-            #[allow(unused_variables)]\n+            #[allow(unused_variables, unused_braces)]\n             fn cache_on_disk(\n                 #tcx: TyCtxt<'tcx>,\n                 #key: Self::Key,\n@@ -429,7 +431,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 });\n \n                 try_load_from_on_disk_cache_stream.extend(quote! {\n-                    ::rustc::dep_graph::DepKind::#name => {\n+                    ::rustc_middle::dep_graph::DepKind::#name => {\n                         if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n                             debug_assert!($tcx.dep_graph\n                                             .node_color($dep_node)\n@@ -486,7 +488,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n             // Add a match arm to force the query given the dep node\n             dep_node_force_stream.extend(quote! {\n-                ::rustc::dep_graph::DepKind::#name => {\n+                ::rustc_middle::dep_graph::DepKind::#name => {\n                     if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n                         if let Some(key) = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node) {\n                             force_query::<crate::ty::query::queries::#name<'_>, _>(\n@@ -510,7 +512,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     }\n \n     dep_node_force_stream.extend(quote! {\n-        ::rustc::dep_graph::DepKind::Null => {\n+        ::rustc_middle::dep_graph::DepKind::Null => {\n             bug!(\"Cannot force dep node: {:?}\", $dep_node)\n         }\n     });"}, {"sha": "6931e6552add28eab90b998e251deecefd08f77f", "filename": "src/librustc_macros/src/type_foldable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_macros%2Fsrc%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_macros%2Fsrc%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Ftype_foldable.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -11,25 +11,25 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n         vi.construct(|_, index| {\n             let bind = &bindings[index];\n             quote! {\n-                ::rustc::ty::fold::TypeFoldable::fold_with(#bind, __folder)\n+                ::rustc_middle::ty::fold::TypeFoldable::fold_with(#bind, __folder)\n             }\n         })\n     });\n     let body_visit = s.fold(false, |acc, bind| {\n-        quote! { #acc || ::rustc::ty::fold::TypeFoldable::visit_with(#bind, __folder) }\n+        quote! { #acc || ::rustc_middle::ty::fold::TypeFoldable::visit_with(#bind, __folder) }\n     });\n \n     s.bound_impl(\n-        quote!(::rustc::ty::fold::TypeFoldable<'tcx>),\n+        quote!(::rustc_middle::ty::fold::TypeFoldable<'tcx>),\n         quote! {\n-            fn super_fold_with<__F: ::rustc::ty::fold::TypeFolder<'tcx>>(\n+            fn super_fold_with<__F: ::rustc_middle::ty::fold::TypeFolder<'tcx>>(\n                 &self,\n                 __folder: &mut __F\n             ) -> Self {\n                 match *self { #body_fold }\n             }\n \n-            fn super_visit_with<__F: ::rustc::ty::fold::TypeVisitor<'tcx>>(\n+            fn super_visit_with<__F: ::rustc_middle::ty::fold::TypeVisitor<'tcx>>(\n                 &self,\n                 __folder: &mut __F\n             ) -> bool {"}, {"sha": "a88ccd52e911122a5fb3a1723c207d0ea7881a34", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -14,7 +14,7 @@ flate2 = \"1.0\"\n log = \"0.4\"\n memmap = \"0.7\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n-rustc = { path = \"../librustc\" }\n+rustc_middle = { path = \"../librustc_middle\" }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "7d5c58ecea2a135c1c076d2d8f04bb562468670f", "filename": "src/librustc_metadata/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fbuild.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,4 +1,5 @@\n fn main() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n     println!(\"cargo:rerun-if-env-changed=CFG_VERSION\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\");\n }"}, {"sha": "3e5d7b8efd530a5d31341446639ca9a62f3af454", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -3,9 +3,6 @@\n use crate::locator::{CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n-use rustc::middle::cstore::DepKind;\n-use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn};\n-use rustc::ty::TyCtxt;\n use rustc_ast::expand::allocator::{global_allocator_spans, AllocatorKind};\n use rustc_ast::{ast, attr};\n use rustc_data_structures::svh::Svh;\n@@ -15,6 +12,11 @@ use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::middle::cstore::DepKind;\n+use rustc_middle::middle::cstore::{\n+    CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn,\n+};\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::config;\n use rustc_session::output::validate_crate_name;\n use rustc_session::search_paths::PathKind;"}, {"sha": "91654067f08155e3206c8a359d3d1db26bcbe2b3", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -53,12 +53,12 @@\n \n use crate::creader::CStore;\n \n-use rustc::middle::cstore::LinkagePreference::{self, RequireDynamic, RequireStatic};\n-use rustc::middle::cstore::{self, DepKind};\n-use rustc::middle::dependency_format::{Dependencies, DependencyList, Linkage};\n-use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::CrateNum;\n+use rustc_middle::middle::cstore::LinkagePreference::{self, RequireDynamic, RequireStatic};\n+use rustc_middle::middle::cstore::{self, DepKind};\n+use rustc_middle::middle::dependency_format::{Dependencies, DependencyList, Linkage};\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::config;\n use rustc_target::spec::PanicStrategy;\n "}, {"sha": "b312aa37d46b027936e5eab75afaee9ed8b532bf", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,7 +1,7 @@\n-use rustc::middle::cstore::ForeignModule;\n-use rustc::ty::TyCtxt;\n use rustc_hir as hir;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_middle::middle::cstore::ForeignModule;\n+use rustc_middle::ty::TyCtxt;\n \n crate fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n     let mut collector = Collector { tcx, modules: Vec::new() };"}, {"sha": "22a2bf280415cc7a16370e925e961805cf88745b", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -14,7 +14,7 @@ extern crate libc;\n extern crate proc_macro;\n \n #[macro_use]\n-extern crate rustc;\n+extern crate rustc_middle;\n #[macro_use]\n extern crate rustc_data_structures;\n "}, {"sha": "2dd4a9c9dbcb114a113cc0951ed430365bb968cb", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,6 +1,6 @@\n-use rustc::ty::TyCtxt;\n use rustc_hir as hir;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n use rustc_target::spec::abi::Abi;\n "}, {"sha": "d56c8490ef5eea949bca79187a652c1c3db28199", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -215,11 +215,11 @@\n use crate::creader::Library;\n use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n-use rustc::middle::cstore::{CrateSource, MetadataLoader};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n+use rustc_middle::middle::cstore::{CrateSource, MetadataLoader};\n use rustc_session::filesearch::{FileDoesntMatch, FileMatches, FileSearch};\n use rustc_session::search_paths::PathKind;\n use rustc_session::{config, CrateDisambiguator, Session};"}, {"sha": "4b92a2205c211ec6e9759ecce25003d0deda4d01", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,10 +1,10 @@\n-use rustc::middle::cstore::{self, NativeLibrary};\n-use rustc::ty::TyCtxt;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_middle::middle::cstore::{self, NativeLibrary};\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::source_map::Span;\n@@ -162,8 +162,13 @@ impl Collector<'tcx> {\n             }\n         }\n         if lib.cfg.is_some() && !self.tcx.features().link_cfg {\n-            feature_err(&self.tcx.sess.parse_sess, sym::link_cfg, span.unwrap(), \"is unstable\")\n-                .emit();\n+            feature_err(\n+                &self.tcx.sess.parse_sess,\n+                sym::link_cfg,\n+                span.unwrap(),\n+                \"kind=\\\"link_cfg\\\" is unstable\",\n+            )\n+            .emit();\n         }\n         if lib.kind == cstore::NativeStaticNobundle && !self.tcx.features().static_nobundle {\n             feature_err("}, {"sha": "c59b155d5dbbce00aff24bc66f1a269f860aaf8e", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 89, "deletions": 46, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -4,17 +4,6 @@ use crate::creader::CrateMetadataRef;\n use crate::rmeta::table::{FixedSizeEncoding, Table};\n use crate::rmeta::*;\n \n-use rustc::dep_graph::{self, DepNode, DepNodeExt, DepNodeIndex};\n-use rustc::hir::exports::Export;\n-use rustc::middle::cstore::{CrateSource, ExternCrate};\n-use rustc::middle::cstore::{ForeignModule, LinkagePreference, NativeLibrary};\n-use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n-use rustc::middle::lang_items;\n-use rustc::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use rustc::mir::{self, interpret, BodyAndCache, Promoted};\n-use rustc::ty::codec::TyDecoder;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::common::record_time;\n use rustc_ast::ast::{self, Ident};\n use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n@@ -29,10 +18,21 @@ use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathTable;\n use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n+use rustc_hir::lang_items;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::dep_graph::{self, DepNode, DepNodeExt, DepNodeIndex};\n+use rustc_middle::hir::exports::Export;\n+use rustc_middle::middle::cstore::{CrateSource, ExternCrate};\n+use rustc_middle::middle::cstore::{ForeignModule, LinkagePreference, NativeLibrary};\n+use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n+use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n+use rustc_middle::mir::{self, interpret, BodyAndCache, Promoted};\n+use rustc_middle::ty::codec::TyDecoder;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::util::common::record_time;\n use rustc_serialize::{opaque, Decodable, Decoder, SpecializedDecoder};\n use rustc_session::Session;\n-use rustc_span::source_map::{self, respan, Spanned};\n+use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{self, hygiene::MacroKind, BytePos, Pos, Span, DUMMY_SP};\n \n@@ -41,6 +41,7 @@ use proc_macro::bridge::client::ProcMacro;\n use std::io;\n use std::mem;\n use std::num::NonZeroUsize;\n+use std::path::Path;\n use std::u32;\n \n pub use cstore_impl::{provide, provide_extern};\n@@ -427,7 +428,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         // we can call `imported_source_files` for the proper crate, and binary search\n         // through the returned slice using our span.\n         let imported_source_files = if tag == TAG_VALID_SPAN_LOCAL {\n-            self.cdata().imported_source_files(sess.source_map())\n+            self.cdata().imported_source_files(sess)\n         } else {\n             // FIXME: We don't decode dependencies of proc-macros.\n             // Remove this once #69976 is merged\n@@ -457,7 +458,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             self.last_source_file_index = 0;\n \n             let foreign_data = self.cdata().cstore.get_crate_data(cnum);\n-            foreign_data.imported_source_files(sess.source_map())\n+            foreign_data.imported_source_files(sess)\n         };\n \n         let source_file = {\n@@ -633,7 +634,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n-        self.root.per_def.kind.get(self, item_id).map(|k| k.decode(self))\n+        self.root.tables.kind.get(self, item_id).map(|k| k.decode(self))\n     }\n \n     fn kind(&self, item_id: DefIndex) -> EntryKind {\n@@ -665,7 +666,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .expect(\"no name in item_ident\");\n             let span = self\n                 .root\n-                .per_def\n+                .tables\n                 .ident_span\n                 .get(self, item_index)\n                 .map(|data| data.decode((self, sess)))\n@@ -688,7 +689,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        self.root.per_def.span.get(self, index).unwrap().decode((self, sess))\n+        self.root.tables.span.get(self, index).unwrap().decode((self, sess))\n     }\n \n     fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n@@ -781,7 +782,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             ctor_did,\n             data.discr,\n             self.root\n-                .per_def\n+                .tables\n                 .children\n                 .get(self, index)\n                 .unwrap_or(Lazy::empty())\n@@ -812,7 +813,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n         let variants = if let ty::AdtKind::Enum = adt_kind {\n             self.root\n-                .per_def\n+                .tables\n                 .children\n                 .get(self, item_id)\n                 .unwrap_or(Lazy::empty())\n@@ -831,7 +832,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.root.per_def.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n+        self.root.tables.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     fn get_inferred_outlives(\n@@ -840,7 +841,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n         self.root\n-            .per_def\n+            .tables\n             .inferred_outlives\n             .get(self, item_id)\n             .map(|predicates| predicates.decode((self, tcx)))\n@@ -852,31 +853,31 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.root.per_def.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n+        self.root.tables.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n-        self.root.per_def.generics.get(self, item_id).unwrap().decode((self, sess))\n+        self.root.tables.generics.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n     fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        self.root.per_def.ty.get(self, id).unwrap().decode((self, tcx))\n+        self.root.tables.ty.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n             true => self.root.proc_macro_stability,\n-            false => self.root.per_def.stability.get(self, id).map(|stab| stab.decode(self)),\n+            false => self.root.tables.stability.get(self, id).map(|stab| stab.decode(self)),\n         }\n     }\n \n     fn get_const_stability(&self, id: DefIndex) -> Option<attr::ConstStability> {\n-        self.root.per_def.const_stability.get(self, id).map(|stab| stab.decode(self))\n+        self.root.tables.const_stability.get(self, id).map(|stab| stab.decode(self))\n     }\n \n     fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n         self.root\n-            .per_def\n+            .tables\n             .deprecation\n             .get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n@@ -886,7 +887,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n         match self.is_proc_macro(id) {\n             true => ty::Visibility::Public,\n-            false => self.root.per_def.visibility.get(self, id).unwrap().decode(self),\n+            false => self.root.tables.visibility.get(self, id).unwrap().decode(self),\n         }\n     }\n \n@@ -914,7 +915,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n-        self.root.per_def.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n+        self.root.tables.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n@@ -984,7 +985,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n         // Iterate over all children.\n         let macros_only = self.dep_kind.lock().macros_only();\n-        let children = self.root.per_def.children.get(self, id).unwrap_or(Lazy::empty());\n+        let children = self.root.tables.children.get(self, id).unwrap_or(Lazy::empty());\n         for child_index in children.decode((self, sess)) {\n             if macros_only {\n                 continue;\n@@ -1004,7 +1005,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     EntryKind::ForeignMod => {\n                         let child_children = self\n                             .root\n-                            .per_def\n+                            .tables\n                             .children\n                             .get(self, child_index)\n                             .unwrap_or(Lazy::empty());\n@@ -1016,7 +1017,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                                     vis: self.get_visibility(child_index),\n                                     span: self\n                                         .root\n-                                        .per_def\n+                                        .tables\n                                         .span\n                                         .get(self, child_index)\n                                         .unwrap()\n@@ -1096,13 +1097,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn is_item_mir_available(&self, id: DefIndex) -> bool {\n-        !self.is_proc_macro(id) && self.root.per_def.mir.get(self, id).is_some()\n+        !self.is_proc_macro(id) && self.root.tables.mir.get(self, id).is_some()\n     }\n \n     fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> BodyAndCache<'tcx> {\n         let mut cache = self\n             .root\n-            .per_def\n+            .tables\n             .mir\n             .get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n@@ -1121,7 +1122,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     ) -> IndexVec<Promoted, BodyAndCache<'tcx>> {\n         let mut cache = self\n             .root\n-            .per_def\n+            .tables\n             .promoted_mir\n             .get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n@@ -1172,7 +1173,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n-        self.root.per_def.variances.get(self, id).unwrap_or(Lazy::empty()).decode(self).collect()\n+        self.root.tables.variances.get(self, id).unwrap_or(Lazy::empty()).decode(self).collect()\n     }\n \n     fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n@@ -1209,7 +1210,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n         Lrc::from(\n             self.root\n-                .per_def\n+                .tables\n                 .attributes\n                 .get(self, item_id)\n                 .unwrap_or(Lazy::empty())\n@@ -1220,7 +1221,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn get_struct_field_names(&self, id: DefIndex, sess: &Session) -> Vec<Spanned<ast::Name>> {\n         self.root\n-            .per_def\n+            .tables\n             .children\n             .get(self, id)\n             .unwrap_or(Lazy::empty())\n@@ -1236,7 +1237,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     ) -> &'tcx [DefId] {\n         tcx.arena.alloc_from_iter(\n             self.root\n-                .per_def\n+                .tables\n                 .inherent_impls\n                 .get(self, id)\n                 .unwrap_or(Lazy::empty())\n@@ -1416,7 +1417,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        self.root.per_def.fn_sig.get(self, id).unwrap().decode((self, tcx))\n+        self.root.tables.fn_sig.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     #[inline]\n@@ -1460,10 +1461,45 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     ///\n     /// Proc macro crates don't currently export spans, so this function does not have\n     /// to work for them.\n-    fn imported_source_files(\n-        &self,\n-        local_source_map: &source_map::SourceMap,\n-    ) -> &'a [ImportedSourceFile] {\n+    fn imported_source_files(&self, sess: &Session) -> &'a [ImportedSourceFile] {\n+        // Translate the virtual `/rustc/$hash` prefix back to a real directory\n+        // that should hold actual sources, where possible.\n+        let virtual_rust_source_base_dir = option_env!(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\")\n+            .map(Path::new)\n+            .filter(|_| {\n+                // Only spend time on further checks if we have what to translate *to*.\n+                sess.real_rust_source_base_dir.is_some()\n+            })\n+            .filter(|virtual_dir| {\n+                // Don't translate away `/rustc/$hash` if we're still remapping to it,\n+                // since that means we're still building `std`/`rustc` that need it,\n+                // and we don't want the real path to leak into codegen/debuginfo.\n+                !sess.opts.remap_path_prefix.iter().any(|(_from, to)| to == virtual_dir)\n+            });\n+        let try_to_translate_virtual_to_real = |name: &mut rustc_span::FileName| {\n+            debug!(\n+                \"try_to_translate_virtual_to_real(name={:?}): \\\n+                 virtual_rust_source_base_dir={:?}, real_rust_source_base_dir={:?}\",\n+                name, virtual_rust_source_base_dir, sess.real_rust_source_base_dir,\n+            );\n+\n+            if let Some(virtual_dir) = virtual_rust_source_base_dir {\n+                if let Some(real_dir) = &sess.real_rust_source_base_dir {\n+                    if let rustc_span::FileName::Real(path) = name {\n+                        if let Ok(rest) = path.strip_prefix(virtual_dir) {\n+                            let new_path = real_dir.join(rest);\n+                            debug!(\n+                                \"try_to_translate_virtual_to_real: `{}` -> `{}`\",\n+                                path.display(),\n+                                new_path.display(),\n+                            );\n+                            *path = new_path;\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+\n         self.cdata.source_map_import_info.init_locking(|| {\n             let external_source_map = self.root.source_map.decode(self);\n \n@@ -1472,7 +1508,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     // We can't reuse an existing SourceFile, so allocate a new one\n                     // containing the information we need.\n                     let rustc_span::SourceFile {\n-                        name,\n+                        mut name,\n                         name_was_remapped,\n                         src_hash,\n                         start_pos,\n@@ -1485,6 +1521,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                         ..\n                     } = source_file_to_import;\n \n+                    // If this file's path has been remapped to `/rustc/$hash`,\n+                    // we might be able to reverse that (also see comments above,\n+                    // on `try_to_translate_virtual_to_real`).\n+                    // FIXME(eddyb) we could check `name_was_remapped` here,\n+                    // but in practice it seems to be always `false`.\n+                    try_to_translate_virtual_to_real(&mut name);\n+\n                     let source_length = (end_pos - start_pos).to_usize();\n \n                     // Translate line-start positions and multibyte character\n@@ -1505,7 +1548,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                         np.pos = np.pos - start_pos;\n                     }\n \n-                    let local_version = local_source_map.new_imported_source_file(\n+                    let local_version = sess.source_map().new_imported_source_file(\n                         name,\n                         name_was_remapped,\n                         src_hash,"}, {"sha": "c99b1dc360682955fb0b8772fe5d612f578342a5", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -4,13 +4,6 @@ use crate::link_args;\n use crate::native_libs;\n use crate::rmeta::{self, encoder};\n \n-use rustc::hir::exports::Export;\n-use rustc::middle::cstore::{CrateSource, CrateStore, EncodedMetadata, NativeLibraryKind};\n-use rustc::middle::exported_symbols::ExportedSymbol;\n-use rustc::middle::stability::DeprecationEntry;\n-use rustc::ty::query::Providers;\n-use rustc::ty::query::QueryConfig;\n-use rustc::ty::{self, TyCtxt};\n use rustc_ast::ast;\n use rustc_ast::attr;\n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -19,6 +12,13 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathTable;\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n+use rustc_middle::hir::exports::Export;\n+use rustc_middle::middle::cstore::{CrateSource, CrateStore, EncodedMetadata, NativeLibraryKind};\n+use rustc_middle::middle::exported_symbols::ExportedSymbol;\n+use rustc_middle::middle::stability::DeprecationEntry;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::query::QueryConfig;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::{CrateDisambiguator, Session};\n use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::Symbol;"}, {"sha": "f2e9f4d7e0b89998838af97ed3c291c45222bff6", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 99, "deletions": 98, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -2,16 +2,6 @@ use crate::rmeta::table::FixedSizeEncoding;\n use crate::rmeta::*;\n \n use log::{debug, trace};\n-use rustc::hir::map::Map;\n-use rustc::middle::cstore::{EncodedMetadata, ForeignModule, LinkagePreference, NativeLibrary};\n-use rustc::middle::dependency_format::Linkage;\n-use rustc::middle::exported_symbols::{metadata_symbol_name, ExportedSymbol, SymbolExportLevel};\n-use rustc::middle::lang_items;\n-use rustc::mir::{self, interpret};\n-use rustc::traits::specialization_graph;\n-use rustc::ty::codec::{self as ty_codec, TyEncoder};\n-use rustc::ty::layout::VariantIdx;\n-use rustc::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_ast::ast::{self, Ident};\n use rustc_ast::attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -25,13 +15,27 @@ use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX,\n use rustc_hir::definitions::DefPathTable;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::{ItemLikeVisitor, ParItemLikeVisitor};\n+use rustc_hir::lang_items;\n use rustc_hir::{AnonConst, GenericParamKind};\n use rustc_index::vec::Idx;\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::middle::cstore::{\n+    EncodedMetadata, ForeignModule, LinkagePreference, NativeLibrary,\n+};\n+use rustc_middle::middle::dependency_format::Linkage;\n+use rustc_middle::middle::exported_symbols::{\n+    metadata_symbol_name, ExportedSymbol, SymbolExportLevel,\n+};\n+use rustc_middle::mir::{self, interpret};\n+use rustc_middle::traits::specialization_graph;\n+use rustc_middle::ty::codec::{self as ty_codec, TyEncoder};\n+use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder};\n use rustc_session::config::{self, CrateType};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span};\n+use rustc_target::abi::VariantIdx;\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n use std::path::Path;\n@@ -41,7 +45,7 @@ struct EncodeContext<'tcx> {\n     opaque: opaque::Encoder,\n     tcx: TyCtxt<'tcx>,\n \n-    per_def: PerDefTableBuilders<'tcx>,\n+    tables: TableBuilders<'tcx>,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -493,8 +497,8 @@ impl<'tcx> EncodeContext<'tcx> {\n         };\n \n         i = self.position();\n-        let per_def = self.per_def.encode(&mut self.opaque);\n-        let per_def_bytes = self.position() - i;\n+        let tables = self.tables.encode(&mut self.opaque);\n+        let tables_bytes = self.position() - i;\n \n         // Encode the proc macro data\n         i = self.position();\n@@ -556,7 +560,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             impls,\n             exported_symbols,\n             interpret_alloc_index,\n-            per_def,\n+            tables,\n         });\n \n         let total_bytes = self.position();\n@@ -581,7 +585,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n             println!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n-            println!(\"   per-def table bytes: {}\", per_def_bytes);\n+            println!(\"           table bytes: {}\", tables_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);\n             println!(\"           total bytes: {}\", total_bytes);\n         }\n@@ -593,12 +597,12 @@ impl<'tcx> EncodeContext<'tcx> {\n impl EncodeContext<'tcx> {\n     fn encode_variances_of(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n-        record!(self.per_def.variances[def_id] <- &self.tcx.variances_of(def_id)[..]);\n+        record!(self.tables.variances[def_id] <- &self.tcx.variances_of(def_id)[..]);\n     }\n \n     fn encode_item_type(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_item_type({:?})\", def_id);\n-        record!(self.per_def.ty[def_id] <- self.tcx.type_of(def_id));\n+        record!(self.tables.ty[def_id] <- self.tcx.type_of(def_id));\n     }\n \n     fn encode_enum_variant_info(&mut self, enum_did: DefId, index: VariantIdx) {\n@@ -617,12 +621,12 @@ impl EncodeContext<'tcx> {\n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.per_def.visibility[def_id] <-\n+        record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.tables.visibility[def_id] <-\n             ty::Visibility::from_hir(enum_vis, enum_id, self.tcx));\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n-        record!(self.per_def.children[def_id] <- variant.fields.iter().map(|f| {\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n+        record!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n             assert!(f.did.is_local());\n             f.did.index\n         }));\n@@ -633,7 +637,7 @@ impl EncodeContext<'tcx> {\n         if variant.ctor_kind == CtorKind::Fn {\n             // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n             if let Some(ctor_def_id) = variant.ctor_def_id {\n-                record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n+                record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n             }\n             // FIXME(eddyb) is this ever used?\n             self.encode_variances_of(def_id);\n@@ -668,14 +672,14 @@ impl EncodeContext<'tcx> {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.per_def.visibility[def_id] <- ctor_vis);\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.tables.visibility[def_id] <- ctor_vis);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n-            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -703,11 +707,11 @@ impl EncodeContext<'tcx> {\n             },\n         };\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n-        record!(self.per_def.visibility[def_id] <- ty::Visibility::from_hir(vis, id, self.tcx));\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.per_def.attributes[def_id] <- attrs);\n-        record!(self.per_def.children[def_id] <- md.item_ids.iter().map(|item_id| {\n+        record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n+        record!(self.tables.visibility[def_id] <- ty::Visibility::from_hir(vis, id, self.tcx));\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.attributes[def_id] <- attrs);\n+        record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n             tcx.hir().local_def_id(item_id.id).index\n         }));\n         self.encode_stability(def_id);\n@@ -725,10 +729,10 @@ impl EncodeContext<'tcx> {\n         let variant_id = tcx.hir().as_local_hir_id(variant.def_id).unwrap();\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Field);\n-        record!(self.per_def.visibility[def_id] <- field.vis);\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.per_def.attributes[def_id] <- variant_data.fields()[field_index].attrs);\n+        record!(self.tables.kind[def_id] <- EntryKind::Field);\n+        record!(self.tables.visibility[def_id] <- field.vis);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.attributes[def_id] <- variant_data.fields()[field_index].attrs);\n         self.encode_ident_span(def_id, field.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -767,14 +771,14 @@ impl EncodeContext<'tcx> {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr));\n-        record!(self.per_def.visibility[def_id] <- ctor_vis);\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr));\n+        record!(self.tables.visibility[def_id] <- ctor_vis);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n-            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -786,26 +790,26 @@ impl EncodeContext<'tcx> {\n \n     fn encode_generics(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_generics({:?})\", def_id);\n-        record!(self.per_def.generics[def_id] <- self.tcx.generics_of(def_id));\n+        record!(self.tables.generics[def_id] <- self.tcx.generics_of(def_id));\n     }\n \n     fn encode_explicit_predicates(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_explicit_predicates({:?})\", def_id);\n-        record!(self.per_def.explicit_predicates[def_id] <-\n+        record!(self.tables.explicit_predicates[def_id] <-\n             self.tcx.explicit_predicates_of(def_id));\n     }\n \n     fn encode_inferred_outlives(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_inferred_outlives({:?})\", def_id);\n         let inferred_outlives = self.tcx.inferred_outlives_of(def_id);\n         if !inferred_outlives.is_empty() {\n-            record!(self.per_def.inferred_outlives[def_id] <- inferred_outlives);\n+            record!(self.tables.inferred_outlives[def_id] <- inferred_outlives);\n         }\n     }\n \n     fn encode_super_predicates(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_super_predicates({:?})\", def_id);\n-        record!(self.per_def.super_predicates[def_id] <- self.tcx.super_predicates_of(def_id));\n+        record!(self.tables.super_predicates[def_id] <- self.tcx.super_predicates_of(def_id));\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n@@ -822,7 +826,7 @@ impl EncodeContext<'tcx> {\n             hir::Defaultness::Final => span_bug!(ast_item.span, \"traits cannot have final items\"),\n         };\n \n-        record!(self.per_def.kind[def_id] <- match trait_item.kind {\n+        record!(self.tables.kind[def_id] <- match trait_item.kind {\n             ty::AssocKind::Const => {\n                 let rendered = rustc_hir_pretty::to_string(\n                     &(&self.tcx.hir() as &dyn intravisit::Map<'_>),\n@@ -863,9 +867,9 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::Type => EntryKind::AssocType(container),\n             ty::AssocKind::OpaqueTy => span_bug!(ast_item.span, \"opaque type in trait\"),\n         });\n-        record!(self.per_def.visibility[def_id] <- trait_item.vis);\n-        record!(self.per_def.span[def_id] <- ast_item.span);\n-        record!(self.per_def.attributes[def_id] <- ast_item.attrs);\n+        record!(self.tables.visibility[def_id] <- trait_item.vis);\n+        record!(self.tables.span[def_id] <- ast_item.span);\n+        record!(self.tables.attributes[def_id] <- ast_item.attrs);\n         self.encode_ident_span(def_id, ast_item.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n@@ -882,7 +886,7 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::OpaqueTy => unreachable!(),\n         }\n         if trait_item.kind == ty::AssocKind::Method {\n-            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -915,7 +919,7 @@ impl EncodeContext<'tcx> {\n             }\n         };\n \n-        record!(self.per_def.kind[def_id] <- match impl_item.kind {\n+        record!(self.tables.kind[def_id] <- match impl_item.kind {\n             ty::AssocKind::Const => {\n                 if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n                     let qualifs = self.tcx.at(ast_item.span).mir_const_qualif(def_id);\n@@ -947,16 +951,16 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::OpaqueTy => EntryKind::AssocOpaqueTy(container),\n             ty::AssocKind::Type => EntryKind::AssocType(container)\n         });\n-        record!(self.per_def.visibility[def_id] <- impl_item.vis);\n-        record!(self.per_def.span[def_id] <- ast_item.span);\n-        record!(self.per_def.attributes[def_id] <- ast_item.attrs);\n+        record!(self.tables.visibility[def_id] <- impl_item.vis);\n+        record!(self.tables.span[def_id] <- ast_item.span);\n+        record!(self.tables.attributes[def_id] <- ast_item.attrs);\n         self.encode_ident_span(def_id, impl_item.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if impl_item.kind == ty::AssocKind::Method {\n-            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -1001,14 +1005,14 @@ impl EncodeContext<'tcx> {\n     fn encode_optimized_mir(&mut self, def_id: DefId) {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n-            record!(self.per_def.mir[def_id] <- self.tcx.optimized_mir(def_id));\n+            record!(self.tables.mir[def_id] <- self.tcx.optimized_mir(def_id));\n         }\n     }\n \n     fn encode_promoted_mir(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_promoted_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n-            record!(self.per_def.promoted_mir[def_id] <- self.tcx.promoted_mir(def_id));\n+            record!(self.tables.promoted_mir[def_id] <- self.tcx.promoted_mir(def_id));\n         }\n     }\n \n@@ -1017,7 +1021,7 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_inherent_implementations({:?})\", def_id);\n         let implementations = self.tcx.inherent_impls(def_id);\n         if !implementations.is_empty() {\n-            record!(self.per_def.inherent_impls[def_id] <- implementations.iter().map(|&def_id| {\n+            record!(self.tables.inherent_impls[def_id] <- implementations.iter().map(|&def_id| {\n                 assert!(def_id.is_local());\n                 def_id.index\n             }));\n@@ -1027,21 +1031,21 @@ impl EncodeContext<'tcx> {\n     fn encode_stability(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_stability({:?})\", def_id);\n         if let Some(stab) = self.tcx.lookup_stability(def_id) {\n-            record!(self.per_def.stability[def_id] <- stab)\n+            record!(self.tables.stability[def_id] <- stab)\n         }\n     }\n \n     fn encode_const_stability(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_const_stability({:?})\", def_id);\n         if let Some(stab) = self.tcx.lookup_const_stability(def_id) {\n-            record!(self.per_def.const_stability[def_id] <- stab)\n+            record!(self.tables.const_stability[def_id] <- stab)\n         }\n     }\n \n     fn encode_deprecation(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n         if let Some(depr) = self.tcx.lookup_deprecation(def_id) {\n-            record!(self.per_def.deprecation[def_id] <- depr);\n+            record!(self.tables.deprecation[def_id] <- depr);\n         }\n     }\n \n@@ -1062,7 +1066,7 @@ impl EncodeContext<'tcx> {\n \n         self.encode_ident_span(def_id, item.ident);\n \n-        record!(self.per_def.kind[def_id] <- match item.kind {\n+        record!(self.tables.kind[def_id] <- match item.kind {\n             hir::ItemKind::Static(_, hir::Mutability::Mut, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::Mutability::Not, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n@@ -1168,26 +1172,26 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         });\n-        record!(self.per_def.visibility[def_id] <-\n+        record!(self.tables.visibility[def_id] <-\n             ty::Visibility::from_hir(&item.vis, item.hir_id, tcx));\n-        record!(self.per_def.span[def_id] <- item.span);\n-        record!(self.per_def.attributes[def_id] <- item.attrs);\n+        record!(self.tables.span[def_id] <- item.span);\n+        record!(self.tables.attributes[def_id] <- item.attrs);\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n-            hir::ItemKind::ForeignMod(ref fm) => record!(self.per_def.children[def_id] <-\n+            hir::ItemKind::ForeignMod(ref fm) => record!(self.tables.children[def_id] <-\n                 fm.items\n                     .iter()\n                     .map(|foreign_item| tcx.hir().local_def_id(\n                         foreign_item.hir_id).index)\n             ),\n-            hir::ItemKind::Enum(..) => record!(self.per_def.children[def_id] <-\n+            hir::ItemKind::Enum(..) => record!(self.tables.children[def_id] <-\n                 self.tcx.adt_def(def_id).variants.iter().map(|v| {\n                     assert!(v.def_id.is_local());\n                     v.def_id.index\n                 })\n             ),\n             hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                record!(self.per_def.children[def_id] <-\n+                record!(self.tables.children[def_id] <-\n                     self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {\n                         assert!(f.did.is_local());\n                         f.did.index\n@@ -1196,7 +1200,7 @@ impl EncodeContext<'tcx> {\n             }\n             hir::ItemKind::Impl { .. } | hir::ItemKind::Trait(..) => {\n                 let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n-                record!(self.per_def.children[def_id] <-\n+                record!(self.tables.children[def_id] <-\n                     associated_item_def_ids.iter().map(|&def_id| {\n                         assert!(def_id.is_local());\n                         def_id.index\n@@ -1221,11 +1225,11 @@ impl EncodeContext<'tcx> {\n             _ => {}\n         }\n         if let hir::ItemKind::Fn(..) = item.kind {\n-            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n         if let hir::ItemKind::Impl { .. } = item.kind {\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n-                record!(self.per_def.impl_trait_ref[def_id] <- trait_ref);\n+                record!(self.tables.impl_trait_ref[def_id] <- trait_ref);\n             }\n         }\n         self.encode_inherent_implementations(def_id);\n@@ -1284,19 +1288,19 @@ impl EncodeContext<'tcx> {\n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef<'_>) {\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n-        record!(self.per_def.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n-        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n-        record!(self.per_def.span[def_id] <- macro_def.span);\n-        record!(self.per_def.attributes[def_id] <- macro_def.attrs);\n+        record!(self.tables.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n+        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.tables.span[def_id] <- macro_def.span);\n+        record!(self.tables.attributes[def_id] <- macro_def.attrs);\n         self.encode_ident_span(def_id, macro_def.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n     }\n \n     fn encode_info_for_generic_param(&mut self, def_id: DefId, kind: EntryKind, encode_type: bool) {\n-        record!(self.per_def.kind[def_id] <- kind);\n-        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.kind[def_id] <- kind);\n+        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         if encode_type {\n             self.encode_item_type(def_id);\n         }\n@@ -1310,7 +1314,7 @@ impl EncodeContext<'tcx> {\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n         let ty = self.tcx.typeck_tables_of(def_id).node_type(hir_id);\n \n-        record!(self.per_def.kind[def_id] <- match ty.kind {\n+        record!(self.tables.kind[def_id] <- match ty.kind {\n             ty::Generator(..) => {\n                 let data = self.tcx.generator_kind(def_id).unwrap();\n                 EntryKind::Generator(data)\n@@ -1320,12 +1324,12 @@ impl EncodeContext<'tcx> {\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         });\n-        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n+        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n         self.encode_item_type(def_id);\n         if let ty::Closure(def_id, substs) = ty.kind {\n-            record!(self.per_def.fn_sig[def_id] <- substs.as_closure().sig());\n+            record!(self.tables.fn_sig[def_id] <- substs.as_closure().sig());\n         }\n         self.encode_generics(def_id);\n         self.encode_optimized_mir(def_id);\n@@ -1339,9 +1343,9 @@ impl EncodeContext<'tcx> {\n         let const_data = self.encode_rendered_const_for_body(body_id);\n         let qualifs = self.tcx.mir_const_qualif(def_id);\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Const(qualifs, const_data));\n-        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.kind[def_id] <- EntryKind::Const(qualifs, const_data));\n+        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         self.encode_item_type(def_id);\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n@@ -1512,7 +1516,7 @@ impl EncodeContext<'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_foreign_item({:?})\", def_id);\n \n-        record!(self.per_def.kind[def_id] <- match nitem.kind {\n+        record!(self.tables.kind[def_id] <- match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     asyncness: hir::IsAsync::NotAsync,\n@@ -1529,17 +1533,17 @@ impl EncodeContext<'tcx> {\n             hir::ForeignItemKind::Static(_, hir::Mutability::Not) => EntryKind::ForeignImmStatic,\n             hir::ForeignItemKind::Type => EntryKind::ForeignType,\n         });\n-        record!(self.per_def.visibility[def_id] <-\n+        record!(self.tables.visibility[def_id] <-\n             ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, self.tcx));\n-        record!(self.per_def.span[def_id] <- nitem.span);\n-        record!(self.per_def.attributes[def_id] <- nitem.attrs);\n+        record!(self.tables.span[def_id] <- nitem.span);\n+        record!(self.tables.attributes[def_id] <- nitem.attrs);\n         self.encode_ident_span(def_id, nitem.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n-            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -1619,17 +1623,14 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr<'_>) {\n-        match expr.kind {\n-            hir::ExprKind::Closure(..) => {\n-                let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n-                self.encode_info_for_closure(def_id);\n-            }\n-            _ => {}\n+        if let hir::ExprKind::Closure(..) = expr.kind {\n+            let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n+            self.encode_info_for_closure(def_id);\n         }\n     }\n \n     fn encode_ident_span(&mut self, def_id: DefId, ident: Ident) {\n-        record!(self.per_def.ident_span[def_id] <- ident.span);\n+        record!(self.tables.ident_span[def_id] <- ident.span);\n     }\n \n     /// In some cases, along with the item itself, we also\n@@ -1845,7 +1846,7 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     let mut ecx = EncodeContext {\n         opaque: encoder,\n         tcx,\n-        per_def: Default::default(),\n+        tables: Default::default(),\n         lazy_state: LazyState::NoNode,\n         type_shorthands: Default::default(),\n         predicate_shorthands: Default::default(),"}, {"sha": "71872d53a56e7ec270b01569f332968ccc4a0df2", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,20 +1,20 @@\n use decoder::Metadata;\n use table::{Table, TableBuilder};\n \n-use rustc::hir::exports::Export;\n-use rustc::middle::cstore::{DepKind, ForeignModule, LinkagePreference, NativeLibrary};\n-use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n-use rustc::middle::lang_items;\n-use rustc::mir;\n-use rustc::ty::{self, ReprOptions, Ty};\n use rustc_ast::ast::{self, MacroDef};\n use rustc_attr as attr;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, DefIndex};\n+use rustc_hir::lang_items;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::hir::exports::Export;\n+use rustc_middle::middle::cstore::{DepKind, ForeignModule, LinkagePreference, NativeLibrary};\n+use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n+use rustc_middle::mir;\n+use rustc_middle::ty::{self, ReprOptions, Ty};\n use rustc_serialize::opaque::Encoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_session::CrateDisambiguator;\n@@ -197,7 +197,7 @@ crate struct CrateRoot<'tcx> {\n     impls: Lazy<[TraitImpls]>,\n     interpret_alloc_index: Lazy<[u32]>,\n \n-    per_def: LazyPerDefTables<'tcx>,\n+    tables: LazyTables<'tcx>,\n \n     /// The DefIndex's of any proc macros declared by this crate.\n     proc_macro_data: Option<Lazy<[DefIndex]>>,\n@@ -228,30 +228,30 @@ crate struct TraitImpls {\n     impls: Lazy<[DefIndex]>,\n }\n \n-/// Define `LazyPerDefTables` and `PerDefTableBuilders` at the same time.\n-macro_rules! define_per_def_tables {\n+/// Define `LazyTables` and `TableBuilders` at the same time.\n+macro_rules! define_tables {\n     ($($name:ident: Table<DefIndex, $T:ty>),+ $(,)?) => {\n         #[derive(RustcEncodable, RustcDecodable)]\n-        crate struct LazyPerDefTables<'tcx> {\n+        crate struct LazyTables<'tcx> {\n             $($name: Lazy!(Table<DefIndex, $T>)),+\n         }\n \n         #[derive(Default)]\n-        struct PerDefTableBuilders<'tcx> {\n+        struct TableBuilders<'tcx> {\n             $($name: TableBuilder<DefIndex, $T>),+\n         }\n \n-        impl PerDefTableBuilders<'tcx> {\n-            fn encode(&self, buf: &mut Encoder) -> LazyPerDefTables<'tcx> {\n-                LazyPerDefTables {\n+        impl TableBuilders<'tcx> {\n+            fn encode(&self, buf: &mut Encoder) -> LazyTables<'tcx> {\n+                LazyTables {\n                     $($name: self.$name.encode(buf)),+\n                 }\n             }\n         }\n     }\n }\n \n-define_per_def_tables! {\n+define_tables! {\n     kind: Table<DefIndex, Lazy<EntryKind>>,\n     visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n     span: Table<DefIndex, Lazy<Span>>,"}, {"sha": "dd322b9da952bcb3a8e756fd7273aa18706432f9", "filename": "src/librustc_middle/Cargo.toml", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2FCargo.toml?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,11 +1,11 @@\n [package]\n authors = [\"The Rust Project Developers\"]\n-name = \"rustc\"\n+name = \"rustc_middle\"\n version = \"0.0.0\"\n edition = \"2018\"\n \n [lib]\n-name = \"rustc\"\n+name = \"rustc_middle\"\n path = \"lib.rs\"\n doctest = false\n ", "previous_filename": "src/librustc/Cargo.toml"}, {"sha": "de58f546cd3b5d1fb053c5a2fd8bd2d03e3a4b55", "filename": "src/librustc_middle/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2FREADME.md?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/README.md"}, {"sha": "e3dec59478c1f6095e44397f6fe0e4e4c60ac65c", "filename": "src/librustc_middle/arena.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -0,0 +1,132 @@\n+/// This declares a list of types which can be allocated by `Arena`.\n+///\n+/// The `few` modifier will cause allocation to use the shared arena and recording the destructor.\n+/// This is faster and more memory efficient if there's only a few allocations of the type.\n+/// Leaving `few` out will cause the type to get its own dedicated `TypedArena` which is\n+/// faster and more memory efficient if there is lots of allocations.\n+///\n+/// Specifying the `decode` modifier will add decode impls for &T and &[T] where T is the type\n+/// listed. These impls will appear in the implement_ty_decoder! macro.\n+#[macro_export]\n+macro_rules! arena_types {\n+    ($macro:path, $args:tt, $tcx:lifetime) => (\n+        $macro!($args, [\n+            [] layouts: rustc_target::abi::Layout,\n+            [] generics: rustc_middle::ty::Generics,\n+            [] trait_def: rustc_middle::ty::TraitDef,\n+            [] adt_def: rustc_middle::ty::AdtDef,\n+            [] steal_mir: rustc_middle::ty::steal::Steal<rustc_middle::mir::BodyAndCache<$tcx>>,\n+            [] mir: rustc_middle::mir::BodyAndCache<$tcx>,\n+            [] steal_promoted: rustc_middle::ty::steal::Steal<\n+                rustc_index::vec::IndexVec<\n+                    rustc_middle::mir::Promoted,\n+                    rustc_middle::mir::BodyAndCache<$tcx>\n+                >\n+            >,\n+            [] promoted: rustc_index::vec::IndexVec<\n+                rustc_middle::mir::Promoted,\n+                rustc_middle::mir::BodyAndCache<$tcx>\n+            >,\n+            [decode] tables: rustc_middle::ty::TypeckTables<$tcx>,\n+            [decode] borrowck_result: rustc_middle::mir::BorrowCheckResult<$tcx>,\n+            [] const_allocs: rustc_middle::mir::interpret::Allocation,\n+            [] vtable_method: Option<(\n+                rustc_hir::def_id::DefId,\n+                rustc_middle::ty::subst::SubstsRef<$tcx>\n+            )>,\n+            [few, decode] mir_keys: rustc_hir::def_id::DefIdSet,\n+            [decode] specialization_graph: rustc_middle::traits::specialization_graph::Graph,\n+            [] region_scope_tree: rustc_middle::middle::region::ScopeTree,\n+            [] item_local_set: rustc_hir::ItemLocalSet,\n+            [decode] mir_const_qualif: rustc_index::bit_set::BitSet<rustc_middle::mir::Local>,\n+            [] trait_impls_of: rustc_middle::ty::trait_def::TraitImpls,\n+            [] associated_items: rustc_middle::ty::AssociatedItems,\n+            [] dropck_outlives:\n+                rustc_middle::infer::canonical::Canonical<'tcx,\n+                    rustc_middle::infer::canonical::QueryResponse<'tcx,\n+                        rustc_middle::traits::query::DropckOutlivesResult<'tcx>\n+                    >\n+                >,\n+            [] normalize_projection_ty:\n+                rustc_middle::infer::canonical::Canonical<'tcx,\n+                    rustc_middle::infer::canonical::QueryResponse<'tcx,\n+                        rustc_middle::traits::query::NormalizationResult<'tcx>\n+                    >\n+                >,\n+            [] implied_outlives_bounds:\n+                rustc_middle::infer::canonical::Canonical<'tcx,\n+                    rustc_middle::infer::canonical::QueryResponse<'tcx,\n+                        Vec<rustc_middle::traits::query::OutlivesBound<'tcx>>\n+                    >\n+                >,\n+            [] type_op_subtype:\n+                rustc_middle::infer::canonical::Canonical<'tcx,\n+                    rustc_middle::infer::canonical::QueryResponse<'tcx, ()>\n+                >,\n+            [] type_op_normalize_poly_fn_sig:\n+                rustc_middle::infer::canonical::Canonical<'tcx,\n+                    rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::PolyFnSig<'tcx>>\n+                >,\n+            [] type_op_normalize_fn_sig:\n+                rustc_middle::infer::canonical::Canonical<'tcx,\n+                    rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::FnSig<'tcx>>\n+                >,\n+            [] type_op_normalize_predicate:\n+                rustc_middle::infer::canonical::Canonical<'tcx,\n+                    rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::Predicate<'tcx>>\n+                >,\n+            [] type_op_normalize_ty:\n+                rustc_middle::infer::canonical::Canonical<'tcx,\n+                    rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::Ty<'tcx>>\n+                >,\n+            [few] crate_inherent_impls: rustc_middle::ty::CrateInherentImpls,\n+            [few] upstream_monomorphizations:\n+                rustc_hir::def_id::DefIdMap<\n+                    rustc_data_structures::fx::FxHashMap<\n+                        rustc_middle::ty::subst::SubstsRef<'tcx>,\n+                        rustc_hir::def_id::CrateNum\n+                    >\n+                >,\n+            [few] diagnostic_items: rustc_data_structures::fx::FxHashMap<\n+                rustc_span::symbol::Symbol,\n+                rustc_hir::def_id::DefId,\n+            >,\n+            [few] resolve_lifetimes: rustc_middle::middle::resolve_lifetime::ResolveLifetimes,\n+            [few] lint_levels: rustc_middle::lint::LintLevelMap,\n+            [few] stability_index: rustc_middle::middle::stability::Index<'tcx>,\n+            [few] features: rustc_feature::Features,\n+            [few] all_traits: Vec<rustc_hir::def_id::DefId>,\n+            [few] privacy_access_levels: rustc_middle::middle::privacy::AccessLevels,\n+            [few] target_features_whitelist: rustc_data_structures::fx::FxHashMap<\n+                String,\n+                Option<rustc_span::symbol::Symbol>\n+            >,\n+            [few] wasm_import_module_map: rustc_data_structures::fx::FxHashMap<\n+                rustc_hir::def_id::DefId,\n+                String\n+            >,\n+            [few] get_lib_features: rustc_middle::middle::lib_features::LibFeatures,\n+            [few] defined_lib_features: rustc_hir::lang_items::LanguageItems,\n+            [few] visible_parent_map: rustc_hir::def_id::DefIdMap<rustc_hir::def_id::DefId>,\n+            [few] foreign_module: rustc_middle::middle::cstore::ForeignModule,\n+            [few] foreign_modules: Vec<rustc_middle::middle::cstore::ForeignModule>,\n+            [few] reachable_non_generics: rustc_hir::def_id::DefIdMap<\n+                rustc_middle::middle::exported_symbols::SymbolExportLevel\n+            >,\n+            [few] crate_variances: rustc_middle::ty::CrateVariancesMap<'tcx>,\n+            [few] inferred_outlives_crate: rustc_middle::ty::CratePredicatesMap<'tcx>,\n+            [] upvars: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n+\n+            // Interned types\n+            [] tys: rustc_middle::ty::TyS<$tcx>,\n+\n+            // HIR query types\n+            [few] indexed_hir: rustc_middle::hir::map::IndexedHir<$tcx>,\n+            [few] hir_definitions: rustc_hir::definitions::Definitions,\n+            [] hir_owner: rustc_middle::hir::Owner<$tcx>,\n+            [] hir_owner_nodes: rustc_middle::hir::OwnerNodes<$tcx>,\n+        ], $tcx);\n+    )\n+}\n+\n+arena_types!(arena::declare_arena, [], 'tcx);"}, {"sha": "237751bcbd787a34c66a400ed6a7d0c6c8e84994", "filename": "src/librustc_middle/benches/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fbenches%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/benches/lib.rs"}, {"sha": "af7723aea34e466edfd582741d409baec623c5ea", "filename": "src/librustc_middle/build.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fbuild.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/build.rs"}, {"sha": "f4a4aab844c1475cc9d30cdbf2d48e0fe493a722", "filename": "src/librustc_middle/dep_graph/dep_node.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/dep_graph/dep_node.rs"}, {"sha": "f56df19bfb0617e1ac89f2799015c02dda05c3c3", "filename": "src/librustc_middle/dep_graph/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/dep_graph/mod.rs"}, {"sha": "4c144a54d6345ef9c9b7c3d07134ef71192ade8b", "filename": "src/librustc_middle/hir/exports.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fhir%2Fexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fhir%2Fexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fexports.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/hir/exports.rs"}, {"sha": "7024e86f95d06a169dabcd2675c3cad5d6b7cb03", "filename": "src/librustc_middle/hir/map/blocks.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fblocks.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/hir/map/blocks.rs"}, {"sha": "70ea856498de4def00c12ea80b1e381f7e1df649", "filename": "src/librustc_middle/hir/map/collector.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fcollector.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/hir/map/collector.rs"}, {"sha": "e8ce13e06e9f55b62a36e666d14a7ac56d4d2fd3", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/hir/map/mod.rs"}, {"sha": "ce8e1f48daa77dcf5c0e925b90e743c3a7dca14b", "filename": "src/librustc_middle/hir/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/hir/mod.rs"}, {"sha": "d58aa383667e45afc1846953cc6f8934f2839434", "filename": "src/librustc_middle/ich/hcx.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fhcx.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/ich/hcx.rs"}, {"sha": "f668cc99754f4e2265c20841b490fbcb75cafd91", "filename": "src/librustc_middle/ich/impls_hir.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_hir.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/ich/impls_hir.rs"}, {"sha": "c5a4b53b10df85487663ba4d1bb238ff21aea3ea", "filename": "src/librustc_middle/ich/impls_syntax.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_syntax.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/ich/impls_syntax.rs"}, {"sha": "226277e440a78d47b30082cb7b8e9af2b0e89e8b", "filename": "src/librustc_middle/ich/impls_ty.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -1,5 +1,5 @@\n //! This module contains `HashStable` implementations for various data types\n-//! from rustc::ty in no particular order.\n+//! from `rustc_middle::ty` in no particular order.\n \n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::middle::region;", "previous_filename": "src/librustc/ich/impls_ty.rs"}, {"sha": "c8fb2bf39cc80025f6fab13fbbaa189ceb58b03d", "filename": "src/librustc_middle/ich/mod.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -4,7 +4,6 @@ pub use self::hcx::{\n     hash_stable_trait_impls, NodeIdHashingMode, StableHashingContext, StableHashingContextProvider,\n };\n use rustc_span::symbol::{sym, Symbol};\n-pub use rustc_span::CachingSourceMapView;\n \n mod hcx;\n ", "previous_filename": "src/librustc/ich/mod.rs"}, {"sha": "5f7e8c849653c50f904f9e1ae45181f132f1308c", "filename": "src/librustc_middle/infer/canonical.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Finfer%2Fcanonical.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/infer/canonical.rs"}, {"sha": "497d3811f281b0af514163f092e46969f40dabc6", "filename": "src/librustc_middle/infer/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Finfer%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/infer/mod.rs"}, {"sha": "e205453a48c535176a9cec03853151f2c41d9127", "filename": "src/librustc_middle/infer/unify_key.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Finfer%2Funify_key.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/infer/unify_key.rs"}, {"sha": "4ed03fd21ad18b46ad0bb452f57c0ca5c9fd362c", "filename": "src/librustc_middle/lib.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -92,5 +92,5 @@ pub mod util {\n     pub mod common;\n }\n \n-// Allows macros to refer to this crate as `::rustc`\n-extern crate self as rustc;\n+// Allows macros to refer to this crate as `::rustc_middle`\n+extern crate self as rustc_middle;", "previous_filename": "src/librustc/lib.rs"}, {"sha": "53061436de07a72d1abf647c451bb061f15f4c6d", "filename": "src/librustc_middle/lint.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flint.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/lint.rs"}, {"sha": "88ddd96eec8f5e66a61c1582bad4bd5b035d7ed0", "filename": "src/librustc_middle/macros.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmacros.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/macros.rs"}, {"sha": "61b25cc4864465e3ae2fe9abe8c01b24bd2e0527", "filename": "src/librustc_middle/middle/codegen_fn_attrs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/middle/codegen_fn_attrs.rs"}, {"sha": "012390e8f74b8712477d9e4972966306b16cc4af", "filename": "src/librustc_middle/middle/cstore.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/middle/cstore.rs"}, {"sha": "ee5f822d3134c69267363292b1caab4b78b49b23", "filename": "src/librustc_middle/middle/dependency_format.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/middle/dependency_format.rs"}, {"sha": "1f4318fa537514bf33c0726f49e4db3bb188440a", "filename": "src/librustc_middle/middle/exported_symbols.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fexported_symbols.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/middle/exported_symbols.rs"}, {"sha": "62ccd94674488277ac66f6b3a405a8394e3fb50d", "filename": "src/librustc_middle/middle/free_region.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Ffree_region.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/middle/free_region.rs"}, {"sha": "0f98c338c16b149f036a443c71b1e85e4ff4075d", "filename": "src/librustc_middle/middle/lang_items.rs", "status": "renamed", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Flang_items.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -7,17 +7,13 @@\n //! * Traits that represent operators; e.g., `Add`, `Sub`, `Index`.\n //! * Functions called by the compiler itself.\n \n-pub use self::LangItem::*;\n-\n use crate::ty::{self, TyCtxt};\n \n use rustc_hir::def_id::DefId;\n+use rustc_hir::LangItem;\n use rustc_span::Span;\n use rustc_target::spec::PanicStrategy;\n \n-pub use rustc_hir::weak_lang_items::link_name;\n-pub use rustc_hir::{LangItem, LanguageItems};\n-\n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n     /// If not found, fatally aborts compilation.", "previous_filename": "src/librustc/middle/lang_items.rs"}, {"sha": "c43c22cd61ba64eb107af9e0ebbc58ef308af0e6", "filename": "src/librustc_middle/middle/limits.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "patch": "@@ -5,7 +5,7 @@\n //! this via an attribute on the crate like `#![recursion_limit=\"22\"]`. This pass\n //! just peeks and looks for that attribute.\n \n-use rustc::bug;\n+use crate::bug;\n use rustc_ast::ast;\n use rustc_data_structures::sync::Once;\n use rustc_session::Session;", "previous_filename": "src/librustc/middle/limits.rs"}, {"sha": "464488964afb7b3c17e1c1b1054155d97472b2b0", "filename": "src/librustc_middle/middle/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fmod.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/middle/mod.rs"}, {"sha": "4756e83b5e9805982b096ea134d47449a5c2cc2d", "filename": "src/librustc_middle/middle/privacy.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa223304dc130c5ace18d48c53b192b14088862e/src%2Flibrustc_middle%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fprivacy.rs?ref=aa223304dc130c5ace18d48c53b192b14088862e", "previous_filename": "src/librustc/middle/privacy.rs"}]}