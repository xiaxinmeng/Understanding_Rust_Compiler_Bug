{"sha": "17f1db672ef5fa3200a2e21791ad3ed3d174b6ac", "node_id": "C_kwDOAAsO6NoAKDE3ZjFkYjY3MmVmNWZhMzIwMGEyZTIxNzkxYWQzZWQzZDE3NGI2YWM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-01-29T15:16:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-23T19:49:38Z"}, "message": "Extract parse_stability and parse_unstability.", "tree": {"sha": "d32416535ba44ce0c6294c276c35572d83fa6272", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d32416535ba44ce0c6294c276c35572d83fa6272"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17f1db672ef5fa3200a2e21791ad3ed3d174b6ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17f1db672ef5fa3200a2e21791ad3ed3d174b6ac", "html_url": "https://github.com/rust-lang/rust/commit/17f1db672ef5fa3200a2e21791ad3ed3d174b6ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17f1db672ef5fa3200a2e21791ad3ed3d174b6ac/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df7fd9995f10627f25ccb325f693a11b3395a73c", "url": "https://api.github.com/repos/rust-lang/rust/commits/df7fd9995f10627f25ccb325f693a11b3395a73c", "html_url": "https://github.com/rust-lang/rust/commit/df7fd9995f10627f25ccb325f693a11b3395a73c"}], "stats": {"total": 429, "additions": 224, "deletions": 205}, "files": [{"sha": "08d75d857795aaaf0f6cd93a7d2fe2ee514dcb8d", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 224, "deletions": 205, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/17f1db672ef5fa3200a2e21791ad3ed3d174b6ac/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17f1db672ef5fa3200a2e21791ad3ed3d174b6ac/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=17f1db672ef5fa3200a2e21791ad3ed3d174b6ac", "patch": "@@ -245,15 +245,13 @@ fn find_stability_generic<'a, I>(\n where\n     I: Iterator<Item = &'a Attribute>,\n {\n-    use StabilityLevel::*;\n-\n     let mut stab: Option<(Stability, Span)> = None;\n     let mut const_stab: Option<(ConstStability, Span)> = None;\n     let mut body_stab: Option<(DefaultBodyStability, Span)> = None;\n     let mut promotable = false;\n     let mut allowed_through_unstable_modules = false;\n \n-    'outer: for attr in attrs_iter {\n+    for attr in attrs_iter {\n         if ![\n             sym::rustc_const_unstable,\n             sym::rustc_const_stable,\n@@ -275,27 +273,7 @@ where\n             promotable = true;\n         } else if attr.has_name(sym::rustc_allowed_through_unstable_modules) {\n             allowed_through_unstable_modules = true;\n-        }\n-        // attributes with data\n-        else if let Some(meta @ MetaItem { kind: MetaItemKind::List(metas), .. }) = &meta {\n-            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n-                if item.is_some() {\n-                    handle_errors(\n-                        &sess.parse_sess,\n-                        meta.span,\n-                        AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n-                    );\n-                    return false;\n-                }\n-                if let Some(v) = meta.value_str() {\n-                    *item = Some(v);\n-                    true\n-                } else {\n-                    sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n-                    false\n-                }\n-            };\n-\n+        } else if let Some(meta) = &meta {\n             let meta_name = meta.name_or_empty();\n             match meta_name {\n                 sym::rustc_const_unstable | sym::rustc_default_body_unstable | sym::unstable => {\n@@ -322,122 +300,18 @@ where\n                         break;\n                     }\n \n-                    let mut feature = None;\n-                    let mut reason = None;\n-                    let mut issue = None;\n-                    let mut issue_num = None;\n-                    let mut is_soft = false;\n-                    let mut implied_by = None;\n-                    for meta in metas {\n-                        let Some(mi) = meta.meta_item() else {\n-                            handle_errors(\n-                                &sess.parse_sess,\n-                                meta.span(),\n-                                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n-                            );\n-                            continue 'outer;\n-                        };\n-                        match mi.name_or_empty() {\n-                            sym::feature => {\n-                                if !get(mi, &mut feature) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            sym::reason => {\n-                                if !get(mi, &mut reason) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            sym::issue => {\n-                                if !get(mi, &mut issue) {\n-                                    continue 'outer;\n-                                }\n-\n-                                // These unwraps are safe because `get` ensures the meta item\n-                                // is a name/value pair string literal.\n-                                issue_num = match issue.unwrap().as_str() {\n-                                    \"none\" => None,\n-                                    issue => match issue.parse::<NonZeroU32>() {\n-                                        Ok(num) => Some(num),\n-                                        Err(err) => {\n-                                            sess.emit_err(\n-                                                session_diagnostics::InvalidIssueString {\n-                                                    span: mi.span,\n-                                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n-                                                        mi.name_value_literal_span().unwrap(),\n-                                                        err.kind(),\n-                                                    ),\n-                                                },\n-                                            );\n-                                            continue 'outer;\n-                                        }\n-                                    },\n-                                };\n-                            }\n-                            sym::soft => {\n-                                if !mi.is_word() {\n-                                    sess.emit_err(session_diagnostics::SoftNoArgs {\n-                                        span: mi.span,\n-                                    });\n-                                }\n-                                is_soft = true;\n-                            }\n-                            sym::implied_by => {\n-                                if !get(mi, &mut implied_by) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            _ => {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    meta.span(),\n-                                    AttrError::UnknownMetaItem(\n-                                        pprust::path_to_string(&mi.path),\n-                                        &[\"feature\", \"reason\", \"issue\", \"soft\"],\n-                                    ),\n-                                );\n-                                continue 'outer;\n-                            }\n-                        }\n-                    }\n-\n-                    match (feature, reason, issue) {\n-                        (Some(feature), reason, Some(_)) => {\n-                            if !rustc_lexer::is_ident(feature.as_str()) {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    attr.span,\n-                                    AttrError::NonIdentFeature,\n-                                );\n-                                continue;\n-                            }\n-                            let level = Unstable {\n-                                reason: UnstableReason::from_opt_reason(reason),\n-                                issue: issue_num,\n-                                is_soft,\n-                                implied_by,\n-                            };\n-                            if sym::unstable == meta_name {\n-                                stab = Some((Stability { level, feature }, attr.span));\n-                            } else if sym::rustc_const_unstable == meta_name {\n-                                const_stab = Some((\n-                                    ConstStability { level, feature, promotable: false },\n-                                    attr.span,\n-                                ));\n-                            } else if sym::rustc_default_body_unstable == meta_name {\n-                                body_stab =\n-                                    Some((DefaultBodyStability { level, feature }, attr.span));\n-                            } else {\n-                                unreachable!(\"Unknown stability attribute {meta_name}\");\n-                            }\n-                        }\n-                        (None, _, _) => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n-                            continue;\n-                        }\n-                        _ => {\n-                            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n-                            continue;\n+                    if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                        if sym::unstable == meta_name {\n+                            stab = Some((Stability { level, feature }, attr.span));\n+                        } else if sym::rustc_const_unstable == meta_name {\n+                            const_stab = Some((\n+                                ConstStability { level, feature, promotable: false },\n+                                attr.span,\n+                            ));\n+                        } else if sym::rustc_default_body_unstable == meta_name {\n+                            body_stab = Some((DefaultBodyStability { level, feature }, attr.span));\n+                        } else {\n+                            unreachable!(\"Unknown stability attribute {meta_name}\");\n                         }\n                     }\n                 }\n@@ -457,71 +331,14 @@ where\n                         );\n                         break;\n                     }\n-\n-                    let mut feature = None;\n-                    let mut since = None;\n-                    for meta in metas {\n-                        match meta {\n-                            NestedMetaItem::MetaItem(mi) => match mi.name_or_empty() {\n-                                sym::feature => {\n-                                    if !get(mi, &mut feature) {\n-                                        continue 'outer;\n-                                    }\n-                                }\n-                                sym::since => {\n-                                    if !get(mi, &mut since) {\n-                                        continue 'outer;\n-                                    }\n-                                }\n-                                _ => {\n-                                    handle_errors(\n-                                        &sess.parse_sess,\n-                                        meta.span(),\n-                                        AttrError::UnknownMetaItem(\n-                                            pprust::path_to_string(&mi.path),\n-                                            &[\"feature\", \"since\"],\n-                                        ),\n-                                    );\n-                                    continue 'outer;\n-                                }\n-                            },\n-                            NestedMetaItem::Lit(lit) => {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    lit.span,\n-                                    AttrError::UnsupportedLiteral(\n-                                        UnsupportedLiteralReason::Generic,\n-                                        false,\n-                                    ),\n-                                );\n-                                continue 'outer;\n-                            }\n-                        }\n-                    }\n-\n-                    if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n-                        since = Some(rust_version_symbol());\n-                    }\n-\n-                    match (feature, since) {\n-                        (Some(feature), Some(since)) => {\n-                            let level = Stable { since, allowed_through_unstable_modules: false };\n-                            if sym::stable == meta_name {\n-                                stab = Some((Stability { level, feature }, attr.span));\n-                            } else {\n-                                const_stab = Some((\n-                                    ConstStability { level, feature, promotable: false },\n-                                    attr.span,\n-                                ));\n-                            }\n-                        }\n-                        (None, _) => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n-                            continue;\n-                        }\n-                        _ => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n-                            continue;\n+                    if let Some((feature, level)) = parse_stability(sess, attr) {\n+                        if sym::stable == meta_name {\n+                            stab = Some((Stability { level, feature }, attr.span));\n+                        } else {\n+                            const_stab = Some((\n+                                ConstStability { level, feature, promotable: false },\n+                                attr.span,\n+                            ));\n                         }\n                     }\n                 }\n@@ -556,6 +373,208 @@ where\n     (stab, const_stab, body_stab)\n }\n \n+fn parse_stability(sess: &Session, attr: &Attribute) -> Option<(Symbol, StabilityLevel)> {\n+    let meta = attr.meta()?;\n+    let MetaItem { kind: MetaItemKind::List(ref metas), .. } = meta else { return None };\n+    let insert = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+        if item.is_some() {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span,\n+                AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+            );\n+            return false;\n+        }\n+        if let Some(v) = meta.value_str() {\n+            *item = Some(v);\n+            true\n+        } else {\n+            sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n+            false\n+        }\n+    };\n+\n+    let mut feature = None;\n+    let mut since = None;\n+    for meta in metas {\n+        let Some(mi) = meta.meta_item() else {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span(),\n+                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n+            );\n+            return None;\n+        };\n+\n+        match mi.name_or_empty() {\n+            sym::feature => {\n+                if !insert(mi, &mut feature) {\n+                    return None;\n+                }\n+            }\n+            sym::since => {\n+                if !insert(mi, &mut since) {\n+                    return None;\n+                }\n+            }\n+            _ => {\n+                handle_errors(\n+                    &sess.parse_sess,\n+                    meta.span(),\n+                    AttrError::UnknownMetaItem(\n+                        pprust::path_to_string(&mi.path),\n+                        &[\"feature\", \"since\"],\n+                    ),\n+                );\n+                return None;\n+            }\n+        }\n+    }\n+\n+    if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n+        since = Some(rust_version_symbol());\n+    }\n+\n+    match (feature, since) {\n+        (Some(feature), Some(since)) => {\n+            let level = StabilityLevel::Stable { since, allowed_through_unstable_modules: false };\n+            Some((feature, level))\n+        }\n+        (None, _) => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n+            None\n+        }\n+        _ => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n+            None\n+        }\n+    }\n+}\n+\n+fn parse_unstability(sess: &Session, attr: &Attribute) -> Option<(Symbol, StabilityLevel)> {\n+    let meta = attr.meta()?;\n+    let MetaItem { kind: MetaItemKind::List(ref metas), .. } = meta else { return None };\n+    let insert = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+        if item.is_some() {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span,\n+                AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+            );\n+            return false;\n+        }\n+        if let Some(v) = meta.value_str() {\n+            *item = Some(v);\n+            true\n+        } else {\n+            sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n+            false\n+        }\n+    };\n+\n+    let mut feature = None;\n+    let mut reason = None;\n+    let mut issue = None;\n+    let mut issue_num = None;\n+    let mut is_soft = false;\n+    let mut implied_by = None;\n+    for meta in metas {\n+        let Some(mi) = meta.meta_item() else {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span(),\n+                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n+            );\n+            return None;\n+        };\n+\n+        match mi.name_or_empty() {\n+            sym::feature => {\n+                if !insert(mi, &mut feature) {\n+                    return None;\n+                }\n+            }\n+            sym::reason => {\n+                if !insert(mi, &mut reason) {\n+                    return None;\n+                }\n+            }\n+            sym::issue => {\n+                if !insert(mi, &mut issue) {\n+                    return None;\n+                }\n+\n+                // These unwraps are safe because `insert` ensures the meta item\n+                // is a name/value pair string literal.\n+                issue_num = match issue.unwrap().as_str() {\n+                    \"none\" => None,\n+                    issue => match issue.parse::<NonZeroU32>() {\n+                        Ok(num) => Some(num),\n+                        Err(err) => {\n+                            sess.emit_err(\n+                                session_diagnostics::InvalidIssueString {\n+                                    span: mi.span,\n+                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n+                                        mi.name_value_literal_span().unwrap(),\n+                                        err.kind(),\n+                                    ),\n+                                },\n+                            );\n+                            return None;\n+                        }\n+                    },\n+                };\n+            }\n+            sym::soft => {\n+                if !mi.is_word() {\n+                    sess.emit_err(session_diagnostics::SoftNoArgs { span: mi.span });\n+                }\n+                is_soft = true;\n+            }\n+            sym::implied_by => {\n+                if !insert(mi, &mut implied_by) {\n+                    return None;\n+                }\n+            }\n+            _ => {\n+                handle_errors(\n+                    &sess.parse_sess,\n+                    meta.span(),\n+                    AttrError::UnknownMetaItem(\n+                        pprust::path_to_string(&mi.path),\n+                        &[\"feature\", \"reason\", \"issue\", \"soft\", \"implied_by\"],\n+                    ),\n+                );\n+                return None;\n+            }\n+        }\n+    }\n+\n+    match (feature, reason, issue) {\n+        (Some(feature), reason, Some(_)) => {\n+            if !rustc_lexer::is_ident(feature.as_str()) {\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::NonIdentFeature);\n+                return None;\n+            }\n+            let level = StabilityLevel::Unstable {\n+                reason: UnstableReason::from_opt_reason(reason),\n+                issue: issue_num,\n+                is_soft,\n+                implied_by,\n+            };\n+            Some((feature, level))\n+        }\n+        (None, _, _) => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n+            return None;\n+        }\n+        _ => {\n+            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n+            return None;\n+        }\n+    }\n+}\n+\n pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n     attr::first_attr_value_str_by_name(attrs, sym::crate_name)\n }"}]}