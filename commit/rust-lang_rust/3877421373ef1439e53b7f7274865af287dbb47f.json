{"sha": "3877421373ef1439e53b7f7274865af287dbb47f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4Nzc0MjEzNzNlZjE0MzllNTNiN2Y3Mjc0ODY1YWYyODdkYmI0N2Y=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-16T20:03:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-16T20:03:41Z"}, "message": "Merge #5989\n\n5989: Rewrite import merging r=jonas-schievink a=Veykril\n\nRewrites how import merging is being handled. It is now a recursive function to properly handle merging of intermediate levels in the import trees. With this ordering the imports is also now possible tho it doesn't quite order it the same way as `rustfmt` does yet, namely it orders lowercase identifiers after uppercase identifiers as that is the standard character order that rust uses. This also fixes a few weird behaviors that were visible in some of the `replace_qualified_name_with_use.rs` tests.\r\n\r\nThis really took longer than I was hoping for, fighting with import trees is quite the exhausting task \ud83d\ude05 \n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "a7180b968598a3ef53ef9587d43fb7842a98dc1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7180b968598a3ef53ef9587d43fb7842a98dc1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3877421373ef1439e53b7f7274865af287dbb47f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfYm+dCRBK7hj4Ov3rIwAAdHIIAID8Q3aacumPx3SpS9OyYGeH\nI02+ovFf7meIh2EhxMun/lLxBa3DHg7C7PZXyCSnYCRIw1Zb0vWsD4MV5On9r5ub\nchtEGwV0OhuWEU29WShtj2iUxoo/VjvIje/jE+fa6Vyh6AcXRmQfm+mw4JebGod8\n1jCXRwnsdUhE6Gn7WsgA3Jlr6o8AOYzw0TfYPLLpF1otNYeFm6Osav6ho48+Dsm9\nwbUw94FGY1/8nWQ6ThQ/laTU8FGDKdNoCdTUUDN3KijhA8k++HJVjkudFIsoLgW4\noFKnonumA09LRaIsXFh0oAUavCC989I5y26WgMKFsDnvLJ/q4oFbiEVuXZb6PeU=\n=nkhD\n-----END PGP SIGNATURE-----\n", "payload": "tree a7180b968598a3ef53ef9587d43fb7842a98dc1a\nparent 4bc8015370e3698248bc93184ef7ec5fefd2c1d4\nparent 45298b5d2a8e7d1f962f3117de27957e393c03e2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1600286621 +0000\ncommitter GitHub <noreply@github.com> 1600286621 +0000\n\nMerge #5989\n\n5989: Rewrite import merging r=jonas-schievink a=Veykril\n\nRewrites how import merging is being handled. It is now a recursive function to properly handle merging of intermediate levels in the import trees. With this ordering the imports is also now possible tho it doesn't quite order it the same way as `rustfmt` does yet, namely it orders lowercase identifiers after uppercase identifiers as that is the standard character order that rust uses. This also fixes a few weird behaviors that were visible in some of the `replace_qualified_name_with_use.rs` tests.\r\n\r\nThis really took longer than I was hoping for, fighting with import trees is quite the exhausting task \ud83d\ude05 \n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3877421373ef1439e53b7f7274865af287dbb47f", "html_url": "https://github.com/rust-lang/rust/commit/3877421373ef1439e53b7f7274865af287dbb47f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3877421373ef1439e53b7f7274865af287dbb47f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bc8015370e3698248bc93184ef7ec5fefd2c1d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bc8015370e3698248bc93184ef7ec5fefd2c1d4", "html_url": "https://github.com/rust-lang/rust/commit/4bc8015370e3698248bc93184ef7ec5fefd2c1d4"}, {"sha": "45298b5d2a8e7d1f962f3117de27957e393c03e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/45298b5d2a8e7d1f962f3117de27957e393c03e2", "html_url": "https://github.com/rust-lang/rust/commit/45298b5d2a8e7d1f962f3117de27957e393c03e2"}], "stats": {"total": 395, "additions": 292, "deletions": 103}, "files": [{"sha": "fe33cee53c41d1c7b41cac23b0c2430647258bb1", "filename": "crates/assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3877421373ef1439e53b7f7274865af287dbb47f/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877421373ef1439e53b7f7274865af287dbb47f/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=3877421373ef1439e53b7f7274865af287dbb47f", "patch": "@@ -95,7 +95,7 @@ use std::fmt::Debug;\n use std::fmt<|>::Display;\n \",\n             r\"\n-use std::fmt::{Display, Debug};\n+use std::fmt::{Debug, Display};\n \",\n         );\n     }\n@@ -122,7 +122,7 @@ use std::fmt::{self, Display};\n use std::{fmt, <|>fmt::Display};\n \",\n             r\"\n-use std::{fmt::{Display, self}};\n+use std::{fmt::{self, Display}};\n \",\n         );\n     }\n@@ -210,13 +210,17 @@ use std::{fmt<|>::Debug, fmt::Display};\n use std::{fmt::{Debug, Display}};\n \",\n         );\n+    }\n+\n+    #[test]\n+    fn test_merge_nested2() {\n         check_assist(\n             merge_imports,\n             r\"\n use std::{fmt::Debug, fmt<|>::Display};\n \",\n             r\"\n-use std::{fmt::{Display, Debug}};\n+use std::{fmt::{Debug, Display}};\n \",\n         );\n     }\n@@ -310,9 +314,7 @@ use foo::<|>{\n };\n \",\n             r\"\n-use foo::{\n-    FooBar,\n-bar::baz};\n+use foo::{FooBar, bar::baz};\n \",\n         )\n     }"}, {"sha": "8ac907707b23da33686642bd5dda05f834bc6bb6", "filename": "crates/assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3877421373ef1439e53b7f7274865af287dbb47f/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877421373ef1439e53b7f7274865af287dbb47f/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=3877421373ef1439e53b7f7274865af287dbb47f", "patch": "@@ -312,7 +312,7 @@ impl std::fmt<|> for Foo {\n }\n     \",\n             r\"\n-use std::fmt::{Debug, self};\n+use std::fmt::{self, Debug};\n \n impl fmt for Foo {\n }\n@@ -330,9 +330,8 @@ use std::fmt::{Debug, nested::{Display}};\n impl std::fmt::nested<|> for Foo {\n }\n \",\n-            // FIXME(veykril): should be nested::{self, Display} here\n             r\"\n-use std::fmt::{Debug, nested::{Display}, nested};\n+use std::fmt::{Debug, nested::{self, Display}};\n \n impl nested for Foo {\n }\n@@ -350,9 +349,8 @@ use std::fmt::{Debug, nested::{self, Display}};\n impl std::fmt::nested<|> for Foo {\n }\n \",\n-            // FIXME(veykril): nested is duplicated now\n             r\"\n-use std::fmt::{Debug, nested::{self, Display}, nested};\n+use std::fmt::{Debug, nested::{self, Display}};\n \n impl nested for Foo {\n }\n@@ -371,7 +369,7 @@ impl std::fmt::nested::Debug<|> for Foo {\n }\n \",\n             r\"\n-use std::fmt::{Debug, nested::{Display}, nested::Debug};\n+use std::fmt::{Debug, nested::{Debug, Display}};\n \n impl Debug for Foo {\n }\n@@ -409,7 +407,7 @@ impl std::fmt::Display<|> for Foo {\n }\n \",\n             r\"\n-use std::fmt::{nested::Debug, Display};\n+use std::fmt::{Display, nested::Debug};\n \n impl Display for Foo {\n }\n@@ -429,12 +427,8 @@ use crate::{\n \n fn foo() { crate::ty::lower<|>::trait_env() }\n \",\n-            // FIXME(veykril): formatting broke here\n             r\"\n-use crate::{\n-    ty::{Substs, Ty},\n-    AssocItem,\n-ty::lower};\n+use crate::{AssocItem, ty::{Substs, Ty, lower}};\n \n fn foo() { lower::trait_env() }\n \",\n@@ -633,7 +627,7 @@ fn main() {\n }\n     \",\n             r\"\n-use std::fmt::{Display, self};\n+use std::fmt::{self, Display};\n \n fn main() {\n     fmt;"}, {"sha": "09f4a2224a01efe8937ae385b04cfdce68975723", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 272, "deletions": 84, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/3877421373ef1439e53b7f7274865af287dbb47f/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877421373ef1439e53b7f7274865af287dbb47f/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=3877421373ef1439e53b7f7274865af287dbb47f", "patch": "@@ -1,17 +1,18 @@\n //! Handle syntactic aspects of inserting a new `use`.\n-use std::iter::{self, successors};\n+use std::{\n+    cmp::Ordering,\n+    iter::{self, successors},\n+};\n \n-use algo::skip_trivia_token;\n use ast::{\n     edit::{AstNodeEdit, IndentLevel},\n     PathSegmentKind, VisibilityOwner,\n };\n use syntax::{\n     algo,\n     ast::{self, make, AstNode},\n-    Direction, InsertPosition, SyntaxElement, SyntaxNode, T,\n+    InsertPosition, SyntaxElement, SyntaxNode,\n };\n-use test_utils::mark;\n \n #[derive(Debug)]\n pub enum ImportScope {\n@@ -119,7 +120,6 @@ pub(crate) fn insert_use(\n         }\n \n         if let ident_level @ 1..=usize::MAX = scope.indent_level().0 as usize {\n-            // FIXME: this alone doesnt properly re-align all cases\n             buf.push(make::tokens::whitespace(&\" \".repeat(4 * ident_level)).into());\n         }\n         buf.push(use_item.syntax().clone().into());\n@@ -149,66 +149,123 @@ fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -\n }\n \n pub(crate) fn try_merge_imports(\n-    old: &ast::Use,\n-    new: &ast::Use,\n+    lhs: &ast::Use,\n+    rhs: &ast::Use,\n     merge_behaviour: MergeBehaviour,\n ) -> Option<ast::Use> {\n     // don't merge imports with different visibilities\n-    if !eq_visibility(old.visibility(), new.visibility()) {\n+    if !eq_visibility(lhs.visibility(), rhs.visibility()) {\n         return None;\n     }\n-    let old_tree = old.use_tree()?;\n-    let new_tree = new.use_tree()?;\n-    let merged = try_merge_trees(&old_tree, &new_tree, merge_behaviour)?;\n-    Some(old.with_use_tree(merged))\n-}\n-\n-/// Simple function that checks if a UseTreeList is deeper than one level\n-fn use_tree_list_is_nested(tl: &ast::UseTreeList) -> bool {\n-    tl.use_trees().any(|use_tree| {\n-        use_tree.use_tree_list().is_some() || use_tree.path().and_then(|p| p.qualifier()).is_some()\n-    })\n+    let lhs_tree = lhs.use_tree()?;\n+    let rhs_tree = rhs.use_tree()?;\n+    let merged = try_merge_trees(&lhs_tree, &rhs_tree, merge_behaviour)?;\n+    Some(lhs.with_use_tree(merged))\n }\n \n-// FIXME: currently this merely prepends the new tree into old, ideally it would insert the items in a sorted fashion\n pub(crate) fn try_merge_trees(\n-    old: &ast::UseTree,\n-    new: &ast::UseTree,\n-    merge_behaviour: MergeBehaviour,\n+    lhs: &ast::UseTree,\n+    rhs: &ast::UseTree,\n+    merge: MergeBehaviour,\n ) -> Option<ast::UseTree> {\n-    let lhs_path = old.path()?;\n-    let rhs_path = new.path()?;\n+    let lhs_path = lhs.path()?;\n+    let rhs_path = rhs.path()?;\n \n     let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n-    let lhs = old.split_prefix(&lhs_prefix);\n-    let rhs = new.split_prefix(&rhs_prefix);\n-    let lhs_tl = lhs.use_tree_list()?;\n-    let rhs_tl = rhs.use_tree_list()?;\n-\n-    // if we are only allowed to merge the last level check if the split off paths are only one level deep\n-    if merge_behaviour == MergeBehaviour::Last\n-        && (use_tree_list_is_nested(&lhs_tl) || use_tree_list_is_nested(&rhs_tl))\n-    {\n-        mark::hit!(test_last_merge_too_long);\n-        return None;\n-    }\n+    let lhs = lhs.split_prefix(&lhs_prefix);\n+    let rhs = rhs.split_prefix(&rhs_prefix);\n+    recursive_merge(&lhs, &rhs, merge).map(|(merged, _)| merged)\n+}\n \n-    let should_insert_comma = lhs_tl\n-        .r_curly_token()\n-        .and_then(|it| skip_trivia_token(it.prev_token()?, Direction::Prev))\n-        .map(|it| it.kind())\n-        != Some(T![,]);\n-    let mut to_insert: Vec<SyntaxElement> = Vec::new();\n-    if should_insert_comma {\n-        to_insert.push(make::token(T![,]).into());\n-        to_insert.push(make::tokens::single_space().into());\n-    }\n-    to_insert.extend(\n-        rhs_tl.syntax().children_with_tokens().filter(|it| !matches!(it.kind(), T!['{'] | T!['}'])),\n-    );\n-    let pos = InsertPosition::Before(lhs_tl.r_curly_token()?.into());\n-    let use_tree_list = lhs_tl.insert_children(pos, to_insert);\n-    Some(lhs.with_use_tree_list(use_tree_list))\n+/// Recursively \"zips\" together lhs and rhs.\n+fn recursive_merge(\n+    lhs: &ast::UseTree,\n+    rhs: &ast::UseTree,\n+    merge: MergeBehaviour,\n+) -> Option<(ast::UseTree, bool)> {\n+    let mut use_trees = lhs\n+        .use_tree_list()\n+        .into_iter()\n+        .flat_map(|list| list.use_trees())\n+        // check if any of the use trees are nested, if they are and the behaviour is `last` we are not allowed to merge this\n+        // so early exit the iterator by using Option's Intoiterator impl\n+        .map(|tree| match merge == MergeBehaviour::Last && tree.use_tree_list().is_some() {\n+            true => None,\n+            false => Some(tree),\n+        })\n+        .collect::<Option<Vec<_>>>()?;\n+    use_trees.sort_unstable_by(|a, b| path_cmp_opt(a.path(), b.path()));\n+    for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {\n+        let rhs_path = rhs_t.path();\n+        match use_trees.binary_search_by(|p| path_cmp_opt(p.path(), rhs_path.clone())) {\n+            Ok(idx) => {\n+                let lhs_t = &mut use_trees[idx];\n+                let lhs_path = lhs_t.path()?;\n+                let rhs_path = rhs_path?;\n+                let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n+                if lhs_prefix == lhs_path && rhs_prefix == rhs_path {\n+                    let tree_is_self = |tree: ast::UseTree| {\n+                        tree.path().as_ref().map(path_is_self).unwrap_or(false)\n+                    };\n+                    // check if only one of the two trees has a tree list, and whether that then contains `self` or not.\n+                    // If this is the case we can skip this iteration since the path without the list is already included in the other one via `self`\n+                    let tree_contains_self = |tree: &ast::UseTree| {\n+                        tree.use_tree_list()\n+                            .map(|tree_list| tree_list.use_trees().any(tree_is_self))\n+                            .unwrap_or(false)\n+                    };\n+                    match (tree_contains_self(&lhs_t), tree_contains_self(&rhs_t)) {\n+                        (true, false) => continue,\n+                        (false, true) => {\n+                            *lhs_t = rhs_t;\n+                            continue;\n+                        }\n+                        _ => (),\n+                    }\n+\n+                    // glob imports arent part of the use-tree lists so we need to special handle them here as well\n+                    // this special handling is only required for when we merge a module import into a glob import of said module\n+                    // see the `merge_self_glob` or `merge_mod_into_glob` tests\n+                    if lhs_t.star_token().is_some() || rhs_t.star_token().is_some() {\n+                        *lhs_t = make::use_tree(\n+                            make::path_unqualified(make::path_segment_self()),\n+                            None,\n+                            None,\n+                            false,\n+                        );\n+                        use_trees.insert(idx, make::glob_use_tree());\n+                        continue;\n+                    }\n+                }\n+                let lhs = lhs_t.split_prefix(&lhs_prefix);\n+                let rhs = rhs_t.split_prefix(&rhs_prefix);\n+                let this_has_children = use_trees.len() > 0;\n+                match recursive_merge(&lhs, &rhs, merge) {\n+                    Some((_, has_multiple_children))\n+                        if merge == MergeBehaviour::Last\n+                            && this_has_children\n+                            && has_multiple_children =>\n+                    {\n+                        return None\n+                    }\n+                    Some((use_tree, _)) => use_trees[idx] = use_tree,\n+                    None => use_trees.insert(idx, rhs_t),\n+                }\n+            }\n+            Err(_)\n+                if merge == MergeBehaviour::Last\n+                    && use_trees.len() > 0\n+                    && rhs_t.use_tree_list().is_some() =>\n+            {\n+                return None\n+            }\n+            Err(idx) => {\n+                use_trees.insert(idx, rhs_t);\n+            }\n+        }\n+    }\n+    let has_multiple_children = use_trees.len() > 1;\n+    Some((lhs.with_use_tree_list(make::use_tree_list(use_trees)), has_multiple_children))\n }\n \n /// Traverses both paths until they differ, returning the common prefix of both.\n@@ -219,7 +276,7 @@ fn common_prefix(lhs: &ast::Path, rhs: &ast::Path) -> Option<(ast::Path, ast::Pa\n     loop {\n         match (lhs_curr.segment(), rhs_curr.segment()) {\n             (Some(lhs), Some(rhs)) if lhs.syntax().text() == rhs.syntax().text() => (),\n-            _ => break,\n+            _ => break res,\n         }\n         res = Some((lhs_curr.clone(), rhs_curr.clone()));\n \n@@ -228,11 +285,62 @@ fn common_prefix(lhs: &ast::Path, rhs: &ast::Path) -> Option<(ast::Path, ast::Pa\n                 lhs_curr = lhs;\n                 rhs_curr = rhs;\n             }\n-            _ => break,\n+            _ => break res,\n         }\n     }\n+}\n \n-    res\n+fn path_is_self(path: &ast::Path) -> bool {\n+    path.segment().and_then(|seg| seg.self_token()).is_some() && path.qualifier().is_none()\n+}\n+\n+#[inline]\n+fn first_segment(path: &ast::Path) -> Option<ast::PathSegment> {\n+    first_path(path).segment()\n+}\n+\n+fn first_path(path: &ast::Path) -> ast::Path {\n+    successors(Some(path.clone()), ast::Path::qualifier).last().unwrap()\n+}\n+\n+fn segment_iter(path: &ast::Path) -> impl Iterator<Item = ast::PathSegment> + Clone {\n+    // cant make use of SyntaxNode::siblings, because the returned Iterator is not clone\n+    successors(first_segment(path), |p| p.parent_path().parent_path().and_then(|p| p.segment()))\n+}\n+\n+/// Orders paths in the following way:\n+/// the sole self token comes first, after that come uppercase identifiers, then lowercase identifiers\n+// FIXME: rustfmt sort lowercase idents before uppercase, in general we want to have the same ordering rustfmt has\n+// which is `self` and `super` first, then identifier imports with lowercase ones first, then glob imports and at last list imports.\n+// Example foo::{self, foo, baz, Baz, Qux, *, {Bar}}\n+fn path_cmp(a: &ast::Path, b: &ast::Path) -> Ordering {\n+    match (path_is_self(a), path_is_self(b)) {\n+        (true, true) => Ordering::Equal,\n+        (true, false) => Ordering::Less,\n+        (false, true) => Ordering::Greater,\n+        (false, false) => {\n+            let a = segment_iter(a);\n+            let b = segment_iter(b);\n+            // cmp_by would be useful for us here but that is currently unstable\n+            // cmp doesnt work due the lifetimes on text's return type\n+            a.zip(b)\n+                .flat_map(|(seg, seg2)| seg.name_ref().zip(seg2.name_ref()))\n+                .find_map(|(a, b)| match a.text().cmp(b.text()) {\n+                    ord @ Ordering::Greater | ord @ Ordering::Less => Some(ord),\n+                    Ordering::Equal => None,\n+                })\n+                .unwrap_or(Ordering::Equal)\n+        }\n+    }\n+}\n+\n+fn path_cmp_opt(a: Option<ast::Path>, b: Option<ast::Path>) -> Ordering {\n+    match (a, b) {\n+        (None, None) => Ordering::Equal,\n+        (None, Some(_)) => Ordering::Less,\n+        (Some(_), None) => Ordering::Greater,\n+        (Some(a), Some(b)) => path_cmp(&a, &b),\n+    }\n }\n \n /// What type of merges are allowed.\n@@ -279,19 +387,6 @@ impl ImportGroup {\n     }\n }\n \n-fn first_segment(path: &ast::Path) -> Option<ast::PathSegment> {\n-    first_path(path).segment()\n-}\n-\n-fn first_path(path: &ast::Path) -> ast::Path {\n-    successors(Some(path.clone()), ast::Path::qualifier).last().unwrap()\n-}\n-\n-fn segment_iter(path: &ast::Path) -> impl Iterator<Item = ast::PathSegment> + Clone {\n-    // cant make use of SyntaxNode::siblings, because the returned Iterator is not clone\n-    successors(first_segment(path), |p| p.parent_path().parent_path().and_then(|p| p.segment()))\n-}\n-\n #[derive(PartialEq, Eq)]\n enum AddBlankLine {\n     Before,\n@@ -594,7 +689,7 @@ use std::io;\",\n         check_full(\n             \"std::foo::bar::Baz\",\n             r\"use std::foo::bar::Qux;\",\n-            r\"use std::foo::bar::{Qux, Baz};\",\n+            r\"use std::foo::bar::{Baz, Qux};\",\n         )\n     }\n \n@@ -603,7 +698,7 @@ use std::io;\",\n         check_last(\n             \"std::foo::bar::Baz\",\n             r\"use std::foo::bar::Qux;\",\n-            r\"use std::foo::bar::{Qux, Baz};\",\n+            r\"use std::foo::bar::{Baz, Qux};\",\n         )\n     }\n \n@@ -612,7 +707,7 @@ use std::io;\",\n         check_full(\n             \"std::foo::bar::Baz\",\n             r\"use std::foo::bar::{Qux, Quux};\",\n-            r\"use std::foo::bar::{Qux, Quux, Baz};\",\n+            r\"use std::foo::bar::{Baz, Quux, Qux};\",\n         )\n     }\n \n@@ -621,7 +716,7 @@ use std::io;\",\n         check_last(\n             \"std::foo::bar::Baz\",\n             r\"use std::foo::bar::{Qux, Quux};\",\n-            r\"use std::foo::bar::{Qux, Quux, Baz};\",\n+            r\"use std::foo::bar::{Baz, Quux, Qux};\",\n         )\n     }\n \n@@ -630,7 +725,7 @@ use std::io;\",\n         check_full(\n             \"std::foo::bar::Baz\",\n             r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n-            r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}, Baz};\",\n+            r\"use std::foo::bar::{Baz, Qux, quux::{Fez, Fizz}};\",\n         )\n     }\n \n@@ -644,6 +739,15 @@ use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n         )\n     }\n \n+    #[test]\n+    fn merge_groups_full_nested_deep() {\n+        check_full(\n+            \"std::foo::bar::quux::Baz\",\n+            r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n+            r\"use std::foo::bar::{Qux, quux::{Baz, Fez, Fizz}};\",\n+        )\n+    }\n+\n     #[test]\n     fn merge_groups_skip_pub() {\n         check_full(\n@@ -670,34 +774,63 @@ use std::io;\",\n         check_last(\n             \"std::fmt::Result\",\n             r\"use std::{fmt, io};\",\n-            r\"use std::{self, fmt::Result};\n+            r\"use std::fmt::{self, Result};\n use std::io;\",\n         )\n     }\n \n+    #[test]\n+    fn merge_into_module_import() {\n+        check_full(\n+            \"std::fmt::Result\",\n+            r\"use std::{fmt, io};\",\n+            r\"use std::{fmt::{self, Result}, io};\",\n+        )\n+    }\n+\n     #[test]\n     fn merge_groups_self() {\n         check_full(\"std::fmt::Debug\", r\"use std::fmt;\", r\"use std::fmt::{self, Debug};\")\n     }\n \n     #[test]\n-    fn merge_self_glob() {\n+    fn merge_mod_into_glob() {\n         check_full(\n             \"token::TokenKind\",\n             r\"use token::TokenKind::*;\",\n-            r\"use token::TokenKind::{self::*, self};\",\n+            r\"use token::TokenKind::{*, self};\",\n+        )\n+        // FIXME: have it emit `use token::TokenKind::{self, *}`?\n+    }\n+\n+    #[test]\n+    fn merge_self_glob() {\n+        check_full(\"self\", r\"use self::*;\", r\"use self::{*, self};\")\n+        // FIXME: have it emit `use {self, *}`?\n+    }\n+\n+    #[test]\n+    #[ignore] // FIXME: Support this\n+    fn merge_partial_path() {\n+        check_full(\n+            \"ast::Foo\",\n+            r\"use syntax::{ast, algo};\",\n+            r\"use syntax::{ast::{self, Foo}, algo};\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_glob_nested() {\n+        check_full(\n+            \"foo::bar::quux::Fez\",\n+            r\"use foo::bar::{Baz, quux::*};\",\n+            r\"use foo::bar::{Baz, quux::{self::*, Fez}};\",\n         )\n     }\n \n     #[test]\n     fn merge_last_too_long() {\n-        mark::check!(test_last_merge_too_long);\n-        check_last(\n-            \"foo::bar\",\n-            r\"use foo::bar::baz::Qux;\",\n-            r\"use foo::bar;\n-use foo::bar::baz::Qux;\",\n-        );\n+        check_last(\"foo::bar\", r\"use foo::bar::baz::Qux;\", r\"use foo::bar::{self, baz::Qux};\");\n     }\n \n     #[test]\n@@ -710,6 +843,42 @@ use foo::bar::baz::Qux;\",\n         );\n     }\n \n+    #[test]\n+    fn merge_last_fail() {\n+        check_merge_only_fail(\n+            r\"use foo::bar::{baz::{Qux, Fez}};\",\n+            r\"use foo::bar::{baaz::{Quux, Feez}};\",\n+            MergeBehaviour::Last,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_last_fail1() {\n+        check_merge_only_fail(\n+            r\"use foo::bar::{baz::{Qux, Fez}};\",\n+            r\"use foo::bar::baaz::{Quux, Feez};\",\n+            MergeBehaviour::Last,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_last_fail2() {\n+        check_merge_only_fail(\n+            r\"use foo::bar::baz::{Qux, Fez};\",\n+            r\"use foo::bar::{baaz::{Quux, Feez}};\",\n+            MergeBehaviour::Last,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_last_fail3() {\n+        check_merge_only_fail(\n+            r\"use foo::bar::baz::{Qux, Fez};\",\n+            r\"use foo::bar::baaz::{Quux, Feez};\",\n+            MergeBehaviour::Last,\n+        );\n+    }\n+\n     fn check(\n         path: &str,\n         ra_fixture_before: &str,\n@@ -742,4 +911,23 @@ use foo::bar::baz::Qux;\",\n     fn check_none(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n         check(path, ra_fixture_before, ra_fixture_after, None)\n     }\n+\n+    fn check_merge_only_fail(ra_fixture0: &str, ra_fixture1: &str, mb: MergeBehaviour) {\n+        let use0 = ast::SourceFile::parse(ra_fixture0)\n+            .tree()\n+            .syntax()\n+            .descendants()\n+            .find_map(ast::Use::cast)\n+            .unwrap();\n+\n+        let use1 = ast::SourceFile::parse(ra_fixture1)\n+            .tree()\n+            .syntax()\n+            .descendants()\n+            .find_map(ast::Use::cast)\n+            .unwrap();\n+\n+        let result = try_merge_imports(&use0, &use1, mb);\n+        assert_eq!(result.map(|u| u.to_string()), None);\n+    }\n }"}, {"sha": "45cf31f1308046a29ecb7aff2703caa5b391b58b", "filename": "crates/syntax/src/ast/edit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3877421373ef1439e53b7f7274865af287dbb47f/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877421373ef1439e53b7f7274865af287dbb47f/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs?ref=3877421373ef1439e53b7f7274865af287dbb47f", "patch": "@@ -347,6 +347,7 @@ impl ast::UseTree {\n         self.clone()\n     }\n \n+    /// Splits off the given prefix, making it the path component of the use tree, appending the rest of the path to all UseTreeList items.\n     #[must_use]\n     pub fn split_prefix(&self, prefix: &ast::Path) -> ast::UseTree {\n         let suffix = if self.path().as_ref() == Some(prefix) && self.use_tree_list().is_none() {"}, {"sha": "6868feed9976ad6e66bbe3435599fff5baa183c6", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3877421373ef1439e53b7f7274865af287dbb47f/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877421373ef1439e53b7f7274865af287dbb47f/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=3877421373ef1439e53b7f7274865af287dbb47f", "patch": "@@ -38,6 +38,10 @@ pub fn path_from_text(text: &str) -> ast::Path {\n     ast_from_text(text)\n }\n \n+pub fn glob_use_tree() -> ast::UseTree {\n+    ast_from_text(\"use *;\")\n+}\n+\n pub fn use_tree(\n     path: ast::Path,\n     use_tree_list: Option<ast::UseTreeList>,"}]}