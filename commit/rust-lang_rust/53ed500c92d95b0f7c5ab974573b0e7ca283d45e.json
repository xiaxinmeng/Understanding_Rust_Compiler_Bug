{"sha": "53ed500c92d95b0f7c5ab974573b0e7ca283d45e", "node_id": "C_kwDOAAsO6NoAKDUzZWQ1MDBjOTJkOTViMGY3YzVhYjk3NDU3M2IwZTdjYTI4M2Q0NWU", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-04-06T21:48:14Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-04-06T21:48:14Z"}, "message": "Fully support FUTEX_*_BITSET.", "tree": {"sha": "211cfe7e679064be494ce0a8b7b376cca8d5f36a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/211cfe7e679064be494ce0a8b7b376cca8d5f36a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53ed500c92d95b0f7c5ab974573b0e7ca283d45e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53ed500c92d95b0f7c5ab974573b0e7ca283d45e", "html_url": "https://github.com/rust-lang/rust/commit/53ed500c92d95b0f7c5ab974573b0e7ca283d45e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53ed500c92d95b0f7c5ab974573b0e7ca283d45e/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12c88886b0a2a112de8ab802447bdd2b48fdb795", "url": "https://api.github.com/repos/rust-lang/rust/commits/12c88886b0a2a112de8ab802447bdd2b48fdb795", "html_url": "https://github.com/rust-lang/rust/commit/12c88886b0a2a112de8ab802447bdd2b48fdb795"}], "stats": {"total": 66, "additions": 48, "deletions": 18}, "files": [{"sha": "b0db9dd51f4fa02bddb28a7e626f2a66924a375e", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/53ed500c92d95b0f7c5ab974573b0e7ca283d45e/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ed500c92d95b0f7c5ab974573b0e7ca283d45e/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=53ed500c92d95b0f7c5ab974573b0e7ca283d45e", "patch": "@@ -38,6 +38,7 @@ pub fn futex<'tcx>(\n     let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n     let futex_wait_bitset = this.eval_libc_i32(\"FUTEX_WAIT_BITSET\")?;\n     let futex_wake = this.eval_libc_i32(\"FUTEX_WAKE\")?;\n+    let futex_wake_bitset = this.eval_libc_i32(\"FUTEX_WAKE_BITSET\")?;\n     let futex_realtime = this.eval_libc_i32(\"FUTEX_CLOCK_REALTIME\")?;\n \n     // FUTEX_PRIVATE enables an optimization that stops it from working across processes.\n@@ -48,32 +49,37 @@ pub fn futex<'tcx>(\n         // or *timeout expires. `timeout == null` for an infinite timeout.\n         //\n         // FUTEX_WAIT_BITSET: (int *addr, int op = FUTEX_WAIT_BITSET, int val, const timespec *timeout, int *_ignored, unsigned int bitset)\n-        // When bitset is u32::MAX, this is identical to FUTEX_WAIT, except the timeout is absolute rather than relative.\n+        // This is identical to FUTEX_WAIT, except:\n+        //  - The timeout is absolute rather than relative.\n+        //  - You can specify the bitset to selecting what WAKE operations to respond to.\n         op if op & !futex_realtime == futex_wait || op & !futex_realtime == futex_wait_bitset => {\n             let wait_bitset = op & !futex_realtime == futex_wait_bitset;\n \n+            let bitset;\n+\n             if wait_bitset {\n                 if args.len() != 7 {\n                     throw_ub_format!(\n                         \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT_BITSET`: got {}, expected 7\",\n                         args.len()\n                     );\n                 }\n-\n-                let bitset = this.read_scalar(&args[6])?.to_u32()?;\n-\n-                if bitset != u32::MAX {\n-                    throw_unsup_format!(\n-                        \"Miri does not support `futex` syscall with `op=FUTEX_WAIT_BITSET` with a bitset other than UINT_MAX\"\n-                    );\n-                }\n+                bitset = this.read_scalar(&args[6])?.to_u32()?;\n             } else {\n                 if args.len() < 5 {\n                     throw_ub_format!(\n                         \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT`: got {}, expected at least 5\",\n                         args.len()\n                     );\n                 }\n+                bitset = u32::MAX;\n+            }\n+\n+            if bitset == 0 {\n+                let einval = this.eval_libc(\"EINVAL\")?;\n+                this.set_last_error(einval)?;\n+                this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                return Ok(());\n             }\n \n             // `deref_operand` but not actually dereferencing the ptr yet (it might be NULL!).\n@@ -141,7 +147,7 @@ pub fn futex<'tcx>(\n             if val == futex_val {\n                 // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);\n-                this.futex_wait(addr_scalar.to_machine_usize(this)?, thread);\n+                this.futex_wait(addr_scalar.to_machine_usize(this)?, thread, bitset);\n                 // Succesfully waking up from FUTEX_WAIT always returns zero.\n                 this.write_scalar(Scalar::from_machine_isize(0, this), dest)?;\n                 // Register a timeout callback if a timeout was specified.\n@@ -173,10 +179,30 @@ pub fn futex<'tcx>(\n         // Wakes at most `val` threads waiting on the futex at `addr`.\n         // Returns the amount of threads woken up.\n         // Does not access the futex value at *addr.\n-        op if op == futex_wake => {\n+        // FUTEX_WAKE_BITSET: (int *addr, int op = FUTEX_WAKE, int val, const timespect *_unused, int *_unused, unsigned int bitset)\n+        // Same as FUTEX_WAKE, but allows you to specify a bitset to select which threads to wake up.\n+        op if op == futex_wake || op == futex_wake_bitset => {\n+            let bitset;\n+            if op == futex_wake_bitset {\n+                if args.len() != 7 {\n+                    throw_ub_format!(\n+                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAKE_BITSET`: got {}, expected 7\",\n+                        args.len()\n+                    );\n+                }\n+                bitset = this.read_scalar(&args[6])?.to_u32()?;\n+            } else {\n+                bitset = u32::MAX;\n+            }\n+            if bitset == 0 {\n+                let einval = this.eval_libc(\"EINVAL\")?;\n+                this.set_last_error(einval)?;\n+                this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                return Ok(());\n+            }\n             let mut n = 0;\n             for _ in 0..val {\n-                if let Some(thread) = this.futex_wake(addr_scalar.to_machine_usize(this)?) {\n+                if let Some(thread) = this.futex_wake(addr_scalar.to_machine_usize(this)?, bitset) {\n                     this.unblock_thread(thread);\n                     this.unregister_timeout_callback_if_exists(thread);\n                     n += 1;"}, {"sha": "9007f25ce5c700ed17c2555fc9a38fde57ce1842", "filename": "src/sync.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53ed500c92d95b0f7c5ab974573b0e7ca283d45e/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ed500c92d95b0f7c5ab974573b0e7ca283d45e/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=53ed500c92d95b0f7c5ab974573b0e7ca283d45e", "patch": "@@ -144,6 +144,8 @@ struct Futex {\n struct FutexWaiter {\n     /// The thread that is waiting on this futex.\n     thread: ThreadId,\n+    /// The bitset used by FUTEX_*_BITSET, or u32::MAX for other operations.\n+    bitset: u32,\n }\n \n /// The state of all synchronization variables.\n@@ -486,15 +488,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.sync.condvars[id].waiters.retain(|waiter| waiter.thread != thread);\n     }\n \n-    fn futex_wait(&mut self, addr: u64, thread: ThreadId) {\n+    fn futex_wait(&mut self, addr: u64, thread: ThreadId, bitset: u32) {\n         let this = self.eval_context_mut();\n         let futex = &mut this.machine.threads.sync.futexes.entry(addr).or_default();\n         let waiters = &mut futex.waiters;\n         assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n-        waiters.push_back(FutexWaiter { thread });\n+        waiters.push_back(FutexWaiter { thread, bitset });\n     }\n \n-    fn futex_wake(&mut self, addr: u64) -> Option<ThreadId> {\n+    fn futex_wake(&mut self, addr: u64, bitset: u32) -> Option<ThreadId> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n         let futex = &mut this.machine.threads.sync.futexes.get_mut(&addr)?;\n@@ -504,13 +506,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some(data_race) = data_race {\n             data_race.validate_lock_release(&mut futex.data_race, current_thread);\n         }\n-        let res = futex.waiters.pop_front().map(|waiter| {\n+\n+        // Wake up the first thread in the queue that matches any of the bits in the bitset.\n+        futex.waiters.iter().position(|w| w.bitset & bitset != 0).map(|i| {\n+            let waiter = futex.waiters.remove(i).unwrap();\n             if let Some(data_race) = data_race {\n                 data_race.validate_lock_acquire(&futex.data_race, waiter.thread);\n             }\n             waiter.thread\n-        });\n-        res\n+        })\n     }\n \n     fn futex_remove_waiter(&mut self, addr: u64, thread: ThreadId) {"}]}