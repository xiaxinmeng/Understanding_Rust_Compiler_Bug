{"sha": "dff1edf919198aa4dea106e63b7d1899f1061fe0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZjFlZGY5MTkxOThhYTRkZWExMDZlNjNiN2QxODk5ZjEwNjFmZTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-10T08:40:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-10T08:40:51Z"}, "message": "Auto merge of #79519 - cjgillot:noattr, r=wesleywiser\n\nStore HIR attributes in a side table\n\nSame idea as #72015 but for attributes.\nThe objective is to reduce incr-comp invalidations due to modified attributes.\nNotably, those due to modified doc comments.\n\nImplementation:\n- collect attributes during AST->HIR lowering, in `LocalDefId -> ItemLocalId -> &[Attributes]` nested tables;\n- access the attributes through a `hir_owner_attrs` query;\n- local refactorings to use this access;\n- remove `attrs` from HIR data structures one-by-one.\n\nChange in behaviour:\n- the HIR visitor traverses all attributes at once instead of parent-by-parent;\n- attribute arrays are sometimes duplicated: for statements and variant constructors;\n- as a consequence, attributes are marked as used after unused-attribute lint emission to avoid duplicate lints.\n\n~~Current bug: the lint level is not correctly applied in `std::backtrace_rs`, triggering an unused attribute warning on `#![no_std]`. I welcome suggestions.~~", "tree": {"sha": "e89b1e39488265fccd99dc2161d0dc60187a1445", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e89b1e39488265fccd99dc2161d0dc60187a1445"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dff1edf919198aa4dea106e63b7d1899f1061fe0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dff1edf919198aa4dea106e63b7d1899f1061fe0", "html_url": "https://github.com/rust-lang/rust/commit/dff1edf919198aa4dea106e63b7d1899f1061fe0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dff1edf919198aa4dea106e63b7d1899f1061fe0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "861872bc453bde79b83ff99d443d035225f10e87", "url": "https://api.github.com/repos/rust-lang/rust/commits/861872bc453bde79b83ff99d443d035225f10e87", "html_url": "https://github.com/rust-lang/rust/commit/861872bc453bde79b83ff99d443d035225f10e87"}, {"sha": "77c0f217ff2197aa0bbafc3cdb01b3da9016e514", "url": "https://api.github.com/repos/rust-lang/rust/commits/77c0f217ff2197aa0bbafc3cdb01b3da9016e514", "html_url": "https://github.com/rust-lang/rust/commit/77c0f217ff2197aa0bbafc3cdb01b3da9016e514"}], "stats": {"total": 1722, "additions": 869, "deletions": 853}, "files": [{"sha": "43b93d03ff6fb958f2224cbcc3666e47f798b14c", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 30, "deletions": 43, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -258,9 +258,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ex.span = e.span;\n                     }\n                     // Merge attributes into the inner expression.\n-                    let mut attrs: Vec<_> = e.attrs.iter().map(|a| self.lower_attr(a)).collect();\n-                    attrs.extend::<Vec<_>>(ex.attrs.into());\n-                    ex.attrs = attrs.into();\n+                    if !e.attrs.is_empty() {\n+                        let old_attrs = self.attrs.get(&ex.hir_id).map(|la| *la).unwrap_or(&[]);\n+                        self.attrs.insert(\n+                            ex.hir_id,\n+                            &*self.arena.alloc_from_iter(\n+                                e.attrs\n+                                    .iter()\n+                                    .map(|a| self.lower_attr(a))\n+                                    .chain(old_attrs.iter().cloned()),\n+                            ),\n+                        );\n+                    }\n                     return ex;\n                 }\n \n@@ -272,12 +281,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n             };\n \n-            hir::Expr {\n-                hir_id: self.lower_node_id(e.id),\n-                kind,\n-                span: e.span,\n-                attrs: e.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n-            }\n+            let hir_id = self.lower_node_id(e.id);\n+            self.lower_attrs(hir_id, &e.attrs);\n+            hir::Expr { hir_id, kind, span: e.span }\n         })\n     }\n \n@@ -618,14 +624,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir::Guard::If(self.lower_expr(cond))\n             }\n         });\n-        hir::Arm {\n-            hir_id: self.next_id(),\n-            attrs: self.lower_attrs(&arm.attrs),\n-            pat,\n-            guard,\n-            body: self.lower_expr(&arm.body),\n-            span: arm.span,\n-        }\n+        let hir_id = self.next_id();\n+        self.lower_attrs(hir_id, &arm.attrs);\n+        hir::Arm { hir_id, pat, guard, body: self.lower_expr(&arm.body), span: arm.span }\n     }\n \n     /// Lower an `async` construct to a generator that is then wrapped so it implements `Future`.\n@@ -669,7 +670,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             Ident::with_dummy_span(sym::_task_context),\n             hir::BindingAnnotation::Mutable,\n         );\n-        let param = hir::Param { attrs: &[], hir_id: self.next_id(), pat, ty_span: span, span };\n+        let param = hir::Param { hir_id: self.next_id(), pat, ty_span: span, span };\n         let params = arena_vec![self; param];\n \n         let body_id = self.lower_body(move |this| {\n@@ -690,12 +691,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             span,\n             Some(hir::Movability::Static),\n         );\n-        let generator = hir::Expr {\n-            hir_id: self.lower_node_id(closure_node_id),\n-            kind: generator_kind,\n-            span,\n-            attrs: ThinVec::new(),\n-        };\n+        let generator =\n+            hir::Expr { hir_id: self.lower_node_id(closure_node_id), kind: generator_kind, span };\n \n         // `future::from_generator`:\n         let unstable_span =\n@@ -849,7 +846,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir_id: loop_hir_id,\n             kind: hir::ExprKind::Loop(loop_block, None, hir::LoopSource::Loop, span),\n             span,\n-            attrs: ThinVec::new(),\n         });\n \n         // mut pinned => loop { ... }\n@@ -1026,7 +1022,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // Introduce a `let` for destructuring: `let (lhs1, lhs2) = t`.\n         let destructure_let = self.stmt_let_pat(\n-            ThinVec::new(),\n+            None,\n             whole_span,\n             Some(rhs),\n             pat,\n@@ -1785,7 +1781,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `let mut __next`\n         let next_let = self.stmt_let_pat(\n-            ThinVec::new(),\n+            None,\n             desugared_span,\n             None,\n             next_pat,\n@@ -1795,7 +1791,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `let <pat> = __next`\n         let pat = self.lower_pat(pat);\n         let pat_let = self.stmt_let_pat(\n-            ThinVec::new(),\n+            None,\n             desugared_span,\n             Some(next_expr),\n             pat,\n@@ -1819,12 +1815,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::LoopSource::ForLoop,\n             e.span.with_hi(orig_head_span.hi()),\n         );\n-        let loop_expr = self.arena.alloc(hir::Expr {\n-            hir_id: self.lower_node_id(e.id),\n-            kind,\n-            span: e.span,\n-            attrs: ThinVec::new(),\n-        });\n+        let loop_expr =\n+            self.arena.alloc(hir::Expr { hir_id: self.lower_node_id(e.id), kind, span: e.span });\n \n         // `mut iter => { ... }`\n         let iter_arm = self.arm(iter_pat, loop_expr);\n@@ -2159,21 +2151,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         kind: hir::ExprKind<'hir>,\n         attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n-        hir::Expr { hir_id: self.next_id(), kind, span, attrs }\n+        let hir_id = self.next_id();\n+        self.lower_attrs(hir_id, &attrs);\n+        hir::Expr { hir_id, kind, span }\n     }\n \n     fn field(&mut self, ident: Ident, expr: &'hir hir::Expr<'hir>, span: Span) -> hir::Field<'hir> {\n         hir::Field { hir_id: self.next_id(), ident, span, expr, is_shorthand: false }\n     }\n \n     fn arm(&mut self, pat: &'hir hir::Pat<'hir>, expr: &'hir hir::Expr<'hir>) -> hir::Arm<'hir> {\n-        hir::Arm {\n-            hir_id: self.next_id(),\n-            attrs: &[],\n-            pat,\n-            guard: None,\n-            span: expr.span,\n-            body: expr,\n-        }\n+        hir::Arm { hir_id: self.next_id(), pat, guard: None, span: expr.span, body: expr }\n     }\n }"}, {"sha": "777d3a5060b9289605d287767c73d40bc6b9133e", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 64, "deletions": 52, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -217,44 +217,41 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item<'hir>> {\n         let mut ident = i.ident;\n         let mut vis = self.lower_visibility(&i.vis, None);\n-        let attrs = self.lower_attrs(&i.attrs);\n \n         if let ItemKind::MacroDef(MacroDef { ref body, macro_rules }) = i.kind {\n             if !macro_rules || self.sess.contains_name(&i.attrs, sym::macro_export) {\n-                let def_id = self.lower_node_id(i.id).expect_owner();\n+                let hir_id = self.lower_node_id(i.id);\n+                self.lower_attrs(hir_id, &i.attrs);\n                 let body = P(self.lower_mac_args(body));\n                 self.exported_macros.push(hir::MacroDef {\n                     ident,\n                     vis,\n-                    attrs,\n-                    def_id,\n+                    def_id: hir_id.expect_owner(),\n                     span: i.span,\n                     ast: MacroDef { body, macro_rules },\n                 });\n             } else {\n-                self.non_exported_macro_attrs.extend(attrs.iter().cloned());\n+                for a in i.attrs.iter() {\n+                    let a = self.lower_attr(a);\n+                    self.non_exported_macro_attrs.push(a);\n+                }\n             }\n             return None;\n         }\n \n-        let kind = self.lower_item_kind(i.span, i.id, &mut ident, attrs, &mut vis, &i.kind);\n-\n-        Some(hir::Item {\n-            def_id: self.lower_node_id(i.id).expect_owner(),\n-            ident,\n-            attrs,\n-            kind,\n-            vis,\n-            span: i.span,\n-        })\n+        let hir_id = self.lower_node_id(i.id);\n+        let attrs = self.lower_attrs(hir_id, &i.attrs);\n+        let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, &mut vis, &i.kind);\n+        Some(hir::Item { def_id: hir_id.expect_owner(), ident, kind, vis, span: i.span })\n     }\n \n     fn lower_item_kind(\n         &mut self,\n         span: Span,\n         id: NodeId,\n+        hir_id: hir::HirId,\n         ident: &mut Ident,\n-        attrs: &'hir [Attribute],\n+        attrs: Option<&'hir [Attribute]>,\n         vis: &mut hir::Visibility<'hir>,\n         i: &ItemKind,\n     ) -> hir::ItemKind<'hir> {\n@@ -365,14 +362,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.lower_generics(generics, ImplTraitContext::disallowed()),\n             ),\n             ItemKind::Struct(ref struct_def, ref generics) => {\n-                let struct_def = self.lower_variant_data(struct_def);\n+                let struct_def = self.lower_variant_data(hir_id, struct_def);\n                 hir::ItemKind::Struct(\n                     struct_def,\n                     self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 )\n             }\n             ItemKind::Union(ref vdata, ref generics) => {\n-                let vdata = self.lower_variant_data(vdata);\n+                let vdata = self.lower_variant_data(hir_id, vdata);\n                 hir::ItemKind::Union(\n                     vdata,\n                     self.lower_generics(generics, ImplTraitContext::disallowed()),\n@@ -505,7 +502,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         vis: &mut hir::Visibility<'hir>,\n         ident: &mut Ident,\n-        attrs: &'hir [Attribute],\n+        attrs: Option<&'hir [Attribute]>,\n     ) -> hir::ItemKind<'hir> {\n         debug!(\"lower_use_tree(tree={:?})\", tree);\n         debug!(\"lower_use_tree: vis = {:?}\", vis);\n@@ -554,11 +551,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let path = this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n                         let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n+                        if let Some(attrs) = attrs {\n+                            this.attrs.insert(new_id, attrs);\n+                        }\n \n                         this.insert_item(hir::Item {\n                             def_id: new_id.expect_owner(),\n                             ident,\n-                            attrs,\n                             kind,\n                             vis,\n                             span,\n@@ -626,11 +625,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                         let kind =\n                             this.lower_use_tree(use_tree, &prefix, id, &mut vis, &mut ident, attrs);\n+                        if let Some(attrs) = attrs {\n+                            this.attrs.insert(new_hir_id, attrs);\n+                        }\n \n                         this.insert_item(hir::Item {\n                             def_id: new_hir_id.expect_owner(),\n                             ident,\n-                            attrs,\n                             kind,\n                             vis,\n                             span: use_tree.span,\n@@ -699,11 +700,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem<'hir> {\n-        let def_id = self.resolver.local_def_id(i.id);\n+        let hir_id = self.lower_node_id(i.id);\n+        let def_id = hir_id.expect_owner();\n+        self.lower_attrs(hir_id, &i.attrs);\n         hir::ForeignItem {\n             def_id,\n             ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n             kind: match i.kind {\n                 ForeignItemKind::Fn(box FnKind(_, ref sig, ref generics, _)) => {\n                     let fdec = &sig.decl;\n@@ -748,29 +750,43 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant<'hir> {\n+        let id = self.lower_node_id(v.id);\n+        self.lower_attrs(id, &v.attrs);\n         hir::Variant {\n-            attrs: self.lower_attrs(&v.attrs),\n-            data: self.lower_variant_data(&v.data),\n+            id,\n+            data: self.lower_variant_data(id, &v.data),\n             disr_expr: v.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n-            id: self.lower_node_id(v.id),\n             ident: v.ident,\n             span: v.span,\n         }\n     }\n \n-    fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData<'hir> {\n+    fn lower_variant_data(\n+        &mut self,\n+        parent_id: hir::HirId,\n+        vdata: &VariantData,\n+    ) -> hir::VariantData<'hir> {\n         match *vdata {\n             VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n                 self.arena\n                     .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_struct_field(f))),\n                 recovered,\n             ),\n-            VariantData::Tuple(ref fields, id) => hir::VariantData::Tuple(\n-                self.arena\n-                    .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_struct_field(f))),\n-                self.lower_node_id(id),\n-            ),\n-            VariantData::Unit(id) => hir::VariantData::Unit(self.lower_node_id(id)),\n+            VariantData::Tuple(ref fields, id) => {\n+                let ctor_id = self.lower_node_id(id);\n+                self.alias_attrs(ctor_id, parent_id);\n+                hir::VariantData::Tuple(\n+                    self.arena.alloc_from_iter(\n+                        fields.iter().enumerate().map(|f| self.lower_struct_field(f)),\n+                    ),\n+                    ctor_id,\n+                )\n+            }\n+            VariantData::Unit(id) => {\n+                let ctor_id = self.lower_node_id(id);\n+                self.alias_attrs(ctor_id, parent_id);\n+                hir::VariantData::Unit(ctor_id)\n+            }\n         }\n     }\n \n@@ -787,22 +803,24 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         } else {\n             self.lower_ty(&f.ty, ImplTraitContext::disallowed())\n         };\n+        let hir_id = self.lower_node_id(f.id);\n+        self.lower_attrs(hir_id, &f.attrs);\n         hir::StructField {\n             span: f.span,\n-            hir_id: self.lower_node_id(f.id),\n+            hir_id,\n             ident: match f.ident {\n                 Some(ident) => ident,\n                 // FIXME(jseyfried): positional field hygiene.\n                 None => Ident::new(sym::integer(index), f.span),\n             },\n             vis: self.lower_visibility(&f.vis, None),\n             ty,\n-            attrs: self.lower_attrs(&f.attrs),\n         }\n     }\n \n     fn lower_trait_item(&mut self, i: &AssocItem) -> hir::TraitItem<'hir> {\n-        let trait_item_def_id = self.resolver.local_def_id(i.id);\n+        let hir_id = self.lower_node_id(i.id);\n+        let trait_item_def_id = hir_id.expect_owner();\n \n         let (generics, kind) = match i.kind {\n             AssocItemKind::Const(_, ref ty, ref default) => {\n@@ -835,14 +853,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::MacCall(..) => panic!(\"macro item shouldn't exist at this point\"),\n         };\n \n-        hir::TraitItem {\n-            def_id: trait_item_def_id,\n-            ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n-            generics,\n-            kind,\n-            span: i.span,\n-        }\n+        self.lower_attrs(hir_id, &i.attrs);\n+        hir::TraitItem { def_id: trait_item_def_id, ident: i.ident, generics, kind, span: i.span }\n     }\n \n     fn lower_trait_item_ref(&mut self, i: &AssocItem) -> hir::TraitItemRef {\n@@ -920,10 +932,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // Since `default impl` is not yet implemented, this is always true in impls.\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n+        let hir_id = self.lower_node_id(i.id);\n+        self.lower_attrs(hir_id, &i.attrs);\n         hir::ImplItem {\n-            def_id: self.lower_node_id(i.id).expect_owner(),\n+            def_id: hir_id.expect_owner(),\n             ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n             generics,\n             vis: self.lower_visibility(&i.vis, None),\n             defaultness,\n@@ -1024,9 +1037,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_param(&mut self, param: &Param) -> hir::Param<'hir> {\n+        let hir_id = self.lower_node_id(param.id);\n+        self.lower_attrs(hir_id, &param.attrs);\n         hir::Param {\n-            attrs: self.lower_attrs(&param.attrs),\n-            hir_id: self.lower_node_id(param.id),\n+            hir_id,\n             pat: self.lower_pat(&param.pat),\n             ty_span: param.ty.span,\n             span: param.span,\n@@ -1158,11 +1172,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 //\n                 // If this is the simple case, this parameter will end up being the same as the\n                 // original parameter, but with a different pattern id.\n-                let mut stmt_attrs = AttrVec::new();\n-                stmt_attrs.extend(parameter.attrs.iter().cloned());\n+                let stmt_attrs = this.attrs.get(&parameter.hir_id).copied();\n                 let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n                 let new_parameter = hir::Param {\n-                    attrs: parameter.attrs,\n                     hir_id: parameter.hir_id,\n                     pat: new_parameter_pat,\n                     ty_span: parameter.ty_span,\n@@ -1205,7 +1217,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     );\n                     let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat(\n-                        AttrVec::new(),\n+                        None,\n                         desugared_span,\n                         Some(move_expr),\n                         move_pat,"}, {"sha": "057e4d81f80fd727072dad606311dc99255b7cfd", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 62, "deletions": 21, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -114,6 +114,8 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     generator_kind: Option<hir::GeneratorKind>,\n \n+    attrs: BTreeMap<hir::HirId, &'hir [Attribute]>,\n+\n     /// When inside an `async` context, this is the `HirId` of the\n     /// `task_context` local bound to the resume argument of the generator.\n     task_context: Option<hir::HirId>,\n@@ -309,6 +311,7 @@ pub fn lower_crate<'a, 'hir>(\n         bodies: BTreeMap::new(),\n         trait_impls: BTreeMap::new(),\n         modules: BTreeMap::new(),\n+        attrs: BTreeMap::default(),\n         exported_macros: Vec::new(),\n         non_exported_macro_attrs: Vec::new(),\n         catch_scopes: Vec::new(),\n@@ -565,7 +568,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n         let module = self.lower_mod(&c.items, c.span);\n-        let attrs = self.lower_attrs(&c.attrs);\n+        self.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n         let body_ids = body_ids(&self.bodies);\n         let proc_macros =\n             c.proc_macros.iter().map(|id| self.node_id_to_hir_id[*id].unwrap()).collect();\n@@ -592,8 +595,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         self.resolver.definitions().init_def_id_to_hir_id_mapping(def_id_to_hir_id);\n \n+        #[cfg(debug_assertions)]\n+        for (&id, attrs) in self.attrs.iter() {\n+            // Verify that we do not store empty slices in the map.\n+            if attrs.is_empty() {\n+                panic!(\"Stored empty attributes for {:?}\", id);\n+            }\n+        }\n+\n         hir::Crate {\n-            item: hir::CrateItem { module, attrs, span: c.span },\n+            item: hir::CrateItem { module, span: c.span },\n             exported_macros: self.arena.alloc_from_iter(self.exported_macros),\n             non_exported_macro_attrs: self.arena.alloc_from_iter(self.non_exported_macro_attrs),\n             items: self.items,\n@@ -606,6 +617,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             modules: self.modules,\n             proc_macros,\n             trait_map,\n+            attrs: self.attrs,\n         }\n     }\n \n@@ -834,7 +846,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::GenericParam {\n             hir_id: self.lower_node_id(node_id),\n             name: hir_name,\n-            attrs: &[],\n             bounds: &[],\n             span,\n             pure_wrt_drop: false,\n@@ -967,11 +978,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ret\n     }\n \n-    fn lower_attrs(&mut self, attrs: &[Attribute]) -> &'hir [Attribute] {\n-        self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)))\n+    fn lower_attrs(&mut self, id: hir::HirId, attrs: &[Attribute]) -> Option<&'hir [Attribute]> {\n+        if attrs.is_empty() {\n+            None\n+        } else {\n+            let ret = self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)));\n+            debug_assert!(!ret.is_empty());\n+            self.attrs.insert(id, ret);\n+            Some(ret)\n+        }\n     }\n \n-    fn lower_attr(&mut self, attr: &Attribute) -> Attribute {\n+    fn lower_attr(&self, attr: &Attribute) -> Attribute {\n         // Note that we explicitly do not walk the path. Since we don't really\n         // lower attributes (we use the AST version) there is nowhere to keep\n         // the `HirId`s. We don't actually need HIR version of attributes anyway.\n@@ -991,7 +1009,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         Attribute { kind, id: attr.id, style: attr.style, span: attr.span }\n     }\n \n-    fn lower_mac_args(&mut self, args: &MacArgs) -> MacArgs {\n+    fn alias_attrs(&mut self, id: hir::HirId, target_id: hir::HirId) {\n+        if let Some(&a) = self.attrs.get(&target_id) {\n+            debug_assert!(!a.is_empty());\n+            self.attrs.insert(id, a);\n+        }\n+    }\n+\n+    fn lower_mac_args(&self, args: &MacArgs) -> MacArgs {\n         match *args {\n             MacArgs::Empty => MacArgs::Empty,\n             MacArgs::Delimited(dspan, delim, ref tokens) => {\n@@ -1444,7 +1469,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             hir_id: self.lower_node_id(def_node_id),\n                             name: ParamName::Plain(ident),\n                             pure_wrt_drop: false,\n-                            attrs: &[],\n                             bounds: hir_bounds,\n                             span,\n                             kind: hir::GenericParamKind::Type {\n@@ -1572,7 +1596,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let opaque_ty_item = hir::Item {\n             def_id: opaque_ty_id,\n             ident: Ident::invalid(),\n-            attrs: Default::default(),\n             kind: opaque_ty_item_kind,\n             vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n             span: opaque_ty_span,\n@@ -1733,7 +1756,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         name,\n                         span: lifetime.span,\n                         pure_wrt_drop: false,\n-                        attrs: &[],\n                         bounds: &[],\n                         kind: hir::GenericParamKind::Lifetime { kind },\n                     });\n@@ -1790,14 +1812,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             )\n         });\n         let init = l.init.as_ref().map(|e| self.lower_expr(e));\n+        let hir_id = self.lower_node_id(l.id);\n+        self.lower_attrs(hir_id, &l.attrs);\n         (\n             hir::Local {\n-                hir_id: self.lower_node_id(l.id),\n+                hir_id,\n                 ty,\n                 pat: self.lower_pat(&l.pat),\n                 init,\n                 span: l.span,\n-                attrs: l.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n                 source: hir::LocalSource::Normal,\n             },\n             ids,\n@@ -2300,12 +2323,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         };\n \n+        let hir_id = self.lower_node_id(param.id);\n+        self.lower_attrs(hir_id, &param.attrs);\n         hir::GenericParam {\n-            hir_id: self.lower_node_id(param.id),\n+            hir_id,\n             name,\n             span: param.ident.span,\n             pure_wrt_drop: self.sess.contains_name(&param.attrs, sym::may_dangle),\n-            attrs: self.lower_attrs(&param.attrs),\n             bounds: self.arena.alloc_from_iter(bounds),\n             kind,\n         }\n@@ -2426,7 +2450,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_stmt(&mut self, s: &Stmt) -> SmallVec<[hir::Stmt<'hir>; 1]> {\n-        let kind = match s.kind {\n+        let (hir_id, kind) = match s.kind {\n             StmtKind::Local(ref l) => {\n                 let (l, item_ids) = self.lower_local(l);\n                 let mut ids: SmallVec<[hir::Stmt<'hir>; 1]> = item_ids\n@@ -2439,9 +2463,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         self.stmt(s.span, hir::StmtKind::Item(item_id))\n                     })\n                     .collect();\n+                let hir_id = self.lower_node_id(s.id);\n+                self.alias_attrs(hir_id, l.hir_id);\n                 ids.push({\n                     hir::Stmt {\n-                        hir_id: self.lower_node_id(s.id),\n+                        hir_id,\n                         kind: hir::StmtKind::Local(self.arena.alloc(l)),\n                         span: s.span,\n                     }\n@@ -2464,12 +2490,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     })\n                     .collect();\n             }\n-            StmtKind::Expr(ref e) => hir::StmtKind::Expr(self.lower_expr(e)),\n-            StmtKind::Semi(ref e) => hir::StmtKind::Semi(self.lower_expr(e)),\n+            StmtKind::Expr(ref e) => {\n+                let e = self.lower_expr(e);\n+                let hir_id = self.lower_node_id(s.id);\n+                self.alias_attrs(hir_id, e.hir_id);\n+                (hir_id, hir::StmtKind::Expr(e))\n+            }\n+            StmtKind::Semi(ref e) => {\n+                let e = self.lower_expr(e);\n+                let hir_id = self.lower_node_id(s.id);\n+                self.alias_attrs(hir_id, e.hir_id);\n+                (hir_id, hir::StmtKind::Semi(e))\n+            }\n             StmtKind::Empty => return smallvec![],\n             StmtKind::MacCall(..) => panic!(\"shouldn't exist here\"),\n         };\n-        smallvec![hir::Stmt { hir_id: self.lower_node_id(s.id), kind, span: s.span }]\n+        smallvec![hir::Stmt { hir_id, kind, span: s.span }]\n     }\n \n     fn lower_block_check_mode(&mut self, b: &BlockCheckMode) -> hir::BlockCheckMode {\n@@ -2513,13 +2549,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn stmt_let_pat(\n         &mut self,\n-        attrs: AttrVec,\n+        attrs: Option<&'hir [Attribute]>,\n         span: Span,\n         init: Option<&'hir hir::Expr<'hir>>,\n         pat: &'hir hir::Pat<'hir>,\n         source: hir::LocalSource,\n     ) -> hir::Stmt<'hir> {\n-        let local = hir::Local { attrs, hir_id: self.next_id(), init, pat, source, span, ty: None };\n+        let hir_id = self.next_id();\n+        if let Some(a) = attrs {\n+            debug_assert!(!a.is_empty());\n+            self.attrs.insert(hir_id, a);\n+        }\n+        let local = hir::Local { hir_id, init, pat, source, span, ty: None };\n         self.stmt(span, hir::StmtKind::Local(self.arena.alloc(local)))\n     }\n "}, {"sha": "854aaac757fb013a32b17c1cbe73ffd8314bdc31", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -433,12 +433,10 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n \n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n-    let no_builtins = tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::no_builtins);\n-    let is_compiler_builtins =\n-        tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::compiler_builtins);\n-    let subsystem = tcx\n-        .sess\n-        .first_attr_value_str_by_name(&tcx.hir().krate().item.attrs, sym::windows_subsystem);\n+    let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n+    let no_builtins = tcx.sess.contains_name(crate_attrs, sym::no_builtins);\n+    let is_compiler_builtins = tcx.sess.contains_name(crate_attrs, sym::compiler_builtins);\n+    let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n     let windows_subsystem = subsystem.map(|subsystem| {\n         if subsystem != sym::windows && subsystem != sym::console {\n             tcx.sess.fatal(&format!("}, {"sha": "8f61adcd8e28870f0c62f1cabd5eeec08cc62976", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -6,7 +6,7 @@ use crate::{itemlikevisit, LangItem};\n \n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_ast::{self as ast, CrateSugar, LlvmAsmDialect};\n-use rustc_ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n+use rustc_ast::{Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n pub use rustc_ast::{BorrowKind, ImplPolarity, IsAuto};\n pub use rustc_ast::{CaptureBy, Movability, Mutability};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n@@ -469,7 +469,6 @@ pub enum GenericParamKind<'hir> {\n pub struct GenericParam<'hir> {\n     pub hir_id: HirId,\n     pub name: ParamName,\n-    pub attrs: &'hir [Attribute],\n     pub bounds: GenericBounds<'hir>,\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n@@ -630,7 +629,6 @@ pub struct ModuleItems {\n #[derive(Encodable, Debug, HashStable_Generic)]\n pub struct CrateItem<'hir> {\n     pub module: Mod<'hir>,\n-    pub attrs: &'hir [Attribute],\n     pub span: Span,\n }\n \n@@ -675,6 +673,9 @@ pub struct Crate<'hir> {\n     pub proc_macros: Vec<HirId>,\n \n     pub trait_map: BTreeMap<HirId, Vec<TraitCandidate>>,\n+\n+    /// Collected attributes from HIR nodes.\n+    pub attrs: BTreeMap<HirId, &'hir [Attribute]>,\n }\n \n impl Crate<'hir> {\n@@ -766,7 +767,6 @@ impl Crate<'_> {\n pub struct MacroDef<'hir> {\n     pub ident: Ident,\n     pub vis: Visibility<'hir>,\n-    pub attrs: &'hir [Attribute],\n     pub def_id: LocalDefId,\n     pub span: Span,\n     pub ast: ast::MacroDef,\n@@ -1166,16 +1166,6 @@ pub enum StmtKind<'hir> {\n     Semi(&'hir Expr<'hir>),\n }\n \n-impl<'hir> StmtKind<'hir> {\n-    pub fn attrs(&self, get_item: impl FnOnce(ItemId) -> &'hir Item<'hir>) -> &'hir [Attribute] {\n-        match *self {\n-            StmtKind::Local(ref l) => &l.attrs,\n-            StmtKind::Item(ref item_id) => &get_item(*item_id).attrs,\n-            StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => &e.attrs,\n-        }\n-    }\n-}\n-\n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n #[derive(Debug, HashStable_Generic)]\n pub struct Local<'hir> {\n@@ -1186,7 +1176,6 @@ pub struct Local<'hir> {\n     pub init: Option<&'hir Expr<'hir>>,\n     pub hir_id: HirId,\n     pub span: Span,\n-    pub attrs: AttrVec,\n     /// Can be `ForLoopDesugar` if the `let` statement is part of a `for` loop\n     /// desugaring. Otherwise will be `Normal`.\n     pub source: LocalSource,\n@@ -1199,7 +1188,6 @@ pub struct Arm<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub span: Span,\n-    pub attrs: &'hir [Attribute],\n     /// If this pattern and the optional guard matches, then `body` is evaluated.\n     pub pat: &'hir Pat<'hir>,\n     /// Optional guard clause.\n@@ -1458,7 +1446,6 @@ pub struct AnonConst {\n pub struct Expr<'hir> {\n     pub hir_id: HirId,\n     pub kind: ExprKind<'hir>,\n-    pub attrs: AttrVec,\n     pub span: Span,\n }\n \n@@ -2040,7 +2027,6 @@ impl TraitItemId {\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n     pub def_id: LocalDefId,\n-    pub attrs: &'hir [Attribute],\n     pub generics: Generics<'hir>,\n     pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n@@ -2103,7 +2089,6 @@ pub struct ImplItem<'hir> {\n     pub def_id: LocalDefId,\n     pub vis: Visibility<'hir>,\n     pub defaultness: Defaultness,\n-    pub attrs: &'hir [Attribute],\n     pub generics: Generics<'hir>,\n     pub kind: ImplItemKind<'hir>,\n     pub span: Span,\n@@ -2433,7 +2418,6 @@ pub struct LlvmInlineAsm<'hir> {\n /// Represents a parameter in a function header.\n #[derive(Debug, HashStable_Generic)]\n pub struct Param<'hir> {\n-    pub attrs: &'hir [Attribute],\n     pub hir_id: HirId,\n     pub pat: &'hir Pat<'hir>,\n     pub ty_span: Span,\n@@ -2551,8 +2535,6 @@ pub struct Variant<'hir> {\n     /// Name of the variant.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n-    /// Attributes of the variant.\n-    pub attrs: &'hir [Attribute],\n     /// Id of the variant (not the constructor, see `VariantData::ctor_hir_id()`).\n     pub id: HirId,\n     /// Fields and constructor id of the variant.\n@@ -2646,7 +2628,6 @@ pub struct StructField<'hir> {\n     pub vis: Visibility<'hir>,\n     pub hir_id: HirId,\n     pub ty: &'hir Ty<'hir>,\n-    pub attrs: &'hir [Attribute],\n }\n \n impl StructField<'_> {\n@@ -2715,7 +2696,6 @@ impl ItemId {\n pub struct Item<'hir> {\n     pub ident: Ident,\n     pub def_id: LocalDefId,\n-    pub attrs: &'hir [Attribute],\n     pub kind: ItemKind<'hir>,\n     pub vis: Visibility<'hir>,\n     pub span: Span,\n@@ -2932,7 +2912,6 @@ pub struct ForeignItemRef<'hir> {\n #[derive(Debug)]\n pub struct ForeignItem<'hir> {\n     pub ident: Ident,\n-    pub attrs: &'hir [Attribute],\n     pub kind: ForeignItemKind<'hir>,\n     pub def_id: LocalDefId,\n     pub span: Span,\n@@ -3091,13 +3070,13 @@ impl<'hir> Node<'hir> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     rustc_data_structures::static_assert_size!(super::Block<'static>, 48);\n-    rustc_data_structures::static_assert_size!(super::Expr<'static>, 72);\n+    rustc_data_structures::static_assert_size!(super::Expr<'static>, 64);\n     rustc_data_structures::static_assert_size!(super::Pat<'static>, 88);\n     rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n     rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);\n \n-    rustc_data_structures::static_assert_size!(super::Item<'static>, 200);\n-    rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 144);\n-    rustc_data_structures::static_assert_size!(super::ImplItem<'static>, 168);\n-    rustc_data_structures::static_assert_size!(super::ForeignItem<'static>, 152);\n+    rustc_data_structures::static_assert_size!(super::Item<'static>, 184);\n+    rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 128);\n+    rustc_data_structures::static_assert_size!(super::ImplItem<'static>, 152);\n+    rustc_data_structures::static_assert_size!(super::ForeignItem<'static>, 136);\n }"}, {"sha": "e0b3d9026a07cfe240f0eca7930ae95ce1a87b12", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -1,4 +1,5 @@\n use crate::def_id::{LocalDefId, CRATE_DEF_INDEX};\n+use rustc_index::vec::IndexVec;\n use std::fmt;\n \n /// Uniquely identifies a node in the HIR of the current crate. It is\n@@ -61,3 +62,69 @@ pub const CRATE_HIR_ID: HirId = HirId {\n     owner: LocalDefId { local_def_index: CRATE_DEF_INDEX },\n     local_id: ItemLocalId::from_u32(0),\n };\n+\n+#[derive(Clone, Default, Debug, Encodable, Decodable)]\n+pub struct HirIdVec<T> {\n+    map: IndexVec<LocalDefId, IndexVec<ItemLocalId, T>>,\n+}\n+\n+impl<T> HirIdVec<T> {\n+    pub fn push_owner(&mut self, id: LocalDefId) {\n+        self.map.ensure_contains_elem(id, IndexVec::new);\n+    }\n+\n+    pub fn push(&mut self, id: HirId, value: T) {\n+        if id.local_id == ItemLocalId::from_u32(0) {\n+            self.push_owner(id.owner);\n+        }\n+        let submap = &mut self.map[id.owner];\n+        let _ret_id = submap.push(value);\n+        debug_assert_eq!(_ret_id, id.local_id);\n+    }\n+\n+    pub fn push_sparse(&mut self, id: HirId, value: T)\n+    where\n+        T: Default,\n+    {\n+        self.map.ensure_contains_elem(id.owner, IndexVec::new);\n+        let submap = &mut self.map[id.owner];\n+        let i = id.local_id.index();\n+        let len = submap.len();\n+        if i >= len {\n+            submap.extend(std::iter::repeat_with(T::default).take(i - len + 1));\n+        }\n+        submap[id.local_id] = value;\n+    }\n+\n+    pub fn get(&self, id: HirId) -> Option<&T> {\n+        self.map.get(id.owner)?.get(id.local_id)\n+    }\n+\n+    pub fn get_owner(&self, id: LocalDefId) -> &IndexVec<ItemLocalId, T> {\n+        &self.map[id]\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = &T> {\n+        self.map.iter().flat_map(|la| la.iter())\n+    }\n+\n+    pub fn iter_enumerated(&self) -> impl Iterator<Item = (HirId, &T)> {\n+        self.map.iter_enumerated().flat_map(|(owner, la)| {\n+            la.iter_enumerated().map(move |(local_id, attr)| (HirId { owner, local_id }, attr))\n+        })\n+    }\n+}\n+\n+impl<T> std::ops::Index<HirId> for HirIdVec<T> {\n+    type Output = T;\n+\n+    fn index(&self, id: HirId) -> &T {\n+        &self.map[id.owner][id.local_id]\n+    }\n+}\n+\n+impl<T> std::ops::IndexMut<HirId> for HirIdVec<T> {\n+    fn index_mut(&mut self, id: HirId) -> &mut T {\n+        &mut self.map[id.owner][id.local_id]\n+    }\n+}"}, {"sha": "df63f0d48c3dd0a6b62349c26fba98f29b4e2d04", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -101,29 +101,21 @@ where\n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n     /// `#[xxx] pub async/const/extern \"Abi\" fn foo()`\n-    ItemFn(Ident, &'a Generics<'a>, FnHeader, &'a Visibility<'a>, &'a [Attribute]),\n+    ItemFn(Ident, &'a Generics<'a>, FnHeader, &'a Visibility<'a>),\n \n     /// `fn foo(&self)`\n-    Method(Ident, &'a FnSig<'a>, Option<&'a Visibility<'a>>, &'a [Attribute]),\n+    Method(Ident, &'a FnSig<'a>, Option<&'a Visibility<'a>>),\n \n     /// `|x, y| {}`\n-    Closure(&'a [Attribute]),\n+    Closure,\n }\n \n impl<'a> FnKind<'a> {\n-    pub fn attrs(&self) -> &'a [Attribute] {\n-        match *self {\n-            FnKind::ItemFn(.., attrs) => attrs,\n-            FnKind::Method(.., attrs) => attrs,\n-            FnKind::Closure(attrs) => attrs,\n-        }\n-    }\n-\n     pub fn header(&self) -> Option<&FnHeader> {\n         match *self {\n-            FnKind::ItemFn(_, _, ref header, _, _) => Some(header),\n-            FnKind::Method(_, ref sig, _, _) => Some(&sig.header),\n-            FnKind::Closure(_) => None,\n+            FnKind::ItemFn(_, _, ref header, _) => Some(header),\n+            FnKind::Method(_, ref sig, _) => Some(&sig.header),\n+            FnKind::Closure => None,\n         }\n     }\n }\n@@ -466,7 +458,7 @@ pub trait Visitor<'v>: Sized {\n     fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding<'v>) {\n         walk_assoc_type_binding(self, type_binding)\n     }\n-    fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n+    fn visit_attribute(&mut self, _id: HirId, _attr: &'v Attribute) {}\n     fn visit_macro_def(&mut self, macro_def: &'v MacroDef<'v>) {\n         walk_macro_def(self, macro_def)\n     }\n@@ -484,14 +476,17 @@ pub trait Visitor<'v>: Sized {\n /// Walks the contents of a crate. See also `Crate::visit_all_items`.\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate<'v>) {\n     visitor.visit_mod(&krate.item.module, krate.item.span, CRATE_HIR_ID);\n-    walk_list!(visitor, visit_attribute, krate.item.attrs);\n     walk_list!(visitor, visit_macro_def, krate.exported_macros);\n+    for (&id, attrs) in krate.attrs.iter() {\n+        for a in *attrs {\n+            visitor.visit_attribute(id, a)\n+        }\n+    }\n }\n \n pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef<'v>) {\n     visitor.visit_id(macro_def.hir_id());\n     visitor.visit_ident(macro_def.ident);\n-    walk_list!(visitor, visit_attribute, macro_def.attrs);\n }\n \n pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n@@ -510,7 +505,6 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n     // Intentionally visiting the expr first - the initialization expr\n     // dominates the local's definition.\n     walk_list!(visitor, visit_expr, &local.init);\n-    walk_list!(visitor, visit_attribute, local.attrs.iter());\n     visitor.visit_id(local.hir_id);\n     visitor.visit_pat(&local.pat);\n     walk_list!(visitor, visit_ty, &local.ty);\n@@ -557,7 +551,6 @@ pub fn walk_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v TraitR\n pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param<'v>) {\n     visitor.visit_id(param.hir_id);\n     visitor.visit_pat(&param.pat);\n-    walk_list!(visitor, visit_attribute, param.attrs);\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n@@ -579,7 +572,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             visitor.visit_nested_body(body);\n         }\n         ItemKind::Fn(ref sig, ref generics, body_id) => visitor.visit_fn(\n-            FnKind::ItemFn(item.ident, generics, sig.header, &item.vis, &item.attrs),\n+            FnKind::ItemFn(item.ident, generics, sig.header, &item.vis),\n             &sig.decl,\n             body_id,\n             item.span,\n@@ -652,7 +645,6 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n     }\n-    walk_list!(visitor, visit_attribute, item.attrs);\n }\n \n pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n@@ -686,7 +678,6 @@ pub fn walk_variant<'v, V: Visitor<'v>>(\n         variant.span,\n     );\n     walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n-    walk_list!(visitor, visit_attribute, variant.attrs);\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n@@ -851,8 +842,6 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n         ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n         ForeignItemKind::Type => (),\n     }\n-\n-    walk_list!(visitor, visit_attribute, foreign_item.attrs);\n }\n \n pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n@@ -870,7 +859,6 @@ pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericB\n \n pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam<'v>) {\n     visitor.visit_id(param.hir_id);\n-    walk_list!(visitor, visit_attribute, param.attrs);\n     match param.name {\n         ParamName::Plain(ident) => visitor.visit_ident(ident),\n         ParamName::Error | ParamName::Fresh(_) => {}\n@@ -940,7 +928,7 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n         FnKind::ItemFn(_, generics, ..) => {\n             visitor.visit_generics(generics);\n         }\n-        FnKind::Method(..) | FnKind::Closure(_) => {}\n+        FnKind::Method(..) | FnKind::Closure => {}\n     }\n }\n \n@@ -960,7 +948,6 @@ pub fn walk_fn<'v, V: Visitor<'v>>(\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem<'v>) {\n     visitor.visit_ident(trait_item.ident);\n-    walk_list!(visitor, visit_attribute, trait_item.attrs);\n     visitor.visit_generics(&trait_item.generics);\n     match trait_item.kind {\n         TraitItemKind::Const(ref ty, default) => {\n@@ -977,7 +964,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n         }\n         TraitItemKind::Fn(ref sig, TraitFn::Provided(body_id)) => {\n             visitor.visit_fn(\n-                FnKind::Method(trait_item.ident, sig, None, &trait_item.attrs),\n+                FnKind::Method(trait_item.ident, sig, None),\n                 &sig.decl,\n                 body_id,\n                 trait_item.span,\n@@ -1003,21 +990,12 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n-    let ImplItem {\n-        def_id: _,\n-        ident,\n-        ref vis,\n-        ref defaultness,\n-        attrs,\n-        ref generics,\n-        ref kind,\n-        span: _,\n-    } = *impl_item;\n+    let ImplItem { def_id: _, ident, ref vis, ref defaultness, ref generics, ref kind, span: _ } =\n+        *impl_item;\n \n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n     visitor.visit_defaultness(defaultness);\n-    walk_list!(visitor, visit_attribute, attrs);\n     visitor.visit_generics(generics);\n     match *kind {\n         ImplItemKind::Const(ref ty, body) => {\n@@ -1027,7 +1005,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n         }\n         ImplItemKind::Fn(ref sig, body_id) => {\n             visitor.visit_fn(\n-                FnKind::Method(impl_item.ident, sig, Some(&impl_item.vis), &impl_item.attrs),\n+                FnKind::Method(impl_item.ident, sig, Some(&impl_item.vis)),\n                 &sig.decl,\n                 body_id,\n                 impl_item.span,\n@@ -1075,7 +1053,6 @@ pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v\n     visitor.visit_vis(&struct_field.vis);\n     visitor.visit_ident(struct_field.ident);\n     visitor.visit_ty(&struct_field.ty);\n-    walk_list!(visitor, visit_attribute, struct_field.attrs);\n }\n \n pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block<'v>) {\n@@ -1102,7 +1079,6 @@ pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonCo\n \n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n     visitor.visit_id(expression.hir_id);\n-    walk_list!(visitor, visit_attribute, expression.attrs.iter());\n     match expression.kind {\n         ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n         ExprKind::Array(subexpressions) => {\n@@ -1162,7 +1138,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n         }\n         ExprKind::Closure(_, ref function_declaration, body, _fn_decl_span, _gen) => visitor\n             .visit_fn(\n-                FnKind::Closure(&expression.attrs),\n+                FnKind::Closure,\n                 function_declaration,\n                 body,\n                 expression.span,\n@@ -1246,7 +1222,6 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n         }\n     }\n     visitor.visit_expr(&arm.body);\n-    walk_list!(visitor, visit_attribute, arm.attrs);\n }\n \n pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility<'v>) {"}, {"sha": "55e87663a1ee773de7187a3d40213fc3be4b99b2", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -139,11 +139,10 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for VisibilityKind<'_>\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitItem<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let TraitItem { def_id: _, ident, ref attrs, ref generics, ref kind, span } = *self;\n+        let TraitItem { def_id: _, ident, ref generics, ref kind, span } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n-            attrs.hash_stable(hcx, hasher);\n             generics.hash_stable(hcx, hasher);\n             kind.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n@@ -153,22 +152,13 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitItem<'_> {\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ImplItem<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let ImplItem {\n-            def_id: _,\n-            ident,\n-            ref vis,\n-            defaultness,\n-            ref attrs,\n-            ref generics,\n-            ref kind,\n-            span,\n-        } = *self;\n+        let ImplItem { def_id: _, ident, ref vis, defaultness, ref generics, ref kind, span } =\n+            *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             defaultness.hash_stable(hcx, hasher);\n-            attrs.hash_stable(hcx, hasher);\n             generics.hash_stable(hcx, hasher);\n             kind.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n@@ -178,11 +168,10 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ImplItem<'_> {\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ForeignItem<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let ForeignItem { def_id: _, ident, ref attrs, ref kind, span, ref vis } = *self;\n+        let ForeignItem { def_id: _, ident, ref kind, span, ref vis } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n-            attrs.hash_stable(hcx, hasher);\n             kind.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n@@ -192,11 +181,10 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ForeignItem<'_> {\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Item<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let Item { ident, ref attrs, def_id: _, ref kind, ref vis, span } = *self;\n+        let Item { ident, def_id: _, ref kind, ref vis, span } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n-            attrs.hash_stable(hcx, hasher);\n             kind.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n@@ -206,11 +194,10 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Item<'_> {\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for MacroDef<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let MacroDef { ident, ref attrs, def_id: _, ref ast, ref vis, span } = *self;\n+        let MacroDef { ident, def_id: _, ref ast, ref vis, span } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n-            attrs.hash_stable(hcx, hasher);\n             ast.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);"}, {"sha": "9c2766a16318db38794b02f148a9893697618926", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -16,6 +16,7 @@ use rustc_target::spec::abi::Abi;\n \n use std::borrow::Cow;\n use std::cell::Cell;\n+use std::collections::BTreeMap;\n use std::vec;\n \n pub fn id_to_string(map: &dyn rustc_hir::intravisit::Map<'_>, hir_id: hir::HirId) -> String {\n@@ -82,6 +83,7 @@ impl PpAnn for &dyn rustc_hir::intravisit::Map<'_> {\n pub struct State<'a> {\n     pub s: pp::Printer,\n     comments: Option<Comments<'a>>,\n+    attrs: &'a BTreeMap<hir::HirId, &'a [ast::Attribute]>,\n     ann: &'a (dyn PpAnn + 'a),\n }\n \n@@ -163,12 +165,12 @@ pub fn print_crate<'a>(\n     input: String,\n     ann: &'a dyn PpAnn,\n ) -> String {\n-    let mut s = State::new_from_input(sm, filename, input, ann);\n+    let mut s = State::new_from_input(sm, filename, input, &krate.attrs, ann);\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n \n-    s.print_mod(&krate.item.module, &krate.item.attrs);\n+    s.print_mod(&krate.item.module, s.attrs(hir::CRATE_HIR_ID));\n     s.print_remaining_comments();\n     s.s.eof()\n }\n@@ -178,17 +180,28 @@ impl<'a> State<'a> {\n         sm: &'a SourceMap,\n         filename: FileName,\n         input: String,\n+        attrs: &'a BTreeMap<hir::HirId, &[ast::Attribute]>,\n         ann: &'a dyn PpAnn,\n     ) -> State<'a> {\n-        State { s: pp::mk_printer(), comments: Some(Comments::new(sm, filename, input)), ann }\n+        State {\n+            s: pp::mk_printer(),\n+            comments: Some(Comments::new(sm, filename, input)),\n+            attrs,\n+            ann,\n+        }\n+    }\n+\n+    fn attrs(&self, id: hir::HirId) -> &'a [ast::Attribute] {\n+        self.attrs.get(&id).map_or(&[], |la| *la)\n     }\n }\n \n pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n where\n     F: FnOnce(&mut State<'_>),\n {\n-    let mut printer = State { s: pp::mk_printer(), comments: None, ann };\n+    let mut printer =\n+        State { s: pp::mk_printer(), comments: None, attrs: &BTreeMap::default(), ann };\n     f(&mut printer);\n     printer.s.eof()\n }\n@@ -441,7 +454,7 @@ impl<'a> State<'a> {\n     pub fn print_foreign_item(&mut self, item: &hir::ForeignItem<'_>) {\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(item.span.lo());\n-        self.print_outer_attributes(&item.attrs);\n+        self.print_outer_attributes(self.attrs(item.hir_id()));\n         match item.kind {\n             hir::ForeignItemKind::Fn(ref decl, ref arg_names, ref generics) => {\n                 self.head(\"\");\n@@ -549,7 +562,8 @@ impl<'a> State<'a> {\n     pub fn print_item(&mut self, item: &hir::Item<'_>) {\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(item.span.lo());\n-        self.print_outer_attributes(&item.attrs);\n+        let attrs = self.attrs(item.hir_id());\n+        self.print_outer_attributes(attrs);\n         self.ann.pre(self, AnnNode::Item(item));\n         match item.kind {\n             hir::ItemKind::ExternCrate(orig_name) => {\n@@ -634,14 +648,14 @@ impl<'a> State<'a> {\n                 self.print_ident(item.ident);\n                 self.nbsp();\n                 self.bopen();\n-                self.print_mod(_mod, &item.attrs);\n+                self.print_mod(_mod, attrs);\n                 self.bclose(item.span);\n             }\n             hir::ItemKind::ForeignMod { abi, items } => {\n                 self.head(\"extern\");\n                 self.word_nbsp(abi.to_string());\n                 self.bopen();\n-                self.print_inner_attributes(item.attrs);\n+                self.print_inner_attributes(self.attrs(item.hir_id()));\n                 for item in items {\n                     self.ann.nested(self, Nested::ForeignItem(item.id));\n                 }\n@@ -725,7 +739,7 @@ impl<'a> State<'a> {\n \n                 self.s.space();\n                 self.bopen();\n-                self.print_inner_attributes(&item.attrs);\n+                self.print_inner_attributes(attrs);\n                 for impl_item in items {\n                     self.ann.nested(self, Nested::ImplItem(impl_item.id));\n                 }\n@@ -822,7 +836,7 @@ impl<'a> State<'a> {\n         for v in variants {\n             self.space_if_not_bol();\n             self.maybe_print_comment(v.span.lo());\n-            self.print_outer_attributes(&v.attrs);\n+            self.print_outer_attributes(self.attrs(v.id));\n             self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n             self.s.word(\",\");\n@@ -876,7 +890,7 @@ impl<'a> State<'a> {\n                     self.popen();\n                     self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n                         s.maybe_print_comment(field.span.lo());\n-                        s.print_outer_attributes(&field.attrs);\n+                        s.print_outer_attributes(s.attrs(field.hir_id));\n                         s.print_visibility(&field.vis);\n                         s.print_type(&field.ty)\n                     });\n@@ -898,7 +912,7 @@ impl<'a> State<'a> {\n                 for field in struct_def.fields() {\n                     self.hardbreak_if_not_bol();\n                     self.maybe_print_comment(field.span.lo());\n-                    self.print_outer_attributes(&field.attrs);\n+                    self.print_outer_attributes(self.attrs(field.hir_id));\n                     self.print_visibility(&field.vis);\n                     self.print_ident(field.ident);\n                     self.word_nbsp(\":\");\n@@ -937,7 +951,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::SubItem(ti.hir_id()));\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(ti.span.lo());\n-        self.print_outer_attributes(&ti.attrs);\n+        self.print_outer_attributes(self.attrs(ti.hir_id()));\n         match ti.kind {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 let vis =\n@@ -976,7 +990,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::SubItem(ii.hir_id()));\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(ii.span.lo());\n-        self.print_outer_attributes(&ii.attrs);\n+        self.print_outer_attributes(self.attrs(ii.hir_id()));\n         self.print_defaultness(ii.defaultness);\n \n         match ii.kind {\n@@ -1321,7 +1335,7 @@ impl<'a> State<'a> {\n \n     pub fn print_expr(&mut self, expr: &hir::Expr<'_>) {\n         self.maybe_print_comment(expr.span.lo());\n-        self.print_outer_attributes(&expr.attrs);\n+        self.print_outer_attributes(self.attrs(expr.hir_id));\n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n         match expr.kind {\n@@ -2020,20 +2034,20 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_param(&mut self, arg: &hir::Param<'_>) {\n-        self.print_outer_attributes(&arg.attrs);\n+        self.print_outer_attributes(self.attrs(arg.hir_id));\n         self.print_pat(&arg.pat);\n     }\n \n     pub fn print_arm(&mut self, arm: &hir::Arm<'_>) {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n-        if arm.attrs.is_empty() {\n+        if self.attrs(arm.hir_id).is_empty() {\n             self.s.space();\n         }\n         self.cbox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Arm(arm));\n         self.ibox(0);\n-        self.print_outer_attributes(&arm.attrs);\n+        self.print_outer_attributes(&self.attrs(arm.hir_id));\n         self.print_pat(&arm.pat);\n         self.s.space();\n         if let Some(ref g) = arm.guard {"}, {"sha": "89a5836d6dfe71b12d62e4c512215ed29e85a72a", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -68,7 +68,7 @@ pub fn assert_dep_graph(tcx: TyCtxt<'_>) {\n         let (if_this_changed, then_this_would_need) = {\n             let mut visitor =\n                 IfThisChanged { tcx, if_this_changed: vec![], then_this_would_need: vec![] };\n-            visitor.process_attrs(hir::CRATE_HIR_ID, &tcx.hir().krate().item.attrs);\n+            visitor.process_attrs(hir::CRATE_HIR_ID);\n             tcx.hir().krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n             (visitor.if_this_changed, visitor.then_this_would_need)\n         };\n@@ -113,9 +113,10 @@ impl IfThisChanged<'tcx> {\n         value\n     }\n \n-    fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n+    fn process_attrs(&mut self, hir_id: hir::HirId) {\n         let def_id = self.tcx.hir().local_def_id(hir_id);\n         let def_path_hash = self.tcx.def_path_hash(def_id.to_def_id());\n+        let attrs = self.tcx.hir().attrs(hir_id);\n         for attr in attrs {\n             if self.tcx.sess.check_name(attr, sym::rustc_if_this_changed) {\n                 let dep_node_interned = self.argument(attr);\n@@ -167,22 +168,22 @@ impl Visitor<'tcx> for IfThisChanged<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.process_attrs(item.hir_id(), &item.attrs);\n+        self.process_attrs(item.hir_id());\n         intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.process_attrs(trait_item.hir_id(), &trait_item.attrs);\n+        self.process_attrs(trait_item.hir_id());\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.process_attrs(impl_item.hir_id(), &impl_item.attrs);\n+        self.process_attrs(impl_item.hir_id());\n         intravisit::walk_impl_item(self, impl_item);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n-        self.process_attrs(s.hir_id, &s.attrs);\n+        self.process_attrs(s.hir_id);\n         intravisit::walk_struct_field(self, s);\n     }\n }"}, {"sha": "5fb2c1cb9c9236e314a052cf1fb00dd062225da2", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -44,7 +44,7 @@ pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n \n         let ams = AssertModuleSource { tcx, available_cgus };\n \n-        for attr in tcx.hir().krate().item.attrs {\n+        for attr in tcx.hir().attrs(rustc_hir::CRATE_HIR_ID) {\n             ams.check_attr(attr);\n         }\n     })"}, {"sha": "0b544b8ab415e4458d4907ff2644b1bcedd6bbc0", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -168,7 +168,7 @@ pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n         // Note that we cannot use the existing \"unused attribute\"-infrastructure\n         // here, since that is running before codegen. This is also the reason why\n         // all codegen-specific attributes are `AssumedUsed` in rustc_ast::feature_gate.\n-        all_attrs.report_unchecked_attrs(&dirty_clean_visitor.checked_attrs);\n+        all_attrs.report_unchecked_attrs(dirty_clean_visitor.checked_attrs);\n     })\n }\n \n@@ -535,13 +535,14 @@ impl FindAllAttrs<'_, 'tcx> {\n         false\n     }\n \n-    fn report_unchecked_attrs(&self, checked_attrs: &FxHashSet<ast::AttrId>) {\n+    fn report_unchecked_attrs(&self, mut checked_attrs: FxHashSet<ast::AttrId>) {\n         for attr in &self.found_attrs {\n             if !checked_attrs.contains(&attr.id) {\n                 self.tcx.sess.span_err(\n                     attr.span,\n                     \"found unchecked `#[rustc_dirty]` / `#[rustc_clean]` attribute\",\n                 );\n+                checked_attrs.insert(attr.id);\n             }\n         }\n     }\n@@ -554,7 +555,7 @@ impl intravisit::Visitor<'tcx> for FindAllAttrs<'_, 'tcx> {\n         intravisit::NestedVisitorMap::All(self.tcx.hir())\n     }\n \n-    fn visit_attribute(&mut self, attr: &'tcx Attribute) {\n+    fn visit_attribute(&mut self, _: hir::HirId, attr: &'tcx Attribute) {\n         if self.is_active_attr(attr) {\n             self.found_attrs.push(attr);\n         }"}, {"sha": "3882818952c33dfa580c21cf437af25606e1ea64", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -695,9 +695,7 @@ impl<I: Idx, T> IndexVec<I, T> {\n     pub fn convert_index_type<Ix: Idx>(self) -> IndexVec<Ix, T> {\n         IndexVec { raw: self.raw, _marker: PhantomData }\n     }\n-}\n \n-impl<I: Idx, T: Clone> IndexVec<I, T> {\n     /// Grows the index vector so that it contains an entry for\n     /// `elem`; if that is already true, then has no\n     /// effect. Otherwise, inserts new values as needed by invoking\n@@ -710,18 +708,20 @@ impl<I: Idx, T: Clone> IndexVec<I, T> {\n         }\n     }\n \n-    #[inline]\n-    pub fn resize(&mut self, new_len: usize, value: T) {\n-        self.raw.resize(new_len, value)\n-    }\n-\n     #[inline]\n     pub fn resize_to_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n         let min_new_len = elem.index() + 1;\n         self.raw.resize_with(min_new_len, fill_value);\n     }\n }\n \n+impl<I: Idx, T: Clone> IndexVec<I, T> {\n+    #[inline]\n+    pub fn resize(&mut self, new_len: usize, value: T) {\n+        self.raw.resize(new_len, value)\n+    }\n+}\n+\n impl<I: Idx, T: Ord> IndexVec<I, T> {\n     #[inline]\n     pub fn binary_search(&self, value: &T) -> Result<I, I> {"}, {"sha": "4637055a82ded1827fad57cb82a208dbec99831c", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -25,7 +25,8 @@ struct Finder<'tcx> {\n \n impl<'v> ItemLikeVisitor<'v> for Finder<'_> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if self.tcx.sess.contains_name(&item.attrs, sym::rustc_proc_macro_decls) {\n+        let attrs = self.tcx.hir().attrs(item.hir_id());\n+        if self.tcx.sess.contains_name(attrs, sym::rustc_proc_macro_decls) {\n             self.decls = Some(item.hir_id());\n         }\n     }"}, {"sha": "dca5e470e7fb93590d5b1ddd9d27255e865b06ff", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 17, "deletions": 42, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -508,8 +508,7 @@ impl MissingDoc {\n     fn check_missing_docs_attrs(\n         &self,\n         cx: &LateContext<'_>,\n-        id: Option<hir::HirId>,\n-        attrs: &[ast::Attribute],\n+        id: hir::HirId,\n         sp: Span,\n         article: &'static str,\n         desc: &'static str,\n@@ -528,12 +527,13 @@ impl MissingDoc {\n         // Only check publicly-visible items, using the result from the privacy pass.\n         // It's an option so the crate root can also use this function (it doesn't\n         // have a `NodeId`).\n-        if let Some(id) = id {\n+        if id != hir::CRATE_HIR_ID {\n             if !cx.access_levels.is_exported(id) {\n                 return;\n             }\n         }\n \n+        let attrs = cx.tcx.hir().attrs(id);\n         let has_doc = attrs.iter().any(|a| has_doc(cx.sess(), a));\n         if !has_doc {\n             cx.struct_span_lint(\n@@ -565,10 +565,11 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &LateContext<'_>, krate: &hir::Crate<'_>) {\n-        self.check_missing_docs_attrs(cx, None, &krate.item.attrs, krate.item.span, \"the\", \"crate\");\n+        self.check_missing_docs_attrs(cx, hir::CRATE_HIR_ID, krate.item.span, \"the\", \"crate\");\n \n         for macro_def in krate.exported_macros {\n-            let has_doc = macro_def.attrs.iter().any(|a| has_doc(cx.sess(), a));\n+            let attrs = cx.tcx.hir().attrs(macro_def.hir_id());\n+            let has_doc = attrs.iter().any(|a| has_doc(cx.sess(), a));\n             if !has_doc {\n                 cx.struct_span_lint(\n                     MISSING_DOCS,\n@@ -622,7 +623,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n         let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, Some(it.hir_id()), &it.attrs, it.span, article, desc);\n+        self.check_missing_docs_attrs(cx, it.hir_id(), it.span, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, trait_item: &hir::TraitItem<'_>) {\n@@ -632,14 +633,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n         let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(\n-            cx,\n-            Some(trait_item.hir_id()),\n-            &trait_item.attrs,\n-            trait_item.span,\n-            article,\n-            desc,\n-        );\n+        self.check_missing_docs_attrs(cx, trait_item.hir_id(), trait_item.span, article, desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n@@ -649,43 +643,22 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n         }\n \n         let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(\n-            cx,\n-            Some(impl_item.hir_id()),\n-            &impl_item.attrs,\n-            impl_item.span,\n-            article,\n-            desc,\n-        );\n+        self.check_missing_docs_attrs(cx, impl_item.hir_id(), impl_item.span, article, desc);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'_>) {\n         let (article, desc) = cx.tcx.article_and_description(foreign_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(\n-            cx,\n-            Some(foreign_item.hir_id()),\n-            &foreign_item.attrs,\n-            foreign_item.span,\n-            article,\n-            desc,\n-        );\n+        self.check_missing_docs_attrs(cx, foreign_item.hir_id(), foreign_item.span, article, desc);\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext<'_>, sf: &hir::StructField<'_>) {\n         if !sf.is_positional() {\n-            self.check_missing_docs_attrs(\n-                cx,\n-                Some(sf.hir_id),\n-                &sf.attrs,\n-                sf.span,\n-                \"a\",\n-                \"struct field\",\n-            )\n+            self.check_missing_docs_attrs(cx, sf.hir_id, sf.span, \"a\", \"struct field\")\n         }\n     }\n \n     fn check_variant(&mut self, cx: &LateContext<'_>, v: &hir::Variant<'_>) {\n-        self.check_missing_docs_attrs(cx, Some(v.id), &v.attrs, v.span, \"a\", \"variant\");\n+        self.check_missing_docs_attrs(cx, v.id, v.span, \"a\", \"variant\");\n     }\n }\n \n@@ -1119,9 +1092,10 @@ declare_lint_pass!(InvalidNoMangleItems => [NO_MANGLE_CONST_ITEMS, NO_MANGLE_GEN\n \n impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n+        let attrs = cx.tcx.hir().attrs(it.hir_id());\n         match it.kind {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n-                if let Some(no_mangle_attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+                if let Some(no_mangle_attr) = cx.sess().find_by_name(attrs, sym::no_mangle) {\n                     for param in generics.params {\n                         match param.kind {\n                             GenericParamKind::Lifetime { .. } => {}\n@@ -1147,7 +1121,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                 }\n             }\n             hir::ItemKind::Const(..) => {\n-                if cx.sess().contains_name(&it.attrs, sym::no_mangle) {\n+                if cx.sess().contains_name(attrs, sym::no_mangle) {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, |lint| {\n@@ -1827,7 +1801,8 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n             return;\n         }\n \n-        if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::rustc_test_marker) {\n+        let attrs = cx.tcx.hir().attrs(it.hir_id());\n+        if let Some(attr) = cx.sess().find_by_name(attrs, sym::rustc_test_marker) {\n             cx.struct_span_lint(UNNAMEABLE_TEST_ITEMS, attr.span, |lint| {\n                 lint.build(\"cannot test inner items\").emit()\n             });"}, {"sha": "9b1a339572ec3cfe5b9fde1709d72415c3aba51a", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -283,7 +283,7 @@ fn is_doc_keyword(s: Symbol) -> bool {\n \n impl<'tcx> LateLintPass<'tcx> for ExistingDocKeyword {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &rustc_hir::Item<'_>) {\n-        for attr in item.attrs {\n+        for attr in cx.tcx.hir().attrs(item.hir_id()) {\n             if !attr.has_name(sym::doc) {\n                 continue;\n             }"}, {"sha": "9a64737f3a25db86c8976752d7103971c9157b4f", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -16,7 +16,6 @@\n \n use crate::{passes::LateLintPassObject, LateContext, LateLintPass, LintStore};\n use rustc_ast as ast;\n-use rustc_ast::walk_list;\n use rustc_data_structures::sync::{join, par_iter, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n@@ -53,10 +52,11 @@ impl<'tcx, T: LateLintPass<'tcx>> LateContextAndPass<'tcx, T> {\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n-    fn with_lint_attrs<F>(&mut self, id: hir::HirId, attrs: &'tcx [ast::Attribute], f: F)\n+    fn with_lint_attrs<F>(&mut self, id: hir::HirId, f: F)\n     where\n         F: FnOnce(&mut Self),\n     {\n+        let attrs = self.context.tcx.hir().attrs(id);\n         let prev = self.context.last_node_with_lint_attrs;\n         self.context.last_node_with_lint_attrs = id;\n         self.enter_attrs(attrs);\n@@ -125,7 +125,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        self.with_lint_attrs(param.hir_id, &param.attrs, |cx| {\n+        self.with_lint_attrs(param.hir_id, |cx| {\n             lint_callback!(cx, check_param, param);\n             hir_visit::walk_param(cx, param);\n         });\n@@ -142,7 +142,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         self.context.generics = it.kind.generics();\n         let old_cached_typeck_results = self.context.cached_typeck_results.take();\n         let old_enclosing_body = self.context.enclosing_body.take();\n-        self.with_lint_attrs(it.hir_id(), &it.attrs, |cx| {\n+        self.with_lint_attrs(it.hir_id(), |cx| {\n             cx.with_param_env(it.hir_id(), |cx| {\n                 lint_callback!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n@@ -155,7 +155,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n-        self.with_lint_attrs(it.hir_id(), &it.attrs, |cx| {\n+        self.with_lint_attrs(it.hir_id(), |cx| {\n             cx.with_param_env(it.hir_id(), |cx| {\n                 lint_callback!(cx, check_foreign_item, it);\n                 hir_visit::walk_foreign_item(cx, it);\n@@ -170,19 +170,17 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n-        self.with_lint_attrs(e.hir_id, &e.attrs, |cx| {\n+        self.with_lint_attrs(e.hir_id, |cx| {\n             lint_callback!(cx, check_expr, e);\n             hir_visit::walk_expr(cx, e);\n             lint_callback!(cx, check_expr_post, e);\n         })\n     }\n \n     fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n-        let get_item = |id: hir::ItemId| self.context.tcx.hir().item(id);\n-        let attrs = &s.kind.attrs(get_item);\n         // See `EarlyContextAndPass::visit_stmt` for an explanation\n         // of why we call `walk_stmt` outside of `with_lint_attrs`\n-        self.with_lint_attrs(s.hir_id, attrs, |cx| {\n+        self.with_lint_attrs(s.hir_id, |cx| {\n             lint_callback!(cx, check_stmt, s);\n         });\n         hir_visit::walk_stmt(self, s);\n@@ -222,7 +220,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n-        self.with_lint_attrs(s.hir_id, &s.attrs, |cx| {\n+        self.with_lint_attrs(s.hir_id, |cx| {\n             lint_callback!(cx, check_struct_field, s);\n             hir_visit::walk_struct_field(cx, s);\n         })\n@@ -234,7 +232,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         g: &'tcx hir::Generics<'tcx>,\n         item_id: hir::HirId,\n     ) {\n-        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n+        self.with_lint_attrs(v.id, |cx| {\n             lint_callback!(cx, check_variant, v);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             lint_callback!(cx, check_variant_post, v);\n@@ -257,7 +255,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        self.with_lint_attrs(l.hir_id, &l.attrs, |cx| {\n+        self.with_lint_attrs(l.hir_id, |cx| {\n             lint_callback!(cx, check_local, l);\n             hir_visit::walk_local(cx, l);\n         })\n@@ -301,7 +299,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         let generics = self.context.generics.take();\n         self.context.generics = Some(&trait_item.generics);\n-        self.with_lint_attrs(trait_item.hir_id(), &trait_item.attrs, |cx| {\n+        self.with_lint_attrs(trait_item.hir_id(), |cx| {\n             cx.with_param_env(trait_item.hir_id(), |cx| {\n                 lint_callback!(cx, check_trait_item, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n@@ -314,7 +312,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         let generics = self.context.generics.take();\n         self.context.generics = Some(&impl_item.generics);\n-        self.with_lint_attrs(impl_item.hir_id(), &impl_item.attrs, |cx| {\n+        self.with_lint_attrs(impl_item.hir_id(), |cx| {\n             cx.with_param_env(impl_item.hir_id(), |cx| {\n                 lint_callback!(cx, check_impl_item, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n@@ -334,8 +332,10 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         hir_visit::walk_path(self, p);\n     }\n \n-    fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n-        lint_callback!(self, check_attribute, attr);\n+    fn visit_attribute(&mut self, hir_id: hir::HirId, attr: &'tcx ast::Attribute) {\n+        self.with_lint_attrs(hir_id, |cx| {\n+            lint_callback!(cx, check_attribute, attr);\n+        })\n     }\n }\n \n@@ -396,7 +396,9 @@ fn late_lint_mod_pass<'tcx, T: LateLintPass<'tcx>>(\n \n     // Visit the crate attributes\n     if hir_id == hir::CRATE_HIR_ID {\n-        walk_list!(cx, visit_attribute, tcx.hir().attrs(hir::CRATE_HIR_ID));\n+        for attr in tcx.hir().attrs(hir::CRATE_HIR_ID).iter() {\n+            cx.visit_attribute(hir_id, attr)\n+        }\n     }\n }\n \n@@ -440,7 +442,7 @@ fn late_lint_pass_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, pass: T)\n     let mut cx = LateContextAndPass { context, pass };\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.item.attrs, |cx| {\n+    cx.with_lint_attrs(hir::CRATE_HIR_ID, |cx| {\n         // since the root module isn't visited as an item (because it isn't an\n         // item), warn for it here.\n         lint_callback!(cx, check_crate, krate);"}, {"sha": "b3bdaf5bdc7d0de54c486117f36e42b3817836fd", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -38,7 +38,7 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> LintLevelMap {\n \n     builder.levels.id_to_set.reserve(krate.exported_macros.len() + 1);\n \n-    let push = builder.levels.push(&krate.item.attrs, &store, true);\n+    let push = builder.levels.push(tcx.hir().attrs(hir::CRATE_HIR_ID), &store, true);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n     for macro_def in krate.exported_macros {\n         builder.levels.register_id(macro_def.hir_id());\n@@ -566,11 +566,12 @@ struct LintLevelMapBuilder<'a, 'tcx> {\n }\n \n impl LintLevelMapBuilder<'_, '_> {\n-    fn with_lint_attrs<F>(&mut self, id: hir::HirId, attrs: &[ast::Attribute], f: F)\n+    fn with_lint_attrs<F>(&mut self, id: hir::HirId, f: F)\n     where\n         F: FnOnce(&mut Self),\n     {\n         let is_crate_hir = id == hir::CRATE_HIR_ID;\n+        let attrs = self.tcx.hir().attrs(id);\n         let push = self.levels.push(attrs, self.store, is_crate_hir);\n         if push.changed {\n             self.levels.register_id(id);\n@@ -588,19 +589,19 @@ impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        self.with_lint_attrs(param.hir_id, &param.attrs, |builder| {\n+        self.with_lint_attrs(param.hir_id, |builder| {\n             intravisit::walk_param(builder, param);\n         });\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        self.with_lint_attrs(it.hir_id(), &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id(), |builder| {\n             intravisit::walk_item(builder, it);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n-        self.with_lint_attrs(it.hir_id(), &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id(), |builder| {\n             intravisit::walk_foreign_item(builder, it);\n         })\n     }\n@@ -613,13 +614,13 @@ impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n-        self.with_lint_attrs(e.hir_id, &e.attrs, |builder| {\n+        self.with_lint_attrs(e.hir_id, |builder| {\n             intravisit::walk_expr(builder, e);\n         })\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n-        self.with_lint_attrs(s.hir_id, &s.attrs, |builder| {\n+        self.with_lint_attrs(s.hir_id, |builder| {\n             intravisit::walk_struct_field(builder, s);\n         })\n     }\n@@ -630,31 +631,31 @@ impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         g: &'tcx hir::Generics<'tcx>,\n         item_id: hir::HirId,\n     ) {\n-        self.with_lint_attrs(v.id, &v.attrs, |builder| {\n+        self.with_lint_attrs(v.id, |builder| {\n             intravisit::walk_variant(builder, v, g, item_id);\n         })\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        self.with_lint_attrs(l.hir_id, &l.attrs, |builder| {\n+        self.with_lint_attrs(l.hir_id, |builder| {\n             intravisit::walk_local(builder, l);\n         })\n     }\n \n     fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n-        self.with_lint_attrs(a.hir_id, &a.attrs, |builder| {\n+        self.with_lint_attrs(a.hir_id, |builder| {\n             intravisit::walk_arm(builder, a);\n         })\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.with_lint_attrs(trait_item.hir_id(), &trait_item.attrs, |builder| {\n+        self.with_lint_attrs(trait_item.hir_id(), |builder| {\n             intravisit::walk_trait_item(builder, trait_item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.with_lint_attrs(impl_item.hir_id(), &impl_item.attrs, |builder| {\n+        self.with_lint_attrs(impl_item.hir_id(), |builder| {\n             intravisit::walk_impl_item(builder, impl_item);\n         });\n     }"}, {"sha": "be9c6eafb6fdbf6801a340cd31b9ddf0f72aca61", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -400,14 +400,15 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n                 }\n                 _ => (),\n             },\n-            FnKind::ItemFn(ident, _, header, _, attrs) => {\n+            FnKind::ItemFn(ident, _, header, _) => {\n+                let attrs = cx.tcx.hir().attrs(id);\n                 // Skip foreign-ABI #[no_mangle] functions (Issue #31924)\n                 if header.abi != Abi::Rust && cx.sess().contains_name(attrs, sym::no_mangle) {\n                     return;\n                 }\n                 self.check_snake_case(cx, \"function\", ident);\n             }\n-            FnKind::Closure(_) => (),\n+            FnKind::Closure => (),\n         }\n     }\n \n@@ -504,8 +505,9 @@ impl NonUpperCaseGlobals {\n \n impl<'tcx> LateLintPass<'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n+        let attrs = cx.tcx.hir().attrs(it.hir_id());\n         match it.kind {\n-            hir::ItemKind::Static(..) if !cx.sess().contains_name(&it.attrs, sym::no_mangle) => {\n+            hir::ItemKind::Static(..) if !cx.sess().contains_name(attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n             }\n             hir::ItemKind::Const(..) => {"}, {"sha": "67946dfb292a6d6b2c5714077bebb6416dad8e6f", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -406,6 +406,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAttributes {\n         if !cx.sess().is_attr_used(attr) {\n             debug!(\"emitting warning for: {:?}\", attr);\n             cx.struct_span_lint(UNUSED_ATTRIBUTES, attr.span, |lint| {\n+                // Mark as used to avoid duplicate warnings.\n+                cx.sess().mark_attr_used(attr);\n                 lint.build(\"unused attribute\").emit()\n             });\n             // Is it a builtin attribute that must be used at the crate level?"}, {"sha": "9e1ac33368c7fdad810b923f1455f56feebe34f9", "filename": "compiler/rustc_metadata/src/link_args.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_metadata%2Fsrc%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_metadata%2Fsrc%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flink_args.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -8,7 +8,7 @@ crate fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n     let mut collector = Collector { tcx, args: Vec::new() };\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n-    for attr in tcx.hir().krate().item.attrs.iter() {\n+    for attr in tcx.hir().attrs(hir::CRATE_HIR_ID).iter() {\n         if attr.has_name(sym::link_args) {\n             if let Some(linkarg) = attr.value_str() {\n                 collector.add_link_args(linkarg);\n@@ -36,7 +36,9 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector<'tcx> {\n \n         // First, add all of the custom #[link_args] attributes\n         let sess = &self.tcx.sess;\n-        for m in it.attrs.iter().filter(|a| sess.check_name(a, sym::link_args)) {\n+        for m in\n+            self.tcx.hir().attrs(it.hir_id()).iter().filter(|a| sess.check_name(a, sym::link_args))\n+        {\n             if let Some(linkarg) = m.value_str() {\n                 self.add_link_args(linkarg);\n             }"}, {"sha": "523e016eeb9f2726dbc700504b8d7634261de200", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -44,7 +44,8 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n \n         // Process all of the #[link(..)]-style arguments\n         let sess = &self.tcx.sess;\n-        for m in it.attrs.iter().filter(|a| sess.check_name(a, sym::link)) {\n+        for m in self.tcx.hir().attrs(it.hir_id()).iter().filter(|a| sess.check_name(a, sym::link))\n+        {\n             let items = match m.meta_item_list() {\n                 Some(item) => item,\n                 None => continue,"}, {"sha": "706c79009496b903bd1bb81492d105cdf21d6856", "filename": "compiler/rustc_middle/src/hir/map/blocks.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -12,7 +12,6 @@\n //! for the `Code` associated with a particular NodeId.\n \n use crate::hir::map::Map;\n-use rustc_ast::Attribute;\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Expr, FnDecl, Node};\n@@ -105,7 +104,6 @@ struct ItemFnParts<'a> {\n     body: hir::BodyId,\n     id: hir::HirId,\n     span: Span,\n-    attrs: &'a [Attribute],\n }\n \n /// These are all the components one can extract from a closure expr\n@@ -115,18 +113,11 @@ struct ClosureParts<'a> {\n     body: hir::BodyId,\n     id: hir::HirId,\n     span: Span,\n-    attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(\n-        d: &'a FnDecl<'a>,\n-        b: hir::BodyId,\n-        id: hir::HirId,\n-        s: Span,\n-        attrs: &'a [Attribute],\n-    ) -> Self {\n-        ClosureParts { decl: d, body: b, id, span: s, attrs }\n+    fn new(d: &'a FnDecl<'a>, b: hir::BodyId, id: hir::HirId, s: Span) -> Self {\n+        ClosureParts { decl: d, body: b, id, span: s }\n     }\n }\n \n@@ -146,31 +137,31 @@ impl<'a> FnLikeNode<'a> {\n     pub fn body(self) -> hir::BodyId {\n         self.handle(\n             |i: ItemFnParts<'a>| i.body,\n-            |_, _, _: &'a hir::FnSig<'a>, _, body: hir::BodyId, _, _| body,\n+            |_, _, _: &'a hir::FnSig<'a>, _, body: hir::BodyId, _| body,\n             |c: ClosureParts<'a>| c.body,\n         )\n     }\n \n     pub fn decl(self) -> &'a FnDecl<'a> {\n         self.handle(\n             |i: ItemFnParts<'a>| &*i.decl,\n-            |_, _, sig: &'a hir::FnSig<'a>, _, _, _, _| &sig.decl,\n+            |_, _, sig: &'a hir::FnSig<'a>, _, _, _| &sig.decl,\n             |c: ClosureParts<'a>| c.decl,\n         )\n     }\n \n     pub fn span(self) -> Span {\n         self.handle(\n             |i: ItemFnParts<'_>| i.span,\n-            |_, _, _: &'a hir::FnSig<'a>, _, _, span, _| span,\n+            |_, _, _: &'a hir::FnSig<'a>, _, _, span| span,\n             |c: ClosureParts<'_>| c.span,\n         )\n     }\n \n     pub fn id(self) -> hir::HirId {\n         self.handle(\n             |i: ItemFnParts<'_>| i.id,\n-            |id, _, _: &'a hir::FnSig<'a>, _, _, _, _| id,\n+            |id, _, _: &'a hir::FnSig<'a>, _, _, _| id,\n             |c: ClosureParts<'_>| c.id,\n         )\n     }\n@@ -189,12 +180,11 @@ impl<'a> FnLikeNode<'a> {\n \n     pub fn kind(self) -> FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n-            FnKind::ItemFn(p.ident, p.generics, p.header, p.vis, p.attrs)\n-        };\n-        let closure = |c: ClosureParts<'a>| FnKind::Closure(c.attrs);\n-        let method = |_, ident: Ident, sig: &'a hir::FnSig<'a>, vis, _, _, attrs| {\n-            FnKind::Method(ident, sig, vis, attrs)\n+            FnKind::ItemFn(p.ident, p.generics, p.header, p.vis)\n         };\n+        let closure = |_: ClosureParts<'a>| FnKind::Closure;\n+        let method =\n+            |_, ident: Ident, sig: &'a hir::FnSig<'a>, vis, _, _| FnKind::Method(ident, sig, vis);\n         self.handle(item, method, closure)\n     }\n \n@@ -208,7 +198,6 @@ impl<'a> FnLikeNode<'a> {\n             Option<&'a hir::Visibility<'a>>,\n             hir::BodyId,\n             Span,\n-            &'a [Attribute],\n         ) -> A,\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n@@ -221,27 +210,26 @@ impl<'a> FnLikeNode<'a> {\n                     body: block,\n                     vis: &i.vis,\n                     span: i.span,\n-                    attrs: &i.attrs,\n                     header: sig.header,\n                     generics,\n                 }),\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n             Node::TraitItem(ti) => match ti.kind {\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                    method(ti.hir_id(), ti.ident, sig, None, body, ti.span, &ti.attrs)\n+                    method(ti.hir_id(), ti.ident, sig, None, body, ti.span)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             Node::ImplItem(ii) => match ii.kind {\n                 hir::ImplItemKind::Fn(ref sig, body) => {\n-                    method(ii.hir_id(), ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n+                    method(ii.hir_id(), ii.ident, sig, Some(&ii.vis), body, ii.span)\n                 }\n                 _ => bug!(\"impl method FnLikeNode that is not fn-like\"),\n             },\n             Node::Expr(e) => match e.kind {\n                 hir::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) => {\n-                    closure(ClosureParts::new(&decl, block, e.hir_id, e.span, &e.attrs))\n+                    closure(ClosureParts::new(&decl, block, e.hir_id, e.span))\n                 }\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },"}, {"sha": "b1dd405a6be6880187aa759b893d8407ccc9424c", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -116,6 +116,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                 modules: _,\n                 proc_macros: _,\n                 trait_map: _,\n+                attrs: _,\n             } = *krate;\n \n             hash_body(&mut hcx, root_mod_def_path_hash, item, &mut hir_body_nodes)"}, {"sha": "41ecffb9c5604c4c4cc34f9159c8abdcfa62863f", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -457,10 +457,7 @@ impl<'hir> Map<'hir> {\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n     pub fn krate_attrs(&self) -> &'hir [ast::Attribute] {\n-        match self.get_entry(CRATE_HIR_ID).node {\n-            Node::Crate(item) => item.attrs,\n-            _ => bug!(),\n-        }\n+        self.attrs(CRATE_HIR_ID)\n     }\n \n     pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n@@ -853,34 +850,7 @@ impl<'hir> Map<'hir> {\n     /// Given a node ID, gets a list of attributes associated with the AST\n     /// corresponding to the node-ID.\n     pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n-        self.find_entry(id).map_or(&[], |entry| match entry.node {\n-            Node::Param(a) => a.attrs,\n-            Node::Local(l) => &l.attrs[..],\n-            Node::Item(i) => i.attrs,\n-            Node::ForeignItem(fi) => fi.attrs,\n-            Node::TraitItem(ref ti) => ti.attrs,\n-            Node::ImplItem(ref ii) => ii.attrs,\n-            Node::Variant(ref v) => v.attrs,\n-            Node::Field(ref f) => f.attrs,\n-            Node::Expr(ref e) => &*e.attrs,\n-            Node::Stmt(ref s) => s.kind.attrs(|id| self.item(id)),\n-            Node::Arm(ref a) => &*a.attrs,\n-            Node::GenericParam(param) => param.attrs,\n-            // Unit/tuple structs/variants take the attributes straight from\n-            // the struct/variant definition.\n-            Node::Ctor(..) => self.attrs(self.get_parent_item(id)),\n-            Node::Crate(item) => item.attrs,\n-            Node::MacroDef(def) => def.attrs,\n-            Node::AnonConst(..)\n-            | Node::PathSegment(..)\n-            | Node::Ty(..)\n-            | Node::Pat(..)\n-            | Node::Binding(..)\n-            | Node::TraitRef(..)\n-            | Node::Block(..)\n-            | Node::Lifetime(..)\n-            | Node::Visibility(..) => &[],\n-        })\n+        self.tcx.hir_attrs(id.owner).get(id.local_id)\n     }\n \n     /// Gets the span of the definition of the specified HIR node."}, {"sha": "cf4e473d8aca1691561e553411f63f6634e62be4", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -9,13 +9,15 @@ pub mod place;\n use crate::ich::StableHashingContext;\n use crate::ty::query::Providers;\n use crate::ty::TyCtxt;\n+use rustc_ast::Attribute;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n use rustc_span::DUMMY_SP;\n+use std::collections::BTreeMap;\n \n #[derive(Debug)]\n pub struct Owner<'tcx> {\n@@ -55,6 +57,48 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OwnerNodes<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone)]\n+pub struct AttributeMap<'tcx> {\n+    map: &'tcx BTreeMap<HirId, &'tcx [Attribute]>,\n+    prefix: LocalDefId,\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for AttributeMap<'tcx> {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        let range = self.range();\n+\n+        range.clone().count().hash_stable(hcx, hasher);\n+        for (key, value) in range {\n+            key.hash_stable(hcx, hasher);\n+            value.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+impl<'tcx> std::fmt::Debug for AttributeMap<'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"AttributeMap\")\n+            .field(\"prefix\", &self.prefix)\n+            .field(\"range\", &&self.range().collect::<Vec<_>>()[..])\n+            .finish()\n+    }\n+}\n+\n+impl<'tcx> AttributeMap<'tcx> {\n+    fn get(&self, id: ItemLocalId) -> &'tcx [Attribute] {\n+        self.map.get(&HirId { owner: self.prefix, local_id: id }).copied().unwrap_or(&[])\n+    }\n+\n+    fn range(&self) -> std::collections::btree_map::Range<'_, rustc_hir::HirId, &[Attribute]> {\n+        let local_zero = ItemLocalId::from_u32(0);\n+        let range = HirId { owner: self.prefix, local_id: local_zero }..HirId {\n+            owner: LocalDefId { local_def_index: self.prefix.local_def_index + 1 },\n+            local_id: local_zero,\n+        };\n+        self.map.range(range)\n+    }\n+}\n+\n impl<'tcx> TyCtxt<'tcx> {\n     #[inline(always)]\n     pub fn hir(self) -> map::Map<'tcx> {\n@@ -76,6 +120,7 @@ pub fn provide(providers: &mut Providers) {\n     providers.hir_module_items = |tcx, id| &tcx.untracked_crate.modules[&id];\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;\n     providers.hir_owner_nodes = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_deref();\n+    providers.hir_attrs = |tcx, id| AttributeMap { map: &tcx.untracked_crate.attrs, prefix: id };\n     providers.def_span = |tcx, def_id| tcx.hir().span_if_local(def_id).unwrap_or(DUMMY_SP);\n     providers.fn_arg_names = |tcx, id| {\n         let hir = tcx.hir();"}, {"sha": "abf56832329b2a6c6a3380eaa1998b4ef90288a2", "filename": "compiler/rustc_middle/src/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -66,11 +66,10 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n \n     fn hash_hir_expr(&mut self, expr: &hir::Expr<'_>, hasher: &mut StableHasher) {\n         self.while_hashing_hir_bodies(true, |hcx| {\n-            let hir::Expr { hir_id: _, ref span, ref kind, ref attrs } = *expr;\n+            let hir::Expr { hir_id: _, ref span, ref kind } = *expr;\n \n             span.hash_stable(hcx, hasher);\n             kind.hash_stable(hcx, hasher);\n-            attrs.hash_stable(hcx, hasher);\n         })\n     }\n "}, {"sha": "b03b26d64606cf83125138847a029b1daf6fb8b1", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -61,6 +61,15 @@ rustc_queries! {\n         desc { |tcx| \"HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n+    /// Gives access to the HIR attributes inside the HIR owner `key`.\n+    ///\n+    /// This can be conveniently accessed by methods on `tcx.hir()`.\n+    /// Avoid calling this query directly.\n+    query hir_attrs(key: LocalDefId) -> rustc_middle::hir::AttributeMap<'tcx> {\n+        eval_always\n+        desc { |tcx| \"HIR owner attributes in `{}`\", tcx.def_path_str(key.to_def_id()) }\n+    }\n+\n     /// Computes the `DefId` of the corresponding const parameter in case the `key` is a\n     /// const argument and returns `None` otherwise.\n     ///"}, {"sha": "ef8bd20d51098c3e94821c1ded39573525b9d0da", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -15,7 +15,7 @@ crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n-        if let FnKind::Closure(_) = fn_like_node.kind() {\n+        if let FnKind::Closure = fn_like_node.kind() {\n             // closures can't recur, so they don't matter.\n             return;\n         }"}, {"sha": "c7b266f18bf8dd57138ea9e6e0caa2e21db9c7fe", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 13, "deletions": 50, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -62,12 +62,12 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_attributes(\n         &self,\n         hir_id: HirId,\n-        attrs: &'hir [Attribute],\n         span: &Span,\n         target: Target,\n         item: Option<ItemLike<'_>>,\n     ) {\n         let mut is_valid = true;\n+        let attrs = self.tcx.hir().attrs(hir_id);\n         for attr in attrs {\n             is_valid &= if self.tcx.sess.check_name(attr, sym::inline) {\n                 self.check_inline(hir_id, attr, span, target)\n@@ -1213,61 +1213,36 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n         let target = Target::from_item(item);\n-        self.check_attributes(\n-            item.hir_id(),\n-            item.attrs,\n-            &item.span,\n-            target,\n-            Some(ItemLike::Item(item)),\n-        );\n+        self.check_attributes(item.hir_id(), &item.span, target, Some(ItemLike::Item(item)));\n         intravisit::walk_item(self, item)\n     }\n \n     fn visit_generic_param(&mut self, generic_param: &'tcx hir::GenericParam<'tcx>) {\n         let target = Target::from_generic_param(generic_param);\n-        self.check_attributes(\n-            generic_param.hir_id,\n-            generic_param.attrs,\n-            &generic_param.span,\n-            target,\n-            None,\n-        );\n+        self.check_attributes(generic_param.hir_id, &generic_param.span, target, None);\n         intravisit::walk_generic_param(self, generic_param)\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx TraitItem<'tcx>) {\n         let target = Target::from_trait_item(trait_item);\n-        self.check_attributes(\n-            trait_item.hir_id(),\n-            &trait_item.attrs,\n-            &trait_item.span,\n-            target,\n-            None,\n-        );\n+        self.check_attributes(trait_item.hir_id(), &trait_item.span, target, None);\n         intravisit::walk_trait_item(self, trait_item)\n     }\n \n     fn visit_struct_field(&mut self, struct_field: &'tcx hir::StructField<'tcx>) {\n-        self.check_attributes(\n-            struct_field.hir_id,\n-            &struct_field.attrs,\n-            &struct_field.span,\n-            Target::Field,\n-            None,\n-        );\n+        self.check_attributes(struct_field.hir_id, &struct_field.span, Target::Field, None);\n         intravisit::walk_struct_field(self, struct_field);\n     }\n \n     fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n-        self.check_attributes(arm.hir_id, &arm.attrs, &arm.span, Target::Arm, None);\n+        self.check_attributes(arm.hir_id, &arm.span, Target::Arm, None);\n         intravisit::walk_arm(self, arm);\n     }\n \n     fn visit_foreign_item(&mut self, f_item: &'tcx ForeignItem<'tcx>) {\n         let target = Target::from_foreign_item(f_item);\n         self.check_attributes(\n             f_item.hir_id(),\n-            &f_item.attrs,\n             &f_item.span,\n             target,\n             Some(ItemLike::ForeignItem(f_item)),\n@@ -1277,14 +1252,14 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         let target = target_from_impl_item(self.tcx, impl_item);\n-        self.check_attributes(impl_item.hir_id(), &impl_item.attrs, &impl_item.span, target, None);\n+        self.check_attributes(impl_item.hir_id(), &impl_item.span, target, None);\n         intravisit::walk_impl_item(self, impl_item)\n     }\n \n     fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt<'tcx>) {\n         // When checking statements ignore expressions, they will be checked later.\n         if let hir::StmtKind::Local(ref l) = stmt.kind {\n-            self.check_attributes(l.hir_id, &l.attrs, &stmt.span, Target::Statement, None);\n+            self.check_attributes(l.hir_id, &stmt.span, Target::Statement, None);\n         }\n         intravisit::walk_stmt(self, stmt)\n     }\n@@ -1295,7 +1270,7 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n             _ => Target::Expression,\n         };\n \n-        self.check_attributes(expr.hir_id, &expr.attrs, &expr.span, target, None);\n+        self.check_attributes(expr.hir_id, &expr.span, target, None);\n         intravisit::walk_expr(self, expr)\n     }\n \n@@ -1305,23 +1280,17 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         generics: &'tcx hir::Generics<'tcx>,\n         item_id: HirId,\n     ) {\n-        self.check_attributes(variant.id, variant.attrs, &variant.span, Target::Variant, None);\n+        self.check_attributes(variant.id, &variant.span, Target::Variant, None);\n         intravisit::walk_variant(self, variant, generics, item_id)\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef<'tcx>) {\n-        self.check_attributes(\n-            macro_def.hir_id(),\n-            macro_def.attrs,\n-            &macro_def.span,\n-            Target::MacroDef,\n-            None,\n-        );\n+        self.check_attributes(macro_def.hir_id(), &macro_def.span, Target::MacroDef, None);\n         intravisit::walk_macro_def(self, macro_def);\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        self.check_attributes(param.hir_id, param.attrs, &param.span, Target::Param, None);\n+        self.check_attributes(param.hir_id, &param.span, Target::Param, None);\n \n         intravisit::walk_param(self, param);\n     }\n@@ -1389,13 +1358,7 @@ fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_exported_macros_in_krate(check_attr_visitor);\n     check_invalid_macro_level_attr(tcx, tcx.hir().krate().non_exported_macro_attrs);\n     if module_def_id.is_top_level_module() {\n-        check_attr_visitor.check_attributes(\n-            CRATE_HIR_ID,\n-            tcx.hir().krate_attrs(),\n-            &DUMMY_SP,\n-            Target::Mod,\n-            None,\n-        );\n+        check_attr_visitor.check_attributes(CRATE_HIR_ID, &DUMMY_SP, Target::Mod, None);\n         check_invalid_crate_level_attr(tcx, tcx.hir().krate_attrs());\n     }\n }"}, {"sha": "ca25445486d40692737a9693a65c82da043292bf", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -15,7 +15,6 @@ use rustc_middle::middle::privacy;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::lint;\n \n-use rustc_ast as ast;\n use rustc_span::symbol::{sym, Symbol};\n \n // Any local node that may call something in its body block should be\n@@ -346,11 +345,8 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n     }\n }\n \n-fn has_allow_dead_code_or_lang_attr(\n-    tcx: TyCtxt<'_>,\n-    id: hir::HirId,\n-    attrs: &[ast::Attribute],\n-) -> bool {\n+fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n+    let attrs = tcx.hir().attrs(id);\n     if tcx.sess.contains_name(attrs, sym::lang) {\n         return true;\n     }\n@@ -400,8 +396,7 @@ struct LifeSeeder<'k, 'tcx> {\n \n impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let allow_dead_code =\n-            has_allow_dead_code_or_lang_attr(self.tcx, item.hir_id(), &item.attrs);\n+        let allow_dead_code = has_allow_dead_code_or_lang_attr(self.tcx, item.hir_id());\n         if allow_dead_code {\n             self.worklist.push(item.hir_id());\n         }\n@@ -424,11 +419,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                 for impl_item_ref in items {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if of_trait.is_some()\n-                        || has_allow_dead_code_or_lang_attr(\n-                            self.tcx,\n-                            impl_item.hir_id(),\n-                            &impl_item.attrs,\n-                        )\n+                        || has_allow_dead_code_or_lang_attr(self.tcx, impl_item.hir_id())\n                     {\n                         self.worklist.push(impl_item_ref.id.hir_id());\n                     }\n@@ -446,7 +437,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n         use hir::TraitItemKind::{Const, Fn};\n         if matches!(trait_item.kind, Const(_, Some(_)) | Fn(_, hir::TraitFn::Provided(_)))\n-            && has_allow_dead_code_or_lang_attr(self.tcx, trait_item.hir_id(), &trait_item.attrs)\n+            && has_allow_dead_code_or_lang_attr(self.tcx, trait_item.hir_id())\n         {\n             self.worklist.push(trait_item.hir_id());\n         }\n@@ -459,11 +450,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem<'_>) {\n         use hir::ForeignItemKind::{Fn, Static};\n         if matches!(foreign_item.kind, Static(..) | Fn(..))\n-            && has_allow_dead_code_or_lang_attr(\n-                self.tcx,\n-                foreign_item.hir_id(),\n-                &foreign_item.attrs,\n-            )\n+            && has_allow_dead_code_or_lang_attr(self.tcx, foreign_item.hir_id())\n         {\n             self.worklist.push(foreign_item.hir_id());\n         }\n@@ -543,17 +530,16 @@ impl DeadVisitor<'tcx> {\n         !field.is_positional()\n             && !self.symbol_is_live(field.hir_id)\n             && !field_type.is_phantom_data()\n-            && !has_allow_dead_code_or_lang_attr(self.tcx, field.hir_id, &field.attrs)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, field.hir_id)\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::Variant<'_>) -> bool {\n-        !self.symbol_is_live(variant.id)\n-            && !has_allow_dead_code_or_lang_attr(self.tcx, variant.id, &variant.attrs)\n+        !self.symbol_is_live(variant.id) && !has_allow_dead_code_or_lang_attr(self.tcx, variant.id)\n     }\n \n     fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem<'_>) -> bool {\n         !self.symbol_is_live(fi.hir_id())\n-            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.hir_id(), &fi.attrs)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.hir_id())\n     }\n \n     // id := HIR id of an item's definition."}, {"sha": "8dd3700e5b6afb44954e4ab81cebb3fed2e05cbb", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -27,19 +27,19 @@ struct DiagnosticItemCollector<'tcx> {\n \n impl<'v, 'tcx> ItemLikeVisitor<'v> for DiagnosticItemCollector<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        self.observe_item(&item.attrs, item.def_id);\n+        self.observe_item(item.def_id);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n-        self.observe_item(&trait_item.attrs, trait_item.def_id);\n+        self.observe_item(trait_item.def_id);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n-        self.observe_item(&impl_item.attrs, impl_item.def_id);\n+        self.observe_item(impl_item.def_id);\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem<'_>) {\n-        self.observe_item(foreign_item.attrs, foreign_item.def_id);\n+        self.observe_item(foreign_item.def_id);\n     }\n }\n \n@@ -48,7 +48,9 @@ impl<'tcx> DiagnosticItemCollector<'tcx> {\n         DiagnosticItemCollector { tcx, items: Default::default() }\n     }\n \n-    fn observe_item(&mut self, attrs: &[ast::Attribute], def_id: LocalDefId) {\n+    fn observe_item(&mut self, def_id: LocalDefId) {\n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+        let attrs = self.tcx.hir().attrs(hir_id);\n         if let Some(name) = extract(&self.tcx.sess, attrs) {\n             // insert into our table\n             collect_item(self.tcx, &mut self.items, name, def_id.to_def_id());\n@@ -105,7 +107,7 @@ fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> FxHashMap<Symbol, DefId> {\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n     for m in tcx.hir().krate().exported_macros {\n-        collector.observe_item(m.attrs, m.def_id);\n+        collector.observe_item(m.def_id);\n     }\n \n     collector.items"}, {"sha": "57848208f945e923cbaaaecb4e29783d069a5309", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -2,7 +2,7 @@ use rustc_ast::entry::EntryPointType;\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::{CrateNum, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::{ForeignItem, HirId, ImplItem, Item, ItemKind, TraitItem};\n+use rustc_hir::{ForeignItem, HirId, ImplItem, Item, ItemKind, TraitItem, CRATE_HIR_ID};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n@@ -60,7 +60,7 @@ fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(LocalDefId, EntryFnType)\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::no_main) {\n+    if tcx.sess.contains_name(&tcx.hir().attrs(CRATE_HIR_ID), sym::no_main) {\n         return None;\n     }\n \n@@ -80,10 +80,11 @@ fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(LocalDefId, EntryFnType)\n \n // Beware, this is duplicated in `librustc_builtin_macros/test_harness.rs`\n // (with `ast::Item`), so make sure to keep them in sync.\n-fn entry_point_type(sess: &Session, item: &Item<'_>, at_root: bool) -> EntryPointType {\n-    if sess.contains_name(&item.attrs, sym::start) {\n+fn entry_point_type(ctxt: &EntryContext<'_, '_>, item: &Item<'_>, at_root: bool) -> EntryPointType {\n+    let attrs = ctxt.map.attrs(item.hir_id());\n+    if ctxt.session.contains_name(attrs, sym::start) {\n         EntryPointType::Start\n-    } else if sess.contains_name(&item.attrs, sym::main) {\n+    } else if ctxt.session.contains_name(attrs, sym::main) {\n         EntryPointType::MainAttr\n     } else if item.ident.name == sym::main {\n         if at_root {\n@@ -103,13 +104,14 @@ fn throw_attr_err(sess: &Session, span: Span, attr: &str) {\n }\n \n fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n-    match entry_point_type(&ctxt.session, item, at_root) {\n+    match entry_point_type(ctxt, item, at_root) {\n         EntryPointType::None => (),\n         _ if !matches!(item.kind, ItemKind::Fn(..)) => {\n-            if let Some(attr) = ctxt.session.find_by_name(item.attrs, sym::start) {\n+            let attrs = ctxt.map.attrs(item.hir_id());\n+            if let Some(attr) = ctxt.session.find_by_name(attrs, sym::start) {\n                 throw_attr_err(&ctxt.session, attr.span, \"start\");\n             }\n-            if let Some(attr) = ctxt.session.find_by_name(item.attrs, sym::main) {\n+            if let Some(attr) = ctxt.session.find_by_name(attrs, sym::main) {\n                 throw_attr_err(&ctxt.session, attr.span, \"main\");\n             }\n         }"}, {"sha": "ccbfc6b16616082434e9f0f3d9f097e839e05b03", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -241,7 +241,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_assoc_type_binding(self, type_binding)\n     }\n \n-    fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n+    fn visit_attribute(&mut self, _: hir::HirId, attr: &'v ast::Attribute) {\n         self.record(\"Attribute\", Id::Attr(attr.id), attr);\n     }\n "}, {"sha": "7e6bb9779f07700411531cfa9263c8a56963a2ab", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -13,7 +13,6 @@ use crate::weak_lang_items;\n use rustc_middle::middle::cstore::ExternCrate;\n use rustc_middle::ty::TyCtxt;\n \n-use rustc_ast::Attribute;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n@@ -30,29 +29,21 @@ struct LanguageItemCollector<'tcx> {\n \n impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        self.check_for_lang(Target::from_item(item), item.hir_id(), item.attrs);\n+        self.check_for_lang(Target::from_item(item), item.hir_id());\n \n         if let hir::ItemKind::Enum(def, ..) = &item.kind {\n             for variant in def.variants {\n-                self.check_for_lang(Target::Variant, variant.id, variant.attrs);\n+                self.check_for_lang(Target::Variant, variant.id);\n             }\n         }\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n-        self.check_for_lang(\n-            Target::from_trait_item(trait_item),\n-            trait_item.hir_id(),\n-            trait_item.attrs,\n-        )\n+        self.check_for_lang(Target::from_trait_item(trait_item), trait_item.hir_id())\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n-        self.check_for_lang(\n-            target_from_impl_item(self.tcx, impl_item),\n-            impl_item.hir_id(),\n-            impl_item.attrs,\n-        )\n+        self.check_for_lang(target_from_impl_item(self.tcx, impl_item), impl_item.hir_id())\n     }\n \n     fn visit_foreign_item(&mut self, _: &hir::ForeignItem<'_>) {}\n@@ -63,7 +54,8 @@ impl LanguageItemCollector<'tcx> {\n         LanguageItemCollector { tcx, items: LanguageItems::new() }\n     }\n \n-    fn check_for_lang(&mut self, actual_target: Target, hir_id: HirId, attrs: &[Attribute]) {\n+    fn check_for_lang(&mut self, actual_target: Target, hir_id: HirId) {\n+        let attrs = self.tcx.hir().attrs(hir_id);\n         let check_name = |attr, sym| self.tcx.sess.check_name(attr, sym);\n         if let Some((value, span)) = extract(check_name, &attrs) {\n             match ITEM_REFS.get(&value).cloned() {"}, {"sha": "3dfe317a4bd175fd1ee7c05e561e59161e07b9e5", "filename": "compiler/rustc_passes/src/lib_features.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -120,7 +120,7 @@ impl Visitor<'tcx> for LibFeatureCollector<'tcx> {\n         NestedVisitorMap::All(self.tcx.hir())\n     }\n \n-    fn visit_attribute(&mut self, attr: &'tcx Attribute) {\n+    fn visit_attribute(&mut self, _: rustc_hir::HirId, attr: &'tcx Attribute) {\n         if let Some((feature, stable, span)) = self.extract(attr) {\n             self.collect_feature(feature, stable, span);\n         }\n@@ -131,7 +131,7 @@ fn collect(tcx: TyCtxt<'_>) -> LibFeatures {\n     let mut collector = LibFeatureCollector::new(tcx);\n     let krate = tcx.hir().krate();\n     for attr in krate.non_exported_macro_attrs {\n-        collector.visit_attribute(attr);\n+        collector.visit_attribute(rustc_hir::CRATE_HIR_ID, attr);\n     }\n     intravisit::walk_crate(&mut collector, krate);\n     collector.lib_features"}, {"sha": "89bc2e1a9870ff168e56e2b05038f54fde81e3e6", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> Visitor<'tcx> for CheckNakedFunctions<'tcx> {\n         let fn_header;\n \n         match fk {\n-            FnKind::Closure(..) => {\n+            FnKind::Closure => {\n                 // Closures with a naked attribute are rejected during attribute\n                 // check. Don't validate them any further.\n                 return;\n@@ -62,7 +62,8 @@ impl<'tcx> Visitor<'tcx> for CheckNakedFunctions<'tcx> {\n             }\n         }\n \n-        let naked = fk.attrs().iter().any(|attr| attr.has_name(sym::naked));\n+        let attrs = self.tcx.hir().attrs(hir_id);\n+        let naked = attrs.iter().any(|attr| attr.has_name(sym::naked));\n         if naked {\n             let body = self.tcx.hir().body(body_id);\n             check_abi(self.tcx, hir_id, fn_header.abi, ident_span);"}, {"sha": "3e957aabd776329ddd0d336f8202616c29b09497", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -97,7 +97,6 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     fn annotate<F>(\n         &mut self,\n         hir_id: HirId,\n-        attrs: &[Attribute],\n         item_sp: Span,\n         kind: AnnotationKind,\n         inherit_deprecation: InheritDeprecation,\n@@ -107,6 +106,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     ) where\n         F: FnOnce(&mut Self),\n     {\n+        let attrs = self.tcx.hir().attrs(hir_id);\n         debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n         let mut did_error = false;\n         if !self.tcx.features().staged_api {\n@@ -385,7 +385,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n                 if let Some(ctor_hir_id) = sd.ctor_hir_id() {\n                     self.annotate(\n                         ctor_hir_id,\n-                        &i.attrs,\n                         i.span,\n                         AnnotationKind::Required,\n                         InheritDeprecation::Yes,\n@@ -400,7 +399,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n         self.annotate(\n             i.hir_id(),\n-            &i.attrs,\n             i.span,\n             kind,\n             InheritDeprecation::Yes,\n@@ -414,7 +412,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n         self.annotate(\n             ti.hir_id(),\n-            &ti.attrs,\n             ti.span,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n@@ -431,7 +428,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             if self.in_trait_impl { AnnotationKind::Prohibited } else { AnnotationKind::Required };\n         self.annotate(\n             ii.hir_id(),\n-            &ii.attrs,\n             ii.span,\n             kind,\n             InheritDeprecation::Yes,\n@@ -446,7 +442,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n         self.annotate(\n             var.id,\n-            &var.attrs,\n             var.span,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n@@ -456,7 +451,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n                 if let Some(ctor_hir_id) = var.data.ctor_hir_id() {\n                     v.annotate(\n                         ctor_hir_id,\n-                        &var.attrs,\n                         var.span,\n                         AnnotationKind::Required,\n                         InheritDeprecation::Yes,\n@@ -474,7 +468,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     fn visit_struct_field(&mut self, s: &'tcx StructField<'tcx>) {\n         self.annotate(\n             s.hir_id,\n-            &s.attrs,\n             s.span,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n@@ -489,7 +482,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n         self.annotate(\n             i.hir_id(),\n-            &i.attrs,\n             i.span,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n@@ -504,7 +496,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n         self.annotate(\n             md.hir_id(),\n-            &md.attrs,\n             md.span,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n@@ -525,7 +516,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n         self.annotate(\n             p.hir_id,\n-            &p.attrs,\n             p.span,\n             kind,\n             InheritDeprecation::No,\n@@ -696,7 +686,6 @@ fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n \n         annotator.annotate(\n             hir::CRATE_HIR_ID,\n-            &krate.item.attrs,\n             krate.item.span,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n@@ -762,8 +751,9 @@ impl Visitor<'tcx> for Checker<'tcx> {\n                     // error if all involved types and traits are stable, because\n                     // it will have no effect.\n                     // See: https://github.com/rust-lang/rust/issues/55436\n+                    let attrs = self.tcx.hir().attrs(item.hir_id());\n                     if let (Some((Stability { level: attr::Unstable { .. }, .. }, span)), _) =\n-                        attr::find_stability(&self.tcx.sess, &item.attrs, item.span)\n+                        attr::find_stability(&self.tcx.sess, attrs, item.span)\n                     {\n                         let mut c = CheckTraitImplStable { tcx: self.tcx, fully_stable: true };\n                         c.visit_ty(self_ty);"}, {"sha": "de369ba9bbbe2fa016609f25531c14307fd9ded3", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -97,7 +97,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n         let check_name = |attr, sym| self.tcx.sess.check_name(attr, sym);\n-        if let Some((lang_item, _)) = lang_items::extract(check_name, &i.attrs) {\n+        let attrs = self.tcx.hir().attrs(i.hir_id());\n+        if let Some((lang_item, _)) = lang_items::extract(check_name, attrs) {\n             self.register(lang_item, i.span);\n         }\n         intravisit::walk_foreign_item(self, i)"}, {"sha": "a49afa35e4624bd2ad4379087e75531da93f240a", "filename": "compiler/rustc_plugin_impl/src/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_plugin_impl%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_plugin_impl%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fsrc%2Fbuild.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -16,7 +16,8 @@ struct RegistrarFinder<'tcx> {\n impl<'v, 'tcx> ItemLikeVisitor<'v> for RegistrarFinder<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Fn(..) = item.kind {\n-            if self.tcx.sess.contains_name(&item.attrs, sym::plugin_registrar) {\n+            let attrs = self.tcx.hir().attrs(item.hir_id());\n+            if self.tcx.sess.contains_name(attrs, sym::plugin_registrar) {\n                 self.registrars.push((item.def_id, item.span));\n             }\n         }"}, {"sha": "72be266b338baeeef74cde3c230bd967745fd59d", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -881,7 +881,8 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n         // Non-opaque macros cannot make other items more accessible than they already are.\n-        if attr::find_transparency(&self.tcx.sess, &md.attrs, md.ast.macro_rules).0\n+        let attrs = self.tcx.hir().attrs(md.hir_id());\n+        if attr::find_transparency(&self.tcx.sess, &attrs, md.ast.macro_rules).0\n             != Transparency::Opaque\n         {\n             // `#[macro_export]`-ed `macro_rules!` are `Public` since they"}, {"sha": "4f92532e3a698e5424ecef765d6e3657113eb257", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -1239,7 +1239,8 @@ fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifet\n                 let result = object_lifetime_defaults_for_item(tcx, generics);\n \n                 // Debugging aid.\n-                if tcx.sess.contains_name(&item.attrs, sym::rustc_object_lifetime_default) {\n+                let attrs = tcx.hir().attrs(item.hir_id());\n+                if tcx.sess.contains_name(attrs, sym::rustc_object_lifetime_default) {\n                     let object_lifetime_default_reprs: String = result\n                         .iter()\n                         .map(|set| match *set {"}, {"sha": "f943753183a547e1a489c7b8dd2e5a96d72a04ee", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -496,6 +496,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n \n         if !self.span.filter_generated(item.ident.span) {\n             let span = self.span_from_span(item.ident.span);\n+            let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, item, item.hir_id()),\n                 Def {\n@@ -508,9 +509,9 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     parent: None,\n                     children: fields,\n                     decl_id: None,\n-                    docs: self.save_ctxt.docs_for_attrs(&item.attrs),\n+                    docs: self.save_ctxt.docs_for_attrs(attrs),\n                     sig: sig::item_signature(item, &self.save_ctxt),\n-                    attributes: lower_attributes(item.attrs.to_vec(), &self.save_ctxt),\n+                    attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n                 },\n             );\n         }\n@@ -554,6 +555,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                         let span = self.span_from_span(name_span);\n                         let id = id_from_hir_id(variant.id, &self.save_ctxt);\n                         let parent = Some(id_from_def_id(item.def_id.to_def_id()));\n+                        let attrs = self.tcx.hir().attrs(variant.id);\n \n                         self.dumper.dump_def(\n                             &access,\n@@ -567,12 +569,9 @@ impl<'tcx> DumpVisitor<'tcx> {\n                                 parent,\n                                 children: vec![],\n                                 decl_id: None,\n-                                docs: self.save_ctxt.docs_for_attrs(&variant.attrs),\n+                                docs: self.save_ctxt.docs_for_attrs(attrs),\n                                 sig: sig::variant_signature(variant, &self.save_ctxt),\n-                                attributes: lower_attributes(\n-                                    variant.attrs.to_vec(),\n-                                    &self.save_ctxt,\n-                                ),\n+                                attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n                             },\n                         );\n                     }\n@@ -594,6 +593,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                         let span = self.span_from_span(name_span);\n                         let id = id_from_hir_id(variant.id, &self.save_ctxt);\n                         let parent = Some(id_from_def_id(item.def_id.to_def_id()));\n+                        let attrs = self.tcx.hir().attrs(variant.id);\n \n                         self.dumper.dump_def(\n                             &access,\n@@ -607,12 +607,9 @@ impl<'tcx> DumpVisitor<'tcx> {\n                                 parent,\n                                 children: vec![],\n                                 decl_id: None,\n-                                docs: self.save_ctxt.docs_for_attrs(&variant.attrs),\n+                                docs: self.save_ctxt.docs_for_attrs(attrs),\n                                 sig: sig::variant_signature(variant, &self.save_ctxt),\n-                                attributes: lower_attributes(\n-                                    variant.attrs.to_vec(),\n-                                    &self.save_ctxt,\n-                                ),\n+                                attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n                             },\n                         );\n                     }\n@@ -675,6 +672,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             let span = self.span_from_span(item.ident.span);\n             let children =\n                 methods.iter().map(|i| id_from_def_id(i.id.def_id.to_def_id())).collect();\n+            let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, item, item.hir_id()),\n                 Def {\n@@ -687,9 +685,9 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     parent: None,\n                     children,\n                     decl_id: None,\n-                    docs: self.save_ctxt.docs_for_attrs(&item.attrs),\n+                    docs: self.save_ctxt.docs_for_attrs(attrs),\n                     sig: sig::item_signature(item, &self.save_ctxt),\n-                    attributes: lower_attributes(item.attrs.to_vec(), &self.save_ctxt),\n+                    attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n                 },\n             );\n         }\n@@ -998,14 +996,15 @@ impl<'tcx> DumpVisitor<'tcx> {\n             hir::TraitItemKind::Const(ref ty, body) => {\n                 let body = body.map(|b| &self.tcx.hir().body(b).value);\n                 let respan = respan(vis_span, hir::VisibilityKind::Public);\n+                let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n                 self.process_assoc_const(\n                     trait_item.hir_id(),\n                     trait_item.ident,\n                     &ty,\n                     body,\n                     trait_id,\n                     &respan,\n-                    &trait_item.attrs,\n+                    attrs,\n                 );\n             }\n             hir::TraitItemKind::Fn(ref sig, ref trait_fn) => {\n@@ -1031,6 +1030,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 if !self.span.filter_generated(trait_item.ident.span) {\n                     let span = self.span_from_span(trait_item.ident.span);\n                     let id = id_from_def_id(trait_item.def_id.to_def_id());\n+                    let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n \n                     self.dumper.dump_def(\n                         &Access { public: true, reachable: true },\n@@ -1044,18 +1044,15 @@ impl<'tcx> DumpVisitor<'tcx> {\n                             parent: Some(id_from_def_id(trait_id)),\n                             children: vec![],\n                             decl_id: None,\n-                            docs: self.save_ctxt.docs_for_attrs(&trait_item.attrs),\n+                            docs: self.save_ctxt.docs_for_attrs(attrs),\n                             sig: sig::assoc_type_signature(\n                                 trait_item.hir_id(),\n                                 trait_item.ident,\n                                 Some(bounds),\n                                 default_ty.as_ref().map(|ty| &**ty),\n                                 &self.save_ctxt,\n                             ),\n-                            attributes: lower_attributes(\n-                                trait_item.attrs.to_vec(),\n-                                &self.save_ctxt,\n-                            ),\n+                            attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n                         },\n                     );\n                 }\n@@ -1072,14 +1069,15 @@ impl<'tcx> DumpVisitor<'tcx> {\n         match impl_item.kind {\n             hir::ImplItemKind::Const(ref ty, body) => {\n                 let body = self.tcx.hir().body(body);\n+                let attrs = self.tcx.hir().attrs(impl_item.hir_id());\n                 self.process_assoc_const(\n                     impl_item.hir_id(),\n                     impl_item.ident,\n                     &ty,\n                     Some(&body.value),\n                     impl_id,\n                     &impl_item.vis,\n-                    &impl_item.attrs,\n+                    attrs,\n                 );\n             }\n             hir::ImplItemKind::Fn(ref sig, body) => {\n@@ -1118,6 +1116,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             .map(|i| id_from_def_id(i.def_id.to_def_id()))\n             .collect();\n         let span = self.span_from_span(krate.item.span);\n+        let attrs = self.tcx.hir().attrs(id);\n \n         self.dumper.dump_def(\n             &Access { public: true, reachable: true },\n@@ -1131,9 +1130,9 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 children,\n                 parent: None,\n                 decl_id: None,\n-                docs: self.save_ctxt.docs_for_attrs(krate.item.attrs),\n+                docs: self.save_ctxt.docs_for_attrs(attrs),\n                 sig: None,\n-                attributes: lower_attributes(krate.item.attrs.to_owned(), &self.save_ctxt),\n+                attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n             },\n         );\n         intravisit::walk_crate(self, krate);\n@@ -1263,6 +1262,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n                     let id = id_from_def_id(item.def_id.to_def_id());\n+                    let attrs = self.tcx.hir().attrs(item.hir_id());\n \n                     self.dumper.dump_def(\n                         &access_from!(self.save_ctxt, item, item.hir_id()),\n@@ -1276,9 +1276,9 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                             parent: None,\n                             children: vec![],\n                             decl_id: None,\n-                            docs: self.save_ctxt.docs_for_attrs(&item.attrs),\n+                            docs: self.save_ctxt.docs_for_attrs(attrs),\n                             sig: sig::item_signature(item, &self.save_ctxt),\n-                            attributes: lower_attributes(item.attrs.to_vec(), &self.save_ctxt),\n+                            attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n                         },\n                     );\n                 }"}, {"sha": "042f3183796d3584a34bc6143f00f253f8be343f", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -139,6 +139,7 @@ impl<'tcx> SaveContext<'tcx> {\n     pub fn get_extern_item_data(&self, item: &hir::ForeignItem<'_>) -> Option<Data> {\n         let def_id = item.def_id.to_def_id();\n         let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n+        let attrs = self.tcx.hir().attrs(item.hir_id());\n         match item.kind {\n             hir::ForeignItemKind::Fn(ref decl, arg_names, ref generics) => {\n                 filter!(self.span_utils, item.ident.span);\n@@ -169,9 +170,9 @@ impl<'tcx> SaveContext<'tcx> {\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n-                    docs: self.docs_for_attrs(&item.attrs),\n+                    docs: self.docs_for_attrs(attrs),\n                     sig: sig::foreign_item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.to_vec(), self),\n+                    attributes: lower_attributes(attrs.to_vec(), self),\n                 }))\n             }\n             hir::ForeignItemKind::Static(ref ty, _) => {\n@@ -190,9 +191,9 @@ impl<'tcx> SaveContext<'tcx> {\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n-                    docs: self.docs_for_attrs(&item.attrs),\n+                    docs: self.docs_for_attrs(attrs),\n                     sig: sig::foreign_item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.to_vec(), self),\n+                    attributes: lower_attributes(attrs.to_vec(), self),\n                 }))\n             }\n             // FIXME(plietar): needs a new DefKind in rls-data\n@@ -202,6 +203,7 @@ impl<'tcx> SaveContext<'tcx> {\n \n     pub fn get_item_data(&self, item: &hir::Item<'_>) -> Option<Data> {\n         let def_id = item.def_id.to_def_id();\n+        let attrs = self.tcx.hir().attrs(item.hir_id());\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, ref generics, _) => {\n                 let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n@@ -224,9 +226,9 @@ impl<'tcx> SaveContext<'tcx> {\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n-                    docs: self.docs_for_attrs(&item.attrs),\n+                    docs: self.docs_for_attrs(attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.to_vec(), self),\n+                    attributes: lower_attributes(attrs.to_vec(), self),\n                 }))\n             }\n             hir::ItemKind::Static(ref typ, ..) => {\n@@ -247,9 +249,9 @@ impl<'tcx> SaveContext<'tcx> {\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n-                    docs: self.docs_for_attrs(&item.attrs),\n+                    docs: self.docs_for_attrs(attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.to_vec(), self),\n+                    attributes: lower_attributes(attrs.to_vec(), self),\n                 }))\n             }\n             hir::ItemKind::Const(ref typ, _) => {\n@@ -269,9 +271,9 @@ impl<'tcx> SaveContext<'tcx> {\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n-                    docs: self.docs_for_attrs(&item.attrs),\n+                    docs: self.docs_for_attrs(attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.to_vec(), self),\n+                    attributes: lower_attributes(attrs.to_vec(), self),\n                 }))\n             }\n             hir::ItemKind::Mod(ref m) => {\n@@ -296,9 +298,9 @@ impl<'tcx> SaveContext<'tcx> {\n                         .map(|i| id_from_def_id(i.def_id.to_def_id()))\n                         .collect(),\n                     decl_id: None,\n-                    docs: self.docs_for_attrs(&item.attrs),\n+                    docs: self.docs_for_attrs(attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.to_vec(), self),\n+                    attributes: lower_attributes(attrs.to_vec(), self),\n                 }))\n             }\n             hir::ItemKind::Enum(ref def, ref generics) => {\n@@ -317,9 +319,9 @@ impl<'tcx> SaveContext<'tcx> {\n                     parent: None,\n                     children: def.variants.iter().map(|v| id_from_hir_id(v.id, self)).collect(),\n                     decl_id: None,\n-                    docs: self.docs_for_attrs(&item.attrs),\n+                    docs: self.docs_for_attrs(attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.to_vec(), self),\n+                    attributes: lower_attributes(attrs.to_vec(), self),\n                 }))\n             }\n             hir::ItemKind::Impl(hir::Impl { ref of_trait, ref self_ty, ref items, .. }) => {\n@@ -387,6 +389,7 @@ impl<'tcx> SaveContext<'tcx> {\n \n         let id = id_from_def_id(field_def_id);\n         let span = self.span_from_span(field.ident.span);\n+        let attrs = self.tcx.hir().attrs(field.hir_id);\n \n         Some(Def {\n             kind: DefKind::Field,\n@@ -398,9 +401,9 @@ impl<'tcx> SaveContext<'tcx> {\n             parent: Some(id_from_def_id(scope_def_id)),\n             children: vec![],\n             decl_id: None,\n-            docs: self.docs_for_attrs(&field.attrs),\n+            docs: self.docs_for_attrs(attrs),\n             sig: sig::field_signature(field, self),\n-            attributes: lower_attributes(field.attrs.to_vec(), self),\n+            attributes: lower_attributes(attrs.to_vec(), self),\n         })\n     }\n \n@@ -424,9 +427,9 @@ impl<'tcx> SaveContext<'tcx> {\n                             let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                             let mut docs = String::new();\n                             let mut attrs = vec![];\n-                            if let Some(Node::ImplItem(item)) = hir.find(hir_id) {\n-                                docs = self.docs_for_attrs(&item.attrs);\n-                                attrs = item.attrs.to_vec();\n+                            if let Some(Node::ImplItem(_)) = hir.find(hir_id) {\n+                                attrs = self.tcx.hir().attrs(hir_id).to_vec();\n+                                docs = self.docs_for_attrs(&attrs);\n                             }\n \n                             let mut decl_id = None;\n@@ -470,9 +473,9 @@ impl<'tcx> SaveContext<'tcx> {\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n \n-                        if let Some(Node::TraitItem(item)) = self.tcx.hir().find(hir_id) {\n-                            docs = self.docs_for_attrs(&item.attrs);\n-                            attrs = item.attrs.to_vec();\n+                        if let Some(Node::TraitItem(_)) = self.tcx.hir().find(hir_id) {\n+                            attrs = self.tcx.hir().attrs(hir_id).to_vec();\n+                            docs = self.docs_for_attrs(&attrs);\n                         }\n \n                         ("}, {"sha": "13757ac41325b245a8e83f10e6235d3a83d67edc", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -1466,11 +1466,12 @@ impl intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n                     if self.span.map_or(true, |span| item.span < span) {\n                         if !item.span.from_expansion() {\n                             // Don't insert between attributes and an item.\n-                            if item.attrs.is_empty() {\n+                            let attrs = self.tcx.hir().attrs(item.hir_id());\n+                            if attrs.is_empty() {\n                                 self.span = Some(item.span.shrink_to_lo());\n                             } else {\n                                 // Find the first attribute on the item.\n-                                for attr in item.attrs {\n+                                for attr in attrs {\n                                     if self.span.map_or(true, |span| attr.span < span) {\n                                         self.span = Some(attr.span.shrink_to_lo());\n                                     }"}, {"sha": "55c6420ae5e2ef3198bb6324cbf91a723ad5045b", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -354,7 +354,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n         hir_id: hir::HirId,\n     ) {\n         assert!(\n-            matches!(fk, intravisit::FnKind::Closure(..)),\n+            matches!(fk, intravisit::FnKind::Closure),\n             \"visit_fn invoked for something other than a closure\"\n         );\n "}, {"sha": "0fc49c4ae2f4805b3fd7d1b99eff978d6d2fe8f3", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -201,7 +201,8 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: LocalDefId) {\n                         error = true;\n                     }\n \n-                    for attr in it.attrs {\n+                    let attrs = tcx.hir().attrs(main_id);\n+                    for attr in attrs {\n                         if tcx.sess.check_name(attr, sym::track_caller) {\n                             tcx.sess\n                                 .struct_span_err(\n@@ -300,7 +301,8 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n                         error = true;\n                     }\n \n-                    for attr in it.attrs {\n+                    let attrs = tcx.hir().attrs(start_id);\n+                    for attr in attrs {\n                         if tcx.sess.check_name(attr, sym::track_caller) {\n                             tcx.sess\n                                 .struct_span_err("}, {"sha": "539895feddd429463ef91cb7882d9be14b629046", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -863,7 +863,8 @@ fn clean_fn_or_proc_macro(\n     name: &mut Symbol,\n     cx: &mut DocContext<'_>,\n ) -> ItemKind {\n-    let macro_kind = item.attrs.iter().find_map(|a| {\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    let macro_kind = attrs.iter().find_map(|a| {\n         if a.has_name(sym::proc_macro) {\n             Some(MacroKind::Bang)\n         } else if a.has_name(sym::proc_macro_derive) {\n@@ -877,16 +878,15 @@ fn clean_fn_or_proc_macro(\n     match macro_kind {\n         Some(kind) => {\n             if kind == MacroKind::Derive {\n-                *name = item\n-                    .attrs\n+                *name = attrs\n                     .lists(sym::proc_macro_derive)\n                     .find_map(|mi| mi.ident())\n                     .expect(\"proc-macro derives require a name\")\n                     .name;\n             }\n \n             let mut helpers = Vec::new();\n-            for mi in item.attrs.lists(sym::proc_macro_derive) {\n+            for mi in attrs.lists(sym::proc_macro_derive) {\n                 if !mi.has_name(sym::attributes) {\n                     continue;\n                 }\n@@ -2102,8 +2102,9 @@ fn clean_extern_crate(\n     let cnum = cx.tcx.extern_mod_stmt_cnum(krate.def_id).unwrap_or(LOCAL_CRATE);\n     // this is the ID of the crate itself\n     let crate_def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+    let attrs = cx.tcx.hir().attrs(krate.hir_id());\n     let please_inline = krate.vis.node.is_pub()\n-        && krate.attrs.iter().any(|a| {\n+        && attrs.iter().any(|a| {\n             a.has_name(sym::doc)\n                 && match a.meta_item_list() {\n                     Some(l) => attr::list_contains_name(&l, sym::inline),\n@@ -2121,7 +2122,7 @@ fn clean_extern_crate(\n             cx.tcx.parent_module(krate.hir_id()).to_def_id(),\n             res,\n             name,\n-            Some(krate.attrs),\n+            Some(attrs),\n             &mut visited,\n         ) {\n             return items;\n@@ -2130,7 +2131,7 @@ fn clean_extern_crate(\n     // FIXME: using `from_def_id_and_kind` breaks `rustdoc/masked` for some reason\n     vec![Item {\n         name: Some(name),\n-        attrs: box krate.attrs.clean(cx),\n+        attrs: box attrs.clean(cx),\n         source: krate.span.clean(cx),\n         def_id: crate_def_id,\n         visibility: krate.vis.clean(cx),\n@@ -2152,7 +2153,8 @@ fn clean_use_statement(\n         return Vec::new();\n     }\n \n-    let inline_attr = import.attrs.lists(sym::doc).get_word_attr(sym::inline);\n+    let attrs = cx.tcx.hir().attrs(import.hir_id());\n+    let inline_attr = attrs.lists(sym::doc).get_word_attr(sym::inline);\n     let pub_underscore = import.vis.node.is_pub() && name == kw::Underscore;\n \n     if pub_underscore {\n@@ -2174,7 +2176,7 @@ fn clean_use_statement(\n     // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n     let mut denied = !import.vis.node.is_pub()\n         || pub_underscore\n-        || import.attrs.iter().any(|a| {\n+        || attrs.iter().any(|a| {\n             a.has_name(sym::doc)\n                 && match a.meta_item_list() {\n                     Some(l) => {\n@@ -2214,7 +2216,7 @@ fn clean_use_statement(\n                 cx.tcx.parent_module(import.hir_id()).to_def_id(),\n                 path.res,\n                 name,\n-                Some(import.attrs),\n+                Some(attrs),\n                 &mut visited,\n             ) {\n                 items.push(Item::from_def_id_and_parts("}, {"sha": "64375964e70685417736d11a8feb10270b4ff278", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 34, "deletions": 52, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -106,25 +106,27 @@ crate fn run(options: Options) -> Result<(), ErrorReported> {\n \n     let tests = interface::run_compiler(config, |compiler| {\n         compiler.enter(|queries| {\n-            let lower_to_hir = queries.lower_to_hir()?;\n-\n-            let mut opts = scrape_test_config(lower_to_hir.peek().0);\n-            opts.display_warnings |= options.display_warnings;\n-            let enable_per_target_ignores = options.enable_per_target_ignores;\n-            let mut collector = Collector::new(\n-                queries.crate_name()?.peek().to_string(),\n-                options,\n-                false,\n-                opts,\n-                Some(compiler.session().parse_sess.clone_source_map()),\n-                None,\n-                enable_per_target_ignores,\n-            );\n+            let _lower_to_hir = queries.lower_to_hir()?;\n \n+            let crate_name = queries.crate_name()?.peek().to_string();\n             let mut global_ctxt = queries.global_ctxt()?.take();\n \n-            global_ctxt.enter(|tcx| {\n+            let collector = global_ctxt.enter(|tcx| {\n                 let krate = tcx.hir().krate();\n+                let crate_attrs = tcx.hir().attrs(CRATE_HIR_ID);\n+\n+                let mut opts = scrape_test_config(crate_attrs);\n+                opts.display_warnings |= options.display_warnings;\n+                let enable_per_target_ignores = options.enable_per_target_ignores;\n+                let mut collector = Collector::new(\n+                    crate_name,\n+                    options,\n+                    false,\n+                    opts,\n+                    Some(compiler.session().parse_sess.clone_source_map()),\n+                    None,\n+                    enable_per_target_ignores,\n+                );\n \n                 let mut hir_collector = HirCollector {\n                     sess: compiler.session(),\n@@ -137,13 +139,14 @@ crate fn run(options: Options) -> Result<(), ErrorReported> {\n                 };\n                 hir_collector.visit_testable(\n                     \"\".to_string(),\n-                    &krate.item.attrs,\n                     CRATE_HIR_ID,\n                     krate.item.span,\n                     |this| {\n                         intravisit::walk_crate(this, krate);\n                     },\n                 );\n+\n+                collector\n             });\n             compiler.session().abort_if_errors();\n \n@@ -168,15 +171,13 @@ crate fn run(options: Options) -> Result<(), ErrorReported> {\n }\n \n // Look for `#![doc(test(no_crate_inject))]`, used by crates in the std facade.\n-fn scrape_test_config(krate: &::rustc_hir::Crate<'_>) -> TestOptions {\n+fn scrape_test_config(attrs: &[ast::Attribute]) -> TestOptions {\n     use rustc_ast_pretty::pprust;\n \n     let mut opts =\n         TestOptions { no_crate_inject: false, display_warnings: false, attrs: Vec::new() };\n \n-    let test_attrs: Vec<_> = krate\n-        .item\n-        .attrs\n+    let test_attrs: Vec<_> = attrs\n         .iter()\n         .filter(|a| a.has_name(sym::doc))\n         .flat_map(|a| a.meta_item_list().unwrap_or_else(Vec::new))\n@@ -991,11 +992,11 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n     fn visit_testable<F: FnOnce(&mut Self)>(\n         &mut self,\n         name: String,\n-        attrs: &[ast::Attribute],\n         hir_id: HirId,\n         sp: Span,\n         nested: F,\n     ) {\n+        let attrs = self.tcx.hir().attrs(hir_id);\n         let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs, None);\n         if let Some(ref cfg) = attrs.cfg {\n             if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features_untracked())) {\n@@ -1053,45 +1054,27 @@ impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx>\n             item.ident.to_string()\n         };\n \n-        self.visit_testable(name, &item.attrs, item.hir_id(), item.span, |this| {\n+        self.visit_testable(name, item.hir_id(), item.span, |this| {\n             intravisit::walk_item(this, item);\n         });\n     }\n \n     fn visit_trait_item(&mut self, item: &'hir hir::TraitItem<'_>) {\n-        self.visit_testable(\n-            item.ident.to_string(),\n-            &item.attrs,\n-            item.hir_id(),\n-            item.span,\n-            |this| {\n-                intravisit::walk_trait_item(this, item);\n-            },\n-        );\n+        self.visit_testable(item.ident.to_string(), item.hir_id(), item.span, |this| {\n+            intravisit::walk_trait_item(this, item);\n+        });\n     }\n \n     fn visit_impl_item(&mut self, item: &'hir hir::ImplItem<'_>) {\n-        self.visit_testable(\n-            item.ident.to_string(),\n-            &item.attrs,\n-            item.hir_id(),\n-            item.span,\n-            |this| {\n-                intravisit::walk_impl_item(this, item);\n-            },\n-        );\n+        self.visit_testable(item.ident.to_string(), item.hir_id(), item.span, |this| {\n+            intravisit::walk_impl_item(this, item);\n+        });\n     }\n \n     fn visit_foreign_item(&mut self, item: &'hir hir::ForeignItem<'_>) {\n-        self.visit_testable(\n-            item.ident.to_string(),\n-            &item.attrs,\n-            item.hir_id(),\n-            item.span,\n-            |this| {\n-                intravisit::walk_foreign_item(this, item);\n-            },\n-        );\n+        self.visit_testable(item.ident.to_string(), item.hir_id(), item.span, |this| {\n+            intravisit::walk_foreign_item(this, item);\n+        });\n     }\n \n     fn visit_variant(\n@@ -1100,21 +1083,20 @@ impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx>\n         g: &'hir hir::Generics<'_>,\n         item_id: hir::HirId,\n     ) {\n-        self.visit_testable(v.ident.to_string(), &v.attrs, v.id, v.span, |this| {\n+        self.visit_testable(v.ident.to_string(), v.id, v.span, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }\n \n     fn visit_struct_field(&mut self, f: &'hir hir::StructField<'_>) {\n-        self.visit_testable(f.ident.to_string(), &f.attrs, f.hir_id, f.span, |this| {\n+        self.visit_testable(f.ident.to_string(), f.hir_id, f.span, |this| {\n             intravisit::walk_struct_field(this, f);\n         });\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'hir hir::MacroDef<'_>) {\n         self.visit_testable(\n             macro_def.ident.to_string(),\n-            &macro_def.attrs,\n             macro_def.hir_id(),\n             macro_def.span,\n             |_| (),"}, {"sha": "b6782fb75df35c62ce8252bd4aef1986125b4b69", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -285,10 +285,12 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     return;\n                 }\n \n+                let attrs = self.cx.tcx.hir().attrs(item.hir_id());\n+\n                 // If there was a private module in the current path then don't bother inlining\n                 // anything as it will probably be stripped anyway.\n                 if item.vis.node.is_pub() && self.inside_public_path {\n-                    let please_inline = item.attrs.iter().any(|item| match item.meta_item_list() {\n+                    let please_inline = attrs.iter().any(|item| match item.meta_item_list() {\n                         Some(ref list) if item.has_name(sym::doc) => {\n                             list.iter().any(|i| i.has_name(sym::inline))\n                         }"}, {"sha": "c73c03ca14e5696a2b21860bdab485d878fca3c0", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -335,7 +335,7 @@ enum EnumAddMustUse {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[must_use]\n enum EnumAddMustUse {\n@@ -353,7 +353,7 @@ enum EnumAddReprC {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,type_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"type_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[repr(C)]\n enum EnumAddReprC {"}, {"sha": "7a923134331a6842f8db03d7c1d42f7bfb3219af", "filename": "src/test/incremental/hashes/extern_mods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -154,7 +154,7 @@ extern \"C\" {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(cfg = \"cfail2\", except = \"hir_owner_nodes\")]\n+#[rustc_dirty(cfg = \"cfail2\", except = \"hir_owner,hir_owner_nodes\")]\n #[rustc_clean(cfg = \"cfail3\")]\n #[link_args = \"-foo -bar -baz\"]\n extern \"C\" {\n@@ -169,7 +169,7 @@ extern \"C\" {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(cfg = \"cfail2\", except = \"hir_owner_nodes\")]\n+#[rustc_dirty(cfg = \"cfail2\", except = \"hir_owner,hir_owner_nodes\")]\n #[rustc_clean(cfg = \"cfail3\")]\n #[link(name = \"bar\")]\n extern \"C\" {"}, {"sha": "ed67b2dcb04801f59242a055aaf2ba7f5c088e0c", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -194,7 +194,7 @@ pub fn second_lifetime_bound<'a, 'b, T: 'a + 'b>() {}\n pub fn inline() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes\")]\n+#[rustc_clean(cfg = \"cfail2\")]\n #[rustc_clean(cfg = \"cfail3\")]\n #[inline]\n pub fn inline() {}\n@@ -206,7 +206,7 @@ pub fn inline() {}\n pub fn inline_never() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes\")]\n+#[rustc_clean(cfg = \"cfail2\")]\n #[rustc_clean(cfg = \"cfail3\")]\n #[inline(never)]\n pub fn inline_never() {}\n@@ -217,7 +217,7 @@ pub fn inline_never() {}\n pub fn no_mangle() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes\")]\n+#[rustc_clean(cfg = \"cfail2\")]\n #[rustc_clean(cfg = \"cfail3\")]\n #[no_mangle]\n pub fn no_mangle() {}\n@@ -228,7 +228,7 @@ pub fn no_mangle() {}\n pub fn linkage() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes\")]\n+#[rustc_clean(cfg = \"cfail2\")]\n #[rustc_clean(cfg = \"cfail3\")]\n #[linkage = \"weak_odr\"]\n pub fn linkage() {}"}, {"sha": "ae8f2ace217dc57d8dae19e3f404f21f783424b8", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -214,7 +214,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+    #[rustc_clean(cfg=\"cfail2\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     #[inline]\n     pub fn make_method_inline(&self) -> u8 { 0 }\n@@ -431,7 +431,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+    #[rustc_clean(cfg=\"cfail2\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     #[no_mangle]\n     pub fn add_no_mangle_to_method(&self) { }"}, {"sha": "6f4089c60fe23669209d847ff5ec1f121d8d22a9", "filename": "src/test/incremental/hashes/statics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -41,7 +41,7 @@ static mut STATIC_MUTABILITY: u8 = 0;\n static STATIC_LINKAGE: u8 = 0;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[linkage=\"weak_odr\"]\n static STATIC_LINKAGE: u8 = 0;\n@@ -52,7 +52,7 @@ static STATIC_LINKAGE: u8 = 0;\n static STATIC_NO_MANGLE: u8 = 0;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[no_mangle]\n static STATIC_NO_MANGLE: u8 = 0;\n@@ -63,7 +63,7 @@ static STATIC_NO_MANGLE: u8 = 0;\n static STATIC_THREAD_LOCAL: u8 = 0;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[thread_local]\n static STATIC_THREAD_LOCAL: u8 = 0;"}, {"sha": "1339a1e5bf21648641f15396d66cbc347fc4d681", "filename": "src/test/incremental/hashes/struct_defs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -24,8 +24,8 @@\n pub struct LayoutPacked;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"hir_owner\", cfg=\"cfail2\")]\n-#[rustc_dirty(label=\"hir_owner_nodes\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"hir_owner\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"hir_owner_nodes\", cfg=\"cfail2\")]\n #[rustc_dirty(label=\"type_of\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"generics_of\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"predicates_of\", cfg=\"cfail2\")]\n@@ -41,8 +41,8 @@ pub struct LayoutPacked;\n struct LayoutC;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"hir_owner\", cfg=\"cfail2\")]\n-#[rustc_dirty(label=\"hir_owner_nodes\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"hir_owner\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"hir_owner_nodes\", cfg=\"cfail2\")]\n #[rustc_dirty(label=\"type_of\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"generics_of\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"predicates_of\", cfg=\"cfail2\")]"}, {"sha": "e9118da5a6137b37b403a502f4e6d2c370d6f120", "filename": "src/test/incremental/hashes/trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -457,7 +457,7 @@ impl AddNoMangleToMethod for Foo {\n #[rustc_clean(label=\"hir_owner\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"hir_owner\", cfg=\"cfail3\")]\n impl AddNoMangleToMethod for Foo {\n-    #[rustc_dirty(label=\"hir_owner\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"hir_owner\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"hir_owner\", cfg=\"cfail3\")]\n     #[no_mangle]\n     fn add_no_mangle_to_method(&self) { }\n@@ -478,7 +478,7 @@ impl MakeMethodInline for Foo {\n #[rustc_clean(label=\"hir_owner\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"hir_owner\", cfg=\"cfail3\")]\n impl MakeMethodInline for Foo {\n-    #[rustc_dirty(label=\"hir_owner\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"hir_owner\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"hir_owner\", cfg=\"cfail3\")]\n     #[inline]\n     fn make_method_inline(&self) -> u8 { 0 }"}, {"sha": "124dd670d0931744d151ad5b6e91bc2a2f0c3945", "filename": "src/test/ui-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -49,7 +49,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingAllowedAttrPass {\n         };\n \n         let allowed = |attr| pprust::attribute_to_string(attr).contains(\"allowed_attr\");\n-        if !item.attrs.iter().any(allowed) {\n+        if !cx.tcx.hir().attrs(item.hir_id()).iter().any(allowed) {\n             cx.lint(MISSING_ALLOWED_ATTR, |lint| {\n                 lint.build(\"Missing 'allowed_attr' attribute\").set_span(span).emit()\n             });"}, {"sha": "8b1a3887f157faa7ab1bc94461fea22112382191", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -28,8 +28,9 @@ macro_rules! fake_lint_pass {\n \n         impl LateLintPass<'_> for $struct {\n             fn check_crate(&mut self, cx: &LateContext, krate: &rustc_hir::Crate) {\n+                let attrs = cx.tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n                 $(\n-                    if !cx.sess().contains_name(&krate.item.attrs, $attr) {\n+                    if !cx.sess().contains_name(attrs, $attr) {\n                         cx.lint(CRATE_NOT_OKAY, |lint| {\n                              let msg = format!(\"crate is not marked with #![{}]\", $attr);\n                              lint.build(&msg).set_span(krate.item.span).emit()"}, {"sha": "c9269d2b9baa84974e59a8b4cfe4b399a54d3f0c", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -27,7 +27,8 @@ declare_lint_pass!(Pass => [CRATE_NOT_OKAY]);\n \n impl<'tcx> LateLintPass<'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext, krate: &rustc_hir::Crate) {\n-        if !cx.sess().contains_name(&krate.item.attrs, Symbol::intern(\"crate_okay\")) {\n+        let attrs = cx.tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n+        if !cx.sess().contains_name(attrs, Symbol::intern(\"crate_okay\")) {\n             cx.lint(CRATE_NOT_OKAY, |lint| {\n                 lint.build(\"crate is not marked with #![crate_okay]\")\n                     .set_span(krate.item.span)"}, {"sha": "c864ccc868665264d2555a243fe3affda89c2cc2", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-builtin-attrs.stderr", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -493,6 +493,30 @@ LL | #![feature(rust1)]\n    |\n    = note: `#[warn(stable_features)]` on by default\n \n+warning: unused attribute\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:46:1\n+   |\n+LL | #![plugin_registrar]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:60:1\n+   |\n+LL | #![should_panic]\n+   | ^^^^^^^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:61:1\n+   |\n+LL | #![ignore]\n+   | ^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:67:1\n+   |\n+LL | #![proc_macro_derive()]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+\n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:191:5\n    |\n@@ -517,6 +541,12 @@ warning: unused attribute\n LL |     #[macro_use] impl S { }\n    |     ^^^^^^^^^^^^\n \n+warning: unused attribute\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:204:1\n+   |\n+LL | #[macro_export]\n+   | ^^^^^^^^^^^^^^^\n+\n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:207:17\n    |\n@@ -548,10 +578,10 @@ LL |     #[macro_export] impl S { }\n    |     ^^^^^^^^^^^^^^^\n \n warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:204:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:223:1\n    |\n-LL | #[macro_export]\n-   | ^^^^^^^^^^^^^^^\n+LL | #[plugin_registrar]\n+   | ^^^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:228:17\n@@ -577,12 +607,6 @@ warning: unused attribute\n LL |     #[plugin_registrar] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^\n \n-warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:223:1\n-   |\n-LL | #[plugin_registrar]\n-   | ^^^^^^^^^^^^^^^^^^^\n-\n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:301:5\n    |\n@@ -607,6 +631,12 @@ warning: unused attribute\n LL |     #[path = \"3800\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^\n \n+warning: unused attribute\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:314:1\n+   |\n+LL | #[automatically_derived]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:317:17\n    |\n@@ -638,10 +668,10 @@ LL |     #[automatically_derived] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:314:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:361:1\n    |\n-LL | #[automatically_derived]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[should_panic]\n+   | ^^^^^^^^^^^^^^^\n \n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:364:17\n@@ -674,10 +704,10 @@ LL |     #[should_panic] impl S { }\n    |     ^^^^^^^^^^^^^^^\n \n warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:361:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:380:1\n    |\n-LL | #[should_panic]\n-   | ^^^^^^^^^^^^^^^\n+LL | #[ignore]\n+   | ^^^^^^^^^\n \n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:383:17\n@@ -710,10 +740,10 @@ LL |     #[ignore] impl S { }\n    |     ^^^^^^^^^\n \n warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:380:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:399:1\n    |\n-LL | #[ignore]\n-   | ^^^^^^^^^\n+LL | #[no_implicit_prelude]\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:402:17\n@@ -746,10 +776,10 @@ LL |     #[no_implicit_prelude] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:399:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:418:1\n    |\n-LL | #[no_implicit_prelude]\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[reexport_test_harness_main = \"2900\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:421:17\n@@ -781,12 +811,6 @@ warning: unused attribute\n LL |     #[reexport_test_harness_main = \"2900\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:418:1\n-   |\n-LL | #[reexport_test_harness_main = \"2900\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:445:5\n    |\n@@ -811,6 +835,18 @@ warning: unused attribute\n LL |     #[macro_escape] impl S { }\n    |     ^^^^^^^^^^^^^^^\n \n+warning: unused attribute\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:458:1\n+   |\n+LL | #[no_std]\n+   | ^^^^^^^^^\n+\n+warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:458:1\n+   |\n+LL | #[no_std]\n+   | ^^^^^^^^^\n+\n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:462:17\n    |\n@@ -872,16 +908,16 @@ LL |     #[no_std] impl S { }\n    |     ^^^^^^^^^\n \n warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:458:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:659:1\n    |\n-LL | #[no_std]\n-   | ^^^^^^^^^\n+LL | #[crate_name = \"0900\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:458:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:659:1\n    |\n-LL | #[no_std]\n-   | ^^^^^^^^^\n+LL | #[crate_name = \"0900\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:663:17\n@@ -944,15 +980,15 @@ LL |     #[crate_name = \"0900\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:659:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:684:1\n    |\n-LL | #[crate_name = \"0900\"]\n+LL | #[crate_type = \"0800\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:659:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:684:1\n    |\n-LL | #[crate_name = \"0900\"]\n+LL | #[crate_type = \"0800\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n@@ -1016,16 +1052,16 @@ LL |     #[crate_type = \"0800\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:684:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:709:1\n    |\n-LL | #[crate_type = \"0800\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[feature(x0600)]\n+   | ^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:684:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:709:1\n    |\n-LL | #[crate_type = \"0800\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[feature(x0600)]\n+   | ^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:713:17\n@@ -1088,16 +1124,16 @@ LL |     #[feature(x0600)] impl S { }\n    |     ^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:709:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:735:1\n    |\n-LL | #[feature(x0600)]\n-   | ^^^^^^^^^^^^^^^^^\n+LL | #[no_main]\n+   | ^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:709:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:735:1\n    |\n-LL | #[feature(x0600)]\n-   | ^^^^^^^^^^^^^^^^^\n+LL | #[no_main]\n+   | ^^^^^^^^^^\n \n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:739:17\n@@ -1160,16 +1196,16 @@ LL |     #[no_main] impl S { }\n    |     ^^^^^^^^^^\n \n warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:735:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:773:1\n    |\n-LL | #[no_main]\n-   | ^^^^^^^^^^\n+LL | #[recursion_limit=\"0200\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:735:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:773:1\n    |\n-LL | #[no_main]\n-   | ^^^^^^^^^^\n+LL | #[recursion_limit=\"0200\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:777:17\n@@ -1232,16 +1268,16 @@ LL |     #[recursion_limit=\"0200\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:773:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:798:1\n    |\n-LL | #[recursion_limit=\"0200\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[type_length_limit=\"0100\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:773:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:798:1\n    |\n-LL | #[recursion_limit=\"0200\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[type_length_limit=\"0100\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused attribute\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:802:17\n@@ -1303,41 +1339,5 @@ warning: crate-level attribute should be an inner attribute: add an exclamation\n LL |     #[type_length_limit=\"0100\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:798:1\n-   |\n-LL | #[type_length_limit=\"0100\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:798:1\n-   |\n-LL | #[type_length_limit=\"0100\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:46:1\n-   |\n-LL | #![plugin_registrar]\n-   | ^^^^^^^^^^^^^^^^^^^^\n-\n-warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:60:1\n-   |\n-LL | #![should_panic]\n-   | ^^^^^^^^^^^^^^^^\n-\n-warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:61:1\n-   |\n-LL | #![ignore]\n-   | ^^^^^^^^^^\n-\n-warning: unused attribute\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:67:1\n-   |\n-LL | #![proc_macro_derive()]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^\n-\n warning: 205 warnings emitted\n "}, {"sha": "707521b7802f0af9bb2af97f083d091d96bfdb70", "filename": "src/test/ui/unused/unused-attr.stderr", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fui%2Funused%2Funused-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftest%2Fui%2Funused%2Funused-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funused%2Funused-attr.stderr?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -1,8 +1,8 @@\n error: unused attribute\n-  --> $DIR/unused-attr.rs:6:1\n+  --> $DIR/unused-attr.rs:4:1\n    |\n-LL | #[rustc_dummy]\n-   | ^^^^^^^^^^^^^^\n+LL | #![rustc_dummy]\n+   | ^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/unused-attr.rs:1:9\n@@ -11,16 +11,16 @@ LL | #![deny(unused_attributes)]\n    |         ^^^^^^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr.rs:9:1\n+  --> $DIR/unused-attr.rs:6:1\n    |\n LL | #[rustc_dummy]\n    | ^^^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr.rs:14:5\n+  --> $DIR/unused-attr.rs:9:1\n    |\n-LL |     #[rustc_dummy]\n-   |     ^^^^^^^^^^^^^^\n+LL | #[rustc_dummy]\n+   | ^^^^^^^^^^^^^^\n \n error: unused attribute\n   --> $DIR/unused-attr.rs:12:1\n@@ -29,10 +29,16 @@ LL | #[rustc_dummy]\n    | ^^^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr.rs:22:9\n+  --> $DIR/unused-attr.rs:14:5\n    |\n-LL |         #[rustc_dummy]\n-   |         ^^^^^^^^^^^^^^\n+LL |     #[rustc_dummy]\n+   |     ^^^^^^^^^^^^^^\n+\n+error: unused attribute\n+  --> $DIR/unused-attr.rs:18:1\n+   |\n+LL | #[rustc_dummy]\n+   | ^^^^^^^^^^^^^^\n \n error: unused attribute\n   --> $DIR/unused-attr.rs:20:5\n@@ -41,7 +47,13 @@ LL |     #[rustc_dummy]\n    |     ^^^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr.rs:18:1\n+  --> $DIR/unused-attr.rs:22:9\n+   |\n+LL |         #[rustc_dummy]\n+   |         ^^^^^^^^^^^^^^\n+\n+error: unused attribute\n+  --> $DIR/unused-attr.rs:27:1\n    |\n LL | #[rustc_dummy]\n    | ^^^^^^^^^^^^^^\n@@ -53,7 +65,7 @@ LL |         #[rustc_dummy]\n    |         ^^^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr.rs:27:1\n+  --> $DIR/unused-attr.rs:35:1\n    |\n LL | #[rustc_dummy]\n    | ^^^^^^^^^^^^^^\n@@ -65,7 +77,7 @@ LL |     #[rustc_dummy]\n    |     ^^^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr.rs:35:1\n+  --> $DIR/unused-attr.rs:41:1\n    |\n LL | #[rustc_dummy]\n    | ^^^^^^^^^^^^^^\n@@ -82,17 +94,5 @@ error: unused attribute\n LL |     #[rustc_dummy]\n    |     ^^^^^^^^^^^^^^\n \n-error: unused attribute\n-  --> $DIR/unused-attr.rs:41:1\n-   |\n-LL | #[rustc_dummy]\n-   | ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:4:1\n-   |\n-LL | #![rustc_dummy]\n-   | ^^^^^^^^^^^^^^^\n-\n error: aborting due to 15 previous errors\n "}, {"sha": "78f0846e88e7dce83dcd655f9e8103d949943533", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -276,14 +276,15 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        let attrs = cx.tcx.hir().attrs(item.hir_id());\n         if is_relevant_item(cx, item) {\n-            check_attrs(cx, item.span, item.ident.name, &item.attrs)\n+            check_attrs(cx, item.span, item.ident.name, attrs)\n         }\n         match item.kind {\n             ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n-                let skip_unused_imports = item.attrs.iter().any(|attr| attr.has_name(sym::macro_use));\n+                let skip_unused_imports = attrs.iter().any(|attr| attr.has_name(sym::macro_use));\n \n-                for attr in item.attrs {\n+                for attr in attrs {\n                     if in_external_macro(cx.sess(), attr.span) {\n                         return;\n                     }\n@@ -353,13 +354,13 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if is_relevant_impl(cx, item) {\n-            check_attrs(cx, item.span, item.ident.name, &item.attrs)\n+            check_attrs(cx, item.span, item.ident.name, cx.tcx.hir().attrs(item.hir_id()))\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n         if is_relevant_trait(cx, item) {\n-            check_attrs(cx, item.span, item.ident.name, &item.attrs)\n+            check_attrs(cx, item.span, item.ident.name, cx.tcx.hir().attrs(item.hir_id()))\n         }\n     }\n }"}, {"sha": "658d445dfec54d0ad2e2a35bff964e571144bc84", "filename": "src/tools/clippy/clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -76,8 +76,8 @@ impl CognitiveComplexity {\n \n         if rust_cc > self.limit.limit() {\n             let fn_span = match kind {\n-                FnKind::ItemFn(ident, _, _, _, _) | FnKind::Method(ident, _, _, _) => ident.span,\n-                FnKind::Closure(_) => {\n+                FnKind::ItemFn(ident, _, _, _) | FnKind::Method(ident, _, _) => ident.span,\n+                FnKind::Closure => {\n                     let header_span = body_span.with_hi(decl.output.span().lo());\n                     let pos = snippet_opt(cx, header_span).and_then(|snip| {\n                         let low_offset = snip.find('|')?;"}, {"sha": "66cf6682f8501008ec0bcbb31e6528a6eb6ffb72", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -170,7 +170,8 @@ impl<'tcx> LateLintPass<'tcx> for Derive {\n         }) = item.kind\n         {\n             let ty = cx.tcx.type_of(item.def_id);\n-            let is_automatically_derived = is_automatically_derived(&*item.attrs);\n+            let attrs = cx.tcx.hir().attrs(item.hir_id());\n+            let is_automatically_derived = is_automatically_derived(attrs);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);\n             check_ord_partial_ord(cx, item.span, trait_ref, ty, is_automatically_derived);"}, {"sha": "23c99e45ca7fcd924461ceab2b2322bfb4a1694f", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -208,12 +208,14 @@ impl_lint_pass!(DocMarkdown =>\n );\n \n impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n-    fn check_crate(&mut self, cx: &LateContext<'tcx>, krate: &'tcx hir::Crate<'_>) {\n-        check_attrs(cx, &self.valid_idents, &krate.item.attrs);\n+    fn check_crate(&mut self, cx: &LateContext<'tcx>, _: &'tcx hir::Crate<'_>) {\n+        let attrs = cx.tcx.hir().attrs(hir::CRATE_HIR_ID);\n+        check_attrs(cx, &self.valid_idents, attrs);\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n+        let attrs = cx.tcx.hir().attrs(item.hir_id());\n+        let headers = check_attrs(cx, &self.valid_idents, attrs);\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, _, body_id) => {\n                 if !(is_entrypoint_fn(cx, item.def_id.to_def_id()) || in_external_macro(cx.tcx.sess, item.span)) {\n@@ -249,7 +251,8 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n-        let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n+        let attrs = cx.tcx.hir().attrs(item.hir_id());\n+        let headers = check_attrs(cx, &self.valid_idents, attrs);\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n             if !in_external_macro(cx.tcx.sess, item.span) {\n                 lint_for_missing_headers(cx, item.hir_id(), item.span, sig, headers, None, None);\n@@ -258,7 +261,8 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n-        let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n+        let attrs = cx.tcx.hir().attrs(item.hir_id());\n+        let headers = check_attrs(cx, &self.valid_idents, attrs);\n         if self.in_trait_impl || in_external_macro(cx.tcx.sess, item.span) {\n             return;\n         }"}, {"sha": "316f7484862803281cdcc2f96e9b3a06d5c87beb", "filename": "src/tools/clippy/clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -73,7 +73,8 @@ impl LateLintPass<'_> for ExhaustiveItems {\n         if_chain! {\n             if let ItemKind::Enum(..) | ItemKind::Struct(..) = item.kind;\n             if cx.access_levels.is_exported(item.hir_id());\n-            if !item.attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n+            let attrs = cx.tcx.hir().attrs(item.hir_id());\n+            if !attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n             then {\n                 let (lint, msg) = if let ItemKind::Struct(ref v, ..) = item.kind {\n                     if v.fields().iter().any(|f| !f.vis.node.is_pub()) {"}, {"sha": "234cb0f53aa0c26a7b77e5ee3426407d8633c7df", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -251,9 +251,9 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n         hir_id: hir::HirId,\n     ) {\n         let unsafety = match kind {\n-            intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _, _) => unsafety,\n-            intravisit::FnKind::Method(_, sig, _, _) => sig.header.unsafety,\n-            intravisit::FnKind::Closure(_) => return,\n+            intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _) => unsafety,\n+            intravisit::FnKind::Method(_, sig, _) => sig.header.unsafety,\n+            intravisit::FnKind::Closure => return,\n         };\n \n         // don't warn for implementations, it's not their fault\n@@ -267,9 +267,8 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n                         ..\n                     },\n                     _,\n-                    _,\n                 )\n-                | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _, _) => {\n+                | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _) => {\n                     self.check_arg_number(cx, decl, span.with_hi(decl.output.span().hi()))\n                 },\n                 _ => {},\n@@ -281,7 +280,8 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        let attr = must_use_attr(&item.attrs);\n+        let attrs = cx.tcx.hir().attrs(item.hir_id());\n+        let attr = must_use_attr(attrs);\n         if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n             let is_public = cx.access_levels.is_exported(item.hir_id());\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n@@ -292,7 +292,7 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n                 check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n                 return;\n             }\n-            if is_public && !is_proc_macro(cx.sess(), &item.attrs) && attr_by_name(&item.attrs, \"no_mangle\").is_none() {\n+            if is_public && !is_proc_macro(cx.sess(), attrs) && attr_by_name(attrs, \"no_mangle\").is_none() {\n                 check_must_use_candidate(\n                     cx,\n                     &sig.decl,\n@@ -313,11 +313,12 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n             if is_public && trait_ref_of_method(cx, item.hir_id()).is_none() {\n                 check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n             }\n-            let attr = must_use_attr(&item.attrs);\n+            let attrs = cx.tcx.hir().attrs(item.hir_id());\n+            let attr = must_use_attr(attrs);\n             if let Some(attr) = attr {\n                 check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n             } else if is_public\n-                && !is_proc_macro(cx.sess(), &item.attrs)\n+                && !is_proc_macro(cx.sess(), attrs)\n                 && trait_ref_of_method(cx, item.hir_id()).is_none()\n             {\n                 check_must_use_candidate(\n@@ -345,15 +346,16 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n                 check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n             }\n \n-            let attr = must_use_attr(&item.attrs);\n+            let attrs = cx.tcx.hir().attrs(item.hir_id());\n+            let attr = must_use_attr(attrs);\n             if let Some(attr) = attr {\n                 check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n             }\n             if let hir::TraitFn::Provided(eid) = *eid {\n                 let body = cx.tcx.hir().body(eid);\n                 Self::check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id());\n \n-                if attr.is_none() && is_public && !is_proc_macro(cx.sess(), &item.attrs) {\n+                if attr.is_none() && is_public && !is_proc_macro(cx.sess(), attrs) {\n                     check_must_use_candidate(\n                         cx,\n                         &sig.decl,"}, {"sha": "9e1a8864a3ebe0ff6deff9c2cbec4c1bf19a7499", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -58,7 +58,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n         _: Span,\n         hir_id: HirId,\n     ) {\n-        if let FnKind::Closure(_) = kind {\n+        if let FnKind::Closure = kind {\n             return;\n         }\n         let ret_ty = utils::return_ty(cx, hir_id);"}, {"sha": "00acbd6cc3f7694525ebba2802f5883207b8a5bc", "filename": "src/tools/clippy/clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -34,7 +34,8 @@ declare_lint_pass!(InlineFnWithoutBody => [INLINE_FN_WITHOUT_BODY]);\n impl<'tcx> LateLintPass<'tcx> for InlineFnWithoutBody {\n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n         if let TraitItemKind::Fn(_, TraitFn::Required(_)) = item.kind {\n-            check_attrs(cx, item.ident.name, &item.attrs);\n+            let attrs = cx.tcx.hir().attrs(item.hir_id());\n+            check_attrs(cx, item.ident.name, attrs);\n         }\n     }\n }"}, {"sha": "9b626d81ebd813e03e940a3cfaca1d8239057873", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -578,7 +578,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n             // also check for empty `loop {}` statements, skipping those in #[panic_handler]\n             if block.stmts.is_empty() && block.expr.is_none() && !is_in_panic_handler(cx, expr) {\n                 let msg = \"empty `loop {}` wastes CPU cycles\";\n-                let help = if is_no_std_crate(cx.tcx.hir().krate()) {\n+                let help = if is_no_std_crate(cx) {\n                     \"you should either use `panic!()` or add a call pausing or sleeping the thread to the loop body\"\n                 } else {\n                     \"you should either use `panic!()` or add `std::thread::sleep(..);` to the loop body\""}, {"sha": "6d9c78393c8c4d2eee97df292a35372f02ee80b1", "filename": "src/tools/clippy/clippy_lints/src/macro_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -107,8 +107,8 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n         if_chain! {\n             if cx.sess().opts.edition >= Edition::Edition2018;\n             if let hir::ItemKind::Use(path, _kind) = &item.kind;\n-            if let Some(mac_attr) = item\n-                .attrs\n+            let attrs = cx.tcx.hir().attrs(item.hir_id());\n+            if let Some(mac_attr) = attrs\n                 .iter()\n                 .find(|attr| attr.ident().map(|s| s.to_string()) == Some(\"macro_use\".to_string()));\n             if let Res::Def(DefKind::Mod, id) = path.res;"}, {"sha": "1b274c79d3820b5a948efb4578adb3bf220b0e3f", "filename": "src/tools/clippy/clippy_lints/src/main_recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmain_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmain_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmain_recursion.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -32,8 +32,8 @@ pub struct MainRecursion {\n impl_lint_pass!(MainRecursion => [MAIN_RECURSION]);\n \n impl LateLintPass<'_> for MainRecursion {\n-    fn check_crate(&mut self, _: &LateContext<'_>, krate: &Crate<'_>) {\n-        self.has_no_std_attr = is_no_std_crate(krate);\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n+        self.has_no_std_attr = is_no_std_crate(cx);\n     }\n \n     fn check_expr_post(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {"}, {"sha": "9c87759d51d2db63dab4723091d93aacdf89c694", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -1207,11 +1207,11 @@ fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr\n         if b0 != b1;\n         let if_guard = &b0_arms[0].guard;\n         if if_guard.is_none() || b0_arms.len() == 1;\n-        if b0_arms[0].attrs.is_empty();\n+        if cx.tcx.hir().attrs(b0_arms[0].hir_id).is_empty();\n         if b0_arms[1..].iter()\n             .all(|arm| {\n                 find_bool_lit(&arm.body.kind, desugared).map_or(false, |b| b == b0) &&\n-                arm.guard.is_none() && arm.attrs.is_empty()\n+                arm.guard.is_none() && cx.tcx.hir().attrs(arm.hir_id).is_empty()\n             });\n         then {\n             // The suggestion may be incorrect, because some arms can have `cfg` attributes"}, {"sha": "35b4c3d5b03abf1d65733962fbdb65e74a503689", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -278,7 +278,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n         span: Span,\n         _: HirId,\n     ) {\n-        if let FnKind::Closure(_) = k {\n+        if let FnKind::Closure = k {\n             // Does not apply to closures\n             return;\n         }"}, {"sha": "b0998a80128cef12d73d13f2136b7c64e5672fd0", "filename": "src/tools/clippy/clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -133,7 +133,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n                     return;\n                 }\n             },\n-            FnKind::Closure(..) => return,\n+            FnKind::Closure => return,\n         }\n \n         let mir = cx.tcx.optimized_mir(def_id);"}, {"sha": "6ec4c38d0f9ccfeac5afc4c86d0a6fc3c46bba37", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -127,7 +127,8 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &LateContext<'tcx>, krate: &'tcx hir::Crate<'_>) {\n-        self.check_missing_docs_attrs(cx, &krate.item.attrs, krate.item.span, \"the\", \"crate\");\n+        let attrs = cx.tcx.hir().attrs(hir::CRATE_HIR_ID);\n+        self.check_missing_docs_attrs(cx, attrs, krate.item.span, \"the\", \"crate\");\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, it: &'tcx hir::Item<'_>) {\n@@ -160,13 +161,15 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n         let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, &it.attrs, it.span, article, desc);\n+        let attrs = cx.tcx.hir().attrs(it.hir_id());\n+        self.check_missing_docs_attrs(cx, attrs, it.span, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx hir::TraitItem<'_>) {\n         let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, &trait_item.attrs, trait_item.span, article, desc);\n+        let attrs = cx.tcx.hir().attrs(trait_item.hir_id());\n+        self.check_missing_docs_attrs(cx, attrs, trait_item.span, article, desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n@@ -181,16 +184,19 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n         }\n \n         let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, article, desc);\n+        let attrs = cx.tcx.hir().attrs(impl_item.hir_id());\n+        self.check_missing_docs_attrs(cx, attrs, impl_item.span, article, desc);\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext<'tcx>, sf: &'tcx hir::StructField<'_>) {\n         if !sf.is_positional() {\n-            self.check_missing_docs_attrs(cx, &sf.attrs, sf.span, \"a\", \"struct field\");\n+            let attrs = cx.tcx.hir().attrs(sf.hir_id);\n+            self.check_missing_docs_attrs(cx, attrs, sf.span, \"a\", \"struct field\");\n         }\n     }\n \n     fn check_variant(&mut self, cx: &LateContext<'tcx>, v: &'tcx hir::Variant<'_>) {\n-        self.check_missing_docs_attrs(cx, &v.attrs, v.span, \"a\", \"variant\");\n+        let attrs = cx.tcx.hir().attrs(v.id);\n+        self.check_missing_docs_attrs(cx, attrs, v.span, \"a\", \"variant\");\n     }\n }"}, {"sha": "9b604471573d96852ac5772707d91925def90c11", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -93,7 +93,8 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n         match it.kind {\n             hir::ItemKind::Fn(..) => {\n                 let desc = \"a function\";\n-                check_missing_inline_attrs(cx, &it.attrs, it.span, desc);\n+                let attrs = cx.tcx.hir().attrs(it.hir_id());\n+                check_missing_inline_attrs(cx, attrs, it.span, desc);\n             },\n             hir::ItemKind::Trait(ref _is_auto, ref _unsafe, ref _generics, ref _bounds, trait_items) => {\n                 // note: we need to check if the trait is exported so we can't use\n@@ -108,7 +109,8 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n                                 // an impl is not provided\n                                 let desc = \"a default trait method\";\n                                 let item = cx.tcx.hir().trait_item(tit.id);\n-                                check_missing_inline_attrs(cx, &item.attrs, item.span, desc);\n+                                let attrs = cx.tcx.hir().attrs(item.hir_id());\n+                                check_missing_inline_attrs(cx, attrs, item.span, desc);\n                             }\n                         },\n                     }\n@@ -160,6 +162,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             }\n         }\n \n-        check_missing_inline_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n+        let attrs = cx.tcx.hir().attrs(impl_item.hir_id());\n+        check_missing_inline_attrs(cx, attrs, impl_item.span, desc);\n     }\n }"}, {"sha": "1aadcfd87b60f73a1dc44626adc30300cae35d93", "filename": "src/tools/clippy/clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -115,8 +115,9 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n         }\n     }\n \n-    fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if is_automatically_derived(item.attrs) {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        let attrs = cx.tcx.hir().attrs(item.hir_id());\n+        if is_automatically_derived(attrs) {\n             debug_assert!(self.derived_item.is_none());\n             self.derived_item = Some(item.def_id);\n         }"}, {"sha": "cac4b2075114ac812c0376555b8cd0cad770c1ee", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -80,13 +80,14 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n         }\n \n         match kind {\n-            FnKind::ItemFn(.., header, _, attrs) => {\n+            FnKind::ItemFn(.., header, _) => {\n+                let attrs = cx.tcx.hir().attrs(hir_id);\n                 if header.abi != Abi::Rust || requires_exact_signature(attrs) {\n                     return;\n                 }\n             },\n             FnKind::Method(..) => (),\n-            FnKind::Closure(..) => return,\n+            FnKind::Closure => return,\n         }\n \n         // Exclude non-inherent impls"}, {"sha": "207423a18614927f30960ba847b944170fbca91e", "filename": "src/tools/clippy/clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -43,9 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for PanicInResultFn {\n         span: Span,\n         hir_id: hir::HirId,\n     ) {\n-        if !matches!(fn_kind, FnKind::Closure(_))\n-            && is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::result_type)\n-        {\n+        if !matches!(fn_kind, FnKind::Closure) && is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::result_type) {\n             lint_impl_body(cx, span, body);\n         }\n     }"}, {"sha": "aca1ed5ca6563144b4e3e9fc3a925f816a05ffd9", "filename": "src/tools/clippy/clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -35,7 +35,8 @@ impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if_chain! {\n             if let ItemKind::Impl(Impl { of_trait: Some(ref trait_ref), items: impl_items, .. }) = item.kind;\n-            if !is_automatically_derived(&*item.attrs);\n+            let attrs = cx.tcx.hir().attrs(item.hir_id());\n+            if !is_automatically_derived(attrs);\n             if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n             if trait_ref.path.res.def_id() == eq_trait;\n             then {"}, {"sha": "ff700aa51460789cc66d0aa7779ce65a24ec0cb2", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -224,10 +224,11 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n         }\n \n         match kind {\n-            FnKind::ItemFn(.., header, _, attrs) => {\n+            FnKind::ItemFn(.., header, _) => {\n                 if header.abi != Abi::Rust {\n                     return;\n                 }\n+                let attrs = cx.tcx.hir().attrs(hir_id);\n                 for a in attrs {\n                     if let Some(meta_items) = a.meta_item_list() {\n                         if a.has_name(sym::proc_macro_derive)\n@@ -239,7 +240,7 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n                 }\n             },\n             FnKind::Method(..) => (),\n-            FnKind::Closure(..) => return,\n+            FnKind::Closure => return,\n         }\n \n         // Exclude non-inherent impls"}, {"sha": "40c0f1f45895ba0af5ed1341e12d21265bc6f637", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -81,7 +81,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n             if let Some(stmt) = block.stmts.iter().last();\n             if let StmtKind::Local(local) = &stmt.kind;\n             if local.ty.is_none();\n-            if local.attrs.is_empty();\n+            if cx.tcx.hir().attrs(local.hir_id).is_empty();\n             if let Some(initexpr) = &local.init;\n             if let PatKind::Binding(.., ident, _) = local.pat.kind;\n             if let ExprKind::Path(qpath) = &retexpr.kind;\n@@ -131,7 +131,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n         _: HirId,\n     ) {\n         match kind {\n-            FnKind::Closure(_) => {\n+            FnKind::Closure => {\n                 // when returning without value in closure, replace this `return`\n                 // with an empty block to prevent invalid suggestion (see #6501)\n                 let replacement = if let ExprKind::Ret(None) = &body.value.kind {\n@@ -177,7 +177,8 @@ fn check_final_expr<'tcx>(\n         // simple return is always \"bad\"\n         ExprKind::Ret(ref inner) => {\n             // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n-            if !expr.attrs.iter().any(attr_is_cfg) {\n+            let attrs = cx.tcx.hir().attrs(expr.hir_id);\n+            if !attrs.iter().any(attr_is_cfg) {\n                 let borrows = inner.map_or(false, |inner| last_statement_borrows(cx, inner));\n                 if !borrows {\n                     emit_return_lint("}, {"sha": "8e076397c119a9a25f94f16734d979f6a593790d", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -66,12 +66,12 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n     ) {\n         // Abort if public function/method or closure.\n         match fn_kind {\n-            FnKind::ItemFn(.., visibility, _) | FnKind::Method(.., Some(visibility), _) => {\n+            FnKind::ItemFn(.., visibility) | FnKind::Method(.., Some(visibility)) => {\n                 if visibility.node.is_pub() {\n                     return;\n                 }\n             },\n-            FnKind::Closure(..) => return,\n+            FnKind::Closure => return,\n             _ => (),\n         }\n "}, {"sha": "3dd190ba440186c2486d6b71151102ea43df1cb5", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -2,15 +2,14 @@\n //! to generate a clippy lint detecting said code automatically.\n \n use crate::utils::get_attr;\n-use rustc_ast::ast::{Attribute, LitFloatType, LitKind};\n+use rustc_ast::ast::{LitFloatType, LitKind};\n use rustc_ast::walk_list;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Pat, PatKind, QPath, Stmt, StmtKind, TyKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n-use rustc_session::Session;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -66,7 +65,7 @@ fn done() {\n \n impl<'tcx> LateLintPass<'tcx> for Author {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        if !has_attr(cx.sess(), &item.attrs) {\n+        if !has_attr(cx, item.hir_id()) {\n             return;\n         }\n         prelude();\n@@ -75,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n-        if !has_attr(cx.sess(), &item.attrs) {\n+        if !has_attr(cx, item.hir_id()) {\n             return;\n         }\n         prelude();\n@@ -84,7 +83,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n-        if !has_attr(cx.sess(), &item.attrs) {\n+        if !has_attr(cx, item.hir_id()) {\n             return;\n         }\n         prelude();\n@@ -93,7 +92,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n     }\n \n     fn check_variant(&mut self, cx: &LateContext<'tcx>, var: &'tcx hir::Variant<'_>) {\n-        if !has_attr(cx.sess(), &var.attrs) {\n+        if !has_attr(cx, var.id) {\n             return;\n         }\n         prelude();\n@@ -103,7 +102,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext<'tcx>, field: &'tcx hir::StructField<'_>) {\n-        if !has_attr(cx.sess(), &field.attrs) {\n+        if !has_attr(cx, field.hir_id) {\n             return;\n         }\n         prelude();\n@@ -112,7 +111,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if !has_attr(cx.sess(), &expr.attrs) {\n+        if !has_attr(cx, expr.hir_id) {\n             return;\n         }\n         prelude();\n@@ -121,7 +120,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n     }\n \n     fn check_arm(&mut self, cx: &LateContext<'tcx>, arm: &'tcx hir::Arm<'_>) {\n-        if !has_attr(cx.sess(), &arm.attrs) {\n+        if !has_attr(cx, arm.hir_id) {\n             return;\n         }\n         prelude();\n@@ -130,7 +129,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n-        if !has_attr(cx.sess(), stmt.kind.attrs(|id| cx.tcx.hir().item(id))) {\n+        if !has_attr(cx, stmt.hir_id) {\n             return;\n         }\n         prelude();\n@@ -139,7 +138,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ForeignItem<'_>) {\n-        if !has_attr(cx.sess(), &item.attrs) {\n+        if !has_attr(cx, item.hir_id()) {\n             return;\n         }\n         prelude();\n@@ -719,8 +718,9 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     }\n }\n \n-fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n-    get_attr(sess, attrs, \"author\").count() > 0\n+fn has_attr(cx: &LateContext<'_>, hir_id: hir::HirId) -> bool {\n+    let attrs = cx.tcx.hir().attrs(hir_id);\n+    get_attr(cx.sess(), attrs, \"author\").count() > 0\n }\n \n #[must_use]"}, {"sha": "9e3973e1d51fcc1b76128a5836236b23b41d6fb7", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -33,14 +33,14 @@ declare_lint_pass!(DeepCodeInspector => [DEEP_CODE_INSPECTION]);\n \n impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        if !has_attr(cx.sess(), &item.attrs) {\n+        if !has_attr(cx.sess(), cx.tcx.hir().attrs(item.hir_id())) {\n             return;\n         }\n         print_item(cx, item);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n-        if !has_attr(cx.sess(), &item.attrs) {\n+        if !has_attr(cx.sess(), cx.tcx.hir().attrs(item.hir_id())) {\n             return;\n         }\n         println!(\"impl item `{}`\", item.ident.name);\n@@ -89,14 +89,14 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n     //\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if !has_attr(cx.sess(), &expr.attrs) {\n+        if !has_attr(cx.sess(), cx.tcx.hir().attrs(expr.hir_id)) {\n             return;\n         }\n         print_expr(cx, expr, 0);\n     }\n \n     fn check_arm(&mut self, cx: &LateContext<'tcx>, arm: &'tcx hir::Arm<'_>) {\n-        if !has_attr(cx.sess(), &arm.attrs) {\n+        if !has_attr(cx.sess(), cx.tcx.hir().attrs(arm.hir_id)) {\n             return;\n         }\n         print_pat(cx, &arm.pat, 1);\n@@ -109,7 +109,7 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n-        if !has_attr(cx.sess(), stmt.kind.attrs(|id| cx.tcx.hir().item(id))) {\n+        if !has_attr(cx.sess(), cx.tcx.hir().attrs(stmt.hir_id)) {\n             return;\n         }\n         match stmt.kind {"}, {"sha": "4cd7ed5c45da3e79277597da183795ecf7c167dc", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff1edf919198aa4dea106e63b7d1899f1061fe0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=dff1edf919198aa4dea106e63b7d1899f1061fe0", "patch": "@@ -61,7 +61,7 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::Node;\n use rustc_hir::{\n-    def, Arm, Block, Body, Constness, Crate, Expr, ExprKind, FnDecl, HirId, ImplItem, ImplItemKind, Item, ItemKind,\n+    def, Arm, Block, Body, Constness, Expr, ExprKind, FnDecl, HirId, ImplItem, ImplItemKind, Item, ItemKind,\n     MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef, TyKind, Unsafety,\n };\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -1510,8 +1510,8 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n }\n \n-pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n-    krate.item.attrs.iter().any(|attr| {\n+pub fn is_no_std_crate(cx: &LateContext<'_>) -> bool {\n+    cx.tcx.hir().attrs(hir::CRATE_HIR_ID).iter().any(|attr| {\n         if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n             attr.path == sym::no_std\n         } else {"}]}