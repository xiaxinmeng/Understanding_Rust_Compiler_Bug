{"sha": "06788fd7a4c89479dfe28c1e42410778adf41eab", "node_id": "C_kwDOAAsO6NoAKDA2Nzg4ZmQ3YTRjODk0NzlkZmUyOGMxZTQyNDEwNzc4YWRmNDFlYWI", "commit": {"author": {"name": "Cyborus04", "email": "87248184+Cyborus04@users.noreply.github.com", "date": "2022-04-02T00:07:28Z"}, "committer": {"name": "Cyborus04", "email": "87248184+Cyborus04@users.noreply.github.com", "date": "2022-04-08T04:54:39Z"}, "message": "add `<[[T; N]]>::flatten`, `<[[T; N]]>::flatten_mut`, and `Vec::<[T; N]>::into_flattened`", "tree": {"sha": "84b7324e681a3a7781af6dbd97c703ab86b3af75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84b7324e681a3a7781af6dbd97c703ab86b3af75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06788fd7a4c89479dfe28c1e42410778adf41eab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06788fd7a4c89479dfe28c1e42410778adf41eab", "html_url": "https://github.com/rust-lang/rust/commit/06788fd7a4c89479dfe28c1e42410778adf41eab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06788fd7a4c89479dfe28c1e42410778adf41eab/comments", "author": {"login": "Cyborus04", "id": 87248184, "node_id": "MDQ6VXNlcjg3MjQ4MTg0", "avatar_url": "https://avatars.githubusercontent.com/u/87248184?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Cyborus04", "html_url": "https://github.com/Cyborus04", "followers_url": "https://api.github.com/users/Cyborus04/followers", "following_url": "https://api.github.com/users/Cyborus04/following{/other_user}", "gists_url": "https://api.github.com/users/Cyborus04/gists{/gist_id}", "starred_url": "https://api.github.com/users/Cyborus04/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Cyborus04/subscriptions", "organizations_url": "https://api.github.com/users/Cyborus04/orgs", "repos_url": "https://api.github.com/users/Cyborus04/repos", "events_url": "https://api.github.com/users/Cyborus04/events{/privacy}", "received_events_url": "https://api.github.com/users/Cyborus04/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Cyborus04", "id": 87248184, "node_id": "MDQ6VXNlcjg3MjQ4MTg0", "avatar_url": "https://avatars.githubusercontent.com/u/87248184?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Cyborus04", "html_url": "https://github.com/Cyborus04", "followers_url": "https://api.github.com/users/Cyborus04/followers", "following_url": "https://api.github.com/users/Cyborus04/following{/other_user}", "gists_url": "https://api.github.com/users/Cyborus04/gists{/gist_id}", "starred_url": "https://api.github.com/users/Cyborus04/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Cyborus04/subscriptions", "organizations_url": "https://api.github.com/users/Cyborus04/orgs", "repos_url": "https://api.github.com/users/Cyborus04/repos", "events_url": "https://api.github.com/users/Cyborus04/events{/privacy}", "received_events_url": "https://api.github.com/users/Cyborus04/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "297a8018b525c28ef10ee6a91d61954839b508b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/297a8018b525c28ef10ee6a91d61954839b508b9", "html_url": "https://github.com/rust-lang/rust/commit/297a8018b525c28ef10ee6a91d61954839b508b9"}], "stats": {"total": 153, "additions": 153, "deletions": 0}, "files": [{"sha": "69ca33cfc2265c1baa48b7a7cacd334b64c38a73", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=06788fd7a4c89479dfe28c1e42410778adf41eab", "patch": "@@ -131,6 +131,7 @@\n #![feature(trusted_len)]\n #![feature(trusted_random_access)]\n #![feature(try_trait_v2)]\n+#![feature(unchecked_math)]\n #![feature(unicode_internals)]\n #![feature(unsize)]\n //"}, {"sha": "74bcac2b5414de6886b4666ce9ad524ea1678041", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=06788fd7a4c89479dfe28c1e42410778adf41eab", "patch": "@@ -2274,6 +2274,51 @@ impl<T: Clone, A: Allocator> Vec<T, A> {\n     }\n }\n \n+impl<T, A: Allocator, const N: usize> Vec<[T; N], A> {\n+    /// Takes a `Vec<[T; N]>` and flattens it into a `Vec<T>`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the length of the resulting vector would overflow a `usize`.\n+    ///\n+    /// This is only possible when flattening a vector of arrays of zero-sized\n+    /// types, and thus tends to be irrelevant in practice. If\n+    /// `size_of::<T>() > 0`, this will never panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_flatten)]\n+    ///\n+    /// let mut vec = vec![[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n+    /// assert_eq!(vec.pop(), Some([7, 8, 9]));\n+    ///\n+    /// let mut flattened = vec.into_flattened();\n+    /// assert_eq!(flattened.pop(), Some(6));\n+    /// ```\n+    #[unstable(feature = \"slice_flatten\", issue = \"95629\")]\n+    pub fn into_flattened(self) -> Vec<T, A> {\n+        let (ptr, len, cap, alloc) = self.into_raw_parts_with_alloc();\n+        let (new_len, new_cap) = if mem::size_of::<T>() == 0 {\n+            (len.checked_mul(N).expect(\"vec len overflow\"), usize::MAX)\n+        } else {\n+            // SAFETY:\n+            // - `cap * N` cannot overflow because the allocation is already in\n+            // the address space.\n+            // - Each `[T; N]` has `N` valid elements, so there are `len * N`\n+            // valid elements in the allocation.\n+            unsafe { (len.unchecked_mul(N), cap.unchecked_mul(N)) }\n+        };\n+        // SAFETY:\n+        // - `ptr` was allocated by `self`\n+        // - `ptr` is well-aligned because `[T; N]` has the same alignment as `T`.\n+        // - `new_cap` refers to the same sized allocation as `cap` because\n+        // `new_cap * size_of::<T>()` == `cap * size_of::<[T; N]>()`\n+        // - `len` <= `cap`, so `len * N` <= `cap * N`.\n+        unsafe { Vec::<T, A>::from_raw_parts_in(ptr.cast(), new_len, new_cap, alloc) }\n+    }\n+}\n+\n // This code generalizes `extend_with_{element,default}`.\n trait ExtendWith<T> {\n     fn next(&mut self) -> T;"}, {"sha": "16ceb8e373dcb37b551bcc633f2954e63ad0c1ba", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=06788fd7a4c89479dfe28c1e42410778adf41eab", "patch": "@@ -38,6 +38,7 @@\n #![feature(const_str_from_utf8)]\n #![feature(nonnull_slice_from_raw_parts)]\n #![feature(panic_update_hook)]\n+#![feature(slice_flatten)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "bc1397146dda9460c0046cc68c852b4129b3ef23", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=06788fd7a4c89479dfe28c1e42410778adf41eab", "patch": "@@ -2408,3 +2408,10 @@ fn test_extend_from_within_panicing_clone() {\n \n     assert_eq!(count.load(Ordering::SeqCst), 4);\n }\n+\n+#[test]\n+#[should_panic = \"vec len overflow\"]\n+fn test_into_flattened_size_overflow() {\n+    let v = vec![[(); usize::MAX]; 2];\n+    let _ = v.into_flattened();\n+}"}, {"sha": "e76c31635eae5f1e5bccbdf04893596fa58e0fbe", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=06788fd7a4c89479dfe28c1e42410778adf41eab", "patch": "@@ -3994,6 +3994,88 @@ impl<T> [T] {\n     }\n }\n \n+#[cfg(not(bootstrap))]\n+impl<T, const N: usize> [[T; N]] {\n+    /// Takes a `&[[T; N]]`, and flattens it to a `&[T]`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This panics if the length of the resulting slice would overflow a `usize`.\n+    ///\n+    /// This is only possible when flattening a slice of arrays of zero-sized\n+    /// types, and thus tends to be irrelevant in practice. If\n+    /// `size_of::<T>() > 0`, this will never panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_flatten)]\n+    ///\n+    /// assert_eq!([[1, 2, 3], [4, 5, 6]].flatten(), &[1, 2, 3, 4, 5, 6]);\n+    ///\n+    /// assert_eq!(\n+    ///     [[1, 2, 3], [4, 5, 6]].flatten(),\n+    ///     [[1, 2], [3, 4], [5, 6]].flatten(),\n+    /// );\n+    ///\n+    /// let slice_of_empty_arrays: &[[i32; 0]] = &[[], [], [], [], []];\n+    /// assert!(slice_of_empty_arrays.flatten().is_empty());\n+    ///\n+    /// let empty_slice_of_arrays: &[[u32; 10]] = &[];\n+    /// assert!(empty_slice_of_arrays.flatten().is_empty());\n+    /// ```\n+    #[unstable(feature = \"slice_flatten\", issue = \"95629\")]\n+    pub fn flatten(&self) -> &[T] {\n+        let len = if crate::mem::size_of::<T>() == 0 {\n+            self.len().checked_mul(N).expect(\"slice len overflow\")\n+        } else {\n+            // SAFETY: `self.len() * N` cannot overflow because `self` is\n+            // already in the address space.\n+            unsafe { self.len().unchecked_mul(N) }\n+        };\n+        // SAFETY: `[T]` is layout-identical to `[T; N]`\n+        unsafe { from_raw_parts(self.as_ptr().cast(), len) }\n+    }\n+\n+    /// Takes a `&mut [[T; N]]`, and flattens it to a `&mut [T]`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This panics if the length of the resulting slice would overflow a `usize`.\n+    ///\n+    /// This is only possible when flattening a slice of arrays of zero-sized\n+    /// types, and thus tends to be irrelevant in practice. If\n+    /// `size_of::<T>() > 0`, this will never panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_flatten)]\n+    ///\n+    /// fn add_5_to_all(slice: &mut [i32]) {\n+    ///     for i in slice {\n+    ///         *i += 5;\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n+    /// add_5_to_all(array.flatten_mut());\n+    /// assert_eq!(array, [[6, 7, 8], [9, 10, 11], [12, 13, 14]]);\n+    /// ```\n+    #[unstable(feature = \"slice_flatten\", issue = \"95629\")]\n+    pub fn flatten_mut(&mut self) -> &mut [T] {\n+        let len = if crate::mem::size_of::<T>() == 0 {\n+            self.len().checked_mul(N).expect(\"slice len overflow\")\n+        } else {\n+            // SAFETY: `self.len() * N` cannot overflow because `self` is\n+            // already in the address space.\n+            unsafe { self.len().unchecked_mul(N) }\n+        };\n+        // SAFETY: `[T]` is layout-identical to `[T; N]`\n+        unsafe { from_raw_parts_mut(self.as_mut_ptr().cast(), len) }\n+    }\n+}\n+\n trait CloneFromSpec<T> {\n     fn spec_clone_from(&mut self, src: &[T]);\n }"}, {"sha": "e9955655295842e86839ad300a1437dbb3793f4b", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=06788fd7a4c89479dfe28c1e42410778adf41eab", "patch": "@@ -93,6 +93,7 @@\n #![feature(const_array_from_ref)]\n #![feature(const_slice_from_ref)]\n #![feature(waker_getters)]\n+#![feature(slice_flatten)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;"}, {"sha": "ada479147db95806c3e638a9ecc36687d91bba9c", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06788fd7a4c89479dfe28c1e42410778adf41eab/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=06788fd7a4c89479dfe28c1e42410778adf41eab", "patch": "@@ -2504,3 +2504,19 @@ fn test_slice_from_ptr_range() {\n         assert_eq!(slice::from_ptr_range(range), &arr);\n     }\n }\n+\n+#[test]\n+#[cfg(not(bootstrap))]\n+#[should_panic = \"slice len overflow\"]\n+fn test_flatten_size_overflow() {\n+    let x = &[[(); usize::MAX]; 2][..];\n+    let _ = x.flatten();\n+}\n+\n+#[test]\n+#[cfg(not(bootstrap))]\n+#[should_panic = \"slice len overflow\"]\n+fn test_flatten_mut_size_overflow() {\n+    let x = &mut [[(); usize::MAX]; 2][..];\n+    let _ = x.flatten_mut();\n+}"}]}