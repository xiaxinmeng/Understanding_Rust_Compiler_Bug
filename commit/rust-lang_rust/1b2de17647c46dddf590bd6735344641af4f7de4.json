{"sha": "1b2de17647c46dddf590bd6735344641af4f7de4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMmRlMTc2NDdjNDZkZGRmNTkwYmQ2NzM1MzQ0NjQxYWY0ZjdkZTQ=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-11-21T18:40:27Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-11-21T18:50:40Z"}, "message": "Applied suggestions from code review.", "tree": {"sha": "af785d225e9e95ac173a332cbac7807fcb6821c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af785d225e9e95ac173a332cbac7807fcb6821c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b2de17647c46dddf590bd6735344641af4f7de4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b2de17647c46dddf590bd6735344641af4f7de4", "html_url": "https://github.com/rust-lang/rust/commit/1b2de17647c46dddf590bd6735344641af4f7de4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b2de17647c46dddf590bd6735344641af4f7de4/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51cb60cd3fc42b3b6a35e48cbc19426c332c260e", "url": "https://api.github.com/repos/rust-lang/rust/commits/51cb60cd3fc42b3b6a35e48cbc19426c332c260e", "html_url": "https://github.com/rust-lang/rust/commit/51cb60cd3fc42b3b6a35e48cbc19426c332c260e"}], "stats": {"total": 189, "additions": 95, "deletions": 94}, "files": [{"sha": "479bffc3ea00d6f0a802e7279abdbe105e8b6804", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 64, "deletions": 63, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/1b2de17647c46dddf590bd6735344641af4f7de4/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2de17647c46dddf590bd6735344641af4f7de4/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=1b2de17647c46dddf590bd6735344641af4f7de4", "patch": "@@ -233,44 +233,45 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n }\n \n impl AutoTraitFinder<'tcx> {\n-    // The core logic responsible for computing the bounds for our synthesized impl.\n-    //\n-    // To calculate the bounds, we call `SelectionContext.select` in a loop. Like\n-    // `FulfillmentContext`, we recursively select the nested obligations of predicates we\n-    // encounter. However, whenever we encounter an `UnimplementedError` involving a type parameter,\n-    // we add it to our `ParamEnv`. Since our goal is to determine when a particular type implements\n-    // an auto trait, Unimplemented errors tell us what conditions need to be met.\n-    //\n-    // This method ends up working somewhat similarly to `FulfillmentContext`, but with a few key\n-    // differences. `FulfillmentContext` works under the assumption that it's dealing with concrete\n-    // user code. According, it considers all possible ways that a `Predicate` could be met, which\n-    // isn't always what we want for a synthesized impl. For example, given the predicate `T:\n-    // Iterator`, `FulfillmentContext` can end up reporting an Unimplemented error for `T:\n-    // IntoIterator` -- since there's an implementation of `Iterator` where `T: IntoIterator`,\n-    // `FulfillmentContext` will drive `SelectionContext` to consider that impl before giving up. If\n-    // we were to rely on `FulfillmentContext`'s decision, we might end up synthesizing an impl like\n-    // this:\n-    //\n-    //     impl<T> Send for Foo<T> where T: IntoIterator\n-    //\n-    // While it might be technically true that Foo implements Send where `T: IntoIterator`,\n-    // the bound is overly restrictive - it's really only necessary that `T: Iterator`.\n-    //\n-    // For this reason, `evaluate_predicates` handles predicates with type variables specially. When\n-    // we encounter an `Unimplemented` error for a bound such as `T: Iterator`, we immediately add\n-    // it to our `ParamEnv`, and add it to our stack for recursive evaluation. When we later select\n-    // it, we'll pick up any nested bounds, without ever inferring that `T: IntoIterator` needs to\n-    // hold.\n-    //\n-    // One additional consideration is supertrait bounds. Normally, a `ParamEnv` is only ever\n-    // constructed once for a given type. As part of the construction process, the `ParamEnv` will\n-    // have any supertrait bounds normalized -- e.g., if we have a type `struct Foo<T: Copy>`, the\n-    // `ParamEnv` will contain `T: Copy` and `T: Clone`, since `Copy: Clone`. When we construct our\n-    // own `ParamEnv`, we need to do this ourselves, through `traits::elaborate_predicates`, or else\n-    // `SelectionContext` will choke on the missing predicates. However, this should never show up\n-    // in the final synthesized generics: we don't want our generated docs page to contain something\n-    // like `T: Copy + Clone`, as that's redundant. Therefore, we keep track of a separate\n-    // `user_env`, which only holds the predicates that will actually be displayed to the user.\n+    /// The core logic responsible for computing the bounds for our synthesized impl.\n+    ///\n+    /// To calculate the bounds, we call `SelectionContext.select` in a loop. Like\n+    /// `FulfillmentContext`, we recursively select the nested obligations of predicates we\n+    /// encounter. However, whenever we encounter an `UnimplementedError` involving a type\n+    /// parameter, we add it to our `ParamEnv`. Since our goal is to determine when a particular\n+    /// type implements an auto trait, Unimplemented errors tell us what conditions need to be met.\n+    ///\n+    /// This method ends up working somewhat similarly to `FulfillmentContext`, but with a few key\n+    /// differences. `FulfillmentContext` works under the assumption that it's dealing with concrete\n+    /// user code. According, it considers all possible ways that a `Predicate` could be met, which\n+    /// isn't always what we want for a synthesized impl. For example, given the predicate `T:\n+    /// Iterator`, `FulfillmentContext` can end up reporting an Unimplemented error for `T:\n+    /// IntoIterator` -- since there's an implementation of `Iterator` where `T: IntoIterator`,\n+    /// `FulfillmentContext` will drive `SelectionContext` to consider that impl before giving up.\n+    /// If we were to rely on `FulfillmentContext`s decision, we might end up synthesizing an impl\n+    /// like this:\n+    ///\n+    ///     impl<T> Send for Foo<T> where T: IntoIterator\n+    ///\n+    /// While it might be technically true that Foo implements Send where `T: IntoIterator`,\n+    /// the bound is overly restrictive - it's really only necessary that `T: Iterator`.\n+    ///\n+    /// For this reason, `evaluate_predicates` handles predicates with type variables specially.\n+    /// When we encounter an `Unimplemented` error for a bound such as `T: Iterator`, we immediately\n+    /// add it to our `ParamEnv`, and add it to our stack for recursive evaluation. When we later\n+    /// select it, we'll pick up any nested bounds, without ever inferring that `T: IntoIterator`\n+    /// needs to hold.\n+    ///\n+    /// One additional consideration is supertrait bounds. Normally, a `ParamEnv` is only ever\n+    /// constructed once for a given type. As part of the construction process, the `ParamEnv` will\n+    /// have any supertrait bounds normalized -- e.g., if we have a type `struct Foo<T: Copy>`, the\n+    /// `ParamEnv` will contain `T: Copy` and `T: Clone`, since `Copy: Clone`. When we construct our\n+    /// own `ParamEnv`, we need to do this ourselves, through `traits::elaborate_predicates`, or\n+    /// else `SelectionContext` will choke on the missing predicates. However, this should never\n+    /// show up in the final synthesized generics: we don't want our generated docs page to contain\n+    /// something like `T: Copy + Clone`, as that's redundant. Therefore, we keep track of a\n+    /// separate `user_env`, which only holds the predicates that will actually be displayed to the\n+    /// user.\n     fn evaluate_predicates(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n@@ -393,29 +394,29 @@ impl AutoTraitFinder<'tcx> {\n         return Some((new_env, final_user_env));\n     }\n \n-    // This method is designed to work around the following issue:\n-    // When we compute auto trait bounds, we repeatedly call `SelectionContext.select`,\n-    // progressively building a `ParamEnv` based on the results we get.\n-    // However, our usage of `SelectionContext` differs from its normal use within the compiler,\n-    // in that we capture and re-reprocess predicates from `Unimplemented` errors.\n-    //\n-    // This can lead to a corner case when dealing with region parameters.\n-    // During our selection loop in `evaluate_predicates`, we might end up with\n-    // two trait predicates that differ only in their region parameters:\n-    // one containing a HRTB lifetime parameter, and one containing a 'normal'\n-    // lifetime parameter. For example:\n-    //\n-    //     T as MyTrait<'a>\n-    //     T as MyTrait<'static>\n-    //\n-    // If we put both of these predicates in our computed `ParamEnv`, we'll\n-    // confuse `SelectionContext`, since it will (correctly) view both as being applicable.\n-    //\n-    // To solve this, we pick the 'more strict' lifetime bound -- i.e., the HRTB\n-    // Our end goal is to generate a user-visible description of the conditions\n-    // under which a type implements an auto trait. A trait predicate involving\n-    // a HRTB means that the type needs to work with any choice of lifetime,\n-    // not just one specific lifetime (e.g., `'static`).\n+    /// This method is designed to work around the following issue:\n+    /// When we compute auto trait bounds, we repeatedly call `SelectionContext.select`,\n+    /// progressively building a `ParamEnv` based on the results we get.\n+    /// However, our usage of `SelectionContext` differs from its normal use within the compiler,\n+    /// in that we capture and re-reprocess predicates from `Unimplemented` errors.\n+    ///\n+    /// This can lead to a corner case when dealing with region parameters.\n+    /// During our selection loop in `evaluate_predicates`, we might end up with\n+    /// two trait predicates that differ only in their region parameters:\n+    /// one containing a HRTB lifetime parameter, and one containing a 'normal'\n+    /// lifetime parameter. For example:\n+    ///\n+    ///     T as MyTrait<'a>\n+    ///     T as MyTrait<'static>\n+    ///\n+    /// If we put both of these predicates in our computed `ParamEnv`, we'll\n+    /// confuse `SelectionContext`, since it will (correctly) view both as being applicable.\n+    ///\n+    /// To solve this, we pick the 'more strict' lifetime bound -- i.e., the HRTB\n+    /// Our end goal is to generate a user-visible description of the conditions\n+    /// under which a type implements an auto trait. A trait predicate involving\n+    /// a HRTB means that the type needs to work with any choice of lifetime,\n+    /// not just one specific lifetime (e.g., `'static`).\n     fn add_user_pred<'c>(\n         &self,\n         user_computed_preds: &mut FxHashSet<ty::Predicate<'c>>,\n@@ -506,8 +507,8 @@ impl AutoTraitFinder<'tcx> {\n         }\n     }\n \n-    // This is very similar to `handle_lifetimes`. However, instead of matching `ty::Region`'s\n-    // to each other, we match `ty::RegionVid`'s to `ty::Region`'s.\n+    /// This is very similar to `handle_lifetimes`. However, instead of matching `ty::Region`s\n+    /// to each other, we match `ty::RegionVid`s to `ty::Region`s.\n     fn map_vid_to_region<'cx>(\n         &self,\n         regions: &RegionConstraintData<'cx>,"}, {"sha": "d94e004db29789ae02a6b1c56d72e688ced9ba60", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b2de17647c46dddf590bd6735344641af4f7de4/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2de17647c46dddf590bd6735344641af4f7de4/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=1b2de17647c46dddf590bd6735344641af4f7de4", "patch": "@@ -191,7 +191,7 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Obligation incurred due to a coercion.\n     Coercion { source: Ty<'tcx>, target: Ty<'tcx> },\n \n-    // Various cases where expressions must be `Sized` / `Copy` / etc.\n+    /// Various cases where expressions must be `Sized` / `Copy` / etc.\n     /// `L = X` implies that `L` is `Sized`.\n     AssignmentLhsSized,\n     /// `(x1, .., xn)` must be `Sized`."}, {"sha": "283fa56d11f4f05a805ded364d7f7362c91b3bf1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b2de17647c46dddf590bd6735344641af4f7de4/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2de17647c46dddf590bd6735344641af4f7de4/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1b2de17647c46dddf590bd6735344641af4f7de4", "patch": "@@ -1198,26 +1198,26 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .insert(trait_ref, WithDepNode::new(dep_node, result));\n     }\n \n-    // For various reasons, it's possible for a subobligation\n-    // to have a *lower* recursion_depth than the obligation used to create it.\n-    // Projection sub-obligations may be returned from the projection cache,\n-    // which results in obligations with an 'old' `recursion_depth`.\n-    // Additionally, methods like `ty::wf::obligations` and\n-    // `InferCtxt.subtype_predicate` produce subobligations without\n-    // taking in a 'parent' depth, causing the generated subobligations\n-    // to have a `recursion_depth` of `0`.\n-    //\n-    // To ensure that obligation_depth never decreasees, we force all subobligations\n-    // to have at least the depth of the original obligation.\n+    /// For various reasons, it's possible for a subobligation\n+    /// to have a *lower* recursion_depth than the obligation used to create it.\n+    /// Projection sub-obligations may be returned from the projection cache,\n+    /// which results in obligations with an 'old' `recursion_depth`.\n+    /// Additionally, methods like `ty::wf::obligations` and\n+    /// `InferCtxt.subtype_predicate` produce subobligations without\n+    /// taking in a 'parent' depth, causing the generated subobligations\n+    /// to have a `recursion_depth` of `0`.\n+    ///\n+    /// To ensure that obligation_depth never decreasees, we force all subobligations\n+    /// to have at least the depth of the original obligation.\n     fn add_depth<T: 'cx, I: Iterator<Item = &'cx mut Obligation<'tcx, T>>>(&self, it: I,\n                                                                            min_depth: usize) {\n         it.for_each(|o| o.recursion_depth = cmp::max(min_depth, o.recursion_depth) + 1);\n     }\n \n-    // Checks that the recursion limit has not been exceeded.\n-    //\n-    // The weird return type of this function allows it to be used with the `try` (`?`)\n-    // operator within certain functions.\n+    /// Checks that the recursion limit has not been exceeded.\n+    ///\n+    /// The weird return type of this function allows it to be used with the `try` (`?`)\n+    /// operator within certain functions.\n     fn check_recursion_limit<T: Display + TypeFoldable<'tcx>, V: Display + TypeFoldable<'tcx>>(\n         &self,\n         obligation: &Obligation<'tcx, T>,"}, {"sha": "2e16ae4c73f88283ee492ecfbe8ce65e40d9048b", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b2de17647c46dddf590bd6735344641af4f7de4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2de17647c46dddf590bd6735344641af4f7de4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=1b2de17647c46dddf590bd6735344641af4f7de4", "patch": "@@ -91,19 +91,19 @@ pub const NO_SCOPE_METADATA: Option<&DIScope> = None;\n #[derive(Copy, Debug, Hash, Eq, PartialEq, Clone)]\n pub struct UniqueTypeId(ast::Name);\n \n-// The `TypeMap` is where the `CrateDebugContext` holds the type metadata nodes\n-// created so far. The metadata nodes are indexed by `UniqueTypeId`, and, for\n-// faster lookup, also by `Ty`. The `TypeMap` is responsible for creating\n-// `UniqueTypeId`s.\n+/// The `TypeMap` is where the `CrateDebugContext` holds the type metadata nodes\n+/// created so far. The metadata nodes are indexed by `UniqueTypeId`, and, for\n+/// faster lookup, also by `Ty`. The `TypeMap` is responsible for creating\n+/// `UniqueTypeId`s.\n #[derive(Default)]\n pub struct TypeMap<'ll, 'tcx> {\n-    // The `UniqueTypeId`s created so far.\n+    /// The `UniqueTypeId`s created so far.\n     unique_id_interner: Interner,\n-    // A map from `UniqueTypeId` to debuginfo metadata for that type. This is a 1:1 mapping.\n+    /// A map from `UniqueTypeId` to debuginfo metadata for that type. This is a 1:1 mapping.\n     unique_id_to_metadata: FxHashMap<UniqueTypeId, &'ll DIType>,\n-    // A map from types to debuginfo metadata. This is an N:1 mapping.\n+    /// A map from types to debuginfo metadata. This is an N:1 mapping.\n     type_to_metadata: FxHashMap<Ty<'tcx>, &'ll DIType>,\n-    // A map from types to `UniqueTypeId`. This is an N:1 mapping.\n+    /// A map from types to `UniqueTypeId`. This is an N:1 mapping.\n     type_to_unique_id: FxHashMap<Ty<'tcx>, UniqueTypeId>\n }\n \n@@ -203,9 +203,9 @@ impl TypeMap<'ll, 'tcx> {\n         return UniqueTypeId(key);\n     }\n \n-    // Get the `UniqueTypeId` for an enum variant. Enum variants are not really\n-    // types of their own, so they need special handling. We still need a\n-    // UniqueTypeId for them, since to debuginfo they *are* real types.\n+    /// Gets the `UniqueTypeId` for an enum variant. Enum variants are not really\n+    /// types of their own, so they need special handling. We still need a\n+    /// `UniqueTypeId` for them, since to debuginfo they *are* real types.\n     fn get_unique_type_id_of_enum_variant<'a>(&mut self,\n                                               cx: &CodegenCx<'a, 'tcx>,\n                                               enum_type: Ty<'tcx>,\n@@ -219,9 +219,9 @@ impl TypeMap<'ll, 'tcx> {\n         UniqueTypeId(interner_key)\n     }\n \n-    // Get the unique type ID string for an enum variant part.\n-    // Variant parts are not types and shouldn't really have their own ID,\n-    // but it makes `set_members_of_composite_type()` simpler.\n+    /// Gets the unique type ID string for an enum variant part.\n+    /// Variant parts are not types and shouldn't really have their own ID,\n+    /// but it makes `set_members_of_composite_type()` simpler.\n     fn get_unique_type_id_str_of_enum_variant_part(&mut self, enum_type_id: UniqueTypeId) -> &str {\n         let variant_part_type_id = format!(\"{}_variant_part\",\n                                            self.get_unique_type_id_as_string(enum_type_id));\n@@ -1027,7 +1027,7 @@ impl MetadataCreationResult<'ll> {\n     }\n }\n \n-// Description of a type member, which can either be a regular field (as in\n+/// Description of a type member, which can either be a regular field (as in\n /// structs or tuples) or an enum variant.\n #[derive(Debug)]\n struct MemberDescription<'ll> {"}]}