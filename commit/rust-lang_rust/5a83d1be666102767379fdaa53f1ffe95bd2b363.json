{"sha": "5a83d1be666102767379fdaa53f1ffe95bd2b363", "node_id": "C_kwDOAAsO6NoAKDVhODNkMWJlNjY2MTAyNzY3Mzc5ZmRhYTUzZjFmZmU5NWJkMmIzNjM", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-23T17:08:42Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-23T17:44:31Z"}, "message": "internal: replace L_DOLLAR/R_DOLLAR with parenthesis hack\n\nThe general problem we are dealing with here is this:\n\n```\nmacro_rules! thrice {\n    ($e:expr) => { $e * 3}\n}\n\nfn main() {\n    let x = thrice!(1 + 2);\n}\n```\n\nwe really want this to print 9 rather than 7.\n\nThe way rustc solves this is rather ad-hoc. In rustc, token trees are\nallowed to include whole AST fragments, so 1+2 is passed through macro\nexpansion as a single unit. This is a significant violation of token\ntree model.\n\nIn rust-analyzer, we intended to handle this in a more elegant way,\nusing token trees with \"invisible\" delimiters. The idea was is that we\nintroduce a new kind of parenthesis, \"left $\"/\"right $\", and let the\nparser intelligently handle this.\n\nThe idea was inspired by the relevant comment in the proc_macro crate:\n\nhttps://doc.rust-lang.org/stable/proc_macro/enum.Delimiter.html#variant.None\n\n> An implicit delimiter, that may, for example, appear around tokens\n> coming from a \u201cmacro variable\u201d $var. It is important to preserve\n> operator priorities in cases like $var * 3 where $var is 1 + 2.\n> Implicit delimiters might not survive roundtrip of a token stream\n> through a string.\n\nNow that we are older and wiser, we conclude that the idea doesn't work.\n\n_First_, the comment in the proc-macro crate is wishful thinking. Rustc\ncurrently completely ignores none delimiters. It solves the (1 + 2) * 3\nproblem by having magical token trees which can't be duplicated:\n\n* https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frust-analyzer/topic/TIL.20that.20token.20streams.20are.20magic\n* https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Handling.20of.20Delimiter.3A.3ANone.20by.20the.20parser\n\n_Second_, it's not like our implementation in rust-analyzer works. We\nspecial-case expressions (as opposed to treating all kinds of $var\ncaptures the same) and we don't know how parser error recovery should\nwork with these dollar-parenthesis.\n\nSo, in this PR we simplify the whole thing away by not pretending that\nwe are doing something proper and instead just explicitly special-casing\nexpressions by wrapping them into real `()`.\n\nIn the future, to maintain bug-parity with `rustc` what we are going to\ndo is probably adding an explicit `CAPTURED_EXPR` *token* which we can\nexplicitly account for in the parser.\n\nIf/when rustc starts handling delimiter=none properly, we'll port that\nlogic as well, in addition to special handling.", "tree": {"sha": "2981e2699538bf847b73ac7ed1a69a8db3ff2df6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2981e2699538bf847b73ac7ed1a69a8db3ff2df6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a83d1be666102767379fdaa53f1ffe95bd2b363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a83d1be666102767379fdaa53f1ffe95bd2b363", "html_url": "https://github.com/rust-lang/rust/commit/5a83d1be666102767379fdaa53f1ffe95bd2b363", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a83d1be666102767379fdaa53f1ffe95bd2b363/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d33d05d85456c855b88a8bdf4ab44d97e32bd4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d33d05d85456c855b88a8bdf4ab44d97e32bd4a", "html_url": "https://github.com/rust-lang/rust/commit/9d33d05d85456c855b88a8bdf4ab44d97e32bd4a"}], "stats": {"total": 295, "additions": 165, "deletions": 130}, "files": [{"sha": "953750d36052cf9710dda36b7ed25dc6a416c05a", "filename": "crates/hir_def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=5a83d1be666102767379fdaa53f1ffe95bd2b363", "patch": "@@ -317,32 +317,35 @@ macro_rules! m {\n     ($ i:expr) => { fn bar() { $ i * 3; } }\n }\n fn bar() {\n-    1+2*3;\n+    (1+2)*3;\n }\n-// MACRO_ITEMS@0..15\n-//   FN@0..15\n+// MACRO_ITEMS@0..17\n+//   FN@0..17\n //     FN_KW@0..2 \"fn\"\n //     NAME@2..5\n //       IDENT@2..5 \"bar\"\n //     PARAM_LIST@5..7\n //       L_PAREN@5..6 \"(\"\n //       R_PAREN@6..7 \")\"\n-//     BLOCK_EXPR@7..15\n-//       STMT_LIST@7..15\n+//     BLOCK_EXPR@7..17\n+//       STMT_LIST@7..17\n //         L_CURLY@7..8 \"{\"\n-//         EXPR_STMT@8..14\n-//           BIN_EXPR@8..13\n-//             BIN_EXPR@8..11\n-//               LITERAL@8..9\n-//                 INT_NUMBER@8..9 \"1\"\n-//               PLUS@9..10 \"+\"\n-//               LITERAL@10..11\n-//                 INT_NUMBER@10..11 \"2\"\n-//             STAR@11..12 \"*\"\n-//             LITERAL@12..13\n-//               INT_NUMBER@12..13 \"3\"\n-//           SEMICOLON@13..14 \";\"\n-//         R_CURLY@14..15 \"}\"\n+//         EXPR_STMT@8..16\n+//           BIN_EXPR@8..15\n+//             PAREN_EXPR@8..13\n+//               L_PAREN@8..9 \"(\"\n+//               BIN_EXPR@9..12\n+//                 LITERAL@9..10\n+//                   INT_NUMBER@9..10 \"1\"\n+//                 PLUS@10..11 \"+\"\n+//                 LITERAL@11..12\n+//                   INT_NUMBER@11..12 \"2\"\n+//               R_PAREN@12..13 \")\"\n+//             STAR@13..14 \"*\"\n+//             LITERAL@14..15\n+//               INT_NUMBER@14..15 \"3\"\n+//           SEMICOLON@15..16 \";\"\n+//         R_CURLY@16..17 \"}\"\n \n \"#]],\n     )\n@@ -722,7 +725,7 @@ macro_rules! m {\n }\n \n fn bar() {\n-    2+2*baz(3).quux();\n+    (2+2*baz(3).quux());\n }\n \"#]],\n     )\n@@ -1370,42 +1373,48 @@ macro_rules! m {\n }\n /* parse error: expected identifier */\n /* parse error: expected SEMICOLON */\n+/* parse error: expected SEMICOLON */\n+/* parse error: expected expression */\n fn f() {\n-    K::C(\"0\");\n+    K::(C(\"0\"));\n }\n-// MACRO_ITEMS@0..17\n-//   FN@0..17\n+// MACRO_ITEMS@0..19\n+//   FN@0..19\n //     FN_KW@0..2 \"fn\"\n //     NAME@2..3\n //       IDENT@2..3 \"f\"\n //     PARAM_LIST@3..5\n //       L_PAREN@3..4 \"(\"\n //       R_PAREN@4..5 \")\"\n-//     BLOCK_EXPR@5..17\n-//       STMT_LIST@5..17\n+//     BLOCK_EXPR@5..19\n+//       STMT_LIST@5..19\n //         L_CURLY@5..6 \"{\"\n-//         EXPR_STMT@6..9\n-//           PATH_EXPR@6..9\n-//             PATH@6..9\n+//         EXPR_STMT@6..10\n+//           PATH_EXPR@6..10\n+//             PATH@6..10\n //               PATH@6..7\n //                 PATH_SEGMENT@6..7\n //                   NAME_REF@6..7\n //                     IDENT@6..7 \"K\"\n //               COLON2@7..9 \"::\"\n-//         EXPR_STMT@9..16\n-//           CALL_EXPR@9..15\n-//             PATH_EXPR@9..10\n-//               PATH@9..10\n-//                 PATH_SEGMENT@9..10\n-//                   NAME_REF@9..10\n-//                     IDENT@9..10 \"C\"\n-//             ARG_LIST@10..15\n-//               L_PAREN@10..11 \"(\"\n-//               LITERAL@11..14\n-//                 STRING@11..14 \"\\\"0\\\"\"\n-//               R_PAREN@14..15 \")\"\n-//           SEMICOLON@15..16 \";\"\n-//         R_CURLY@16..17 \"}\"\n+//               ERROR@9..10\n+//                 L_PAREN@9..10 \"(\"\n+//         EXPR_STMT@10..16\n+//           CALL_EXPR@10..16\n+//             PATH_EXPR@10..11\n+//               PATH@10..11\n+//                 PATH_SEGMENT@10..11\n+//                   NAME_REF@10..11\n+//                     IDENT@10..11 \"C\"\n+//             ARG_LIST@11..16\n+//               L_PAREN@11..12 \"(\"\n+//               LITERAL@12..15\n+//                 STRING@12..15 \"\\\"0\\\"\"\n+//               R_PAREN@15..16 \")\"\n+//         ERROR@16..17\n+//           R_PAREN@16..17 \")\"\n+//         SEMICOLON@17..18 \";\"\n+//         R_CURLY@18..19 \"}\"\n \n \"#]],\n     );\n@@ -1441,7 +1450,7 @@ fn f() {\n         expect![[r#\"\n macro_rules! m { ($expr:expr) => { map($expr) } }\n fn f() {\n-    let _ = map(x+foo);\n+    let _ = map((x+foo));\n }\n \"#]],\n     )"}, {"sha": "2dff4adf2ee804b538fe612a4cee8af4570705ae", "filename": "crates/hir_def/src/macro_expansion_tests/mbe/regression.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs?ref=5a83d1be666102767379fdaa53f1ffe95bd2b363", "patch": "@@ -825,15 +825,18 @@ macro_rules! rgb_color {\n     };\n }\n /* parse error: expected type */\n+/* parse error: expected R_PAREN */\n /* parse error: expected R_ANGLE */\n /* parse error: expected COMMA */\n /* parse error: expected R_ANGLE */\n /* parse error: expected SEMICOLON */\n+/* parse error: expected SEMICOLON */\n+/* parse error: expected expression */\n pub fn new() {\n-    let _ = 0as u32<<8+8;\n+    let _ = 0as u32<<(8+8);\n }\n-// MACRO_ITEMS@0..29\n-//   FN@0..29\n+// MACRO_ITEMS@0..31\n+//   FN@0..31\n //     VISIBILITY@0..3\n //       PUB_KW@0..3 \"pub\"\n //     FN_KW@3..5 \"fn\"\n@@ -842,39 +845,45 @@ pub fn new() {\n //     PARAM_LIST@8..10\n //       L_PAREN@8..9 \"(\"\n //       R_PAREN@9..10 \")\"\n-//     BLOCK_EXPR@10..29\n-//       STMT_LIST@10..29\n+//     BLOCK_EXPR@10..31\n+//       STMT_LIST@10..31\n //         L_CURLY@10..11 \"{\"\n-//         LET_STMT@11..24\n+//         LET_STMT@11..27\n //           LET_KW@11..14 \"let\"\n //           WILDCARD_PAT@14..15\n //             UNDERSCORE@14..15 \"_\"\n //           EQ@15..16 \"=\"\n-//           CAST_EXPR@16..24\n+//           CAST_EXPR@16..27\n //             LITERAL@16..17\n //               INT_NUMBER@16..17 \"0\"\n //             AS_KW@17..19 \"as\"\n-//             PATH_TYPE@19..24\n-//               PATH@19..24\n-//                 PATH_SEGMENT@19..24\n+//             PATH_TYPE@19..27\n+//               PATH@19..27\n+//                 PATH_SEGMENT@19..27\n //                   NAME_REF@19..22\n //                     IDENT@19..22 \"u32\"\n-//                   GENERIC_ARG_LIST@22..24\n+//                   GENERIC_ARG_LIST@22..27\n //                     L_ANGLE@22..23 \"<\"\n-//                     TYPE_ARG@23..24\n-//                       PATH_TYPE@23..24\n-//                         PATH@23..24\n-//                           PATH_SEGMENT@23..24\n-//                             L_ANGLE@23..24 \"<\"\n-//         EXPR_STMT@24..28\n-//           BIN_EXPR@24..27\n-//             LITERAL@24..25\n-//               INT_NUMBER@24..25 \"8\"\n-//             PLUS@25..26 \"+\"\n-//             LITERAL@26..27\n-//               INT_NUMBER@26..27 \"8\"\n-//           SEMICOLON@27..28 \";\"\n-//         R_CURLY@28..29 \"}\"\n+//                     TYPE_ARG@23..27\n+//                       DYN_TRAIT_TYPE@23..27\n+//                         TYPE_BOUND_LIST@23..27\n+//                           TYPE_BOUND@23..26\n+//                             PATH_TYPE@23..26\n+//                               PATH@23..26\n+//                                 PATH_SEGMENT@23..26\n+//                                   L_ANGLE@23..24 \"<\"\n+//                                   PAREN_TYPE@24..26\n+//                                     L_PAREN@24..25 \"(\"\n+//                                     ERROR@25..26\n+//                                       INT_NUMBER@25..26 \"8\"\n+//                           PLUS@26..27 \"+\"\n+//         EXPR_STMT@27..28\n+//           LITERAL@27..28\n+//             INT_NUMBER@27..28 \"8\"\n+//         ERROR@28..29\n+//           R_PAREN@28..29 \")\"\n+//         SEMICOLON@29..30 \";\"\n+//         R_CURLY@30..31 \"}\"\n \n \"#]],\n     );"}, {"sha": "1e1bfa55055831a2fa2b8cb9affaa2c2f3e5a06e", "filename": "crates/mbe/src/expander.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fmbe%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fmbe%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander.rs?ref=5a83d1be666102767379fdaa53f1ffe95bd2b363", "patch": "@@ -110,7 +110,12 @@ enum Binding {\n enum Fragment {\n     /// token fragments are just copy-pasted into the output\n     Tokens(tt::TokenTree),\n-    /// Ast fragments are inserted with fake delimiters, so as to make things\n-    /// like `$i * 2` where `$i = 1 + 1` work as expectd.\n-    Ast(tt::TokenTree),\n+    /// Expr ast fragments are surrounded with `()` on insertion to preserve\n+    /// precedence. Note that this impl is different from the one currently in\n+    /// `rustc` -- `rustc` doesn't translate fragments into token trees at all.\n+    ///\n+    /// At one point in time, we tried to to use \"fake\" delimiters here a-la\n+    /// proc-macro delimiter=none. As we later discovered, \"none\" delimiters are\n+    /// tricky to handle in the parser, and rustc doesn't handle those either.\n+    Expr(tt::TokenTree),\n }"}, {"sha": "b2d3f038f544a558d04d239a88cd1a7886fac6b0", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=5a83d1be666102767379fdaa53f1ffe95bd2b363", "patch": "@@ -736,7 +736,7 @@ fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragmen\n         }\n     };\n     let result = input.expect_fragment(fragment);\n-    result.map(|tt| if kind == \"expr\" { tt.map(Fragment::Ast) } else { tt.map(Fragment::Tokens) })\n+    result.map(|tt| if kind == \"expr\" { tt.map(Fragment::Expr) } else { tt.map(Fragment::Tokens) })\n }\n \n fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &MetaTemplate) {"}, {"sha": "0db17fea6e4e2d9f59b430387130b30151d50823", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=5a83d1be666102767379fdaa53f1ffe95bd2b363", "patch": "@@ -238,7 +238,16 @@ fn expand_repeat(\n fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {\n     match fragment {\n         Fragment::Tokens(tt::TokenTree::Subtree(tt)) => push_subtree(buf, tt),\n-        Fragment::Tokens(tt) | Fragment::Ast(tt) => buf.push(tt),\n+        Fragment::Expr(tt::TokenTree::Subtree(mut tt)) => {\n+            if tt.delimiter.is_none() {\n+                tt.delimiter = Some(tt::Delimiter {\n+                    id: tt::TokenId::unspecified(),\n+                    kind: tt::DelimiterKind::Parenthesis,\n+                })\n+            }\n+            buf.push(tt.into())\n+        }\n+        Fragment::Tokens(tt) | Fragment::Expr(tt) => buf.push(tt),\n     }\n }\n "}, {"sha": "6bdd787e301adca61bf26bc0e1f3cc06f77707d2", "filename": "crates/mbe/src/subtree_source.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs?ref=5a83d1be666102767379fdaa53f1ffe95bd2b363", "patch": "@@ -52,17 +52,20 @@ impl<'a> SubtreeTokenSource {\n                     cursor.bump()\n                 }\n                 Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) => {\n-                    cached.push(convert_delim(subtree.delimiter_kind(), false));\n+                    if let Some(d) = subtree.delimiter_kind() {\n+                        cached.push(convert_delim(d, false));\n+                    }\n                     cursor.subtree().unwrap()\n                 }\n-                None => {\n-                    if let Some(subtree) = cursor.end() {\n-                        cached.push(convert_delim(subtree.delimiter_kind(), true));\n+                None => match cursor.end() {\n+                    Some(subtree) => {\n+                        if let Some(d) = subtree.delimiter_kind() {\n+                            cached.push(convert_delim(d, true));\n+                        }\n                         cursor.bump()\n-                    } else {\n-                        continue;\n                     }\n-                }\n+                    None => continue,\n+                },\n             };\n         }\n \n@@ -109,17 +112,16 @@ impl<'a> TokenSource for SubtreeTokenSource {\n     }\n }\n \n-fn convert_delim(d: Option<tt::DelimiterKind>, closing: bool) -> TtToken {\n+fn convert_delim(d: tt::DelimiterKind, closing: bool) -> TtToken {\n     let (kinds, texts) = match d {\n-        Some(tt::DelimiterKind::Parenthesis) => ([T!['('], T![')']], \"()\"),\n-        Some(tt::DelimiterKind::Brace) => ([T!['{'], T!['}']], \"{}\"),\n-        Some(tt::DelimiterKind::Bracket) => ([T!['['], T![']']], \"[]\"),\n-        None => ([L_DOLLAR, R_DOLLAR], \"\"),\n+        tt::DelimiterKind::Parenthesis => ([T!['('], T![')']], \"()\"),\n+        tt::DelimiterKind::Brace => ([T!['{'], T!['}']], \"{}\"),\n+        tt::DelimiterKind::Bracket => ([T!['['], T![']']], \"[]\"),\n     };\n \n     let idx = closing as usize;\n     let kind = kinds[idx];\n-    let text = if !texts.is_empty() { &texts[idx..texts.len() - (1 - idx)] } else { \"\" };\n+    let text = &texts[idx..texts.len() - (1 - idx)];\n     TtToken { tt: Token { kind, is_jointed_to_next: false }, text: SmolStr::new(text) }\n }\n "}, {"sha": "0b65fa171f41137e566d6f546d193b807a34b422", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a83d1be666102767379fdaa53f1ffe95bd2b363/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=5a83d1be666102767379fdaa53f1ffe95bd2b363", "patch": "@@ -632,12 +632,11 @@ impl<'a> TtTreeSink<'a> {\n     }\n }\n \n-fn delim_to_str(d: Option<tt::DelimiterKind>, closing: bool) -> &'static str {\n+fn delim_to_str(d: tt::DelimiterKind, closing: bool) -> &'static str {\n     let texts = match d {\n-        Some(tt::DelimiterKind::Parenthesis) => \"()\",\n-        Some(tt::DelimiterKind::Brace) => \"{}\",\n-        Some(tt::DelimiterKind::Bracket) => \"[]\",\n-        None => return \"\",\n+        tt::DelimiterKind::Parenthesis => \"()\",\n+        tt::DelimiterKind::Brace => \"{}\",\n+        tt::DelimiterKind::Bracket => \"[]\",\n     };\n \n     let idx = closing as usize;\n@@ -646,10 +645,6 @@ fn delim_to_str(d: Option<tt::DelimiterKind>, closing: bool) -> &'static str {\n \n impl<'a> TreeSink for TtTreeSink<'a> {\n     fn token(&mut self, kind: SyntaxKind, mut n_tokens: u8) {\n-        if kind == L_DOLLAR || kind == R_DOLLAR {\n-            self.cursor = self.cursor.bump_subtree();\n-            return;\n-        }\n         if kind == LIFETIME_IDENT {\n             n_tokens = 2;\n         }\n@@ -661,48 +656,54 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n                 break;\n             }\n             last = self.cursor;\n-            let text: &str = match self.cursor.token_tree() {\n-                Some(tt::buffer::TokenTreeRef::Leaf(leaf, _)) => {\n-                    // Mark the range if needed\n-                    let (text, id) = match leaf {\n-                        tt::Leaf::Ident(ident) => (&ident.text, ident.id),\n-                        tt::Leaf::Punct(punct) => {\n-                            assert!(punct.char.is_ascii());\n-                            let char = &(punct.char as u8);\n-                            tmp_str = SmolStr::new_inline(\n-                                std::str::from_utf8(std::slice::from_ref(char)).unwrap(),\n-                            );\n-                            (&tmp_str, punct.id)\n+            let text: &str = loop {\n+                break match self.cursor.token_tree() {\n+                    Some(tt::buffer::TokenTreeRef::Leaf(leaf, _)) => {\n+                        // Mark the range if needed\n+                        let (text, id) = match leaf {\n+                            tt::Leaf::Ident(ident) => (&ident.text, ident.id),\n+                            tt::Leaf::Punct(punct) => {\n+                                assert!(punct.char.is_ascii());\n+                                let char = &(punct.char as u8);\n+                                tmp_str = SmolStr::new_inline(\n+                                    std::str::from_utf8(std::slice::from_ref(char)).unwrap(),\n+                                );\n+                                (&tmp_str, punct.id)\n+                            }\n+                            tt::Leaf::Literal(lit) => (&lit.text, lit.id),\n+                        };\n+                        let range = TextRange::at(self.text_pos, TextSize::of(text.as_str()));\n+                        self.token_map.insert(id, range);\n+                        self.cursor = self.cursor.bump();\n+                        text\n+                    }\n+                    Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) => {\n+                        self.cursor = self.cursor.subtree().unwrap();\n+                        match subtree.delimiter {\n+                            Some(d) => {\n+                                self.open_delims.insert(d.id, self.text_pos);\n+                                delim_to_str(d.kind, false)\n+                            }\n+                            None => continue,\n                         }\n-                        tt::Leaf::Literal(lit) => (&lit.text, lit.id),\n-                    };\n-                    let range = TextRange::at(self.text_pos, TextSize::of(text.as_str()));\n-                    self.token_map.insert(id, range);\n-                    self.cursor = self.cursor.bump();\n-                    text\n-                }\n-                Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) => {\n-                    self.cursor = self.cursor.subtree().unwrap();\n-                    if let Some(id) = subtree.delimiter.map(|it| it.id) {\n-                        self.open_delims.insert(id, self.text_pos);\n                     }\n-                    delim_to_str(subtree.delimiter_kind(), false)\n-                }\n-                None => {\n-                    if let Some(parent) = self.cursor.end() {\n+                    None => {\n+                        let parent = self.cursor.end().unwrap();\n                         self.cursor = self.cursor.bump();\n-                        if let Some(id) = parent.delimiter.map(|it| it.id) {\n-                            if let Some(open_delim) = self.open_delims.get(&id) {\n-                                let open_range = TextRange::at(*open_delim, TextSize::of('('));\n-                                let close_range = TextRange::at(self.text_pos, TextSize::of('('));\n-                                self.token_map.insert_delim(id, open_range, close_range);\n+                        match parent.delimiter {\n+                            Some(d) => {\n+                                if let Some(open_delim) = self.open_delims.get(&d.id) {\n+                                    let open_range = TextRange::at(*open_delim, TextSize::of('('));\n+                                    let close_range =\n+                                        TextRange::at(self.text_pos, TextSize::of('('));\n+                                    self.token_map.insert_delim(d.id, open_range, close_range);\n+                                }\n+                                delim_to_str(d.kind, true)\n                             }\n+                            None => continue,\n                         }\n-                        delim_to_str(parent.delimiter_kind(), true)\n-                    } else {\n-                        continue;\n                     }\n-                }\n+                };\n             };\n             self.buf += text;\n             self.text_pos += TextSize::of(text);"}]}