{"sha": "0c935732bcb7f13a491181e8996be3ec1c2244ac", "node_id": "C_kwDOAAsO6NoAKDBjOTM1NzMyYmNiN2YxM2E0OTExODFlODk5NmJlM2VjMWMyMjQ0YWM", "commit": {"author": {"name": "XFFXFF", "email": "1247714429@qq.com", "date": "2023-03-15T01:06:36Z"}, "committer": {"name": "XFFXFF", "email": "1247714429@qq.com", "date": "2023-03-15T01:12:40Z"}, "message": "do not offer fixit for macro expansions and refactor the code", "tree": {"sha": "2af3bf0452a0b7b15dd877c1808bc06fdf92e399", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2af3bf0452a0b7b15dd877c1808bc06fdf92e399"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c935732bcb7f13a491181e8996be3ec1c2244ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c935732bcb7f13a491181e8996be3ec1c2244ac", "html_url": "https://github.com/rust-lang/rust/commit/0c935732bcb7f13a491181e8996be3ec1c2244ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c935732bcb7f13a491181e8996be3ec1c2244ac/comments", "author": {"login": "xffxff", "id": 30254428, "node_id": "MDQ6VXNlcjMwMjU0NDI4", "avatar_url": "https://avatars.githubusercontent.com/u/30254428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xffxff", "html_url": "https://github.com/xffxff", "followers_url": "https://api.github.com/users/xffxff/followers", "following_url": "https://api.github.com/users/xffxff/following{/other_user}", "gists_url": "https://api.github.com/users/xffxff/gists{/gist_id}", "starred_url": "https://api.github.com/users/xffxff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xffxff/subscriptions", "organizations_url": "https://api.github.com/users/xffxff/orgs", "repos_url": "https://api.github.com/users/xffxff/repos", "events_url": "https://api.github.com/users/xffxff/events{/privacy}", "received_events_url": "https://api.github.com/users/xffxff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xffxff", "id": 30254428, "node_id": "MDQ6VXNlcjMwMjU0NDI4", "avatar_url": "https://avatars.githubusercontent.com/u/30254428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xffxff", "html_url": "https://github.com/xffxff", "followers_url": "https://api.github.com/users/xffxff/followers", "following_url": "https://api.github.com/users/xffxff/following{/other_user}", "gists_url": "https://api.github.com/users/xffxff/gists{/gist_id}", "starred_url": "https://api.github.com/users/xffxff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xffxff/subscriptions", "organizations_url": "https://api.github.com/users/xffxff/orgs", "repos_url": "https://api.github.com/users/xffxff/repos", "events_url": "https://api.github.com/users/xffxff/events{/privacy}", "received_events_url": "https://api.github.com/users/xffxff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf0322cd0c841a31b1ce242333c2d457ab85ee5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf0322cd0c841a31b1ce242333c2d457ab85ee5a", "html_url": "https://github.com/rust-lang/rust/commit/bf0322cd0c841a31b1ce242333c2d457ab85ee5a"}], "stats": {"total": 111, "additions": 55, "deletions": 56}, "files": [{"sha": "eb32db250656c1dac5deb0563d3c7146b9f85d18", "filename": "crates/ide-diagnostics/src/handlers/missing_unsafe.rs", "status": "modified", "additions": 55, "deletions": 56, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/0c935732bcb7f13a491181e8996be3ec1c2244ac/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c935732bcb7f13a491181e8996be3ec1c2244ac/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs?ref=0c935732bcb7f13a491181e8996be3ec1c2244ac", "patch": "@@ -1,7 +1,7 @@\n-use hir::db::AstDatabase;\n+use hir::db::ExpandDatabase;\n use ide_db::{assists::Assist, source_change::SourceChange};\n-use syntax::AstNode;\n use syntax::{ast, SyntaxNode};\n+use syntax::{match_ast, AstNode};\n use text_edit::TextEdit;\n \n use crate::{fix, Diagnostic, DiagnosticsContext};\n@@ -19,10 +19,15 @@ pub(crate) fn missing_unsafe(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsaf\n }\n \n fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsafe) -> Option<Vec<Assist>> {\n+    // The fixit will not work correctly for macro expansions, so we don't offer it in that case.\n+    if d.expr.file_id.is_macro() {\n+        return None;\n+    }\n+\n     let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n     let expr = d.expr.value.to_node(&root);\n \n-    let node_to_add_unsafe_block = pick_best_node_to_add_unsafe_block(&expr);\n+    let node_to_add_unsafe_block = pick_best_node_to_add_unsafe_block(&expr)?;\n \n     let replacement = format!(\"unsafe {{ {} }}\", node_to_add_unsafe_block.text());\n     let edit = TextEdit::replace(node_to_add_unsafe_block.text_range(), replacement);\n@@ -42,72 +47,51 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsafe) -> Option<Vec<Ass\n // - `unsafe_expr += 1` -> `unsafe { unsafe_expr += 1 }`\n // - `&unsafe_expr` -> `unsafe { &unsafe_expr }`\n // - `&&unsafe_expr` -> `unsafe { &&unsafe_expr }`\n-fn pick_best_node_to_add_unsafe_block(unsafe_expr: &ast::Expr) -> SyntaxNode {\n+fn pick_best_node_to_add_unsafe_block(unsafe_expr: &ast::Expr) -> Option<SyntaxNode> {\n     // The `unsafe_expr` might be:\n     // - `ast::CallExpr`: call an unsafe function\n     // - `ast::MethodCallExpr`: call an unsafe method\n     // - `ast::PrefixExpr`: dereference a raw pointer\n     // - `ast::PathExpr`: access a static mut variable\n-    for node in unsafe_expr.syntax().ancestors() {\n-        let Some(parent) = node.parent() else {\n-            return node;\n-        };\n-        match parent.kind() {\n-            syntax::SyntaxKind::METHOD_CALL_EXPR => {\n-                // Check if the `node` is the receiver of the method call\n-                let method_call_expr = ast::MethodCallExpr::cast(parent.clone()).unwrap();\n-                if method_call_expr\n-                    .receiver()\n-                    .map(|receiver| {\n-                        receiver.syntax().text_range().contains_range(node.text_range())\n-                    })\n-                    .unwrap_or(false)\n-                {\n-                    // Actually, I think it's not necessary to check whether the\n-                    // text range of the `node` (which is the ancestor of the\n-                    // `unsafe_expr`) is contained in the text range of the\n-                    // receiver. The `node` could potentially be the receiver, the\n-                    // method name, or the argument list. Since the `node` is the\n-                    // ancestor of the unsafe_expr, it cannot be the method name.\n-                    // Additionally, if the `node` is the argument list, the loop\n-                    // would break at least when `parent` reaches the argument list.\n-                    //\n-                    // Dispite this, I still check the text range because I think it\n-                    // makes the code easier to understand.\n-                    continue;\n-                }\n-                return node;\n-            }\n-            syntax::SyntaxKind::FIELD_EXPR | syntax::SyntaxKind::REF_EXPR => continue,\n-            syntax::SyntaxKind::BIN_EXPR => {\n-                // Check if the `node` is the left-hand side of an assignment\n-                let is_left_hand_side_of_assignment = {\n-                    let bin_expr = ast::BinExpr::cast(parent.clone()).unwrap();\n-                    if let Some(ast::BinaryOp::Assignment { .. }) = bin_expr.op_kind() {\n-                        let is_left_hand_side = bin_expr\n-                            .lhs()\n-                            .map(|lhs| lhs.syntax().text_range().contains_range(node.text_range()))\n-                            .unwrap_or(false);\n-                        is_left_hand_side\n-                    } else {\n-                        false\n+    for (node, parent) in\n+        unsafe_expr.syntax().ancestors().zip(unsafe_expr.syntax().ancestors().skip(1))\n+    {\n+        match_ast! {\n+            match parent {\n+                // If the `parent` is a `MethodCallExpr`, that means the `node`\n+                // is the receiver of the method call, because only the receiver\n+                // can be a direct child of a method call. The method name\n+                // itself is not an expression but a `NameRef`, and an argument\n+                // is a direct child of an `ArgList`.\n+                ast::MethodCallExpr(_) => continue,\n+                ast::FieldExpr(_) => continue,\n+                ast::RefExpr(_) => continue,\n+                ast::BinExpr(it) => {\n+                    // Check if the `node` is the left-hand side of an\n+                    // assignment, if so, we don't want to wrap it in an unsafe\n+                    // block, e.g. `unsafe_expr += 1`\n+                    let is_left_hand_side_of_assignment = {\n+                        if let Some(ast::BinaryOp::Assignment { .. }) = it.op_kind() {\n+                            it.lhs().map(|lhs| lhs.syntax().text_range().contains_range(node.text_range())).unwrap_or(false)\n+                        } else {\n+                            false\n+                        }\n+                    };\n+                    if !is_left_hand_side_of_assignment {\n+                        return Some(node);\n                     }\n-                };\n-                if !is_left_hand_side_of_assignment {\n-                    return node;\n-                }\n-            }\n-            _ => {\n-                return node;\n+                },\n+                _ => { return Some(node); }\n+\n             }\n         }\n     }\n-    unsafe_expr.syntax().clone()\n+    None\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::{check_diagnostics, check_fix};\n+    use crate::tests::{check_diagnostics, check_fix, check_no_fix};\n \n     #[test]\n     fn missing_unsafe_diagnostic_with_raw_ptr() {\n@@ -467,4 +451,19 @@ fn main() {\n \"#,\n         )\n     }\n+\n+    #[test]\n+    fn unsafe_expr_in_macro_call() {\n+        check_no_fix(\n+            r#\"\n+unsafe fn foo() -> u8 {\n+    0\n+}\n+\n+fn main() {\n+    let x = format!(\"foo: {}\", foo$0());\n+}\n+            \"#,\n+        )\n+    }\n }"}]}