{"sha": "31d01efb069065449e53cfd7d0935c4b9fecf1e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZDAxZWZiMDY5MDY1NDQ5ZTUzY2ZkN2QwOTM1YzRiOWZlY2YxZTM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-15T07:45:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-15T07:45:57Z"}, "message": "Merge #2251\n\n2251: Privatize modules r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "00b30d62bb7cb34532fe0dbfe2ba6de64f8fde0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00b30d62bb7cb34532fe0dbfe2ba6de64f8fde0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31d01efb069065449e53cfd7d0935c4b9fecf1e3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdzle1CRBK7hj4Ov3rIwAAdHIIADULcbhB6APefIvFKbuLp5Fh\ndGpkruNuiRncNKuUBcaptAnnu4cYqLMulN2fSsEH/i74vXJ+yRGBIaQdPhE+LAdU\n+CUB6QXN82JeoEliObiqMWXHHEX7VOXIgUXZmSnrCsJQEWJbNwSanzJl6bvvR0VC\nbdg0+e5TGyN1tyuCtIdzlNgFbngSZSsjWloR+iEPhlwsKqfkv5Ei9EYDUNt5axws\nvPaiCUSOFinZ3x/3zRwPmU0G3vkE2QVdkVvJUnBkKvVYdaoCGSs+vTLFEVdz6Z6d\n8O11teuF/qMN4wSthrTa7Do0G7cYF3+VP6F5wSmxPAISKSk6GHgyIEGTDkeQvTE=\n=J+Il\n-----END PGP SIGNATURE-----\n", "payload": "tree 00b30d62bb7cb34532fe0dbfe2ba6de64f8fde0f\nparent 3ad11973ac7596323f085a9fcb9530e47f021c41\nparent a28907af8ca93077601053cf168ac2429855c394\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573803957 +0000\ncommitter GitHub <noreply@github.com> 1573803957 +0000\n\nMerge #2251\n\n2251: Privatize modules r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31d01efb069065449e53cfd7d0935c4b9fecf1e3", "html_url": "https://github.com/rust-lang/rust/commit/31d01efb069065449e53cfd7d0935c4b9fecf1e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31d01efb069065449e53cfd7d0935c4b9fecf1e3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ad11973ac7596323f085a9fcb9530e47f021c41", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ad11973ac7596323f085a9fcb9530e47f021c41", "html_url": "https://github.com/rust-lang/rust/commit/3ad11973ac7596323f085a9fcb9530e47f021c41"}, {"sha": "a28907af8ca93077601053cf168ac2429855c394", "url": "https://api.github.com/repos/rust-lang/rust/commits/a28907af8ca93077601053cf168ac2429855c394", "html_url": "https://github.com/rust-lang/rust/commit/a28907af8ca93077601053cf168ac2429855c394"}], "stats": {"total": 85, "additions": 50, "deletions": 35}, "files": [{"sha": "dd43271f4caff443c0337713b9424d4bc501ef51", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31d01efb069065449e53cfd7d0935c4b9fecf1e3/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31d01efb069065449e53cfd7d0935c4b9fecf1e3/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=31d01efb069065449e53cfd7d0935c4b9fecf1e3", "patch": "@@ -157,7 +157,7 @@ impl Module {\n     }\n \n     /// Finds a child module with the specified name.\n-    pub fn child(self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n+    pub fn child(self, db: &impl DefDatabase, name: &Name) -> Option<Module> {\n         let def_map = db.crate_def_map(self.id.krate);\n         let child_id = def_map[self.id.module_id].children.get(name)?;\n         Some(self.with_module_id(*child_id))"}, {"sha": "7e5523c54a3bd73a8d0b6ccef385a52bd4094124", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/31d01efb069065449e53cfd7d0935c4b9fecf1e3/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31d01efb069065449e53cfd7d0935c4b9fecf1e3/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=31d01efb069065449e53cfd7d0935c4b9fecf1e3", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir_def::{StructId, StructOrUnionId, UnionId};\n+use hir_def::{ModuleId, StructId, StructOrUnionId, UnionId};\n use hir_expand::name::AsName;\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n@@ -10,9 +10,9 @@ use ra_syntax::{\n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     ids::{AstItemDef, LocationCtx},\n-    AstId, Const, Crate, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasBody, HasSource,\n-    ImplBlock, Local, Module, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias,\n-    Union, VariantDef,\n+    Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasBody, HasSource, ImplBlock,\n+    Local, Module, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union,\n+    VariantDef,\n };\n \n pub trait FromSource: Sized {\n@@ -152,44 +152,48 @@ impl Local {\n }\n \n impl Module {\n-    pub fn from_declaration(db: &impl HirDatabase, src: Source<ast::Module>) -> Option<Self> {\n-        let src_parent = Source {\n-            file_id: src.file_id,\n-            ast: ModuleSource::new(db, Some(src.file_id.original_file(db)), None),\n-        };\n-        let parent_module = Module::from_definition(db, src_parent)?;\n+    pub fn from_declaration(db: &impl DefDatabase, src: Source<ast::Module>) -> Option<Self> {\n+        let parent_declaration = src.ast.syntax().ancestors().skip(1).find_map(ast::Module::cast);\n+\n+        let parent_module = match parent_declaration {\n+            Some(parent_declaration) => {\n+                let src_parent = Source { file_id: src.file_id, ast: parent_declaration };\n+                Module::from_declaration(db, src_parent)\n+            }\n+            _ => {\n+                let src_parent = Source {\n+                    file_id: src.file_id,\n+                    ast: ModuleSource::new(db, Some(src.file_id.original_file(db)), None),\n+                };\n+                Module::from_definition(db, src_parent)\n+            }\n+        }?;\n+\n         let child_name = src.ast.name()?;\n         parent_module.child(db, &child_name.as_name())\n     }\n \n-    pub fn from_definition(\n-        db: &(impl DefDatabase + AstDatabase),\n-        src: Source<ModuleSource>,\n-    ) -> Option<Self> {\n-        let decl_id = match src.ast {\n+    pub fn from_definition(db: &impl DefDatabase, src: Source<ModuleSource>) -> Option<Self> {\n+        match src.ast {\n             ModuleSource::Module(ref module) => {\n                 assert!(!module.has_semi());\n-                let ast_id_map = db.ast_id_map(src.file_id);\n-                let item_id = AstId::new(src.file_id, ast_id_map.ast_id(module));\n-                Some(item_id)\n+                return Module::from_declaration(\n+                    db,\n+                    Source { file_id: src.file_id, ast: module.clone() },\n+                );\n             }\n-            ModuleSource::SourceFile(_) => None,\n+            ModuleSource::SourceFile(_) => (),\n         };\n \n-        db.relevant_crates(src.file_id.original_file(db)).iter().find_map(|&crate_id| {\n-            let def_map = db.crate_def_map(crate_id);\n-\n-            let (module_id, _module_data) =\n-                def_map.modules.iter().find(|(_module_id, module_data)| {\n-                    if decl_id.is_some() {\n-                        module_data.declaration == decl_id\n-                    } else {\n-                        module_data.definition.map(|it| it.into()) == Some(src.file_id)\n-                    }\n-                })?;\n+        let original_file = src.file_id.original_file(db);\n \n-            Some(Module::new(Crate { crate_id }, module_id))\n-        })\n+        let (krate, module_id) =\n+            db.relevant_crates(original_file).iter().find_map(|&crate_id| {\n+                let crate_def_map = db.crate_def_map(crate_id);\n+                let local_module_id = crate_def_map.modules_for_file(original_file).next()?;\n+                Some((crate_id, local_module_id))\n+            })?;\n+        Some(Module { id: ModuleId { krate, module_id } })\n     }\n }\n "}, {"sha": "1caa2e8759dc8cb94dad9a6426459aefb08ca0e6", "filename": "crates/ra_hir/src/test_db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31d01efb069065449e53cfd7d0935c4b9fecf1e3/crates%2Fra_hir%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31d01efb069065449e53cfd7d0935c4b9fecf1e3/crates%2Fra_hir%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftest_db.rs?ref=31d01efb069065449e53cfd7d0935c4b9fecf1e3", "patch": "@@ -81,7 +81,7 @@ impl TestDB {\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter().next() {\n             let crate_def_map = self.crate_def_map(krate);\n-            for (module_id, _) in crate_def_map.modules.iter() {\n+            for module_id in crate_def_map.modules() {\n                 let module_id = ModuleId { krate, module_id };\n                 let module = crate::Module::from(module_id);\n                 module.diagnostics("}, {"sha": "5fc592150088aa4beda7b9ab193b0f00bae4a495", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31d01efb069065449e53cfd7d0935c4b9fecf1e3/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31d01efb069065449e53cfd7d0935c4b9fecf1e3/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=31d01efb069065449e53cfd7d0935c4b9fecf1e3", "patch": "@@ -87,7 +87,7 @@ pub struct CrateDefMap {\n     prelude: Option<ModuleId>,\n     extern_prelude: FxHashMap<Name, ModuleDefId>,\n     root: CrateModuleId,\n-    pub modules: Arena<CrateModuleId, ModuleData>,\n+    modules: Arena<CrateModuleId, ModuleData>,\n \n     /// Some macros are not well-behavior, which leads to infinite loop\n     /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n@@ -258,6 +258,17 @@ impl CrateDefMap {\n         let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n         (res.resolved_def, res.segment_index)\n     }\n+\n+    pub fn modules(&self) -> impl Iterator<Item = CrateModuleId> + '_ {\n+        self.modules.iter().map(|(id, _data)| id)\n+    }\n+\n+    pub fn modules_for_file(&self, file_id: FileId) -> impl Iterator<Item = CrateModuleId> + '_ {\n+        self.modules\n+            .iter()\n+            .filter(move |(_id, data)| data.definition == Some(file_id))\n+            .map(|(id, _data)| id)\n+    }\n }\n \n mod diagnostics {"}]}