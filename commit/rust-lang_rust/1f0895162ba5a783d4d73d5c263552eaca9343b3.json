{"sha": "1f0895162ba5a783d4d73d5c263552eaca9343b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmMDg5NTE2MmJhNWE3ODNkNGQ3M2Q1YzI2MzU1MmVhY2E5MzQzYjM=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-06-14T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-06-15T08:02:06Z"}, "message": "Avoid forming references to an uninitialized memory in DroplessArena\n\nReturn a pointer from `alloc_raw` instead of a slice. There is no\npractical use for slice as a return type and changing it to a pointer\navoids forming references to an uninitialized memory.", "tree": {"sha": "661e0fe44d168857edeee089169afa74ae3e3244", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/661e0fe44d168857edeee089169afa74ae3e3244"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f0895162ba5a783d4d73d5c263552eaca9343b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f0895162ba5a783d4d73d5c263552eaca9343b3", "html_url": "https://github.com/rust-lang/rust/commit/1f0895162ba5a783d4d73d5c263552eaca9343b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f0895162ba5a783d4d73d5c263552eaca9343b3/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0c3327ade8b0caa3043425ee45842c86fbd4f76", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c3327ade8b0caa3043425ee45842c86fbd4f76", "html_url": "https://github.com/rust-lang/rust/commit/c0c3327ade8b0caa3043425ee45842c86fbd4f76"}], "stats": {"total": 27, "additions": 12, "deletions": 15}, "files": [{"sha": "4b837a28434e9104e0b8e9a331a27a22828561aa", "filename": "src/librustc_arena/lib.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1f0895162ba5a783d4d73d5c263552eaca9343b3/src%2Flibrustc_arena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0895162ba5a783d4d73d5c263552eaca9343b3/src%2Flibrustc_arena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_arena%2Flib.rs?ref=1f0895162ba5a783d4d73d5c263552eaca9343b3", "patch": "@@ -367,7 +367,7 @@ impl DroplessArena {\n     /// current memory chunk. Returns `None` if there is no free space left to\n     /// satisfy the request.\n     #[inline]\n-    fn alloc_raw_without_grow(&self, bytes: usize, align: usize) -> Option<&mut [u8]> {\n+    fn alloc_raw_without_grow(&self, bytes: usize, align: usize) -> Option<*mut u8> {\n         let ptr = self.ptr.get() as usize;\n         let end = self.end.get() as usize;\n         // The allocation request fits into the current chunk iff:\n@@ -383,14 +383,14 @@ impl DroplessArena {\n         let new_ptr = aligned.checked_add(bytes)?;\n         if new_ptr <= end {\n             self.ptr.set(new_ptr as *mut u8);\n-            unsafe { Some(slice::from_raw_parts_mut(aligned as *mut u8, bytes)) }\n+            Some(aligned as *mut u8)\n         } else {\n             None\n         }\n     }\n \n     #[inline]\n-    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n+    pub fn alloc_raw(&self, bytes: usize, align: usize) -> *mut u8 {\n         assert!(bytes != 0);\n         loop {\n             if let Some(a) = self.alloc_raw_without_grow(bytes, align) {\n@@ -406,7 +406,7 @@ impl DroplessArena {\n     pub fn alloc<T>(&self, object: T) -> &mut T {\n         assert!(!mem::needs_drop::<T>());\n \n-        let mem = self.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut _ as *mut T;\n+        let mem = self.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut T;\n \n         unsafe {\n             // Write into uninitialized memory.\n@@ -431,13 +431,11 @@ impl DroplessArena {\n         assert!(mem::size_of::<T>() != 0);\n         assert!(!slice.is_empty());\n \n-        let mem = self.alloc_raw(slice.len() * mem::size_of::<T>(), mem::align_of::<T>()) as *mut _\n-            as *mut T;\n+        let mem = self.alloc_raw(slice.len() * mem::size_of::<T>(), mem::align_of::<T>()) as *mut T;\n \n         unsafe {\n-            let arena_slice = slice::from_raw_parts_mut(mem, slice.len());\n-            arena_slice.copy_from_slice(slice);\n-            arena_slice\n+            mem.copy_from_nonoverlapping(slice.as_ptr(), slice.len());\n+            slice::from_raw_parts_mut(mem, slice.len())\n         }\n     }\n \n@@ -480,7 +478,7 @@ impl DroplessArena {\n                     return &mut [];\n                 }\n                 let size = len.checked_mul(mem::size_of::<T>()).unwrap();\n-                let mem = self.alloc_raw(size, mem::align_of::<T>()) as *mut _ as *mut T;\n+                let mem = self.alloc_raw(size, mem::align_of::<T>()) as *mut T;\n                 unsafe { self.write_from_iter(iter, len, mem) }\n             }\n             (_, _) => {\n@@ -495,7 +493,7 @@ impl DroplessArena {\n                         let len = vec.len();\n                         let start_ptr = self\n                             .alloc_raw(len * mem::size_of::<T>(), mem::align_of::<T>())\n-                            as *mut _ as *mut T;\n+                            as *mut T;\n                         vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n                         vec.set_len(0);\n                         slice::from_raw_parts_mut(start_ptr, len)\n@@ -539,8 +537,7 @@ pub struct DropArena {\n impl DropArena {\n     #[inline]\n     pub unsafe fn alloc<T>(&self, object: T) -> &mut T {\n-        let mem =\n-            self.arena.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut _ as *mut T;\n+        let mem = self.arena.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut T;\n         // Write into uninitialized memory.\n         ptr::write(mem, object);\n         let result = &mut *mem;\n@@ -563,7 +560,7 @@ impl DropArena {\n         let start_ptr = self\n             .arena\n             .alloc_raw(len.checked_mul(mem::size_of::<T>()).unwrap(), mem::align_of::<T>())\n-            as *mut _ as *mut T;\n+            as *mut T;\n \n         let mut destructors = self.destructors.borrow_mut();\n         // Reserve space for the destructors so we can't panic while adding them"}, {"sha": "76c72e4c2603d53f7d8673b4fe9e73c548351ed9", "filename": "src/librustc_middle/ty/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f0895162ba5a783d4d73d5c263552eaca9343b3/src%2Flibrustc_middle%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0895162ba5a783d4d73d5c263552eaca9343b3/src%2Flibrustc_middle%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flist.rs?ref=1f0895162ba5a783d4d73d5c263552eaca9343b3", "patch": "@@ -55,7 +55,7 @@ impl<T: Copy> List<T> {\n             .dropless\n             .alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n         unsafe {\n-            let result = &mut *(mem.as_mut_ptr() as *mut List<T>);\n+            let result = &mut *(mem as *mut List<T>);\n             // Write the length\n             result.len = slice.len();\n "}]}