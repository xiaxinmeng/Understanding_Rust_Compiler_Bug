{"sha": "8a73f50d875840b8077b8ec080fa41881d7ce40d", "node_id": "C_kwDOAAsO6NoAKDhhNzNmNTBkODc1ODQwYjgwNzdiOGVjMDgwZmE0MTg4MWQ3Y2U0MGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-11T18:15:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-11T18:15:53Z"}, "message": "Auto merge of #109019 - matthiaskrgr:rollup-ihjntil, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #104363 (Make `unused_allocation` lint against `Box::new` too)\n - #106633 (Stabilize `nonzero_min_max`)\n - #106844 (allow negative numeric literals in `concat!`)\n - #108071 (Implement goal caching with the new solver)\n - #108542 (Force parentheses around `match` expression in binary expression)\n - #108690 (Place size limits on query keys and values)\n - #108708 (Prevent overflow through Arc::downgrade)\n - #108739 (Prevent the `start_bx` basic block in codegen from having two `Builder`s at the same time)\n - #108806 (Querify register_tools and post-expansion early lints)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ff0b511068a12ecebbb77b0bbe3aca66c80a6b9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff0b511068a12ecebbb77b0bbe3aca66c80a6b9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a73f50d875840b8077b8ec080fa41881d7ce40d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a73f50d875840b8077b8ec080fa41881d7ce40d", "html_url": "https://github.com/rust-lang/rust/commit/8a73f50d875840b8077b8ec080fa41881d7ce40d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a73f50d875840b8077b8ec080fa41881d7ce40d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67e1681c1db9545ec05c458cad440a9197617a30", "url": "https://api.github.com/repos/rust-lang/rust/commits/67e1681c1db9545ec05c458cad440a9197617a30", "html_url": "https://github.com/rust-lang/rust/commit/67e1681c1db9545ec05c458cad440a9197617a30"}, {"sha": "df50001c7de485b31cc4ea3c5100ac090e470c7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/df50001c7de485b31cc4ea3c5100ac090e470c7c", "html_url": "https://github.com/rust-lang/rust/commit/df50001c7de485b31cc4ea3c5100ac090e470c7c"}], "stats": {"total": 717, "additions": 445, "deletions": 272}, "files": [{"sha": "0862db1c34582e339bc8d8a7c3a26ea9c846e8a6", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -436,6 +436,7 @@ fn compute_hir_hash(\n pub fn lower_to_hir(tcx: TyCtxt<'_>, (): ()) -> hir::Crate<'_> {\n     let sess = tcx.sess;\n     tcx.ensure().output_filenames(());\n+    let _ = tcx.early_lint_checks(()); // Borrows `resolver_for_lowering`.\n     let (mut resolver, krate) = tcx.resolver_for_lowering(()).steal();\n \n     let ast_index = index_crate(&resolver.node_id_to_def_id, &krate);"}, {"sha": "a4d91a956627337198777f92d76886aad5ad6130", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -244,6 +244,10 @@ impl<'a> State<'a> {\n             (&ast::ExprKind::Let { .. }, _) if !parser::needs_par_as_let_scrutinee(prec) => {\n                 parser::PREC_FORCE_PAREN\n             }\n+            // For a binary expression like `(match () { _ => a }) OP b`, the parens are required\n+            // otherwise the parser would interpret `match () { _ => a }` as a statement,\n+            // with the remaining `OP b` not making sense. So we force parens.\n+            (&ast::ExprKind::Match(..), _) => parser::PREC_FORCE_PAREN,\n             _ => left_prec,\n         };\n "}, {"sha": "36682bbe0708f88babcb29aee81c064ce452f7c3", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -42,6 +42,18 @@ pub fn expand_concat(\n                     has_errors = true;\n                 }\n             },\n+            // We also want to allow negative numeric literals.\n+            ast::ExprKind::Unary(ast::UnOp::Neg, ref expr) if let ast::ExprKind::Lit(token_lit) = expr.kind => {\n+                match ast::LitKind::from_token_lit(token_lit) {\n+                    Ok(ast::LitKind::Int(i, _)) => accumulator.push_str(&format!(\"-{i}\")),\n+                    Ok(ast::LitKind::Float(f, _)) => accumulator.push_str(&format!(\"-{f}\")),\n+                    Err(err) => {\n+                        report_lit_error(&cx.sess.parse_sess, err, token_lit, e.span);\n+                        has_errors = true;\n+                    }\n+                    _ => missing_literal.push(e.span),\n+                }\n+            }\n             ast::ExprKind::IncludedBytes(..) => {\n                 cx.span_err(e.span, \"cannot concatenate a byte string literal\")\n             }\n@@ -53,9 +65,10 @@ pub fn expand_concat(\n             }\n         }\n     }\n+\n     if !missing_literal.is_empty() {\n         let mut err = cx.struct_span_err(missing_literal, \"expected a literal\");\n-        err.note(\"only literals (like `\\\"foo\\\"`, `42` and `3.14`) can be passed to `concat!()`\");\n+        err.note(\"only literals (like `\\\"foo\\\"`, `-42` and `3.14`) can be passed to `concat!()`\");\n         err.emit();\n         return DummyResult::any(sp);\n     } else if has_errors {"}, {"sha": "5cffca5230a8f4c3f6193f7b2dbbfda68eb54015", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -258,6 +258,10 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     // Apply debuginfo to the newly allocated locals.\n     fx.debug_introduce_locals(&mut start_bx);\n \n+    // The builders will be created separately for each basic block at `codegen_block`.\n+    // So drop the builder of `start_llbb` to avoid having two at the same time.\n+    drop(start_bx);\n+\n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in traversal::reverse_postorder(&mir) {\n         fx.codegen_block(bb);"}, {"sha": "e321a9847ba06e516181a492ab2796a38e986eb1", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -331,6 +331,7 @@ fn run_compiler(\n             if let Some(ppm) = &sess.opts.pretty {\n                 if ppm.needs_ast_map() {\n                     queries.global_ctxt()?.enter(|tcx| {\n+                        tcx.ensure().early_lint_checks(());\n                         pretty::print_after_hir_lowering(tcx, *ppm);\n                         Ok(())\n                     })?;"}, {"sha": "713e4fbbdce2364b855db30b2604080ce2a4409a", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -12,13 +12,13 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{AssocCtxt, Visitor};\n use rustc_ast::{self as ast, AttrVec, Attribute, HasAttrs, Item, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, Stability};\n-use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{\n     Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, MultiSpan, PResult,\n };\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n-use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics};\n+use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, RegisteredTools};\n use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n use rustc_session::errors::report_lit_error;\n use rustc_session::{parse::ParseSess, Limit, Session};\n@@ -947,14 +947,14 @@ pub trait ResolverExpand {\n     fn declare_proc_macro(&mut self, id: NodeId);\n \n     /// Tools registered with `#![register_tool]` and used by tool attributes and lints.\n-    fn registered_tools(&self) -> &FxHashSet<Ident>;\n+    fn registered_tools(&self) -> &RegisteredTools;\n }\n \n pub trait LintStoreExpand {\n     fn pre_expansion_lint(\n         &self,\n         sess: &Session,\n-        registered_tools: &FxHashSet<Ident>,\n+        registered_tools: &RegisteredTools,\n         node_id: NodeId,\n         attrs: &[Attribute],\n         items: &[P<Item>],"}, {"sha": "77c67c14ecc55a88685987b502f98e1eca4aa77d", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -53,6 +53,12 @@ pub struct Obligation<'tcx, T> {\n     pub recursion_depth: usize,\n }\n \n+impl<'tcx, P> From<Obligation<'tcx, P>> for solve::Goal<'tcx, P> {\n+    fn from(value: Obligation<'tcx, P>) -> Self {\n+        solve::Goal { param_env: value.param_env, predicate: value.predicate }\n+    }\n+}\n+\n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n "}, {"sha": "4a02981f9543dbd5ff46d28c8fc23142732adbf1", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -11,7 +11,7 @@ use rustc_data_structures::parallel;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::PResult;\n-use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n+use rustc_expand::base::{ExtCtxt, LintStoreExpand};\n use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n use rustc_lint::{unerased_lint_store, BufferedEarlyLint, EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n@@ -178,7 +178,7 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n     let sess = tcx.sess;\n     let lint_store = unerased_lint_store(tcx);\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n-    pre_expansion_lint(sess, lint_store, resolver.registered_tools(), &krate, crate_name);\n+    pre_expansion_lint(sess, lint_store, tcx.registered_tools(()), &krate, crate_name);\n     rustc_builtin_macros::register_builtin_macros(resolver);\n \n     krate = sess.time(\"crate_injection\", || {\n@@ -302,6 +302,16 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n \n     // Done with macro expansion!\n \n+    resolver.resolve_crate(&krate);\n+\n+    krate\n+}\n+\n+fn early_lint_checks(tcx: TyCtxt<'_>, (): ()) {\n+    let sess = tcx.sess;\n+    let (resolver, krate) = &*tcx.resolver_for_lowering(()).borrow();\n+    let mut lint_buffer = resolver.lint_buffer.steal();\n+\n     if sess.opts.unstable_opts.input_stats {\n         eprintln!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }\n@@ -310,8 +320,6 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n         hir_stats::print_ast_stats(&krate, \"POST EXPANSION AST STATS\", \"ast-stats-2\");\n     }\n \n-    resolver.resolve_crate(&krate);\n-\n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     sess.time(\"complete_gated_feature_checking\", || {\n         rustc_ast_passes::feature_gate::check_crate(&krate, sess);\n@@ -321,7 +329,7 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n     sess.parse_sess.buffered_lints.with_lock(|buffered_lints| {\n         info!(\"{} parse sess buffered_lints\", buffered_lints.len());\n         for early_lint in buffered_lints.drain(..) {\n-            resolver.lint_buffer().add_early_lint(early_lint);\n+            lint_buffer.add_early_lint(early_lint);\n         }\n     });\n \n@@ -340,20 +348,16 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n         }\n     });\n \n-    sess.time(\"early_lint_checks\", || {\n-        let lint_buffer = Some(std::mem::take(resolver.lint_buffer()));\n-        rustc_lint::check_ast_node(\n-            sess,\n-            false,\n-            lint_store,\n-            resolver.registered_tools(),\n-            lint_buffer,\n-            rustc_lint::BuiltinCombinedEarlyLintPass::new(),\n-            &krate,\n-        )\n-    });\n-\n-    krate\n+    let lint_store = unerased_lint_store(tcx);\n+    rustc_lint::check_ast_node(\n+        sess,\n+        false,\n+        lint_store,\n+        tcx.registered_tools(()),\n+        Some(lint_buffer),\n+        rustc_lint::BuiltinCombinedEarlyLintPass::new(),\n+        &**krate,\n+    )\n }\n \n // Returns all the paths that correspond to generated files.\n@@ -557,6 +561,7 @@ fn resolver_for_lowering<'tcx>(\n     (): (),\n ) -> &'tcx Steal<(ty::ResolverAstLowering, Lrc<ast::Crate>)> {\n     let arenas = Resolver::arenas();\n+    let _ = tcx.registered_tools(()); // Uses `crate_for_resolver`.\n     let krate = tcx.crate_for_resolver(()).steal();\n     let mut resolver = Resolver::new(tcx, &krate, &arenas);\n     let krate = configure_and_expand(krate, &mut resolver);\n@@ -629,6 +634,7 @@ pub static DEFAULT_QUERY_PROVIDERS: LazyLock<Providers> = LazyLock::new(|| {\n     providers.hir_crate = rustc_ast_lowering::lower_to_hir;\n     providers.output_filenames = output_filenames;\n     providers.resolver_for_lowering = resolver_for_lowering;\n+    providers.early_lint_checks = early_lint_checks;\n     proc_macro_decls::provide(providers);\n     rustc_const_eval::provide(providers);\n     rustc_middle::hir::provide(providers);\n@@ -637,6 +643,7 @@ pub static DEFAULT_QUERY_PROVIDERS: LazyLock<Providers> = LazyLock::new(|| {\n     rustc_mir_transform::provide(providers);\n     rustc_monomorphize::provide(providers);\n     rustc_privacy::provide(providers);\n+    rustc_resolve::provide(providers);\n     rustc_hir_analysis::provide(providers);\n     rustc_hir_typeck::provide(providers);\n     ty::provide(providers);"}, {"sha": "a76229dd3524b2ed0ce13a9310817a542317a4cb", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -128,7 +128,7 @@ fn lint_expectations(tcx: TyCtxt<'_>, (): ()) -> Vec<(LintExpectationId, LintExp\n         },\n         warn_about_weird_lints: false,\n         store,\n-        registered_tools: &tcx.resolutions(()).registered_tools,\n+        registered_tools: &tcx.registered_tools(()),\n     };\n \n     builder.add_command_line();\n@@ -156,7 +156,7 @@ fn shallow_lint_levels_on(tcx: TyCtxt<'_>, owner: hir::OwnerId) -> ShallowLintLe\n         },\n         warn_about_weird_lints: false,\n         store,\n-        registered_tools: &tcx.resolutions(()).registered_tools,\n+        registered_tools: &tcx.registered_tools(()),\n     };\n \n     if owner == hir::CRATE_OWNER_ID {"}, {"sha": "2ba365e298f587ffe80246481eb804271c1e1753", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -1349,9 +1349,8 @@ declare_lint! {\n     /// ### Example\n     ///\n     /// ```rust\n-    /// #![feature(box_syntax)]\n     /// fn main() {\n-    ///     let a = (box [1, 2, 3]).len();\n+    ///     let a = Box::new([1, 2, 3]).len();\n     /// }\n     /// ```\n     ///\n@@ -1373,6 +1372,11 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAllocation {\n     fn check_expr(&mut self, cx: &LateContext<'_>, e: &hir::Expr<'_>) {\n         match e.kind {\n             hir::ExprKind::Box(_) => {}\n+            hir::ExprKind::Call(path_expr, [_])\n+                if let hir::ExprKind::Path(qpath) = &path_expr.kind\n+                && let Some(did) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id()\n+                && cx.tcx.is_diagnostic_item(sym::box_new, did)\n+                => {}\n             _ => return,\n         }\n "}, {"sha": "6f22bdabff450e898fcf3141b718c631427526b9", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -8,7 +8,7 @@ extern crate rustc_macros;\n pub use self::Level::*;\n use rustc_ast::node_id::NodeId;\n use rustc_ast::{AttrId, Attribute};\n-use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_error_messages::{DiagnosticMessage, MultiSpan};\n use rustc_hir::HashStableContext;\n@@ -533,6 +533,7 @@ pub enum BuiltinLintDiagnostics {\n \n /// Lints that are buffered up early on in the `Session` before the\n /// `LintLevels` is calculated.\n+#[derive(Debug)]\n pub struct BufferedEarlyLint {\n     /// The span of code that we are linting on.\n     pub span: MultiSpan,\n@@ -551,7 +552,7 @@ pub struct BufferedEarlyLint {\n     pub diagnostic: BuiltinLintDiagnostics,\n }\n \n-#[derive(Default)]\n+#[derive(Default, Debug)]\n pub struct LintBuffer {\n     pub map: FxIndexMap<NodeId, Vec<BufferedEarlyLint>>,\n }\n@@ -601,6 +602,8 @@ impl LintBuffer {\n     }\n }\n \n+pub type RegisteredTools = FxIndexSet<Ident>;\n+\n /// Declares a static item of type `&'static Lint`.\n ///\n /// See <https://rustc-dev-guide.rust-lang.org/diagnostics.html> for"}, {"sha": "72907fba5e62ce23712c6a9b21989ad7592907f3", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -108,6 +108,7 @@ macro_rules! arena_types {\n             // (during lowering) and the `librustc_middle` arena (for decoding MIR)\n             [decode] asm_template: rustc_ast::InlineAsmTemplatePiece,\n             [decode] used_trait_imports: rustc_data_structures::unord::UnordSet<rustc_hir::def_id::LocalDefId>,\n+            [decode] registered_tools: rustc_middle::ty::RegisteredTools,\n             [decode] is_late_bound_map: rustc_data_structures::fx::FxIndexSet<rustc_hir::ItemLocalId>,\n             [decode] impl_source: rustc_middle::traits::ImplSource<'tcx, ()>,\n "}, {"sha": "ca0243d715faaff85afbb4912db2588c3b97f22c", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -26,6 +26,15 @@ rustc_queries! {\n         desc { \"triggering a delay span bug\" }\n     }\n \n+    query registered_tools(_: ()) -> &'tcx ty::RegisteredTools {\n+        arena_cache\n+        desc { \"compute registered tools for crate\" }\n+    }\n+\n+    query early_lint_checks(_: ()) -> () {\n+        desc { \"perform lints prior to macro expansion\" }\n+    }\n+\n     query resolutions(_: ()) -> &'tcx ty::ResolverGlobalCtxt {\n         feedable\n         no_hash"}, {"sha": "92d3e73e683cd832ec640ab1f3a6ed332795aca0", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -1,12 +1,104 @@\n use std::ops::ControlFlow;\n \n use rustc_data_structures::intern::Interned;\n+use rustc_query_system::cache::Cache;\n \n-use crate::infer::canonical::QueryRegionConstraints;\n+use crate::infer::canonical::{CanonicalVarValues, QueryRegionConstraints};\n+use crate::traits::query::NoSolution;\n+use crate::traits::Canonical;\n use crate::ty::{\n-    FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeVisitable, TypeVisitor,\n+    self, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeVisitable,\n+    TypeVisitor,\n };\n \n+pub type EvaluationCache<'tcx> = Cache<CanonicalGoal<'tcx>, QueryResult<'tcx>>;\n+\n+/// A goal is a statement, i.e. `predicate`, we want to prove\n+/// given some assumptions, i.e. `param_env`.\n+///\n+/// Most of the time the `param_env` contains the `where`-bounds of the function\n+/// we're currently typechecking while the `predicate` is some trait bound.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub struct Goal<'tcx, P> {\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub predicate: P,\n+}\n+\n+impl<'tcx, P> Goal<'tcx, P> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: impl ToPredicate<'tcx, P>,\n+    ) -> Goal<'tcx, P> {\n+        Goal { param_env, predicate: predicate.to_predicate(tcx) }\n+    }\n+\n+    /// Updates the goal to one with a different `predicate` but the same `param_env`.\n+    pub fn with<Q>(self, tcx: TyCtxt<'tcx>, predicate: impl ToPredicate<'tcx, Q>) -> Goal<'tcx, Q> {\n+        Goal { param_env: self.param_env, predicate: predicate.to_predicate(tcx) }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub struct Response<'tcx> {\n+    pub var_values: CanonicalVarValues<'tcx>,\n+    /// Additional constraints returned by this query.\n+    pub external_constraints: ExternalConstraints<'tcx>,\n+    pub certainty: Certainty,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum Certainty {\n+    Yes,\n+    Maybe(MaybeCause),\n+}\n+\n+impl Certainty {\n+    pub const AMBIGUOUS: Certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n+\n+    /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n+    /// use this function to unify the certainty of these goals\n+    pub fn unify_and(self, other: Certainty) -> Certainty {\n+        match (self, other) {\n+            (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n+            (Certainty::Yes, Certainty::Maybe(_)) => other,\n+            (Certainty::Maybe(_), Certainty::Yes) => self,\n+            (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n+                Certainty::Maybe(MaybeCause::Overflow)\n+            }\n+            // If at least one of the goals is ambiguous, hide the overflow as the ambiguous goal\n+            // may still result in failure.\n+            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(_))\n+            | (Certainty::Maybe(_), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n+                Certainty::Maybe(MaybeCause::Ambiguity)\n+            }\n+        }\n+    }\n+}\n+\n+/// Why we failed to evaluate a goal.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum MaybeCause {\n+    /// We failed due to ambiguity. This ambiguity can either\n+    /// be a true ambiguity, i.e. there are multiple different answers,\n+    /// or we hit a case where we just don't bother, e.g. `?x: Trait` goals.\n+    Ambiguity,\n+    /// We gave up due to an overflow, most often by hitting the recursion limit.\n+    Overflow,\n+}\n+\n+pub type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n+\n+pub type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n+\n+/// The result of evaluating a canonical query.\n+///\n+/// FIXME: We use a different type than the existing canonical queries. This is because\n+/// we need to add a `Certainty` for `overflow` and may want to restructure this code without\n+/// having to worry about changes to currently used code. Once we've made progress on this\n+/// solver, merge the two responses again.\n+pub type QueryResult<'tcx> = Result<CanonicalResponse<'tcx>, NoSolution>;\n+\n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n pub struct ExternalConstraints<'tcx>(pub(crate) Interned<'tcx, ExternalConstraintsData<'tcx>>);\n "}, {"sha": "e95f6f91357ef18a74ed44b6866ba8e7c412c5c2", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -17,6 +17,7 @@ use crate::mir::{\n };\n use crate::thir::Thir;\n use crate::traits;\n+use crate::traits::solve;\n use crate::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n@@ -537,6 +538,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Merge this with `selection_cache`?\n     pub evaluation_cache: traits::EvaluationCache<'tcx>,\n \n+    /// Caches the results of goal evaluation in the new solver.\n+    pub new_solver_evaluation_cache: solve::EvaluationCache<'tcx>,\n+\n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n \n@@ -712,6 +716,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             pred_rcache: Default::default(),\n             selection_cache: Default::default(),\n             evaluation_cache: Default::default(),\n+            new_solver_evaluation_cache: Default::default(),\n             data_layout,\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n         }"}, {"sha": "487cbf1ec4e301a4d680833b3a5dbeb8cca2c4e4", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -34,6 +34,7 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n@@ -44,6 +45,8 @@ use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::{Decodable, Encodable};\n+use rustc_session::lint::LintBuffer;\n+pub use rustc_session::lint::RegisteredTools;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, ExpnKind, Span};\n@@ -148,8 +151,6 @@ mod typeck_results;\n \n // Data types\n \n-pub type RegisteredTools = FxHashSet<Ident>;\n-\n pub struct ResolverOutputs {\n     pub global_ctxt: ResolverGlobalCtxt,\n     pub ast_lowering: ResolverAstLowering,\n@@ -175,7 +176,6 @@ pub struct ResolverGlobalCtxt {\n     /// Mapping from ident span to path span for paths that don't exist as written, but that\n     /// exist under `std`. For example, wrote `str::from_utf8` instead of `std::str::from_utf8`.\n     pub confused_type_with_std_module: FxHashMap<Span, Span>,\n-    pub registered_tools: RegisteredTools,\n     pub doc_link_resolutions: FxHashMap<LocalDefId, DocLinkResMap>,\n     pub doc_link_traits_in_scope: FxHashMap<LocalDefId, Vec<DefId>>,\n     pub all_macro_rules: FxHashMap<Symbol, Res<ast::NodeId>>,\n@@ -209,6 +209,9 @@ pub struct ResolverAstLowering {\n     pub builtin_macro_kinds: FxHashMap<LocalDefId, MacroKind>,\n     /// List functions and methods for which lifetime elision was successful.\n     pub lifetime_elision_allowed: FxHashSet<ast::NodeId>,\n+\n+    /// Lints that were emitted by the resolver and early lints.\n+    pub lint_buffer: Steal<LintBuffer>,\n }\n \n #[derive(Clone, Copy, Debug)]"}, {"sha": "963cb29ffb3269d8d0e519d83f06d0e9b7dba72e", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -252,6 +252,36 @@ macro_rules! define_callbacks {\n             )*\n         }\n \n+        $(\n+            // Ensure that keys grow no larger than 64 bytes\n+            #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+            const _: () = {\n+                if mem::size_of::<query_keys::$name<'static>>() > 64 {\n+                    panic!(\"{}\", concat!(\n+                        \"the query `\",\n+                        stringify!($name),\n+                        \"` has a key type `\",\n+                        stringify!($($K)*),\n+                        \"` that is too large\"\n+                    ));\n+                }\n+            };\n+\n+            // Ensure that values grow no larger than 64 bytes\n+            #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+            const _: () = {\n+                if mem::size_of::<query_values::$name<'static>>() > 64 {\n+                    panic!(\"{}\", concat!(\n+                        \"the query `\",\n+                        stringify!($name),\n+                        \"` has a value type `\",\n+                        stringify!($V),\n+                        \"` that is too large\"\n+                    ));\n+                }\n+            };\n+        )*\n+\n         pub struct QueryArenas<'tcx> {\n             $($(#[$attr])* pub $name: query_if_arena!([$($modifiers)*]\n                 (WorkerLocal<TypedArena<<$V as Deref>::Target>>)"}, {"sha": "e822c18fa5f8af1f3bbb6e0e59e0c412a9737f68", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -27,6 +27,7 @@ use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{Lrc, MappedReadGuard};\n use rustc_errors::{\n     Applicability, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed, SubdiagnosticMessage,\n@@ -965,7 +966,7 @@ pub struct Resolver<'a, 'tcx> {\n     /// A small map keeping true kinds of built-in macros that appear to be fn-like on\n     /// the surface (`macro` items in libcore), but are actually attributes or derives.\n     builtin_macro_kinds: FxHashMap<LocalDefId, MacroKind>,\n-    registered_tools: RegisteredTools,\n+    registered_tools: &'tcx RegisteredTools,\n     macro_use_prelude: FxHashMap<Symbol, &'a NameBinding<'a>>,\n     macro_map: FxHashMap<DefId, MacroData>,\n     dummy_ext_bang: Lrc<SyntaxExtension>,\n@@ -1233,7 +1234,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        let registered_tools = macros::registered_tools(tcx.sess, &krate.attrs);\n+        let registered_tools = tcx.registered_tools(());\n \n         let features = tcx.sess.features_untracked();\n \n@@ -1408,7 +1409,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             trait_impls: self.trait_impls,\n             proc_macros,\n             confused_type_with_std_module,\n-            registered_tools: self.registered_tools,\n             doc_link_resolutions: self.doc_link_resolutions,\n             doc_link_traits_in_scope: self.doc_link_traits_in_scope,\n             all_macro_rules: self.all_macro_rules,\n@@ -1426,6 +1426,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             trait_map: self.trait_map,\n             builtin_macro_kinds: self.builtin_macro_kinds,\n             lifetime_elision_allowed: self.lifetime_elision_allowed,\n+            lint_buffer: Steal::new(self.lint_buffer),\n         };\n         ResolverOutputs { global_ctxt, ast_lowering }\n     }\n@@ -2032,3 +2033,7 @@ impl Finalize {\n         Finalize { node_id, path_span, root_span, report_private: true }\n     }\n }\n+\n+pub fn provide(providers: &mut ty::query::Providers) {\n+    providers.registered_tools = macros::registered_tools;\n+}"}, {"sha": "37153854f7e7f7c49e03a5a87b817c98a5c2bb2d", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -8,7 +8,6 @@ use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment};\n use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability};\n@@ -20,11 +19,11 @@ use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{CrateNum, LocalDefId};\n use rustc_middle::middle::stability;\n use rustc_middle::ty::RegisteredTools;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, SOFT_UNSTABLE};\n use rustc_session::lint::builtin::{UNUSED_MACROS, UNUSED_MACRO_RULES};\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::feature_err;\n-use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{self, ExpnData, ExpnKind, LocalExpnId};\n use rustc_span::hygiene::{AstPass, MacroKind};\n@@ -111,23 +110,28 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n     }\n }\n \n-pub(crate) fn registered_tools(sess: &Session, attrs: &[ast::Attribute]) -> FxHashSet<Ident> {\n-    let mut registered_tools = FxHashSet::default();\n-    for attr in sess.filter_by_name(attrs, sym::register_tool) {\n+pub(crate) fn registered_tools(tcx: TyCtxt<'_>, (): ()) -> RegisteredTools {\n+    let mut registered_tools = RegisteredTools::default();\n+    let krate = tcx.crate_for_resolver(()).borrow();\n+    for attr in tcx.sess.filter_by_name(&krate.attrs, sym::register_tool) {\n         for nested_meta in attr.meta_item_list().unwrap_or_default() {\n             match nested_meta.ident() {\n                 Some(ident) => {\n                     if let Some(old_ident) = registered_tools.replace(ident) {\n                         let msg = format!(\"{} `{}` was already registered\", \"tool\", ident);\n-                        sess.struct_span_err(ident.span, &msg)\n+                        tcx.sess\n+                            .struct_span_err(ident.span, &msg)\n                             .span_label(old_ident.span, \"already registered here\")\n                             .emit();\n                     }\n                 }\n                 None => {\n                     let msg = format!(\"`{}` only accepts identifiers\", sym::register_tool);\n                     let span = nested_meta.span();\n-                    sess.struct_span_err(span, &msg).span_label(span, \"not an identifier\").emit();\n+                    tcx.sess\n+                        .struct_span_err(span, &msg)\n+                        .span_label(span, \"not an identifier\")\n+                        .emit();\n                 }\n             }\n         }"}, {"sha": "bf27bd6c5ad4233c83de8130ea281bf4e5d1e71e", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -429,6 +429,7 @@ symbols! {\n         borrowck_graphviz_format,\n         borrowck_graphviz_postflow,\n         box_free,\n+        box_new,\n         box_patterns,\n         box_syntax,\n         bpf_target_feature,"}, {"sha": "b092503a007ecffc4783bf52d2c247a486d7ab8b", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -2,11 +2,12 @@\n \n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n+use super::EvalCtxt;\n use itertools::Itertools;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n+use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, MaybeCause, QueryResult};\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::fmt::Debug;"}, {"sha": "55d361b120441cc616fa73430fc998166e571db4", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 5, "deletions": 92, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -21,11 +21,13 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::Obligation;\n-use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n+use rustc_middle::traits::solve::{\n+    CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n+    Goal, MaybeCause, QueryResult, Response,\n+};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n-    CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, ToPredicate, TypeOutlivesPredicate,\n+    CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n use rustc_span::DUMMY_SP;\n \n@@ -43,45 +45,6 @@ mod trait_goals;\n pub use eval_ctxt::EvalCtxt;\n pub use fulfill::FulfillmentCtxt;\n \n-/// A goal is a statement, i.e. `predicate`, we want to prove\n-/// given some assumptions, i.e. `param_env`.\n-///\n-/// Most of the time the `param_env` contains the `where`-bounds of the function\n-/// we're currently typechecking while the `predicate` is some trait bound.\n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n-pub struct Goal<'tcx, P> {\n-    param_env: ty::ParamEnv<'tcx>,\n-    predicate: P,\n-}\n-\n-impl<'tcx, P> Goal<'tcx, P> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        predicate: impl ToPredicate<'tcx, P>,\n-    ) -> Goal<'tcx, P> {\n-        Goal { param_env, predicate: predicate.to_predicate(tcx) }\n-    }\n-\n-    /// Updates the goal to one with a different `predicate` but the same `param_env`.\n-    fn with<Q>(self, tcx: TyCtxt<'tcx>, predicate: impl ToPredicate<'tcx, Q>) -> Goal<'tcx, Q> {\n-        Goal { param_env: self.param_env, predicate: predicate.to_predicate(tcx) }\n-    }\n-}\n-\n-impl<'tcx, P> From<Obligation<'tcx, P>> for Goal<'tcx, P> {\n-    fn from(obligation: Obligation<'tcx, P>) -> Goal<'tcx, P> {\n-        Goal { param_env: obligation.param_env, predicate: obligation.predicate }\n-    }\n-}\n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n-pub struct Response<'tcx> {\n-    pub var_values: CanonicalVarValues<'tcx>,\n-    /// Additional constraints returned by this query.\n-    pub external_constraints: ExternalConstraints<'tcx>,\n-    pub certainty: Certainty,\n-}\n-\n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n }\n@@ -94,56 +57,6 @@ impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n-pub enum Certainty {\n-    Yes,\n-    Maybe(MaybeCause),\n-}\n-\n-impl Certainty {\n-    pub const AMBIGUOUS: Certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n-\n-    /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n-    /// use this function to unify the certainty of these goals\n-    pub fn unify_and(self, other: Certainty) -> Certainty {\n-        match (self, other) {\n-            (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n-            (Certainty::Yes, Certainty::Maybe(_)) => other,\n-            (Certainty::Maybe(_), Certainty::Yes) => self,\n-            (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n-                Certainty::Maybe(MaybeCause::Overflow)\n-            }\n-            // If at least one of the goals is ambiguous, hide the overflow as the ambiguous goal\n-            // may still result in failure.\n-            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(_))\n-            | (Certainty::Maybe(_), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n-                Certainty::Maybe(MaybeCause::Ambiguity)\n-            }\n-        }\n-    }\n-}\n-\n-/// Why we failed to evaluate a goal.\n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n-pub enum MaybeCause {\n-    /// We failed due to ambiguity. This ambiguity can either\n-    /// be a true ambiguity, i.e. there are multiple different answers,\n-    /// or we hit a case where we just don't bother, e.g. `?x: Trait` goals.\n-    Ambiguity,\n-    /// We gave up due to an overflow, most often by hitting the recursion limit.\n-    Overflow,\n-}\n-\n-type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n-type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n-/// The result of evaluating a canonical query.\n-///\n-/// FIXME: We use a different type than the existing canonical queries. This is because\n-/// we need to add a `Certainty` for `overflow` and may want to restructure this code without\n-/// having to worry about changes to currently used code. Once we've made progress on this\n-/// solver, merge the two responses again.\n-pub type QueryResult<'tcx> = Result<CanonicalResponse<'tcx>, NoSolution>;\n-\n pub trait InferCtxtEvalExt<'tcx> {\n     /// Evaluates a goal from **outside** of the trait solver.\n     ///"}, {"sha": "e206658b4b90d2cc8374c524048c3c028d06574a", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -2,7 +2,7 @@ use crate::traits::{specialization_graph, translate_substs};\n \n use super::assembly;\n use super::trait_goals::structural_traits;\n-use super::{Certainty, EvalCtxt, Goal, QueryResult};\n+use super::EvalCtxt;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -11,6 +11,7 @@ use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::Reveal;\n+use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, QueryResult};\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::ProjectionPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -512,7 +513,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     fn consider_builtin_dyn_upcast_candidates(\n         _ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-    ) -> Vec<super::CanonicalResponse<'tcx>> {\n+    ) -> Vec<CanonicalResponse<'tcx>> {\n         bug!(\"`Unsize` does not have an associated type: {:?}\", goal);\n     }\n "}, {"sha": "d1b4fa554c5f2f5e1e3a73009d9be82cdade3cc4", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/cache.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -8,12 +8,10 @@\n //!\n //! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n //! before then or if I still haven't done that before January 2023.\n-use super::overflow::OverflowData;\n use super::StackDepth;\n-use crate::solve::{CanonicalGoal, QueryResult};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::traits::solve::{CanonicalGoal, QueryResult};\n \n rustc_index::newtype_index! {\n     pub struct EntryIndex {}\n@@ -98,26 +96,3 @@ impl<'tcx> ProvisionalCache<'tcx> {\n         self.entries[entry_index].response\n     }\n }\n-\n-pub(super) fn try_move_finished_goal_to_global_cache<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    overflow_data: &mut OverflowData,\n-    stack: &IndexVec<super::StackDepth, super::StackElem<'tcx>>,\n-    goal: CanonicalGoal<'tcx>,\n-    response: QueryResult<'tcx>,\n-) {\n-    // We move goals to the global cache if we either did not hit an overflow or if it's\n-    // the root goal as that will now always hit the same overflow limit.\n-    //\n-    // NOTE: We cannot move any non-root goals to the global cache even if their final result\n-    // isn't impacted by the overflow as that goal still has unstable query dependencies\n-    // because it didn't go its full depth.\n-    //\n-    // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n-    // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n-    let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n-    if should_cache_globally {\n-        // FIXME: move the provisional entry to the global cache.\n-        let _ = (tcx, goal, response);\n-    }\n-}"}, {"sha": "f1b840aac556abfaf4d2d45278a5f0eb02c4f57d", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 61, "deletions": 46, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -2,11 +2,12 @@ mod cache;\n mod overflow;\n \n use self::cache::ProvisionalEntry;\n-use super::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n pub(super) use crate::solve::search_graph::overflow::OverflowHandler;\n use cache::ProvisionalCache;\n use overflow::OverflowData;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::dep_graph::DepKind;\n+use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_middle::ty::TyCtxt;\n use std::{collections::hash_map::Entry, mem};\n \n@@ -139,10 +140,9 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// updated the provisional cache and we have to recompute the current goal.\n     ///\n     /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n-    #[instrument(level = \"debug\", skip(self, tcx, actual_goal), ret)]\n+    #[instrument(level = \"debug\", skip(self, actual_goal), ret)]\n     fn try_finalize_goal(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n         actual_goal: CanonicalGoal<'tcx>,\n         response: QueryResult<'tcx>,\n     ) -> bool {\n@@ -176,72 +176,87 @@ impl<'tcx> SearchGraph<'tcx> {\n             self.stack.push(StackElem { goal, has_been_used: false });\n             false\n         } else {\n-            self.try_move_finished_goal_to_global_cache(tcx, stack_elem);\n             true\n         }\n     }\n \n-    fn try_move_finished_goal_to_global_cache(\n+    pub(super) fn with_new_goal(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        stack_elem: StackElem<'tcx>,\n-    ) {\n-        let StackElem { goal, .. } = stack_elem;\n+        canonical_goal: CanonicalGoal<'tcx>,\n+        mut loop_body: impl FnMut(&mut Self) -> QueryResult<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(result) = tcx.new_solver_evaluation_cache.get(&canonical_goal, tcx) {\n+            return result;\n+        }\n+\n+        match self.try_push_stack(tcx, canonical_goal) {\n+            Ok(()) => {}\n+            // Our goal is already on the stack, eager return.\n+            Err(response) => return response,\n+        }\n+\n+        // This is for global caching, so we properly track query dependencies.\n+        // Everything that affects the `Result` should be performed within this\n+        // `with_anon_task` closure.\n+        let (result, dep_node) = tcx.dep_graph.with_anon_task(tcx, DepKind::TraitSelect, || {\n+            self.repeat_while_none(\n+                |this| {\n+                    let result = this.deal_with_overflow(tcx, canonical_goal);\n+                    let _ = this.stack.pop().unwrap();\n+                    result\n+                },\n+                |this| {\n+                    let result = loop_body(this);\n+                    this.try_finalize_goal(canonical_goal, result).then(|| result)\n+                },\n+            )\n+        });\n+\n         let cache = &mut self.provisional_cache;\n-        let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n+        let provisional_entry_index = *cache.lookup_table.get(&canonical_goal).unwrap();\n         let provisional_entry = &mut cache.entries[provisional_entry_index];\n         let depth = provisional_entry.depth;\n \n         // If not, we're done with this goal.\n         //\n         // Check whether that this goal doesn't depend on a goal deeper on the stack\n-        // and if so, move it and all nested goals to the global cache.\n+        // and if so, move it to the global cache.\n         //\n         // Note that if any nested goal were to depend on something deeper on the stack,\n         // this would have also updated the depth of the current goal.\n         if depth == self.stack.next_index() {\n-            for (i, entry) in cache.entries.drain_enumerated(provisional_entry_index.index()..) {\n+            // If the current goal is the head of a cycle, we drop all other\n+            // cycle participants without moving them to the global cache.\n+            let other_cycle_participants = provisional_entry_index.index() + 1;\n+            for (i, entry) in cache.entries.drain_enumerated(other_cycle_participants..) {\n                 let actual_index = cache.lookup_table.remove(&entry.goal);\n                 debug_assert_eq!(Some(i), actual_index);\n                 debug_assert!(entry.depth == depth);\n-                cache::try_move_finished_goal_to_global_cache(\n-                    tcx,\n-                    &mut self.overflow_data,\n-                    &self.stack,\n-                    entry.goal,\n-                    entry.response,\n-                );\n             }\n-        }\n-    }\n \n-    pub(super) fn with_new_goal(\n-        &mut self,\n-        tcx: TyCtxt<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n-        mut loop_body: impl FnMut(&mut Self) -> QueryResult<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        match self.try_push_stack(tcx, canonical_goal) {\n-            Ok(()) => {}\n-            // Our goal is already on the stack, eager return.\n-            Err(response) => return response,\n+            let current_goal = cache.entries.pop().unwrap();\n+            let actual_index = cache.lookup_table.remove(&current_goal.goal);\n+            debug_assert_eq!(Some(provisional_entry_index), actual_index);\n+            debug_assert!(current_goal.depth == depth);\n+\n+            // We move the root goal to the global cache if we either did not hit an overflow or if it's\n+            // the root goal as that will now always hit the same overflow limit.\n+            //\n+            // NOTE: We cannot move any non-root goals to the global cache. When replaying the root goal's\n+            // dependencies, our non-root goal may no longer appear as child of the root goal.\n+            //\n+            // See https://github.com/rust-lang/rust/pull/108071 for some additional context.\n+            let should_cache_globally = !self.overflow_data.did_overflow() || self.stack.is_empty();\n+            if should_cache_globally {\n+                tcx.new_solver_evaluation_cache.insert(\n+                    current_goal.goal,\n+                    dep_node,\n+                    current_goal.response,\n+                );\n+            }\n         }\n \n-        self.repeat_while_none(\n-            |this| {\n-                let result = this.deal_with_overflow(tcx, canonical_goal);\n-                let stack_elem = this.stack.pop().unwrap();\n-                this.try_move_finished_goal_to_global_cache(tcx, stack_elem);\n-                result\n-            },\n-            |this| {\n-                let result = loop_body(this);\n-                if this.try_finalize_goal(tcx, canonical_goal, result) {\n-                    Some(result)\n-                } else {\n-                    None\n-                }\n-            },\n-        )\n+        result\n     }\n }"}, {"sha": "7c9e63f529b5503a78a9d606fba3b1eb5fc8f329", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/overflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -1,10 +1,11 @@\n use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::traits::solve::{Certainty, MaybeCause, QueryResult};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Limit;\n \n use super::SearchGraph;\n-use crate::solve::{response_no_constraints, Certainty, EvalCtxt, MaybeCause, QueryResult};\n+use crate::solve::{response_no_constraints, EvalCtxt};\n \n /// When detecting a solver overflow, we return ambiguity. Overflow can be\n /// *hidden* by either a fatal error in an **AND** or a trivial success in an **OR**."}, {"sha": "0669975d63819174d57d86c2472b2672d1775810", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -2,12 +2,12 @@\n \n use std::iter;\n \n-use super::assembly;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n+use super::{assembly, EvalCtxt};\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::supertraits;\n+use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, QueryResult};\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use rustc_middle::ty::{TraitPredicate, TypeVisitableExt};"}, {"sha": "1420c25c922801e70298c97766a64d61f2621131", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -1,9 +1,10 @@\n+use rustc_middle::traits::solve::{Certainty, Goal, MaybeCause};\n use rustc_middle::ty;\n use rustc_session::config::TraitSolver;\n \n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::InferCtxt;\n-use crate::solve::{Certainty, Goal, InferCtxtEvalExt, MaybeCause};\n+use crate::solve::InferCtxtEvalExt;\n use crate::traits::{EvaluationResult, OverflowError, PredicateObligation, SelectionContext};\n \n pub trait InferCtxtExt<'tcx> {"}, {"sha": "241b11c3f5f5219650c8f534156426eca0be8364", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -214,6 +214,7 @@ impl<T> Box<T> {\n     #[inline(always)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n+    #[rustc_diagnostic_item = \"box_new\"]\n     pub fn new(x: T) -> Self {\n         #[rustc_box]\n         Box::new(x)"}, {"sha": "f37573c6f27f4aa91f93683183ae0579a2bdcc7d", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -51,8 +51,16 @@ mod tests;\n ///\n /// Going above this limit will abort your program (although not\n /// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\n+/// Trying to go above it might call a `panic` (if not actually going above it).\n+///\n+/// This is a global invariant, and also applies when using a compare-exchange loop.\n+///\n+/// See comment in `Arc::clone`.\n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n+/// The error in case either counter reaches above `MAX_REFCOUNT`, and we can `panic` safely.\n+const INTERNAL_OVERFLOW_ERROR: &str = \"Arc counter overflow\";\n+\n #[cfg(not(sanitize = \"thread\"))]\n macro_rules! acquire {\n     ($x:expr) => {\n@@ -1104,6 +1112,9 @@ impl<T: ?Sized> Arc<T> {\n                 continue;\n             }\n \n+            // We can't allow the refcount to increase much past `MAX_REFCOUNT`.\n+            assert!(cur <= MAX_REFCOUNT, \"{}\", INTERNAL_OVERFLOW_ERROR);\n+\n             // NOTE: this code currently ignores the possibility of overflow\n             // into usize::MAX; in general both Rc and Arc need to be adjusted\n             // to deal with overflow.\n@@ -1519,6 +1530,11 @@ impl<T: ?Sized> Clone for Arc<T> {\n         // the worst already happened and we actually do overflow the `usize` counter. However, that\n         // requires the counter to grow from `isize::MAX` to `usize::MAX` between the increment\n         // above and the `abort` below, which seems exceedingly unlikely.\n+        //\n+        // This is a global invariant, and also applies when using a compare-exchange loop to increment\n+        // counters in other methods.\n+        // Otherwise, the counter could be brought to an almost-overflow using a compare-exchange loop,\n+        // and then overflow using a few `fetch_add`s.\n         if old_size > MAX_REFCOUNT {\n             abort();\n         }\n@@ -2180,9 +2196,7 @@ impl<T: ?Sized> Weak<T> {\n                     return None;\n                 }\n                 // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n-                if n > MAX_REFCOUNT {\n-                    abort();\n-                }\n+                assert!(n <= MAX_REFCOUNT, \"{}\", INTERNAL_OVERFLOW_ERROR);\n                 Some(n + 1)\n             })\n             .ok()"}, {"sha": "b1d3a9fa8ac9035239a7aae6cb5d3a530d3e6cf3", "filename": "library/alloc/src/tests.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/library%2Falloc%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/library%2Falloc%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ftests.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -4,7 +4,6 @@ use core::any::Any;\n use core::clone::Clone;\n use core::convert::TryInto;\n use core::ops::Deref;\n-use core::result::Result::{Err, Ok};\n \n use std::boxed::Box;\n \n@@ -15,32 +14,25 @@ fn test_owned_clone() {\n     assert!(a == b);\n }\n \n-#[derive(PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq)]\n struct Test;\n \n #[test]\n fn any_move() {\n     let a = Box::new(8) as Box<dyn Any>;\n     let b = Box::new(Test) as Box<dyn Any>;\n \n-    match a.downcast::<i32>() {\n-        Ok(a) => {\n-            assert!(a == Box::new(8));\n-        }\n-        Err(..) => panic!(),\n-    }\n-    match b.downcast::<Test>() {\n-        Ok(a) => {\n-            assert!(a == Box::new(Test));\n-        }\n-        Err(..) => panic!(),\n-    }\n+    let a: Box<i32> = a.downcast::<i32>().unwrap();\n+    assert_eq!(*a, 8);\n+\n+    let b: Box<Test> = b.downcast::<Test>().unwrap();\n+    assert_eq!(*b, Test);\n \n     let a = Box::new(8) as Box<dyn Any>;\n     let b = Box::new(Test) as Box<dyn Any>;\n \n-    assert!(a.downcast::<Box<Test>>().is_err());\n-    assert!(b.downcast::<Box<i32>>().is_err());\n+    assert!(a.downcast::<Box<i32>>().is_err());\n+    assert!(b.downcast::<Box<Test>>().is_err());\n }\n \n #[test]"}, {"sha": "06d22d84aedcca715aeab43f694403ab72529227", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -1147,12 +1147,10 @@ macro_rules! nonzero_min_max_unsigned {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(nonzero_min_max)]\n-                ///\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::MIN.get(), 1\", stringify!($Int), \");\")]\n                 /// ```\n-                #[unstable(feature = \"nonzero_min_max\", issue = \"89065\")]\n+                #[stable(feature = \"nonzero_min_max\", since = \"CURRENT_RUSTC_VERSION\")]\n                 pub const MIN: Self = Self::new(1).unwrap();\n \n                 /// The largest value that can be represented by this non-zero\n@@ -1162,12 +1160,10 @@ macro_rules! nonzero_min_max_unsigned {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(nonzero_min_max)]\n-                ///\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::MAX.get(), \", stringify!($Int), \"::MAX);\")]\n                 /// ```\n-                #[unstable(feature = \"nonzero_min_max\", issue = \"89065\")]\n+                #[stable(feature = \"nonzero_min_max\", since = \"CURRENT_RUSTC_VERSION\")]\n                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap();\n             }\n         )+\n@@ -1189,12 +1185,10 @@ macro_rules! nonzero_min_max_signed {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(nonzero_min_max)]\n-                ///\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::MIN.get(), \", stringify!($Int), \"::MIN);\")]\n                 /// ```\n-                #[unstable(feature = \"nonzero_min_max\", issue = \"89065\")]\n+                #[stable(feature = \"nonzero_min_max\", since = \"CURRENT_RUSTC_VERSION\")]\n                 pub const MIN: Self = Self::new(<$Int>::MIN).unwrap();\n \n                 /// The largest value that can be represented by this non-zero\n@@ -1208,12 +1202,10 @@ macro_rules! nonzero_min_max_signed {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(nonzero_min_max)]\n-                ///\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::MAX.get(), \", stringify!($Int), \"::MAX);\")]\n                 /// ```\n-                #[unstable(feature = \"nonzero_min_max\", issue = \"89065\")]\n+                #[stable(feature = \"nonzero_min_max\", since = \"CURRENT_RUSTC_VERSION\")]\n                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap();\n             }\n         )+"}, {"sha": "43c8a0a23fb5bafa6b7003775fb113e109692bcd", "filename": "tests/ui/issues/issue-3029.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fissues%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fissues%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-3029.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -2,9 +2,7 @@\n // error-pattern:so long\n // ignore-emscripten no processes\n \n-#![allow(unused_allocation)]\n #![allow(unreachable_code)]\n-#![allow(unused_variables)]\n \n fn main() {\n     let mut x = Vec::new();"}, {"sha": "5b91aaf9ea5541db509a26ff361c5880038275c6", "filename": "tests/ui/iterators/into-iter-on-arrays-lint.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -2,7 +2,7 @@\n // run-rustfix\n // rustfix-only-machine-applicable\n \n-#[allow(unused_must_use)]\n+#[allow(unused_must_use, unused_allocation)]\n fn main() {\n     let small = [1, 2];\n     let big = [0u8; 33];"}, {"sha": "25b0cef73d77784ee20342fa2fd1d71cddb5ee1f", "filename": "tests/ui/iterators/into-iter-on-arrays-lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -2,7 +2,7 @@\n // run-rustfix\n // rustfix-only-machine-applicable\n \n-#[allow(unused_must_use)]\n+#[allow(unused_must_use, unused_allocation)]\n fn main() {\n     let small = [1, 2];\n     let big = [0u8; 33];"}, {"sha": "c1a6f5ceaf17880e7d3381886b80c09016697d3b", "filename": "tests/ui/lint/unused/unused-allocation.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Flint%2Funused%2Funused-allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Flint%2Funused%2Funused-allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Funused-allocation.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -0,0 +1,7 @@\n+#![feature(rustc_attrs, stmt_expr_attributes)]\n+#![deny(unused_allocation)]\n+\n+fn main() {\n+    _ = (#[rustc_box] Box::new([1])).len(); //~ error: unnecessary allocation, use `&` instead\n+    _ = Box::new([1]).len(); //~ error: unnecessary allocation, use `&` instead\n+}"}, {"sha": "c9ccfbd30e5d42d0135499bc57dcdb899eeb714c", "filename": "tests/ui/lint/unused/unused-allocation.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Flint%2Funused%2Funused-allocation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Flint%2Funused%2Funused-allocation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Funused-allocation.stderr?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -0,0 +1,20 @@\n+error: unnecessary allocation, use `&` instead\n+  --> $DIR/unused-allocation.rs:5:9\n+   |\n+LL |     _ = (#[rustc_box] Box::new([1])).len();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused-allocation.rs:2:9\n+   |\n+LL | #![deny(unused_allocation)]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: unnecessary allocation, use `&` instead\n+  --> $DIR/unused-allocation.rs:6:9\n+   |\n+LL |     _ = Box::new([1]).len();\n+   |         ^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "d67f3c33d36e3cf1fe6a82ffb73c1906e01de192", "filename": "tests/ui/macros/bad-concat.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fmacros%2Fbad-concat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fmacros%2Fbad-concat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fbad-concat.stderr?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -4,7 +4,7 @@ error: expected a literal\n LL |     let _ = concat!(x, y, z, \"bar\");\n    |                     ^  ^  ^\n    |\n-   = note: only literals (like `\"foo\"`, `42` and `3.14`) can be passed to `concat!()`\n+   = note: only literals (like `\"foo\"`, `-42` and `3.14`) can be passed to `concat!()`\n \n error: aborting due to previous error\n "}, {"sha": "d65d9354454c3e829e0813e99cfaf0ff188d42fe", "filename": "tests/ui/macros/concat.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fmacros%2Fconcat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fmacros%2Fconcat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fconcat.stderr?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -16,15 +16,15 @@ error: expected a literal\n LL |     concat!(foo);\n    |             ^^^\n    |\n-   = note: only literals (like `\"foo\"`, `42` and `3.14`) can be passed to `concat!()`\n+   = note: only literals (like `\"foo\"`, `-42` and `3.14`) can be passed to `concat!()`\n \n error: expected a literal\n   --> $DIR/concat.rs:5:13\n    |\n LL |     concat!(foo());\n    |             ^^^^^\n    |\n-   = note: only literals (like `\"foo\"`, `42` and `3.14`) can be passed to `concat!()`\n+   = note: only literals (like `\"foo\"`, `-42` and `3.14`) can be passed to `concat!()`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "7bbd3d68a900eb2ff4d0783a2aa647270b72c0ee", "filename": "tests/ui/macros/issue-106837.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fmacros%2Fissue-106837.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fmacros%2Fissue-106837.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fissue-106837.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    concat!(-42);\n+    concat!(-3.14);\n+\n+    concat!(-\"hello\");\n+    //~^ ERROR expected a literal\n+\n+    concat!(--1);\n+    //~^ ERROR expected a literal\n+}"}, {"sha": "998d6c5eb6f2b2df9f2ba993a45161b6bda3c451", "filename": "tests/ui/macros/issue-106837.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fmacros%2Fissue-106837.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fmacros%2Fissue-106837.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fissue-106837.stderr?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -0,0 +1,18 @@\n+error: expected a literal\n+  --> $DIR/issue-106837.rs:5:13\n+   |\n+LL |     concat!(-\"hello\");\n+   |             ^^^^^^^^\n+   |\n+   = note: only literals (like `\"foo\"`, `-42` and `3.14`) can be passed to `concat!()`\n+\n+error: expected a literal\n+  --> $DIR/issue-106837.rs:8:13\n+   |\n+LL |     concat!(--1);\n+   |             ^^^\n+   |\n+   = note: only literals (like `\"foo\"`, `-42` and `3.14`) can be passed to `concat!()`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "8fe6fc41d10b77435e0e39bb330d9de117bc7f13", "filename": "tests/ui/macros/issue-98790.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fmacros%2Fissue-98790.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fmacros%2Fissue-98790.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fissue-98790.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+\n+macro_rules! stringify_item {\n+    ($item:item) => {\n+        stringify!($item)\n+    };\n+}\n+\n+macro_rules! repro {\n+    ($expr:expr) => {\n+        stringify_item! {\n+            pub fn repro() -> bool {\n+                $expr\n+            }\n+        }\n+    };\n+}\n+\n+fn main() {\n+    assert_eq!(\n+        repro!(match () { () => true } | true),\n+        \"pub fn repro() -> bool { (match () { () => true, }) | true }\"\n+    );\n+}"}, {"sha": "39ba1714cc70b4e16a17adddf7952174b20c9dc6", "filename": "tests/ui/macros/rfc-2011-nicer-assert-messages/all-expr-kinds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -164,7 +164,7 @@ fn main() {\n     // mac call\n \n     // match\n-    [ match elem { _ => elem } == 3 ] => \"Assertion failed: match elem { _ => elem, } == 3\"\n+    [ match elem { _ => elem } == 3 ] => \"Assertion failed: (match elem { _ => elem, }) == 3\"\n \n     // ret\n     [ (|| { return elem; })() == 3 ] => \"Assertion failed: (|| { return elem; })() == 3\""}, {"sha": "c4651ec717787edd9faf1e4e4282554e9682de0c", "filename": "tests/ui/self/arbitrary_self_types_trait.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fself%2Farbitrary_self_types_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fself%2Farbitrary_self_types_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself%2Farbitrary_self_types_trait.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_allocation)]\n \n use std::rc::Rc;\n \n@@ -13,7 +14,7 @@ impl Trait for Vec<i32> {\n }\n \n fn main() {\n-    let v = vec![1,2,3];\n+    let v = vec![1, 2, 3];\n \n-    assert_eq!(&[1,2,3], Box::new(Rc::new(v)).trait_method());\n+    assert_eq!(&[1, 2, 3], Box::new(Rc::new(v)).trait_method());\n }"}, {"sha": "54092542f98fae143ce38e0124524c0755ef5ec5", "filename": "tests/ui/structs-enums/align-struct.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fstructs-enums%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a73f50d875840b8077b8ec080fa41881d7ce40d/tests%2Fui%2Fstructs-enums%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs-enums%2Falign-struct.rs?ref=8a73f50d875840b8077b8ec080fa41881d7ce40d", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-#![allow(dead_code)]\n+#![allow(dead_code, unused_allocation)]\n \n use std::mem;\n \n@@ -20,7 +20,6 @@ struct AlignMany(i32);\n \n // Raising alignment may not alter size.\n #[repr(align(8))]\n-#[allow(dead_code)]\n struct Align8Many {\n     a: i32,\n     b: i32,\n@@ -29,9 +28,8 @@ struct Align8Many {\n }\n \n enum Enum {\n-    #[allow(dead_code)]\n     A(i32),\n-    B(Align16)\n+    B(Align16),\n }\n \n // Nested alignment - use `#[repr(C)]` to suppress field reordering for sizeof test\n@@ -73,7 +71,7 @@ struct AlignLarge {\n \n union UnionContainsAlign {\n     a: Align16,\n-    b: f32\n+    b: f32,\n }\n \n impl Align16 {\n@@ -158,7 +156,7 @@ pub fn main() {\n     // Note that the size of Nested may change if struct field re-ordering is enabled\n     assert_eq!(mem::align_of::<Nested>(), 16);\n     assert_eq!(mem::size_of::<Nested>(), 48);\n-    let a = Nested{ a: 1, b: 2, c: Align16(3), d: 4};\n+    let a = Nested { a: 1, b: 2, c: Align16(3), d: 4 };\n     assert_eq!(mem::align_of_val(&a), 16);\n     assert_eq!(mem::align_of_val(&a.b), 4);\n     assert_eq!(mem::align_of_val(&a.c), 16);\n@@ -179,8 +177,8 @@ pub fn main() {\n             assert_eq!(a.0, 15);\n             assert_eq!(mem::align_of_val(a), 16);\n             assert_eq!(mem::size_of_val(a), 16);\n-        },\n-        _ => ()\n+        }\n+        _ => (),\n     }\n     assert!(is_aligned_to(&e, 16));\n \n@@ -197,8 +195,8 @@ pub fn main() {\n     }\n \n     // arrays of aligned elements should also be aligned\n-    assert_eq!(mem::align_of::<[Align16;2]>(), 16);\n-    assert_eq!(mem::size_of::<[Align16;2]>(), 32);\n+    assert_eq!(mem::align_of::<[Align16; 2]>(), 16);\n+    assert_eq!(mem::size_of::<[Align16; 2]>(), 32);\n \n     let a = [Align16(0), Align16(1)];\n     assert_eq!(mem::align_of_val(&a[0]), 16);\n@@ -209,7 +207,7 @@ pub fn main() {\n     assert_eq!(mem::align_of_val(Box::new(Align16(0)).as_ref()), 16);\n \n     // check heap array is aligned\n-    let a = vec!(Align16(0), Align16(1));\n+    let a = vec![Align16(0), Align16(1)];\n     assert_eq!(mem::align_of_val(&a[0]), 16);\n     assert_eq!(mem::align_of_val(&a[1]), 16);\n \n@@ -224,16 +222,14 @@ pub fn main() {\n \n     assert_eq!(mem::align_of::<AlignContainsPacked4C>(), 16);\n     assert_eq!(mem::size_of::<AlignContainsPacked4C>(), 32);\n-    let a = AlignContainsPacked4C { a: Packed4C{ a: 1, b: 2 }, b: 3 };\n+    let a = AlignContainsPacked4C { a: Packed4C { a: 1, b: 2 }, b: 3 };\n     assert_eq!(mem::align_of_val(&a), 16);\n     assert_eq!(mem::align_of_val(&a.a), 4);\n     assert_eq!(mem::align_of_val(&a.b), mem::align_of::<u64>());\n     assert_eq!(mem::size_of_val(&a), 32);\n     assert!(is_aligned_to(&a, 16));\n \n-    let mut large = Box::new(AlignLarge {\n-        stuff: [0; 0x10000],\n-    });\n+    let mut large = Box::new(AlignLarge { stuff: [0; 0x10000] });\n     large.stuff[0] = 132;\n     *large.stuff.last_mut().unwrap() = 102;\n     assert_eq!(large.stuff[0], 132);"}]}