{"sha": "86b6e6e2f5529cc7c806622fabc5ea56f49a3316", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YjZlNmUyZjU1MjljYzdjODA2NjIyZmFiYzVlYTU2ZjQ5YTMzMTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-10T17:10:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-11T18:37:45Z"}, "message": "Add simple control-flow-graph abstraction based on graph, currently unused", "tree": {"sha": "9db0fc3f16ee1e4ad27084fee93a9c182023044b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9db0fc3f16ee1e4ad27084fee93a9c182023044b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86b6e6e2f5529cc7c806622fabc5ea56f49a3316", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86b6e6e2f5529cc7c806622fabc5ea56f49a3316", "html_url": "https://github.com/rust-lang/rust/commit/86b6e6e2f5529cc7c806622fabc5ea56f49a3316", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86b6e6e2f5529cc7c806622fabc5ea56f49a3316/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2fbe4d09a37f89285a0b0de41d3c076ecf298b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2fbe4d09a37f89285a0b0de41d3c076ecf298b8", "html_url": "https://github.com/rust-lang/rust/commit/a2fbe4d09a37f89285a0b0de41d3c076ecf298b8"}], "stats": {"total": 586, "additions": 586, "deletions": 0}, "files": [{"sha": "9ecb4dcaf5e9f01b218c0eecde1540bd43aa32ef", "filename": "src/librustc/middle/cfg/construct.rs", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/86b6e6e2f5529cc7c806622fabc5ea56f49a3316/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b6e6e2f5529cc7c806622fabc5ea56f49a3316/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=86b6e6e2f5529cc7c806622fabc5ea56f49a3316", "patch": "@@ -0,0 +1,523 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::cfg::*;\n+use middle::graph;\n+use middle::typeck;\n+use middle::ty;\n+use std::hashmap::HashMap;\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::opt_vec;\n+\n+struct CFGBuilder {\n+    tcx: ty::ctxt,\n+    method_map: typeck::method_map,\n+    exit_map: HashMap<ast::node_id, CFGIndex>,\n+    graph: CFGGraph,\n+    loop_scopes: ~[LoopScope],\n+}\n+\n+struct LoopScope {\n+    loop_id: ast::node_id,    // id of loop/while node\n+    continue_index: CFGIndex, // where to go on a `loop`\n+    break_index: CFGIndex,    // where to go on a `break\n+}\n+\n+pub fn construct(tcx: ty::ctxt,\n+                 method_map: typeck::method_map,\n+                 blk: &ast::blk) -> CFG {\n+    let mut cfg_builder = CFGBuilder {\n+        exit_map: HashMap::new(),\n+        graph: graph::Graph::new(),\n+        tcx: tcx,\n+        method_map: method_map,\n+        loop_scopes: ~[]\n+    };\n+    let entry = cfg_builder.add_node(0, []);\n+    let exit = cfg_builder.block(blk, entry);\n+    let CFGBuilder {exit_map, graph, _} = cfg_builder;\n+    CFG {exit_map: exit_map,\n+         graph: graph,\n+         entry: entry,\n+         exit: exit}\n+}\n+\n+impl CFGBuilder {\n+    fn block(&mut self, blk: &ast::blk, pred: CFGIndex) -> CFGIndex {\n+        let mut stmts_exit = pred;\n+        for blk.node.stmts.iter().advance |&stmt| {\n+            stmts_exit = self.stmt(stmt, stmts_exit);\n+        }\n+\n+        let expr_exit = self.opt_expr(blk.node.expr, stmts_exit);\n+\n+        self.add_node(blk.node.id, [expr_exit])\n+    }\n+\n+    fn stmt(&mut self, stmt: @ast::stmt, pred: CFGIndex) -> CFGIndex {\n+        match stmt.node {\n+            ast::stmt_decl(decl, _) => {\n+                self.decl(decl, pred)\n+            }\n+\n+            ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n+                self.expr(expr, pred)\n+            }\n+\n+            ast::stmt_mac(*) => {\n+                self.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n+            }\n+        }\n+    }\n+\n+    fn decl(&mut self, decl: @ast::decl, pred: CFGIndex) -> CFGIndex {\n+        match decl.node {\n+            ast::decl_local(local) => {\n+                let init_exit = self.opt_expr(local.node.init, pred);\n+                self.pat(local.node.pat, init_exit)\n+            }\n+\n+            ast::decl_item(_) => {\n+                pred\n+            }\n+        }\n+    }\n+\n+    fn pat(&mut self, pat: @ast::pat, pred: CFGIndex) -> CFGIndex {\n+        match pat.node {\n+            ast::pat_ident(_, _, None) |\n+            ast::pat_enum(_, None) |\n+            ast::pat_lit(*) |\n+            ast::pat_range(*) |\n+            ast::pat_wild => {\n+                self.add_node(pat.id, [pred])\n+            }\n+\n+            ast::pat_box(subpat) |\n+            ast::pat_uniq(subpat) |\n+            ast::pat_region(subpat) |\n+            ast::pat_ident(_, _, Some(subpat)) => {\n+                let subpat_exit = self.pat(subpat, pred);\n+                self.add_node(pat.id, [subpat_exit])\n+            }\n+\n+            ast::pat_enum(_, Some(ref subpats)) |\n+            ast::pat_tup(ref subpats) => {\n+                let pats_exit =\n+                    self.pats_all(subpats.iter().transform(|p| *p), pred);\n+                self.add_node(pat.id, [pats_exit])\n+            }\n+\n+            ast::pat_struct(_, ref subpats, _) => {\n+                let pats_exit =\n+                    self.pats_all(subpats.iter().transform(|f| f.pat), pred);\n+                self.add_node(pat.id, [pats_exit])\n+            }\n+\n+            ast::pat_vec(ref pre, ref vec, ref post) => {\n+                let pre_exit =\n+                    self.pats_all(pre.iter().transform(|p| *p), pred);\n+                let vec_exit =\n+                    self.pats_all(vec.iter().transform(|p| *p), pre_exit);\n+                let post_exit =\n+                    self.pats_all(post.iter().transform(|p| *p), vec_exit);\n+                self.add_node(pat.id, [post_exit])\n+            }\n+        }\n+    }\n+\n+    fn pats_all<I: Iterator<@ast::pat>>(&mut self,\n+                                        pats: I,\n+                                        pred: CFGIndex) -> CFGIndex {\n+        //! Handles case where all of the patterns must match.\n+        let mut pats = pats;\n+        pats.fold(pred, |pred, pat| self.pat(pat, pred))\n+    }\n+\n+    fn pats_any(&mut self,\n+                pats: &[@ast::pat],\n+                pred: CFGIndex) -> CFGIndex {\n+        //! Handles case where just one of the patterns must match.\n+\n+        if pats.len() == 1 {\n+            self.pat(pats[0], pred)\n+        } else {\n+            let collect = self.add_dummy_node([]);\n+            for pats.iter().advance |&pat| {\n+                let pat_exit = self.pat(pat, pred);\n+                self.add_contained_edge(pat_exit, collect);\n+            }\n+            collect\n+        }\n+    }\n+\n+    fn expr(&mut self, expr: @ast::expr, pred: CFGIndex) -> CFGIndex {\n+        match expr.node {\n+            ast::expr_block(ref blk) => {\n+                let blk_exit = self.block(blk, pred);\n+                self.add_node(expr.id, [blk_exit])\n+            }\n+\n+            ast::expr_if(cond, ref then, None) => {\n+                //\n+                //     [pred]\n+                //       |\n+                //       v 1\n+                //     [cond]\n+                //       |\n+                //      / \\\n+                //     /   \\\n+                //    v 2   *\n+                //  [then]  |\n+                //    |     |\n+                //    v 3   v 4\n+                //   [..expr..]\n+                //\n+                let cond_exit = self.expr(cond, pred);                // 1\n+                let then_exit = self.block(then, cond_exit);          // 2\n+                self.add_node(expr.id, [cond_exit, then_exit])        // 3,4\n+            }\n+\n+            ast::expr_if(cond, ref then, Some(otherwise)) => {\n+                //\n+                //     [pred]\n+                //       |\n+                //       v 1\n+                //     [cond]\n+                //       |\n+                //      / \\\n+                //     /   \\\n+                //    v 2   v 3\n+                //  [then][otherwise]\n+                //    |     |\n+                //    v 4   v 5\n+                //   [..expr..]\n+                //\n+                let cond_exit = self.expr(cond, pred);                // 1\n+                let then_exit = self.block(then, cond_exit);          // 2\n+                let else_exit = self.expr(otherwise, cond_exit);      // 3\n+                self.add_node(expr.id, [then_exit, else_exit])        // 4, 5\n+            }\n+\n+            ast::expr_while(cond, ref body) => {\n+                //\n+                //         [pred]\n+                //           |\n+                //           v 1\n+                //       [loopback] <--+ 5\n+                //           |         |\n+                //           v 2       |\n+                //   +-----[cond]      |\n+                //   |       |         |\n+                //   |       v 4       |\n+                //   |     [body] -----+\n+                //   v 3\n+                // [expr]\n+                //\n+                // Note that `break` and `loop` statements\n+                // may cause additional edges.\n+\n+                // NOTE: Is the condition considered part of the loop?\n+                let loopback = self.add_dummy_node([pred]);           // 1\n+                let cond_exit = self.expr(cond, loopback);            // 2\n+                let expr_exit = self.add_node(expr.id, [cond_exit]);  // 3\n+                self.loop_scopes.push(LoopScope {\n+                    loop_id: expr.id,\n+                    continue_index: loopback,\n+                    break_index: expr_exit\n+                });\n+                let body_exit = self.block(body, cond_exit);          // 4\n+                self.add_contained_edge(body_exit, loopback);         // 5\n+                expr_exit\n+            }\n+\n+            ast::expr_loop(ref body, _) => {\n+                //\n+                //     [pred]\n+                //       |\n+                //       v 1\n+                //   [loopback] <---+\n+                //       |      4   |\n+                //       v 3        |\n+                //     [body] ------+\n+                //\n+                //     [expr] 2\n+                //\n+                // Note that `break` and `loop` statements\n+                // may cause additional edges.\n+\n+                let loopback = self.add_dummy_node([pred]);           // 1\n+                let expr_exit = self.add_node(expr.id, []);           // 2\n+                self.loop_scopes.push(LoopScope {\n+                    loop_id: expr.id,\n+                    continue_index: loopback,\n+                    break_index: expr_exit,\n+                });\n+                let body_exit = self.block(body, loopback);           // 3\n+                self.add_contained_edge(body_exit, loopback);         // 4\n+                self.loop_scopes.pop();\n+                expr_exit\n+            }\n+\n+            ast::expr_match(discr, ref arms) => {\n+                //\n+                //     [pred]\n+                //       |\n+                //       v 1\n+                //    [discr]\n+                //       |\n+                //       v 2\n+                //    [guard1]\n+                //      /  \\\n+                //     |    \\\n+                //     v 3  |\n+                //  [pat1]  |\n+                //     |\n+                //     v 4  |\n+                // [body1]  v\n+                //     |  [guard2]\n+                //     |    /   \\\n+                //     | [body2] \\\n+                //     |    |   ...\n+                //     |    |    |\n+                //     v 5  v    v\n+                //   [....expr....]\n+                //\n+                let discr_exit = self.expr(discr, pred);                 // 1\n+\n+                let expr_exit = self.add_node(expr.id, []);\n+                let mut guard_exit = discr_exit;\n+                for arms.iter().advance |arm| {\n+                    guard_exit = self.opt_expr(arm.guard, guard_exit); // 2\n+                    let pats_exit = self.pats_any(arm.pats, guard_exit); // 3\n+                    let body_exit = self.block(&arm.body, pats_exit);    // 4\n+                    self.add_contained_edge(body_exit, expr_exit);       // 5\n+                }\n+                expr_exit\n+            }\n+\n+            ast::expr_binary(_, op, l, r) if ast_util::lazy_binop(op) => {\n+                //\n+                //     [pred]\n+                //       |\n+                //       v 1\n+                //      [l]\n+                //       |\n+                //      / \\\n+                //     /   \\\n+                //    v 2  *\n+                //   [r]   |\n+                //    |    |\n+                //    v 3  v 4\n+                //   [..exit..]\n+                //\n+                let l_exit = self.expr(l, pred);                         // 1\n+                let r_exit = self.expr(r, l_exit);                       // 2\n+                self.add_node(expr.id, [l_exit, r_exit])                 // 3,4\n+            }\n+\n+            ast::expr_ret(v) => {\n+                let v_exit = self.opt_expr(v, pred);\n+                let loop_scope = self.loop_scopes[0];\n+                self.add_exiting_edge(expr, v_exit,\n+                                      loop_scope, loop_scope.break_index);\n+                self.add_node(expr.id, [])\n+            }\n+\n+            ast::expr_break(label) => {\n+                let loop_scope = self.find_scope(expr, label);\n+                self.add_exiting_edge(expr, pred,\n+                                      loop_scope, loop_scope.break_index);\n+                self.add_node(expr.id, [])\n+            }\n+\n+            ast::expr_again(label) => {\n+                let loop_scope = self.find_scope(expr, label);\n+                self.add_exiting_edge(expr, pred,\n+                                      loop_scope, loop_scope.continue_index);\n+                self.add_node(expr.id, [])\n+            }\n+\n+            ast::expr_vec(ref elems, _) => {\n+                self.straightline(expr, pred, *elems)\n+            }\n+\n+            ast::expr_call(func, ref args, _) => {\n+                self.call(expr, pred, func, *args)\n+            }\n+\n+            ast::expr_method_call(_, rcvr, _, _, ref args, _) => {\n+                self.call(expr, pred, rcvr, *args)\n+            }\n+\n+            ast::expr_index(_, l, r) |\n+            ast::expr_binary(_, _, l, r) if self.is_method_call(expr) => {\n+                self.call(expr, pred, l, [r])\n+            }\n+\n+            ast::expr_unary(_, _, e) if self.is_method_call(expr) => {\n+                self.call(expr, pred, e, [])\n+            }\n+\n+            ast::expr_tup(ref exprs) => {\n+                self.straightline(expr, pred, *exprs)\n+            }\n+\n+            ast::expr_struct(_, ref fields, base) => {\n+                let base_exit = self.opt_expr(base, pred);\n+                let field_exprs: ~[@ast::expr] =\n+                    fields.iter().transform(|f| f.node.expr).collect();\n+                self.straightline(expr, base_exit, field_exprs)\n+            }\n+\n+            ast::expr_repeat(elem, count, _) => {\n+                self.straightline(expr, pred, [elem, count])\n+            }\n+\n+            ast::expr_assign(l, r) |\n+            ast::expr_assign_op(_, _, l, r) => {\n+                self.straightline(expr, pred, [r, l])\n+            }\n+\n+            ast::expr_log(l, r) |\n+            ast::expr_index(_, l, r) |\n+            ast::expr_binary(_, _, l, r) => { // NB: && and || handled earlier\n+                self.straightline(expr, pred, [l, r])\n+            }\n+\n+            ast::expr_addr_of(_, e) |\n+            ast::expr_copy(e) |\n+            ast::expr_loop_body(e) |\n+            ast::expr_do_body(e) |\n+            ast::expr_cast(e, _) |\n+            ast::expr_unary(_, _, e) |\n+            ast::expr_paren(e) |\n+            ast::expr_vstore(e, _) |\n+            ast::expr_field(e, _, _) => {\n+                self.straightline(expr, pred, [e])\n+            }\n+\n+            ast::expr_mac(*) |\n+            ast::expr_inline_asm(*) |\n+            ast::expr_self |\n+            ast::expr_fn_block(*) |\n+            ast::expr_lit(*) |\n+            ast::expr_path(*) => {\n+                self.straightline(expr, pred, [])\n+            }\n+        }\n+    }\n+\n+    fn call(&mut self,\n+            call_expr: @ast::expr,\n+            pred: CFGIndex,\n+            func_or_rcvr: @ast::expr,\n+            args: &[@ast::expr]) -> CFGIndex {\n+        let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n+        self.straightline(call_expr, func_or_rcvr_exit, args)\n+    }\n+\n+    fn exprs(&mut self,\n+             exprs: &[@ast::expr],\n+             pred: CFGIndex) -> CFGIndex {\n+        //! Constructs graph for `exprs` evaluated in order\n+\n+        exprs.iter().fold(pred, |p, &e| self.expr(e, p))\n+    }\n+\n+    fn opt_expr(&mut self,\n+                opt_expr: Option<@ast::expr>,\n+                pred: CFGIndex) -> CFGIndex {\n+        //! Constructs graph for `opt_expr` evaluated, if Some\n+\n+        opt_expr.iter().fold(pred, |p, &e| self.expr(e, p))\n+    }\n+\n+    fn straightline(&mut self,\n+                    expr: @ast::expr,\n+                    pred: CFGIndex,\n+                    subexprs: &[@ast::expr]) -> CFGIndex {\n+        //! Handles case of an expression that evaluates `subexprs` in order\n+\n+        let subexprs_exit = self.exprs(subexprs, pred);\n+        self.add_node(expr.id, [subexprs_exit])\n+    }\n+\n+    fn add_dummy_node(&mut self, preds: &[CFGIndex]) -> CFGIndex {\n+        self.add_node(0, preds)\n+    }\n+\n+    fn add_node(&mut self, id: ast::node_id, preds: &[CFGIndex]) -> CFGIndex {\n+        assert!(!self.exit_map.contains_key(&id));\n+        let node = self.graph.add_node(CFGNodeData {id: id});\n+        self.exit_map.insert(id, node);\n+        for preds.iter().advance |&pred| {\n+            self.add_contained_edge(pred, node);\n+        }\n+        node\n+    }\n+\n+    fn add_contained_edge(&mut self,\n+                          source: CFGIndex,\n+                          target: CFGIndex) {\n+        let data = CFGEdgeData {exiting_scopes: opt_vec::Empty};\n+        self.graph.add_edge(source, target, data);\n+    }\n+\n+    fn add_exiting_edge(&mut self,\n+                        from_expr: @ast::expr,\n+                        from_index: CFGIndex,\n+                        to_loop: LoopScope,\n+                        to_index: CFGIndex) {\n+        let mut data = CFGEdgeData {exiting_scopes: opt_vec::Empty};\n+        let mut scope_id = from_expr.id;\n+        while scope_id != to_loop.loop_id {\n+            data.exiting_scopes.push(scope_id);\n+            scope_id = self.tcx.region_maps.encl_scope(scope_id);\n+        }\n+        self.graph.add_edge(from_index, to_index, data);\n+    }\n+\n+    fn find_scope(&self,\n+                  expr: @ast::expr,\n+                  label: Option<ast::ident>) -> LoopScope {\n+        match label {\n+            None => {\n+                return *self.loop_scopes.last();\n+            }\n+\n+            Some(_) => {\n+                match self.tcx.def_map.find(&expr.id) {\n+                    Some(&ast::def_label(loop_id)) => {\n+                        for self.loop_scopes.iter().advance |l| {\n+                            if l.loop_id == loop_id {\n+                                return *l;\n+                            }\n+                        }\n+                        self.tcx.sess.span_bug(\n+                            expr.span,\n+                            fmt!(\"No loop scope for id %?\", loop_id));\n+                    }\n+\n+                    r => {\n+                        self.tcx.sess.span_bug(\n+                            expr.span,\n+                            fmt!(\"Bad entry `%?` in def_map for label\", r));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn is_method_call(&self, expr: &ast::expr) -> bool {\n+        self.method_map.contains_key(&expr.id)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "68aee78f28fe451477dd21199ea468148ee067a1", "filename": "src/librustc/middle/cfg/mod.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/86b6e6e2f5529cc7c806622fabc5ea56f49a3316/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b6e6e2f5529cc7c806622fabc5ea56f49a3316/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=86b6e6e2f5529cc7c806622fabc5ea56f49a3316", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Module that constructs a control-flow graph representing an item.\n+Uses `Graph` as the underlying representation.\n+\n+*/\n+\n+use middle::graph;\n+use middle::ty;\n+use middle::typeck;\n+use std::hashmap::HashMap;\n+use syntax::ast;\n+use syntax::opt_vec::OptVec;\n+\n+mod construct;\n+\n+pub struct CFG {\n+    exit_map: HashMap<ast::node_id, CFGIndex>,\n+    graph: CFGGraph,\n+    entry: CFGIndex,\n+    exit: CFGIndex,\n+}\n+\n+pub struct CFGNodeData {\n+    id: ast::node_id\n+}\n+\n+pub struct CFGEdgeData {\n+    exiting_scopes: OptVec<ast::node_id>\n+}\n+\n+pub type CFGIndex = graph::NodeIndex;\n+\n+pub type CFGGraph = graph::Graph<CFGNodeData, CFGEdgeData>;\n+\n+pub type CFGNode = graph::Node<CFGNodeData>;\n+\n+pub type CFGEdge = graph::Edge<CFGEdgeData>;\n+\n+pub struct CFGIndices {\n+    entry: CFGIndex,\n+    exit: CFGIndex,\n+}\n+\n+impl CFG {\n+    pub fn new(tcx: ty::ctxt,\n+               method_map: typeck::method_map,\n+               blk: &ast::blk) -> CFG {\n+        construct::construct(tcx, method_map, blk)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "542183e24db7632fef35d4925b4e2d577c836f8d", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86b6e6e2f5529cc7c806622fabc5ea56f49a3316/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b6e6e2f5529cc7c806622fabc5ea56f49a3316/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=86b6e6e2f5529cc7c806622fabc5ea56f49a3316", "patch": "@@ -75,6 +75,8 @@ pub mod middle {\n     pub mod effect;\n     pub mod reachable;\n     pub mod graph;\n+    #[path = \"cfg/mod.rs\"]\n+    pub mod cfg;\n }\n \n pub mod front {"}]}