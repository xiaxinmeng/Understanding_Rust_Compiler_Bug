{"sha": "89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZDVkMjQ0OGQ1NzQ1NzdlNjc3MmRiZmVmMGZmNWIxZDFlMGQyMzg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-24T06:56:01Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-24T06:56:01Z"}, "message": "Rollup merge of #22213 - eddyb:ty_open-case-closed, r=nikomatsakis\n\n This type wasn't necessary, as there was no place using it and unsized types not wrapped in it, at the same time.\nr? @nikomatsakis", "tree": {"sha": "b2d589c4a659ff2b3a45fe0020acd0ec6744cfa7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2d589c4a659ff2b3a45fe0020acd0ec6744cfa7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "html_url": "https://github.com/rust-lang/rust/commit/89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e711ac7e759b7668932b3d6a612ba7b1600e5234", "url": "https://api.github.com/repos/rust-lang/rust/commits/e711ac7e759b7668932b3d6a612ba7b1600e5234", "html_url": "https://github.com/rust-lang/rust/commit/e711ac7e759b7668932b3d6a612ba7b1600e5234"}, {"sha": "8659de0334208ccb6b3a4929109275857da84e81", "url": "https://api.github.com/repos/rust-lang/rust/commits/8659de0334208ccb6b3a4929109275857da84e81", "html_url": "https://github.com/rust-lang/rust/commit/8659de0334208ccb6b3a4929109275857da84e81"}], "stats": {"total": 504, "additions": 184, "deletions": 320}, "files": [{"sha": "11609ebe675efa8522265339ad71d4463828eae0", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -153,9 +153,6 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         ty::ty_err => {\n             mywrite!(w, \"e\");\n         }\n-        ty::ty_open(_) => {\n-            cx.diag.handler().bug(\"unexpected type in enc_sty (ty_open)\");\n-        }\n     }\n \n     let end = w.tell().unwrap();"}, {"sha": "7584a2e44cc7c0b3316be2718c153705e530ec03", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -93,7 +93,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n                 None\n             }\n         }\n-        ty::ty_open(_) | ty::ty_infer(_) | ty::ty_err => None,\n+        ty::ty_infer(_) | ty::ty_err => None,\n     }\n }\n "}, {"sha": "e41b949d5df1d75cb98d80b57fccc83bb79a76eb", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -135,7 +135,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                 t\n             }\n \n-            ty::ty_open(..) |\n             ty::ty_bool |\n             ty::ty_char |\n             ty::ty_int(..) |"}, {"sha": "4d45bb841f49ff0cecf1d999366c8a73b8110236", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -194,7 +194,6 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n \n         ty::ty_closure(..) |\n         ty::ty_infer(..) |\n-        ty::ty_open(..) |\n         ty::ty_err => {\n             tcx.sess.bug(\n                 &format!(\"ty_is_local invoked on unexpected type: {}\","}, {"sha": "d42fd987ba89c1135e1f63dc9e5bb1caf3b3847a", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -1626,25 +1626,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(AmbiguousBuiltin)\n             }\n \n-            ty::ty_open(ty) => {\n-                // these only crop up in trans, and represent an\n-                // \"opened\" unsized/existential type (one that has\n-                // been dereferenced)\n-                match bound {\n-                    ty::BoundCopy => {\n-                        Ok(If(vec!(ty)))\n-                    }\n-\n-                    ty::BoundSized => {\n-                        Err(Unimplemented)\n-                    }\n-\n-                    ty::BoundSync |\n-                    ty::BoundSend => {\n-                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-                }\n-            }\n             ty::ty_err => {\n                 Ok(If(Vec::new()))\n             }"}, {"sha": "3d059e27c5207d4cf5f0f3dd30e8211323b75ddc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 40, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -930,7 +930,7 @@ impl<'tcx> ctxt<'tcx> {\n         sty_debug_print!(\n             self,\n             ty_enum, ty_uniq, ty_vec, ty_ptr, ty_rptr, ty_bare_fn, ty_trait,\n-            ty_struct, ty_closure, ty_tup, ty_param, ty_open, ty_infer, ty_projection);\n+            ty_struct, ty_closure, ty_tup, ty_param, ty_infer, ty_projection);\n \n         println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n@@ -1374,12 +1374,6 @@ pub enum sty<'tcx> {\n     ty_projection(ProjectionTy<'tcx>),\n     ty_param(ParamTy), // type parameter\n \n-    ty_open(Ty<'tcx>), // A deref'ed fat pointer, i.e., a dynamically sized value\n-                       // and its size. Only ever used in trans. It is not necessary\n-                       // earlier since we don't need to distinguish a DST with its\n-                       // size (e.g., in a deref) vs a DST with the size elsewhere (\n-                       // e.g., in a field).\n-\n     ty_infer(InferTy), // something used only during inference/typeck\n     ty_err, // Also only used during inference/typeck, to represent\n             // the type of an erroneous expression (helps cut down\n@@ -2689,7 +2683,7 @@ impl FlagComputation {\n                 self.add_bounds(bounds);\n             }\n \n-            &ty_uniq(tt) | &ty_vec(tt, _) | &ty_open(tt) => {\n+            &ty_uniq(tt) | &ty_vec(tt, _) => {\n                 self.add_ty(tt)\n             }\n \n@@ -2964,8 +2958,6 @@ pub fn mk_param_from_def<'tcx>(cx: &ctxt<'tcx>, def: &TypeParameterDef) -> Ty<'t\n     mk_param(cx, def.space, def.index, def.name)\n }\n \n-pub fn mk_open<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_open(ty)) }\n-\n impl<'tcx> TyS<'tcx> {\n     /// Iterator that walks `self` and any types reachable from\n     /// `self`, in depth-first order. Note that just walks the types\n@@ -3164,7 +3156,6 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_vec(ty, _) => ty,\n         ty_str => mk_mach_uint(cx, ast::TyU8),\n-        ty_open(ty) => sequence_element_type(cx, ty),\n         _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n                                  ty_to_string(cx, ty))),\n     }\n@@ -3583,12 +3574,6 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 TC::All\n             }\n \n-            ty_open(ty) => {\n-                let result = tc_ty(cx, ty, cache);\n-                assert!(!result.is_sized(cx));\n-                result.unsafe_pointer() | TC::Nonsized\n-            }\n-\n             ty_infer(_) |\n             ty_err => {\n                 cx.sess.bug(\"asked to compute contents of error type\");\n@@ -3747,7 +3732,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             ty_vec(_, None) => {\n                 false\n             }\n-            ty_uniq(typ) | ty_open(typ) => {\n+            ty_uniq(typ) => {\n                 type_requires(cx, seen, r_ty, typ)\n             }\n             ty_rptr(_, ref mt) => {\n@@ -4106,14 +4091,6 @@ pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n     }\n }\n \n-pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.sty {\n-        ty_open(ty) => mk_rptr(cx, cx.mk_region(ReStatic), mt {ty: ty, mutbl:ast::MutImmutable}),\n-        _ => cx.sess.bug(&format!(\"Trying to close a non-open type {}\",\n-                                 ty_to_string(cx, ty)))\n-    }\n-}\n-\n pub fn type_content<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_uniq(ty) => ty,\n@@ -4122,14 +4099,6 @@ pub fn type_content<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     }\n }\n \n-// Extract the unsized type in an open type (or just return ty if it is not open).\n-pub fn unopen_type<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.sty {\n-        ty_open(ty) => ty,\n-        _ => ty\n-    }\n-}\n-\n // Returns the type of ty[i]\n pub fn index<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match ty.sty {\n@@ -4802,7 +4771,6 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n             }\n         }\n         ty_err => \"type error\".to_string(),\n-        ty_open(_) => \"opened DST\".to_string(),\n     }\n }\n \n@@ -6328,16 +6296,15 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                     hash!(p.idx);\n                     hash!(token::get_name(p.name));\n                 }\n-                ty_open(_) => byte!(22),\n                 ty_infer(_) => unreachable!(),\n-                ty_err => byte!(23),\n+                ty_err => byte!(21),\n                 ty_closure(d, r, _) => {\n-                    byte!(24);\n+                    byte!(22);\n                     did(state, d);\n                     region(state, *r);\n                 }\n                 ty_projection(ref data) => {\n-                    byte!(25);\n+                    byte!(23);\n                     did(state, data.trait_ref.def_id);\n                     hash!(token::get_name(data.item_name));\n                 }\n@@ -6666,7 +6633,6 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_projection(_) |\n             ty_param(_) |\n             ty_infer(_) |\n-            ty_open(_) |\n             ty_err => {\n             }\n         }"}, {"sha": "d2469c052ac51348aa613fa42023c3a332f7ccc5", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -626,9 +626,6 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n         ty::ty_vec(typ, sz) => {\n             ty::ty_vec(typ.fold_with(this), sz)\n         }\n-        ty::ty_open(typ) => {\n-            ty::ty_open(typ.fold_with(this))\n-        }\n         ty::ty_enum(tid, ref substs) => {\n             let substs = substs.fold_with(this);\n             ty::ty_enum(tid, this.tcx().mk_substs(substs))"}, {"sha": "3336e7ee8bf71e6186107a989782913d8dd13f2f", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -28,7 +28,7 @@ impl<'tcx> TypeWalker<'tcx> {\n             ty::ty_bool | ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n             ty::ty_str | ty::ty_infer(_) | ty::ty_param(_) | ty::ty_err => {\n             }\n-            ty::ty_uniq(ty) | ty::ty_vec(ty, _) | ty::ty_open(ty) => {\n+            ty::ty_uniq(ty) | ty::ty_vec(ty, _) => {\n                 self.stack.push(ty);\n             }\n             ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {"}, {"sha": "15b3c6d9d0602c7ed65a0ce39c560de1e99f4414", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -20,7 +20,7 @@ use middle::ty::{ReSkolemized, ReVar, BrEnv};\n use middle::ty::{mt, Ty, ParamTy};\n use middle::ty::{ty_bool, ty_char, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn};\n-use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n+use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup};\n use middle::ty::{ty_closure};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n@@ -369,8 +369,6 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             buf.push_str(&mt_to_string(cx, tm));\n             buf\n         }\n-        ty_open(typ) =>\n-            format!(\"opened<{}>\", ty_to_string(cx, typ)),\n         ty_tup(ref elems) => {\n             let strs = elems\n                 .iter()"}, {"sha": "26e1a981f1bae25de1e722c0783e17af900126a9", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -678,7 +678,7 @@ fn bind_subslice_pat(bcx: Block,\n }\n \n fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 left_ty: Ty,\n+                                 left_ty: Ty<'tcx>,\n                                  before: uint,\n                                  after: uint,\n                                  val: ValueRef)"}, {"sha": "3ea14d3c58929dd5967c0a9893bb29a7e1233ca8", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -699,7 +699,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, st: &Struct<'tcx>,\n         st.fields.iter().filter(|&ty| !dst || type_is_sized(cx.tcx(), *ty))\n             .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n-        st.fields.iter().map(|&ty| type_of::type_of(cx, ty)).collect()\n+        st.fields.iter().map(|&ty| type_of::in_memory_type_of(cx, ty)).collect()\n     }\n }\n "}, {"sha": "b18b7b75d32fc1fc65acd2980779716b1d74ec33", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -676,8 +676,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                   let val = if common::type_is_sized(cx.tcx(), field_ty) {\n                       llfld_a\n                   } else {\n-                      let boxed_ty = ty::mk_open(cx.tcx(), field_ty);\n-                      let scratch = datum::rvalue_scratch_datum(cx, boxed_ty, \"__fat_ptr_iter\");\n+                      let scratch = datum::rvalue_scratch_datum(cx, field_ty, \"__fat_ptr_iter\");\n                       Store(cx, llfld_a, GEPi(cx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n                       Store(cx, info.unwrap(), GEPi(cx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n                       scratch.val"}, {"sha": "a3ba506fc46a2034b977589d18f3300cb6c89d56", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -120,14 +120,16 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n // Is the type's representation size known at compile time?\n pub fn type_is_sized<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     let param_env = ty::empty_parameter_environment(tcx);\n-    ty::type_is_sized(&param_env, DUMMY_SP, ty)\n-}\n-\n-pub fn lltype_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        ty::ty_open(_) => true,\n-        _ => type_is_sized(cx, ty),\n+    // FIXME(#4287) This can cause errors due to polymorphic recursion,\n+    // a better span should be provided, if available.\n+    let err_count = tcx.sess.err_count();\n+    let is_sized = ty::type_is_sized(&param_env, DUMMY_SP, ty);\n+    // Those errors aren't fatal, but an incorrect result can later\n+    // trip over asserts in both rustc's trans and LLVM.\n+    if err_count < tcx.sess.err_count() {\n+        tcx.sess.abort_if_errors();\n     }\n+    is_sized\n }\n \n pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -211,9 +213,7 @@ pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<\n     }\n }\n \n-pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>,\n-                         ty: Ty<'tcx>)\n-                         -> bool {\n+pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     ty::type_contents(cx, ty).needs_drop(cx)\n }\n "}, {"sha": "19046d84d6972f5b2ff4df293a9cd3271c801b01", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -146,8 +146,8 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 (const_deref_ptr(cx, v), mt.ty)\n             } else {\n                 // Derefing a fat pointer does not change the representation,\n-                // just the type to ty_open.\n-                (v, ty::mk_open(cx.tcx(), mt.ty))\n+                // just the type to the unsized contents.\n+                (v, mt.ty)\n             }\n         }\n         None => {\n@@ -290,15 +290,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         // an optimisation, it is necessary for mutable vectors to\n                         // work properly.\n                         ty = match ty::deref(ty, true) {\n-                            Some(mt) => {\n-                                if type_is_sized(cx.tcx(), mt.ty) {\n-                                    mt.ty\n-                                } else {\n-                                    // Derefing a fat pointer does not change the representation,\n-                                    // just the type to ty_open.\n-                                    ty::mk_open(cx.tcx(), mt.ty)\n-                                }\n-                            }\n+                            Some(mt) => mt.ty,\n                             None => {\n                                 cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n                                                        ty_to_string(cx.tcx(), ty)))\n@@ -319,11 +311,12 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     llconst = addr_of(cx, llconst, \"autoref\", e.id);\n                 }\n                 Some(box ty::AutoUnsize(ref k)) => {\n-                    let unsized_ty = ty::unsize_ty(cx.tcx(), ty, k, e.span);\n                     let info = expr::unsized_info(cx, k, e.id, ty, param_substs,\n                         |t| ty::mk_imm_rptr(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), t));\n \n-                    let base = ptrcast(llconst, type_of::type_of(cx, unsized_ty).ptr_to());\n+                    let unsized_ty = ty::unsize_ty(cx.tcx(), ty, k, e.span);\n+                    let ptr_ty = type_of::in_memory_type_of(cx, unsized_ty).ptr_to();\n+                    let base = ptrcast(llconst, ptr_ty);\n                     let prev_const = cx.const_unsized().borrow_mut()\n                                        .insert(base, llconst);\n                     assert!(prev_const.is_none() || prev_const == Some(llconst));\n@@ -477,16 +470,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               };\n               let (arr, len) = match bt.sty {\n                   ty::ty_vec(_, Some(u)) => (bv, C_uint(cx, u)),\n-                  ty::ty_open(ty) => match ty.sty {\n-                      ty::ty_vec(_, None) | ty::ty_str => {\n-                          let e1 = const_get_elt(cx, bv, &[0]);\n-                          (const_deref_ptr(cx, e1), const_get_elt(cx, bv, &[1]))\n-                      },\n-                      _ => cx.sess().span_bug(base.span,\n-                                              &format!(\"index-expr base must be a vector \\\n-                                                       or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt)))\n-                  },\n+                  ty::ty_vec(_, None) | ty::ty_str => {\n+                      let e1 = const_get_elt(cx, bv, &[0]);\n+                      (const_deref_ptr(cx, e1), const_get_elt(cx, bv, &[1]))\n+                  }\n                   ty::ty_rptr(_, mt) => match mt.ty.sty {\n                       ty::ty_vec(_, Some(u)) => {\n                           (const_deref_ptr(cx, bv), C_uint(cx, u))"}, {"sha": "8262dbf55ddaefe0ca376064cff207eb648c27d9", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -492,8 +492,6 @@ impl<'tcx> Datum<'tcx, Expr> {\n                                  -> DatumBlock<'blk, 'tcx, Lvalue> {\n         debug!(\"to_lvalue_datum self: {}\", self.to_string(bcx.ccx()));\n \n-        assert!(lltype_is_sized(bcx.tcx(), self.ty),\n-                \"Trying to convert unsized value to lval\");\n         self.match_kind(\n             |l| DatumBlock::new(bcx, l),\n             |r| {\n@@ -549,15 +547,10 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n                                 -> Datum<'tcx, Lvalue> where\n         F: FnOnce(ValueRef) -> ValueRef,\n     {\n-        let val = match self.ty.sty {\n-            _ if type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n-            ty::ty_open(_) => {\n-                let base = Load(bcx, expr::get_dataptr(bcx, self.val));\n-                gep(base)\n-            }\n-            _ => bcx.tcx().sess.bug(\n-                &format!(\"Unexpected unsized type in get_element: {}\",\n-                        bcx.ty_to_string(self.ty)))\n+        let val = if type_is_sized(bcx.tcx(), self.ty) {\n+            gep(self.val)\n+        } else {\n+            gep(Load(bcx, expr::get_dataptr(bcx, self.val)))\n         };\n         Datum {\n             val: val,\n@@ -566,7 +559,8 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n         }\n     }\n \n-    pub fn get_vec_base_and_len(&self, bcx: Block) -> (ValueRef, ValueRef) {\n+    pub fn get_vec_base_and_len<'blk>(&self, bcx: Block<'blk, 'tcx>)\n+                                      -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair.\n \n         tvec::get_base_and_len(bcx, self.val, self.ty)"}, {"sha": "162881f58c74e2a96a4fe18a9d4fb0e3361a1791", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -3828,7 +3828,6 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ty::ty_err |\n         ty::ty_infer(_) |\n-        ty::ty_open(_) |\n         ty::ty_projection(..) |\n         ty::ty_param(_) => {\n             cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\"}, {"sha": "9e9ee4537524b81bfc262027c61bb614c45296ad", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 27, "deletions": 39, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -451,8 +451,6 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let datum_ty = datum.ty;\n         let unsized_ty = ty::unsize_ty(tcx, datum_ty, k, expr.span);\n         debug!(\"unsized_ty={}\", unsized_ty.repr(bcx.tcx()));\n-        let dest_ty = ty::mk_open(tcx, unsized_ty);\n-        debug!(\"dest_ty={}\", unsized_ty.repr(bcx.tcx()));\n \n         let info = unsized_info(bcx.ccx(), k, expr.id, datum_ty, bcx.fcx.param_substs,\n                                 |t| ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), t));\n@@ -462,20 +460,16 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  datum.to_lvalue_datum(bcx, \"into_fat_ptr\", expr.id));\n         // Compute the base pointer. This doesn't change the pointer value,\n         // but merely its type.\n-        let base = match *k {\n-            ty::UnsizeStruct(..) | ty::UnsizeVtable(..) => {\n-                PointerCast(bcx, lval.val, type_of::type_of(bcx.ccx(), unsized_ty).ptr_to())\n-            }\n-            ty::UnsizeLength(..) => {\n-                GEPi(bcx, lval.val, &[0, 0])\n-            }\n-        };\n+        let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), unsized_ty).ptr_to();\n+        let base = PointerCast(bcx, lval.val, ptr_ty);\n \n-        let scratch = rvalue_scratch_datum(bcx, dest_ty, \"__fat_ptr\");\n-        Store(bcx, base, get_dataptr(bcx, scratch.val));\n-        Store(bcx, info, get_len(bcx, scratch.val));\n+        let llty = type_of::type_of(bcx.ccx(), unsized_ty);\n+        // HACK(eddyb) get around issues with lifetime intrinsics.\n+        let scratch = alloca_no_lifetime(bcx, llty, \"__fat_ptr\");\n+        Store(bcx, base, get_dataptr(bcx, scratch));\n+        Store(bcx, info, get_len(bcx, scratch));\n \n-        DatumBlock::new(bcx, scratch.to_expr_datum())\n+        DatumBlock::new(bcx, Datum::new(scratch, unsized_ty, LvalueExpr))\n     }\n \n     fn unsize_unique_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -711,7 +705,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_rec_field\");\n \n     let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base, \"field\"));\n-    let bare_ty = ty::unopen_type(base_datum.ty);\n+    let bare_ty = base_datum.ty;\n     let repr = adt::represent_type(bcx.ccx(), bare_ty);\n     with_field_tys(bcx.tcx(), bare_ty, None, move |discr, field_tys| {\n         let ix = get_idx(bcx.tcx(), field_tys);\n@@ -723,7 +717,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         if type_is_sized(bcx.tcx(), d.ty) {\n             DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n         } else {\n-            let scratch = rvalue_scratch_datum(bcx, ty::mk_open(bcx.tcx(), d.ty), \"\");\n+            let scratch = rvalue_scratch_datum(bcx, d.ty, \"\");\n             Store(bcx, d.val, get_dataptr(bcx, scratch.val));\n             let info = Load(bcx, get_len(bcx, base_datum.val));\n             Store(bcx, info, get_len(bcx, scratch.val));\n@@ -809,7 +803,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if type_is_sized(bcx.tcx(), elt_ty) {\n                 Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr)\n             } else {\n-                Datum::new(datum.val, ty::mk_open(bcx.tcx(), elt_ty), LvalueExpr)\n+                Datum::new(datum.val, elt_ty, LvalueExpr)\n             }\n         }\n         None => {\n@@ -1671,7 +1665,7 @@ fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            lval: Datum<'tcx, Lvalue>)\n                            -> DatumBlock<'blk, 'tcx, Expr> {\n-    let dest_ty = ty::close_type(bcx.tcx(), lval.ty);\n+    let dest_ty = ty::mk_imm_rptr(bcx.tcx(), bcx.tcx().mk_region(ty::ReStatic), lval.ty);\n     let scratch = rvalue_scratch_datum(bcx, dest_ty, \"__fat_ptr\");\n     memcpy_ty(bcx, scratch.val, lval.val, scratch.ty);\n \n@@ -1685,16 +1679,13 @@ fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n     let sub_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, subexpr, \"addr_of\"));\n-    match sub_datum.ty.sty {\n-        ty::ty_open(_) => {\n-            // Opened DST value, close to a fat pointer\n-            ref_fat_ptr(bcx, sub_datum)\n-        }\n-        _ => {\n-            // Sized value, ref to a thin pointer\n-            let ty = expr_ty(bcx, expr);\n-            immediate_rvalue_bcx(bcx, sub_datum.val, ty).to_expr_datumblock()\n-        }\n+    if !type_is_sized(bcx.tcx(), sub_datum.ty) {\n+        // DST lvalue, close to a fat pointer\n+        ref_fat_ptr(bcx, sub_datum)\n+    } else {\n+        // Sized value, ref to a thin pointer\n+        let ty = expr_ty(bcx, expr);\n+        immediate_rvalue_bcx(bcx, sub_datum.val, ty).to_expr_datumblock()\n     }\n }\n \n@@ -2234,16 +2225,15 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if type_is_sized(bcx.tcx(), content_ty) {\n                 deref_owned_pointer(bcx, expr, datum, content_ty)\n             } else {\n-                // A fat pointer and an opened DST value have the same\n-                // representation just different types. Since there is no\n-                // temporary for `*e` here (because it is unsized), we cannot\n-                // emulate the sized object code path for running drop glue and\n-                // free. Instead, we schedule cleanup for `e`, turning it into\n-                // an lvalue.\n+                // A fat pointer and a DST lvalue have the same representation\n+                // just different types. Since there is no temporary for `*e`\n+                // here (because it is unsized), we cannot emulate the sized\n+                // object code path for running drop glue and free. Instead,\n+                // we schedule cleanup for `e`, turning it into an lvalue.\n                 let datum = unpack_datum!(\n                     bcx, datum.to_lvalue_datum(bcx, \"deref\", expr.id));\n \n-                let datum = Datum::new(datum.val, ty::mk_open(bcx.tcx(), content_ty), LvalueExpr);\n+                let datum = Datum::new(datum.val, content_ty, LvalueExpr);\n                 DatumBlock::new(bcx, datum)\n             }\n         }\n@@ -2260,11 +2250,9 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // owner (or, in the case of *T, by the user).\n                 DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n             } else {\n-                // A fat pointer and an opened DST value have the same representation\n+                // A fat pointer and a DST lvalue have the same representation\n                 // just different types.\n-                DatumBlock::new(bcx, Datum::new(datum.val,\n-                                                ty::mk_open(bcx.tcx(), content_ty),\n-                                                LvalueExpr))\n+                DatumBlock::new(bcx, Datum::new(datum.val, content_ty, LvalueExpr))\n             }\n         }\n "}, {"sha": "c14683aeade058407b940b8a4f61ee856e5f7536", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -34,7 +34,7 @@ use trans::expr;\n use trans::machine::*;\n use trans::tvec;\n use trans::type_::Type;\n-use trans::type_of::{type_of, sizing_type_of, align_of};\n+use trans::type_of::{self, type_of, sizing_type_of, align_of};\n use middle::ty::{self, Ty};\n use util::ppaux::{ty_to_short_str, Repr};\n use util::ppaux;\n@@ -265,8 +265,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         assert_eq!(params.len(), 1);\n         let self_arg = if type_is_fat_ptr(bcx.tcx(), self_ty) {\n             // The dtor expects a fat pointer, so make one, even if we have to fake it.\n-            let boxed_ty = ty::mk_open(bcx.tcx(), t);\n-            let scratch = datum::rvalue_scratch_datum(bcx, boxed_ty, \"__fat_ptr_drop_self\");\n+            let scratch = datum::rvalue_scratch_datum(bcx, t, \"__fat_ptr_drop_self\");\n             Store(bcx, value, GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n             Store(bcx,\n                   // If we just had a thin pointer, make a fat pointer by sticking\n@@ -284,20 +283,18 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // Add all the fields as a value which needs to be cleaned at the end of\n         // this scope. Iterate in reverse order so a Drop impl doesn't reverse\n         // the order in which fields get dropped.\n-        for (i, ty) in st.fields.iter().enumerate().rev() {\n+        for (i, &ty) in st.fields.iter().enumerate().rev() {\n             let llfld_a = adt::struct_field_ptr(variant_cx, &*st, value, i, false);\n \n-            let val = if type_is_sized(bcx.tcx(), *ty) {\n+            let val = if type_is_sized(bcx.tcx(), ty) {\n                 llfld_a\n             } else {\n-                let boxed_ty = ty::mk_open(bcx.tcx(), *ty);\n-                let scratch = datum::rvalue_scratch_datum(bcx, boxed_ty, \"__fat_ptr_drop_field\");\n+                let scratch = datum::rvalue_scratch_datum(bcx, ty, \"__fat_ptr_drop_field\");\n                 Store(bcx, llfld_a, GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n                 Store(bcx, info.unwrap(), GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n                 scratch.val\n             };\n-            variant_cx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope),\n-                                             val, *ty);\n+            variant_cx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope), val, ty);\n         }\n \n         let dtor_ty = ty::mk_ctor_fn(bcx.tcx(),\n@@ -502,7 +499,10 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     // tydescs.\n     assert!(!ccx.finished_tydescs().get());\n \n-    let llty = type_of(ccx, t);\n+    // This really shouldn't be like this, size/align will be wrong for\n+    // unsized types (i.e. [T] will have the size/align of T).\n+    // But we need it until we split this out into a \"type name\" intrinsic.\n+    let llty = type_of::in_memory_type_of(ccx, t);\n \n     if ccx.sess().count_type_sizes() {\n         println!(\"{}\\t{}\", llsize_of_real(ccx, llty),"}, {"sha": "d3acd23e6416d8537fbd4e2e356019af8f5a50a5", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -372,38 +372,31 @@ pub fn get_fixed_base_and_len(bcx: Block,\n     (base, len)\n }\n \n-fn get_slice_base_and_len(bcx: Block,\n-                          llval: ValueRef)\n-                          -> (ValueRef, ValueRef) {\n-    let base = Load(bcx, GEPi(bcx, llval, &[0, abi::FAT_PTR_ADDR]));\n-    let len = Load(bcx, GEPi(bcx, llval, &[0, abi::FAT_PTR_EXTRA]));\n-    (base, len)\n-}\n-\n /// Converts a vector into the slice pair.  The vector should be stored in `llval` which should be\n /// by-reference.  If you have a datum, you would probably prefer to call\n /// `Datum::get_base_and_len()` which will handle any conversions for you.\n-pub fn get_base_and_len(bcx: Block,\n-                        llval: ValueRef,\n-                        vec_ty: Ty)\n-                        -> (ValueRef, ValueRef) {\n+pub fn get_base_and_len<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    llval: ValueRef,\n+                                    vec_ty: Ty<'tcx>)\n+                                    -> (ValueRef, ValueRef) {\n     let ccx = bcx.ccx();\n \n     match vec_ty.sty {\n         ty::ty_vec(_, Some(n)) => get_fixed_base_and_len(bcx, llval, n),\n-        ty::ty_open(ty) => match ty.sty {\n-            ty::ty_vec(_, None) | ty::ty_str => get_slice_base_and_len(bcx, llval),\n-            _ => ccx.sess().bug(\"unexpected type in get_base_and_len\")\n-        },\n+        ty::ty_vec(_, None) | ty::ty_str => {\n+            let base = Load(bcx, expr::get_dataptr(bcx, llval));\n+            let len = Load(bcx, expr::get_len(bcx, llval));\n+            (base, len)\n+        }\n \n         // Only used for pattern matching.\n-        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty.sty {\n-            ty::ty_vec(_, None) | ty::ty_str => get_slice_base_and_len(bcx, llval),\n-            ty::ty_vec(_, Some(n)) => {\n-                let base = GEPi(bcx, Load(bcx, llval), &[0, 0]);\n-                (base, C_uint(ccx, n))\n-            }\n-            _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n+        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n+            let inner = if type_is_sized(bcx.tcx(), ty) {\n+                Load(bcx, llval)\n+            } else {\n+                llval\n+            };\n+            get_base_and_len(bcx, inner, ty)\n         },\n         _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n     }"}, {"sha": "d5ec18e641b7963de9a11ff5cfb71f36f785c8e2", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -232,14 +232,6 @@ impl Type {\n         Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to()\n     }\n \n-    pub fn opaque_trait(ccx: &CrateContext) -> Type {\n-        Type::struct_(ccx, &[Type::opaque_trait_data(ccx).ptr_to(), Type::vtable_ptr(ccx)], false)\n-    }\n-\n-    pub fn opaque_trait_data(ccx: &CrateContext) -> Type {\n-        Type::i8(ccx)\n-    }\n-\n     pub fn kind(&self) -> TypeKind {\n         unsafe {\n             llvm::LLVMGetTypeKind(self.to_ref())"}, {"sha": "97278eb0512e226ea0018c27258bbe79ed42ccd1", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 71, "deletions": 93, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -10,8 +10,6 @@\n \n #![allow(non_camel_case_types)]\n \n-pub use self::named_ty::*;\n-\n use middle::subst;\n use trans::adt;\n use trans::common::*;\n@@ -183,9 +181,8 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     }\n \n     let llsizingty = match t.sty {\n-        _ if !lltype_is_sized(cx.tcx(), t) => {\n-            cx.sess().bug(&format!(\"trying to take the sizing type of {}, an unsized type\",\n-                                  ppaux::ty_to_string(cx.tcx(), t)))\n+        _ if !type_is_sized(cx.tcx(), t) => {\n+            Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n         }\n \n         ty::ty_bool => Type::bool(cx),\n@@ -232,15 +229,11 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             }\n         }\n \n-        ty::ty_open(_) => {\n-            Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n-        }\n-\n         ty::ty_projection(..) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n             cx.sess().bug(&format!(\"fictitious type {} in sizing_type_of()\",\n                                   ppaux::ty_to_string(cx.tcx(), t)))\n         }\n-        ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => panic!(\"unreachable\")\n+        ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => unreachable!()\n     };\n \n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n@@ -270,25 +263,37 @@ pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     }\n }\n \n-// NB: If you update this, be sure to update `sizing_type_of()` as well.\n-pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    fn type_of_unsize_info<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-        // It is possible to end up here with a sized type. This happens with a\n-        // struct which might be unsized, but is monomorphised to a sized type.\n-        // In this case we'll fake a fat pointer with no unsize info (we use 0).\n-        // However, its still a fat pointer, so we need some type use.\n-        if type_is_sized(cx.tcx(), t) {\n-            return Type::i8p(cx);\n-        }\n-\n-        match unsized_part_of_type(cx.tcx(), t).sty {\n-            ty::ty_str | ty::ty_vec(..) => Type::uint_from_ty(cx, ast::TyUs(false)),\n-            ty::ty_trait(_) => Type::vtable_ptr(cx),\n-            _ => panic!(\"Unexpected type returned from unsized_part_of_type : {}\",\n-                       t.repr(cx.tcx()))\n-        }\n-    }\n+/// Get the LLVM type corresponding to a Rust type, i.e. `middle::ty::Ty`.\n+/// This is the right LLVM type for an alloca containg a value of that type,\n+/// and the pointee of an Lvalue Datum (which is always a LLVM pointer).\n+/// For unsized types, the returned type is a fat pointer, thus the resulting\n+/// LLVM type for a `Trait` Lvalue is `{ i8*, void(i8*)** }*`, which is a double\n+/// indirection to the actual data, unlike a `i8` Lvalue, which is just `i8*`.\n+/// This is needed due to the treatment of immediate values, as a fat pointer\n+/// is too large for it to be placed in SSA value (by our rules).\n+/// For the raw type without far pointer indirection, see `in_memory_type_of`.\n+pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n+    let ty = if !type_is_sized(cx.tcx(), ty) {\n+        ty::mk_imm_ptr(cx.tcx(), ty)\n+    } else {\n+        ty\n+    };\n+    in_memory_type_of(cx, ty)\n+}\n \n+/// Get the LLVM type corresponding to a Rust type, i.e. `middle::ty::Ty`.\n+/// This is the right LLVM type for a field/array element of that type,\n+/// and is the same as `type_of` for all Sized types.\n+/// Unsized types, however, are represented by a \"minimal unit\", e.g.\n+/// `[T]` becomes `T`, while `str` and `Trait` turn into `i8` - this\n+/// is useful for indexing slices, as `&[T]`'s data pointer is `T*`.\n+/// If the type is an unsized struct, the regular layout is generated,\n+/// with the inner-most trailing unsized field using the \"minimal unit\"\n+/// of that field's type - this is useful for taking the address of\n+/// that field and ensuring the struct has the right alignment.\n+/// For the LLVM type of a value as a whole, see `type_of`.\n+/// NB: If you update this, be sure to update `sizing_type_of()` as well.\n+pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     // Check the cache.\n     match cx.lltypes().borrow().get(&t) {\n         Some(&llty) => return llty,\n@@ -307,7 +312,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     let t_norm = erase_regions(cx.tcx(), &t);\n \n     if t != t_norm {\n-        let llty = type_of(cx, t_norm);\n+        let llty = in_memory_type_of(cx, t_norm);\n         debug!(\"--> normalized {} {:?} to {} {:?} llty={}\",\n                 t.repr(cx.tcx()),\n                 t,\n@@ -331,52 +336,58 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           // of the enum's variants refers to the enum itself.\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n-          let name = llvm_type_name(cx, an_enum, did, tps);\n+          let name = llvm_type_name(cx, did, tps);\n           adt::incomplete_type_of(cx, &*repr, &name[..])\n       }\n-      ty::ty_closure(did, _, ref substs) => {\n+      ty::ty_closure(..) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache.\n           let repr = adt::represent_type(cx, t);\n           // Unboxed closures can have substitutions in all spaces\n           // inherited from their environment, so we use entire\n           // contents of the VecPerParamSpace to to construct the llvm\n           // name\n-          let name = llvm_type_name(cx, a_closure, did, substs.types.as_slice());\n-          adt::incomplete_type_of(cx, &*repr, &name[..])\n+          adt::incomplete_type_of(cx, &*repr, \"closure\")\n       }\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n-          match ty.sty {\n-              ty::ty_str => {\n+          if !type_is_sized(cx.tcx(), ty) {\n+              if let ty::ty_str = ty.sty {\n                   // This means we get a nicer name in the output (str is always\n                   // unsized).\n                   cx.tn().find_type(\"str_slice\").unwrap()\n+              } else {\n+                  let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n+                  let unsized_part = unsized_part_of_type(cx.tcx(), ty);\n+                  let info_ty = match unsized_part.sty {\n+                      ty::ty_str | ty::ty_vec(..) => {\n+                          Type::uint_from_ty(cx, ast::TyUs(false))\n+                      }\n+                      ty::ty_trait(_) => Type::vtable_ptr(cx),\n+                      _ => panic!(\"Unexpected type returned from \\\n+                                   unsized_part_of_type: {} for ty={}\",\n+                                  unsized_part.repr(cx.tcx()), ty.repr(cx.tcx()))\n+                  };\n+                  Type::struct_(cx, &[ptr_ty, info_ty], false)\n               }\n-              ty::ty_trait(..) => Type::opaque_trait(cx),\n-              _ if !type_is_sized(cx.tcx(), ty) => {\n-                  let p_ty = type_of(cx, ty).ptr_to();\n-                  Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, ty)], false)\n-              }\n-              _ => type_of(cx, ty).ptr_to(),\n+          } else {\n+              in_memory_type_of(cx, ty).ptr_to()\n           }\n       }\n \n       ty::ty_vec(ty, Some(size)) => {\n           let size = size as u64;\n-          let llty = type_of(cx, ty);\n+          let llty = in_memory_type_of(cx, ty);\n           ensure_array_fits_in_address_space(cx, llty, size, t);\n           Type::array(&llty, size)\n       }\n-      ty::ty_vec(ty, None) => {\n-          type_of(cx, ty)\n-      }\n \n-      ty::ty_trait(..) => {\n-          Type::opaque_trait_data(cx)\n-      }\n-\n-      ty::ty_str => Type::i8(cx),\n+      // Unsized slice types (and str) have the type of their element, and\n+      // traits have the type of u8. This is so that the data pointer inside\n+      // fat pointers is of the right type (e.g. for array accesses), even\n+      // when taking the address of an unsized field in a struct.\n+      ty::ty_vec(ty, None) => in_memory_type_of(cx, ty),\n+      ty::ty_str | ty::ty_trait(..) => Type::i8(cx),\n \n       ty::ty_bare_fn(..) => {\n           type_of_fn_from_ty(cx, t).ptr_to()\n@@ -388,7 +399,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n       }\n       ty::ty_struct(did, ref substs) => {\n           if ty::type_is_simd(cx.tcx(), t) {\n-              let llet = type_of(cx, ty::simd_type(cx.tcx(), t));\n+              let llet = in_memory_type_of(cx, ty::simd_type(cx.tcx(), t));\n               let n = ty::simd_size(cx.tcx(), t) as u64;\n               ensure_array_fits_in_address_space(cx, llet, n, t);\n               Type::vector(&llet, n)\n@@ -398,29 +409,11 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n-              let name = llvm_type_name(cx, a_struct, did, tps);\n+              let name = llvm_type_name(cx, did, tps);\n               adt::incomplete_type_of(cx, &*repr, &name[..])\n           }\n       }\n \n-      ty::ty_open(t) => match t.sty {\n-          ty::ty_struct(..) => {\n-              let p_ty = type_of(cx, t).ptr_to();\n-              Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, t)], false)\n-          }\n-          ty::ty_vec(ty, None) => {\n-              let p_ty = type_of(cx, ty).ptr_to();\n-              Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, t)], false)\n-          }\n-          ty::ty_str => {\n-              let p_ty = Type::i8p(cx);\n-              Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, t)], false)\n-          }\n-          ty::ty_trait(..) => Type::opaque_trait(cx),\n-          _ => cx.sess().bug(&format!(\"ty_open with sized type: {}\",\n-                                     ppaux::ty_to_string(cx.tcx(), t)))\n-      },\n-\n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n       ty::ty_projection(..) => cx.sess().bug(\"type_of with ty_projection\"),\n       ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),\n@@ -444,7 +437,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n         _ => ()\n     }\n \n-    return llty;\n+    llty\n }\n \n pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n@@ -453,37 +446,22 @@ pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     machine::llalign_of_min(cx, llty)\n }\n \n-// Want refinements! (Or case classes, I guess\n-#[derive(Copy)]\n-pub enum named_ty {\n-    a_struct,\n-    an_enum,\n-    a_closure,\n-}\n-\n-pub fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                what: named_ty,\n-                                did: ast::DefId,\n-                                tps: &[Ty<'tcx>])\n-                                -> String {\n-    let name = match what {\n-        a_struct => \"struct\",\n-        an_enum => \"enum\",\n-        a_closure => return \"closure\".to_string(),\n-    };\n-\n+fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                            did: ast::DefId,\n+                            tps: &[Ty<'tcx>])\n+                            -> String {\n     let base = ty::item_path_str(cx.tcx(), did);\n     let strings: Vec<String> = tps.iter().map(|t| t.repr(cx.tcx())).collect();\n     let tstr = if strings.is_empty() {\n         base\n     } else {\n-        format!(\"{}<{:?}>\", base, strings)\n+        format!(\"{}<{}>\", base, strings.connect(\", \"))\n     };\n \n     if did.krate == 0 {\n-        format!(\"{}.{}\", name, tstr)\n+        tstr\n     } else {\n-        format!(\"{}.{}[{}{}]\", name, tstr, \"#\", did.krate)\n+        format!(\"{}.{}\", did.krate, tstr)\n     }\n }\n "}, {"sha": "f65e585d23edd3c8c11e2ac3c11db443db9bd7ed", "filename": "src/librustc_typeck/check/implicator.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -161,12 +161,6 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 //   entering the fn check. We should do this after\n                 //   the fn check, then we can call this case a bug().\n             }\n-\n-            ty::ty_open(_) => {\n-                self.tcx().sess.bug(\n-                    &format!(\"Unexpected type encountered while doing wf check: {}\",\n-                            ty.repr(self.tcx())));\n-            }\n         }\n     }\n "}, {"sha": "7dac1eeb6f11723d95acf77184e164a6c7a24d8d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -25,7 +25,7 @@ use middle::ty::{ParameterEnvironment, TypeTraitItemId, lookup_item_type};\n use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n-use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n+use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int};\n use middle::ty::{ty_uint, ty_closure, ty_uniq, ty_bare_fn};\n use middle::ty::{ty_projection};\n use middle::ty;\n@@ -75,7 +75,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n \n         ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_tup(..) |\n-        ty_param(..) | ty_err | ty_open(..) |\n+        ty_param(..) | ty_err |\n         ty_ptr(_) | ty_rptr(_, _) | ty_projection(..) => {\n             None\n         }"}, {"sha": "90ca6a798056bf6e7694e1ea893f76888fa75a9f", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -849,7 +849,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n \n-            ty::ty_uniq(typ) | ty::ty_vec(typ, _) | ty::ty_open(typ) => {\n+            ty::ty_uniq(typ) | ty::ty_vec(typ, _) => {\n                 self.add_constraints_from_ty(generics, typ, variance);\n             }\n "}, {"sha": "a3e0cecdd4826092f506d16c2824e013f86c9d87", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -1619,7 +1619,6 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::ty_closure(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n             ty::ty_infer(..) => panic!(\"ty_infer\"),\n-            ty::ty_open(..) => panic!(\"ty_open\"),\n             ty::ty_err => panic!(\"ty_err\"),\n         }\n     }"}, {"sha": "d39efa3c2ab78f909815c6db507a9a0be4a6419a", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,28 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reached the recursion limit during monomorphization\n-// issue 2258\n+//~^^^^^^^^^^ ERROR overflow\n+//\n+// We get an error message at the top of file (dummy span).\n+// This is not helpful, but also kind of annoying to prevent,\n+// so for now just live with it.\n+// This test case was originally for issue #2258.\n \n-trait to_opt {\n+trait ToOpt {\n     fn to_option(&self) -> Option<Self>;\n }\n \n-impl to_opt for usize {\n+impl ToOpt for usize {\n     fn to_option(&self) -> Option<usize> {\n         Some(*self)\n     }\n }\n \n-impl<T:Clone> to_opt for Option<T> {\n+impl<T:Clone> ToOpt for Option<T> {\n     fn to_option(&self) -> Option<Option<T>> {\n         Some((*self).clone())\n     }\n }\n \n-fn function<T:to_opt + Clone>(counter: usize, t: T) {\n+fn function<T:ToOpt + Clone>(counter: usize, t: T) {\n     if counter > 0_usize {\n         function(counter - 1_usize, t.to_option());\n+        // FIXME(#4287) Error message should be here. It should be\n+        // a type error to instantiate `test` at a type other than T.\n     }\n }\n "}, {"sha": "55f3b995336534c5e7cf8e9424ceb167bf2387b5", "filename": "src/test/compile-fail/recursion.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d5d2448d574577e6772dbfef0ff5b1d1e0d238/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion.rs?ref=89d5d2448d574577e6772dbfef0ff5b1d1e0d238", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,10 +10,9 @@\n \n //~^^^^^^^^^^ ERROR overflow\n //\n-// We also get a second error message at the top of file (dummy\n-// span). This is not helpful, but also kind of annoying to prevent,\n-// so for now just live with it, since we also get a second message\n-// that is more helpful.\n+// We get an error message at the top of file (dummy span).\n+// This is not helpful, but also kind of annoying to prevent,\n+// so for now just live with it.\n \n enum Nil {NilValue}\n struct Cons<T> {head:isize, tail:T}\n@@ -28,9 +27,8 @@ impl<T:Dot> Dot for Cons<T> {\n }\n fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize {\n   match n {    0 => {first.dot(second)}\n-      //~^ ERROR: reached the recursion limit during monomorphization\n-      // Error message should be here. It should be a type error\n-      // to instantiate `test` at a type other than T. (See #4287)\n+      // FIXME(#4287) Error message should be here. It should be\n+      // a type error to instantiate `test` at a type other than T.\n     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}\n   }\n }"}]}