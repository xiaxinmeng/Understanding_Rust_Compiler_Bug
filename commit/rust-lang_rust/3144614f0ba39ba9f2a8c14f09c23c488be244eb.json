{"sha": "3144614f0ba39ba9f2a8c14f09c23c488be244eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxNDQ2MTRmMGJhMzliYTlmMmE4YzE0ZjA5YzIzYzQ4OGJlMjQ0ZWI=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-01T23:16:00Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-24T17:24:03Z"}, "message": "Move lint infrastructure and individual lints into separate files", "tree": {"sha": "d914ec0f2ba764f349795bf21f699ec7ca2a7a23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d914ec0f2ba764f349795bf21f699ec7ca2a7a23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3144614f0ba39ba9f2a8c14f09c23c488be244eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3144614f0ba39ba9f2a8c14f09c23c488be244eb", "html_url": "https://github.com/rust-lang/rust/commit/3144614f0ba39ba9f2a8c14f09c23c488be244eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3144614f0ba39ba9f2a8c14f09c23c488be244eb/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75bfedaef5c7b7bbfd91a78188f8b8e6a97510c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/75bfedaef5c7b7bbfd91a78188f8b8e6a97510c3", "html_url": "https://github.com/rust-lang/rust/commit/75bfedaef5c7b7bbfd91a78188f8b8e6a97510c3"}], "stats": {"total": 2204, "additions": 1134, "deletions": 1070}, "files": [{"sha": "3065645db2798434b2d055fd7f9465393019290c", "filename": "src/librustc/lint/builtin.rs", "status": "added", "additions": 1081, "deletions": 0, "changes": 1081, "blob_url": "https://github.com/rust-lang/rust/blob/3144614f0ba39ba9f2a8c14f09c23c488be244eb/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3144614f0ba39ba9f2a8c14f09c23c488be244eb/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=3144614f0ba39ba9f2a8c14f09c23c488be244eb", "patch": "@@ -0,0 +1,1081 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Lints built in to rustc.\n+\n+use metadata::csearch;\n+use middle::def;\n+use middle::def::*;\n+use middle::pat_util;\n+use middle::trans::adt; // for `adt::is_ffi_safe`\n+use middle::ty;\n+use middle::typeck::astconv::{ast_ty_to_ty, AstConv};\n+use middle::typeck::infer;\n+use middle::typeck;\n+use util::ppaux::{ty_to_str};\n+use lint::Context;\n+use lint;\n+\n+use std::cmp;\n+use std::collections::HashMap;\n+use std::i16;\n+use std::i32;\n+use std::i64;\n+use std::i8;\n+use std::u16;\n+use std::u32;\n+use std::u64;\n+use std::u8;\n+use syntax::abi;\n+use syntax::ast_map;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::visit::Visitor;\n+use syntax::{ast, ast_util, visit};\n+\n+pub fn check_while_true_expr(cx: &Context, e: &ast::Expr) {\n+    match e.node {\n+        ast::ExprWhile(cond, _) => {\n+            match cond.node {\n+                ast::ExprLit(lit) => {\n+                    match lit.node {\n+                        ast::LitBool(true) => {\n+                            cx.span_lint(lint::WhileTrue,\n+                                         e.span,\n+                                         \"denote infinite loops with loop \\\n+                                          { ... }\");\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                _ => ()\n+            }\n+        }\n+        _ => ()\n+    }\n+}\n+\n+pub fn check_unused_casts(cx: &Context, e: &ast::Expr) {\n+    return match e.node {\n+        ast::ExprCast(expr, ty) => {\n+            let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), ty);\n+            if  ty::get(ty::expr_ty(cx.tcx, expr)).sty == ty::get(t_t).sty {\n+                cx.span_lint(lint::UnnecessaryTypecast, ty.span,\n+                             \"unnecessary type cast\");\n+            }\n+        }\n+        _ => ()\n+    };\n+}\n+\n+pub fn check_type_limits(cx: &Context, e: &ast::Expr) {\n+    return match e.node {\n+        ast::ExprUnary(ast::UnNeg, ex) => {\n+            match ex.node  {\n+                ast::ExprLit(lit) => {\n+                    match lit.node {\n+                        ast::LitUint(..) => {\n+                            cx.span_lint(lint::UnsignedNegate, e.span,\n+                                         \"negation of unsigned int literal may be unintentional\");\n+                        },\n+                        _ => ()\n+                    }\n+                },\n+                _ => {\n+                    let t = ty::expr_ty(cx.tcx, ex);\n+                    match ty::get(t).sty {\n+                        ty::ty_uint(_) => {\n+                            cx.span_lint(lint::UnsignedNegate, e.span,\n+                                         \"negation of unsigned int variable may be unintentional\");\n+                        },\n+                        _ => ()\n+                    }\n+                }\n+            }\n+        },\n+        ast::ExprBinary(binop, l, r) => {\n+            if is_comparison(binop) && !check_limits(cx.tcx, binop, l, r) {\n+                cx.span_lint(lint::TypeLimits, e.span,\n+                             \"comparison is useless due to type limits\");\n+            }\n+        },\n+        ast::ExprLit(lit) => {\n+            match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n+                ty::ty_int(t) => {\n+                    let int_type = if t == ast::TyI {\n+                        cx.tcx.sess.targ_cfg.int_type\n+                    } else { t };\n+                    let (min, max) = int_ty_range(int_type);\n+                    let mut lit_val: i64 = match lit.node {\n+                        ast::LitInt(v, _) => v,\n+                        ast::LitUint(v, _) => v as i64,\n+                        ast::LitIntUnsuffixed(v) => v,\n+                        _ => fail!()\n+                    };\n+                    if cx.negated_expr_id == e.id {\n+                        lit_val *= -1;\n+                    }\n+                    if  lit_val < min || lit_val > max {\n+                        cx.span_lint(lint::TypeOverflow, e.span,\n+                                     \"literal out of range for its type\");\n+                    }\n+                },\n+                ty::ty_uint(t) => {\n+                    let uint_type = if t == ast::TyU {\n+                        cx.tcx.sess.targ_cfg.uint_type\n+                    } else { t };\n+                    let (min, max) = uint_ty_range(uint_type);\n+                    let lit_val: u64 = match lit.node {\n+                        ast::LitInt(v, _) => v as u64,\n+                        ast::LitUint(v, _) => v,\n+                        ast::LitIntUnsuffixed(v) => v as u64,\n+                        _ => fail!()\n+                    };\n+                    if  lit_val < min || lit_val > max {\n+                        cx.span_lint(lint::TypeOverflow, e.span,\n+                                     \"literal out of range for its type\");\n+                    }\n+                },\n+\n+                _ => ()\n+            };\n+        },\n+        _ => ()\n+    };\n+\n+    fn is_valid<T:cmp::PartialOrd>(binop: ast::BinOp, v: T,\n+                            min: T, max: T) -> bool {\n+        match binop {\n+            ast::BiLt => v >  min && v <= max,\n+            ast::BiLe => v >= min && v <  max,\n+            ast::BiGt => v >= min && v <  max,\n+            ast::BiGe => v >  min && v <= max,\n+            ast::BiEq | ast::BiNe => v >= min && v <= max,\n+            _ => fail!()\n+        }\n+    }\n+\n+    fn rev_binop(binop: ast::BinOp) -> ast::BinOp {\n+        match binop {\n+            ast::BiLt => ast::BiGt,\n+            ast::BiLe => ast::BiGe,\n+            ast::BiGt => ast::BiLt,\n+            ast::BiGe => ast::BiLe,\n+            _ => binop\n+        }\n+    }\n+\n+    // for int & uint, be conservative with the warnings, so that the\n+    // warnings are consistent between 32- and 64-bit platforms\n+    fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n+        match int_ty {\n+            ast::TyI =>    (i64::MIN,        i64::MAX),\n+            ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n+            ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n+            ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n+            ast::TyI64 =>  (i64::MIN,        i64::MAX)\n+        }\n+    }\n+\n+    fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n+        match uint_ty {\n+            ast::TyU =>   (u64::MIN,         u64::MAX),\n+            ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n+            ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n+            ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n+            ast::TyU64 => (u64::MIN,         u64::MAX)\n+        }\n+    }\n+\n+    fn check_limits(tcx: &ty::ctxt, binop: ast::BinOp,\n+                    l: &ast::Expr, r: &ast::Expr) -> bool {\n+        let (lit, expr, swap) = match (&l.node, &r.node) {\n+            (&ast::ExprLit(_), _) => (l, r, true),\n+            (_, &ast::ExprLit(_)) => (r, l, false),\n+            _ => return true\n+        };\n+        // Normalize the binop so that the literal is always on the RHS in\n+        // the comparison\n+        let norm_binop = if swap { rev_binop(binop) } else { binop };\n+        match ty::get(ty::expr_ty(tcx, expr)).sty {\n+            ty::ty_int(int_ty) => {\n+                let (min, max) = int_ty_range(int_ty);\n+                let lit_val: i64 = match lit.node {\n+                    ast::ExprLit(li) => match li.node {\n+                        ast::LitInt(v, _) => v,\n+                        ast::LitUint(v, _) => v as i64,\n+                        ast::LitIntUnsuffixed(v) => v,\n+                        _ => return true\n+                    },\n+                    _ => fail!()\n+                };\n+                is_valid(norm_binop, lit_val, min, max)\n+            }\n+            ty::ty_uint(uint_ty) => {\n+                let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n+                let lit_val: u64 = match lit.node {\n+                    ast::ExprLit(li) => match li.node {\n+                        ast::LitInt(v, _) => v as u64,\n+                        ast::LitUint(v, _) => v,\n+                        ast::LitIntUnsuffixed(v) => v as u64,\n+                        _ => return true\n+                    },\n+                    _ => fail!()\n+                };\n+                is_valid(norm_binop, lit_val, min, max)\n+            }\n+            _ => true\n+        }\n+    }\n+\n+    fn is_comparison(binop: ast::BinOp) -> bool {\n+        match binop {\n+            ast::BiEq | ast::BiLt | ast::BiLe |\n+            ast::BiNe | ast::BiGe | ast::BiGt => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n+pub fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n+    fn check_ty(cx: &Context, ty: &ast::Ty) {\n+        match ty.node {\n+            ast::TyPath(_, _, id) => {\n+                match cx.tcx.def_map.borrow().get_copy(&id) {\n+                    def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n+                        cx.span_lint(lint::CTypes, ty.span,\n+                                \"found rust type `int` in foreign module, while \\\n+                                libc::c_int or libc::c_long should be used\");\n+                    }\n+                    def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n+                        cx.span_lint(lint::CTypes, ty.span,\n+                                \"found rust type `uint` in foreign module, while \\\n+                                libc::c_uint or libc::c_ulong should be used\");\n+                    }\n+                    def::DefTy(def_id) => {\n+                        if !adt::is_ffi_safe(cx.tcx, def_id) {\n+                            cx.span_lint(lint::CTypes, ty.span,\n+                                         \"found enum type without foreign-function-safe \\\n+                                          representation annotation in foreign module\");\n+                            // hmm... this message could be more helpful\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+            }\n+            ast::TyPtr(ref mt) => { check_ty(cx, mt.ty) }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n+        for input in decl.inputs.iter() {\n+            check_ty(cx, input.ty);\n+        }\n+        check_ty(cx, decl.output)\n+    }\n+\n+    match it.node {\n+      ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n+        for ni in nmod.items.iter() {\n+            match ni.node {\n+                ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, decl),\n+                ast::ForeignItemStatic(t, _) => check_ty(cx, t)\n+            }\n+        }\n+      }\n+      _ => {/* nothing to do */ }\n+    }\n+}\n+\n+pub fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n+    let xs = [lint::ManagedHeapMemory, lint::OwnedHeapMemory, lint::HeapMemory];\n+    for &lint in xs.iter() {\n+        if cx.get_level(lint) == lint::Allow { continue }\n+\n+        let mut n_box = 0;\n+        let mut n_uniq = 0;\n+        ty::fold_ty(cx.tcx, ty, |t| {\n+            match ty::get(t).sty {\n+                ty::ty_box(_) => {\n+                    n_box += 1;\n+                }\n+                ty::ty_uniq(_) |\n+                ty::ty_trait(box ty::TyTrait {\n+                    store: ty::UniqTraitStore, ..\n+                }) |\n+                ty::ty_closure(box ty::ClosureTy {\n+                    store: ty::UniqTraitStore,\n+                    ..\n+                }) => {\n+                    n_uniq += 1;\n+                }\n+\n+                _ => ()\n+            };\n+            t\n+        });\n+\n+        if n_uniq > 0 && lint != lint::ManagedHeapMemory {\n+            let s = ty_to_str(cx.tcx, ty);\n+            let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n+            cx.span_lint(lint, span, m.as_slice());\n+        }\n+\n+        if n_box > 0 && lint != lint::OwnedHeapMemory {\n+            let s = ty_to_str(cx.tcx, ty);\n+            let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n+            cx.span_lint(lint, span, m.as_slice());\n+        }\n+    }\n+}\n+\n+pub fn check_heap_item(cx: &Context, it: &ast::Item) {\n+    match it.node {\n+        ast::ItemFn(..) |\n+        ast::ItemTy(..) |\n+        ast::ItemEnum(..) |\n+        ast::ItemStruct(..) => check_heap_type(cx, it.span,\n+                                               ty::node_id_to_type(cx.tcx,\n+                                                                   it.id)),\n+        _ => ()\n+    }\n+\n+    // If it's a struct, we also have to check the fields' types\n+    match it.node {\n+        ast::ItemStruct(struct_def, _) => {\n+            for struct_field in struct_def.fields.iter() {\n+                check_heap_type(cx, struct_field.span,\n+                                ty::node_id_to_type(cx.tcx,\n+                                                    struct_field.node.id));\n+            }\n+        }\n+        _ => ()\n+    }\n+}\n+\n+struct RawPtrDerivingVisitor<'a> {\n+    cx: &'a Context<'a>\n+}\n+\n+impl<'a> Visitor<()> for RawPtrDerivingVisitor<'a> {\n+    fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n+        static MSG: &'static str = \"use of `#[deriving]` with a raw pointer\";\n+        match ty.node {\n+            ast::TyPtr(..) => self.cx.span_lint(lint::RawPointerDeriving, ty.span, MSG),\n+            _ => {}\n+        }\n+        visit::walk_ty(self, ty, ());\n+    }\n+    // explicit override to a no-op to reduce code bloat\n+    fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n+    fn visit_block(&mut self, _: &ast::Block, _: ()) {}\n+}\n+\n+pub fn check_raw_ptr_deriving(cx: &mut Context, item: &ast::Item) {\n+    if !attr::contains_name(item.attrs.as_slice(), \"automatically_derived\") {\n+        return\n+    }\n+    let did = match item.node {\n+        ast::ItemImpl(..) => {\n+            match ty::get(ty::node_id_to_type(cx.tcx, item.id)).sty {\n+                ty::ty_enum(did, _) => did,\n+                ty::ty_struct(did, _) => did,\n+                _ => return,\n+            }\n+        }\n+        _ => return,\n+    };\n+    if !ast_util::is_local(did) { return }\n+    let item = match cx.tcx.map.find(did.node) {\n+        Some(ast_map::NodeItem(item)) => item,\n+        _ => return,\n+    };\n+    if !cx.checked_raw_pointers.insert(item.id) { return }\n+    match item.node {\n+        ast::ItemStruct(..) | ast::ItemEnum(..) => {\n+            let mut visitor = RawPtrDerivingVisitor { cx: cx };\n+            visit::walk_item(&mut visitor, item, ());\n+        }\n+        _ => {}\n+    }\n+}\n+\n+pub fn check_unused_attribute(cx: &Context, attr: &ast::Attribute) {\n+    static ATTRIBUTE_WHITELIST: &'static [&'static str] = &'static [\n+        // FIXME: #14408 whitelist docs since rustdoc looks at them\n+        \"doc\",\n+\n+        // FIXME: #14406 these are processed in trans, which happens after the\n+        // lint pass\n+        \"address_insignificant\",\n+        \"cold\",\n+        \"inline\",\n+        \"link\",\n+        \"link_name\",\n+        \"link_section\",\n+        \"no_builtins\",\n+        \"no_mangle\",\n+        \"no_split_stack\",\n+        \"packed\",\n+        \"static_assert\",\n+        \"thread_local\",\n+\n+        // not used anywhere (!?) but apparently we want to keep them around\n+        \"comment\",\n+        \"desc\",\n+        \"license\",\n+\n+        // FIXME: #14407 these are only looked at on-demand so we can't\n+        // guarantee they'll have already been checked\n+        \"deprecated\",\n+        \"experimental\",\n+        \"frozen\",\n+        \"locked\",\n+        \"must_use\",\n+        \"stable\",\n+        \"unstable\",\n+    ];\n+\n+    static CRATE_ATTRS: &'static [&'static str] = &'static [\n+        \"crate_type\",\n+        \"feature\",\n+        \"no_start\",\n+        \"no_main\",\n+        \"no_std\",\n+        \"crate_id\",\n+        \"desc\",\n+        \"comment\",\n+        \"license\",\n+        \"copyright\",\n+        \"no_builtins\",\n+    ];\n+\n+    for &name in ATTRIBUTE_WHITELIST.iter() {\n+        if attr.check_name(name) {\n+            break;\n+        }\n+    }\n+\n+    if !attr::is_used(attr) {\n+        cx.span_lint(lint::UnusedAttribute, attr.span, \"unused attribute\");\n+        if CRATE_ATTRS.contains(&attr.name().get()) {\n+            let msg = match attr.node.style {\n+               ast::AttrOuter => \"crate-level attribute should be an inner \\\n+                                  attribute: add an exclamation mark: #![foo]\",\n+                ast::AttrInner => \"crate-level attribute should be in the \\\n+                                   root module\",\n+            };\n+            cx.span_lint(lint::UnusedAttribute, attr.span, msg);\n+        }\n+    }\n+}\n+\n+pub fn check_heap_expr(cx: &Context, e: &ast::Expr) {\n+    let ty = ty::expr_ty(cx.tcx, e);\n+    check_heap_type(cx, e.span, ty);\n+}\n+\n+pub fn check_path_statement(cx: &Context, s: &ast::Stmt) {\n+    match s.node {\n+        ast::StmtSemi(expr, _) => {\n+            match expr.node {\n+                ast::ExprPath(_) => {\n+                    cx.span_lint(lint::PathStatement,\n+                                 s.span,\n+                                 \"path statement with no effect\");\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => ()\n+    }\n+}\n+\n+pub fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n+    let expr = match s.node {\n+        ast::StmtSemi(expr, _) => expr,\n+        _ => return\n+    };\n+    let t = ty::expr_ty(cx.tcx, expr);\n+    match ty::get(t).sty {\n+        ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n+        _ => {}\n+    }\n+    match expr.node {\n+        ast::ExprRet(..) => return,\n+        _ => {}\n+    }\n+\n+    let t = ty::expr_ty(cx.tcx, expr);\n+    let mut warned = false;\n+    match ty::get(t).sty {\n+        ty::ty_struct(did, _) |\n+        ty::ty_enum(did, _) => {\n+            if ast_util::is_local(did) {\n+                match cx.tcx.map.get(did.node) {\n+                    ast_map::NodeItem(it) => {\n+                        if attr::contains_name(it.attrs.as_slice(),\n+                                               \"must_use\") {\n+                            cx.span_lint(lint::UnusedMustUse, s.span,\n+                                         \"unused result which must be used\");\n+                            warned = true;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            } else {\n+                csearch::get_item_attrs(&cx.tcx.sess.cstore, did, |attrs| {\n+                    if attr::contains_name(attrs.as_slice(), \"must_use\") {\n+                        cx.span_lint(lint::UnusedMustUse, s.span,\n+                                     \"unused result which must be used\");\n+                        warned = true;\n+                    }\n+                });\n+            }\n+        }\n+        _ => {}\n+    }\n+    if !warned {\n+        cx.span_lint(lint::UnusedResult, s.span, \"unused result\");\n+    }\n+}\n+\n+pub fn check_deprecated_owned_vector(cx: &Context, e: &ast::Expr) {\n+    let t = ty::expr_ty(cx.tcx, e);\n+    match ty::get(t).sty {\n+        ty::ty_uniq(t) => match ty::get(t).sty {\n+            ty::ty_vec(_, None) => {\n+                cx.span_lint(lint::DeprecatedOwnedVector, e.span,\n+                             \"use of deprecated `~[]` vector; replaced by `std::vec::Vec`\")\n+            }\n+            _ => {}\n+        },\n+        _ => {}\n+    }\n+}\n+\n+pub fn check_item_non_camel_case_types(cx: &Context, it: &ast::Item) {\n+    fn is_camel_case(ident: ast::Ident) -> bool {\n+        let ident = token::get_ident(ident);\n+        assert!(!ident.get().is_empty());\n+        let ident = ident.get().trim_chars('_');\n+\n+        // start with a non-lowercase letter rather than non-uppercase\n+        // ones (some scripts don't have a concept of upper/lowercase)\n+        !ident.char_at(0).is_lowercase() && !ident.contains_char('_')\n+    }\n+\n+    fn to_camel_case(s: &str) -> String {\n+        s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n+            if i == 0 { c.to_uppercase() }\n+            else { c }\n+        )).collect()\n+    }\n+\n+    fn check_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+        let s = token::get_ident(ident);\n+\n+        if !is_camel_case(ident) {\n+            cx.span_lint(lint::\n+                NonCamelCaseTypes, span,\n+                format!(\"{} `{}` should have a camel case name such as `{}`\",\n+                    sort, s, to_camel_case(s.get())).as_slice());\n+        }\n+    }\n+\n+    match it.node {\n+        ast::ItemTy(..) | ast::ItemStruct(..) => {\n+            check_case(cx, \"type\", it.ident, it.span)\n+        }\n+        ast::ItemTrait(..) => {\n+            check_case(cx, \"trait\", it.ident, it.span)\n+        }\n+        ast::ItemEnum(ref enum_definition, _) => {\n+            check_case(cx, \"type\", it.ident, it.span);\n+            for variant in enum_definition.variants.iter() {\n+                check_case(cx, \"variant\", variant.node.name, variant.span);\n+            }\n+        }\n+        _ => ()\n+    }\n+}\n+\n+pub fn check_snake_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+    fn is_snake_case(ident: ast::Ident) -> bool {\n+        let ident = token::get_ident(ident);\n+        assert!(!ident.get().is_empty());\n+        let ident = ident.get().trim_chars('_');\n+\n+        let mut allow_underscore = true;\n+        ident.chars().all(|c| {\n+            allow_underscore = match c {\n+                c if c.is_lowercase() || c.is_digit() => true,\n+                '_' if allow_underscore => false,\n+                _ => return false,\n+            };\n+            true\n+        })\n+    }\n+\n+    fn to_snake_case(str: &str) -> String {\n+        let mut words = vec![];\n+        for s in str.split('_') {\n+            let mut buf = String::new();\n+            if s.is_empty() { continue; }\n+            for ch in s.chars() {\n+                if !buf.is_empty() && ch.is_uppercase() {\n+                    words.push(buf);\n+                    buf = String::new();\n+                }\n+                buf.push_char(ch.to_lowercase());\n+            }\n+            words.push(buf);\n+        }\n+        words.connect(\"_\")\n+    }\n+\n+    let s = token::get_ident(ident);\n+\n+    if !is_snake_case(ident) {\n+        cx.span_lint(lint::NonSnakeCaseFunctions, span,\n+            format!(\"{} `{}` should have a snake case name such as `{}`\",\n+                sort, s, to_snake_case(s.get())).as_slice());\n+    }\n+}\n+\n+pub fn check_item_non_uppercase_statics(cx: &Context, it: &ast::Item) {\n+    match it.node {\n+        // only check static constants\n+        ast::ItemStatic(_, ast::MutImmutable, _) => {\n+            let s = token::get_ident(it.ident);\n+            // check for lowercase letters rather than non-uppercase\n+            // ones (some scripts don't have a concept of\n+            // upper/lowercase)\n+            if s.get().chars().any(|c| c.is_lowercase()) {\n+                cx.span_lint(lint::NonUppercaseStatics, it.span,\n+                    format!(\"static constant `{}` should have an uppercase name \\\n+                        such as `{}`\", s.get(),\n+                        s.get().chars().map(|c| c.to_uppercase())\n+                            .collect::<String>().as_slice()).as_slice());\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n+pub fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n+    // Lint for constants that look like binding identifiers (#7526)\n+    match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n+        (&ast::PatIdent(_, ref path, _), Some(&def::DefStatic(_, false))) => {\n+            // last identifier alone is right choice for this lint.\n+            let ident = path.segments.last().unwrap().identifier;\n+            let s = token::get_ident(ident);\n+            if s.get().chars().any(|c| c.is_lowercase()) {\n+                cx.span_lint(lint::NonUppercasePatternStatics, path.span,\n+                    format!(\"static constant in pattern `{}` should have an uppercase \\\n+                        name such as `{}`\", s.get(),\n+                        s.get().chars().map(|c| c.to_uppercase())\n+                            .collect::<String>().as_slice()).as_slice());\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n+pub fn check_pat_uppercase_variable(cx: &Context, p: &ast::Pat) {\n+    match &p.node {\n+        &ast::PatIdent(_, ref path, _) => {\n+            match cx.tcx.def_map.borrow().find(&p.id) {\n+                Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |\n+                        Some(&def::DefArg(_, _)) => {\n+                    // last identifier alone is right choice for this lint.\n+                    let ident = path.segments.last().unwrap().identifier;\n+                    let s = token::get_ident(ident);\n+                    if s.get().len() > 0 && s.get().char_at(0).is_uppercase() {\n+                        cx.span_lint(lint::\n+                            UppercaseVariables,\n+                            path.span,\n+                            \"variable names should start with a lowercase character\");\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n+pub fn check_struct_uppercase_variable(cx: &Context, s: &ast::StructDef) {\n+    for sf in s.fields.iter() {\n+        match sf.node {\n+            ast::StructField_ { kind: ast::NamedField(ident, _), .. } => {\n+                let s = token::get_ident(ident);\n+                if s.get().char_at(0).is_uppercase() {\n+                    cx.span_lint(lint::\n+                        UppercaseVariables,\n+                        sf.span,\n+                        \"structure field names should start with a lowercase character\");\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+pub fn check_unnecessary_parens_core(cx: &Context, value: &ast::Expr, msg: &str) {\n+    match value.node {\n+        ast::ExprParen(_) => {\n+            cx.span_lint(lint::UnnecessaryParens, value.span,\n+                         format!(\"unnecessary parentheses around {}\",\n+                                 msg).as_slice())\n+        }\n+        _ => {}\n+    }\n+}\n+\n+pub fn check_unnecessary_parens_expr(cx: &Context, e: &ast::Expr) {\n+    let (value, msg) = match e.node {\n+        ast::ExprIf(cond, _, _) => (cond, \"`if` condition\"),\n+        ast::ExprWhile(cond, _) => (cond, \"`while` condition\"),\n+        ast::ExprMatch(head, _) => (head, \"`match` head expression\"),\n+        ast::ExprRet(Some(value)) => (value, \"`return` value\"),\n+        ast::ExprAssign(_, value) => (value, \"assigned value\"),\n+        ast::ExprAssignOp(_, _, value) => (value, \"assigned value\"),\n+        _ => return\n+    };\n+    check_unnecessary_parens_core(cx, value, msg);\n+}\n+\n+pub fn check_unnecessary_parens_stmt(cx: &Context, s: &ast::Stmt) {\n+    let (value, msg) = match s.node {\n+        ast::StmtDecl(decl, _) => match decl.node {\n+            ast::DeclLocal(local) => match local.init {\n+                Some(value) => (value, \"assigned value\"),\n+                None => return\n+            },\n+            _ => return\n+        },\n+        _ => return\n+    };\n+    check_unnecessary_parens_core(cx, value, msg);\n+}\n+\n+pub fn check_unused_unsafe(cx: &Context, e: &ast::Expr) {\n+    match e.node {\n+        // Don't warn about generated blocks, that'll just pollute the output.\n+        ast::ExprBlock(ref blk) => {\n+            if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n+                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n+                cx.span_lint(lint::UnusedUnsafe, blk.span,\n+                             \"unnecessary `unsafe` block\");\n+            }\n+        }\n+        _ => ()\n+    }\n+}\n+\n+pub fn check_unsafe_block(cx: &Context, e: &ast::Expr) {\n+    match e.node {\n+        // Don't warn about generated blocks, that'll just pollute the output.\n+        ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n+            cx.span_lint(lint::UnsafeBlock, blk.span, \"usage of an `unsafe` block\");\n+        }\n+        _ => ()\n+    }\n+}\n+\n+pub fn check_unused_mut_pat(cx: &Context, pats: &[@ast::Pat]) {\n+    // collect all mutable pattern and group their NodeIDs by their Identifier to\n+    // avoid false warnings in match arms with multiple patterns\n+    let mut mutables = HashMap::new();\n+    for &p in pats.iter() {\n+        pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path| {\n+            match mode {\n+                ast::BindByValue(ast::MutMutable) => {\n+                    if path.segments.len() != 1 {\n+                        cx.tcx.sess.span_bug(p.span,\n+                                             \"mutable binding that doesn't consist \\\n+                                              of exactly one segment\");\n+                    }\n+                    let ident = path.segments.get(0).identifier;\n+                    if !token::get_ident(ident).get().starts_with(\"_\") {\n+                        mutables.insert_or_update_with(ident.name as uint, vec!(id), |_, old| {\n+                            old.push(id);\n+                        });\n+                    }\n+                }\n+                _ => {\n+                }\n+            }\n+        });\n+    }\n+\n+    let used_mutables = cx.tcx.used_mut_nodes.borrow();\n+    for (_, v) in mutables.iter() {\n+        if !v.iter().any(|e| used_mutables.contains(e)) {\n+            cx.span_lint(lint::UnusedMut, cx.tcx.map.span(*v.get(0)),\n+                         \"variable does not need to be mutable\");\n+        }\n+    }\n+}\n+\n+enum Allocation {\n+    VectorAllocation,\n+    BoxAllocation\n+}\n+\n+pub fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n+    // Warn if string and vector literals with sigils, or boxing expressions,\n+    // are immediately borrowed.\n+    let allocation = match e.node {\n+        ast::ExprVstore(e2, ast::ExprVstoreUniq) => {\n+            match e2.node {\n+                ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n+                    VectorAllocation\n+                }\n+                ast::ExprVec(..) => VectorAllocation,\n+                _ => return\n+            }\n+        }\n+        ast::ExprUnary(ast::UnUniq, _) |\n+        ast::ExprUnary(ast::UnBox, _) => BoxAllocation,\n+\n+        _ => return\n+    };\n+\n+    let report = |msg| {\n+        cx.span_lint(lint::UnnecessaryAllocation, e.span, msg);\n+    };\n+\n+    match cx.tcx.adjustments.borrow().find(&e.id) {\n+        Some(adjustment) => {\n+            match *adjustment {\n+                ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n+                    match (allocation, autoref) {\n+                        (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n+                            report(\"unnecessary allocation, the sigil can be \\\n+                                    removed\");\n+                        }\n+                        (BoxAllocation,\n+                         Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n+                            report(\"unnecessary allocation, use & instead\");\n+                        }\n+                        (BoxAllocation,\n+                         Some(ty::AutoPtr(_, ast::MutMutable))) => {\n+                            report(\"unnecessary allocation, use &mut \\\n+                                    instead\");\n+                        }\n+                        _ => ()\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        _ => ()\n+    }\n+}\n+\n+pub fn check_missing_doc_attrs(cx: &Context,\n+                           id: Option<ast::NodeId>,\n+                           attrs: &[ast::Attribute],\n+                           sp: Span,\n+                           desc: &'static str) {\n+    // If we're building a test harness, then warning about\n+    // documentation is probably not really relevant right now.\n+    if cx.tcx.sess.opts.test { return }\n+\n+    // `#[doc(hidden)]` disables missing_doc check.\n+    if cx.is_doc_hidden { return }\n+\n+    // Only check publicly-visible items, using the result from the privacy pass. It's an option so\n+    // the crate root can also use this function (it doesn't have a NodeId).\n+    match id {\n+        Some(ref id) if !cx.exported_items.contains(id) => return,\n+        _ => ()\n+    }\n+\n+    let has_doc = attrs.iter().any(|a| {\n+        match a.node.value.node {\n+            ast::MetaNameValue(ref name, _) if name.equiv(&(\"doc\")) => true,\n+            _ => false\n+        }\n+    });\n+    if !has_doc {\n+        cx.span_lint(lint::MissingDoc,\n+                     sp,\n+                     format!(\"missing documentation for {}\",\n+                             desc).as_slice());\n+    }\n+}\n+\n+pub fn check_missing_doc_item(cx: &Context, it: &ast::Item) {\n+    let desc = match it.node {\n+        ast::ItemFn(..) => \"a function\",\n+        ast::ItemMod(..) => \"a module\",\n+        ast::ItemEnum(..) => \"an enum\",\n+        ast::ItemStruct(..) => \"a struct\",\n+        ast::ItemTrait(..) => \"a trait\",\n+        _ => return\n+    };\n+    check_missing_doc_attrs(cx,\n+                            Some(it.id),\n+                            it.attrs.as_slice(),\n+                            it.span,\n+                            desc);\n+}\n+\n+pub fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n+    // If the method is an impl for a trait, don't doc.\n+    if lint::method_context(cx, m) == lint::TraitImpl { return; }\n+\n+    // Otherwise, doc according to privacy. This will also check\n+    // doc for default methods defined on traits.\n+    check_missing_doc_attrs(cx,\n+                            Some(m.id),\n+                            m.attrs.as_slice(),\n+                            m.span,\n+                            \"a method\");\n+}\n+\n+pub fn check_missing_doc_ty_method(cx: &Context, tm: &ast::TypeMethod) {\n+    check_missing_doc_attrs(cx,\n+                            Some(tm.id),\n+                            tm.attrs.as_slice(),\n+                            tm.span,\n+                            \"a type method\");\n+}\n+\n+pub fn check_missing_doc_struct_field(cx: &Context, sf: &ast::StructField) {\n+    match sf.node.kind {\n+        ast::NamedField(_, vis) if vis == ast::Public =>\n+            check_missing_doc_attrs(cx,\n+                                    Some(cx.cur_struct_def_id),\n+                                    sf.node.attrs.as_slice(),\n+                                    sf.span,\n+                                    \"a struct field\"),\n+        _ => {}\n+    }\n+}\n+\n+pub fn check_missing_doc_variant(cx: &Context, v: &ast::Variant) {\n+    check_missing_doc_attrs(cx,\n+                            Some(v.node.id),\n+                            v.node.attrs.as_slice(),\n+                            v.span,\n+                            \"a variant\");\n+}\n+\n+/// Checks for use of items with #[deprecated], #[experimental] and\n+/// #[unstable] (or none of them) attributes.\n+pub fn check_stability(cx: &Context, e: &ast::Expr) {\n+    let id = match e.node {\n+        ast::ExprPath(..) | ast::ExprStruct(..) => {\n+            match cx.tcx.def_map.borrow().find(&e.id) {\n+                Some(&def) => def.def_id(),\n+                None => return\n+            }\n+        }\n+        ast::ExprMethodCall(..) => {\n+            let method_call = typeck::MethodCall::expr(e.id);\n+            match cx.tcx.method_map.borrow().find(&method_call) {\n+                Some(method) => {\n+                    match method.origin {\n+                        typeck::MethodStatic(def_id) => {\n+                            // If this implements a trait method, get def_id\n+                            // of the method inside trait definition.\n+                            // Otherwise, use the current def_id (which refers\n+                            // to the method inside impl).\n+                            ty::trait_method_of_method(\n+                                cx.tcx, def_id).unwrap_or(def_id)\n+                        }\n+                        typeck::MethodParam(typeck::MethodParam {\n+                            trait_id: trait_id,\n+                            method_num: index,\n+                            ..\n+                        })\n+                        | typeck::MethodObject(typeck::MethodObject {\n+                            trait_id: trait_id,\n+                            method_num: index,\n+                            ..\n+                        }) => ty::trait_method(cx.tcx, trait_id, index).def_id\n+                    }\n+                }\n+                None => return\n+            }\n+        }\n+        _ => return\n+    };\n+\n+    let stability = if ast_util::is_local(id) {\n+        // this crate\n+        let s = cx.tcx.map.with_attrs(id.node, |attrs| {\n+            attrs.map(|a| attr::find_stability(a.as_slice()))\n+        });\n+        match s {\n+            Some(s) => s,\n+\n+            // no possibility of having attributes\n+            // (e.g. it's a local variable), so just\n+            // ignore it.\n+            None => return\n+        }\n+    } else {\n+        // cross-crate\n+\n+        let mut s = None;\n+        // run through all the attributes and take the first\n+        // stability one.\n+        csearch::get_item_attrs(&cx.tcx.sess.cstore, id, |attrs| {\n+            if s.is_none() {\n+                s = attr::find_stability(attrs.as_slice())\n+            }\n+        });\n+        s\n+    };\n+\n+    let (lint, label) = match stability {\n+        // no stability attributes == Unstable\n+        None => (lint::Unstable, \"unmarked\"),\n+        Some(attr::Stability { level: attr::Unstable, .. }) =>\n+                (lint::Unstable, \"unstable\"),\n+        Some(attr::Stability { level: attr::Experimental, .. }) =>\n+                (lint::Experimental, \"experimental\"),\n+        Some(attr::Stability { level: attr::Deprecated, .. }) =>\n+                (lint::Deprecated, \"deprecated\"),\n+        _ => return\n+    };\n+\n+    let msg = match stability {\n+        Some(attr::Stability { text: Some(ref s), .. }) => {\n+            format!(\"use of {} item: {}\", label, *s)\n+        }\n+        _ => format!(\"use of {} item\", label)\n+    };\n+\n+    cx.span_lint(lint, e.span, msg.as_slice());\n+}\n+\n+pub fn check_enum_variant_sizes(cx: &mut Context, it: &ast::Item) {\n+    match it.node {\n+        ast::ItemEnum(..) => {\n+            match cx.cur.find(&(lint::VariantSizeDifference as uint)) {\n+                Some(&(lvl, src)) if lvl != lint::Allow => {\n+                    cx.node_levels.insert((it.id, lint::VariantSizeDifference), (lvl, src));\n+                },\n+                _ => { }\n+            }\n+        },\n+        _ => { }\n+    }\n+}"}, {"sha": "e60726f6d6b7c8cb68e4faa332d3085ba11a7640", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 53, "deletions": 1070, "changes": 1123, "blob_url": "https://github.com/rust-lang/rust/blob/3144614f0ba39ba9f2a8c14f09c23c488be244eb/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3144614f0ba39ba9f2a8c14f09c23c488be244eb/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=3144614f0ba39ba9f2a8c14f09c23c488be244eb", "patch": "@@ -36,45 +36,28 @@\n #![allow(non_camel_case_types)]\n \n use driver::session;\n-use metadata::csearch;\n use middle::dead::DEAD_CODE_LINT_STR;\n-use middle::def;\n-use middle::def::*;\n-use middle::pat_util;\n use middle::privacy;\n-use middle::trans::adt; // for `adt::is_ffi_safe`\n use middle::ty;\n-use middle::typeck::astconv::{ast_ty_to_ty, AstConv};\n+use middle::typeck::astconv::AstConv;\n use middle::typeck::infer;\n-use middle::typeck;\n-use util::ppaux::{ty_to_str};\n use util::nodemap::NodeSet;\n \n-use std::cmp;\n use std::collections::HashMap;\n-use std::i16;\n-use std::i32;\n-use std::i64;\n-use std::i8;\n use std::rc::Rc;\n use std::gc::Gc;\n use std::to_str::ToStr;\n-use std::u16;\n-use std::u32;\n-use std::u64;\n-use std::u8;\n use std::collections::SmallIntMap;\n-use syntax::abi;\n-use syntax::ast_map;\n use syntax::ast_util::IdVisitingOperation;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::{ast, ast_util, visit};\n \n+mod builtin;\n+\n #[deriving(Clone, Show, PartialEq, PartialOrd, Eq, Ord, Hash)]\n pub enum Lint {\n     CTypes,\n@@ -697,918 +680,13 @@ pub fn contains_lint(attrs: &[ast::Attribute],\n     false\n }\n \n-fn check_while_true_expr(cx: &Context, e: &ast::Expr) {\n-    match e.node {\n-        ast::ExprWhile(cond, _) => {\n-            match cond.node {\n-                ast::ExprLit(lit) => {\n-                    match lit.node {\n-                        ast::LitBool(true) => {\n-                            cx.span_lint(WhileTrue,\n-                                         e.span,\n-                                         \"denote infinite loops with loop \\\n-                                          { ... }\");\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                _ => ()\n-            }\n-        }\n-        _ => ()\n-    }\n-}\n-impl<'a> AstConv for Context<'a>{\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n-        ty::lookup_item_type(self.tcx, id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n-        ty::lookup_trait_def(self.tcx, id)\n-    }\n-\n-    fn ty_infer(&self, _span: Span) -> ty::t {\n-        infer::new_infer_ctxt(self.tcx).next_ty_var()\n-    }\n-}\n-\n-\n-fn check_unused_casts(cx: &Context, e: &ast::Expr) {\n-    return match e.node {\n-        ast::ExprCast(expr, ty) => {\n-            let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &*ty);\n-            if  ty::get(ty::expr_ty(cx.tcx, &*expr)).sty == ty::get(t_t).sty {\n-                cx.span_lint(UnnecessaryTypecast, ty.span,\n-                             \"unnecessary type cast\");\n-            }\n-        }\n-        _ => ()\n-    };\n-}\n-\n-fn check_type_limits(cx: &Context, e: &ast::Expr) {\n-    return match e.node {\n-        ast::ExprUnary(ast::UnNeg, ex) => {\n-            match ex.node  {\n-                ast::ExprLit(lit) => {\n-                    match lit.node {\n-                        ast::LitUint(..) => {\n-                            cx.span_lint(UnsignedNegate, e.span,\n-                                         \"negation of unsigned int literal may be unintentional\");\n-                        },\n-                        _ => ()\n-                    }\n-                },\n-                _ => {\n-                    let t = ty::expr_ty(cx.tcx, &*ex);\n-                    match ty::get(t).sty {\n-                        ty::ty_uint(_) => {\n-                            cx.span_lint(UnsignedNegate, e.span,\n-                                         \"negation of unsigned int variable may be unintentional\");\n-                        },\n-                        _ => ()\n-                    }\n-                }\n-            }\n-        },\n-        ast::ExprBinary(binop, l, r) => {\n-            if is_comparison(binop) && !check_limits(cx.tcx, binop, &*l, &*r) {\n-                cx.span_lint(TypeLimits, e.span,\n-                             \"comparison is useless due to type limits\");\n-            }\n-        },\n-        ast::ExprLit(lit) => {\n-            match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n-                ty::ty_int(t) => {\n-                    let int_type = if t == ast::TyI {\n-                        cx.tcx.sess.targ_cfg.int_type\n-                    } else { t };\n-                    let (min, max) = int_ty_range(int_type);\n-                    let mut lit_val: i64 = match lit.node {\n-                        ast::LitInt(v, _) => v,\n-                        ast::LitUint(v, _) => v as i64,\n-                        ast::LitIntUnsuffixed(v) => v,\n-                        _ => fail!()\n-                    };\n-                    if cx.negated_expr_id == e.id {\n-                        lit_val *= -1;\n-                    }\n-                    if  lit_val < min || lit_val > max {\n-                        cx.span_lint(TypeOverflow, e.span,\n-                                     \"literal out of range for its type\");\n-                    }\n-                },\n-                ty::ty_uint(t) => {\n-                    let uint_type = if t == ast::TyU {\n-                        cx.tcx.sess.targ_cfg.uint_type\n-                    } else { t };\n-                    let (min, max) = uint_ty_range(uint_type);\n-                    let lit_val: u64 = match lit.node {\n-                        ast::LitByte(_v) => return,  // _v is u8, within range by definition\n-                        ast::LitInt(v, _) => v as u64,\n-                        ast::LitUint(v, _) => v,\n-                        ast::LitIntUnsuffixed(v) => v as u64,\n-                        _ => fail!()\n-                    };\n-                    if  lit_val < min || lit_val > max {\n-                        cx.span_lint(TypeOverflow, e.span,\n-                                     \"literal out of range for its type\");\n-                    }\n-                },\n-\n-                _ => ()\n-            };\n-        },\n-        _ => ()\n-    };\n-\n-    fn is_valid<T:cmp::PartialOrd>(binop: ast::BinOp, v: T,\n-                            min: T, max: T) -> bool {\n-        match binop {\n-            ast::BiLt => v >  min && v <= max,\n-            ast::BiLe => v >= min && v <  max,\n-            ast::BiGt => v >= min && v <  max,\n-            ast::BiGe => v >  min && v <= max,\n-            ast::BiEq | ast::BiNe => v >= min && v <= max,\n-            _ => fail!()\n-        }\n-    }\n-\n-    fn rev_binop(binop: ast::BinOp) -> ast::BinOp {\n-        match binop {\n-            ast::BiLt => ast::BiGt,\n-            ast::BiLe => ast::BiGe,\n-            ast::BiGt => ast::BiLt,\n-            ast::BiGe => ast::BiLe,\n-            _ => binop\n-        }\n-    }\n-\n-    // for int & uint, be conservative with the warnings, so that the\n-    // warnings are consistent between 32- and 64-bit platforms\n-    fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n-        match int_ty {\n-            ast::TyI =>    (i64::MIN,        i64::MAX),\n-            ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n-            ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n-            ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n-            ast::TyI64 =>  (i64::MIN,        i64::MAX)\n-        }\n-    }\n-\n-    fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n-        match uint_ty {\n-            ast::TyU =>   (u64::MIN,         u64::MAX),\n-            ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n-            ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n-            ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n-            ast::TyU64 => (u64::MIN,         u64::MAX)\n-        }\n-    }\n-\n-    fn check_limits(tcx: &ty::ctxt, binop: ast::BinOp,\n-                    l: &ast::Expr, r: &ast::Expr) -> bool {\n-        let (lit, expr, swap) = match (&l.node, &r.node) {\n-            (&ast::ExprLit(_), _) => (l, r, true),\n-            (_, &ast::ExprLit(_)) => (r, l, false),\n-            _ => return true\n-        };\n-        // Normalize the binop so that the literal is always on the RHS in\n-        // the comparison\n-        let norm_binop = if swap { rev_binop(binop) } else { binop };\n-        match ty::get(ty::expr_ty(tcx, expr)).sty {\n-            ty::ty_int(int_ty) => {\n-                let (min, max) = int_ty_range(int_ty);\n-                let lit_val: i64 = match lit.node {\n-                    ast::ExprLit(li) => match li.node {\n-                        ast::LitInt(v, _) => v,\n-                        ast::LitUint(v, _) => v as i64,\n-                        ast::LitIntUnsuffixed(v) => v,\n-                        _ => return true\n-                    },\n-                    _ => fail!()\n-                };\n-                is_valid(norm_binop, lit_val, min, max)\n-            }\n-            ty::ty_uint(uint_ty) => {\n-                let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n-                let lit_val: u64 = match lit.node {\n-                    ast::ExprLit(li) => match li.node {\n-                        ast::LitInt(v, _) => v as u64,\n-                        ast::LitUint(v, _) => v,\n-                        ast::LitIntUnsuffixed(v) => v as u64,\n-                        _ => return true\n-                    },\n-                    _ => fail!()\n-                };\n-                is_valid(norm_binop, lit_val, min, max)\n-            }\n-            _ => true\n-        }\n-    }\n-\n-    fn is_comparison(binop: ast::BinOp) -> bool {\n-        match binop {\n-            ast::BiEq | ast::BiLt | ast::BiLe |\n-            ast::BiNe | ast::BiGe | ast::BiGt => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n-fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n-    fn check_ty(cx: &Context, ty: &ast::Ty) {\n-        match ty.node {\n-            ast::TyPath(_, _, id) => {\n-                match cx.tcx.def_map.borrow().get_copy(&id) {\n-                    def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n-                        cx.span_lint(CTypes, ty.span,\n-                                \"found rust type `int` in foreign module, while \\\n-                                libc::c_int or libc::c_long should be used\");\n-                    }\n-                    def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n-                        cx.span_lint(CTypes, ty.span,\n-                                \"found rust type `uint` in foreign module, while \\\n-                                libc::c_uint or libc::c_ulong should be used\");\n-                    }\n-                    def::DefTy(def_id) => {\n-                        if !adt::is_ffi_safe(cx.tcx, def_id) {\n-                            cx.span_lint(CTypes, ty.span,\n-                                         \"found enum type without foreign-function-safe \\\n-                                          representation annotation in foreign module\");\n-                            // hmm... this message could be more helpful\n-                        }\n-                    }\n-                    _ => ()\n-                }\n-            }\n-            ast::TyPtr(ref mt) => { check_ty(cx, &*mt.ty) }\n-            _ => {}\n-        }\n-    }\n-\n-    fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n-        for input in decl.inputs.iter() {\n-            check_ty(cx, &*input.ty);\n-        }\n-        check_ty(cx, &*decl.output)\n-    }\n-\n-    match it.node {\n-      ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n-        for ni in nmod.items.iter() {\n-            match ni.node {\n-                ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, &*decl),\n-                ast::ForeignItemStatic(t, _) => check_ty(cx, &*t)\n-            }\n-        }\n-      }\n-      _ => {/* nothing to do */ }\n-    }\n-}\n-\n-fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n-    let xs = [ManagedHeapMemory, OwnedHeapMemory, HeapMemory];\n-    for &lint in xs.iter() {\n-        if cx.get_level(lint) == Allow { continue }\n-\n-        let mut n_box = 0;\n-        let mut n_uniq = 0;\n-        ty::fold_ty(cx.tcx, ty, |t| {\n-            match ty::get(t).sty {\n-                ty::ty_box(_) => {\n-                    n_box += 1;\n-                }\n-                ty::ty_uniq(_) |\n-                ty::ty_closure(box ty::ClosureTy {\n-                    store: ty::UniqTraitStore,\n-                    ..\n-                }) => {\n-                    n_uniq += 1;\n-                }\n-\n-                _ => ()\n-            };\n-            t\n-        });\n-\n-        if n_uniq > 0 && lint != ManagedHeapMemory {\n-            let s = ty_to_str(cx.tcx, ty);\n-            let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(lint, span, m.as_slice());\n-        }\n-\n-        if n_box > 0 && lint != OwnedHeapMemory {\n-            let s = ty_to_str(cx.tcx, ty);\n-            let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n-            cx.span_lint(lint, span, m.as_slice());\n-        }\n-    }\n-}\n-\n-fn check_heap_item(cx: &Context, it: &ast::Item) {\n-    match it.node {\n-        ast::ItemFn(..) |\n-        ast::ItemTy(..) |\n-        ast::ItemEnum(..) |\n-        ast::ItemStruct(..) => check_heap_type(cx, it.span,\n-                                               ty::node_id_to_type(cx.tcx,\n-                                                                   it.id)),\n-        _ => ()\n-    }\n-\n-    // If it's a struct, we also have to check the fields' types\n-    match it.node {\n-        ast::ItemStruct(struct_def, _) => {\n-            for struct_field in struct_def.fields.iter() {\n-                check_heap_type(cx, struct_field.span,\n-                                ty::node_id_to_type(cx.tcx,\n-                                                    struct_field.node.id));\n-            }\n-        }\n-        _ => ()\n-    }\n-}\n-\n-struct RawPtrDerivingVisitor<'a> {\n-    cx: &'a Context<'a>\n-}\n-\n-impl<'a> Visitor<()> for RawPtrDerivingVisitor<'a> {\n-    fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n-        static MSG: &'static str = \"use of `#[deriving]` with a raw pointer\";\n-        match ty.node {\n-            ast::TyPtr(..) => self.cx.span_lint(RawPointerDeriving, ty.span, MSG),\n-            _ => {}\n-        }\n-        visit::walk_ty(self, ty, ());\n-    }\n-    // explicit override to a no-op to reduce code bloat\n-    fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n-    fn visit_block(&mut self, _: &ast::Block, _: ()) {}\n-}\n-\n-fn check_raw_ptr_deriving(cx: &mut Context, item: &ast::Item) {\n-    if !attr::contains_name(item.attrs.as_slice(), \"automatically_derived\") {\n-        return\n-    }\n-    let did = match item.node {\n-        ast::ItemImpl(..) => {\n-            match ty::get(ty::node_id_to_type(cx.tcx, item.id)).sty {\n-                ty::ty_enum(did, _) => did,\n-                ty::ty_struct(did, _) => did,\n-                _ => return,\n-            }\n-        }\n-        _ => return,\n-    };\n-    if !ast_util::is_local(did) { return }\n-    let item = match cx.tcx.map.find(did.node) {\n-        Some(ast_map::NodeItem(item)) => item,\n-        _ => return,\n-    };\n-    if !cx.checked_raw_pointers.insert(item.id) { return }\n-    match item.node {\n-        ast::ItemStruct(..) | ast::ItemEnum(..) => {\n-            let mut visitor = RawPtrDerivingVisitor { cx: cx };\n-            visit::walk_item(&mut visitor, &*item, ());\n-        }\n-        _ => {}\n-    }\n-}\n-\n-fn check_unused_attribute(cx: &Context, attr: &ast::Attribute) {\n-    static ATTRIBUTE_WHITELIST: &'static [&'static str] = &'static [\n-        // FIXME: #14408 whitelist docs since rustdoc looks at them\n-        \"doc\",\n-\n-        // FIXME: #14406 these are processed in trans, which happens after the\n-        // lint pass\n-        \"cold\",\n-        \"inline\",\n-        \"link\",\n-        \"link_name\",\n-        \"link_section\",\n-        \"no_builtins\",\n-        \"no_mangle\",\n-        \"no_split_stack\",\n-        \"packed\",\n-        \"static_assert\",\n-        \"thread_local\",\n-\n-        // not used anywhere (!?) but apparently we want to keep them around\n-        \"comment\",\n-        \"desc\",\n-        \"license\",\n-\n-        // FIXME: #14407 these are only looked at on-demand so we can't\n-        // guarantee they'll have already been checked\n-        \"deprecated\",\n-        \"experimental\",\n-        \"frozen\",\n-        \"locked\",\n-        \"must_use\",\n-        \"stable\",\n-        \"unstable\",\n-    ];\n-\n-    static CRATE_ATTRS: &'static [&'static str] = &'static [\n-        \"crate_type\",\n-        \"feature\",\n-        \"no_start\",\n-        \"no_main\",\n-        \"no_std\",\n-        \"crate_id\",\n-        \"desc\",\n-        \"comment\",\n-        \"license\",\n-        \"copyright\",\n-        \"no_builtins\",\n-    ];\n-\n-    for &name in ATTRIBUTE_WHITELIST.iter() {\n-        if attr.check_name(name) {\n-            break;\n-        }\n-    }\n-\n-    if !attr::is_used(attr) {\n-        cx.span_lint(UnusedAttribute, attr.span, \"unused attribute\");\n-        if CRATE_ATTRS.contains(&attr.name().get()) {\n-            let msg = match attr.node.style {\n-                ast::AttrOuter => \"crate-level attribute should be an inner \\\n-                                  attribute: add an exclamation mark: #![foo]\",\n-                ast::AttrInner => \"crate-level attribute should be in the \\\n-                                   root module\",\n-            };\n-            cx.span_lint(UnusedAttribute, attr.span, msg);\n-        }\n-    }\n-}\n-\n-fn check_heap_expr(cx: &Context, e: &ast::Expr) {\n-    let ty = ty::expr_ty(cx.tcx, e);\n-    check_heap_type(cx, e.span, ty);\n-}\n-\n-fn check_path_statement(cx: &Context, s: &ast::Stmt) {\n-    match s.node {\n-        ast::StmtSemi(expr, _) => {\n-            match expr.node {\n-                ast::ExprPath(_) => {\n-                    cx.span_lint(PathStatement,\n-                                 s.span,\n-                                 \"path statement with no effect\");\n-                }\n-                _ => {}\n-            }\n-        }\n-        _ => ()\n-    }\n-}\n-\n-fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n-    let expr = match s.node {\n-        ast::StmtSemi(expr, _) => expr,\n-        _ => return\n-    };\n-    let t = ty::expr_ty(cx.tcx, &*expr);\n-    match ty::get(t).sty {\n-        ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n-        _ => {}\n-    }\n-    match expr.node {\n-        ast::ExprRet(..) => return,\n-        _ => {}\n-    }\n-\n-    let t = ty::expr_ty(cx.tcx, &*expr);\n-    let mut warned = false;\n-    match ty::get(t).sty {\n-        ty::ty_struct(did, _) |\n-        ty::ty_enum(did, _) => {\n-            if ast_util::is_local(did) {\n-                match cx.tcx.map.get(did.node) {\n-                    ast_map::NodeItem(it) => {\n-                        if attr::contains_name(it.attrs.as_slice(),\n-                                               \"must_use\") {\n-                            cx.span_lint(UnusedMustUse, s.span,\n-                                         \"unused result which must be used\");\n-                            warned = true;\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            } else {\n-                csearch::get_item_attrs(&cx.tcx.sess.cstore, did, |attrs| {\n-                    if attr::contains_name(attrs.as_slice(), \"must_use\") {\n-                        cx.span_lint(UnusedMustUse, s.span,\n-                                     \"unused result which must be used\");\n-                        warned = true;\n-                    }\n-                });\n-            }\n-        }\n-        _ => {}\n-    }\n-    if !warned {\n-        cx.span_lint(UnusedResult, s.span, \"unused result\");\n-    }\n-}\n-\n-fn check_item_non_camel_case_types(cx: &Context, it: &ast::Item) {\n-    fn is_camel_case(ident: ast::Ident) -> bool {\n-        let ident = token::get_ident(ident);\n-        assert!(!ident.get().is_empty());\n-        let ident = ident.get().trim_chars('_');\n-\n-        // start with a non-lowercase letter rather than non-uppercase\n-        // ones (some scripts don't have a concept of upper/lowercase)\n-        !ident.char_at(0).is_lowercase() && !ident.contains_char('_')\n-    }\n-\n-    fn to_camel_case(s: &str) -> String {\n-        s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n-            if i == 0 { c.to_uppercase() }\n-            else { c }\n-        )).collect()\n-    }\n-\n-    fn check_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n-        let s = token::get_ident(ident);\n-\n-        if !is_camel_case(ident) {\n-            cx.span_lint(\n-                NonCamelCaseTypes, span,\n-                format!(\"{} `{}` should have a camel case name such as `{}`\",\n-                    sort, s, to_camel_case(s.get())).as_slice());\n-        }\n-    }\n-\n-    match it.node {\n-        ast::ItemTy(..) | ast::ItemStruct(..) => {\n-            check_case(cx, \"type\", it.ident, it.span)\n-        }\n-        ast::ItemTrait(..) => {\n-            check_case(cx, \"trait\", it.ident, it.span)\n-        }\n-        ast::ItemEnum(ref enum_definition, _) => {\n-            check_case(cx, \"type\", it.ident, it.span);\n-            for variant in enum_definition.variants.iter() {\n-                check_case(cx, \"variant\", variant.node.name, variant.span);\n-            }\n-        }\n-        _ => ()\n-    }\n-}\n-\n-fn check_snake_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n-    fn is_snake_case(ident: ast::Ident) -> bool {\n-        let ident = token::get_ident(ident);\n-        assert!(!ident.get().is_empty());\n-        let ident = ident.get().trim_chars('_');\n-\n-        let mut allow_underscore = true;\n-        ident.chars().all(|c| {\n-            allow_underscore = match c {\n-                c if c.is_lowercase() || c.is_digit() => true,\n-                '_' if allow_underscore => false,\n-                _ => return false,\n-            };\n-            true\n-        })\n-    }\n-\n-    fn to_snake_case(str: &str) -> String {\n-        let mut words = vec![];\n-        for s in str.split('_') {\n-            let mut buf = String::new();\n-            if s.is_empty() { continue; }\n-            for ch in s.chars() {\n-                if !buf.is_empty() && ch.is_uppercase() {\n-                    words.push(buf);\n-                    buf = String::new();\n-                }\n-                buf.push_char(ch.to_lowercase());\n-            }\n-            words.push(buf);\n-        }\n-        words.connect(\"_\")\n-    }\n-\n-    let s = token::get_ident(ident);\n-\n-    if !is_snake_case(ident) {\n-        cx.span_lint(NonSnakeCaseFunctions, span,\n-                    format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                            sort, s, to_snake_case(s.get())).as_slice());\n-    }\n-}\n-\n-fn check_item_non_uppercase_statics(cx: &Context, it: &ast::Item) {\n-    match it.node {\n-        // only check static constants\n-        ast::ItemStatic(_, ast::MutImmutable, _) => {\n-            let s = token::get_ident(it.ident);\n-            // check for lowercase letters rather than non-uppercase\n-            // ones (some scripts don't have a concept of\n-            // upper/lowercase)\n-            if s.get().chars().any(|c| c.is_lowercase()) {\n-                cx.span_lint(NonUppercaseStatics, it.span,\n-                            format!(\"static constant `{}` should have an uppercase name \\\n-                                such as `{}`\", s.get(),\n-                                s.get().chars().map(|c| c.to_uppercase())\n-                                    .collect::<String>().as_slice()).as_slice());\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n-fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n-    // Lint for constants that look like binding identifiers (#7526)\n-    match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n-        (&ast::PatIdent(_, ref path, _), Some(&def::DefStatic(_, false))) => {\n-            // last identifier alone is right choice for this lint.\n-            let ident = path.segments.last().unwrap().identifier;\n-            let s = token::get_ident(ident);\n-            if s.get().chars().any(|c| c.is_lowercase()) {\n-                cx.span_lint(NonUppercasePatternStatics, path.span,\n-                            format!(\"static constant in pattern `{}` should have an uppercase \\\n-                                name such as `{}`\", s.get(),\n-                                s.get().chars().map(|c| c.to_uppercase())\n-                                    .collect::<String>().as_slice()).as_slice());\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n-fn check_pat_uppercase_variable(cx: &Context, p: &ast::Pat) {\n-    match &p.node {\n-        &ast::PatIdent(_, ref path, _) => {\n-            match cx.tcx.def_map.borrow().find(&p.id) {\n-                Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |\n-                        Some(&def::DefArg(_, _)) => {\n-                    // last identifier alone is right choice for this lint.\n-                    let ident = path.segments.last().unwrap().identifier;\n-                    let s = token::get_ident(ident);\n-                    if s.get().len() > 0 && s.get().char_at(0).is_uppercase() {\n-                        cx.span_lint(\n-                            UppercaseVariables,\n-                            path.span,\n-                            \"variable names should start with a lowercase character\");\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n-fn check_struct_uppercase_variable(cx: &Context, s: &ast::StructDef) {\n-    for sf in s.fields.iter() {\n-        match sf.node {\n-            ast::StructField_ { kind: ast::NamedField(ident, _), .. } => {\n-                let s = token::get_ident(ident);\n-                if s.get().char_at(0).is_uppercase() {\n-                    cx.span_lint(\n-                        UppercaseVariables,\n-                        sf.span,\n-                        \"structure field names should start with a lowercase character\");\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n-fn check_unnecessary_parens_core(cx: &Context, value: &ast::Expr, msg: &str) {\n-    match value.node {\n-        ast::ExprParen(_) => {\n-            cx.span_lint(UnnecessaryParens, value.span,\n-                         format!(\"unnecessary parentheses around {}\",\n-                                 msg).as_slice())\n-        }\n-        _ => {}\n-    }\n-}\n-\n-fn check_unnecessary_parens_expr(cx: &Context, e: &ast::Expr) {\n-    let (value, msg) = match e.node {\n-        ast::ExprIf(cond, _, _) => (cond, \"`if` condition\"),\n-        ast::ExprWhile(cond, _) => (cond, \"`while` condition\"),\n-        ast::ExprMatch(head, _) => (head, \"`match` head expression\"),\n-        ast::ExprRet(Some(value)) => (value, \"`return` value\"),\n-        ast::ExprAssign(_, value) => (value, \"assigned value\"),\n-        ast::ExprAssignOp(_, _, value) => (value, \"assigned value\"),\n-        _ => return\n-    };\n-    check_unnecessary_parens_core(cx, &*value, msg);\n-}\n-\n-fn check_unnecessary_parens_stmt(cx: &Context, s: &ast::Stmt) {\n-    let (value, msg) = match s.node {\n-        ast::StmtDecl(decl, _) => match decl.node {\n-            ast::DeclLocal(local) => match local.init {\n-                Some(value) => (value, \"assigned value\"),\n-                None => return\n-            },\n-            _ => return\n-        },\n-        _ => return\n-    };\n-    check_unnecessary_parens_core(cx, &*value, msg);\n-}\n-\n-fn check_unused_unsafe(cx: &Context, e: &ast::Expr) {\n-    match e.node {\n-        // Don't warn about generated blocks, that'll just pollute the output.\n-        ast::ExprBlock(ref blk) => {\n-            if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n-                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n-                cx.span_lint(UnusedUnsafe, blk.span,\n-                             \"unnecessary `unsafe` block\");\n-            }\n-        }\n-        _ => ()\n-    }\n-}\n-\n-fn check_unsafe_block(cx: &Context, e: &ast::Expr) {\n-    match e.node {\n-        // Don't warn about generated blocks, that'll just pollute the output.\n-        ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n-            cx.span_lint(UnsafeBlock, blk.span, \"usage of an `unsafe` block\");\n-        }\n-        _ => ()\n-    }\n-}\n-\n-fn check_unused_mut_pat(cx: &Context, pats: &[Gc<ast::Pat>]) {\n-    // collect all mutable pattern and group their NodeIDs by their Identifier to\n-    // avoid false warnings in match arms with multiple patterns\n-    let mut mutables = HashMap::new();\n-    for &p in pats.iter() {\n-        pat_util::pat_bindings(&cx.tcx.def_map, &*p, |mode, id, _, path| {\n-            match mode {\n-                ast::BindByValue(ast::MutMutable) => {\n-                    if path.segments.len() != 1 {\n-                        cx.tcx.sess.span_bug(p.span,\n-                                             \"mutable binding that doesn't consist \\\n-                                              of exactly one segment\");\n-                    }\n-                    let ident = path.segments.get(0).identifier;\n-                    if !token::get_ident(ident).get().starts_with(\"_\") {\n-                        mutables.insert_or_update_with(ident.name as uint, vec!(id), |_, old| {\n-                            old.push(id);\n-                        });\n-                    }\n-                }\n-                _ => {\n-                }\n-            }\n-        });\n-    }\n-\n-    let used_mutables = cx.tcx.used_mut_nodes.borrow();\n-    for (_, v) in mutables.iter() {\n-        if !v.iter().any(|e| used_mutables.contains(e)) {\n-            cx.span_lint(UnusedMut, cx.tcx.map.span(*v.get(0)),\n-                         \"variable does not need to be mutable\");\n-        }\n-    }\n-}\n-\n-enum Allocation {\n-    VectorAllocation,\n-    BoxAllocation\n-}\n-\n-fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n-    // Warn if string and vector literals with sigils, or boxing expressions,\n-    // are immediately borrowed.\n-    let allocation = match e.node {\n-        ast::ExprVstore(e2, ast::ExprVstoreUniq) => {\n-            match e2.node {\n-                ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n-                    VectorAllocation\n-                }\n-                ast::ExprVec(..) => VectorAllocation,\n-                _ => return\n-            }\n-        }\n-        ast::ExprUnary(ast::UnUniq, _) |\n-        ast::ExprUnary(ast::UnBox, _) => BoxAllocation,\n-\n-        _ => return\n-    };\n-\n-    let report = |msg| {\n-        cx.span_lint(UnnecessaryAllocation, e.span, msg);\n-    };\n-\n-    match cx.tcx.adjustments.borrow().find(&e.id) {\n-        Some(adjustment) => {\n-            match *adjustment {\n-                ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n-                    match (allocation, autoref) {\n-                        (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n-                            report(\"unnecessary allocation, the sigil can be \\\n-                                    removed\");\n-                        }\n-                        (BoxAllocation,\n-                         Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n-                            report(\"unnecessary allocation, use & instead\");\n-                        }\n-                        (BoxAllocation,\n-                         Some(ty::AutoPtr(_, ast::MutMutable))) => {\n-                            report(\"unnecessary allocation, use &mut \\\n-                                    instead\");\n-                        }\n-                        _ => ()\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        _ => ()\n-    }\n-}\n-\n-fn check_missing_doc_attrs(cx: &Context,\n-                           id: Option<ast::NodeId>,\n-                           attrs: &[ast::Attribute],\n-                           sp: Span,\n-                           desc: &'static str) {\n-    // If we're building a test harness, then warning about\n-    // documentation is probably not really relevant right now.\n-    if cx.tcx.sess.opts.test { return }\n-\n-    // `#[doc(hidden)]` disables missing_doc check.\n-    if cx.is_doc_hidden { return }\n-\n-    // Only check publicly-visible items, using the result from the privacy pass. It's an option so\n-    // the crate root can also use this function (it doesn't have a NodeId).\n-    match id {\n-        Some(ref id) if !cx.exported_items.contains(id) => return,\n-        _ => ()\n-    }\n-\n-    let has_doc = attrs.iter().any(|a| {\n-        match a.node.value.node {\n-            ast::MetaNameValue(ref name, _) if name.equiv(&(\"doc\")) => true,\n-            _ => false\n-        }\n-    });\n-    if !has_doc {\n-        cx.span_lint(MissingDoc,\n-                     sp,\n-                     format!(\"missing documentation for {}\",\n-                             desc).as_slice());\n-    }\n-}\n-\n-fn check_missing_doc_item(cx: &Context, it: &ast::Item) {\n-    let desc = match it.node {\n-        ast::ItemFn(..) => \"a function\",\n-        ast::ItemMod(..) => \"a module\",\n-        ast::ItemEnum(..) => \"an enum\",\n-        ast::ItemStruct(..) => \"a struct\",\n-        ast::ItemTrait(..) => \"a trait\",\n-        _ => return\n-    };\n-    check_missing_doc_attrs(cx,\n-                            Some(it.id),\n-                            it.attrs.as_slice(),\n-                            it.span,\n-                            desc);\n-}\n-\n #[deriving(PartialEq)]\n enum MethodContext {\n     TraitDefaultImpl,\n     TraitImpl,\n     PlainImpl\n }\n \n-fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n-    // If the method is an impl for a trait, don't doc.\n-    if method_context(cx, m) == TraitImpl { return; }\n-\n-    // Otherwise, doc according to privacy. This will also check\n-    // doc for default methods defined on traits.\n-    check_missing_doc_attrs(cx,\n-                            Some(m.id),\n-                            m.attrs.as_slice(),\n-                            m.span,\n-                            \"a method\");\n-}\n-\n fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n     let did = ast::DefId {\n         krate: ast::LOCAL_CRATE,\n@@ -1631,129 +709,32 @@ fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n     }\n }\n \n-fn check_missing_doc_ty_method(cx: &Context, tm: &ast::TypeMethod) {\n-    check_missing_doc_attrs(cx,\n-                            Some(tm.id),\n-                            tm.attrs.as_slice(),\n-                            tm.span,\n-                            \"a type method\");\n-}\n+impl<'a> AstConv for Context<'a>{\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n-fn check_missing_doc_struct_field(cx: &Context, sf: &ast::StructField) {\n-    match sf.node.kind {\n-        ast::NamedField(_, vis) if vis == ast::Public =>\n-            check_missing_doc_attrs(cx,\n-                                    Some(cx.cur_struct_def_id),\n-                                    sf.node.attrs.as_slice(),\n-                                    sf.span,\n-                                    \"a struct field\"),\n-        _ => {}\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n+        ty::lookup_item_type(self.tcx, id)\n     }\n-}\n-\n-fn check_missing_doc_variant(cx: &Context, v: &ast::Variant) {\n-    check_missing_doc_attrs(cx,\n-                            Some(v.node.id),\n-                            v.node.attrs.as_slice(),\n-                            v.span,\n-                            \"a variant\");\n-}\n-\n-/// Checks for use of items with #[deprecated], #[experimental] and\n-/// #[unstable] (or none of them) attributes.\n-fn check_stability(cx: &Context, e: &ast::Expr) {\n-    let tcx = cx.tcx;\n-\n-    let id = match e.node {\n-        ast::ExprPath(..) | ast::ExprStruct(..) => {\n-            match cx.tcx.def_map.borrow().find(&e.id) {\n-                Some(&def) => def.def_id(),\n-                None => return\n-            }\n-        }\n-        ast::ExprMethodCall(..) => {\n-            let method_call = typeck::MethodCall::expr(e.id);\n-            match tcx.method_map.borrow().find(&method_call) {\n-                Some(method) => {\n-                    match method.origin {\n-                        typeck::MethodStatic(def_id) => {\n-                            // If this implements a trait method, get def_id\n-                            // of the method inside trait definition.\n-                            // Otherwise, use the current def_id (which refers\n-                            // to the method inside impl).\n-                            ty::trait_method_of_method(cx.tcx, def_id)\n-                               .unwrap_or(def_id)\n-                        }\n-                        typeck::MethodParam(typeck::MethodParam {\n-                            trait_id: trait_id,\n-                            method_num: index,\n-                            ..\n-                        })\n-                        | typeck::MethodObject(typeck::MethodObject {\n-                            trait_id: trait_id,\n-                            method_num: index,\n-                            ..\n-                        }) => ty::trait_method(cx.tcx, trait_id, index).def_id\n-                    }\n-                }\n-                None => return\n-            }\n-        }\n-        _ => return\n-    };\n-\n-    // stability attributes are promises made across crates; do not\n-    // check anything for crate-local usage.\n-    if ast_util::is_local(id) { return }\n-\n-    let stability = tcx.stability.borrow_mut().lookup(&tcx.sess.cstore, id);\n-\n-    let (lint, label) = match stability {\n-        // no stability attributes == Unstable\n-        None => (Unstable, \"unmarked\"),\n-        Some(attr::Stability { level: attr::Unstable, .. }) =>\n-                (Unstable, \"unstable\"),\n-        Some(attr::Stability { level: attr::Experimental, .. }) =>\n-                (Experimental, \"experimental\"),\n-        Some(attr::Stability { level: attr::Deprecated, .. }) =>\n-                (Deprecated, \"deprecated\"),\n-        _ => return\n-    };\n \n-    let msg = match stability {\n-        Some(attr::Stability { text: Some(ref s), .. }) => {\n-            format!(\"use of {} item: {}\", label, *s)\n-        }\n-        _ => format!(\"use of {} item\", label)\n-    };\n-\n-    cx.span_lint(lint, e.span, msg.as_slice());\n-}\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+        ty::lookup_trait_def(self.tcx, id)\n+    }\n \n-fn check_enum_variant_sizes(cx: &mut Context, it: &ast::Item) {\n-    match it.node {\n-        ast::ItemEnum(..) => {\n-            match cx.cur.find(&(VariantSizeDifference as uint)) {\n-                Some(&(lvl, src)) if lvl != Allow => {\n-                    cx.node_levels.insert((it.id, VariantSizeDifference), (lvl, src));\n-                },\n-                _ => { }\n-            }\n-        },\n-        _ => { }\n+    fn ty_infer(&self, _span: Span) -> ty::t {\n+        infer::new_infer_ctxt(self.tcx).next_ty_var()\n     }\n }\n \n impl<'a> Visitor<()> for Context<'a> {\n     fn visit_item(&mut self, it: &ast::Item, _: ()) {\n         self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n-            check_enum_variant_sizes(cx, it);\n-            check_item_ctypes(cx, it);\n-            check_item_non_camel_case_types(cx, it);\n-            check_item_non_uppercase_statics(cx, it);\n-            check_heap_item(cx, it);\n-            check_missing_doc_item(cx, it);\n-            check_raw_ptr_deriving(cx, it);\n+            builtin::check_enum_variant_sizes(cx, it);\n+            builtin::check_item_ctypes(cx, it);\n+            builtin::check_item_non_camel_case_types(cx, it);\n+            builtin::check_item_non_uppercase_statics(cx, it);\n+            builtin::check_heap_item(cx, it);\n+            builtin::check_missing_doc_item(cx, it);\n+            builtin::check_raw_ptr_deriving(cx, it);\n \n             cx.visit_ids(|v| v.visit_item(it, ()));\n \n@@ -1776,8 +757,8 @@ impl<'a> Visitor<()> for Context<'a> {\n     }\n \n     fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n-        check_pat_non_uppercase_statics(self, p);\n-        check_pat_uppercase_variable(self, p);\n+        builtin::check_pat_non_uppercase_statics(self, p);\n+        builtin::check_pat_uppercase_variable(self, p);\n \n         visit::walk_pat(self, p, ());\n     }\n@@ -1795,36 +776,36 @@ impl<'a> Visitor<()> for Context<'a> {\n             },\n             ast::ExprMatch(_, ref arms) => {\n                 for a in arms.iter() {\n-                    check_unused_mut_pat(self, a.pats.as_slice());\n+                    builtin::check_unused_mut_pat(self, a.pats.as_slice());\n                 }\n             },\n             _ => ()\n         };\n \n-        check_while_true_expr(self, e);\n-        check_stability(self, e);\n-        check_unnecessary_parens_expr(self, e);\n-        check_unused_unsafe(self, e);\n-        check_unsafe_block(self, e);\n-        check_unnecessary_allocation(self, e);\n-        check_heap_expr(self, e);\n+        builtin::check_while_true_expr(self, e);\n+        builtin::check_stability(self, e);\n+        builtin::check_unnecessary_parens_expr(self, e);\n+        builtin::check_unused_unsafe(self, e);\n+        builtin::check_unsafe_block(self, e);\n+        builtin::check_unnecessary_allocation(self, e);\n+        builtin::check_heap_expr(self, e);\n \n-        check_type_limits(self, e);\n-        check_unused_casts(self, e);\n+        builtin::check_type_limits(self, e);\n+        builtin::check_unused_casts(self, e);\n \n         visit::walk_expr(self, e, ());\n     }\n \n     fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) {\n-        check_path_statement(self, s);\n-        check_unused_result(self, s);\n-        check_unnecessary_parens_stmt(self, s);\n+        builtin::check_path_statement(self, s);\n+        builtin::check_unused_result(self, s);\n+        builtin::check_unnecessary_parens_stmt(self, s);\n \n         match s.node {\n             ast::StmtDecl(d, _) => {\n                 match d.node {\n                     ast::DeclLocal(l) => {\n-                        check_unused_mut_pat(self, &[l.pat]);\n+                        builtin::check_unused_mut_pat(self, &[l.pat]);\n                     },\n                     _ => {}\n                 }\n@@ -1842,17 +823,19 @@ impl<'a> Visitor<()> for Context<'a> {\n         };\n \n         for a in decl.inputs.iter(){\n-            check_unused_mut_pat(self, &[a.pat]);\n+            builtin::check_unused_mut_pat(self, &[a.pat]);\n         }\n \n         match *fk {\n             visit::FkMethod(ident, _, m) => {\n                 self.with_lint_attrs(m.attrs.as_slice(), |cx| {\n-                    check_missing_doc_method(cx, m);\n+                    builtin::check_missing_doc_method(cx, m);\n \n                     match method_context(cx, m) {\n-                        PlainImpl => check_snake_case(cx, \"method\", ident, span),\n-                        TraitDefaultImpl => check_snake_case(cx, \"trait method\", ident, span),\n+                        PlainImpl\n+                            => builtin::check_snake_case(cx, \"method\", ident, span),\n+                        TraitDefaultImpl\n+                            => builtin::check_snake_case(cx, \"trait method\", ident, span),\n                         _ => (),\n                     }\n \n@@ -1863,7 +846,7 @@ impl<'a> Visitor<()> for Context<'a> {\n                 })\n             },\n             visit::FkItemFn(ident, _, _, _) => {\n-                check_snake_case(self, \"function\", ident, span);\n+                builtin::check_snake_case(self, \"function\", ident, span);\n                 recurse(self);\n             }\n             _ => recurse(self),\n@@ -1872,8 +855,8 @@ impl<'a> Visitor<()> for Context<'a> {\n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n         self.with_lint_attrs(t.attrs.as_slice(), |cx| {\n-            check_missing_doc_ty_method(cx, t);\n-            check_snake_case(cx, \"trait method\", t.ident, t.span);\n+            builtin::check_missing_doc_ty_method(cx, t);\n+            builtin::check_snake_case(cx, \"trait method\", t.ident, t.span);\n \n             visit::walk_ty_method(cx, t, ());\n         })\n@@ -1885,7 +868,7 @@ impl<'a> Visitor<()> for Context<'a> {\n                         _: &ast::Generics,\n                         id: ast::NodeId,\n                         _: ()) {\n-        check_struct_uppercase_variable(self, s);\n+        builtin::check_struct_uppercase_variable(self, s);\n \n         let old_id = self.cur_struct_def_id;\n         self.cur_struct_def_id = id;\n@@ -1895,15 +878,15 @@ impl<'a> Visitor<()> for Context<'a> {\n \n     fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n         self.with_lint_attrs(s.node.attrs.as_slice(), |cx| {\n-            check_missing_doc_struct_field(cx, s);\n+            builtin::check_missing_doc_struct_field(cx, s);\n \n             visit::walk_struct_field(cx, s, ());\n         })\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n         self.with_lint_attrs(v.node.attrs.as_slice(), |cx| {\n-            check_missing_doc_variant(cx, v);\n+            builtin::check_missing_doc_variant(cx, v);\n \n             visit::walk_variant(cx, v, g, ());\n         })\n@@ -1913,7 +896,7 @@ impl<'a> Visitor<()> for Context<'a> {\n     fn visit_ty(&mut self, _t: &ast::Ty, _: ()) {}\n \n     fn visit_attribute(&mut self, attr: &ast::Attribute, _: ()) {\n-        check_unused_attribute(self, attr);\n+        builtin::check_unused_attribute(self, attr);\n     }\n }\n \n@@ -1965,11 +948,11 @@ pub fn check_crate(tcx: &ty::ctxt,\n \n         // since the root module isn't visited as an item (because it isn't an item), warn for it\n         // here.\n-        check_missing_doc_attrs(cx,\n-                                None,\n-                                krate.attrs.as_slice(),\n-                                krate.span,\n-                                \"crate\");\n+        builtin::check_missing_doc_attrs(cx,\n+                                         None,\n+                                         krate.attrs.as_slice(),\n+                                         krate.span,\n+                                         \"crate\");\n \n         visit::walk_crate(cx, krate, ());\n     });"}]}