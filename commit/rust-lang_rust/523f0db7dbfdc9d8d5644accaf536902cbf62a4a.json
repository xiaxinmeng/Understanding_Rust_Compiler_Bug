{"sha": "523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "node_id": "C_kwDOAAsO6NoAKDUyM2YwZGI3ZGJmZGM5ZDhkNTY0NGFjY2FmNTM2OTAyY2JmNjJhNGE", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-13T14:53:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-13T14:53:28Z"}, "message": "Merge pull request #1264 from bjorn3/parallel_comp_refactor\n\nRefactorings for enabling parallel compilation (part 1)", "tree": {"sha": "120ad53eb417f6bff69d5150df850b8fd20be35b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/120ad53eb417f6bff69d5150df850b8fd20be35b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi97roCRBK7hj4Ov3rIwAAe+MIAJqyDTOsOJpvWJWx2GvTlPcS\nWR1VnZ2WqlUcP+xx4JMKqSEC12DbFy0CmVukWTeN+iV9B2vLnpUJQQFdpumBa1Q5\njpQGg949ogK9/JXKVf48Tz19s+kVUti8Ess+8Rm20BmWKZSkCsmke/ywqiJsK5gW\nV5zSyI+S+5HzwZf8NuUFDFLSGZoGAALaobTNe3jKeTLCdg3198oMrgiN6UGqzklA\niwcVJu0PZ6yTm2nZGh0G8TYkj+h5lgg35hSjAF+zUPPVv0GtHktLByJtbeE43ndA\n8UgiUPPdcxwv/vGycmovWug/Pu4LjXNs1XhLaFcnqZVHHmACp5K6H9WsU5QQMqg=\n=qFX4\n-----END PGP SIGNATURE-----\n", "payload": "tree 120ad53eb417f6bff69d5150df850b8fd20be35b\nparent 484041cefeab79874b5dd134a7e9b4b189e3c5a2\nparent 9461fd2cb061c7016207c22dc77f7ad906066279\nauthor bjorn3 <17426603+bjorn3@users.noreply.github.com> 1660402408 +0200\ncommitter GitHub <noreply@github.com> 1660402408 +0200\n\nMerge pull request #1264 from bjorn3/parallel_comp_refactor\n\nRefactorings for enabling parallel compilation (part 1)"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "html_url": "https://github.com/rust-lang/rust/commit/523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "484041cefeab79874b5dd134a7e9b4b189e3c5a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/484041cefeab79874b5dd134a7e9b4b189e3c5a2", "html_url": "https://github.com/rust-lang/rust/commit/484041cefeab79874b5dd134a7e9b4b189e3c5a2"}, {"sha": "9461fd2cb061c7016207c22dc77f7ad906066279", "url": "https://api.github.com/repos/rust-lang/rust/commits/9461fd2cb061c7016207c22dc77f7ad906066279", "html_url": "https://github.com/rust-lang/rust/commit/9461fd2cb061c7016207c22dc77f7ad906066279"}], "stats": {"total": 779, "additions": 482, "deletions": 297}, "files": [{"sha": "1e84c7fa3657b37afeb26614a49896fab8846b40", "filename": "Readme.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "patch": "@@ -52,9 +52,7 @@ configuration options.\n ## Not yet supported\n \n * Inline assembly ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1041))\n-    * On Linux there is support for invoking an external assembler for `global_asm!` and `asm!`.\n-      `llvm_asm!` will remain unimplemented forever. `asm!` doesn't yet support reg classes. You\n-      have to specify specific registers instead.\n+    * On UNIX there is support for invoking an external assembler for `global_asm!` and `asm!`.\n * SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), some basic things work)\n \n ## License"}, {"sha": "e83be3a3df5c4f410f470099f1d623df22a2c76b", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "patch": "@@ -321,7 +321,7 @@ fn main() {\n     #[cfg(not(any(jit, windows)))]\n     test_tls();\n \n-    #[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"linux\"))]\n+    #[cfg(all(not(jit), target_arch = \"x86_64\", any(target_os = \"linux\", target_os = \"darwin\")))]\n     unsafe {\n         global_asm_test();\n     }\n@@ -343,7 +343,7 @@ fn main() {\n }\n }\n \n-#[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"linux\"))]\n+#[cfg(all(not(jit), target_arch = \"x86_64\", any(target_os = \"linux\", target_os = \"darwin\")))]\n extern \"C\" {\n     fn global_asm_test();\n }\n@@ -358,6 +358,16 @@ global_asm! {\n     \"\n }\n \n+#[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"darwin\"))]\n+global_asm! {\n+    \"\n+    .global _global_asm_test\n+    _global_asm_test:\n+    // comment that would normally be removed by LLVM\n+    ret\n+    \"\n+}\n+\n #[repr(C)]\n enum c_void {\n     _1,"}, {"sha": "c68d33465bc2ac1f1ce55c9300ff60a2fa69566c", "filename": "src/base.rs", "status": "modified", "additions": 71, "deletions": 51, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "patch": "@@ -5,24 +5,50 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::SymbolName;\n \n use indexmap::IndexSet;\n \n use crate::constant::ConstantCx;\n use crate::prelude::*;\n use crate::pretty_clif::CommentWriter;\n \n-pub(crate) fn codegen_fn<'tcx>(\n+struct CodegenedFunction<'tcx> {\n+    instance: Instance<'tcx>,\n+    symbol_name: SymbolName<'tcx>,\n+    func_id: FuncId,\n+    func: Function,\n+    clif_comments: CommentWriter,\n+    source_info_set: IndexSet<SourceInfo>,\n+    local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n+}\n+\n+pub(crate) fn codegen_and_compile_fn<'tcx>(\n     cx: &mut crate::CodegenCx<'tcx>,\n+    cached_context: &mut Context,\n     module: &mut dyn Module,\n     instance: Instance<'tcx>,\n ) {\n     let tcx = cx.tcx;\n-\n     let _inst_guard =\n         crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, tcx.symbol_name(instance).name));\n+\n+    let cached_func = std::mem::replace(&mut cached_context.func, Function::new());\n+    let codegened_func = codegen_fn(cx, cached_func, module, instance);\n+\n+    compile_fn(cx, cached_context, module, codegened_func);\n+}\n+\n+fn codegen_fn<'tcx>(\n+    cx: &mut crate::CodegenCx<'tcx>,\n+    cached_func: Function,\n+    module: &mut dyn Module,\n+    instance: Instance<'tcx>,\n+) -> CodegenedFunction<'tcx> {\n     debug_assert!(!instance.substs.needs_infer());\n \n+    let tcx = cx.tcx;\n+\n     let mir = tcx.instance_mir(instance.def);\n     let _mir_guard = crate::PrintOnPanic(|| {\n         let mut buf = Vec::new();\n@@ -38,11 +64,10 @@ pub(crate) fn codegen_fn<'tcx>(\n     let sig = get_function_sig(tcx, module.isa().triple(), instance);\n     let func_id = module.declare_function(symbol_name.name, Linkage::Local, &sig).unwrap();\n \n-    cx.cached_context.clear();\n-\n     // Make the FunctionBuilder\n     let mut func_ctx = FunctionBuilderContext::new();\n-    let mut func = std::mem::replace(&mut cx.cached_context.func, Function::new());\n+    let mut func = cached_func;\n+    func.clear();\n     func.name = ExternalName::user(0, func_id.as_u32());\n     func.signature = sig;\n     func.collect_debug_info();\n@@ -82,27 +107,7 @@ pub(crate) fn codegen_fn<'tcx>(\n         next_ssa_var: 0,\n     };\n \n-    let arg_uninhabited = fx\n-        .mir\n-        .args_iter()\n-        .any(|arg| fx.layout_of(fx.monomorphize(fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n-\n-    if !crate::constant::check_constants(&mut fx) {\n-        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n-        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n-        // compilation should have been aborted\n-        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-    } else if arg_uninhabited {\n-        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n-        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n-        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-    } else {\n-        tcx.sess.time(\"codegen clif ir\", || {\n-            tcx.sess\n-                .time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(&mut fx, start_block));\n-            codegen_fn_content(&mut fx);\n-        });\n-    }\n+    tcx.sess.time(\"codegen clif ir\", || codegen_fn_body(&mut fx, start_block));\n \n     // Recover all necessary data from fx, before accessing func will prevent future access to it.\n     let instance = fx.instance;\n@@ -124,36 +129,31 @@ pub(crate) fn codegen_fn<'tcx>(\n     // Verify function\n     verify_func(tcx, &clif_comments, &func);\n \n-    compile_fn(\n-        cx,\n-        module,\n+    CodegenedFunction {\n         instance,\n-        symbol_name.name,\n+        symbol_name,\n         func_id,\n         func,\n         clif_comments,\n         source_info_set,\n         local_map,\n-    );\n+    }\n }\n \n fn compile_fn<'tcx>(\n     cx: &mut crate::CodegenCx<'tcx>,\n+    cached_context: &mut Context,\n     module: &mut dyn Module,\n-    instance: Instance<'tcx>,\n-    symbol_name: &str,\n-    func_id: FuncId,\n-    func: Function,\n-    mut clif_comments: CommentWriter,\n-    source_info_set: IndexSet<SourceInfo>,\n-    local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n+    codegened_func: CodegenedFunction<'tcx>,\n ) {\n     let tcx = cx.tcx;\n \n+    let mut clif_comments = codegened_func.clif_comments;\n+\n     // Store function in context\n-    let context = &mut cx.cached_context;\n+    let context = cached_context;\n     context.clear();\n-    context.func = func;\n+    context.func = codegened_func.func;\n \n     // If the return block is not reachable, then the SSA builder may have inserted an `iconst.i128`\n     // instruction, which doesn't have an encoding.\n@@ -170,7 +170,7 @@ fn compile_fn<'tcx>(\n         crate::optimize::optimize_function(\n             tcx,\n             module.isa(),\n-            instance,\n+            codegened_func.instance,\n             context,\n             &mut clif_comments,\n         );\n@@ -206,23 +206,23 @@ fn compile_fn<'tcx>(\n     // Define function\n     tcx.sess.time(\"define function\", || {\n         context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n-        module.define_function(func_id, context).unwrap();\n+        module.define_function(codegened_func.func_id, context).unwrap();\n     });\n \n     // Write optimized function to file for debugging\n     crate::pretty_clif::write_clif_file(\n         tcx,\n         \"opt\",\n         module.isa(),\n-        instance,\n+        codegened_func.instance,\n         &context.func,\n         &clif_comments,\n     );\n \n     if let Some(disasm) = &context.mach_compile_result.as_ref().unwrap().disasm {\n         crate::pretty_clif::write_ir_file(\n             tcx,\n-            || format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n+            || format!(\"{}.vcode\", tcx.symbol_name(codegened_func.instance).name),\n             |file| file.write_all(disasm.as_bytes()),\n         )\n     }\n@@ -234,16 +234,16 @@ fn compile_fn<'tcx>(\n     tcx.sess.time(\"generate debug info\", || {\n         if let Some(debug_context) = debug_context {\n             debug_context.define_function(\n-                instance,\n-                func_id,\n-                symbol_name,\n+                codegened_func.instance,\n+                codegened_func.func_id,\n+                codegened_func.symbol_name.name,\n                 isa,\n                 context,\n-                &source_info_set,\n-                local_map,\n+                &codegened_func.source_info_set,\n+                codegened_func.local_map,\n             );\n         }\n-        unwind_context.add_function(func_id, &context, isa);\n+        unwind_context.add_function(codegened_func.func_id, &context, isa);\n     });\n }\n \n@@ -269,7 +269,27 @@ pub(crate) fn verify_func(\n     });\n }\n \n-fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n+fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n+    if !crate::constant::check_constants(fx) {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        // compilation should have been aborted\n+        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        return;\n+    }\n+\n+    let arg_uninhabited = fx\n+        .mir\n+        .args_iter()\n+        .any(|arg| fx.layout_of(fx.monomorphize(fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n+    if arg_uninhabited {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        return;\n+    }\n+    fx.tcx.sess.time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(fx, start_block));\n+\n     for (bb, bb_data) in fx.mir.basic_blocks().iter_enumerated() {\n         let block = fx.get_block(bb);\n         fx.bcx.switch_to_block(block);"}, {"sha": "9d819e3995bbce8d1d747a6948e3ea3e1e6576fa", "filename": "src/driver/aot.rs", "status": "modified", "additions": 237, "deletions": 212, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "patch": "@@ -1,33 +1,111 @@\n //! The AOT driver uses [`cranelift_object`] to write object files suitable for linking into a\n //! standalone executable.\n \n+use std::fs::File;\n use std::path::PathBuf;\n+use std::sync::Arc;\n \n-use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_codegen_ssa::back::metadata::create_compressed_metadata_file;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n+use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n-use rustc_session::config::{DebugInfo, OutputType};\n+use rustc_session::config::{DebugInfo, OutputFilenames, OutputType};\n use rustc_session::Session;\n \n-use cranelift_codegen::isa::TargetIsa;\n use cranelift_object::{ObjectBuilder, ObjectModule};\n \n+use crate::global_asm::GlobalAsmConfig;\n use crate::{prelude::*, BackendConfig};\n \n-struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n+struct ModuleCodegenResult {\n+    module_regular: CompiledModule,\n+    module_global_asm: Option<CompiledModule>,\n+    existing_work_product: Option<(WorkProductId, WorkProduct)>,\n+}\n \n impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n     fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n         // do nothing\n     }\n }\n \n-fn make_module(sess: &Session, isa: Box<dyn TargetIsa>, name: String) -> ObjectModule {\n+pub(crate) struct OngoingCodegen {\n+    modules: Vec<Result<ModuleCodegenResult, String>>,\n+    allocator_module: Option<CompiledModule>,\n+    metadata_module: Option<CompiledModule>,\n+    metadata: EncodedMetadata,\n+    crate_info: CrateInfo,\n+}\n+\n+impl OngoingCodegen {\n+    pub(crate) fn join(\n+        self,\n+        sess: &Session,\n+        backend_config: &BackendConfig,\n+    ) -> (CodegenResults, FxHashMap<WorkProductId, WorkProduct>) {\n+        let mut work_products = FxHashMap::default();\n+        let mut modules = vec![];\n+\n+        for module_codegen_result in self.modules {\n+            let module_codegen_result = match module_codegen_result {\n+                Ok(module_codegen_result) => module_codegen_result,\n+                Err(err) => sess.fatal(&err),\n+            };\n+            let ModuleCodegenResult { module_regular, module_global_asm, existing_work_product } =\n+                module_codegen_result;\n+\n+            if let Some((work_product_id, work_product)) = existing_work_product {\n+                work_products.insert(work_product_id, work_product);\n+            } else {\n+                let work_product = if backend_config.disable_incr_cache {\n+                    None\n+                } else if let Some(module_global_asm) = &module_global_asm {\n+                    rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n+                        sess,\n+                        &module_regular.name,\n+                        &[\n+                            (\"o\", &module_regular.object.as_ref().unwrap()),\n+                            (\"asm.o\", &module_global_asm.object.as_ref().unwrap()),\n+                        ],\n+                    )\n+                } else {\n+                    rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n+                        sess,\n+                        &module_regular.name,\n+                        &[(\"o\", &module_regular.object.as_ref().unwrap())],\n+                    )\n+                };\n+                if let Some((work_product_id, work_product)) = work_product {\n+                    work_products.insert(work_product_id, work_product);\n+                }\n+            }\n+\n+            modules.push(module_regular);\n+            if let Some(module_global_asm) = module_global_asm {\n+                modules.push(module_global_asm);\n+            }\n+        }\n+\n+        (\n+            CodegenResults {\n+                modules,\n+                allocator_module: self.allocator_module,\n+                metadata_module: self.metadata_module,\n+                metadata: self.metadata,\n+                crate_info: self.crate_info,\n+            },\n+            work_products,\n+        )\n+    }\n+}\n+\n+fn make_module(sess: &Session, backend_config: &BackendConfig, name: String) -> ObjectModule {\n+    let isa = crate::build_isa(sess, backend_config);\n+\n     let mut builder =\n         ObjectBuilder::new(isa, name + \".o\", cranelift_module::default_libcall_names()).unwrap();\n     // Unlike cg_llvm, cg_clif defaults to disabling -Zfunction-sections. For cg_llvm binary size\n@@ -37,15 +115,15 @@ fn make_module(sess: &Session, isa: Box<dyn TargetIsa>, name: String) -> ObjectM\n     ObjectModule::new(builder)\n }\n \n-fn emit_module(\n-    tcx: TyCtxt<'_>,\n-    backend_config: &BackendConfig,\n+fn emit_cgu(\n+    output_filenames: &OutputFilenames,\n+    prof: &SelfProfilerRef,\n     name: String,\n-    kind: ModuleKind,\n     module: ObjectModule,\n     debug: Option<DebugContext<'_>>,\n     unwind_context: UnwindContext,\n-) -> ModuleCodegenResult {\n+    global_asm_object_file: Option<PathBuf>,\n+) -> Result<ModuleCodegenResult, String> {\n     let mut product = module.finish();\n \n     if let Some(mut debug) = debug {\n@@ -54,71 +132,117 @@ fn emit_module(\n \n     unwind_context.emit(&mut product);\n \n-    let tmp_file = tcx.output_filenames(()).temp_path(OutputType::Object, Some(&name));\n-    let obj = product.object.write().unwrap();\n+    let module_regular =\n+        emit_module(output_filenames, prof, product.object, ModuleKind::Regular, name.clone())?;\n+\n+    Ok(ModuleCodegenResult {\n+        module_regular,\n+        module_global_asm: global_asm_object_file.map(|global_asm_object_file| CompiledModule {\n+            name: format!(\"{name}.asm\"),\n+            kind: ModuleKind::Regular,\n+            object: Some(global_asm_object_file),\n+            dwarf_object: None,\n+            bytecode: None,\n+        }),\n+        existing_work_product: None,\n+    })\n+}\n \n-    tcx.sess.prof.artifact_size(\"object_file\", name.clone(), obj.len().try_into().unwrap());\n+fn emit_module(\n+    output_filenames: &OutputFilenames,\n+    prof: &SelfProfilerRef,\n+    object: cranelift_object::object::write::Object<'_>,\n+    kind: ModuleKind,\n+    name: String,\n+) -> Result<CompiledModule, String> {\n+    let tmp_file = output_filenames.temp_path(OutputType::Object, Some(&name));\n+    let mut file = match File::create(&tmp_file) {\n+        Ok(file) => file,\n+        Err(err) => return Err(format!(\"error creating object file: {}\", err)),\n+    };\n \n-    if let Err(err) = std::fs::write(&tmp_file, obj) {\n-        tcx.sess.fatal(&format!(\"error writing object file: {}\", err));\n+    if let Err(err) = object.write_stream(&mut file) {\n+        return Err(format!(\"error writing object file: {}\", err));\n     }\n \n-    let work_product = if backend_config.disable_incr_cache {\n-        None\n-    } else {\n-        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n-            tcx.sess,\n-            &name,\n-            &[(\"o\", &tmp_file)],\n-        )\n-    };\n+    prof.artifact_size(\"object_file\", &*name, file.metadata().unwrap().len());\n \n-    ModuleCodegenResult(\n-        CompiledModule { name, kind, object: Some(tmp_file), dwarf_object: None, bytecode: None },\n-        work_product,\n-    )\n+    Ok(CompiledModule { name, kind, object: Some(tmp_file), dwarf_object: None, bytecode: None })\n }\n \n fn reuse_workproduct_for_cgu(\n     tcx: TyCtxt<'_>,\n     cgu: &CodegenUnit<'_>,\n-    work_products: &mut FxHashMap<WorkProductId, WorkProduct>,\n-) -> CompiledModule {\n+) -> Result<ModuleCodegenResult, String> {\n     let work_product = cgu.previous_work_product(tcx);\n-    let obj_out = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n-    let source_file = rustc_incremental::in_incr_comp_dir_sess(\n+    let obj_out_regular =\n+        tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n+    let source_file_regular = rustc_incremental::in_incr_comp_dir_sess(\n         &tcx.sess,\n         &work_product.saved_files.get(\"o\").expect(\"no saved object file in work product\"),\n     );\n-    if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n-        tcx.sess.err(&format!(\n+\n+    if let Err(err) = rustc_fs_util::link_or_copy(&source_file_regular, &obj_out_regular) {\n+        return Err(format!(\n             \"unable to copy {} to {}: {}\",\n-            source_file.display(),\n-            obj_out.display(),\n+            source_file_regular.display(),\n+            obj_out_regular.display(),\n             err\n         ));\n     }\n+    let obj_out_global_asm =\n+        crate::global_asm::add_file_stem_postfix(obj_out_regular.clone(), \".asm\");\n+    let has_global_asm = if let Some(asm_o) = work_product.saved_files.get(\"asm.o\") {\n+        let source_file_global_asm = rustc_incremental::in_incr_comp_dir_sess(&tcx.sess, asm_o);\n+        if let Err(err) = rustc_fs_util::link_or_copy(&source_file_global_asm, &obj_out_global_asm)\n+        {\n+            return Err(format!(\n+                \"unable to copy {} to {}: {}\",\n+                source_file_regular.display(),\n+                obj_out_regular.display(),\n+                err\n+            ));\n+        }\n+        true\n+    } else {\n+        false\n+    };\n \n-    work_products.insert(cgu.work_product_id(), work_product);\n-\n-    CompiledModule {\n-        name: cgu.name().to_string(),\n-        kind: ModuleKind::Regular,\n-        object: Some(obj_out),\n-        dwarf_object: None,\n-        bytecode: None,\n-    }\n+    Ok(ModuleCodegenResult {\n+        module_regular: CompiledModule {\n+            name: cgu.name().to_string(),\n+            kind: ModuleKind::Regular,\n+            object: Some(obj_out_regular),\n+            dwarf_object: None,\n+            bytecode: None,\n+        },\n+        module_global_asm: if has_global_asm {\n+            Some(CompiledModule {\n+                name: cgu.name().to_string(),\n+                kind: ModuleKind::Regular,\n+                object: Some(obj_out_global_asm),\n+                dwarf_object: None,\n+                bytecode: None,\n+            })\n+        } else {\n+            None\n+        },\n+        existing_work_product: Some((cgu.work_product_id(), work_product)),\n+    })\n }\n \n fn module_codegen(\n     tcx: TyCtxt<'_>,\n-    (backend_config, cgu_name): (BackendConfig, rustc_span::Symbol),\n-) -> ModuleCodegenResult {\n+    (backend_config, global_asm_config, cgu_name): (\n+        BackendConfig,\n+        Arc<GlobalAsmConfig>,\n+        rustc_span::Symbol,\n+    ),\n+) -> Result<ModuleCodegenResult, String> {\n     let cgu = tcx.codegen_unit(cgu_name);\n     let mono_items = cgu.items_in_deterministic_order(tcx);\n \n-    let isa = crate::build_isa(tcx.sess, &backend_config);\n-    let mut module = make_module(tcx.sess, isa, cgu_name.as_str().to_string());\n+    let mut module = make_module(tcx.sess, &backend_config, cgu_name.as_str().to_string());\n \n     let mut cx = crate::CodegenCx::new(\n         tcx,\n@@ -128,32 +252,22 @@ fn module_codegen(\n         cgu_name,\n     );\n     super::predefine_mono_items(tcx, &mut module, &mono_items);\n+    let mut cached_context = Context::new();\n     for (mono_item, _) in mono_items {\n         match mono_item {\n             MonoItem::Fn(inst) => {\n-                cx.tcx\n-                    .sess\n-                    .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, &mut module, inst));\n+                cx.tcx.sess.time(\"codegen fn\", || {\n+                    crate::base::codegen_and_compile_fn(\n+                        &mut cx,\n+                        &mut cached_context,\n+                        &mut module,\n+                        inst,\n+                    )\n+                });\n             }\n             MonoItem::Static(def_id) => crate::constant::codegen_static(tcx, &mut module, def_id),\n             MonoItem::GlobalAsm(item_id) => {\n-                let item = cx.tcx.hir().item(item_id);\n-                if let rustc_hir::ItemKind::GlobalAsm(asm) = item.kind {\n-                    if !asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n-                        cx.global_asm.push_str(\"\\n.intel_syntax noprefix\\n\");\n-                    } else {\n-                        cx.global_asm.push_str(\"\\n.att_syntax\\n\");\n-                    }\n-                    for piece in asm.template {\n-                        match *piece {\n-                            InlineAsmTemplatePiece::String(ref s) => cx.global_asm.push_str(s),\n-                            InlineAsmTemplatePiece::Placeholder { .. } => todo!(),\n-                        }\n-                    }\n-                    cx.global_asm.push_str(\"\\n.att_syntax\\n\\n\");\n-                } else {\n-                    bug!(\"Expected GlobalAsm found {:?}\", item);\n-                }\n+                crate::global_asm::codegen_global_asm_item(tcx, &mut cx.global_asm, item_id);\n             }\n         }\n     }\n@@ -165,33 +279,36 @@ fn module_codegen(\n         cgu.is_primary(),\n     );\n \n+    let global_asm_object_file = match crate::global_asm::compile_global_asm(\n+        &global_asm_config,\n+        cgu.name().as_str(),\n+        &cx.global_asm,\n+    ) {\n+        Ok(global_asm_object_file) => global_asm_object_file,\n+        Err(err) => tcx.sess.fatal(&err),\n+    };\n+\n     let debug_context = cx.debug_context;\n     let unwind_context = cx.unwind_context;\n-    let codegen_result = tcx.sess.time(\"write object file\", || {\n-        emit_module(\n-            tcx,\n-            &backend_config,\n+    tcx.sess.time(\"write object file\", || {\n+        emit_cgu(\n+            &global_asm_config.output_filenames,\n+            &tcx.sess.prof,\n             cgu.name().as_str().to_string(),\n-            ModuleKind::Regular,\n             module,\n             debug_context,\n             unwind_context,\n+            global_asm_object_file,\n         )\n-    });\n-\n-    codegen_global_asm(tcx, cgu.name().as_str(), &cx.global_asm);\n-\n-    codegen_result\n+    })\n }\n \n pub(crate) fn run_aot(\n     tcx: TyCtxt<'_>,\n     backend_config: BackendConfig,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n-) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n-    let mut work_products = FxHashMap::default();\n-\n+) -> Box<OngoingCodegen> {\n     let cgus = if tcx.sess.opts.output_types.should_codegen() {\n         tcx.collect_and_partition_mono_items(()).1\n     } else {\n@@ -206,62 +323,59 @@ pub(crate) fn run_aot(\n         }\n     }\n \n+    let global_asm_config = Arc::new(crate::global_asm::GlobalAsmConfig::new(tcx));\n+\n     let modules = super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n         cgus.iter()\n             .map(|cgu| {\n-                let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n+                let cgu_reuse = if backend_config.disable_incr_cache {\n+                    CguReuse::No\n+                } else {\n+                    determine_cgu_reuse(tcx, cgu)\n+                };\n                 tcx.sess.cgu_reuse_tracker.set_actual_reuse(cgu.name().as_str(), cgu_reuse);\n \n                 match cgu_reuse {\n-                    _ if backend_config.disable_incr_cache => {}\n-                    CguReuse::No => {}\n-                    CguReuse::PreLto => {\n-                        return reuse_workproduct_for_cgu(tcx, &*cgu, &mut work_products);\n+                    CguReuse::No => {\n+                        let dep_node = cgu.codegen_dep_node(tcx);\n+                        tcx.dep_graph\n+                            .with_task(\n+                                dep_node,\n+                                tcx,\n+                                (backend_config.clone(), global_asm_config.clone(), cgu.name()),\n+                                module_codegen,\n+                                Some(rustc_middle::dep_graph::hash_result),\n+                            )\n+                            .0\n                     }\n+                    CguReuse::PreLto => reuse_workproduct_for_cgu(tcx, &*cgu),\n                     CguReuse::PostLto => unreachable!(),\n                 }\n-\n-                let dep_node = cgu.codegen_dep_node(tcx);\n-                let (ModuleCodegenResult(module, work_product), _) = tcx.dep_graph.with_task(\n-                    dep_node,\n-                    tcx,\n-                    (backend_config.clone(), cgu.name()),\n-                    module_codegen,\n-                    Some(rustc_middle::dep_graph::hash_result),\n-                );\n-\n-                if let Some((id, product)) = work_product {\n-                    work_products.insert(id, product);\n-                }\n-\n-                module\n             })\n             .collect::<Vec<_>>()\n     });\n \n     tcx.sess.abort_if_errors();\n \n-    let isa = crate::build_isa(tcx.sess, &backend_config);\n-    let mut allocator_module = make_module(tcx.sess, isa, \"allocator_shim\".to_string());\n-    assert_eq!(pointer_ty(tcx), allocator_module.target_config().pointer_type());\n+    let mut allocator_module = make_module(tcx.sess, &backend_config, \"allocator_shim\".to_string());\n     let mut allocator_unwind_context = UnwindContext::new(allocator_module.isa(), true);\n     let created_alloc_shim =\n         crate::allocator::codegen(tcx, &mut allocator_module, &mut allocator_unwind_context);\n \n     let allocator_module = if created_alloc_shim {\n-        let ModuleCodegenResult(module, work_product) = emit_module(\n-            tcx,\n-            &backend_config,\n-            \"allocator_shim\".to_string(),\n+        let mut product = allocator_module.finish();\n+        allocator_unwind_context.emit(&mut product);\n+\n+        match emit_module(\n+            tcx.output_filenames(()),\n+            &tcx.sess.prof,\n+            product.object,\n             ModuleKind::Allocator,\n-            allocator_module,\n-            None,\n-            allocator_unwind_context,\n-        );\n-        if let Some((id, product)) = work_product {\n-            work_products.insert(id, product);\n+            \"allocator_shim\".to_owned(),\n+        ) {\n+            Ok(allocator_module) => Some(allocator_module),\n+            Err(err) => tcx.sess.fatal(err),\n         }\n-        Some(module)\n     } else {\n         None\n     };\n@@ -308,102 +422,13 @@ pub(crate) fn run_aot(\n     }\n     .to_owned();\n \n-    Box::new((\n-        CodegenResults {\n-            modules,\n-            allocator_module,\n-            metadata_module,\n-            metadata,\n-            crate_info: CrateInfo::new(tcx, target_cpu),\n-        },\n-        work_products,\n-    ))\n-}\n-\n-fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n-    use std::io::Write;\n-    use std::process::{Command, Stdio};\n-\n-    if global_asm.is_empty() {\n-        return;\n-    }\n-\n-    if cfg!(not(feature = \"inline_asm\"))\n-        || tcx.sess.target.is_like_osx\n-        || tcx.sess.target.is_like_windows\n-    {\n-        if global_asm.contains(\"__rust_probestack\") {\n-            return;\n-        }\n-\n-        // FIXME fix linker error on macOS\n-        if cfg!(not(feature = \"inline_asm\")) {\n-            tcx.sess.fatal(\n-                \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\",\n-            );\n-        } else {\n-            tcx.sess.fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n-        }\n-    }\n-\n-    let assembler = crate::toolchain::get_toolchain_binary(tcx.sess, \"as\");\n-    let linker = crate::toolchain::get_toolchain_binary(tcx.sess, \"ld\");\n-\n-    // Remove all LLVM style comments\n-    let global_asm = global_asm\n-        .lines()\n-        .map(|line| if let Some(index) = line.find(\"//\") { &line[0..index] } else { line })\n-        .collect::<Vec<_>>()\n-        .join(\"\\n\");\n-\n-    let output_object_file = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu_name));\n-\n-    // Assemble `global_asm`\n-    let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n-    let mut child = Command::new(assembler)\n-        .arg(\"-o\")\n-        .arg(&global_asm_object_file)\n-        .stdin(Stdio::piped())\n-        .spawn()\n-        .expect(\"Failed to spawn `as`.\");\n-    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n-    let status = child.wait().expect(\"Failed to wait for `as`.\");\n-    if !status.success() {\n-        tcx.sess.fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n-    }\n-\n-    // Link the global asm and main object file together\n-    let main_object_file = add_file_stem_postfix(output_object_file.clone(), \".main\");\n-    std::fs::rename(&output_object_file, &main_object_file).unwrap();\n-    let status = Command::new(linker)\n-        .arg(\"-r\") // Create a new object file\n-        .arg(\"-o\")\n-        .arg(output_object_file)\n-        .arg(&main_object_file)\n-        .arg(&global_asm_object_file)\n-        .status()\n-        .unwrap();\n-    if !status.success() {\n-        tcx.sess.fatal(&format!(\n-            \"Failed to link `{}` and `{}` together\",\n-            main_object_file.display(),\n-            global_asm_object_file.display(),\n-        ));\n-    }\n-\n-    std::fs::remove_file(global_asm_object_file).unwrap();\n-    std::fs::remove_file(main_object_file).unwrap();\n-}\n-\n-fn add_file_stem_postfix(mut path: PathBuf, postfix: &str) -> PathBuf {\n-    let mut new_filename = path.file_stem().unwrap().to_owned();\n-    new_filename.push(postfix);\n-    if let Some(extension) = path.extension() {\n-        new_filename.push(\".\");\n-        new_filename.push(extension);\n-    }\n-    path.set_file_name(new_filename);\n-    path\n+    Box::new(OngoingCodegen {\n+        modules,\n+        allocator_module,\n+        metadata_module,\n+        metadata,\n+        crate_info: CrateInfo::new(tcx, target_cpu),\n+    })\n }\n \n // Adapted from https://github.com/rust-lang/rust/blob/303d8aff6092709edd4dbd35b1c88e9aa40bf6d8/src/librustc_codegen_ssa/base.rs#L922-L953"}, {"sha": "1b046d7ec6e8b84abb885a62b00e972cf4d4dbec", "filename": "src/driver/jit.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "patch": "@@ -111,6 +111,7 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         &backend_config,\n         matches!(backend_config.codegen_mode, CodegenMode::JitLazy),\n     );\n+    let mut cached_context = Context::new();\n \n     let (_, cgus) = tcx.collect_and_partition_mono_items(());\n     let mono_items = cgus\n@@ -129,10 +130,17 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n                         cx.tcx.sess.time(\"codegen fn\", || {\n-                            crate::base::codegen_fn(&mut cx, &mut jit_module, inst)\n+                            crate::base::codegen_and_compile_fn(\n+                                &mut cx,\n+                                &mut cached_context,\n+                                &mut jit_module,\n+                                inst,\n+                            )\n                         });\n                     }\n-                    CodegenMode::JitLazy => codegen_shim(&mut cx, &mut jit_module, inst),\n+                    CodegenMode::JitLazy => {\n+                        codegen_shim(&mut cx, &mut cached_context, &mut jit_module, inst)\n+                    }\n                 },\n                 MonoItem::Static(def_id) => {\n                     crate::constant::codegen_static(tcx, &mut jit_module, def_id);\n@@ -259,7 +267,14 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n                 false,\n                 Symbol::intern(\"dummy_cgu_name\"),\n             );\n-            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, jit_module, instance));\n+            tcx.sess.time(\"codegen fn\", || {\n+                crate::base::codegen_and_compile_fn(\n+                    &mut cx,\n+                    &mut Context::new(),\n+                    jit_module,\n+                    instance,\n+                )\n+            });\n \n             assert!(cx.global_asm.is_empty());\n             jit_module.finalize_definitions();\n@@ -334,7 +349,12 @@ fn load_imported_symbols_for_jit(\n     imported_symbols\n }\n \n-fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: Instance<'tcx>) {\n+fn codegen_shim<'tcx>(\n+    cx: &mut CodegenCx<'tcx>,\n+    cached_context: &mut Context,\n+    module: &mut JITModule,\n+    inst: Instance<'tcx>,\n+) {\n     let tcx = cx.tcx;\n \n     let pointer_type = module.target_config().pointer_type();\n@@ -357,8 +377,9 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: In\n         )\n         .unwrap();\n \n-    cx.cached_context.clear();\n-    let trampoline = &mut cx.cached_context.func;\n+    let context = cached_context;\n+    context.clear();\n+    let trampoline = &mut context.func;\n     trampoline.signature = sig.clone();\n \n     let mut builder_ctx = FunctionBuilderContext::new();\n@@ -381,5 +402,5 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: In\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n \n-    module.define_function(func_id, &mut cx.cached_context).unwrap();\n+    module.define_function(func_id, context).unwrap();\n }"}, {"sha": "dcbcaba30feeda219cea9d7042dd73e40167fe82", "filename": "src/global_asm.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/src%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/src%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fglobal_asm.rs?ref=523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "patch": "@@ -0,0 +1,114 @@\n+//! The AOT driver uses [`cranelift_object`] to write object files suitable for linking into a\n+//! standalone executable.\n+\n+use std::io::Write;\n+use std::path::PathBuf;\n+use std::process::{Command, Stdio};\n+use std::sync::Arc;\n+\n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_hir::ItemId;\n+use rustc_session::config::{OutputFilenames, OutputType};\n+\n+use crate::prelude::*;\n+\n+pub(crate) fn codegen_global_asm_item(tcx: TyCtxt<'_>, global_asm: &mut String, item_id: ItemId) {\n+    let item = tcx.hir().item(item_id);\n+    if let rustc_hir::ItemKind::GlobalAsm(asm) = item.kind {\n+        if !asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+            global_asm.push_str(\"\\n.intel_syntax noprefix\\n\");\n+        } else {\n+            global_asm.push_str(\"\\n.att_syntax\\n\");\n+        }\n+        for piece in asm.template {\n+            match *piece {\n+                InlineAsmTemplatePiece::String(ref s) => global_asm.push_str(s),\n+                InlineAsmTemplatePiece::Placeholder { .. } => todo!(),\n+            }\n+        }\n+        global_asm.push_str(\"\\n.att_syntax\\n\\n\");\n+    } else {\n+        bug!(\"Expected GlobalAsm found {:?}\", item);\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct GlobalAsmConfig {\n+    asm_enabled: bool,\n+    assembler: PathBuf,\n+    pub(crate) output_filenames: Arc<OutputFilenames>,\n+}\n+\n+impl GlobalAsmConfig {\n+    pub(crate) fn new(tcx: TyCtxt<'_>) -> Self {\n+        let asm_enabled = cfg!(feature = \"inline_asm\") && !tcx.sess.target.is_like_windows;\n+\n+        GlobalAsmConfig {\n+            asm_enabled,\n+            assembler: crate::toolchain::get_toolchain_binary(tcx.sess, \"as\"),\n+            output_filenames: tcx.output_filenames(()).clone(),\n+        }\n+    }\n+}\n+\n+pub(crate) fn compile_global_asm(\n+    config: &GlobalAsmConfig,\n+    cgu_name: &str,\n+    global_asm: &str,\n+) -> Result<Option<PathBuf>, String> {\n+    if global_asm.is_empty() {\n+        return Ok(None);\n+    }\n+\n+    if !config.asm_enabled {\n+        if global_asm.contains(\"__rust_probestack\") {\n+            return Ok(None);\n+        }\n+\n+        // FIXME fix linker error on macOS\n+        if cfg!(not(feature = \"inline_asm\")) {\n+            return Err(\n+                \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\"\n+                    .to_owned(),\n+            );\n+        } else {\n+            return Err(\"asm! and global_asm! are not yet supported on Windows\".to_owned());\n+        }\n+    }\n+\n+    // Remove all LLVM style comments\n+    let global_asm = global_asm\n+        .lines()\n+        .map(|line| if let Some(index) = line.find(\"//\") { &line[0..index] } else { line })\n+        .collect::<Vec<_>>()\n+        .join(\"\\n\");\n+\n+    let output_object_file = config.output_filenames.temp_path(OutputType::Object, Some(cgu_name));\n+\n+    // Assemble `global_asm`\n+    let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n+    let mut child = Command::new(&config.assembler)\n+        .arg(\"-o\")\n+        .arg(&global_asm_object_file)\n+        .stdin(Stdio::piped())\n+        .spawn()\n+        .expect(\"Failed to spawn `as`.\");\n+    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n+    let status = child.wait().expect(\"Failed to wait for `as`.\");\n+    if !status.success() {\n+        return Err(format!(\"Failed to assemble `{}`\", global_asm));\n+    }\n+\n+    Ok(Some(global_asm_object_file))\n+}\n+\n+pub(crate) fn add_file_stem_postfix(mut path: PathBuf, postfix: &str) -> PathBuf {\n+    let mut new_filename = path.file_stem().unwrap().to_owned();\n+    new_filename.push(postfix);\n+    if let Some(extension) = path.extension() {\n+        new_filename.push(\".\");\n+        new_filename.push(extension);\n+    }\n+    path.set_file_name(new_filename);\n+    path\n+}"}, {"sha": "909f4f00f1edfcfd4b5e778f423f456ab62accf7", "filename": "src/lib.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "patch": "@@ -25,7 +25,7 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n \n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n@@ -56,6 +56,7 @@ mod constant;\n mod debuginfo;\n mod discriminant;\n mod driver;\n+mod global_asm;\n mod inline_asm;\n mod intrinsics;\n mod linkage;\n@@ -123,7 +124,6 @@ struct CodegenCx<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     global_asm: String,\n     inline_asm_index: Cell<usize>,\n-    cached_context: Context,\n     debug_context: Option<DebugContext<'tcx>>,\n     unwind_context: UnwindContext,\n     cgu_name: Symbol,\n@@ -150,7 +150,6 @@ impl<'tcx> CodegenCx<'tcx> {\n             tcx,\n             global_asm: String::new(),\n             inline_asm_index: Cell::new(0),\n-            cached_context: Context::new(),\n             debug_context,\n             unwind_context,\n             cgu_name,\n@@ -159,7 +158,7 @@ impl<'tcx> CodegenCx<'tcx> {\n }\n \n pub struct CraneliftCodegenBackend {\n-    pub config: Option<BackendConfig>,\n+    pub config: RefCell<Option<BackendConfig>>,\n }\n \n impl CodegenBackend for CraneliftCodegenBackend {\n@@ -169,6 +168,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             Lto::No | Lto::ThinLocal => {}\n             Lto::Thin | Lto::Fat => sess.warn(\"LTO is not supported. You may get a linker error.\"),\n         }\n+\n+        let mut config = self.config.borrow_mut();\n+        if config.is_none() {\n+            let new_config = BackendConfig::from_opts(&sess.opts.cg.llvm_args)\n+                .unwrap_or_else(|err| sess.fatal(&err));\n+            *config = Some(new_config);\n+        }\n     }\n \n     fn target_features(&self, _sess: &Session, _allow_unstable: bool) -> Vec<rustc_span::Symbol> {\n@@ -186,15 +192,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n         tcx.sess.abort_if_errors();\n-        let config = if let Some(config) = self.config.clone() {\n-            config\n-        } else {\n-            if !tcx.sess.unstable_options() && !tcx.sess.opts.cg.llvm_args.is_empty() {\n-                tcx.sess.fatal(\"`-Z unstable-options` must be passed to allow configuring cg_clif\");\n-            }\n-            BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n-                .unwrap_or_else(|err| tcx.sess.fatal(&err))\n-        };\n+        let config = self.config.borrow().clone().unwrap();\n         match config.codegen_mode {\n             CodegenMode::Aot => driver::aot::run_aot(tcx, config, metadata, need_metadata_module),\n             CodegenMode::Jit | CodegenMode::JitLazy => {\n@@ -210,12 +208,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     fn join_codegen(\n         &self,\n         ongoing_codegen: Box<dyn Any>,\n-        _sess: &Session,\n+        sess: &Session,\n         _outputs: &OutputFilenames,\n     ) -> Result<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>), ErrorGuaranteed> {\n-        Ok(*ongoing_codegen\n-            .downcast::<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)>()\n-            .unwrap())\n+        Ok(ongoing_codegen\n+            .downcast::<driver::aot::OngoingCodegen>()\n+            .unwrap()\n+            .join(sess, self.config.borrow().as_ref().unwrap()))\n     }\n \n     fn link(\n@@ -312,5 +311,5 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n /// This is the entrypoint for a hot plugged rustc_codegen_cranelift\n #[no_mangle]\n pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n-    Box::new(CraneliftCodegenBackend { config: None })\n+    Box::new(CraneliftCodegenBackend { config: RefCell::new(None) })\n }"}, {"sha": "b6b465e1f4e0a808a394c07b68ee0563d1538314", "filename": "src/toolchain.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/src%2Ftoolchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523f0db7dbfdc9d8d5644accaf536902cbf62a4a/src%2Ftoolchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftoolchain.rs?ref=523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "patch": "@@ -8,10 +8,8 @@ use rustc_session::Session;\n /// Tries to infer the path of a binary for the target toolchain from the linker name.\n pub(crate) fn get_toolchain_binary(sess: &Session, tool: &str) -> PathBuf {\n     let (mut linker, _linker_flavor) = linker_and_flavor(sess);\n-    let linker_file_name = linker\n-        .file_name()\n-        .and_then(|name| name.to_str())\n-        .unwrap_or_else(|| sess.fatal(\"couldn't extract file name from specified linker\"));\n+    let linker_file_name =\n+        linker.file_name().unwrap().to_str().expect(\"linker filename should be valid UTF-8\");\n \n     if linker_file_name == \"ld.lld\" {\n         if tool != \"ld\" {"}]}