{"sha": "006f3eacae03adb1546e7ea04d92fe90d52fa509", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNmYzZWFjYWUwM2FkYjE1NDZlN2VhMDRkOTJmZTkwZDUyZmE1MDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-11T20:18:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-28T10:15:23Z"}, "message": "Fix a latent bug in trait dispatch where we sometimes counted associated types\nwhen constructing the vtable-index. Not good.", "tree": {"sha": "4239c7e3a781a4138d7c0969db8b9ed4fcade555", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4239c7e3a781a4138d7c0969db8b9ed4fcade555"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/006f3eacae03adb1546e7ea04d92fe90d52fa509", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/006f3eacae03adb1546e7ea04d92fe90d52fa509", "html_url": "https://github.com/rust-lang/rust/commit/006f3eacae03adb1546e7ea04d92fe90d52fa509", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/006f3eacae03adb1546e7ea04d92fe90d52fa509/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07cdb853317697c247b41e61f7a429c3fb623524", "url": "https://api.github.com/repos/rust-lang/rust/commits/07cdb853317697c247b41e61f7a429c3fb623524", "html_url": "https://github.com/rust-lang/rust/commit/07cdb853317697c247b41e61f7a429c3fb623524"}], "stats": {"total": 154, "additions": 80, "deletions": 74}, "files": [{"sha": "af41844b2df1220f2cf2208e23ec295b4431a59c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=006f3eacae03adb1546e7ea04d92fe90d52fa509", "patch": "@@ -904,8 +904,8 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                             try!(this.emit_struct_field(\"method_num\", 0, |this| {\n                                 this.emit_uint(o.method_num)\n                             }));\n-                            try!(this.emit_struct_field(\"real_index\", 0, |this| {\n-                                this.emit_uint(o.real_index)\n+                            try!(this.emit_struct_field(\"vtable_index\", 0, |this| {\n+                                this.emit_uint(o.vtable_index)\n                             }));\n                             Ok(())\n                         })\n@@ -1492,8 +1492,8 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                             this.read_uint()\n                                         }).unwrap()\n                                     },\n-                                    real_index: {\n-                                        this.read_struct_field(\"real_index\", 3, |this| {\n+                                    vtable_index: {\n+                                        this.read_struct_field(\"vtable_index\", 3, |this| {\n                                             this.read_uint()\n                                         }).unwrap()\n                                     },"}, {"sha": "4d5f3d925b09abfeb764b6d123dc8ac0de9eaf37", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=006f3eacae03adb1546e7ea04d92fe90d52fa509", "patch": "@@ -214,7 +214,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.closure_typer.param_env()\n     }\n \n-    pub fn closure_typer(&self) -> &'cx (ty::UnboxedClosureTyper<'tcx>+'cx) {\n+    pub fn closure_typer(&self) -> &'cx (ty::ClosureTyper<'tcx>+'cx) {\n         self.closure_typer\n     }\n "}, {"sha": "edeca83d5697f6dadba1300840e019f50d61d01c", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=006f3eacae03adb1546e7ea04d92fe90d52fa509", "patch": "@@ -329,58 +329,67 @@ pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                object_trait_ref: ty::PolyTraitRef<'tcx>,\n                                                trait_def_id: ast::DefId,\n-                                               method_index_in_trait: uint) -> uint {\n+                                               method_offset_in_trait: uint) -> uint {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by\n     // iterating down the supertraits of the object's trait until\n     // we find the trait the method came from, counting up the\n     // methods from them.\n     let mut method_count = 0;\n-    ty::each_bound_trait_and_supertraits(tcx, &[object_trait_ref], |bound_ref| {\n+\n+    for bound_ref in transitive_bounds(tcx, &[object_trait_ref]) {\n         if bound_ref.def_id() == trait_def_id {\n-            false\n-        } else {\n-            let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n-            for trait_item in trait_items.iter() {\n-                match *trait_item {\n-                    ty::MethodTraitItem(_) => method_count += 1,\n-                    ty::TypeTraitItem(_) => {}\n-                }\n+            break;\n+        }\n+\n+        let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n+        for trait_item in trait_items.iter() {\n+            match *trait_item {\n+                ty::MethodTraitItem(_) => method_count += 1,\n+                ty::TypeTraitItem(_) => {}\n             }\n-            true\n         }\n+    }\n+\n+    // count number of methods preceding the one we are selecting and\n+    // add them to the total offset; skip over associated types.\n+    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    for trait_item in trait_items.iter().take(method_offset_in_trait) {\n+        match *trait_item {\n+            ty::MethodTraitItem(_) => method_count += 1,\n+            ty::TypeTraitItem(_) => {}\n+        }\n+    }\n+\n+    // the item at the offset we were given really ought to be a method\n+    assert!(match trait_items[method_offset_in_trait] {\n+        ty::MethodTraitItem(_) => true,\n+        ty::TypeTraitItem(_) => false\n     });\n-    method_count + method_index_in_trait\n+\n+    method_count\n }\n \n-pub fn unboxed_closure_trait_ref_and_return_type<'tcx>(\n-    closure_typer: &ty::UnboxedClosureTyper<'tcx>,\n+pub enum TupleArgumentsFlag { Yes, No }\n+\n+pub fn closure_trait_ref_and_return_type<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n     fn_trait_def_id: ast::DefId,\n     self_ty: Ty<'tcx>,\n-    closure_def_id: ast::DefId,\n-    substs: &Substs<'tcx>)\n+    sig: &ty::PolyFnSig<'tcx>,\n+    tuple_arguments: TupleArgumentsFlag)\n     -> ty::Binder<(Rc<ty::TraitRef<'tcx>>, Ty<'tcx>)>\n {\n-    let tcx = closure_typer.param_env().tcx;\n-    let closure_type = closure_typer.unboxed_closure_type(closure_def_id, substs);\n-\n-    debug!(\"unboxed_closure_trait_ref: closure_def_id={} closure_type={}\",\n-           closure_def_id.repr(tcx),\n-           closure_type.repr(tcx));\n-\n-    let closure_sig = &closure_type.sig;\n-    let arguments_tuple = closure_sig.0.inputs[0];\n-    let trait_substs =\n-        Substs::new_trait(\n-            vec![arguments_tuple],\n-            vec![],\n-            self_ty);\n+    let arguments_tuple = match tuple_arguments {\n+        TupleArgumentsFlag::No => sig.0.inputs[0],\n+        TupleArgumentsFlag::Yes => ty::mk_tup(tcx, sig.0.inputs.to_vec()),\n+    };\n+    let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n     let trait_ref = Rc::new(ty::TraitRef {\n         def_id: fn_trait_def_id,\n         substs: tcx.mk_substs(trait_substs),\n     });\n-\n-    ty::Binder((trait_ref, closure_sig.0.output.unwrap()))\n+    ty::Binder((trait_ref, sig.0.output.unwrap()))\n }\n \n impl<'tcx,O:Repr<'tcx>> Repr<'tcx> for super::Obligation<'tcx, O> {"}, {"sha": "062ddd23d9de936ee5d93fadd080ef9d6c8ae919", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=006f3eacae03adb1546e7ea04d92fe90d52fa509", "patch": "@@ -452,7 +452,10 @@ pub struct MethodParam<'tcx> {\n     // never contains bound regions; those regions should have been\n     // instantiated with fresh variables at this point.\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n-    // index of uint in the list of methods for the trait\n+\n+    // index of uint in the list of trait items. Note that this is NOT\n+    // the index into the vtable, because the list of trait items\n+    // includes associated types.\n     pub method_num: uint,\n \n     /// The impl for the trait from which the method comes. This\n@@ -471,14 +474,14 @@ pub struct MethodObject<'tcx> {\n     // the actual base trait id of the object\n     pub object_trait_id: ast::DefId,\n \n-    // index of the method to be invoked amongst the trait's methods\n+    // index of the method to be invoked amongst the trait's items\n     pub method_num: uint,\n \n     // index into the actual runtime vtable.\n     // the vtable is formed by concatenating together the method lists of\n-    // the base object trait and all supertraits;  this is the index into\n+    // the base object trait and all supertraits; this is the index into\n     // that vtable\n-    pub real_index: uint,\n+    pub vtable_index: uint,\n }\n \n #[derive(Clone)]"}, {"sha": "de7a93d8d1294d245249b04e4752fb7616f4c8ea", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=006f3eacae03adb1546e7ea04d92fe90d52fa509", "patch": "@@ -319,7 +319,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::MethodOrigin<'tcx> {\n                     trait_ref: object.trait_ref.fold_with(folder),\n                     object_trait_id: object.object_trait_id,\n                     method_num: object.method_num,\n-                    real_index: object.real_index\n+                    vtable_index: object.vtable_index,\n                 })\n             }\n         }"}, {"sha": "0940c9b9ff4a025e1ca3937dbf5c2b5700d2ba64", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=006f3eacae03adb1546e7ea04d92fe90d52fa509", "patch": "@@ -1061,7 +1061,7 @@ impl<'tcx> Repr<'tcx> for ty::MethodObject<'tcx> {\n         format!(\"MethodObject({},{},{})\",\n                 self.trait_ref.repr(tcx),\n                 self.method_num,\n-                self.real_index)\n+                self.vtable_index)\n     }\n }\n "}, {"sha": "c4240fa9ebae7230c5e973cede7c674a8acd1bee", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=006f3eacae03adb1546e7ea04d92fe90d52fa509", "patch": "@@ -13,7 +13,7 @@ use back::abi;\n use back::link;\n use llvm::{self, ValueRef, get_param};\n use metadata::csearch;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::Substs;\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n@@ -29,6 +29,7 @@ use trans::expr::{SaveIn, Ignore};\n use trans::expr;\n use trans::glue;\n use trans::machine;\n+use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of::*;\n use middle::ty::{self, Ty};\n@@ -162,7 +163,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n             trans_trait_callee(bcx,\n                                monomorphize_type(bcx, method_ty),\n-                               mt.real_index,\n+                               mt.vtable_index,\n                                self_expr,\n                                arg_cleanup_scope)\n         }\n@@ -439,7 +440,7 @@ fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// extract the self data and vtable out of the pair.\n fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   method_ty: Ty<'tcx>,\n-                                  n_method: uint,\n+                                  vtable_index: uint,\n                                   self_expr: &ast::Expr,\n                                   arg_cleanup_scope: cleanup::ScopeId)\n                                   -> Callee<'blk, 'tcx> {\n@@ -469,28 +470,28 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         self_datum.val\n     };\n \n-    trans_trait_callee_from_llval(bcx, method_ty, n_method, llval)\n+    trans_trait_callee_from_llval(bcx, method_ty, vtable_index, llval)\n }\n \n /// Same as `trans_trait_callee()` above, except that it is given a by-ref pointer to the object\n /// pair.\n pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                  callee_ty: Ty<'tcx>,\n-                                                 n_method: uint,\n+                                                 vtable_index: uint,\n                                                  llpair: ValueRef)\n                                                  -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_trait_callee\");\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n-    debug!(\"(translating trait callee) loading second index from pair\");\n+    debug!(\"trans_trait_callee_from_llval(callee_ty={}, vtable_index={}, llpair={})\",\n+           callee_ty.repr(ccx.tcx()),\n+           vtable_index,\n+           bcx.val_to_string(llpair));\n     let llboxptr = GEPi(bcx, llpair, &[0u, abi::FAT_PTR_ADDR]);\n     let llbox = Load(bcx, llboxptr);\n     let llself = PointerCast(bcx, llbox, Type::i8p(ccx));\n \n-    // Load the function from the vtable and cast it to the expected type.\n-    debug!(\"(translating trait callee) loading method\");\n-\n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let llcallee_ty = match callee_ty.sty {\n         ty::ty_bare_fn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n@@ -500,10 +501,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     output: f.sig.0.output,\n                     variadic: f.sig.0.variadic,\n                 });\n-            type_of_rust_fn(ccx,\n-                            Some(Type::i8p(ccx)),\n-                            &fake_sig,\n-                            f.abi)\n+            type_of_rust_fn(ccx, Some(Type::i8p(ccx)), &fake_sig, f.abi)\n         }\n         _ => {\n             ccx.sess().bug(\"meth::trans_trait_callee given non-bare-rust-fn\");\n@@ -514,7 +512,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     GEPi(bcx, llpair,\n                                          &[0u, abi::FAT_PTR_EXTRA]),\n                                     Type::vtable(ccx).ptr_to().ptr_to()));\n-    let mptr = Load(bcx, GEPi(bcx, llvtable, &[0u, n_method + VTABLE_OFFSET]));\n+    let mptr = Load(bcx, GEPi(bcx, llvtable, &[0u, vtable_index + VTABLE_OFFSET]));\n     let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n     return Callee {\n@@ -558,7 +556,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_object_shim(object_ty={}, trait_id={}, n_method={})\",\n+    debug!(\"trans_object_shim(object_ty={}, trait_id={}, method_offset_in_trait={})\",\n            object_ty.repr(tcx),\n            trait_id.repr(tcx),\n            method_offset_in_trait);\n@@ -587,7 +585,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n             tcx.sess.bug(\"can't create a method shim for an associated type\")\n         }\n     };\n-    let fty = method_ty.fty.subst(tcx, &object_substs);\n+    let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n     let fty = tcx.mk_bare_fn(fty);\n     debug!(\"trans_object_shim: fty={}\", fty.repr(tcx));\n "}, {"sha": "6b6ca600a88310bed56931b48a376d359f3ef1ce", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=006f3eacae03adb1546e7ea04d92fe90d52fa509", "patch": "@@ -103,6 +103,10 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  abi: abi::Abi)\n                                  -> Type\n {\n+    debug!(\"type_of_rust_fn(sig={},abi={:?})\",\n+           sig.repr(cx.tcx()),\n+           abi);\n+\n     let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n     assert!(!sig.variadic); // rust fns are never variadic\n "}, {"sha": "67b055ac946cc0cf56c61ddaa55ca8ea920acd8d", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=006f3eacae03adb1546e7ea04d92fe90d52fa509", "patch": "@@ -206,7 +206,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 (impl_polytype.substs, MethodStatic(pick.method_ty.def_id))\n             }\n \n-            probe::ObjectPick(trait_def_id, method_num, real_index) => {\n+            probe::ObjectPick(trait_def_id, method_num, vtable_index) => {\n                 self.extract_trait_ref(self_ty, |this, object_ty, data| {\n                     // The object data has no entry for the Self\n                     // Type. For the purposes of this method call, we\n@@ -233,7 +233,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         trait_ref: upcast_trait_ref,\n                         object_trait_id: trait_def_id,\n                         method_num: method_num,\n-                        real_index: real_index,\n+                        vtable_index: vtable_index,\n                     });\n                     (substs, origin)\n                 })"}, {"sha": "6a3554314e215ac3e85c3910c130a982f62dc373", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006f3eacae03adb1546e7ea04d92fe90d52fa509/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=006f3eacae03adb1546e7ea04d92fe90d52fa509", "patch": "@@ -59,7 +59,7 @@ struct Candidate<'tcx> {\n \n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n-    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n+    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ uint, /* vtable index */ uint),\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n                            subst::Substs<'tcx>, MethodIndex),\n     ClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n@@ -318,7 +318,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n-        self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n+        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, m, method_num| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n             let vtable_index =\n@@ -365,7 +365,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             })\n             .collect();\n \n-        self.elaborate_bounds(bounds.as_slice(), true, |this, poly_trait_ref, m, method_num| {\n+        self.elaborate_bounds(bounds.as_slice(), |this, poly_trait_ref, m, method_num| {\n             let trait_ref =\n                 this.erase_late_bound_regions(&poly_trait_ref);\n \n@@ -405,7 +405,6 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn elaborate_bounds<F>(\n         &mut self,\n         bounds: &[ty::PolyTraitRef<'tcx>],\n-        num_includes_types: bool,\n         mut mk_cand: F,\n     ) where\n         F: for<'b> FnMut(\n@@ -427,8 +426,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             let (pos, method) = match trait_method(tcx,\n                                                    bound_trait_ref.def_id(),\n-                                                   self.method_name,\n-                                                   num_includes_types) {\n+                                                   self.method_name) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n@@ -1139,19 +1137,13 @@ fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// index (or `None`, if no such method).\n fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       trait_def_id: ast::DefId,\n-                      method_name: ast::Name,\n-                      num_includes_types: bool)\n+                      method_name: ast::Name)\n                       -> Option<(uint, Rc<ty::Method<'tcx>>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     debug!(\"trait_method; items: {:?}\", trait_items);\n     trait_items\n         .iter()\n-        .filter(|item|\n-            num_includes_types || match *item {\n-                &ty::MethodTraitItem(_) => true,\n-                &ty::TypeTraitItem(_) => false\n-            })\n         .enumerate()\n         .find(|&(_, ref item)| item.name() == method_name)\n         .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))"}]}