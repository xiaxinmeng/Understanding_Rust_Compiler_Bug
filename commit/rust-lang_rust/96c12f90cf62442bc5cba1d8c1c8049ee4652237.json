{"sha": "96c12f90cf62442bc5cba1d8c1c8049ee4652237", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YzEyZjkwY2Y2MjQ0MmJjNWNiYTFkOGMxYzgwNDllZTQ2NTIyMzc=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-02-12T09:07:41Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-02-12T09:10:17Z"}, "message": "fixup! Implement the precise analysis pass for lint `disjoint_capture_drop_reorder`", "tree": {"sha": "27fe0a4c9e11bfa711a8f2aa413b59cb2d62e9b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27fe0a4c9e11bfa711a8f2aa413b59cb2d62e9b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96c12f90cf62442bc5cba1d8c1c8049ee4652237", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96c12f90cf62442bc5cba1d8c1c8049ee4652237", "html_url": "https://github.com/rust-lang/rust/commit/96c12f90cf62442bc5cba1d8c1c8049ee4652237", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96c12f90cf62442bc5cba1d8c1c8049ee4652237/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b54640128766d967d5d7366f5d068cd4a774ead", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b54640128766d967d5d7366f5d068cd4a774ead", "html_url": "https://github.com/rust-lang/rust/commit/5b54640128766d967d5d7366f5d068cd4a774ead"}], "stats": {"total": 92, "additions": 34, "deletions": 58}, "files": [{"sha": "0d045c1b9c475a044c25c196a57f15234be35579", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 34, "deletions": 58, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/96c12f90cf62442bc5cba1d8c1c8049ee4652237/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96c12f90cf62442bc5cba1d8c1c8049ee4652237/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=96c12f90cf62442bc5cba1d8c1c8049ee4652237", "patch": "@@ -540,21 +540,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         body: &'tcx hir::Body<'tcx>,\n     ) {\n-        let need_migrations_first_pass = self.compute_2229_migrations_first_pass(\n+        let need_migrations = self.compute_2229_migrations(\n             closure_def_id,\n             span,\n             capture_clause,\n             body,\n             self.typeck_results.borrow().closure_min_captures.get(&closure_def_id),\n         );\n \n-        let need_migrations = self.compute_2229_migrations_precise_pass(\n-            closure_def_id,\n-            span,\n-            self.typeck_results.borrow().closure_min_captures.get(&closure_def_id),\n-            &need_migrations_first_pass,\n-        );\n-\n         if !need_migrations.is_empty() {\n             let migrations_text = migration_suggestion_for_2229(self.tcx, &need_migrations);\n \n@@ -583,15 +576,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// - It would have been moved into the closure when `capture_disjoint_fields` wasn't\n     ///   enabled, **and**\n     /// - It wasn't completely captured by the closure, **and**\n-    /// - The type of the root variable needs Drop.\n-    fn compute_2229_migrations_first_pass(\n+    /// - One of the paths starting at this root variable, that is not captured needs Drop.\n+    fn compute_2229_migrations(\n         &self,\n         closure_def_id: DefId,\n         closure_span: Span,\n         closure_clause: hir::CaptureBy,\n         body: &'tcx hir::Body<'tcx>,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n-    ) -> Vec<(hir::HirId, Ty<'tcx>)> {\n+    ) -> Vec<hir::HirId> {\n         fn resolve_ty<T: TypeFoldable<'tcx>>(\n             fcx: &FnCtxt<'_, 'tcx>,\n             span: Span,\n@@ -627,64 +620,44 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 match closure_clause {\n                     // Only migrate if closure is a move closure\n-                    hir::CaptureBy::Value => need_migrations.push((var_hir_id, ty)),\n+                    hir::CaptureBy::Value => need_migrations.push(var_hir_id),\n \n                     hir::CaptureBy::Ref => {}\n                 }\n \n                 continue;\n             };\n \n-            let is_moved = root_var_min_capture_list\n+            let projections_list = root_var_min_capture_list\n                 .iter()\n-                .any(|capture| matches!(capture.info.capture_kind, ty::UpvarCapture::ByValue(_)));\n-\n-            let is_not_completely_captured =\n-                root_var_min_capture_list.iter().any(|capture| capture.place.projections.len() > 0);\n-\n-            if is_moved && is_not_completely_captured {\n-                need_migrations.push((var_hir_id, ty));\n-            }\n-        }\n-\n-        need_migrations\n-    }\n-\n-    fn compute_2229_migrations_precise_pass(\n-        &self,\n-        closure_def_id: DefId,\n-        closure_span: Span,\n-        min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n-        need_migrations: &[(hir::HirId, Ty<'tcx>)],\n-    ) -> Vec<hir::HirId> {\n-        // Need migrations -- second pass\n-        let mut need_migrations_2 = Vec::new();\n-\n-        for (hir_id, ty) in need_migrations {\n-            let projections_list = min_captures\n-                .and_then(|m| m.get(hir_id))\n-                .into_iter()\n-                .flatten()\n                 .filter_map(|captured_place| match captured_place.info.capture_kind {\n                     // Only care about captures that are moved into the closure\n                     ty::UpvarCapture::ByValue(..) => {\n                         Some(captured_place.place.projections.as_slice())\n                     }\n                     ty::UpvarCapture::ByRef(..) => None,\n                 })\n-                .collect();\n+                .collect::<Vec<_>>();\n \n-            if self.has_significant_drop_outside_of_captures(\n-                closure_def_id,\n-                closure_span,\n-                ty,\n-                projections_list,\n-            ) {\n-                need_migrations_2.push(*hir_id);\n+            let is_moved = !projections_list.is_empty();\n+\n+            let is_not_completely_captured =\n+                root_var_min_capture_list.iter().any(|capture| capture.place.projections.len() > 0);\n+\n+            if is_moved\n+                && is_not_completely_captured\n+                && self.has_significant_drop_outside_of_captures(\n+                    closure_def_id,\n+                    closure_span,\n+                    ty,\n+                    projections_list,\n+                )\n+            {\n+                need_migrations.push(var_hir_id);\n             }\n         }\n \n-        need_migrations_2\n+        need_migrations\n     }\n \n     /// This is a helper function to `compute_2229_migrations_precise_pass`. Provided the type\n@@ -822,21 +795,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         assert!(!is_completely_captured || (captured_projs.len() == 1));\n \n-        if is_drop_defined_for_ty {\n-            // If drop is implemented for this type then we need it to be fully captured, or\n-            // it will require migration.\n-            return !is_completely_captured;\n-        }\n-\n         if is_completely_captured {\n             // The place is captured entirely, so doesn't matter if needs dtor, it will be drop\n             // when the closure is dropped.\n             return false;\n         }\n \n-        match base_path_ty.kind() {\n-            _ if captured_projs.is_empty() => needs_drop(base_path_ty),\n+        if is_drop_defined_for_ty {\n+            // If drop is implemented for this type then we need it to be fully captured,\n+            // which we know it is not because of the previous check. Therefore we need to\n+            // do migrate.\n+            return true;\n+        }\n+\n+        if captured_projs.is_empty() {\n+            return needs_drop(base_path_ty);\n+        }\n \n+        match base_path_ty.kind() {\n             // Observations:\n             // - `captured_projs` is not empty. Therefore we can call\n             //   `captured_projs.first().unwrap()` safely."}]}