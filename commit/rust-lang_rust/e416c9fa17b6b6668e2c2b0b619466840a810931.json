{"sha": "e416c9fa17b6b6668e2c2b0b619466840a810931", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MTZjOWZhMTdiNmI2NjY4ZTJjMmIwYjYxOTQ2Njg0MGE4MTA5MzE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-06-16T18:03:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-02T00:43:54Z"}, "message": "Adjust documentation to describe how closures and closure bounds\naffect things.", "tree": {"sha": "68db1c16b5e3b35bd574d915820dd4e7a1cea61b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68db1c16b5e3b35bd574d915820dd4e7a1cea61b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e416c9fa17b6b6668e2c2b0b619466840a810931", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e416c9fa17b6b6668e2c2b0b619466840a810931", "html_url": "https://github.com/rust-lang/rust/commit/e416c9fa17b6b6668e2c2b0b619466840a810931", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e416c9fa17b6b6668e2c2b0b619466840a810931/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7522fec1599d99ff7cff95c53850fd72e74979f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7522fec1599d99ff7cff95c53850fd72e74979f", "html_url": "https://github.com/rust-lang/rust/commit/d7522fec1599d99ff7cff95c53850fd72e74979f"}], "stats": {"total": 272, "additions": 254, "deletions": 18}, "files": [{"sha": "df6d5dc1b2060060b684104203e9a8e7d1fa6041", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "modified", "additions": 254, "deletions": 18, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/e416c9fa17b6b6668e2c2b0b619466840a810931/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e416c9fa17b6b6668e2c2b0b619466840a810931/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=e416c9fa17b6b6668e2c2b0b619466840a810931", "patch": "@@ -12,6 +12,11 @@\n \n Region inference module.\n \n+# Terminology\n+\n+Note that we use the terms region and lifetime interchangeably,\n+though the term `lifetime` is preferred.\n+\n # Introduction\n \n Region inference uses a somewhat more involved algorithm than type\n@@ -50,10 +55,7 @@ Variables and constraints are created using the following methods:\n   the greatest region that is smaller than both R_i and R_j\n \n The actual region resolution algorithm is not entirely\n-obvious, though it is also not overly complex.  I'll explain\n-the algorithm as it currently works, then explain a somewhat\n-more complex variant that would probably scale better for\n-large graphs (and possibly all graphs).\n+obvious, though it is also not overly complex.\n \n ## Snapshotting\n \n@@ -68,10 +70,9 @@ is in progress, but only the root snapshot can \"commit\".\n \n The constraint resolution algorithm is not super complex but also not\n entirely obvious.  Here I describe the problem somewhat abstractly,\n-then describe how the current code works, and finally describe a\n-better solution that is as of yet unimplemented.  There may be other,\n-smarter ways of doing this with which I am unfamiliar and can't be\n-bothered to research at the moment. - NDM\n+then describe how the current code works.  There may be other, smarter\n+ways of doing this with which I am unfamiliar and can't be bothered to\n+research at the moment. - NDM\n \n ## The problem\n \n@@ -120,19 +121,254 @@ its value as the GLB of all its successors.  Basically contracting\n nodes ensure that there is overlap between their successors; we will\n ultimately infer the largest overlap possible.\n \n-### A better algorithm\n-\n-Fixed-point iteration is not necessary.  What we ought to do is first\n+# The Region Hierarchy\n+\n+## Without closures\n+\n+Let's first consider the region hierarchy without thinking about\n+closures, because they add a lot of complications. The region\n+hierarchy *basically* mirrors the lexical structure of the code.\n+There is a region for every piece of 'evaluation' that occurs, meaning\n+every expression, block, and pattern (patterns are considered to\n+\"execute\" by testing the value they are applied to and creating any\n+relevant bindings).  So, for example:\n+\n+    fn foo(x: int, y: int) { // -+\n+    //  +------------+       //  |\n+    //  |      +-----+       //  |\n+    //  |  +-+ +-+ +-+       //  |\n+    //  |  | | | | | |       //  |\n+    //  v  v v v v v v       //  |\n+        let z = x + y;       //  |\n+        ...                  //  |\n+    }                        // -+\n+\n+    fn bar() { ... }\n+\n+In this example, there is a region for the fn body block as a whole,\n+and then a subregion for the declaration of the local variable.\n+Within that, there are sublifetimes for the assignment pattern and\n+also the expression `x + y`. The expression itself has sublifetimes\n+for evaluating `x` and and `y`.\n+\n+## Function calls\n+\n+Function calls are a bit tricky. I will describe how we handle them\n+*now* and then a bit about how we can improve them (Issue #6268).\n+\n+Consider a function call like `func(expr1, expr2)`, where `func`,\n+`arg1`, and `arg2` are all arbitrary expressions. Currently,\n+we construct a region hierarchy like:\n+\n+    +----------------+\n+    |                |\n+    +--+ +---+  +---+|\n+    v  v v   v  v   vv\n+    func(expr1, expr2)\n+\n+Here you can see that the call as a whole has a region and the\n+function plus arguments are subregions of that. As a side-effect of\n+this, we get a lot of spurious errors around nested calls, in\n+particular when combined with `&mut` functions. For example, a call\n+like this one\n+\n+    self.foo(self.bar())\n+\n+where both `foo` and `bar` are `&mut self` functions will always yield\n+an error.\n+\n+Here is a more involved example (which is safe) so we can see what's\n+going on:\n+\n+    struct Foo { f: uint, g: uint }\n+    ...\n+    fn add(p: &mut uint, v: uint) {\n+        *p += v;\n+    }\n+    ...\n+    fn inc(p: &mut uint) -> uint {\n+        *p += 1; *p\n+    }\n+    fn weird() {\n+        let mut x: ~Foo = ~Foo { ... };\n+        'a: add(&mut (*x).f,\n+                'b: inc(&mut (*x).f)) // (*)\n+    }\n+\n+The important part is the line marked `(*)` which contains a call to\n+`add()`. The first argument is a mutable borrow of the field `f`.  The\n+second argument also borrows the field `f`. Now, in the current borrow\n+checker, the first borrow is given the lifetime of the call to\n+`add()`, `'a`.  The second borrow is given the lifetime of `'b` of the\n+call to `inc()`. Because `'b` is considered to be a sublifetime of\n+`'a`, an error is reported since there are two co-existing mutable\n+borrows of the same data.\n+\n+However, if we were to examine the lifetimes a bit more carefully, we\n+can see that this error is unnecessary. Let's examine the lifetimes\n+involved with `'a` in detail. We'll break apart all the steps involved\n+in a call expression:\n+\n+    'a: {\n+        'a_arg1: let a_temp1: ... = add;\n+        'a_arg2: let a_temp2: &'a mut uint = &'a mut (*x).f;\n+        'a_arg3: let a_temp3: uint = {\n+            let b_temp1: ... = inc;\n+            let b_temp2: &'b = &'b mut (*x).f;\n+            'b_call: b_temp1(b_temp2)\n+        };\n+        'a_call: a_temp1(a_temp2, a_temp3) // (**)\n+    }\n+\n+Here we see that the lifetime `'a` includes a number of substatements.\n+In particular, there is this lifetime I've called `'a_call` that\n+corresponds to the *actual execution of the function `add()`*, after\n+all arguments have been evaluated. There is a corresponding lifetime\n+`'b_call` for the execution of `inc()`. If we wanted to be precise\n+about it, the lifetime of the two borrows should be `'a_call` and\n+`'b_call` respectively, since the borrowed pointers that were created\n+will not be dereferenced except during the execution itself.\n+\n+However, this model by itself is not sound. The reason is that\n+while the two borrowed pointers that are created will never be used\n+simultaneously, it is still true that the first borrowed pointer is\n+*created* before the second argument is evaluated, and so even though\n+it will not be *dereferenced* during the evaluation of the second\n+argument, it can still be *invalidated* by that evaluation. Consider\n+this similar but unsound example:\n+\n+    struct Foo { f: uint, g: uint }\n+    ...\n+    fn add(p: &mut uint, v: uint) {\n+        *p += v;\n+    }\n+    ...\n+    fn consume(x: ~Foo) -> uint {\n+        x.f + x.g\n+    }\n+    fn weird() {\n+        let mut x: ~Foo = ~Foo { ... };\n+        'a: add(&mut (*x).f, consume(x)) // (*)\n+    }\n+\n+In this case, the second argument to `add` actually consumes `x`, thus\n+invalidating the first argument.\n+\n+So, for now, we exclude the `call` lifetimes from our model.\n+Eventually I would like to include them, but we will have to make the\n+borrow checker handle this situation correctly. In particular, if\n+there is a borrowed pointer created whose lifetime does not enclose\n+the borrow expression, we must issue sufficient restrictions to ensure\n+that the pointee remains valid.\n+\n+## Adding closures\n+\n+The other significant complication to the region hierarchy is\n+closures. I will describe here how closures should work, though some\n+of the work to implement this model is ongoing at the time of this\n+writing.\n+\n+The body of closures are type-checked along with the function that\n+creates them. However, unlike other expressions that appear within the\n+function body, it is not entirely obvious when a closure body executes\n+with respect to the other expressions. This is because the closure\n+body will execute whenever the closure is called; however, we can\n+never know precisely when the closure will be called, especially\n+without some sort of alias analysis.\n+\n+However, we can place some sort of limits on when the closure\n+executes.  In particular, the type of every closure `fn:'r K` includes\n+a region bound `'r`. This bound indicates the maximum lifetime of that\n+closure; once we exit that region, the closure cannot be called\n+anymore. Therefore, we say that the lifetime of the closure body is a\n+sublifetime of the closure bound, but the closure body itself is unordered\n+with respect to other parts of the code.\n+\n+For example, consider the following fragment of code:\n+\n+    'a: {\n+         let closure: fn:'a() = || 'b: {\n+             'c: ...\n+         };\n+         'd: ...\n+    }\n+\n+Here we have four lifetimes, `'a`, `'b`, `'c`, and `'d`. The closure\n+`closure` is bounded by the lifetime `'a`. The lifetime `'b` is the\n+lifetime of the closure body, and `'c` is some statement within the\n+closure body. Finally, `'d` is a statement within the outer block that\n+created the closure.\n+\n+We can say that the closure body `'b` is a sublifetime of `'a` due to\n+the closure bound. By the usual lexical scoping conventions, the\n+statement `'c` is clearly a sublifetime of `'b`, and `'d` is a\n+sublifetime of `'d`. However, there is no ordering between `'c` and\n+`'d` per se (this kind of ordering between statements is actually only\n+an issue for dataflow; passes like the borrow checker must assume that\n+closures could execute at any time from the moment they are created\n+until they go out of scope).\n+\n+### Complications due to closure bound inference\n+\n+There is only one problem with the above model: in general, we do not\n+actually *know* the closure bounds during region inference! In fact,\n+closure bounds are almost always region variables! This is very tricky\n+because the inference system implicitly assumes that we can do things\n+like compute the LUB of two scoped lifetimes without needing to know\n+the values of any variables.\n+\n+Here is an example to illustrate the problem:\n+\n+    fn identify<T>(x: T) -> T { x }\n+\n+    fn foo() { // 'foo is the function body\n+      'a: {\n+           let closure = identity(|| 'b: {\n+               'c: ...\n+           });\n+           'd: closure();\n+      }\n+      'e: ...;\n+    }\n+\n+In this example, the closure bound is not explicit. At compile time,\n+we will create a region variable (let's call it `V0`) to represent the\n+closure bound.\n+\n+The primary difficulty arises during the constraint propagation phase.\n+Imagine there is some variable with incoming edges from `'c` and `'d`.\n+This means that the value of the variable must be `LUB('c,\n+'d)`. However, without knowing what the closure bound `V0` is, we\n+can't compute the LUB of `'c` and `'d`! Any we don't know the closure\n+bound until inference is done.\n+\n+The solution is to rely on the fixed point nature of inference.\n+Basically, when we must compute `LUB('c, 'd)`, we just use the current\n+value for `V0` as the closure's bound. If `V0`'s binding should\n+change, then we will do another round of inference, and the result of\n+`LUB('c, 'd)` will change.\n+\n+One minor implication of this is that the graph does not in fact track\n+the full set of dependencies between edges. We cannot easily know\n+whether the result of a LUB computation will change, since there may\n+be indirect dependencies on other variables that are not reflected on\n+the graph. Therefore, we must *always* iterate over all edges when\n+doing the fixed point calculation, not just those adjacent to nodes\n+whose values have changed.\n+\n+Were it not for this requirement, we could in fact avoid fixed-point\n+iteration altogether. In that universe, we could instead first\n identify and remove strongly connected components (SCC) in the graph.\n Note that such components must consist solely of region variables; all\n of these variables can effectively be unified into a single variable.\n-\n-Once SCCs are removed, we are left with a DAG.  At this point, we can\n-walk the DAG in toplogical order once to compute the expanding nodes,\n-and again in reverse topological order to compute the contracting\n-nodes. The main reason I did not write it this way is that I did not\n-feel like implementing the SCC and toplogical sort algorithms at the\n-moment.\n+Once SCCs are removed, we are left with a DAG.  At this point, we\n+could walk the DAG in toplogical order once to compute the expanding\n+nodes, and again in reverse topological order to compute the\n+contracting nodes. However, as I said, this does not work given the\n+current treatment of closure bounds, but perhaps in the future we can\n+address this problem somehow and make region inference somewhat more\n+efficient. Note that this is solely a matter of performance, not\n+expressiveness.\n \n # Skolemization and functions\n "}]}