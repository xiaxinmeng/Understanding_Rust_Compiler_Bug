{"sha": "7474be066022d2cd0b0695a466651570c00f3700", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NzRiZTA2NjAyMmQyY2QwYjA2OTVhNDY2NjUxNTcwYzAwZjM3MDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-02T09:09:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-03T12:01:21Z"}, "message": "Make `ty::ParameterEnvironment`, not `ty::ctxt`, implement `Typer` and\n`UnboxedClosureTyper`. This requires adding a `tcx` field to\n`ParameterEnvironment` but generally simplifies everything since we\nonly need to pass along an `UnboxedClosureTyper` or `Typer`.", "tree": {"sha": "83eb0f9d208ac3b3e14c81694ad348ee2b473923", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83eb0f9d208ac3b3e14c81694ad348ee2b473923"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7474be066022d2cd0b0695a466651570c00f3700", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7474be066022d2cd0b0695a466651570c00f3700", "html_url": "https://github.com/rust-lang/rust/commit/7474be066022d2cd0b0695a466651570c00f3700", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7474be066022d2cd0b0695a466651570c00f3700/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83ef3042de889db07b819fc6b2802cd0ace7e21c", "url": "https://api.github.com/repos/rust-lang/rust/commits/83ef3042de889db07b819fc6b2802cd0ace7e21c", "html_url": "https://github.com/rust-lang/rust/commit/83ef3042de889db07b819fc6b2802cd0ace7e21c"}], "stats": {"total": 547, "additions": 288, "deletions": 259}, "files": [{"sha": "9cb8674c3e1b7478137e2b37a1c598ae92b049b0", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -99,7 +99,7 @@ impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n \n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub param_env: ParameterEnvironment<'tcx>,\n+    pub param_env: ParameterEnvironment<'a, 'tcx>,\n }\n \n #[deriving(Clone, PartialEq)]\n@@ -148,7 +148,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n pub fn check_crate(tcx: &ty::ctxt) {\n     visit::walk_crate(&mut MatchCheckCtxt {\n         tcx: tcx,\n-        param_env: ty::empty_parameter_environment(),\n+        param_env: ty::empty_parameter_environment(tcx),\n     }, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n@@ -1061,8 +1061,7 @@ fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n         cx: cx,\n     };\n     let mut visitor = ExprUseVisitor::new(&mut checker,\n-                                          checker.cx.tcx,\n-                                          &cx.param_env);\n+                                          &checker.cx.param_env);\n     visitor.walk_expr(guard);\n }\n "}, {"sha": "c383b1579ef84332a9817a10dc5cafc9dc133ba6", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n         {\n             let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n             let mut delegate = RvalueContextDelegate { tcx: self.tcx, param_env: &param_env };\n-            let mut euv = euv::ExprUseVisitor::new(&mut delegate, self.tcx, &param_env);\n+            let mut euv = euv::ExprUseVisitor::new(&mut delegate, &param_env);\n             euv.walk_fn(fd, b);\n         }\n         visit::walk_fn(self, fk, fd, b, s)\n@@ -50,7 +50,7 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n \n struct RvalueContextDelegate<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'a,'tcx>,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {"}, {"sha": "9c9e68002c980d9c40e2c6b5b2177f019b54aa5e", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -54,7 +54,7 @@ struct CheckStaticVisitor<'a, 'tcx: 'a> {\n }\n \n struct GlobalVisitor<'a,'b,'tcx:'a+'b>(\n-    euv::ExprUseVisitor<'a,'b,'tcx,ty::ctxt<'tcx>>);\n+    euv::ExprUseVisitor<'a,'b,'tcx,ty::ParameterEnvironment<'b,'tcx>>);\n struct GlobalChecker {\n     static_consumptions: NodeSet,\n     const_borrows: NodeSet,\n@@ -70,8 +70,8 @@ pub fn check_crate(tcx: &ty::ctxt) {\n         static_local_borrows: NodeSet::new(),\n     };\n     {\n-        let param_env = ty::empty_parameter_environment();\n-        let visitor = euv::ExprUseVisitor::new(&mut checker, tcx, &param_env);\n+        let param_env = ty::empty_parameter_environment(tcx);\n+        let visitor = euv::ExprUseVisitor::new(&mut checker, &param_env);\n         visit::walk_crate(&mut GlobalVisitor(visitor), tcx.map.krate());\n     }\n     visit::walk_crate(&mut CheckStaticVisitor {\n@@ -121,8 +121,8 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-        let env = ty::empty_parameter_environment();\n-        match fulfill_cx.select_all_or_error(&infcx, &env, self.tcx) {\n+        let env = ty::empty_parameter_environment(self.tcx);\n+        match fulfill_cx.select_all_or_error(&infcx, &env) {\n             Ok(()) => { },\n             Err(ref errors) => {\n                 traits::report_fulfillment_errors(&infcx, errors);"}, {"sha": "f5cf4af1230a4a02dc66d1ba95599bf3a7fdf313", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -23,7 +23,7 @@ use self::OverloadedCallType::*;\n use middle::{def, region, pat_util};\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Typer;\n-use middle::ty::{mod, ParameterEnvironment, Ty};\n+use middle::ty::{mod};\n use middle::ty::{MethodCall, MethodObject, MethodTraitObject};\n use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::ty::{MethodStatic, MethodStaticUnboxedClosure};\n@@ -299,7 +299,8 @@ pub struct ExprUseVisitor<'d,'t,'tcx:'t,TYPER:'t> {\n     typer: &'t TYPER,\n     mc: mc::MemCategorizationContext<'t,TYPER>,\n     delegate: &'d mut (Delegate<'tcx>+'d),\n-    param_env: &'t ParameterEnvironment<'tcx>,\n+}\n+\n // If the TYPER results in an error, it's because the type check\n // failed (or will fail, when the error is uncovered and reported\n // during writeback). In this case, we just ignore this part of the\n@@ -324,14 +325,12 @@ enum PassArgs {\n \n impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     pub fn new(delegate: &'d mut Delegate<'tcx>,\n-               typer: &'t TYPER,\n-               param_env: &'t ParameterEnvironment<'tcx>)\n+               typer: &'t TYPER)\n                -> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         ExprUseVisitor {\n             typer: typer,\n             mc: mc::MemCategorizationContext::new(typer),\n             delegate: delegate,\n-            param_env: param_env,\n         }\n     }\n "}, {"sha": "2962b7b7c8e48b2727eab61cb4c53d24df2a029f", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -41,7 +41,7 @@ struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n     // environments for each function we encounter. When we find a\n     // call to `transmute`, we can check it in the context of the top\n     // of the stack (which ought not to be empty).\n-    param_envs: Vec<ty::ParameterEnvironment<'tcx>>,\n+    param_envs: Vec<ty::ParameterEnvironment<'a,'tcx>>,\n \n     // Dummy sized/unsized types that use to substitute for type\n     // parameters in order to estimate how big a type will be for any"}, {"sha": "722fe82d41c32446bd3f3bbdfcd77008d9a1f690", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 73, "deletions": 71, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -272,7 +272,6 @@ pub type McResult<T> = Result<T, ()>;\n /// can be sure that only `Ok` results will occur.\n pub trait Typer<'tcx> : ty::UnboxedClosureTyper<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-    fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx>;\n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>>;\n     fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool;\n@@ -1292,77 +1291,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n               self.tcx().sess.span_bug(pat.span, \"unexpanded macro\");\n           }\n         }\n-    }\n \n-    pub fn cmt_to_string(&self, cmt: &cmt_<'tcx>) -> String {\n-        fn upvar_to_string(upvar: &Upvar, is_copy: bool) -> String {\n-            if upvar.is_unboxed {\n-                let kind = match upvar.kind {\n-                    ty::FnUnboxedClosureKind => \"Fn\",\n-                    ty::FnMutUnboxedClosureKind => \"FnMut\",\n-                    ty::FnOnceUnboxedClosureKind => \"FnOnce\"\n-                };\n-                format!(\"captured outer variable in an `{}` closure\", kind)\n-            } else {\n-                (match (upvar.kind, is_copy) {\n-                    (ty::FnOnceUnboxedClosureKind, true) => \"captured outer variable in a proc\",\n-                    _ => \"captured outer variable\"\n-                }).to_string()\n-            }\n-        }\n-\n-        match cmt.cat {\n-          cat_static_item => {\n-              \"static item\".to_string()\n-          }\n-          cat_rvalue(..) => {\n-              \"non-lvalue\".to_string()\n-          }\n-          cat_local(vid) => {\n-              match self.tcx().map.find(vid) {\n-                  Some(ast_map::NodeArg(_)) => {\n-                      \"argument\".to_string()\n-                  }\n-                  _ => \"local variable\".to_string()\n-              }\n-          }\n-          cat_deref(_, _, pk) => {\n-              let upvar = cmt.upvar();\n-              match upvar.as_ref().map(|i| &i.cat) {\n-                  Some(&cat_upvar(ref var)) => {\n-                      upvar_to_string(var, false)\n-                  }\n-                  Some(_) => unreachable!(),\n-                  None => {\n-                      match pk {\n-                          Implicit(..) => {\n-                            \"dereference (dereference is implicit, due to indexing)\".to_string()\n-                          }\n-                          Unique => format!(\"dereference of `{}`\", ptr_sigil(pk)),\n-                          _ => format!(\"dereference of `{}`-pointer\", ptr_sigil(pk))\n-                      }\n-                  }\n-              }\n-          }\n-          cat_interior(_, InteriorField(NamedField(_))) => {\n-              \"field\".to_string()\n-          }\n-          cat_interior(_, InteriorField(PositionalField(_))) => {\n-              \"anonymous field\".to_string()\n-          }\n-          cat_interior(_, InteriorElement(VecElement)) => {\n-              \"vec content\".to_string()\n-          }\n-          cat_interior(_, InteriorElement(OtherElement)) => {\n-              \"indexed content\".to_string()\n-          }\n-          cat_upvar(ref var) => {\n-              upvar_to_string(var, true)\n-          }\n-          cat_downcast(ref cmt, _) => {\n-            self.cmt_to_string(&**cmt)\n-          }\n-        }\n+        Ok(())\n     }\n }\n \n@@ -1474,6 +1404,78 @@ impl<'tcx> cmt_<'tcx> {\n             NoteNone => None\n         }\n     }\n+\n+\n+    pub fn descriptive_string(&self, tcx: &ty::ctxt) -> String {\n+        fn upvar_to_string(upvar: &Upvar, is_copy: bool) -> String {\n+            if upvar.is_unboxed {\n+                let kind = match upvar.kind {\n+                    ty::FnUnboxedClosureKind => \"Fn\",\n+                    ty::FnMutUnboxedClosureKind => \"FnMut\",\n+                    ty::FnOnceUnboxedClosureKind => \"FnOnce\"\n+                };\n+                format!(\"captured outer variable in an `{}` closure\", kind)\n+            } else {\n+                (match (upvar.kind, is_copy) {\n+                    (ty::FnOnceUnboxedClosureKind, true) => \"captured outer variable in a proc\",\n+                    _ => \"captured outer variable\"\n+                }).to_string()\n+            }\n+        }\n+\n+        match self.cat {\n+            cat_static_item => {\n+                \"static item\".to_string()\n+            }\n+            cat_rvalue(..) => {\n+                \"non-lvalue\".to_string()\n+            }\n+            cat_local(vid) => {\n+                match tcx.map.find(vid) {\n+                    Some(ast_map::NodeArg(_)) => {\n+                        \"argument\".to_string()\n+                    }\n+                    _ => \"local variable\".to_string()\n+                }\n+            }\n+            cat_deref(_, _, pk) => {\n+                let upvar = self.upvar();\n+                match upvar.as_ref().map(|i| &i.cat) {\n+                    Some(&cat_upvar(ref var)) => {\n+                        upvar_to_string(var, false)\n+                    }\n+                    Some(_) => unreachable!(),\n+                    None => {\n+                        match pk {\n+                            Implicit(..) => {\n+                                \"dereference (dereference is implicit, due to indexing)\".to_string()\n+                            }\n+                            Unique => format!(\"dereference of `{}`\", ptr_sigil(pk)),\n+                            _ => format!(\"dereference of `{}`-pointer\", ptr_sigil(pk))\n+                        }\n+                    }\n+                }\n+            }\n+            cat_interior(_, InteriorField(NamedField(_))) => {\n+                \"field\".to_string()\n+            }\n+            cat_interior(_, InteriorField(PositionalField(_))) => {\n+                \"anonymous field\".to_string()\n+            }\n+            cat_interior(_, InteriorElement(VecElement)) => {\n+                \"vec content\".to_string()\n+            }\n+            cat_interior(_, InteriorElement(OtherElement)) => {\n+                \"indexed content\".to_string()\n+            }\n+            cat_upvar(ref var) => {\n+                upvar_to_string(var, true)\n+            }\n+            cat_downcast(ref cmt, _) => {\n+                cmt.descriptive_string(tcx)\n+            }\n+        }\n+    }\n }\n \n impl<'tcx> Repr<'tcx> for cmt_<'tcx> {"}, {"sha": "6a8b6d49cc0c562640ff8562bd71c5add05f7909", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -42,8 +42,8 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n \n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n-    let param_env = ty::empty_parameter_environment();\n-    let mut selcx = SelectionContext::intercrate(infcx, &param_env, infcx.tcx);\n+    let param_env = ty::empty_parameter_environment(infcx.tcx);\n+    let mut selcx = SelectionContext::intercrate(infcx, &param_env);\n     let obligation = Obligation::new(ObligationCause::dummy(),\n                                      ty::Binder(ty::TraitPredicate {\n                                          trait_ref: Rc::new(impl1_trait_ref),"}, {"sha": "e8a22e3d1d8f8963eddc57541c8dedd7308e2438", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -109,7 +109,6 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// `projection_ty` again.\n     pub fn normalize_projection_type<'a>(&mut self,\n                                          infcx: &InferCtxt<'a,'tcx>,\n-                                         param_env: &ty::ParameterEnvironment<'tcx>,\n                                          typer: &ty::UnboxedClosureTyper<'tcx>,\n                                          projection_ty: ty::ProjectionTy<'tcx>,\n                                          cause: ObligationCause<'tcx>)\n@@ -122,7 +121,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         // FIXME(#20304) -- cache\n \n-        let mut selcx = SelectionContext::new(infcx, param_env, typer);\n+        let mut selcx = SelectionContext::new(infcx, typer);\n         let normalized = project::normalize_projection_type(&mut selcx, projection_ty, cause, 0);\n \n         for obligation in normalized.obligations.into_iter() {\n@@ -186,11 +185,10 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n     pub fn select_all_or_error<'a>(&mut self,\n                                    infcx: &InferCtxt<'a,'tcx>,\n-                                   param_env: &ty::ParameterEnvironment<'tcx>,\n                                    typer: &ty::UnboxedClosureTyper<'tcx>)\n                                    -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n-        try!(self.select_where_possible(infcx, param_env, typer));\n+        try!(self.select_where_possible(infcx, typer));\n \n         // Anything left is ambiguous.\n         let errors: Vec<FulfillmentError> =\n@@ -212,21 +210,19 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// results in `O(n^2)` performance (#18208).\n     pub fn select_new_obligations<'a>(&mut self,\n                                       infcx: &InferCtxt<'a,'tcx>,\n-                                      param_env: &ty::ParameterEnvironment<'tcx>,\n                                       typer: &ty::UnboxedClosureTyper<'tcx>)\n                                       -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n-        let mut selcx = SelectionContext::new(infcx, param_env, typer);\n+        let mut selcx = SelectionContext::new(infcx, typer);\n         self.select(&mut selcx, true)\n     }\n \n     pub fn select_where_possible<'a>(&mut self,\n                                      infcx: &InferCtxt<'a,'tcx>,\n-                                     param_env: &ty::ParameterEnvironment<'tcx>,\n                                      typer: &ty::UnboxedClosureTyper<'tcx>)\n                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n-        let mut selcx = SelectionContext::new(infcx, param_env, typer);\n+        let mut selcx = SelectionContext::new(infcx, typer);\n         self.select(&mut selcx, false)\n     }\n "}, {"sha": "7da33babaeb6078f9597041f5ad4579694c636ee", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -46,7 +46,6 @@ use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    param_env: &'cx ty::ParameterEnvironment<'tcx>,\n     closure_typer: &'cx (ty::UnboxedClosureTyper<'tcx>+'cx),\n \n     /// Freshener used specifically for skolemizing entries on the\n@@ -181,25 +180,21 @@ enum EvaluationResult<'tcx> {\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-               param_env: &'cx ty::ParameterEnvironment<'tcx>,\n                closure_typer: &'cx ty::UnboxedClosureTyper<'tcx>)\n                -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n-            param_env: param_env,\n             closure_typer: closure_typer,\n             freshener: infcx.freshener(),\n             intercrate: false,\n         }\n     }\n \n     pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-                      param_env: &'cx ty::ParameterEnvironment<'tcx>,\n                       closure_typer: &'cx ty::UnboxedClosureTyper<'tcx>)\n                       -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n-            param_env: param_env,\n             closure_typer: closure_typer,\n             freshener: infcx.freshener(),\n             intercrate: true,\n@@ -210,14 +205,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn param_env(&self) -> &'cx ty::ParameterEnvironment<'tcx> {\n-        self.param_env\n-    }\n-\n     pub fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n \n+    pub fn param_env(&self) -> &'cx ty::ParameterEnvironment<'cx, 'tcx> {\n+        self.closure_typer.param_env()\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -650,7 +645,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // it's not worth going to more trouble to increase the\n         // hit-rate I don't think.\n         if self.intercrate {\n-            return &self.param_env.selection_cache;\n+            return &self.param_env().selection_cache;\n         }\n \n         // If the trait refers to any parameters in scope, then use\n@@ -659,7 +654,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             cache_fresh_trait_pred.0.input_types().iter().any(\n                 |&t| ty::type_has_self(t) || ty::type_has_params(t))\n         {\n-            return &self.param_env.selection_cache;\n+            return &self.param_env().selection_cache;\n         }\n \n         // If the trait refers to unbound type variables, and there\n@@ -668,11 +663,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // common case, then we can use the global environment.\n         // See the discussion in doc.rs for more details.\n         if\n-            !self.param_env.caller_bounds.is_empty() &&\n+            !self.param_env().caller_bounds.is_empty() &&\n             cache_fresh_trait_pred.0.input_types().iter().any(\n                 |&t| ty::type_has_ty_infer(t))\n         {\n-            return &self.param_env.selection_cache;\n+            return &self.param_env().selection_cache;\n         }\n \n         // Otherwise, we can use the global cache.\n@@ -902,7 +897,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation.repr(self.tcx()));\n \n         let caller_trait_refs: Vec<_> =\n-            self.param_env.caller_bounds.predicates.iter()\n+            self.param_env().caller_bounds.predicates.iter()\n             .filter_map(|o| o.to_opt_poly_trait_ref())\n             .collect();\n "}, {"sha": "c720032bef264956c579f1d08f975759cc2464ce", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 81, "deletions": 42, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -2058,7 +2058,9 @@ impl<'tcx> TraitRef<'tcx> {\n /// future I hope to refine the representation of types so as to make\n /// more distinctions clearer.\n #[deriving(Clone)]\n-pub struct ParameterEnvironment<'tcx> {\n+pub struct ParameterEnvironment<'a, 'tcx:'a> {\n+    pub tcx: &'a ctxt<'tcx>,\n+\n     /// A substitution that can be applied to move from\n     /// the \"outer\" view of a type or method to the \"inner\" view.\n     /// In general, this means converting from bound parameters to\n@@ -2082,8 +2084,8 @@ pub struct ParameterEnvironment<'tcx> {\n     pub selection_cache: traits::SelectionCache<'tcx>,\n }\n \n-impl<'tcx> ParameterEnvironment<'tcx> {\n-    pub fn for_item(cx: &ctxt<'tcx>, id: NodeId) -> ParameterEnvironment<'tcx> {\n+impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n+    pub fn for_item(cx: &'a ctxt<'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match **impl_item {\n@@ -2272,6 +2274,8 @@ impl UnboxedClosureKind {\n }\n \n pub trait UnboxedClosureTyper<'tcx> {\n+    fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx>;\n+\n     fn unboxed_closure_kind(&self,\n                             def_id: ast::DefId)\n                             -> ty::UnboxedClosureKind;\n@@ -2424,6 +2428,21 @@ impl<'tcx> ctxt<'tcx> {\n         self.region_interner.borrow_mut().insert(region, region);\n         region\n     }\n+\n+    pub fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        self.unboxed_closures.borrow()[def_id].kind\n+    }\n+\n+    pub fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        self.unboxed_closures.borrow()[def_id].closure_type.subst(self, substs)\n+    }\n }\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n@@ -3377,7 +3396,8 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             ty_unboxed_closure(did, r, substs) => {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut`\n                 // unboxed closure.\n-                let upvars = unboxed_closure_upvars(cx, did, substs).unwrap();\n+                let param_env = ty::empty_parameter_environment(cx);\n+                let upvars = unboxed_closure_upvars(&param_env, did, substs).unwrap();\n                 TypeContents::union(upvars.as_slice(),\n                                     |f| tc_ty(cx, f.ty, cache))\n                     | borrowed_contents(*r, MutMutable)\n@@ -3526,12 +3546,12 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n     }\n }\n \n-fn type_impls_bound<'tcx>(cx: &ctxt<'tcx>,\n-                          cache: &RefCell<HashMap<Ty<'tcx>,bool>>,\n-                          param_env: &ParameterEnvironment<'tcx>,\n-                          ty: Ty<'tcx>,\n-                          bound: ty::BuiltinBound)\n-                          -> bool\n+fn type_impls_bound<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n+                             cache: &RefCell<HashMap<Ty<'tcx>,bool>>,\n+                             ty: Ty<'tcx>,\n+                             bound: ty::BuiltinBound,\n+                             span: Span)\n+                             -> bool\n {\n     assert!(!ty::type_needs_infer(ty));\n \n@@ -3540,7 +3560,7 @@ fn type_impls_bound<'tcx>(cx: &ctxt<'tcx>,\n             None => {}\n             Some(&result) => {\n                 debug!(\"type_impls_bound({}, {}) = {} (cached)\",\n-                       ty_to_string(cx, ty),\n+                       ty.repr(param_env.tcx),\n                        bound,\n                        result);\n                 return result\n@@ -3625,8 +3645,6 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             ty_str |\n             ty_bare_fn(..) |\n             ty_closure(_) |\n-            ty_infer(_) |\n-            ty_err |\n             ty_param(_) |\n             ty_projection(_) |\n             ty_vec(_, None) => {\n@@ -3659,9 +3677,12 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n                 r\n             }\n \n-            ty_unboxed_closure(did, _, substs) => {\n-                let upvars = unboxed_closure_upvars(cx, did, substs).unwrap();\n-                upvars.iter().any(|f| type_requires(cx, seen, r_ty, f.ty))\n+            ty_err |\n+            ty_infer(_) |\n+            ty_unboxed_closure(..) => {\n+                // this check is run on type definitions, so we don't expect to see\n+                // inference by-products or unboxed closure types\n+                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {}\", ty)[])\n             }\n \n             ty_tup(ref ts) => {\n@@ -3751,9 +3772,10 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n \n                 find_nonrepresentable(cx, sp, seen, iter)\n             }\n-            ty_unboxed_closure(did, _, substs) => {\n-                let upvars = unboxed_closure_upvars(cx, did, substs).unwrap();\n-                find_nonrepresentable(cx, sp, seen, upvars.iter().map(|f| f.ty))\n+            ty_unboxed_closure(..) => {\n+                // this check is run on type definitions, so we don't expect to see\n+                // unboxed closure types\n+                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {}\", ty)[])\n             }\n             _ => Representable,\n         }\n@@ -6377,19 +6399,20 @@ impl Variance {\n \n /// Construct a parameter environment suitable for static contexts or other contexts where there\n /// are no free type/lifetime parameters in scope.\n-pub fn empty_parameter_environment<'tcx>() -> ParameterEnvironment<'tcx> {\n-    ty::ParameterEnvironment { free_substs: Substs::empty(),\n+pub fn empty_parameter_environment<'a,'tcx>(cx: &'a ctxt<'tcx>) -> ParameterEnvironment<'a,'tcx> {\n+    ty::ParameterEnvironment { tcx: cx,\n+                               free_substs: Substs::empty(),\n                                caller_bounds: GenericBounds::empty(),\n                                implicit_region_bound: ty::ReEmpty,\n                                selection_cache: traits::SelectionCache::new(), }\n }\n \n /// See `ParameterEnvironment` struct def'n for details\n-pub fn construct_parameter_environment<'tcx>(\n-    tcx: &ctxt<'tcx>,\n+pub fn construct_parameter_environment<'a,'tcx>(\n+    tcx: &'a ctxt<'tcx>,\n     generics: &ty::Generics<'tcx>,\n     free_id: ast::NodeId)\n-    -> ParameterEnvironment<'tcx>\n+    -> ParameterEnvironment<'a, 'tcx>\n {\n \n     //\n@@ -6432,6 +6455,7 @@ pub fn construct_parameter_environment<'tcx>(\n            bounds.repr(tcx));\n \n     return ty::ParameterEnvironment {\n+        tcx: tcx,\n         free_substs: free_substs,\n         implicit_region_bound: ty::ReScope(free_id_scope),\n         caller_bounds: bounds,\n@@ -6522,69 +6546,84 @@ impl BorrowKind {\n     }\n }\n \n-impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-        self\n+impl<'tcx> ctxt<'tcx> {\n+    pub fn capture_mode(&self, closure_expr_id: ast::NodeId)\n+                    -> ast::CaptureClause {\n+        self.capture_modes.borrow()[closure_expr_id].clone()\n+    }\n+\n+    pub fn is_method_call(&self, expr_id: ast::NodeId) -> bool {\n+        self.method_map.borrow().contains_key(&MethodCall::expr(expr_id))\n     }\n+}\n \n-    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        ty::node_id_to_type(self, id)\n+impl<'a,'tcx> mc::Typer<'tcx> for ParameterEnvironment<'a,'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.tcx\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n-        ty::expr_ty_adjusted(self, expr)\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n+        Ok(ty::node_id_to_type(self.tcx, id))\n+    }\n+\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n+        Ok(ty::expr_ty_adjusted(self.tcx, expr))\n     }\n \n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n-        self.method_map.borrow().get(&method_call).map(|method| method.ty)\n+        self.tcx.method_map.borrow().get(&method_call).map(|method| method.ty)\n     }\n \n     fn node_method_origin(&self, method_call: ty::MethodCall)\n                           -> Option<ty::MethodOrigin<'tcx>>\n     {\n-        self.method_map.borrow().get(&method_call).map(|method| method.origin.clone())\n+        self.tcx.method_map.borrow().get(&method_call).map(|method| method.origin.clone())\n     }\n \n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        &self.adjustments\n+    fn adjustments(&self) -> &RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        &self.tcx.adjustments\n     }\n \n     fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.method_map.borrow().contains_key(&MethodCall::expr(id))\n+        self.tcx.is_method_call(id)\n     }\n \n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n-        self.region_maps.temporary_scope(rvalue_id)\n+        self.tcx.region_maps.temporary_scope(rvalue_id)\n     }\n \n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n-        Some(self.upvar_borrow_map.borrow()[upvar_id].clone())\n+        Some(self.tcx.upvar_borrow_map.borrow()[upvar_id].clone())\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n-        self.capture_modes.borrow()[closure_expr_id].clone()\n+        self.tcx.capture_mode(closure_expr_id)\n     }\n \n     fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n         type_moves_by_default(self, span, ty)\n     }\n }\n \n-impl<'tcx> UnboxedClosureTyper<'tcx> for ty::ctxt<'tcx> {\n+impl<'a,'tcx> UnboxedClosureTyper<'tcx> for ty::ParameterEnvironment<'a,'tcx> {\n+    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+        self\n+    }\n+\n     fn unboxed_closure_kind(&self,\n                             def_id: ast::DefId)\n                             -> ty::UnboxedClosureKind\n     {\n-        self.unboxed_closures.borrow()[def_id].kind\n+        self.tcx.unboxed_closure_kind(def_id)\n     }\n \n     fn unboxed_closure_type(&self,\n                             def_id: ast::DefId,\n                             substs: &subst::Substs<'tcx>)\n                             -> ty::ClosureTy<'tcx>\n     {\n-        self.unboxed_closures.borrow()[def_id].closure_type.subst(self, substs)\n+        self.tcx.unboxed_closure_type(def_id, substs)\n     }\n \n     fn unboxed_closure_upvars(&self,"}, {"sha": "17a3f4a88e5c080801f7ee23def2f2d4186eb5c3", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -87,7 +87,7 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n     move_data: move_data::FlowedMoveData<'a, 'tcx>,\n     all_loans: &'a [Loan<'tcx>],\n-    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n@@ -208,9 +208,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     {\n-        let mut euv = euv::ExprUseVisitor::new(&mut clcx,\n-                                               bccx.tcx,\n-                                               &param_env);\n+        let mut euv = euv::ExprUseVisitor::new(&mut clcx, &param_env);\n         euv.walk_fn(decl, body);\n     }\n }"}, {"sha": "1e9e5b22aa0ed85ac85865537b16111e6c49946a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -51,9 +51,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n \n     {\n-        let mut euv = euv::ExprUseVisitor::new(&mut glcx,\n-                                               bccx.tcx,\n-                                               &param_env);\n+        let mut euv = euv::ExprUseVisitor::new(&mut glcx, &param_env);\n         euv.walk_fn(decl, body);\n     }\n \n@@ -485,13 +483,15 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n /// This visitor walks static initializer's expressions and makes\n /// sure the loans being taken are sound.\n struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         if let ast::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let base_cmt = self.bccx.cat_expr(&**base);\n+            let param_env = ty::empty_parameter_environment(self.bccx.tcx);\n+            let mc = mc::MemCategorizationContext::new(&param_env);\n+            let base_cmt = mc.cat_expr(&**base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n             // Check that we don't allow borrows of unsafe static items.\n             if check_aliasability(self.bccx, ex.span, euv::AddrOf,"}, {"sha": "d81974d1ae038441ef8191004d0de33f4876d97d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -511,28 +511,20 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n \n-    pub fn mc(&self) -> mc::MemCategorizationContext<'a, ty::ctxt<'tcx>> {\n-        mc::MemCategorizationContext::new(self.tcx)\n-    }\n-\n-    pub fn cat_expr(&self, expr: &ast::Expr) -> mc::cmt<'tcx> {\n-        self.mc().cat_expr(expr)\n-    }\n-\n     pub fn report(&self, err: BckError<'tcx>) {\n         self.span_err(\n             err.span,\n             self.bckerr_to_string(&err)[]);\n         self.note_and_explain_bckerr(err);\n     }\n \n-    pub fn report_use_of_moved_value(&self,\n-                                     use_span: Span,\n-                                     use_kind: MovedValueUseKind,\n-                                     lp: &LoanPath<'tcx>,\n-                                     the_move: &move_data::Move,\n-                                     moved_lp: &LoanPath<'tcx>,\n-                                     param_env: &ty::ParameterEnvironment<'tcx>) {\n+    pub fn report_use_of_moved_value<'b>(&self,\n+                                         use_span: Span,\n+                                         use_kind: MovedValueUseKind,\n+                                         lp: &LoanPath<'tcx>,\n+                                         the_move: &move_data::Move,\n+                                         moved_lp: &LoanPath<'tcx>,\n+                                         param_env: &ty::ParameterEnvironment<'b,'tcx>) {\n         let verb = match use_kind {\n             MovedInUse => \"use\",\n             MovedInCapture => \"capture\",\n@@ -608,8 +600,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                   r)[])\n                     }\n                 };\n-                let (suggestion, _) = move_suggestion(self.tcx, param_env, expr_ty,\n-                        (\"moved by default\", \"\"));\n+                let (suggestion, _) =\n+                    move_suggestion(param_env, expr_span, expr_ty, (\"moved by default\", \"\"));\n                 self.tcx.sess.span_note(\n                     expr_span,\n                     format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n@@ -646,11 +638,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                   r)[])\n                     }\n                 };\n-                let (suggestion, help) = move_suggestion(self.tcx,\n-                                                         param_env,\n-                                                         expr_ty,\n-                        (\"moved by default\", \"make a copy and \\\n-                         capture that instead to override\"));\n+                let (suggestion, help) =\n+                    move_suggestion(param_env,\n+                                    expr_span,\n+                                    expr_ty,\n+                                    (\"moved by default\",\n+                                     \"make a copy and capture that instead to override\"));\n                 self.tcx.sess.span_note(\n                     expr_span,\n                     format!(\"`{}` moved into closure environment here{} because it \\\n@@ -663,22 +656,27 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn move_suggestion<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 param_env: &ty::ParameterEnvironment<'tcx>,\n-                                 ty: Ty<'tcx>,\n-                                 default_msgs: (&'static str, &'static str))\n-                                 -> (&'static str, &'static str) {\n+        fn move_suggestion<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx>,\n+                                    span: Span,\n+                                    ty: Ty<'tcx>,\n+                                    default_msgs: (&'static str, &'static str))\n+                                    -> (&'static str, &'static str) {\n             match ty.sty {\n                 ty::ty_closure(box ty::ClosureTy {\n-                        store: ty::RegionTraitStore(..),\n-                        ..\n-                    }) =>\n+                    store: ty::RegionTraitStore(..),\n+                    ..\n+                }) => {\n                     (\"a non-copyable stack closure\",\n-                     \"capture it in a new closure, e.g. `|x| f(x)`, to override\"),\n-                _ if ty::type_moves_by_default(tcx, ty, param_env) =>\n-                    (\"non-copyable\",\n-                     \"perhaps you meant to use `clone()`?\"),\n-                _ => default_msgs,\n+                     \"capture it in a new closure, e.g. `|x| f(x)`, to override\")\n+                }\n+                _ => {\n+                    if ty::type_moves_by_default(param_env, span, ty) {\n+                        (\"non-copyable\",\n+                         \"perhaps you meant to use `clone()`?\")\n+                    } else {\n+                        default_msgs\n+                    }\n+                }\n             }\n         }\n     }\n@@ -991,7 +989,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     pub fn cmt_to_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n-        self.mc().cmt_to_string(cmt)\n+        cmt.descriptive_string(self.tcx)\n     }\n }\n "}, {"sha": "19781a51d578b759353ad522c84ad9b469eb5768", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -542,7 +542,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n             check_match::Constructor::Variant(def_id)\n     };\n \n-    let param_env = ty::empty_parameter_environment();\n+    let param_env = ty::empty_parameter_environment(bcx.tcx());\n     let mcx = check_match::MatchCheckCtxt {\n         tcx: bcx.tcx(),\n         param_env: param_env,\n@@ -1008,7 +1008,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let mcx = check_match::MatchCheckCtxt {\n         tcx: bcx.tcx(),\n-        param_env: ty::empty_parameter_environment(),\n+        param_env: ty::empty_parameter_environment(bcx.tcx()),\n     };\n     let adt_vals = if any_irrefutable_adt_pat(bcx.tcx(), m, col) {\n         let repr = adt::represent_type(bcx.ccx(), left_ty);\n@@ -1262,8 +1262,7 @@ fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool\n         reassigned: false\n     };\n     {\n-        let param_env = ty::empty_parameter_environment();\n-        let mut visitor = euv::ExprUseVisitor::new(&mut rc, bcx, &param_env);\n+        let mut visitor = euv::ExprUseVisitor::new(&mut rc, bcx);\n         visitor.walk_expr(body);\n     }\n     rc.reassigned\n@@ -1321,7 +1320,7 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n         let tcx = bcx.tcx();\n-        let param_env = ty::empty_parameter_environment();\n+        let param_env = ty::empty_parameter_environment(tcx);\n \n         let llmatch;\n         let trmode;"}, {"sha": "85a7ec330695064f33a966264d58bcf8f33e0dd9", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -61,7 +61,7 @@ use trans::datum;\n use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, Ty, UnboxedClosureTyper};\n use middle::ty::Disr;\n use syntax::ast;\n use syntax::attr;\n@@ -168,7 +168,8 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             Univariant(mk_struct(cx, ftys[], packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _, substs) => {\n-            let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs).unwrap();\n+            let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n+            let upvars = typer.unboxed_closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n             Univariant(mk_struct(cx, upvar_types[], false, t), false)\n         }"}, {"sha": "4c29467d93a44f9dfe337c57a75ffafe4669b64b", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -731,7 +731,8 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n       }\n       ty::ty_unboxed_closure(def_id, _, substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs).unwrap();\n+          let typer = common::NormalizingUnboxedClosureTyper::new(cx.tcx());\n+          let upvars = typer.unboxed_closure_upvars(def_id, substs).unwrap();\n           for (i, upvar) in upvars.iter().enumerate() {\n               let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llupvar, upvar.ty);\n@@ -1451,6 +1452,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n           llfn: llfndecl,\n           llenv: None,\n           llretslotptr: Cell::new(None),\n+          param_env: ty::empty_parameter_environment(ccx.tcx()),\n           alloca_insert_pt: Cell::new(None),\n           llreturn: Cell::new(None),\n           needs_ret_allocas: nested_returns,"}, {"sha": "6efdcc2f0fa0ff61de6bcfa44b574a469823bc06", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -302,6 +302,9 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // section of the executable we're generating.\n     pub llfn: ValueRef,\n \n+    // always an empty parameter-environment\n+    pub param_env: ty::ParameterEnvironment<'a, 'tcx>,\n+\n     // The environment argument in a closure.\n     pub llenv: Option<ValueRef>,\n \n@@ -579,12 +582,12 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx()\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        node_id_type(self, id)\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n+        Ok(node_id_type(self, id))\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n-        expr_ty_adjusted(self, expr)\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n+        Ok(expr_ty_adjusted(self, expr))\n     }\n \n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n@@ -627,11 +630,15 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n \n     fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n-        self.param_env().type_moves_by_default(span, ty)\n+        self.fcx.param_env.type_moves_by_default(span, ty)\n     }\n }\n \n impl<'blk, 'tcx> ty::UnboxedClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n+    fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx> {\n+        &self.fcx.param_env\n+    }\n+\n     fn unboxed_closure_kind(&self,\n                             def_id: ast::DefId)\n                             -> ty::UnboxedClosureKind\n@@ -945,14 +952,10 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);\n \n-    // Parameter environment is used to give details about type parameters,\n-    // but since we are in trans, everything is fully monomorphized.\n-    let param_env = ty::empty_parameter_environment();\n-\n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n-    let mut selcx = traits::SelectionContext::new(&infcx, &param_env, &typer);\n+    let typer = NormalizingUnboxedClosureTyper::new(tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                              trait_ref.to_poly_trait_predicate());\n     let selection = match selcx.select(&obligation) {\n@@ -987,7 +990,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let vtable = selection.map_move_nested(|predicate| {\n         fulfill_cx.register_predicate_obligation(&infcx, predicate);\n     });\n-    let vtable = drain_fulfillment_cx(span, &infcx, &param_env, &mut fulfill_cx, &vtable);\n+    let vtable = drain_fulfillment_cx(span, &infcx, &mut fulfill_cx, &vtable);\n \n     info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n     ccx.trait_cache().borrow_mut().insert(trait_ref,\n@@ -997,21 +1000,27 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub struct NormalizingUnboxedClosureTyper<'a,'tcx:'a> {\n-    tcx: &'a ty::ctxt<'tcx>\n+    param_env: ty::ParameterEnvironment<'a, 'tcx>\n }\n \n impl<'a,'tcx> NormalizingUnboxedClosureTyper<'a,'tcx> {\n     pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingUnboxedClosureTyper<'a,'tcx> {\n-        NormalizingUnboxedClosureTyper { tcx: tcx }\n+        // Parameter environment is used to give details about type parameters,\n+        // but since we are in trans, everything is fully monomorphized.\n+        NormalizingUnboxedClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n     }\n }\n \n impl<'a,'tcx> ty::UnboxedClosureTyper<'tcx> for NormalizingUnboxedClosureTyper<'a,'tcx> {\n+    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+        &self.param_env\n+    }\n+\n     fn unboxed_closure_kind(&self,\n                             def_id: ast::DefId)\n                             -> ty::UnboxedClosureKind\n     {\n-        self.tcx.unboxed_closure_kind(def_id)\n+        self.param_env.tcx.unboxed_closure_kind(def_id)\n     }\n \n     fn unboxed_closure_type(&self,\n@@ -1021,8 +1030,8 @@ impl<'a,'tcx> ty::UnboxedClosureTyper<'tcx> for NormalizingUnboxedClosureTyper<'\n     {\n         // the substitutions in `substs` are already monomorphized,\n         // but we still must normalize associated types\n-        let closure_ty = self.tcx.unboxed_closure_type(def_id, substs);\n-        monomorphize::normalize_associated_type(self.tcx, &closure_ty)\n+        let closure_ty = self.param_env.tcx.unboxed_closure_type(def_id, substs);\n+        monomorphize::normalize_associated_type(self.param_env.tcx, &closure_ty)\n     }\n \n     fn unboxed_closure_upvars(&self,\n@@ -1032,14 +1041,13 @@ impl<'a,'tcx> ty::UnboxedClosureTyper<'tcx> for NormalizingUnboxedClosureTyper<'\n     {\n         // the substitutions in `substs` are already monomorphized,\n         // but we still must normalize associated types\n-        let result = ty::unboxed_closure_upvars(self.tcx, def_id, substs);\n-        monomorphize::normalize_associated_type(self.tcx, &result)\n+        let result = ty::unboxed_closure_upvars(&self.param_env, def_id, substs);\n+        monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n     }\n }\n \n pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n                                        infcx: &infer::InferCtxt<'a,'tcx>,\n-                                       param_env: &ty::ParameterEnvironment<'tcx>,\n                                        fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                        result: &T)\n                                        -> T\n@@ -1052,7 +1060,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n     // contains unbound type parameters. It could be a slight\n     // optimization to stop iterating early.\n     let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n-    match fulfill_cx.select_all_or_error(infcx, param_env, &typer) {\n+    match fulfill_cx.select_all_or_error(infcx, &typer) {\n         Ok(()) => { }\n         Err(errors) => {\n             if errors.iter().all(|e| e.is_overflow()) {"}, {"sha": "72074040a2c678fc37c719911f1febbebf4374de", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -28,6 +28,7 @@ use util::ppaux::{ty_to_string};\n \n use std::fmt;\n use syntax::ast;\n+use syntax::codemap::DUMMY_SP;\n \n /// A `Datum` encapsulates the result of evaluating an expression.  It\n /// describes where the value is stored, what Rust type the value has,"}, {"sha": "cc259e6765c34f2180030d2a1225d830168b03a9", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -322,9 +322,8 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     // FIXME(#20304) -- cache\n \n     let infcx = infer::new_infer_ctxt(tcx);\n-    let param_env = ty::empty_parameter_environment();\n-    let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n-    let mut selcx = traits::SelectionContext::new(&infcx, &param_env, &typer);\n+    let typer = NormalizingUnboxedClosureTyper::new(tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: result, obligations } =\n         traits::normalize(&mut selcx, cause, value);\n@@ -337,7 +336,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     for obligation in obligations.into_iter() {\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n-    let result = drain_fulfillment_cx(DUMMY_SP, &infcx, &param_env, &mut fulfill_cx, &result);\n+    let result = drain_fulfillment_cx(DUMMY_SP, &infcx, &mut fulfill_cx, &result);\n \n     result\n }"}, {"sha": "6950850e5f3c140d95306d34f159aafe8ac1c9fa", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -18,7 +18,6 @@ use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                                                param_env: &ty::ParameterEnvironment<'tcx>,\n                                                 typer: &(ty::UnboxedClosureTyper<'tcx>+'a),\n                                                 fulfillment_cx: &mut FulfillmentContext<'tcx>,\n                                                 span: Span,\n@@ -28,7 +27,7 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n {\n     debug!(\"normalize_associated_types_in(value={})\", value.repr(infcx.tcx));\n-    let mut selcx = SelectionContext::new(infcx, param_env, typer);\n+    let mut selcx = SelectionContext::new(infcx, typer);\n     let cause = ObligationCause::new(span, body_id, MiscObligation);\n     let Normalized { value: result, obligations } = traits::normalize(&mut selcx, cause, value);\n     debug!(\"normalize_associated_types_in: result={} predicates={}\","}, {"sha": "92b8c2bbcf718152acf80d06b5256cb683bcf355", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -169,9 +169,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                               poly_trait_ref.as_predicate());\n \n     // Now we want to know if this can be matched\n-    let mut selcx = traits::SelectionContext::new(fcx.infcx(),\n-                                                  &fcx.inh.param_env,\n-                                                  fcx);\n+    let mut selcx = traits::SelectionContext::new(fcx.infcx(), fcx);\n     if !selcx.evaluate_obligation(&obligation) {\n         debug!(\"--> Cannot match obligation\");\n         return None; // Cannot be matched, no such method resolution is possible."}, {"sha": "cd97d89b2465a668dcf7bb1de19088d860e0b2e1", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -788,9 +788,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     debug!(\"impl_obligations={}\", obligations.repr(self.tcx()));\n \n                     // Evaluate those obligations to see if they might possibly hold.\n-                    let mut selcx = traits::SelectionContext::new(self.infcx(),\n-                                                                  &self.fcx.inh.param_env,\n-                                                                  self.fcx);\n+                    let mut selcx = traits::SelectionContext::new(self.infcx(), self.fcx);\n                     obligations.all(|o| selcx.evaluate_obligation(o))\n                 }\n "}, {"sha": "ed4c55cea5db366026db2279587cc26540890396", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -87,6 +87,7 @@ use middle::{const_eval, def};\n use middle::infer;\n use middle::lang_items::IteratorItem;\n use middle::mem_categorization as mc;\n+use middle::mem_categorization::McResult;\n use middle::pat_util::{mod, pat_id_map};\n use middle::region::CodeExtent;\n use middle::subst::{mod, Subst, Substs, VecPerParamSpace, ParamSpace};\n@@ -146,7 +147,7 @@ mod callee;\n pub struct Inherited<'a, 'tcx: 'a> {\n     infcx: infer::InferCtxt<'a, 'tcx>,\n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n-    param_env: ty::ParameterEnvironment<'tcx>,\n+    param_env: ty::ParameterEnvironment<'a, 'tcx>,\n \n     // Temporary tables:\n     node_types: RefCell<NodeMap<Ty<'tcx>>>,\n@@ -288,7 +289,6 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n-    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n         let ty = self.node_ty(id);\n         self.resolve_type_vars_or_error(&ty)\n@@ -322,7 +322,7 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         self.inh.method_map.borrow().contains_key(&ty::MethodCall::expr(id))\n     }\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n-        self.tcx().temporary_scope(rvalue_id)\n+        self.param_env().temporary_scope(rvalue_id)\n     }\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n         self.inh.upvar_borrow_map.borrow().get(&upvar_id).cloned()\n@@ -334,6 +334,10 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ty::UnboxedClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n+    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+        &self.inh.param_env\n+    }\n+\n     fn unboxed_closure_kind(&self,\n                             def_id: ast::DefId)\n                             -> ty::UnboxedClosureKind\n@@ -360,7 +364,7 @@ impl<'a, 'tcx> ty::UnboxedClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n-           param_env: ty::ParameterEnvironment<'tcx>)\n+           param_env: ty::ParameterEnvironment<'a, 'tcx>)\n            -> Inherited<'a, 'tcx> {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n@@ -388,7 +392,6 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n     {\n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n         assoc::normalize_associated_types_in(&self.infcx,\n-                                             &self.param_env,\n                                              typer,\n                                              &mut *fulfillment_cx, span,\n                                              body_id,\n@@ -418,7 +421,7 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n                                     -> Inherited<'a, 'tcx> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n-    let param_env = ty::empty_parameter_environment();\n+    let param_env = ty::empty_parameter_environment(ccx.tcx);\n     Inherited::new(ccx.tcx, param_env)\n }\n \n@@ -462,7 +465,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            body: &ast::Block,\n                            id: ast::NodeId,\n                            raw_fty: Ty<'tcx>,\n-                           param_env: ty::ParameterEnvironment<'tcx>) {\n+                           param_env: ty::ParameterEnvironment<'a, 'tcx>) {\n     match raw_fty.sty {\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n@@ -473,7 +476,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let fn_sig =\n                 liberate_late_bound_regions(ccx.tcx, CodeExtent::from_node_id(body.id), &fn_sig);\n             let fn_sig =\n-                inh.normalize_associated_types_in(ccx.tcx, body.span, body.id, &fn_sig);\n+                inh.normalize_associated_types_in(&inh.param_env, body.span, body.id, &fn_sig);\n \n             let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_sig,\n                                decl, id, body, &inh);\n@@ -1225,7 +1228,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let impl_sig =\n             assoc::normalize_associated_types_in(&infcx,\n                                                  &impl_param_env,\n-                                                 infcx.tcx,\n                                                  &mut fulfillment_cx,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n@@ -1246,7 +1248,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let trait_sig =\n             assoc::normalize_associated_types_in(&infcx,\n                                                  &impl_param_env,\n-                                                 infcx.tcx,\n                                                  &mut fulfillment_cx,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n@@ -1282,7 +1283,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // Run the fulfillment context to completion to accommodate any\n     // associated type normalizations that may have occurred.\n-    match fulfillment_cx.select_all_or_error(&infcx, &impl_param_env, tcx) {\n+    match fulfillment_cx.select_all_or_error(&infcx, &impl_param_env) {\n         Ok(()) => { }\n         Err(errors) => {\n             traits::report_fulfillment_errors(&infcx, &errors);\n@@ -1660,11 +1661,11 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    pub fn infcx(&self) -> &infer::InferCtxt<'a, 'tcx> {\n+    pub fn infcx(&self) -> &infer::InferCtxt<'a,'tcx> {\n         &self.inh.infcx\n     }\n \n-    pub fn param_env(&self) -> &ty::ParameterEnvironment<'tcx> {\n+    pub fn param_env(&self) -> &ty::ParameterEnvironment<'a,'tcx> {\n         &self.inh.param_env\n     }\n \n@@ -1835,7 +1836,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.inh.fulfillment_cx\n             .borrow_mut()\n             .normalize_projection_type(self.infcx(),\n-                                       &self.inh.param_env,\n                                        self,\n                                        ty::ProjectionTy {\n                                            trait_ref: trait_ref,"}, {"sha": "8566d1f1e12b97e3b773cf0df57dde3e153cf01e", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7474be066022d2cd0b0695a466651570c00f3700/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=7474be066022d2cd0b0695a466651570c00f3700", "patch": "@@ -287,9 +287,7 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     fcx.default_type_parameters();\n \n     let mut fulfillment_cx = fcx.inh.fulfillment_cx.borrow_mut();\n-    let r = fulfillment_cx.select_all_or_error(fcx.infcx(),\n-                                               &fcx.inh.param_env,\n-                                               fcx);\n+    let r = fulfillment_cx.select_all_or_error(fcx.infcx(), fcx);\n     match r {\n         Ok(()) => { }\n         Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n@@ -302,7 +300,7 @@ pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt)\n     match\n         fcx.inh.fulfillment_cx\n         .borrow_mut()\n-        .select_where_possible(fcx.infcx(), &fcx.inh.param_env, fcx)\n+        .select_where_possible(fcx.infcx(), fcx)\n     {\n         Ok(()) => { }\n         Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n@@ -316,7 +314,7 @@ pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n     match\n         fcx.inh.fulfillment_cx\n         .borrow_mut()\n-        .select_new_obligations(fcx.infcx(), &fcx.inh.param_env, fcx)\n+        .select_new_obligations(fcx.infcx(), fcx)\n     {\n         Ok(()) => { }\n         Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }"}]}