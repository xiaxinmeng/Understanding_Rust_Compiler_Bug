{"sha": "9cd3f1c54956e5b306567161d1965277c9ef8455", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljZDNmMWM1NDk1NmU1YjMwNjU2NzE2MWQxOTY1Mjc3YzllZjg0NTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-29T04:05:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-29T04:05:03Z"}, "message": "Auto merge of #72506 - Nadrieril:fix-72476, r=matthewjasper\n\nExhaustiveness checking: work around type normalization issues\n\nThis should resolve https://github.com/rust-lang/rust/issues/72476 and probably https://github.com/rust-lang/rust/issues/72467.\nThis is a bit hacky but that's actually what the code was doing before https://github.com/rust-lang/rust/pull/71930. I'm essentially reverting https://github.com/rust-lang/rust/commit/e5a2cd526a6ad92b90dda81104abc7adf4c83495. So despite being hacky, it's been tried and tested (so much so that code relies on it now x)).\nOnly the third commit does anything interesting.", "tree": {"sha": "116359d49d97fa5263a49fa6d37f26eb21515c57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/116359d49d97fa5263a49fa6d37f26eb21515c57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cd3f1c54956e5b306567161d1965277c9ef8455", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cd3f1c54956e5b306567161d1965277c9ef8455", "html_url": "https://github.com/rust-lang/rust/commit/9cd3f1c54956e5b306567161d1965277c9ef8455", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cd3f1c54956e5b306567161d1965277c9ef8455/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "255c0338dc0b02f833fb1a816d76febd50c399c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/255c0338dc0b02f833fb1a816d76febd50c399c4", "html_url": "https://github.com/rust-lang/rust/commit/255c0338dc0b02f833fb1a816d76febd50c399c4"}, {"sha": "3e8ba3a3cbf5d25352f95d93867a9fcda7d33e91", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e8ba3a3cbf5d25352f95d93867a9fcda7d33e91", "html_url": "https://github.com/rust-lang/rust/commit/3e8ba3a3cbf5d25352f95d93867a9fcda7d33e91"}], "stats": {"total": 71, "additions": 52, "deletions": 19}, "files": [{"sha": "575ddcef9971581a982e4118022b44583b4823f9", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9cd3f1c54956e5b306567161d1965277c9ef8455/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cd3f1c54956e5b306567161d1965277c9ef8455/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=9cd3f1c54956e5b306567161d1965277c9ef8455", "patch": "@@ -1025,11 +1025,11 @@ enum Fields<'p, 'tcx> {\n     /// have not measured if it really made a difference.\n     Slice(&'p [Pat<'tcx>]),\n     Vec(SmallVec<[&'p Pat<'tcx>; 2]>),\n-    /// Patterns where some of the fields need to be hidden. `len` caches the number of non-hidden\n-    /// fields.\n+    /// Patterns where some of the fields need to be hidden. `kept_count` caches the number of\n+    /// non-hidden fields.\n     Filtered {\n         fields: SmallVec<[FilteredField<'p, 'tcx>; 2]>,\n-        len: usize,\n+        kept_count: usize,\n     },\n }\n \n@@ -1066,10 +1066,9 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         constructor: &Constructor<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> Self {\n-        debug!(\"Fields::wildcards({:#?}, {:?})\", constructor, ty);\n         let wildcard_from_ty = |ty| &*cx.pattern_arena.alloc(Pat::wildcard_from_ty(ty));\n \n-        match constructor {\n+        let ret = match constructor {\n             Single | Variant(_) => match ty.kind {\n                 ty::Tuple(ref fs) => {\n                     Fields::wildcards_from_tys(cx, fs.into_iter().map(|ty| ty.expect_ty()))\n@@ -1093,7 +1092,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         if has_no_hidden_fields {\n                             Fields::wildcards_from_tys(cx, field_tys)\n                         } else {\n-                            let mut len = 0;\n+                            let mut kept_count = 0;\n                             let fields = variant\n                                 .fields\n                                 .iter()\n@@ -1110,12 +1109,12 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                                     if is_uninhabited && (!is_visible || is_non_exhaustive) {\n                                         FilteredField::Hidden(ty)\n                                     } else {\n-                                        len += 1;\n+                                        kept_count += 1;\n                                         FilteredField::Kept(wildcard_from_ty(ty))\n                                     }\n                                 })\n                                 .collect();\n-                            Fields::Filtered { fields, len }\n+                            Fields::Filtered { fields, kept_count }\n                         }\n                     }\n                 }\n@@ -1129,14 +1128,19 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n             ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => Fields::empty(),\n-        }\n+        };\n+        debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n+        ret\n     }\n \n+    /// Returns the number of patterns from the viewpoint of match-checking, i.e. excluding hidden\n+    /// fields. This is what we want in most cases in this file, the only exception being\n+    /// conversion to/from `Pat`.\n     fn len(&self) -> usize {\n         match self {\n             Fields::Slice(pats) => pats.len(),\n             Fields::Vec(pats) => pats.len(),\n-            Fields::Filtered { len, .. } => *len,\n+            Fields::Filtered { kept_count, .. } => *kept_count,\n         }\n     }\n \n@@ -1206,7 +1210,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         let pats: &[_] = cx.pattern_arena.alloc_from_iter(pats);\n \n         match self {\n-            Fields::Filtered { fields, len } => {\n+            Fields::Filtered { fields, kept_count } => {\n                 let mut pats = pats.iter();\n                 let mut fields = fields.clone();\n                 for f in &mut fields {\n@@ -1215,7 +1219,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         *p = pats.next().unwrap();\n                     }\n                 }\n-                Fields::Filtered { fields, len: *len }\n+                Fields::Filtered { fields, kept_count: *kept_count }\n             }\n             _ => Fields::Slice(pats),\n         }\n@@ -1866,11 +1870,13 @@ crate fn is_useful<'p, 'tcx>(\n         return if any_is_useful { Useful(unreachable_pats) } else { NotUseful };\n     }\n \n-    let pcx = PatCtxt { ty: v.head().ty, span: v.head().span };\n+    // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n+    let ty = matrix.heads().next().map(|r| r.ty).unwrap_or(v.head().ty);\n+    let pcx = PatCtxt { ty, span: v.head().span };\n \n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v.head());\n \n-    if let Some(constructor) = pat_constructor(cx.tcx, cx.param_env, v.head()) {\n+    let ret = if let Some(constructor) = pat_constructor(cx.tcx, cx.param_env, v.head()) {\n         debug!(\"is_useful - expanding constructor: {:#?}\", constructor);\n         split_grouped_constructors(\n             cx.tcx,\n@@ -1901,11 +1907,11 @@ crate fn is_useful<'p, 'tcx>(\n \n         let used_ctors: Vec<Constructor<'_>> =\n             matrix.heads().filter_map(|p| pat_constructor(cx.tcx, cx.param_env, p)).collect();\n-        debug!(\"used_ctors = {:#?}\", used_ctors);\n+        debug!(\"is_useful_used_ctors = {:#?}\", used_ctors);\n         // `all_ctors` are all the constructors for the given type, which\n         // should all be represented (or caught with the wild pattern `_`).\n         let all_ctors = all_constructors(cx, pcx);\n-        debug!(\"all_ctors = {:#?}\", all_ctors);\n+        debug!(\"is_useful_all_ctors = {:#?}\", all_ctors);\n \n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n@@ -1920,7 +1926,7 @@ crate fn is_useful<'p, 'tcx>(\n         // can be big.\n         let missing_ctors = MissingConstructors::new(all_ctors, used_ctors);\n \n-        debug!(\"missing_ctors.empty()={:#?}\", missing_ctors.is_empty(),);\n+        debug!(\"is_useful_missing_ctors.empty()={:#?}\", missing_ctors.is_empty(),);\n \n         if missing_ctors.is_empty() {\n             let (all_ctors, _) = missing_ctors.into_inner();\n@@ -1988,7 +1994,9 @@ crate fn is_useful<'p, 'tcx>(\n                 usefulness.apply_missing_ctors(cx, pcx.ty, &missing_ctors)\n             }\n         }\n-    }\n+    };\n+    debug!(\"is_useful::returns({:#?}, {:#?}) = {:?}\", matrix, v, ret);\n+    ret\n }\n \n /// A shorthand for the `U(S(c, P), S(c, q))` operation from the paper. I.e., `is_useful` applied\n@@ -2647,7 +2655,10 @@ fn specialize_one_pattern<'p, 'tcx>(\n \n         PatKind::Or { .. } => bug!(\"Or-pattern should have been expanded earlier on.\"),\n     };\n-    debug!(\"specialize({:#?}, {:#?}) = {:#?}\", pat, ctor_wild_subpatterns, result);\n+    debug!(\n+        \"specialize({:#?}, {:#?}, {:#?}) = {:#?}\",\n+        pat, constructor, ctor_wild_subpatterns, result\n+    );\n \n     result\n }"}, {"sha": "1e1d21433b79cae613a5313bb7d89bb4fde03972", "filename": "src/test/ui/pattern/usefulness/issue-72476-associated-type.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9cd3f1c54956e5b306567161d1965277c9ef8455/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-72476-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cd3f1c54956e5b306567161d1965277c9ef8455/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-72476-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-72476-associated-type.rs?ref=9cd3f1c54956e5b306567161d1965277c9ef8455", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+// From https://github.com/rust-lang/rust/issues/72476\n+\n+trait A {\n+    type Projection;\n+}\n+\n+impl A for () {\n+    type Projection = bool;\n+}\n+\n+struct Next<T: A>(T::Projection);\n+\n+fn f(item: Next<()>) {\n+    match item {\n+        Next(true) => {}\n+        Next(false) => {}\n+    }\n+}\n+\n+fn main() {}"}]}