{"sha": "1e89bbcb67020892bc0af5af218c35f0fd453fa4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlODliYmNiNjcwMjA4OTJiYzBhZjVhZjIxOGMzNWYwZmQ0NTNmYTQ=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2014-12-28T00:20:47Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2014-12-28T11:46:35Z"}, "message": "Rename TaskRng to ThreadRng\n\nSince runtime is removed, rust has no tasks anymore and everything is moving\nfrom being task-* to thread-*. Let\u2019s rename TaskRng as well!\n\n* Rename TaskRng to ThreadRng\n* Rename task_rng to thread_rng\n\n[breaking-change]", "tree": {"sha": "7f76435dc4fb50ab581a1f3043f12e3d7f5abca7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f76435dc4fb50ab581a1f3043f12e3d7f5abca7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e89bbcb67020892bc0af5af218c35f0fd453fa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e89bbcb67020892bc0af5af218c35f0fd453fa4", "html_url": "https://github.com/rust-lang/rust/commit/1e89bbcb67020892bc0af5af218c35f0fd453fa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e89bbcb67020892bc0af5af218c35f0fd453fa4/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0201334439393bed205c1148bed425b80aab8c22", "url": "https://api.github.com/repos/rust-lang/rust/commits/0201334439393bed205c1148bed425b80aab8c22", "html_url": "https://github.com/rust-lang/rust/commit/0201334439393bed205c1148bed425b80aab8c22"}], "stats": {"total": 196, "additions": 98, "deletions": 98}, "files": [{"sha": "60c360de0948713f472d03e7a96b0d77d88bef69", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -1347,7 +1347,7 @@ mod tests {\n     use core::cell::Cell;\n     use core::default::Default;\n     use core::mem;\n-    use std::rand::{Rng, task_rng};\n+    use std::rand::{Rng, thread_rng};\n     use std::rc::Rc;\n     use super::ElementSwaps;\n \n@@ -1963,7 +1963,7 @@ mod tests {\n     fn test_sort() {\n         for len in range(4u, 25) {\n             for _ in range(0i, 100) {\n-                let mut v = task_rng().gen_iter::<uint>().take(len)\n+                let mut v = thread_rng().gen_iter::<uint>().take(len)\n                                       .collect::<Vec<uint>>();\n                 let mut v1 = v.clone();\n \n@@ -1999,7 +1999,7 @@ mod tests {\n                 // number this element is, i.e. the second elements\n                 // will occur in sorted order.\n                 let mut v = range(0, len).map(|_| {\n-                        let n = task_rng().gen::<uint>() % 10;\n+                        let n = thread_rng().gen::<uint>() % 10;\n                         counts[n] += 1;\n                         (n, counts[n])\n                     }).collect::<Vec<(uint, int)>>();"}, {"sha": "aa1550ae5b874cfbfd5d08dfcfb82e4af1d4ccf9", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -112,7 +112,7 @@ mod tests {\n \n     #[test]\n     fn test_flate_round_trip() {\n-        let mut r = rand::task_rng();\n+        let mut r = rand::thread_rng();\n         let mut words = vec!();\n         for _ in range(0u, 20) {\n             let range = r.gen_range(1u, 10);"}, {"sha": "f31f3468a4c0065947d957f11a65f0e36c577a57", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -64,7 +64,7 @@ impl Rand for Exp1 {\n /// use std::rand::distributions::{Exp, IndependentSample};\n ///\n /// let exp = Exp::new(2.0);\n-/// let v = exp.ind_sample(&mut rand::task_rng());\n+/// let v = exp.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from a Exp(2) distribution\", v);\n /// ```\n #[deriving(Copy)]"}, {"sha": "618db380db8d4d8bdf13e9df1ac8dbf9574d974a", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -44,7 +44,7 @@ use super::{IndependentSample, Sample, Exp};\n /// use std::rand::distributions::{IndependentSample, Gamma};\n ///\n /// let gamma = Gamma::new(2.0, 5.0);\n-/// let v = gamma.ind_sample(&mut rand::task_rng());\n+/// let v = gamma.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from a Gamma(2, 5) distribution\", v);\n /// ```\n ///\n@@ -191,7 +191,7 @@ impl IndependentSample<f64> for GammaLargeShape {\n /// use std::rand::distributions::{ChiSquared, IndependentSample};\n ///\n /// let chi = ChiSquared::new(11.0);\n-/// let v = chi.ind_sample(&mut rand::task_rng());\n+/// let v = chi.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from a \u03c7\u00b2(11) distribution\", v)\n /// ```\n pub struct ChiSquared {\n@@ -248,7 +248,7 @@ impl IndependentSample<f64> for ChiSquared {\n /// use std::rand::distributions::{FisherF, IndependentSample};\n ///\n /// let f = FisherF::new(2.0, 32.0);\n-/// let v = f.ind_sample(&mut rand::task_rng());\n+/// let v = f.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from an F(2, 32) distribution\", v)\n /// ```\n pub struct FisherF {\n@@ -292,7 +292,7 @@ impl IndependentSample<f64> for FisherF {\n /// use std::rand::distributions::{StudentT, IndependentSample};\n ///\n /// let t = StudentT::new(11.0);\n-/// let v = t.ind_sample(&mut rand::task_rng());\n+/// let v = t.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from a t(11) distribution\", v)\n /// ```\n pub struct StudentT {"}, {"sha": "54cb8ae19071893eb320ef1f13bc208111c83ea1", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -96,7 +96,7 @@ pub struct Weighted<T> {\n ///                      Weighted { weight: 4, item: 'b' },\n ///                      Weighted { weight: 1, item: 'c' });\n /// let wc = WeightedChoice::new(items.as_mut_slice());\n-/// let mut rng = rand::task_rng();\n+/// let mut rng = rand::thread_rng();\n /// for _ in range(0u, 16) {\n ///      // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n ///      println!(\"{}\", wc.ind_sample(&mut rng));"}, {"sha": "3507282ec486af51ce63639998b1c1c624ed3fd7", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -81,7 +81,7 @@ impl Rand for StandardNormal {\n ///\n /// // mean 2, standard deviation 3\n /// let normal = Normal::new(2.0, 3.0);\n-/// let v = normal.ind_sample(&mut rand::task_rng());\n+/// let v = normal.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from a N(2, 9) distribution\", v)\n /// ```\n #[deriving(Copy)]\n@@ -129,7 +129,7 @@ impl IndependentSample<f64> for Normal {\n ///\n /// // mean 2, standard deviation 3\n /// let log_normal = LogNormal::new(2.0, 3.0);\n-/// let v = log_normal.ind_sample(&mut rand::task_rng());\n+/// let v = log_normal.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from an ln N(2, 9) distribution\", v)\n /// ```\n #[deriving(Copy)]"}, {"sha": "20ba3566d5b1226601d66f2697a9a8d15c97c63a", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -39,7 +39,7 @@ use distributions::{Sample, IndependentSample};\n ///\n /// fn main() {\n ///     let between = Range::new(10u, 10000u);\n-///     let mut rng = std::rand::task_rng();\n+///     let mut rng = std::rand::thread_rng();\n ///     let mut sum = 0;\n ///     for _ in range(0u, 1000) {\n ///         sum += between.ind_sample(&mut rng);"}, {"sha": "273b991bc22f2a6561f032c014164b82b34551dc", "filename": "src/librand/lib.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -138,10 +138,10 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut v = [0u8, .. 13579];\n-    /// task_rng().fill_bytes(&mut v);\n+    /// thread_rng().fill_bytes(&mut v);\n     /// println!(\"{}\", v.as_slice());\n     /// ```\n     fn fill_bytes(&mut self, dest: &mut [u8]) {\n@@ -173,9 +173,9 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let mut rng = task_rng();\n+    /// let mut rng = thread_rng();\n     /// let x: uint = rng.gen();\n     /// println!(\"{}\", x);\n     /// println!(\"{}\", rng.gen::<(f64, bool)>());\n@@ -191,9 +191,9 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let mut rng = task_rng();\n+    /// let mut rng = thread_rng();\n     /// let x = rng.gen_iter::<uint>().take(10).collect::<Vec<uint>>();\n     /// println!(\"{}\", x);\n     /// println!(\"{}\", rng.gen_iter::<(f64, bool)>().take(5)\n@@ -218,9 +218,9 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let mut rng = task_rng();\n+    /// let mut rng = thread_rng();\n     /// let n: uint = rng.gen_range(0u, 10);\n     /// println!(\"{}\", n);\n     /// let m: f64 = rng.gen_range(-40.0f64, 1.3e5f64);\n@@ -236,9 +236,9 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let mut rng = task_rng();\n+    /// let mut rng = thread_rng();\n     /// println!(\"{}\", rng.gen_weighted_bool(3));\n     /// ```\n     fn gen_weighted_bool(&mut self, n: uint) -> bool {\n@@ -250,9 +250,9 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let s: String = task_rng().gen_ascii_chars().take(10).collect();\n+    /// let s: String = thread_rng().gen_ascii_chars().take(10).collect();\n     /// println!(\"{}\", s);\n     /// ```\n     fn gen_ascii_chars<'a>(&'a mut self) -> AsciiGenerator<'a, Self> {\n@@ -266,10 +266,10 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let choices = [1i, 2, 4, 8, 16, 32];\n-    /// let mut rng = task_rng();\n+    /// let mut rng = thread_rng();\n     /// println!(\"{}\", rng.choose(&choices));\n     /// assert_eq!(rng.choose(choices[..0]), None);\n     /// ```\n@@ -286,9 +286,9 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let mut rng = task_rng();\n+    /// let mut rng = thread_rng();\n     /// let mut y = [1i, 2, 3];\n     /// rng.shuffle(&mut y);\n     /// println!(\"{}\", y.as_slice());\n@@ -520,8 +520,8 @@ mod test {\n         }\n     }\n \n-    pub fn rng() -> MyRng<rand::TaskRng> {\n-        MyRng { inner: rand::task_rng() }\n+    pub fn rng() -> MyRng<rand::ThreadRng> {\n+        MyRng { inner: rand::thread_rng() }\n     }\n \n     pub fn weak_rng() -> MyRng<rand::XorShiftRng> {"}, {"sha": "e50153076c390698759ab5f9832b016c0f9c5b5b", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -215,7 +215,7 @@ impl<T:Rand> Rand for Option<T> {\n #[cfg(test)]\n mod tests {\n     use std::prelude::*;\n-    use std::rand::{Rng, task_rng, Open01, Closed01};\n+    use std::rand::{Rng, thread_rng, Open01, Closed01};\n \n     struct ConstantRng(u64);\n     impl Rng for ConstantRng {\n@@ -240,7 +240,7 @@ mod tests {\n     fn rand_open() {\n         // this is unlikely to catch an incorrect implementation that\n         // generates exactly 0 or 1, but it keeps it sane.\n-        let mut rng = task_rng();\n+        let mut rng = thread_rng();\n         for _ in range(0u, 1_000) {\n             // strict inequalities\n             let Open01(f) = rng.gen::<Open01<f64>>();\n@@ -253,7 +253,7 @@ mod tests {\n \n     #[test]\n     fn rand_closed() {\n-        let mut rng = task_rng();\n+        let mut rng = thread_rng();\n         for _ in range(0u, 1_000) {\n             // strict inequalities\n             let Closed01(f) = rng.gen::<Closed01<f64>>();"}, {"sha": "38f030c3bdac82e739dd389fde43b4f81dcc9e80", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n #![allow(non_snake_case)]\n \n-use std::rand::{Rng, task_rng};\n+use std::rand::{Rng, thread_rng};\n use stdtest::Bencher;\n \n use regex::{Regex, NoExpand};\n@@ -154,7 +154,7 @@ fn medium() -> Regex { regex!(\"[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n fn hard() -> Regex { regex!(\"[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n \n fn gen_text(n: uint) -> String {\n-    let mut rng = task_rng();\n+    let mut rng = thread_rng();\n     let mut bytes = rng.gen_ascii_chars().map(|n| n as u8).take(n)\n                        .collect::<Vec<u8>>();\n     for (i, b) in bytes.iter_mut().enumerate() {"}, {"sha": "fae73cc834fd243e804df191ed6c07a3d1fdffbe", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -392,10 +392,10 @@ mod tests {\n \n     #[test]\n     fn test_base64_random() {\n-        use std::rand::{task_rng, random, Rng};\n+        use std::rand::{thread_rng, random, Rng};\n \n         for _ in range(0u, 1000) {\n-            let times = task_rng().gen_range(1u, 100);\n+            let times = thread_rng().gen_range(1u, 100);\n             let v = Vec::from_fn(times, |_| random::<u8>());\n             assert_eq!(v.to_base64(STANDARD)\n                         .from_base64()"}, {"sha": "737fef23c74668764b564c5e10add1858f912b43", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -79,7 +79,7 @@ impl RandomSipHasher {\n     /// Construct a new `RandomSipHasher` that is initialized with random keys.\n     #[inline]\n     pub fn new() -> RandomSipHasher {\n-        let mut r = rand::task_rng();\n+        let mut r = rand::thread_rng();\n         let r0 = r.gen();\n         let r1 = r.gen();\n         RandomSipHasher {"}, {"sha": "822ba643f839b4c95aac1613a0cacb730f5c698f", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -1438,7 +1438,7 @@ mod tests {\n     }\n \n     fn make_rand_name() -> String {\n-        let mut rng = rand::task_rng();\n+        let mut rng = rand::thread_rng();\n         let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10u)\n                                      .collect::<String>());\n         assert!(getenv(n.as_slice()).is_none());"}, {"sha": "d4f72a53aec1b7651928ec72a4f26add13014bee", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -18,10 +18,10 @@\n //! See the `distributions` submodule for sampling random numbers from\n //! distributions like normal and exponential.\n //!\n-//! # Task-local RNG\n+//! # Thread-local RNG\n //!\n-//! There is built-in support for a RNG associated with each task stored\n-//! in task-local storage. This RNG can be accessed via `task_rng`, or\n+//! There is built-in support for a RNG associated with each thread stored\n+//! in thread-local storage. This RNG can be accessed via `thread_rng`, or\n //! used implicitly via `random`. This RNG is normally randomly seeded\n //! from an operating-system source of randomness, e.g. `/dev/urandom` on\n //! Unix systems, and will automatically reseed itself from this source\n@@ -61,7 +61,7 @@\n //! use std::rand;\n //! use std::rand::Rng;\n //!\n-//! let mut rng = rand::task_rng();\n+//! let mut rng = rand::thread_rng();\n //! if rng.gen() { // random bool\n //!     println!(\"int: {}, uint: {}\", rng.gen::<int>(), rng.gen::<uint>())\n //! }\n@@ -97,7 +97,7 @@\n //!\n //! fn main() {\n //!    let between = Range::new(-1f64, 1.);\n-//!    let mut rng = rand::task_rng();\n+//!    let mut rng = rand::thread_rng();\n //!\n //!    let total = 1_000_000u;\n //!    let mut in_circle = 0u;\n@@ -183,7 +183,7 @@\n //!     // The estimation will be more accurate with more simulations\n //!     let num_simulations = 10000u;\n //!\n-//!     let mut rng = rand::task_rng();\n+//!     let mut rng = rand::thread_rng();\n //!     let random_door = Range::new(0u, 3);\n //!\n //!     let (mut switch_wins, mut switch_losses) = (0u, 0u);\n@@ -257,7 +257,7 @@ impl StdRng {\n     /// randomness from the operating system and use this in an\n     /// expensive seeding operation. If one is only generating a small\n     /// number of random numbers, or doesn't need the utmost speed for\n-    /// generating each number, `task_rng` and/or `random` may be more\n+    /// generating each number, `thread_rng` and/or `random` may be more\n     /// appropriate.\n     ///\n     /// Reading the randomness from the OS may fail, and any error is\n@@ -307,28 +307,28 @@ pub fn weak_rng() -> XorShiftRng {\n     }\n }\n \n-/// Controls how the task-local RNG is reseeded.\n-struct TaskRngReseeder;\n+/// Controls how the thread-local RNG is reseeded.\n+struct ThreadRngReseeder;\n \n-impl reseeding::Reseeder<StdRng> for TaskRngReseeder {\n+impl reseeding::Reseeder<StdRng> for ThreadRngReseeder {\n     fn reseed(&mut self, rng: &mut StdRng) {\n         *rng = match StdRng::new() {\n             Ok(r) => r,\n-            Err(e) => panic!(\"could not reseed task_rng: {}\", e)\n+            Err(e) => panic!(\"could not reseed thread_rng: {}\", e)\n         }\n     }\n }\n-static TASK_RNG_RESEED_THRESHOLD: uint = 32_768;\n-type TaskRngInner = reseeding::ReseedingRng<StdRng, TaskRngReseeder>;\n+static THREAD_RNG_RESEED_THRESHOLD: uint = 32_768;\n+type ThreadRngInner = reseeding::ReseedingRng<StdRng, ThreadRngReseeder>;\n \n-/// The task-local RNG.\n-pub struct TaskRng {\n-    rng: Rc<RefCell<TaskRngInner>>,\n+/// The thread-local RNG.\n+pub struct ThreadRng {\n+    rng: Rc<RefCell<ThreadRngInner>>,\n }\n \n-/// Retrieve the lazily-initialized task-local random number\n+/// Retrieve the lazily-initialized thread-local random number\n /// generator, seeded by the system. Intended to be used in method\n-/// chaining style, e.g. `task_rng().gen::<int>()`.\n+/// chaining style, e.g. `thread_rng().gen::<int>()`.\n ///\n /// The RNG provided will reseed itself from the operating system\n /// after generating a certain amount of randomness.\n@@ -337,23 +337,23 @@ pub struct TaskRng {\n /// if the operating system random number generator is rigged to give\n /// the same sequence always. If absolute consistency is required,\n /// explicitly select an RNG, e.g. `IsaacRng` or `Isaac64Rng`.\n-pub fn task_rng() -> TaskRng {\n+pub fn thread_rng() -> ThreadRng {\n     // used to make space in TLS for a random number generator\n-    thread_local!(static TASK_RNG_KEY: Rc<RefCell<TaskRngInner>> = {\n+    thread_local!(static THREAD_RNG_KEY: Rc<RefCell<ThreadRngInner>> = {\n         let r = match StdRng::new() {\n             Ok(r) => r,\n-            Err(e) => panic!(\"could not initialize task_rng: {}\", e)\n+            Err(e) => panic!(\"could not initialize thread_rng: {}\", e)\n         };\n         let rng = reseeding::ReseedingRng::new(r,\n-                                               TASK_RNG_RESEED_THRESHOLD,\n-                                               TaskRngReseeder);\n+                                               THREAD_RNG_RESEED_THRESHOLD,\n+                                               ThreadRngReseeder);\n         Rc::new(RefCell::new(rng))\n     });\n \n-    TaskRng { rng: TASK_RNG_KEY.with(|t| t.clone()) }\n+    ThreadRng { rng: THREAD_RNG_KEY.with(|t| t.clone()) }\n }\n \n-impl Rng for TaskRng {\n+impl Rng for ThreadRng {\n     fn next_u32(&mut self) -> u32 {\n         self.rng.borrow_mut().next_u32()\n     }\n@@ -368,7 +368,7 @@ impl Rng for TaskRng {\n     }\n }\n \n-/// Generates a random value using the task-local random number generator.\n+/// Generates a random value using the thread-local random number generator.\n ///\n /// `random()` can generate various types of random things, and so may require\n /// type hinting to generate the specific type you want.\n@@ -390,17 +390,17 @@ impl Rng for TaskRng {\n /// ```\n #[inline]\n pub fn random<T: Rand>() -> T {\n-    task_rng().gen()\n+    thread_rng().gen()\n }\n \n /// Randomly sample up to `amount` elements from an iterator.\n ///\n /// # Example\n ///\n /// ```rust\n-/// use std::rand::{task_rng, sample};\n+/// use std::rand::{thread_rng, sample};\n ///\n-/// let mut rng = task_rng();\n+/// let mut rng = thread_rng();\n /// let sample = sample(&mut rng, range(1i, 100), 5);\n /// println!(\"{}\", sample);\n /// ```\n@@ -420,7 +420,7 @@ pub fn sample<T, I: Iterator<T>, R: Rng>(rng: &mut R,\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use super::{Rng, task_rng, random, SeedableRng, StdRng, sample};\n+    use super::{Rng, thread_rng, random, SeedableRng, StdRng, sample};\n     use iter::order;\n \n     struct ConstRng { i: u64 }\n@@ -453,7 +453,7 @@ mod test {\n \n     #[test]\n     fn test_gen_range() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         for _ in range(0u, 1000) {\n             let a = r.gen_range(-3i, 42);\n             assert!(a >= -3 && a < 42);\n@@ -473,51 +473,51 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_gen_range_panic_int() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         r.gen_range(5i, -2);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_gen_range_panic_uint() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         r.gen_range(5u, 2u);\n     }\n \n     #[test]\n     fn test_gen_f64() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         let a = r.gen::<f64>();\n         let b = r.gen::<f64>();\n         debug!(\"{}\", (a, b));\n     }\n \n     #[test]\n     fn test_gen_weighted_bool() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         assert_eq!(r.gen_weighted_bool(0u), true);\n         assert_eq!(r.gen_weighted_bool(1u), true);\n     }\n \n     #[test]\n     fn test_gen_ascii_str() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         assert_eq!(r.gen_ascii_chars().take(0).count(), 0u);\n         assert_eq!(r.gen_ascii_chars().take(10).count(), 10u);\n         assert_eq!(r.gen_ascii_chars().take(16).count(), 16u);\n     }\n \n     #[test]\n     fn test_gen_vec() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         assert_eq!(r.gen_iter::<u8>().take(0).count(), 0u);\n         assert_eq!(r.gen_iter::<u8>().take(10).count(), 10u);\n         assert_eq!(r.gen_iter::<f64>().take(16).count(), 16u);\n     }\n \n     #[test]\n     fn test_choose() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         assert_eq!(r.choose(&[1i, 1, 1]).map(|&x|x), Some(1));\n \n         let v: &[int] = &[];\n@@ -526,7 +526,7 @@ mod test {\n \n     #[test]\n     fn test_shuffle() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         let empty: &mut [int] = &mut [];\n         r.shuffle(empty);\n         let mut one = [1i];\n@@ -545,8 +545,8 @@ mod test {\n     }\n \n     #[test]\n-    fn test_task_rng() {\n-        let mut r = task_rng();\n+    fn test_thread_rng() {\n+        let mut r = thread_rng();\n         r.gen::<int>();\n         let mut v = [1i, 1, 1];\n         r.shuffle(&mut v);\n@@ -574,7 +574,7 @@ mod test {\n         let min_val = 1i;\n         let max_val = 100i;\n \n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         let vals = range(min_val, max_val).collect::<Vec<int>>();\n         let small_sample = sample(&mut r, vals.iter(), 5);\n         let large_sample = sample(&mut r, vals.iter(), vals.len() + 5);\n@@ -589,7 +589,7 @@ mod test {\n \n     #[test]\n     fn test_std_rng_seeded() {\n-        let s = task_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n+        let s = thread_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n         let mut ra: StdRng = SeedableRng::from_seed(s.as_slice());\n         let mut rb: StdRng = SeedableRng::from_seed(s.as_slice());\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n@@ -598,7 +598,7 @@ mod test {\n \n     #[test]\n     fn test_std_rng_reseed() {\n-        let s = task_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n+        let s = thread_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n         let mut r: StdRng = SeedableRng::from_seed(s.as_slice());\n         let string1 = r.gen_ascii_chars().take(100).collect::<String>();\n "}, {"sha": "7b6a6be78852607cf2c74b3fe6c3b8c14a2c5f7d", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -394,7 +394,7 @@ mod tests {\n         for _ in range(0, N) {\n             let tx = tx.clone();\n             spawn(move|| {\n-                let mut rng = rand::task_rng();\n+                let mut rng = rand::thread_rng();\n                 for _ in range(0, M) {\n                     if rng.gen_weighted_bool(N) {\n                         drop(R.write());"}, {"sha": "f22a4b5c6ed10b30e09a85824afe5ad703e4f161", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -724,7 +724,7 @@ pub fn fresh_name(src: &ast::Ident) -> ast::Name {\n     // following: debug version. Could work in final except that it's incompatible with\n     // good error messages and uses of struct names in ambiguous could-be-binding\n     // locations. Also definitely destroys the guarantee given above about ptr_eq.\n-    /*let num = rand::task_rng().gen_uint_range(0,0xffff);\n+    /*let num = rand::thread_rng().gen_uint_range(0,0xffff);\n     gensym(format!(\"{}_{}\",ident_to_string(src),num))*/\n }\n "}, {"sha": "d9a4aede7d7d910b5f0c703ee07b8bb6ea962351", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -83,7 +83,7 @@ fn read_line() {\n }\n \n fn vec_plus() {\n-    let mut r = rand::task_rng();\n+    let mut r = rand::thread_rng();\n \n     let mut v = Vec::new();\n     let mut i = 0;\n@@ -101,7 +101,7 @@ fn vec_plus() {\n }\n \n fn vec_append() {\n-    let mut r = rand::task_rng();\n+    let mut r = rand::thread_rng();\n \n     let mut v = Vec::new();\n     let mut i = 0;\n@@ -122,7 +122,7 @@ fn vec_append() {\n }\n \n fn vec_push_all() {\n-    let mut r = rand::task_rng();\n+    let mut r = rand::thread_rng();\n \n     let mut v = Vec::new();\n     for i in range(0u, 1500) {"}, {"sha": "f673c3b797809803e0d1d7c5bb3bc57e0ded9f87", "filename": "src/test/compile-fail/task-rng-isnt-sendable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ensure that the TaskRng isn't/doesn't become accidentally sendable.\n+// ensure that the ThreadRng isn't/doesn't become accidentally sendable.\n \n use std::rand;\n \n fn test_send<S: Send>() {}\n \n pub fn main() {\n-    test_send::<rand::TaskRng>();\n+    test_send::<rand::ThreadRng>();\n     //~^ ERROR `core::kinds::Send` is not implemented\n     //~^^ ERROR `core::kinds::Send` is not implemented\n }"}, {"sha": "88d8f10e7094d9f60561c613ed05b8a0ab379239", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -10,7 +10,7 @@\n \n use std::{char, os};\n use std::io::{File, Command};\n-use std::rand::{task_rng, Rng};\n+use std::rand::{thread_rng, Rng};\n \n // creates unicode_input_multiple_files_{main,chars}.rs, where the\n // former imports the latter. `_chars` just contains an identifier\n@@ -19,7 +19,7 @@ use std::rand::{task_rng, Rng};\n // this span used to upset the compiler).\n \n fn random_char() -> char {\n-    let mut rng = task_rng();\n+    let mut rng = thread_rng();\n     // a subset of the XID_start Unicode table (ensuring that the\n     // compiler doesn't fail with an \"unrecognised token\" error)\n     let (lo, hi): (u32, u32) = match rng.gen_range(1u32, 4u32 + 1) {"}, {"sha": "f83734b1502eb61426eb194afc83680bca85aa63", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -10,15 +10,15 @@\n \n use std::{char, os};\n use std::io::{File, Command};\n-use std::rand::{task_rng, Rng};\n+use std::rand::{thread_rng, Rng};\n \n // creates a file with `fn main() { <random ident> }` and checks the\n // compiler emits a span of the appropriate length (for the\n // \"unresolved name\" message); currently just using the number of code\n // points, but should be the number of graphemes (FIXME #7043)\n \n fn random_char() -> char {\n-    let mut rng = task_rng();\n+    let mut rng = thread_rng();\n     // a subset of the XID_start Unicode table (ensuring that the\n     // compiler doesn't fail with an \"unrecognised token\" error)\n     let (lo, hi): (u32, u32) = match rng.gen_range(1u32, 4u32 + 1) {\n@@ -38,7 +38,7 @@ fn main() {\n     let main_file = tmpdir.join(\"span_main.rs\");\n \n     for _ in range(0u, 100) {\n-        let n = task_rng().gen_range(3u, 20);\n+        let n = thread_rng().gen_range(3u, 20);\n \n         {\n             let _ = write!(&mut File::create(&main_file).unwrap(),"}, {"sha": "6ff1cffb4a42f448bf9fda4a3d7cc8e98fdbf4de", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e89bbcb67020892bc0af5af218c35f0fd453fa4/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=1e89bbcb67020892bc0af5af218c35f0fd453fa4", "patch": "@@ -10,7 +10,7 @@\n \n use std::task;\n use std::sync::atomic::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n-use std::rand::{task_rng, Rng, Rand};\n+use std::rand::{thread_rng, Rng, Rand};\n \n const REPEATS: uint = 5;\n const MAX_LEN: uint = 32;\n@@ -59,7 +59,7 @@ pub fn main() {\n             // IDs start from 0.\n             creation_count.store(0, Relaxed);\n \n-            let main = task_rng().gen_iter::<DropCounter>()\n+            let main = thread_rng().gen_iter::<DropCounter>()\n                                  .take(len)\n                                  .collect::<Vec<DropCounter>>();\n "}]}