{"sha": "741e27b41408e42fc14c41f8001eeefb92fbf00b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MWUyN2I0MTQwOGU0MmZjMTRjNDFmODAwMWVlZWZiOTJmYmYwMGI=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-11T17:40:47Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-11T17:40:47Z"}, "message": "dedup PartialEq for Record enums", "tree": {"sha": "b0487856e67077614be9155395182f62324dcb66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0487856e67077614be9155395182f62324dcb66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/741e27b41408e42fc14c41f8001eeefb92fbf00b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/741e27b41408e42fc14c41f8001eeefb92fbf00b", "html_url": "https://github.com/rust-lang/rust/commit/741e27b41408e42fc14c41f8001eeefb92fbf00b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/741e27b41408e42fc14c41f8001eeefb92fbf00b/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc17eb482d082135c477c18154179dc6acde810b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc17eb482d082135c477c18154179dc6acde810b", "html_url": "https://github.com/rust-lang/rust/commit/fc17eb482d082135c477c18154179dc6acde810b"}], "stats": {"total": 75, "additions": 38, "deletions": 37}, "files": [{"sha": "0db2aa320857b8cdd828878d26f702215ff056be", "filename": "crates/ide_assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/741e27b41408e42fc14c41f8001eeefb92fbf00b/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/741e27b41408e42fc14c41f8001eeefb92fbf00b/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=741e27b41408e42fc14c41f8001eeefb92fbf00b", "patch": "@@ -339,6 +339,34 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         fn_name\n     }\n \n+    fn gen_eq_chain(expr: Option<ast::Expr>, cmp: ast::Expr) -> Option<ast::Expr> {\n+        match expr {\n+            Some(expr) => Some(make::expr_op(ast::BinOp::BooleanAnd, expr, cmp)),\n+            None => Some(cmp),\n+        }\n+    }\n+\n+    fn gen_record_pat_field(field_name: &str, pat_name: &str) -> ast::RecordPatField {\n+        let pat = make::ext::simple_ident_pat(make::name(&pat_name));\n+        let name_ref = make::name_ref(field_name);\n+        let field = make::record_pat_field(name_ref, pat.into());\n+        field\n+    }\n+\n+    fn gen_record_pat(\n+        record_name: ast::Path,\n+        r_fields: Vec<ast::RecordPatField>,\n+    ) -> ast::RecordPat {\n+        let list = make::record_pat_field_list(r_fields);\n+        make::record_pat_with_fields(record_name, list)\n+    }\n+\n+    fn gen_variant_path(variant: &ast::Variant) -> Option<ast::Path> {\n+        let first = make::ext::ident_path(\"Self\");\n+        let second = make::path_from_text(&variant.name()?.to_string());\n+        let record_name = make::path_concat(first, second);\n+        Some(record_name)\n+    }\n     // FIXME: return `None` if the trait carries a generic type; we can only\n     // generate this code `Self` for the time being.\n \n@@ -364,52 +392,31 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         let mut expr = None;\n                         let mut l_fields = vec![];\n                         let mut r_fields = vec![];\n-                        // let mut fields = vec![];\n-\n-                        // !! make::record_pat_field{list, etc};\n \n                         for field in list.fields() {\n                             let field_name = field.name()?.to_string();\n \n                             let l_name = &format!(\"l_{}\", field_name);\n-                            let pat = make::ext::simple_ident_pat(make::name(&l_name));\n-                            let name_ref = make::name_ref(&field_name);\n-                            let field = make::record_pat_field(name_ref, pat.into());\n-                            l_fields.push(field);\n+                            l_fields.push(gen_record_pat_field(&field_name, &l_name));\n \n-                            let r_name = &format!(\"r_{}\", field_name);\n-                            let pat = make::ext::simple_ident_pat(make::name(&r_name));\n-                            let name_ref = make::name_ref(&field_name);\n-                            let field = make::record_pat_field(name_ref, pat.into());\n-                            r_fields.push(field);\n+                            let r_name = &format!(\"l_{}\", field_name);\n+                            r_fields.push(gen_record_pat_field(&field_name, &r_name));\n \n                             let lhs = make::expr_path(make::ext::ident_path(l_name));\n                             let rhs = make::expr_path(make::ext::ident_path(r_name));\n                             let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n-                            expr = match expr {\n-                                Some(expr) => {\n-                                    Some(make::expr_op(ast::BinOp::BooleanAnd, expr, cmp))\n-                                }\n-                                None => Some(cmp),\n-                            };\n+                            expr = gen_eq_chain(expr, cmp);\n                         }\n-                        let first = make::ext::ident_path(\"Self\");\n-                        let second = make::path_from_text(&variant.name()?.to_string());\n-                        let record_name = make::path_concat(first, second);\n-                        let list = make::record_pat_field_list(l_fields);\n-                        let l_record = make::record_pat_with_fields(record_name, list);\n-\n-                        let first = make::ext::ident_path(\"Self\");\n-                        let second = make::path_from_text(&variant.name()?.to_string());\n-                        let record_name = make::path_concat(first, second);\n-                        let list = make::record_pat_field_list(r_fields);\n-                        let r_record = make::record_pat_with_fields(record_name, list);\n \n+                        let l_record = gen_record_pat(gen_variant_path(&variant)?, l_fields);\n+                        let r_record = gen_record_pat(gen_variant_path(&variant)?, r_fields);\n                         let tuple = make::tuple_pat(vec![l_record.into(), r_record.into()]);\n+\n                         if let Some(expr) = expr {\n                             arms.push(make::match_arm(Some(tuple.into()), None, expr));\n                         }\n                     }\n+\n                     // todo!(\"implement tuple record iteration\")\n                     Some(ast::FieldList::TupleFieldList(list)) => {\n                         todo!(\"implement tuple enum iteration\")\n@@ -453,10 +460,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n                     let rhs = make::expr_field(rhs, &field.name()?.to_string());\n                     let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n-                    expr = match expr {\n-                        Some(expr) => Some(make::expr_op(ast::BinOp::BooleanAnd, expr, cmp)),\n-                        None => Some(cmp),\n-                    };\n+                    expr = gen_eq_chain(expr, cmp);\n                 }\n                 make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))\n             }\n@@ -470,10 +474,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n                     let rhs = make::expr_field(rhs, &idx);\n                     let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n-                    expr = match expr {\n-                        Some(expr) => Some(make::expr_op(ast::BinOp::BooleanAnd, expr, cmp)),\n-                        None => Some(cmp),\n-                    };\n+                    expr = gen_eq_chain(expr, cmp);\n                 }\n                 make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))\n             }"}]}