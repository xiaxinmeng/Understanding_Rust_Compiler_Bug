{"sha": "7481e6d1a415853a96dcec11a052caaa02859b5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ODFlNmQxYTQxNTg1M2E5NmRjZWMxMWEwNTJjYWFhMDI4NTliNWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-22T13:26:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-22T13:26:32Z"}, "message": "Auto merge of #88163 - camsteffen:collapsible-match-fix, r=Manishearth\n\nFix clippy::collapsible_match with let expressions\n\nThis fixes rust-lang/rust-clippy#7575 which is a regression from #80357. I am fixing the bug here instead of in the clippy repo (if that's okay) because a) the regression has not been synced yet and b) I would like to land the fix on nightly asap.\n\nThe fix is basically to re-generalize `match` and `if let` for the lint implementation (they were split because `if let` no longer desugars to `match` in the HIR).\n\nAlso fixes rust-lang/rust-clippy#7586 and fixes rust-lang/rust-clippy#7591\ncc `@rust-lang/clippy`\n`@xFrednet` do you want to review this?", "tree": {"sha": "63de73abacd8425bc7670c18c35f7e3acaba7bec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63de73abacd8425bc7670c18c35f7e3acaba7bec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7481e6d1a415853a96dcec11a052caaa02859b5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7481e6d1a415853a96dcec11a052caaa02859b5a", "html_url": "https://github.com/rust-lang/rust/commit/7481e6d1a415853a96dcec11a052caaa02859b5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7481e6d1a415853a96dcec11a052caaa02859b5a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1eb187c16ec4f26fdeaff527e3ba2b1e609cabd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1eb187c16ec4f26fdeaff527e3ba2b1e609cabd2", "html_url": "https://github.com/rust-lang/rust/commit/1eb187c16ec4f26fdeaff527e3ba2b1e609cabd2"}, {"sha": "ada92825c9f38a0c1e198b63e806687d2338340e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ada92825c9f38a0c1e198b63e806687d2338340e", "html_url": "https://github.com/rust-lang/rust/commit/ada92825c9f38a0c1e198b63e806687d2338340e"}], "stats": {"total": 286, "additions": 136, "deletions": 150}, "files": [{"sha": "a42eee53459eba504f63638ba2ef8af761e06bca", "filename": "src/tools/clippy/clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 78, "deletions": 79, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{higher, is_lang_ctor, path_to_local, peel_ref_operators, SpanlessEq};\n+use clippy_utils::{higher, is_lang_ctor, is_unit_expr, path_to_local, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n+use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, MatchSource, Pat, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n@@ -49,104 +49,87 @@ declare_lint_pass!(CollapsibleMatch => [COLLAPSIBLE_MATCH]);\n \n impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n-        if let Some(higher::IfLet {\n-            let_pat,\n-            if_then,\n-            if_else,\n-            ..\n-        }) = higher::IfLet::hir(expr)\n-        {\n-            check_arm(cx, if_then, None, let_pat, if_else);\n-\n-            check_if_let(cx, if_then, let_pat);\n-        }\n-\n-        if let ExprKind::Match(_expr, arms, _source) = expr.kind {\n-            if let Some(wild_arm) = arms.iter().rfind(|arm| is_wild_like(cx, &arm.pat.kind, &arm.guard)) {\n-                for arm in arms {\n-                    check_arm(cx, arm.body, arm.guard.as_ref(), arm.pat, Some(wild_arm.body));\n+        match IfLetOrMatch::parse(cx, expr) {\n+            Some(IfLetOrMatch::Match(_, arms, _)) => {\n+                if let Some(els_arm) = arms.iter().rfind(|arm| arm_is_wild_like(cx, arm)) {\n+                    for arm in arms {\n+                        check_arm(cx, true, arm.pat, arm.body, arm.guard.as_ref(), Some(els_arm.body));\n+                    }\n                 }\n             }\n-\n-            if let Some(first_arm) = arms.get(0) {\n-                check_if_let(cx, &first_arm.body, &first_arm.pat);\n+            Some(IfLetOrMatch::IfLet(_, pat, body, els)) => {\n+                check_arm(cx, false, pat, body, None, els);\n             }\n+            None => {}\n         }\n     }\n }\n \n fn check_arm<'tcx>(\n     cx: &LateContext<'tcx>,\n-    outer_block: &'tcx Expr<'tcx>,\n-    outer_guard: Option<&Guard<'tcx>>,\n+    outer_is_match: bool,\n     outer_pat: &'tcx Pat<'tcx>,\n-    wild_outer_block: Option<&'tcx Expr<'tcx>>,\n+    outer_then_body: &'tcx Expr<'tcx>,\n+    outer_guard: Option<&'tcx Guard<'tcx>>,\n+    outer_else_body: Option<&'tcx Expr<'tcx>>\n ) {\n-    let expr = strip_singleton_blocks(outer_block);\n+    let inner_expr = strip_singleton_blocks(outer_then_body);\n     if_chain! {\n-        if let ExprKind::Match(expr_in, arms_inner, _) = expr.kind;\n-        // the outer arm pattern and the inner match\n-        if expr_in.span.ctxt() == outer_pat.span.ctxt();\n-        // there must be no more than two arms in the inner match for this lint\n-        if arms_inner.len() == 2;\n-        // no if guards on the inner match\n-        if arms_inner.iter().all(|arm| arm.guard.is_none());\n+        if let Some(inner) = IfLetOrMatch::parse(cx, inner_expr);\n+        if let Some((inner_scrutinee, inner_then_pat, inner_else_body)) = match inner {\n+            IfLetOrMatch::IfLet(scrutinee, pat, _, els) => Some((scrutinee, pat, els)),\n+            IfLetOrMatch::Match(scrutinee, arms, ..) => if_chain! {\n+                // if there are more than two arms, collapsing would be non-trivial\n+                if arms.len() == 2 && arms.iter().all(|a| a.guard.is_none());\n+                // one of the arms must be \"wild-like\"\n+                if let Some(wild_idx) = arms.iter().rposition(|a| arm_is_wild_like(cx, a));\n+                then {\n+                    let (then, els) = (&arms[1 - wild_idx], &arms[wild_idx]);\n+                    Some((scrutinee, then.pat, Some(els.body)))\n+                } else {\n+                    None\n+                }\n+            },\n+        };\n+        if outer_pat.span.ctxt() == inner_scrutinee.span.ctxt();\n         // match expression must be a local binding\n         // match <local> { .. }\n-        if let Some(binding_id) = path_to_local(peel_ref_operators(cx, expr_in));\n-        // one of the branches must be \"wild-like\"\n-        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| is_wild_like(cx, &arm_inner.pat.kind, &arm_inner.guard));\n-        let (wild_inner_arm, non_wild_inner_arm) =\n-            (&arms_inner[wild_inner_arm_idx], &arms_inner[1 - wild_inner_arm_idx]);\n-        if !pat_contains_or(non_wild_inner_arm.pat);\n+        if let Some(binding_id) = path_to_local(peel_ref_operators(cx, inner_scrutinee));\n+        if !pat_contains_or(inner_then_pat);\n         // the binding must come from the pattern of the containing match arm\n         // ..<local>.. => match <local> { .. }\n         if let Some(binding_span) = find_pat_binding(outer_pat, binding_id);\n-        // the \"wild-like\" branches must be equal\n-        if wild_outer_block.map(|el| SpanlessEq::new(cx).eq_expr(wild_inner_arm.body, el)).unwrap_or(true);\n+        // the \"else\" branches must be equal\n+        if match (outer_else_body, inner_else_body) {\n+            (None, None) => true,\n+            (None, Some(e)) | (Some(e), None) => is_unit_expr(e),\n+            (Some(a), Some(b)) => SpanlessEq::new(cx).eq_expr(a, b),\n+        };\n         // the binding must not be used in the if guard\n         let mut used_visitor = LocalUsedVisitor::new(cx, binding_id);\n-        if match outer_guard {\n-            None => true,\n-            Some(Guard::If(expr) | Guard::IfLet(_, expr)) => !used_visitor.check_expr(expr),\n+        if outer_guard.map_or(true, |(Guard::If(e) | Guard::IfLet(_, e))| !used_visitor.check_expr(e));\n+        // ...or anywhere in the inner expression\n+        if match inner {\n+            IfLetOrMatch::IfLet(_, _, body, els) => {\n+                !used_visitor.check_expr(body) && els.map_or(true, |e| !used_visitor.check_expr(e))\n+            },\n+            IfLetOrMatch::Match(_, arms, ..) => !arms.iter().any(|arm| used_visitor.check_arm(arm)),\n         };\n-        // ...or anywhere in the inner match\n-        if !arms_inner.iter().any(|arm| used_visitor.check_arm(arm));\n         then {\n-            span_lint_and_then(\n-                cx,\n-                COLLAPSIBLE_MATCH,\n-                expr.span,\n-                \"unnecessary nested match\",\n-                |diag| {\n-                    let mut help_span = MultiSpan::from_spans(vec![binding_span, non_wild_inner_arm.pat.span]);\n-                    help_span.push_span_label(binding_span, \"replace this binding\".into());\n-                    help_span.push_span_label(non_wild_inner_arm.pat.span, \"with this pattern\".into());\n-                    diag.span_help(help_span, \"the outer pattern can be modified to include the inner pattern\");\n-                },\n+            let msg = format!(\n+                \"this `{}` can be collapsed into the outer `{}`\",\n+                if matches!(inner, IfLetOrMatch::Match(..)) { \"match\" } else { \"if let\" },\n+                if outer_is_match { \"match\" } else { \"if let\" },\n             );\n-        }\n-    }\n-}\n-\n-fn check_if_let<'tcx>(cx: &LateContext<'tcx>, outer_expr: &'tcx Expr<'tcx>, outer_pat: &'tcx Pat<'tcx>) {\n-    let block_inner = strip_singleton_blocks(outer_expr);\n-    if_chain! {\n-        if let Some(higher::IfLet { if_then: inner_if_then, let_expr: inner_let_expr, let_pat: inner_let_pat, .. }) = higher::IfLet::hir(block_inner);\n-        if let Some(binding_id) = path_to_local(peel_ref_operators(cx, inner_let_expr));\n-        if let Some(binding_span) = find_pat_binding(outer_pat, binding_id);\n-        let mut used_visitor = LocalUsedVisitor::new(cx, binding_id);\n-        if !used_visitor.check_expr(inner_if_then);\n-        then {\n             span_lint_and_then(\n                 cx,\n                 COLLAPSIBLE_MATCH,\n-                block_inner.span,\n-                \"unnecessary nested `if let` or `match`\",\n+                inner_expr.span,\n+                &msg,\n                 |diag| {\n-                    let mut help_span = MultiSpan::from_spans(vec![binding_span, inner_let_pat.span]);\n+                    let mut help_span = MultiSpan::from_spans(vec![binding_span, inner_then_pat.span]);\n                     help_span.push_span_label(binding_span, \"replace this binding\".into());\n-                    help_span.push_span_label(inner_let_pat.span, \"with this pattern\".into());\n+                    help_span.push_span_label(inner_then_pat.span, \"with this pattern\".into());\n                     diag.span_help(help_span, \"the outer pattern can be modified to include the inner pattern\");\n                 },\n             );\n@@ -168,14 +151,30 @@ fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir>\n     expr\n }\n \n-/// A \"wild-like\" pattern is wild (\"_\") or `None`.\n-/// For this lint to apply, both the outer and inner patterns\n-/// must have \"wild-like\" branches that can be combined.\n-fn is_wild_like(cx: &LateContext<'_>, pat_kind: &PatKind<'_>, arm_guard: &Option<Guard<'_>>) -> bool {\n-    if arm_guard.is_some() {\n+enum IfLetOrMatch<'hir> {\n+    Match(&'hir Expr<'hir>, &'hir [Arm<'hir>], MatchSource),\n+    /// scrutinee, pattern, then block, else block\n+    IfLet(&'hir Expr<'hir>, &'hir Pat<'hir>, &'hir Expr<'hir>, Option<&'hir Expr<'hir>>),\n+}\n+\n+impl<'hir> IfLetOrMatch<'hir> {\n+    fn parse(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n+        match expr.kind {\n+            ExprKind::Match(expr, arms, source) => Some(Self::Match(expr, arms, source)),\n+            _ => higher::IfLet::hir(cx, expr).map(|higher::IfLet { let_expr, let_pat, if_then, if_else }| {\n+                Self::IfLet(let_expr, let_pat, if_then, if_else)\n+            })\n+        }\n+    }\n+}\n+\n+/// A \"wild-like\" arm has a wild (`_`) or `None` pattern and no guard. Such arms can be \"collapsed\"\n+/// into a single wild arm without any significant loss in semantics or readability.\n+fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n+    if arm.guard.is_some() {\n         return false;\n     }\n-    match pat_kind {\n+    match arm.pat.kind {\n         PatKind::Binding(..) | PatKind::Wild => true,\n         PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n         _ => false,"}, {"sha": "7dad1c31150e2cc49b6dfba66391a7f0dbce6062", "filename": "src/tools/clippy/clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n             if_then,\n             if_else: Some(if_else),\n             ..\n-        }) = higher::IfLet::hir(expr)\n+        }) = higher::IfLet::hir(cx, expr)\n         {\n             op_visit.visit_expr(let_expr);\n             if op_visit.mutex_lock_called {"}, {"sha": "fb5637fcec183559a9b18cc5c53a13784031c943", "filename": "src/tools/clippy/clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -45,7 +45,7 @@ declare_lint_pass!(OkIfLet => [IF_LET_SOME_RESULT]);\n impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! { //begin checking variables\n-            if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(expr);\n+            if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(cx, expr);\n             if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = let_pat.kind; //get operation\n             if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;"}, {"sha": "5852674da578067661fcf961501aa890cd531d02", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -37,7 +37,7 @@ pub(super) fn check<'tcx>(\n \n         if_chain! {\n             if let Some(inner_expr) = inner_expr;\n-            if let Some(higher::IfLet { let_pat, let_expr, if_else: None, .. }) = higher::IfLet::hir(inner_expr);\n+            if let Some(higher::IfLet { let_pat, let_expr, if_else: None, .. }) = higher::IfLet::hir(cx, inner_expr);\n             // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n             if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n             if path_to_local_id(let_expr, pat_hir_id);"}, {"sha": "d6d3315e0a83ed8c2ec69afb27dc6feb5826e45e", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -17,7 +17,7 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'\n             let_expr,\n             if_else: Some(if_else),\n             ..\n-        }) = higher::IfLet::hir(inner)\n+        }) = higher::IfLet::hir(cx, inner)\n         {\n             if is_simple_break_expr(if_else) {\n                 could_be_while_let(cx, expr, let_pat, let_expr);"}, {"sha": "161d884149075012d3cb7a300056910de428096e", "filename": "src/tools/clippy/clippy_lints/src/manual_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -49,7 +49,7 @@ impl LateLintPass<'_> for ManualMap {\n             let_expr,\n             if_then,\n             if_else: Some(if_else),\n-        }) = higher::IfLet::hir(expr)\n+        }) = higher::IfLet::hir(cx, expr)\n         {\n             manage_lint(cx, expr, (&let_pat.kind, if_then), (&PatKind::Wild, if_else), let_expr);\n         }"}, {"sha": "3d0da472ddcbff8f2fe61560c94e490d2587d7b1", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -8,9 +8,9 @@ use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n use clippy_utils::visitors::LocalUsedVisitor;\n use clippy_utils::{\n-    get_parent_expr, in_macro, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_wild, meets_msrv, msrvs,\n-    path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, remove_blocks,\n-    strip_pat_refs,\n+    get_parent_expr, in_macro, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild,\n+    meets_msrv, msrvs, path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n+    remove_blocks, strip_pat_refs,\n };\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use core::array;\n@@ -634,7 +634,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         if let ExprKind::Match(ref ex, ref arms, _) = expr.kind {\n             check_match_ref_pats(cx, ex, arms.iter().map(|el| el.pat), expr);\n         }\n-        if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(expr) {\n+        if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(cx, expr) {\n             check_match_ref_pats(cx, let_expr, once(let_pat), expr);\n         }\n     }\n@@ -1298,7 +1298,7 @@ fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)\n         let_expr,\n         if_then,\n         if_else: Some(if_else),\n-    }) = higher::IfLet::hir(expr)\n+    }) = higher::IfLet::hir(cx, expr)\n     {\n         return find_matches_sugg(\n             cx,\n@@ -1672,14 +1672,6 @@ fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n         .collect()\n }\n \n-fn is_unit_expr(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Tup(v) if v.is_empty() => true,\n-        ExprKind::Block(b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n-        _ => false,\n-    }\n-}\n-\n // Checks if arm has the form `None => None`\n fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n@@ -1835,7 +1827,7 @@ mod redundant_pattern_match {\n             let_pat,\n             let_expr,\n             ..\n-        }) = higher::IfLet::ast(cx, expr)\n+        }) = higher::IfLet::hir(cx, expr)\n         {\n             find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some())\n         }"}, {"sha": "eff3d3abff80cdc5affd4e0f03025be6acb9d7a5", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -125,7 +125,7 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionIfLetElseOccurence> {\n     if_chain! {\n         if !in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n-        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) }) = higher::IfLet::hir(expr);\n+        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) }) = higher::IfLet::hir(cx, expr);\n         if !is_else_clause(cx.tcx, expr);\n         if !is_result_ok(cx, let_expr); // Don't lint on Result::ok because a different lint does it already\n         if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &let_pat.kind;"}, {"sha": "7b6a0894e6d2fcc4ccb1c70133f5cff65078d51a", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -97,7 +97,7 @@ impl QuestionMark {\n \n     fn check_if_let_some_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) }) = higher::IfLet::hir(expr);\n+            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) }) = higher::IfLet::hir(cx, expr);\n             if Self::is_option(cx, let_expr);\n \n             if let PatKind::TupleStruct(ref path1, fields, None) = let_pat.kind;"}, {"sha": "957ec35be6f9be3e62e110d02816e2b25fae1da9", "filename": "src/tools/clippy/clippy_utils/src/higher.rs", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -79,15 +79,7 @@ pub struct IfLet<'hir> {\n }\n \n impl<'hir> IfLet<'hir> {\n-    #[inline]\n-    pub fn ast(cx: &LateContext<'tcx>, expr: &Expr<'hir>) -> Option<Self> {\n-        let rslt = Self::hir(expr)?;\n-        Self::is_not_within_while_context(cx, expr)?;\n-        Some(rslt)\n-    }\n-\n-    #[inline]\n-    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+    pub fn hir(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n         if let ExprKind::If(\n             Expr {\n                 kind: ExprKind::Let(let_pat, let_expr, _),\n@@ -97,6 +89,14 @@ impl<'hir> IfLet<'hir> {\n             if_else,\n         ) = expr.kind\n         {\n+            let hir = cx.tcx.hir();\n+            let mut iter = hir.parent_iter(expr.hir_id);\n+            if let Some((_, Node::Block(Block { stmts: [], .. }))) = iter.next() {\n+                if let Some((_, Node::Expr(Expr { kind: ExprKind::Loop(_, _, LoopSource::While, _), .. }))) = iter.next() {\n+                    // while loop desugar\n+                    return None;\n+                }\n+            }\n             return Some(Self {\n                 let_pat,\n                 let_expr,\n@@ -106,22 +106,6 @@ impl<'hir> IfLet<'hir> {\n         }\n         None\n     }\n-\n-    #[inline]\n-    fn is_not_within_while_context(cx: &LateContext<'tcx>, expr: &Expr<'hir>) -> Option<()> {\n-        let hir = cx.tcx.hir();\n-        let parent = hir.get_parent_node(expr.hir_id);\n-        let parent_parent = hir.get_parent_node(parent);\n-        let parent_parent_node = hir.get(parent_parent);\n-        if let Node::Expr(Expr {\n-            kind: ExprKind::Loop(_, _, LoopSource::While, _),\n-            ..\n-        }) = parent_parent_node\n-        {\n-            return None;\n-        }\n-        Some(())\n-    }\n }\n \n pub struct IfOrIfLet<'hir> {"}, {"sha": "7d7c3b8846c3f1c16f1266bc088df736330335fe", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -254,6 +254,10 @@ pub fn in_macro(span: Span) -> bool {\n     }\n }\n \n+pub fn is_unit_expr(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::Block(Block { stmts: [], expr: None, .. }, _) | ExprKind::Tup([]))\n+}\n+\n /// Checks if given pattern is a wildcard (`_`)\n pub fn is_wild(pat: &Pat<'_>) -> bool {\n     matches!(pat.kind, PatKind::Wild)"}, {"sha": "4ce365cc7649ab0a405e472535caada9f65c5822", "filename": "src/tools/clippy/tests/ui/collapsible_match.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -98,6 +98,11 @@ fn lint_cases(opt_opt: Option<Option<u32>>, res_opt: Result<Option<u32>, String>\n }\n \n fn negative_cases(res_opt: Result<Option<u32>, String>, res_res: Result<Result<u32, String>, String>) {\n+    while let Some(x) = make() {\n+        if let Some(1) = x {\n+            todo!();\n+        }\n+    }\n     // no wild pattern in outer match\n     match res_opt {\n         Ok(val) => match val {"}, {"sha": "c119570e8abd8eab585064870a28f3cfd8582938", "filename": "src/tools/clippy/tests/ui/collapsible_match.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.stderr?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -1,4 +1,4 @@\n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match.rs:7:20\n    |\n LL |           Ok(val) => match val {\n@@ -17,7 +17,7 @@ LL |         Ok(val) => match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match.rs:16:20\n    |\n LL |           Ok(val) => match val {\n@@ -35,7 +35,7 @@ LL |         Ok(val) => match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested `if let` or `match`\n+error: this `if let` can be collapsed into the outer `if let`\n   --> $DIR/collapsible_match.rs:25:9\n    |\n LL | /         if let Some(n) = val {\n@@ -51,7 +51,7 @@ LL |     if let Ok(val) = res_opt {\n LL |         if let Some(n) = val {\n    |                ^^^^^^^ with this pattern\n \n-error: unnecessary nested `if let` or `match`\n+error: this `if let` can be collapsed into the outer `if let`\n   --> $DIR/collapsible_match.rs:32:9\n    |\n LL | /         if let Some(n) = val {\n@@ -69,7 +69,7 @@ LL |     if let Ok(val) = res_opt {\n LL |         if let Some(n) = val {\n    |                ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `if let`\n   --> $DIR/collapsible_match.rs:43:9\n    |\n LL | /         match val {\n@@ -87,7 +87,7 @@ LL |         match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested `if let` or `match`\n+error: this `if let` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match.rs:52:13\n    |\n LL | /             if let Some(n) = val {\n@@ -103,7 +103,7 @@ LL |         Ok(val) => {\n LL |             if let Some(n) = val {\n    |                    ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `if let`\n   --> $DIR/collapsible_match.rs:61:9\n    |\n LL | /         match val {\n@@ -121,7 +121,7 @@ LL |         match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested `if let` or `match`\n+error: this `if let` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match.rs:72:13\n    |\n LL | /             if let Some(n) = val {\n@@ -139,7 +139,7 @@ LL |         Ok(val) => {\n LL |             if let Some(n) = val {\n    |                    ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match.rs:83:20\n    |\n LL |           Ok(val) => match val {\n@@ -157,7 +157,7 @@ LL |         Ok(val) => match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match.rs:92:22\n    |\n LL |           Some(val) => match val {"}, {"sha": "55e70dce208a0016bbf5acb560bb17161a832316", "filename": "src/tools/clippy/tests/ui/collapsible_match2.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match2.stderr?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -1,4 +1,4 @@\n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match2.rs:13:34\n    |\n LL |               Ok(val) if make() => match val {\n@@ -17,7 +17,7 @@ LL |             Ok(val) if make() => match val {\n LL |                 Some(n) => foo(n),\n    |                 ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match2.rs:20:24\n    |\n LL |               Ok(val) => match val {\n@@ -35,7 +35,7 @@ LL |             Ok(val) => match val {\n LL |                 Some(n) => foo(n),\n    |                 ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match2.rs:34:29\n    |\n LL |                       $pat => match $e {\n@@ -57,7 +57,7 @@ LL |         mac!(res_opt => Ok(val), val => Some(n), foo(n));\n    |                            replace this binding\n    = note: this error originates in the macro `mac` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match2.rs:51:20\n    |\n LL |           Some(s) => match *s {\n@@ -75,7 +75,7 @@ LL |         Some(s) => match *s {\n LL |             [n] => foo(n),\n    |             ^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match2.rs:60:24\n    |\n LL |           Some(ref s) => match &*s {"}, {"sha": "1bddc47721e5a71037eb70ad49622519197a3392", "filename": "src/tools/clippy/tests/ui/if_let_some_result.fixed", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_some_result.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_some_result.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_some_result.fixed?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::if_let_some_result)]\n+#![allow(dead_code)]\n \n fn str_to_int(x: &str) -> i32 {\n     if let Ok(y) = x.parse() { y } else { 0 }\n@@ -20,8 +21,8 @@ fn strange_some_no_else(x: &str) -> i32 {\n     }\n }\n \n-fn main() {\n-    let _ = str_to_int(\"1\");\n-    let _ = str_to_int_ok(\"2\");\n-    let _ = strange_some_no_else(\"3\");\n+fn negative() {\n+    while let Some(1) = \"\".parse().ok() {}\n }\n+\n+fn main() {}"}, {"sha": "d4a52ec9881d76f465d003af6f7c60b2a4107519", "filename": "src/tools/clippy/tests/ui/if_let_some_result.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_some_result.rs?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::if_let_some_result)]\n+#![allow(dead_code)]\n \n fn str_to_int(x: &str) -> i32 {\n     if let Some(y) = x.parse().ok() { y } else { 0 }\n@@ -20,8 +21,8 @@ fn strange_some_no_else(x: &str) -> i32 {\n     }\n }\n \n-fn main() {\n-    let _ = str_to_int(\"1\");\n-    let _ = str_to_int_ok(\"2\");\n-    let _ = strange_some_no_else(\"3\");\n+fn negative() {\n+    while let Some(1) = \"\".parse().ok() {}\n }\n+\n+fn main() {}"}, {"sha": "bc3a5e7698d749764f4c79e819586a6d72076ac6", "filename": "src/tools/clippy/tests/ui/if_let_some_result.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_some_result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7481e6d1a415853a96dcec11a052caaa02859b5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_some_result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_some_result.stderr?ref=7481e6d1a415853a96dcec11a052caaa02859b5a", "patch": "@@ -1,5 +1,5 @@\n error: matching on `Some` with `ok()` is redundant\n-  --> $DIR/if_let_some_result.rs:6:5\n+  --> $DIR/if_let_some_result.rs:7:5\n    |\n LL |     if let Some(y) = x.parse().ok() { y } else { 0 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -11,7 +11,7 @@ LL |     if let Ok(y) = x.parse() { y } else { 0 }\n    |     ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: matching on `Some` with `ok()` is redundant\n-  --> $DIR/if_let_some_result.rs:16:9\n+  --> $DIR/if_let_some_result.rs:17:9\n    |\n LL |         if let Some(y) = x   .   parse()   .   ok   ()    {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}]}