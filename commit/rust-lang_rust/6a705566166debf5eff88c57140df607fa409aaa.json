{"sha": "6a705566166debf5eff88c57140df607fa409aaa", "node_id": "C_kwDOAAsO6NoAKDZhNzA1NTY2MTY2ZGViZjVlZmY4OGM1NzE0MGRmNjA3ZmE0MDlhYWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-27T17:42:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-27T17:42:48Z"}, "message": "Auto merge of #94412 - scottmcm:cfg-out-miri-from-swap, r=oli-obk\n\nFor MIRI, cfg out the swap vectorization logic from 94212\n\nBecause of #69488 the swap logic from #94212 doesn't currently work in MIRI.\n\nCopying in smaller pieces is probably much worse for its performance anyway, so it'd probably rather just use the simple path regardless.\n\nPart of #94371, though another PR will be needed for the CTFE aspect.\n\nr? `@oli-obk`\ncc `@RalfJung`", "tree": {"sha": "943724a46461430c07e5df2b608911e7392c4c39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/943724a46461430c07e5df2b608911e7392c4c39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a705566166debf5eff88c57140df607fa409aaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a705566166debf5eff88c57140df607fa409aaa", "html_url": "https://github.com/rust-lang/rust/commit/6a705566166debf5eff88c57140df607fa409aaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a705566166debf5eff88c57140df607fa409aaa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b1fe7e7c95e14dd8a420edf2f8a160c70211e04", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b1fe7e7c95e14dd8a420edf2f8a160c70211e04", "html_url": "https://github.com/rust-lang/rust/commit/3b1fe7e7c95e14dd8a420edf2f8a160c70211e04"}, {"sha": "b582bd388f5693119bbefa85ed7ea055760f9eef", "url": "https://api.github.com/repos/rust-lang/rust/commits/b582bd388f5693119bbefa85ed7ea055760f9eef", "html_url": "https://github.com/rust-lang/rust/commit/b582bd388f5693119bbefa85ed7ea055760f9eef"}], "stats": {"total": 77, "additions": 64, "deletions": 13}, "files": [{"sha": "8a99bed6a96ab186ff528075669ceae80865d3ac", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6a705566166debf5eff88c57140df607fa409aaa/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a705566166debf5eff88c57140df607fa409aaa/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=6a705566166debf5eff88c57140df607fa409aaa", "patch": "@@ -708,7 +708,10 @@ pub const fn swap<T>(x: &mut T, y: &mut T) {\n     // understanding `mem::replace`, `Option::take`, etc. - a better overall\n     // solution might be to make `ptr::swap_nonoverlapping` into an intrinsic, which\n     // a backend can choose to implement using the block optimization, or not.\n-    #[cfg(not(target_arch = \"spirv\"))]\n+    // NOTE(scottmcm) MIRI is disabled here as reading in smaller units is a\n+    // pessimization for it.  Also, if the type contains any unaligned pointers,\n+    // copying those over multiple reads is difficult to support.\n+    #[cfg(not(any(target_arch = \"spirv\", miri)))]\n     {\n         // For types that are larger multiples of their alignment, the simple way\n         // tends to copy the whole thing to stack rather than doing it one part\n@@ -737,12 +740,26 @@ pub const fn swap<T>(x: &mut T, y: &mut T) {\n #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n #[inline]\n pub(crate) const fn swap_simple<T>(x: &mut T, y: &mut T) {\n+    // We arrange for this to typically be called with small types,\n+    // so this reads-and-writes approach is actually better than using\n+    // copy_nonoverlapping as it easily puts things in LLVM registers\n+    // directly and doesn't end up inlining allocas.\n+    // And LLVM actually optimizes it to 3\u00d7memcpy if called with\n+    // a type larger than it's willing to keep in a register.\n+    // Having typed reads and writes in MIR here is also good as\n+    // it lets MIRI and CTFE understand them better, including things\n+    // like enforcing type validity for them.\n+    // Importantly, read+copy_nonoverlapping+write introduces confusing\n+    // asymmetry to the behaviour where one value went through read+write\n+    // whereas the other was copied over by the intrinsic (see #94371).\n+\n     // SAFETY: exclusive references are always valid to read/write,\n-    // are non-overlapping, and nothing here panics so it's drop-safe.\n+    // including being aligned, and nothing here panics so it's drop-safe.\n     unsafe {\n-        let z = ptr::read(x);\n-        ptr::copy_nonoverlapping(y, x, 1);\n-        ptr::write(y, z);\n+        let a = ptr::read(x);\n+        let b = ptr::read(y);\n+        ptr::write(x, b);\n+        ptr::write(y, a);\n     }\n }\n "}, {"sha": "59b1b4c1367526a274b0fc1ad26aa44a12096fa8", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6a705566166debf5eff88c57140df607fa409aaa/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a705566166debf5eff88c57140df607fa409aaa/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=6a705566166debf5eff88c57140df607fa409aaa", "patch": "@@ -419,6 +419,7 @@ pub const unsafe fn swap<T>(x: *mut T, y: *mut T) {\n #[stable(feature = \"swap_nonoverlapping\", since = \"1.27.0\")]\n #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n+    #[allow(unused)]\n     macro_rules! attempt_swap_as_chunks {\n         ($ChunkTy:ty) => {\n             if mem::align_of::<T>() >= mem::align_of::<$ChunkTy>()\n@@ -437,15 +438,21 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n         };\n     }\n \n-    // Split up the slice into small power-of-two-sized chunks that LLVM is able\n-    // to vectorize (unless it's a special type with more-than-pointer alignment,\n-    // because we don't want to pessimize things like slices of SIMD vectors.)\n-    if mem::align_of::<T>() <= mem::size_of::<usize>()\n-        && (!mem::size_of::<T>().is_power_of_two()\n-            || mem::size_of::<T>() > mem::size_of::<usize>() * 2)\n+    // NOTE(scottmcm) MIRI is disabled here as reading in smaller units is a\n+    // pessimization for it.  Also, if the type contains any unaligned pointers,\n+    // copying those over multiple reads is difficult to support.\n+    #[cfg(not(miri))]\n     {\n-        attempt_swap_as_chunks!(usize);\n-        attempt_swap_as_chunks!(u8);\n+        // Split up the slice into small power-of-two-sized chunks that LLVM is able\n+        // to vectorize (unless it's a special type with more-than-pointer alignment,\n+        // because we don't want to pessimize things like slices of SIMD vectors.)\n+        if mem::align_of::<T>() <= mem::size_of::<usize>()\n+            && (!mem::size_of::<T>().is_power_of_two()\n+                || mem::size_of::<T>() > mem::size_of::<usize>() * 2)\n+        {\n+            attempt_swap_as_chunks!(usize);\n+            attempt_swap_as_chunks!(u8);\n+        }\n     }\n \n     // SAFETY: Same preconditions as this function"}, {"sha": "91a1ab7144fd4ed72d6a728a794e3aea17364257", "filename": "src/test/codegen/swap-large-types.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6a705566166debf5eff88c57140df607fa409aaa/src%2Ftest%2Fcodegen%2Fswap-large-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a705566166debf5eff88c57140df607fa409aaa/src%2Ftest%2Fcodegen%2Fswap-large-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fswap-large-types.rs?ref=6a705566166debf5eff88c57140df607fa409aaa", "patch": "@@ -39,6 +39,9 @@ pub fn swap_std(x: &mut KeccakBuffer, y: &mut KeccakBuffer) {\n     swap(x, y)\n }\n \n+// Verify that types with usize alignment are swapped via vectored usizes,\n+// not falling back to byte-level code.\n+\n // CHECK-LABEL: @swap_slice\n #[no_mangle]\n pub fn swap_slice(x: &mut [KeccakBuffer], y: &mut [KeccakBuffer]) {\n@@ -50,6 +53,8 @@ pub fn swap_slice(x: &mut [KeccakBuffer], y: &mut [KeccakBuffer]) {\n     }\n }\n \n+// But for a large align-1 type, vectorized byte copying is what we want.\n+\n type OneKilobyteBuffer = [u8; 1024];\n \n // CHECK-LABEL: @swap_1kb_slices\n@@ -62,3 +67,25 @@ pub fn swap_1kb_slices(x: &mut [OneKilobyteBuffer], y: &mut [OneKilobyteBuffer])\n         x.swap_with_slice(y);\n     }\n }\n+\n+// This verifies that the 2\u00d7read + 2\u00d7write optimizes to just 3 memcpys\n+// for an unusual type like this.  It's not clear whether we should do anything\n+// smarter in Rust for these, so for now it's fine to leave these up to the backend.\n+// That's not as bad as it might seem, as for example, LLVM will lower the\n+// memcpys below to VMOVAPS on YMMs if one enables the AVX target feature.\n+// Eventually we'll be able to pass `align_of::<T>` to a const generic and\n+// thus pick a smarter chunk size ourselves without huge code duplication.\n+\n+#[repr(align(64))]\n+pub struct BigButHighlyAligned([u8; 64 * 3]);\n+\n+// CHECK-LABEL: @swap_big_aligned\n+#[no_mangle]\n+pub fn swap_big_aligned(x: &mut BigButHighlyAligned, y: &mut BigButHighlyAligned) {\n+// CHECK-NOT: call void @llvm.memcpy\n+// CHECK: call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 64 dereferenceable(192)\n+// CHECK: call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 64 dereferenceable(192)\n+// CHECK: call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 64 dereferenceable(192)\n+// CHECK-NOT: call void @llvm.memcpy\n+    swap(x, y)\n+}"}]}