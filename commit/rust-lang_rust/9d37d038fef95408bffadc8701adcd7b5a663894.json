{"sha": "9d37d038fef95408bffadc8701adcd7b5a663894", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMzdkMDM4ZmVmOTU0MDhiZmZhZGM4NzAxYWRjZDdiNWE2NjM4OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-25T18:04:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-25T18:04:58Z"}, "message": "auto merge of #6737 : dotdash/rust/static_keywords, r=pcwalton\n\nCurrently, keywords are stored in hashsets that are recreated for every\r\nParser instance, which is quite expensive since macro expansion creates\r\nlots of them. Additionally, the parser functions that look for a keyword\r\ncurrently accept a string and have a runtime check to validate that they\r\nactually received a keyword.\r\n\r\nBy creating an enum for the keywords and inserting them into the\r\nident interner, we can avoid the creation of the hashsets and get static\r\nchecks for the keywords.\r\n\r\nFor libstd, this cuts the parse+expansion part from ~2.6s to ~1.6s.", "tree": {"sha": "43db18663f616a24c05d1d71eeb35530b987ffe8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43db18663f616a24c05d1d71eeb35530b987ffe8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d37d038fef95408bffadc8701adcd7b5a663894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d37d038fef95408bffadc8701adcd7b5a663894", "html_url": "https://github.com/rust-lang/rust/commit/9d37d038fef95408bffadc8701adcd7b5a663894", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d37d038fef95408bffadc8701adcd7b5a663894/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e65a3fa152d67046f1962b06e1462035fc3b8f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e65a3fa152d67046f1962b06e1462035fc3b8f4", "html_url": "https://github.com/rust-lang/rust/commit/6e65a3fa152d67046f1962b06e1462035fc3b8f4"}, {"sha": "6c62d77830d75c5bbc9f546f944c038be2622a8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c62d77830d75c5bbc9f546f944c038be2622a8b", "html_url": "https://github.com/rust-lang/rust/commit/6c62d77830d75c5bbc9f546f944c038be2622a8b"}], "stats": {"total": 525, "additions": 280, "deletions": 245}, "files": [{"sha": "f899004de5c5fd32698fc9440cfd69f2b749bd4d", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d37d038fef95408bffadc8701adcd7b5a663894/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d37d038fef95408bffadc8701adcd7b5a663894/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=9d37d038fef95408bffadc8701adcd7b5a663894", "patch": "@@ -16,6 +16,7 @@ use ext::base::ExtCtxt;\n use ext::base;\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n+use parse::token::keywords;\n \n pub fn expand_trace_macros(cx: @ExtCtxt,\n                            sp: span,\n@@ -36,9 +37,9 @@ pub fn expand_trace_macros(cx: @ExtCtxt,\n         rdr.dup()\n     );\n \n-    if rust_parser.is_keyword(\"true\") {\n+    if rust_parser.is_keyword(keywords::True) {\n         cx.set_trace_macros(true);\n-    } else if rust_parser.is_keyword(\"false\") {\n+    } else if rust_parser.is_keyword(keywords::False) {\n         cx.set_trace_macros(false);\n     } else {\n         cx.span_fatal(sp, \"trace_macros! only accepts `true` or `false`\")"}, {"sha": "6a868fbf173ddd6595d8e6d87bfca23739162c5a", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 13, "deletions": 84, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/9d37d038fef95408bffadc8701adcd7b5a663894/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d37d038fef95408bffadc8701adcd7b5a663894/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=9d37d038fef95408bffadc8701adcd7b5a663894", "patch": "@@ -14,6 +14,7 @@ use ast;\n use codemap::{BytePos, spanned};\n use parse::lexer::reader;\n use parse::parser::Parser;\n+use parse::token::keywords;\n use parse::token;\n \n use opt_vec;\n@@ -133,54 +134,15 @@ pub impl Parser {\n         return if *self.token == *tok { self.bump(); true } else { false };\n     }\n \n-    // Storing keywords as interned idents instead of strings would be nifty.\n-\n-    // A sanity check that the word we are asking for is a known keyword\n-    // NOTE: this could be done statically....\n-    fn require_keyword(&self, word: &str) {\n-        if !self.keywords.contains_equiv(&word) {\n-            self.bug(fmt!(\"unknown keyword: %s\", word));\n-        }\n-    }\n-\n-    // return true when this token represents the given string, and is not\n-    // followed immediately by :: .\n-    fn token_is_word(&self, word: &str, tok: &token::Token) -> bool {\n-        match *tok {\n-            token::IDENT(sid, false) => { word == *self.id_to_str(sid) }\n-             _ => { false }\n-        }\n-    }\n-\n-    fn token_is_keyword(&self, word: &str, tok: &token::Token) -> bool {\n-        self.require_keyword(word);\n-        self.token_is_word(word, tok)\n-    }\n-\n-    fn is_keyword(&self, word: &str) -> bool {\n-        self.token_is_keyword(word, &copy *self.token)\n-    }\n-\n-    fn id_is_any_keyword(&self, id: ast::ident) -> bool {\n-        self.keywords.contains(self.id_to_str(id))\n-    }\n-\n-    fn is_any_keyword(&self, tok: &token::Token) -> bool {\n-        match *tok {\n-          token::IDENT(sid, false) => {\n-            self.keywords.contains(self.id_to_str(sid))\n-          }\n-          _ => false\n-        }\n+    fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n+        token::is_keyword(kw, self.token)\n     }\n \n-    // if the given word is not a keyword, signal an error.\n     // if the next token is the given keyword, eat it and return\n     // true. Otherwise, return false.\n-    fn eat_keyword(&self, word: &str) -> bool {\n-        self.require_keyword(word);\n+    fn eat_keyword(&self, kw: keywords::Keyword) -> bool {\n         let is_kw = match *self.token {\n-            token::IDENT(sid, false) => word == *self.id_to_str(sid),\n+            token::IDENT(sid, false) => kw.to_ident().repr == sid.repr,\n             _ => false\n         };\n         if is_kw { self.bump() }\n@@ -190,63 +152,30 @@ pub impl Parser {\n     // if the given word is not a keyword, signal an error.\n     // if the next token is not the given word, signal an error.\n     // otherwise, eat it.\n-    fn expect_keyword(&self, word: &str) {\n-        self.require_keyword(word);\n-        if !self.eat_keyword(word) {\n+    fn expect_keyword(&self, kw: keywords::Keyword) {\n+        if !self.eat_keyword(kw) {\n             self.fatal(\n                 fmt!(\n                     \"expected `%s`, found `%s`\",\n-                    word,\n+                    *self.id_to_str(kw.to_ident()),\n                     self.this_token_to_str()\n                 )\n             );\n         }\n     }\n \n-    // return true if the given string is a strict keyword\n-    fn is_strict_keyword(&self, word: &str) -> bool {\n-        self.strict_keywords.contains_equiv(&word)\n-    }\n-\n-    // signal an error if the current token is a strict keyword\n-    fn check_strict_keywords(&self) {\n-        match *self.token {\n-            token::IDENT(_, false) => {\n-                let w = token_to_str(self.reader, &copy *self.token);\n-                self.check_strict_keywords_(w);\n-            }\n-            _ => ()\n-        }\n-    }\n-\n     // signal an error if the given string is a strict keyword\n-    fn check_strict_keywords_(&self, w: &str) {\n-        if self.is_strict_keyword(w) {\n+    fn check_strict_keywords(&self) {\n+        if token::is_strict_keyword(self.token) {\n             self.span_err(*self.last_span,\n-                          fmt!(\"found `%s` in ident position\", w));\n+                          fmt!(\"found `%s` in ident position\", self.this_token_to_str()));\n         }\n     }\n \n-    // return true if this is a reserved keyword\n-    fn is_reserved_keyword(&self, word: &str) -> bool {\n-        self.reserved_keywords.contains_equiv(&word)\n-    }\n-\n     // signal an error if the current token is a reserved keyword\n     fn check_reserved_keywords(&self) {\n-        match *self.token {\n-            token::IDENT(_, false) => {\n-                let w = token_to_str(self.reader, &copy *self.token);\n-                self.check_reserved_keywords_(w);\n-            }\n-            _ => ()\n-        }\n-    }\n-\n-    // signal an error if the given string is a reserved keyword\n-    fn check_reserved_keywords_(&self, w: &str) {\n-        if self.is_reserved_keyword(w) {\n-            self.fatal(fmt!(\"`%s` is a reserved keyword\", w));\n+        if token::is_reserved_keyword(self.token) {\n+            self.fatal(fmt!(\"`%s` is a reserved keyword\", self.this_token_to_str()));\n         }\n     }\n "}, {"sha": "9a8001386abd84a757ac0eed0e80a26e132f0d3f", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d37d038fef95408bffadc8701adcd7b5a663894/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d37d038fef95408bffadc8701adcd7b5a663894/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=9d37d038fef95408bffadc8701adcd7b5a663894", "patch": "@@ -23,7 +23,7 @@ use ast::{expr, expr_lit, lit_nil, attribute};\n use ast;\n use codemap::{span, respan};\n use parse::parser::Parser;\n-use parse::token::Token;\n+use parse::token::{keywords, Token};\n use parse::token;\n \n use core::to_bytes;\n@@ -295,9 +295,9 @@ pub impl Parser {\n     }\n \n     fn try_parse_obsolete_priv_section(&self, attrs: &[attribute]) -> bool {\n-        if self.is_keyword(\"priv\") && self.look_ahead(1) == token::LBRACE {\n+        if self.is_keyword(keywords::Priv) && self.look_ahead(1) == token::LBRACE {\n             self.obsolete(copy *self.span, ObsoletePrivSection);\n-            self.eat_keyword(\"priv\");\n+            self.eat_keyword(keywords::Priv);\n             self.bump();\n             while *self.token != token::RBRACE {\n                 self.parse_single_struct_field(ast::private, attrs.to_owned());"}, {"sha": "d3c39f4b246863c15493ba0dd8e4cd86f8c885c8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 105, "deletions": 111, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/9d37d038fef95408bffadc8701adcd7b5a663894/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d37d038fef95408bffadc8701adcd7b5a663894/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9d37d038fef95408bffadc8701adcd7b5a663894", "patch": "@@ -86,7 +86,7 @@ use parse::obsolete::{ObsoletePurity, ObsoleteStaticMethod};\n use parse::obsolete::{ObsoleteConstItem, ObsoleteFixedLengthVectorType};\n use parse::obsolete::{ObsoleteNamedExternModule};\n use parse::token::{can_begin_expr, is_ident, is_ident_or_path};\n-use parse::token::{is_plain_ident, INTERPOLATED, special_idents, token_to_binop};\n+use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents, token_to_binop};\n use parse::token;\n use parse::{new_sub_parser_from_file, next_node_id, ParseSess};\n use opt_vec;\n@@ -234,9 +234,6 @@ pub fn Parser(sess: @mut ParseSess,\n         tokens_consumed: @mut 0,\n         restriction: @mut UNRESTRICTED,\n         quote_depth: @mut 0,\n-        keywords: token::keyword_table(),\n-        strict_keywords: token::strict_keyword_table(),\n-        reserved_keywords: token::reserved_keyword_table(),\n         obsolete_set: @mut HashSet::new(),\n         mod_path_stack: @mut ~[],\n     }\n@@ -260,9 +257,6 @@ pub struct Parser {\n     quote_depth: @mut uint, // not (yet) related to the quasiquoter\n     reader: @reader,\n     interner: @token::ident_interner,\n-    keywords: HashSet<~str>,\n-    strict_keywords: HashSet<~str>,\n-    reserved_keywords: HashSet<~str>,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n     /// extra detail when the same error is seen twice\n     obsolete_set: @mut HashSet<ObsoleteSyntax>,\n@@ -340,10 +334,10 @@ pub impl Parser {\n \n     // is this one of the keywords that signals a closure type?\n     fn token_is_closure_keyword(&self, tok: &token::Token) -> bool {\n-        self.token_is_keyword(\"pure\", tok) ||\n-            self.token_is_keyword(\"unsafe\", tok) ||\n-            self.token_is_keyword(\"once\", tok) ||\n-            self.token_is_keyword(\"fn\", tok)\n+        token::is_keyword(keywords::Pure, tok) ||\n+            token::is_keyword(keywords::Unsafe, tok) ||\n+            token::is_keyword(keywords::Once, tok) ||\n+            token::is_keyword(keywords::Fn, tok)\n     }\n \n     fn token_is_lifetime(&self, tok: &token::Token) -> bool {\n@@ -380,7 +374,7 @@ pub impl Parser {\n         let opt_abis = self.parse_opt_abis();\n         let abis = opt_abis.get_or_default(AbiSet::Rust());\n         let purity = self.parse_unsafety();\n-        self.expect_keyword(\"fn\");\n+        self.expect_keyword(keywords::Fn);\n         let (decl, lifetimes) = self.parse_ty_fn_decl();\n         return ty_bare_fn(@TyBareFn {\n             abis: abis,\n@@ -416,7 +410,7 @@ pub impl Parser {\n \n         let purity = self.parse_unsafety();\n         let onceness = parse_onceness(self);\n-        self.expect_keyword(\"fn\");\n+        self.expect_keyword(keywords::Fn);\n         let bounds = self.parse_optional_ty_param_bounds();\n \n         if self.parse_fn_ty_sigil().is_some() {\n@@ -436,7 +430,7 @@ pub impl Parser {\n         });\n \n         fn parse_onceness(this: &Parser) -> Onceness {\n-            if this.eat_keyword(\"once\") {\n+            if this.eat_keyword(keywords::Once) {\n                 Once\n             } else {\n                 Many\n@@ -446,10 +440,10 @@ pub impl Parser {\n \n     // looks like this should be called parse_unsafety\n     fn parse_unsafety(&self) -> purity {\n-        if self.eat_keyword(\"pure\") {\n+        if self.eat_keyword(keywords::Pure) {\n             self.obsolete(*self.last_span, ObsoletePurity);\n             return impure_fn;\n-        } else if self.eat_keyword(\"unsafe\") {\n+        } else if self.eat_keyword(keywords::Unsafe) {\n             return unsafe_fn;\n         } else {\n             return impure_fn;\n@@ -704,7 +698,7 @@ pub impl Parser {\n             // BORROWED POINTER\n             self.bump();\n             self.parse_borrowed_pointee()\n-        } else if self.eat_keyword(\"extern\") {\n+        } else if self.eat_keyword(keywords::Extern) {\n             // EXTERN FUNCTION\n             self.parse_ty_bare_fn()\n         } else if self.token_is_closure_keyword(&copy *self.token) {\n@@ -828,7 +822,7 @@ pub impl Parser {\n         let mut is_mutbl = false;\n         let pat = if require_name || self.is_named_argument() {\n             self.parse_arg_mode();\n-            is_mutbl = self.eat_keyword(\"mut\");\n+            is_mutbl = self.eat_keyword(keywords::Mut);\n             let pat = self.parse_pat(false);\n             self.expect(&token::COLON);\n             pat\n@@ -856,7 +850,7 @@ pub impl Parser {\n     // parse an argument in a lambda header e.g. |arg, arg|\n     fn parse_fn_block_arg(&self) -> arg_or_capture_item {\n         self.parse_arg_mode();\n-        let is_mutbl = self.eat_keyword(\"mut\");\n+        let is_mutbl = self.eat_keyword(keywords::Mut);\n         let pat = self.parse_pat(false);\n         let t = if self.eat(&token::COLON) {\n             self.parse_ty(false)\n@@ -907,9 +901,9 @@ pub impl Parser {\n     // matches lit = true | false | token_lit\n     fn parse_lit(&self) -> lit {\n         let lo = self.span.lo;\n-        let lit = if self.eat_keyword(\"true\") {\n+        let lit = if self.eat_keyword(keywords::True) {\n             lit_bool(true)\n-        } else if self.eat_keyword(\"false\") {\n+        } else if self.eat_keyword(keywords::False) {\n             lit_bool(false)\n         } else {\n             // XXX: This is a really bad copy!\n@@ -1145,15 +1139,15 @@ pub impl Parser {\n     }\n \n     fn token_is_mutability(&self, tok: &token::Token) -> bool {\n-        self.token_is_keyword(\"mut\", tok) ||\n-        self.token_is_keyword(\"const\", tok)\n+        token::is_keyword(keywords::Mut, tok) ||\n+        token::is_keyword(keywords::Const, tok)\n     }\n \n     // parse mutability declaration (mut/const/imm)\n     fn parse_mutability(&self) -> mutability {\n-        if self.eat_keyword(\"mut\") {\n+        if self.eat_keyword(keywords::Mut) {\n             m_mutbl\n-        } else if self.eat_keyword(\"const\") {\n+        } else if self.eat_keyword(keywords::Const) {\n             m_const\n         } else {\n             m_imm\n@@ -1251,30 +1245,30 @@ pub impl Parser {\n                                  expr_block(blk));\n         } else if token::is_bar(&*self.token) {\n             return self.parse_lambda_expr();\n-        } else if self.eat_keyword(\"self\") {\n+        } else if self.eat_keyword(keywords::Self) {\n             ex = expr_self;\n             hi = self.span.hi;\n-        } else if self.eat_keyword(\"if\") {\n+        } else if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n-        } else if self.eat_keyword(\"for\") {\n+        } else if self.eat_keyword(keywords::For) {\n             return self.parse_sugary_call_expr(~\"for\", ForSugar,\n                                                expr_loop_body);\n-        } else if self.eat_keyword(\"do\") {\n+        } else if self.eat_keyword(keywords::Do) {\n             return self.parse_sugary_call_expr(~\"do\", DoSugar,\n                                                expr_do_body);\n-        } else if self.eat_keyword(\"while\") {\n+        } else if self.eat_keyword(keywords::While) {\n             return self.parse_while_expr();\n         } else if self.token_is_lifetime(&*self.token) {\n             let lifetime = self.get_lifetime(&*self.token);\n             self.bump();\n             self.expect(&token::COLON);\n-            self.expect_keyword(\"loop\");\n+            self.expect_keyword(keywords::Loop);\n             return self.parse_loop_expr(Some(lifetime));\n-        } else if self.eat_keyword(\"loop\") {\n+        } else if self.eat_keyword(keywords::Loop) {\n             return self.parse_loop_expr(None);\n-        } else if self.eat_keyword(\"match\") {\n+        } else if self.eat_keyword(keywords::Match) {\n             return self.parse_match_expr();\n-        } else if self.eat_keyword(\"unsafe\") {\n+        } else if self.eat_keyword(keywords::Unsafe) {\n             return self.parse_block_expr(lo, unsafe_blk);\n         } else if *self.token == token::LBRACKET {\n             self.bump();\n@@ -1314,7 +1308,7 @@ pub impl Parser {\n                 }\n             }\n             hi = self.last_span.hi;\n-        } else if self.eat_keyword(\"__log\") {\n+        } else if self.eat_keyword(keywords::__Log) {\n             // LOG expression\n             self.expect(&token::LPAREN);\n             let lvl = self.parse_expr();\n@@ -1323,14 +1317,14 @@ pub impl Parser {\n             ex = expr_log(lvl, e);\n             hi = self.span.hi;\n             self.expect(&token::RPAREN);\n-        } else if self.eat_keyword(\"return\") {\n+        } else if self.eat_keyword(keywords::Return) {\n             // RETURN expression\n             if can_begin_expr(&*self.token) {\n                 let e = self.parse_expr();\n                 hi = e.span.hi;\n                 ex = expr_ret(Some(e));\n             } else { ex = expr_ret(None); }\n-        } else if self.eat_keyword(\"break\") {\n+        } else if self.eat_keyword(keywords::Break) {\n             // BREAK expression\n             if self.token_is_lifetime(&*self.token) {\n                 let lifetime = self.get_lifetime(&*self.token);\n@@ -1340,14 +1334,14 @@ pub impl Parser {\n                 ex = expr_break(None);\n             }\n             hi = self.span.hi;\n-        } else if self.eat_keyword(\"copy\") {\n+        } else if self.eat_keyword(keywords::Copy) {\n             // COPY expression\n             let e = self.parse_expr();\n             ex = expr_copy(e);\n             hi = e.span.hi;\n         } else if *self.token == token::MOD_SEP ||\n-                is_ident(&*self.token) && !self.is_keyword(\"true\") &&\n-                !self.is_keyword(\"false\") {\n+                is_ident(&*self.token) && !self.is_keyword(keywords::True) &&\n+                !self.is_keyword(keywords::False) {\n             let pth = self.parse_path_with_tps(true);\n \n             // `!`, as an operator, is prefix, so we know this isn't that\n@@ -1827,7 +1821,7 @@ pub impl Parser {\n                     }\n                 }\n                 None => {\n-                    if as_prec > min_prec && self.eat_keyword(\"as\") {\n+                    if as_prec > min_prec && self.eat_keyword(keywords::As) {\n                         let rhs = self.parse_ty(true);\n                         let _as = self.mk_expr(lhs.span.lo,\n                                                rhs.span.hi,\n@@ -1901,7 +1895,7 @@ pub impl Parser {\n         let thn = self.parse_block();\n         let mut els: Option<@expr> = None;\n         let mut hi = thn.span.hi;\n-        if self.eat_keyword(\"else\") {\n+        if self.eat_keyword(keywords::Else) {\n             let elexpr = self.parse_else_expr();\n             els = Some(elexpr);\n             hi = elexpr.span.hi;\n@@ -1968,7 +1962,7 @@ pub impl Parser {\n     }\n \n     fn parse_else_expr(&self) -> @expr {\n-        if self.eat_keyword(\"if\") {\n+        if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n         } else {\n             let blk = self.parse_block();\n@@ -2082,7 +2076,7 @@ pub impl Parser {\n     fn looking_at_record_literal(&self) -> bool {\n         let lookahead = self.look_ahead(1);\n         *self.token == token::LBRACE &&\n-            (self.token_is_keyword(\"mut\", &lookahead) ||\n+            (token::is_keyword(keywords::Mut, &lookahead) ||\n              (is_plain_ident(&lookahead) &&\n               self.look_ahead(2) == token::COLON))\n     }\n@@ -2095,7 +2089,7 @@ pub impl Parser {\n         while *self.token != token::RBRACE {\n             let pats = self.parse_pats();\n             let mut guard = None;\n-            if self.eat_keyword(\"if\") { guard = Some(self.parse_expr()); }\n+            if self.eat_keyword(keywords::If) { guard = Some(self.parse_expr()); }\n             self.expect(&token::FAT_ARROW);\n             let expr = self.parse_expr_res(RESTRICT_STMT_EXPR);\n \n@@ -2384,8 +2378,8 @@ pub impl Parser {\n           }\n           ref tok => {\n             if !is_ident_or_path(tok)\n-                || self.is_keyword(\"true\")\n-                || self.is_keyword(\"false\")\n+                || self.is_keyword(keywords::True)\n+                || self.is_keyword(keywords::False)\n             {\n                 // Parse an expression pattern or exp .. exp.\n                 //\n@@ -2404,11 +2398,11 @@ pub impl Parser {\n                 } else {\n                     pat = pat_lit(val);\n                 }\n-            } else if self.eat_keyword(\"ref\") {\n+            } else if self.eat_keyword(keywords::Ref) {\n                 // parse ref pat\n                 let mutbl = self.parse_mutability();\n                 pat = self.parse_pat_ident(refutable, bind_by_ref(mutbl));\n-            } else if self.eat_keyword(\"copy\") {\n+            } else if self.eat_keyword(keywords::Copy) {\n                 // parse copy pat\n                 pat = self.parse_pat_ident(refutable, bind_by_copy);\n             } else {\n@@ -2558,7 +2552,7 @@ pub impl Parser {\n \n     // parse a \"let\" stmt\n     fn parse_let(&self) -> @decl {\n-        let is_mutbl = self.eat_keyword(\"mut\");\n+        let is_mutbl = self.eat_keyword(keywords::Mut);\n         let lo = self.span.lo;\n         let mut locals = ~[self.parse_local(is_mutbl)];\n         while self.eat(&token::COMMA) {\n@@ -2572,7 +2566,7 @@ pub impl Parser {\n                          pr: visibility,\n                          attrs: ~[attribute]) -> @struct_field {\n         let lo = self.span.lo;\n-        if self.eat_keyword(\"mut\") {\n+        if self.eat_keyword(keywords::Mut) {\n             // Do nothing, for backwards compatibility.\n             // XXX: Remove after snapshot.\n         }\n@@ -2604,13 +2598,13 @@ pub impl Parser {\n         }\n \n         let lo = self.span.lo;\n-        if self.is_keyword(\"let\") {\n+        if self.is_keyword(keywords::Let) {\n             check_expected_item(self, item_attrs);\n-            self.expect_keyword(\"let\");\n+            self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n             return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n         } else if is_ident(&*self.token)\n-            && !self.is_any_keyword(&copy *self.token)\n+            && !token::is_any_keyword(self.token)\n             && self.look_ahead(1) == token::NOT {\n             // parse a macro invocation. Looks like there's serious\n             // overlap here; if this clause doesn't catch it (and it\n@@ -2690,7 +2684,7 @@ pub impl Parser {\n         maybe_whole!(self, nt_block);\n \n         let lo = self.span.lo;\n-        if self.eat_keyword(\"unsafe\") {\n+        if self.eat_keyword(keywords::Unsafe) {\n             self.obsolete(copy *self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(&token::LBRACE);\n@@ -2705,7 +2699,7 @@ pub impl Parser {\n         maybe_whole!(pair_empty self, nt_block);\n \n         let lo = self.span.lo;\n-        if self.eat_keyword(\"unsafe\") {\n+        if self.eat_keyword(keywords::Unsafe) {\n             self.obsolete(copy *self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(&token::LBRACE);\n@@ -2849,18 +2843,18 @@ pub impl Parser {\n     }\n \n     fn parse_optional_purity(&self) -> ast::purity {\n-        if self.eat_keyword(\"pure\") {\n+        if self.eat_keyword(keywords::Pure) {\n             self.obsolete(*self.last_span, ObsoletePurity);\n             ast::impure_fn\n-        } else if self.eat_keyword(\"unsafe\") {\n+        } else if self.eat_keyword(keywords::Unsafe) {\n             ast::unsafe_fn\n         } else {\n             ast::impure_fn\n         }\n     }\n \n     fn parse_optional_onceness(&self) -> ast::Onceness {\n-        if self.eat_keyword(\"once\") { ast::Once } else { ast::Many }\n+        if self.eat_keyword(keywords::Once) { ast::Once } else { ast::Many }\n     }\n \n     // matches optbounds = ( ( : ( boundseq )? )? )\n@@ -3023,10 +3017,10 @@ pub impl Parser {\n             p: &Parser\n         ) -> ast::explicit_self_ {\n             // We need to make sure it isn't a mode or a type\n-            if p.token_is_keyword(\"self\", &p.look_ahead(1)) ||\n-                ((p.token_is_keyword(\"const\", &p.look_ahead(1)) ||\n-                  p.token_is_keyword(\"mut\", &p.look_ahead(1))) &&\n-                 p.token_is_keyword(\"self\", &p.look_ahead(2))) {\n+            if token::is_keyword(keywords::Self, &p.look_ahead(1)) ||\n+                ((token::is_keyword(keywords::Const, &p.look_ahead(1)) ||\n+                  token::is_keyword(keywords::Mut, &p.look_ahead(1))) &&\n+                 token::is_keyword(keywords::Self, &p.look_ahead(2))) {\n \n                 p.bump();\n                 let mutability = p.parse_mutability();\n@@ -3047,25 +3041,25 @@ pub impl Parser {\n             //\n             // We already know that the current token is `&`.\n \n-            if (this.token_is_keyword(\"self\", &this.look_ahead(1))) {\n+            if (token::is_keyword(keywords::Self, &this.look_ahead(1))) {\n                 this.bump();\n                 this.expect_self_ident();\n                 sty_region(None, m_imm)\n             } else if (this.token_is_mutability(&this.look_ahead(1)) &&\n-                       this.token_is_keyword(\"self\", &this.look_ahead(2))) {\n+                       token::is_keyword(keywords::Self, &this.look_ahead(2))) {\n                 this.bump();\n                 let mutability = this.parse_mutability();\n                 this.expect_self_ident();\n                 sty_region(None, mutability)\n             } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n-                       this.token_is_keyword(\"self\", &this.look_ahead(2))) {\n+                       token::is_keyword(keywords::Self, &this.look_ahead(2))) {\n                 this.bump();\n                 let lifetime = @this.parse_lifetime();\n                 this.expect_self_ident();\n                 sty_region(Some(lifetime), m_imm)\n             } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n                        this.token_is_mutability(&this.look_ahead(2)) &&\n-                       this.token_is_keyword(\"self\", &this.look_ahead(3))) {\n+                       token::is_keyword(keywords::Self, &this.look_ahead(3))) {\n                 this.bump();\n                 let lifetime = @this.parse_lifetime();\n                 let mutability = this.parse_mutability();\n@@ -3274,7 +3268,7 @@ pub impl Parser {\n         let mut ty = self.parse_ty(false);\n \n         // Parse traits, if necessary.\n-        let opt_trait = if could_be_trait && self.eat_keyword(\"for\") {\n+        let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n                 ty_path(path, node_id) => {\n@@ -3449,11 +3443,11 @@ pub impl Parser {\n             return ~[];\n         }\n \n-        if self.eat_keyword(\"priv\") {\n+        if self.eat_keyword(keywords::Priv) {\n             return ~[self.parse_single_struct_field(private, attrs)]\n         }\n \n-        if self.eat_keyword(\"pub\") {\n+        if self.eat_keyword(keywords::Pub) {\n            return ~[self.parse_single_struct_field(public, attrs)];\n         }\n \n@@ -3466,13 +3460,13 @@ pub impl Parser {\n \n     // parse visiility: PUB, PRIV, or nothing\n     fn parse_visibility(&self) -> visibility {\n-        if self.eat_keyword(\"pub\") { public }\n-        else if self.eat_keyword(\"priv\") { private }\n+        if self.eat_keyword(keywords::Pub) { public }\n+        else if self.eat_keyword(keywords::Priv) { private }\n         else { inherited }\n     }\n \n     fn parse_staticness(&self) -> bool {\n-        if self.eat_keyword(\"static\") {\n+        if self.eat_keyword(keywords::Static) {\n             self.obsolete(*self.last_span, ObsoleteStaticMethod);\n             true\n         } else {\n@@ -3692,10 +3686,10 @@ pub impl Parser {\n         let lo = self.span.lo;\n \n         // XXX: Obsolete; remove after snap.\n-        if self.eat_keyword(\"const\") {\n+        if self.eat_keyword(keywords::Const) {\n             self.obsolete(*self.last_span, ObsoleteConstItem);\n         } else {\n-            self.expect_keyword(\"static\");\n+            self.expect_keyword(keywords::Static);\n         }\n \n         let ident = self.parse_ident();\n@@ -3713,14 +3707,14 @@ pub impl Parser {\n \n     // parse safe/unsafe and fn\n     fn parse_fn_purity(&self) -> purity {\n-        if self.eat_keyword(\"fn\") { impure_fn }\n-        else if self.eat_keyword(\"pure\") {\n+        if self.eat_keyword(keywords::Fn) { impure_fn }\n+        else if self.eat_keyword(keywords::Pure) {\n             self.obsolete(*self.last_span, ObsoletePurity);\n-            self.expect_keyword(\"fn\");\n+            self.expect_keyword(keywords::Fn);\n             // NB: We parse this as impure for bootstrapping purposes.\n             impure_fn\n-        } else if self.eat_keyword(\"unsafe\") {\n-            self.expect_keyword(\"fn\");\n+        } else if self.eat_keyword(keywords::Unsafe) {\n+            self.expect_keyword(keywords::Fn);\n             unsafe_fn\n         }\n         else { self.unexpected(); }\n@@ -3762,9 +3756,9 @@ pub impl Parser {\n                               items_allowed: bool)\n                               -> item_or_view_item {\n         let mut must_be_named_mod = false;\n-        if self.is_keyword(\"mod\") {\n+        if self.is_keyword(keywords::Mod) {\n             must_be_named_mod = true;\n-            self.expect_keyword(\"mod\");\n+            self.expect_keyword(keywords::Mod);\n         } else if *self.token != token::LBRACE {\n             self.span_fatal(\n                 copy *self.span,\n@@ -4049,7 +4043,7 @@ pub impl Parser {\n         let visibility = self.parse_visibility();\n \n         // must be a view item:\n-        if self.eat_keyword(\"use\") {\n+        if self.eat_keyword(keywords::Use) {\n             // USE ITEM (iovi_view_item)\n             let view_item = self.parse_use();\n             self.expect(&token::SEMI);\n@@ -4061,10 +4055,10 @@ pub impl Parser {\n             });\n         }\n         // either a view item or an item:\n-        if self.eat_keyword(\"extern\") {\n+        if self.eat_keyword(keywords::Extern) {\n             let opt_abis = self.parse_opt_abis();\n \n-            if self.eat_keyword(\"fn\") {\n+            if self.eat_keyword(keywords::Fn) {\n                 // EXTERN FUNCTION ITEM\n                 let abis = opt_abis.get_or_default(AbiSet::C());\n                 let (ident, item_, extra_attrs) =\n@@ -4080,11 +4074,11 @@ pub impl Parser {\n             }\n         }\n         // the rest are all guaranteed to be items:\n-        if (self.is_keyword(\"const\") ||\n-            (self.is_keyword(\"static\") &&\n-             !self.token_is_keyword(\"fn\", &self.look_ahead(1)))) {\n+        if (self.is_keyword(keywords::Const) ||\n+            (self.is_keyword(keywords::Static) &&\n+             !token::is_keyword(keywords::Fn, &self.look_ahead(1)))) {\n             // CONST / STATIC ITEM\n-            if self.is_keyword(\"const\") {\n+            if self.is_keyword(keywords::Const) {\n                 self.obsolete(*self.span, ObsoleteConstItem);\n             }\n             self.bump();\n@@ -4093,7 +4087,7 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.is_keyword(\"fn\") &&\n+        if self.is_keyword(keywords::Fn) &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n             // FUNCTION ITEM\n             self.bump();\n@@ -4103,65 +4097,65 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(\"pure\") {\n+        if self.eat_keyword(keywords::Pure) {\n             // PURE FUNCTION ITEM (obsolete)\n             self.obsolete(*self.last_span, ObsoletePurity);\n-            self.expect_keyword(\"fn\");\n+            self.expect_keyword(keywords::Fn);\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(impure_fn, AbiSet::Rust());\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.is_keyword(\"unsafe\")\n+        if self.is_keyword(keywords::Unsafe)\n             && self.look_ahead(1u) != token::LBRACE {\n             // UNSAFE FUNCTION ITEM\n             self.bump();\n-            self.expect_keyword(\"fn\");\n+            self.expect_keyword(keywords::Fn);\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(unsafe_fn, AbiSet::Rust());\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(\"mod\") {\n+        if self.eat_keyword(keywords::Mod) {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_mod(/*bad*/ copy attrs);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(\"type\") {\n+        if self.eat_keyword(keywords::Type) {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(\"enum\") {\n+        if self.eat_keyword(keywords::Enum) {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(\"trait\") {\n+        if self.eat_keyword(keywords::Trait) {\n             // TRAIT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(\"impl\") {\n+        if self.eat_keyword(keywords::Impl) {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_impl(visibility);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(\"struct\") {\n+        if self.eat_keyword(keywords::Struct) {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n@@ -4182,13 +4176,13 @@ pub impl Parser {\n \n         let visibility = self.parse_visibility();\n \n-        if (self.is_keyword(\"const\") || self.is_keyword(\"static\")) {\n+        if (self.is_keyword(keywords::Const) || self.is_keyword(keywords::Static)) {\n             // FOREIGN CONST ITEM\n             let item = self.parse_item_foreign_const(visibility, attrs);\n             return iovi_foreign_item(item);\n         }\n-        if (self.is_keyword(\"fn\") || self.is_keyword(\"pure\") ||\n-                self.is_keyword(\"unsafe\")) {\n+        if (self.is_keyword(keywords::Fn) || self.is_keyword(keywords::Pure) ||\n+                self.is_keyword(keywords::Unsafe)) {\n             // FOREIGN FUNCTION ITEM\n             let item = self.parse_item_foreign_fn(attrs);\n             return iovi_foreign_item(item);\n@@ -4204,7 +4198,7 @@ pub impl Parser {\n         lo : BytePos,\n         visibility : visibility\n     ) -> item_or_view_item {\n-        if macros_allowed && !self.is_any_keyword(&copy *self.token)\n+        if macros_allowed && !token::is_any_keyword(self.token)\n                 && self.look_ahead(1) == token::NOT\n                 && (is_plain_ident(&self.look_ahead(2))\n                     || self.look_ahead(2) == token::LPAREN\n@@ -4379,16 +4373,16 @@ pub impl Parser {\n \n     fn is_view_item(&self) -> bool {\n         let tok, next_tok;\n-        if !self.is_keyword(\"pub\") && !self.is_keyword(\"priv\") {\n+        if !self.is_keyword(keywords::Pub) && !self.is_keyword(keywords::Priv) {\n             tok = copy *self.token;\n             next_tok = self.look_ahead(1);\n         } else {\n             tok = self.look_ahead(1);\n             next_tok = self.look_ahead(2);\n         };\n-        self.token_is_keyword(\"use\", &tok)\n-            || (self.token_is_keyword(\"extern\", &tok) &&\n-                self.token_is_keyword(\"mod\", &next_tok))\n+        token::is_keyword(keywords::Use, &tok)\n+            || (token::is_keyword(keywords::Extern, &tok) &&\n+                token::is_keyword(keywords::Mod, &next_tok))\n     }\n \n     // parse a view item.\n@@ -4398,10 +4392,10 @@ pub impl Parser {\n         vis: visibility\n     ) -> @view_item {\n         let lo = self.span.lo;\n-        let node = if self.eat_keyword(\"use\") {\n+        let node = if self.eat_keyword(keywords::Use) {\n             self.parse_use()\n-        } else if self.eat_keyword(\"extern\") {\n-            self.expect_keyword(\"mod\");\n+        } else if self.eat_keyword(keywords::Extern) {\n+            self.expect_keyword(keywords::Mod);\n             let ident = self.parse_ident();\n             let metadata = self.parse_optional_meta();\n             view_item_extern_mod(ident, metadata, self.get_id())"}, {"sha": "56b1ed5d5c7f823520b4e8b3a5bbd1fafc2c2881", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 156, "deletions": 45, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/9d37d038fef95408bffadc8701adcd7b5a663894/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d37d038fef95408bffadc8701adcd7b5a663894/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9d37d038fef95408bffadc8701adcd7b5a663894", "patch": "@@ -17,7 +17,6 @@ use util::interner::StrInterner;\n use util::interner;\n \n use core::cmp::Equiv;\n-use core::hashmap::HashSet;\n use core::to_bytes;\n \n #[deriving(Encodable, Decodable, Eq)]\n@@ -452,6 +451,45 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n         \"__field__\",          // 32\n         \"C\",                  // 33\n         \"Self\",               // 34\n+\n+        \"as\",                 // 35\n+        \"break\",              // 36\n+        \"const\",              // 37\n+        \"copy\",               // 38\n+        \"do\",                 // 39\n+        \"drop\",               // 40\n+        \"else\",               // 41\n+        \"enum\",               // 42\n+        \"extern\",             // 43\n+        \"false\",              // 44\n+        \"fn\",                 // 45\n+        \"for\",                // 46\n+        \"if\",                 // 47\n+        \"impl\",               // 48\n+        \"let\",                // 49\n+        \"__log\",              // 50\n+        \"loop\",               // 51\n+        \"match\",              // 52\n+        \"mod\",                // 53\n+        \"mut\",                // 54\n+        \"once\",               // 55\n+        \"priv\",               // 56\n+        \"pub\",                // 57\n+        \"pure\",               // 58\n+        \"ref\",                // 59\n+        \"return\",             // 60\n+        \"static\",             // 29 -- also a special ident\n+        \"self\",               //  8 -- also a special ident\n+        \"struct\",             // 61\n+        \"super\",              // 62\n+        \"true\",               // 63\n+        \"trait\",              // 64\n+        \"type\",               // 65\n+        \"unsafe\",             // 66\n+        \"use\",                // 67\n+        \"while\",              // 68\n+\n+        \"be\",                 // 69\n     ];\n \n     @ident_interner {\n@@ -495,61 +533,134 @@ pub fn intern(str : &str) -> ast::ident {\n /**\n  * All the valid words that have meaning in the Rust language.\n  *\n- * Rust keywords are either 'temporary', 'strict' or 'reserved'.  Temporary\n- * keywords are contextual and may be used as identifiers anywhere.  They are\n- * expected to disappear from the grammar soon.  Strict keywords may not\n+ * Rust keywords are either 'strict' or 'reserved'.  Strict keywords may not\n  * appear as identifiers at all. Reserved keywords are not used anywhere in\n  * the language and may not appear as identifiers.\n  */\n-pub fn keyword_table() -> HashSet<~str> {\n-    let mut keywords = HashSet::new();\n-    let mut strict = strict_keyword_table();\n-    let mut reserved = reserved_keyword_table();\n+pub mod keywords {\n+    use ast::ident;\n+\n+    pub enum Keyword {\n+        // Strict keywords\n+        As,\n+        Break,\n+        Const,\n+        Copy,\n+        Do,\n+        Drop,\n+        Else,\n+        Enum,\n+        Extern,\n+        False,\n+        Fn,\n+        For,\n+        If,\n+        Impl,\n+        Let,\n+        __Log,\n+        Loop,\n+        Match,\n+        Mod,\n+        Mut,\n+        Once,\n+        Priv,\n+        Pub,\n+        Pure,\n+        Ref,\n+        Return,\n+        Static,\n+        Self,\n+        Struct,\n+        Super,\n+        True,\n+        Trait,\n+        Type,\n+        Unsafe,\n+        Use,\n+        While,\n+\n+        // Reserved keywords\n+        Be,\n+    }\n \n-    do strict.consume |word| {\n-        keywords.insert(word);\n+    pub impl Keyword {\n+        fn to_ident(&self) -> ident {\n+            match *self {\n+                As => ident { repr: 35, ctxt: 0 },\n+                   Break => ident { repr: 36, ctxt: 0 },\n+                   Const => ident { repr: 37, ctxt: 0 },\n+                   Copy => ident { repr: 38, ctxt: 0 },\n+                   Do => ident { repr: 39, ctxt: 0 },\n+                   Drop => ident { repr: 40, ctxt: 0 },\n+                   Else => ident { repr: 41, ctxt: 0 },\n+                   Enum => ident { repr: 42, ctxt: 0 },\n+                   Extern => ident { repr: 43, ctxt: 0 },\n+                   False => ident { repr: 44, ctxt: 0 },\n+                   Fn => ident { repr: 45, ctxt: 0 },\n+                   For => ident { repr: 46, ctxt: 0 },\n+                   If => ident { repr: 47, ctxt: 0 },\n+                   Impl => ident { repr: 48, ctxt: 0 },\n+                   Let => ident { repr: 49, ctxt: 0 },\n+                   __Log => ident { repr: 50, ctxt: 0 },\n+                   Loop => ident { repr: 51, ctxt: 0 },\n+                   Match => ident { repr: 52, ctxt: 0 },\n+                   Mod => ident { repr: 53, ctxt: 0 },\n+                   Mut => ident { repr: 54, ctxt: 0 },\n+                   Once => ident { repr: 55, ctxt: 0 },\n+                   Priv => ident { repr: 56, ctxt: 0 },\n+                   Pub => ident { repr: 57, ctxt: 0 },\n+                   Pure => ident { repr: 58, ctxt: 0 },\n+                   Ref => ident { repr: 59, ctxt: 0 },\n+                   Return => ident { repr: 60, ctxt: 0 },\n+                   Static => ident { repr: 29, ctxt: 0 },\n+                   Self => ident { repr: 8, ctxt: 0 },\n+                   Struct => ident { repr: 61, ctxt: 0 },\n+                   Super => ident { repr: 62, ctxt: 0 },\n+                   True => ident { repr: 63, ctxt: 0 },\n+                   Trait => ident { repr: 64, ctxt: 0 },\n+                   Type => ident { repr: 65, ctxt: 0 },\n+                   Unsafe => ident { repr: 66, ctxt: 0 },\n+                   Use => ident { repr: 67, ctxt: 0 },\n+                   While => ident { repr: 68, ctxt: 0 },\n+                   Be => ident { repr: 69, ctxt: 0 },\n+            }\n+        }\n     }\n-    do reserved.consume |word| {\n-        keywords.insert(word);\n+}\n+\n+pub fn is_keyword(kw: keywords::Keyword, tok: &Token) -> bool {\n+    match *tok {\n+        token::IDENT(sid, false) => { kw.to_ident().repr == sid.repr }\n+        _ => { false }\n     }\n+}\n \n-    keywords\n+pub fn is_any_keyword(tok: &Token) -> bool {\n+    match *tok {\n+        token::IDENT(sid, false) => match sid.repr {\n+            8 | 29 | 35 .. 69 => true,\n+            _ => false,\n+        },\n+        _ => false\n+    }\n }\n \n-/// Full keywords. May not appear anywhere else.\n-pub fn strict_keyword_table() -> HashSet<~str> {\n-    let mut words = HashSet::new();\n-    let keys = ~[\n-        ~\"as\",\n-        ~\"break\",\n-        ~\"const\", ~\"copy\",\n-        ~\"do\", ~\"drop\",\n-        ~\"else\", ~\"enum\", ~\"extern\",\n-        ~\"false\", ~\"fn\", ~\"for\",\n-        ~\"if\", ~\"impl\",\n-        ~\"let\", ~\"__log\", ~\"loop\",\n-        ~\"match\", ~\"mod\", ~\"mut\",\n-        ~\"once\",\n-        ~\"priv\", ~\"pub\", ~\"pure\",\n-        ~\"ref\", ~\"return\",\n-        ~\"static\", ~\"self\", ~\"struct\", ~\"super\",\n-        ~\"true\", ~\"trait\", ~\"type\",\n-        ~\"unsafe\", ~\"use\",\n-        ~\"while\"\n-    ];\n-    do vec::consume(keys) |_, w| {\n-        words.insert(w);\n+pub fn is_strict_keyword(tok: &Token) -> bool {\n+    match *tok {\n+        token::IDENT(sid, false) => match sid.repr {\n+            8 | 29 | 35 .. 68 => true,\n+            _ => false,\n+        },\n+        _ => false,\n     }\n-    return words;\n }\n \n-pub fn reserved_keyword_table() -> HashSet<~str> {\n-    let mut words = HashSet::new();\n-    let keys = ~[\n-        ~\"be\"\n-    ];\n-    do vec::consume(keys) |_, s| {\n-        words.insert(s);\n+pub fn is_reserved_keyword(tok: &Token) -> bool {\n+    match *tok {\n+        token::IDENT(sid, false) => match sid.repr {\n+            69 => true,\n+            _ => false,\n+        },\n+        _ => false,\n     }\n-    return words;\n }"}]}