{"sha": "630627c3d43c17a6a657e7b91b754c45929a5bf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMDYyN2MzZDQzYzE3YTZhNjU3ZTdiOTFiNzU0YzQ1OTI5YTViZjY=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-29T15:44:45Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-29T23:48:17Z"}, "message": "std: Implement RandomAccessIterator for iterator adaptors\n\nImplement RAI where possible for iterator adaptors such as Map,\nEnumerate, Skip, Take, Zip, Cycle (all of the requiring that the adapted\niterator also implements RAI).", "tree": {"sha": "fe90b688d3c4f05e39ab5ac5a890471637695716", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe90b688d3c4f05e39ab5ac5a890471637695716"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/630627c3d43c17a6a657e7b91b754c45929a5bf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/630627c3d43c17a6a657e7b91b754c45929a5bf6", "html_url": "https://github.com/rust-lang/rust/commit/630627c3d43c17a6a657e7b91b754c45929a5bf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/630627c3d43c17a6a657e7b91b754c45929a5bf6/comments", "author": null, "committer": null, "parents": [{"sha": "5d4af58c1d2abc0895d170185796e837f37b16cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d4af58c1d2abc0895d170185796e837f37b16cb", "html_url": "https://github.com/rust-lang/rust/commit/5d4af58c1d2abc0895d170185796e837f37b16cb"}], "stats": {"total": 160, "additions": 142, "deletions": 18}, "files": [{"sha": "a432546f8d092c0579e9a34c14b8094c13b8a5c8", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 142, "deletions": 18, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/630627c3d43c17a6a657e7b91b754c45929a5bf6/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630627c3d43c17a6a657e7b91b754c45929a5bf6/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=630627c3d43c17a6a657e7b91b754c45929a5bf6", "patch": "@@ -811,6 +811,30 @@ impl<A, T: Clone + Iterator<A>> Iterator<A> for Cycle<T> {\n     }\n }\n \n+impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        if self.orig.indexable() > 0 {\n+            uint::max_value\n+        } else {\n+            0\n+        }\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        let liter = self.iter.indexable();\n+        let lorig = self.orig.indexable();\n+        if lorig == 0 {\n+            None\n+        } else if index < liter {\n+            self.iter.idx(index)\n+        } else {\n+            self.orig.idx((index - liter) % lorig)\n+        }\n+    }\n+}\n+\n /// An iterator which strings two iterators together\n #[deriving(Clone)]\n pub struct Chain<T, U> {\n@@ -924,20 +948,44 @@ impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for Zip<T, U> {\n     }\n }\n \n+impl<A, B, T: RandomAccessIterator<A>, U: RandomAccessIterator<B>>\n+RandomAccessIterator<(A, B)> for Zip<T, U> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        cmp::min(self.a.indexable(), self.b.indexable())\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<(A, B)> {\n+        match (self.a.idx(index), self.b.idx(index)) {\n+            (Some(x), Some(y)) => Some((x, y)),\n+            _ => None\n+        }\n+    }\n+}\n+\n /// An iterator which maps the values of `iter` with `f`\n pub struct Map<'self, A, B, T> {\n     priv iter: T,\n     priv f: &'self fn(A) -> B\n }\n \n-impl<'self, A, B, T: Iterator<A>> Iterator<B> for Map<'self, A, B, T> {\n+impl<'self, A, B, T> Map<'self, A, B, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        match self.iter.next() {\n+    fn do_map(&self, elt: Option<A>) -> Option<B> {\n+        match elt {\n             Some(a) => Some((self.f)(a)),\n             _ => None\n         }\n     }\n+}\n+\n+impl<'self, A, B, T: Iterator<A>> Iterator<B> for Map<'self, A, B, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        let next = self.iter.next();\n+        self.do_map(next)\n+    }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n@@ -949,10 +997,21 @@ impl<'self, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B>\n for Map<'self, A, B, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n-        match self.iter.next_back() {\n-            Some(a) => Some((self.f)(a)),\n-            _ => None\n-        }\n+        let next = self.iter.next_back();\n+        self.do_map(next)\n+    }\n+}\n+\n+impl<'self, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B>\n+for Map<'self, A, B, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.iter.indexable()\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<B> {\n+        self.do_map(self.iter.idx(index))\n     }\n }\n \n@@ -1069,6 +1128,21 @@ impl<A, T: Iterator<A>> Iterator<(uint, A)> for Enumerate<T> {\n     }\n }\n \n+impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerate<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.iter.indexable()\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<(uint, A)> {\n+        match self.iter.idx(index) {\n+            Some(a) => Some((self.count + index, a)),\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// An iterator which rejects elements while `predicate` is true\n pub struct SkipWhile<'self, A, T> {\n     priv iter: T,\n@@ -1189,6 +1263,27 @@ impl<A, T: Iterator<A>> Iterator<A> for Skip<T> {\n     }\n }\n \n+impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        let N = self.iter.indexable();\n+        if N < self.n {\n+            0\n+        } else {\n+            N - self.n\n+        }\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        if index >= self.indexable() {\n+            None\n+        } else {\n+            self.iter.idx(index + self.n)\n+        }\n+    }\n+}\n+\n /// An iterator which only iterates over the first `n` iterations of `iter`.\n #[deriving(Clone)]\n pub struct Take<T> {\n@@ -1223,6 +1318,23 @@ impl<A, T: Iterator<A>> Iterator<A> for Take<T> {\n     }\n }\n \n+impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        cmp::min(self.iter.indexable(), self.n)\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        if index >= self.n {\n+            None\n+        } else {\n+            self.iter.idx(index)\n+        }\n+    }\n+}\n+\n+\n /// An iterator to maintain state while iterating another iterator\n pub struct Scan<'self, A, B, T, St> {\n     priv iter: T,\n@@ -1311,17 +1423,23 @@ pub struct Peek<'self, A, T> {\n     priv f: &'self fn(&A)\n }\n \n-impl<'self, A, T: Iterator<A>> Iterator<A> for Peek<'self, A, T> {\n+impl<'self, A, T> Peek<'self, A, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        let next = self.iter.next();\n-\n-        match next {\n+    fn do_peek(&self, elt: Option<A>) -> Option<A> {\n+        match elt {\n             Some(ref a) => (self.f)(a),\n             None => ()\n         }\n \n-        next\n+        elt\n+    }\n+}\n+\n+impl<'self, A, T: Iterator<A>> Iterator<A> for Peek<'self, A, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let next = self.iter.next();\n+        self.do_peek(next)\n     }\n \n     #[inline]\n@@ -1334,13 +1452,19 @@ impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Peek<'self,\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         let next = self.iter.next_back();\n+        self.do_peek(next)\n+    }\n+}\n \n-        match next {\n-            Some(ref a) => (self.f)(a),\n-            None => ()\n-        }\n+impl<'self, A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Peek<'self, A, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.iter.indexable()\n+    }\n \n-        next\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        self.do_peek(self.iter.idx(index))\n     }\n }\n "}]}