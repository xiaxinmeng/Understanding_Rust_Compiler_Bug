{"sha": "ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMTBlOTQ5OTNmNmU0YjA0YjI4M2U0MTRiMDRlZDAyZWM5ZjZjOTk=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-18T19:28:06Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-23T12:18:35Z"}, "message": "Correctly handle named lifetimes.\n\nEnhances annotation logic to properly consider named lifetimes where\nlifetime elision rules that were previously implemented would not apply.\n\nFurther, adds new help and note messages to diagnostics and highlights\nonly lifetime when dealing with named lifetimes.", "tree": {"sha": "c1f7dbaf71cea40e40e99b45a661d726b621397a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1f7dbaf71cea40e40e99b45a661d726b621397a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlunhJsACgkQAXYLT59T\n8VRYGg/9G+7cxuiJb4xUJOFpLIpx508Ie3eNActGp7BHKDYVUAL9zTN18RXSYs0b\nPcFLFPbW+0YNOwHWWEJCVQmvlLY/hBAE7MIViNBARdeVTkwm4ectXRgpc8W/ubqJ\nx4rlxV8xzlxPCjCi+3lVImJZCHuWCLRmvWsLD8XGQOytO9KnWW30bNmBif4MCDe/\nskFEE3YgjxQcyhbM186T8JACnN6btkXSO8LftPqo26urRJXRaeStcmxrrtxmZhJS\nfv5QGWfuamSlL68wUQQEPszcfBniGMvEBsFkq3u46dKx/7QfGjKXaNdb9BaWOooI\nRV7l2ABbhKsiO2VZ6m5r4j5JeGHWxX1cg7ZlIr2TzjIgGfL9syu//qr3bZudhxwJ\naXpX2ZklsWwHRunb0WaltdDKFejPN3xCCghXyYK7GyhBVMSBNAcWO47cJZdqoTck\nKQ9VaGWpnJRB8W45zEqpIjC52tVTXC1IzLnM2envcQUBmKOYg8ec6/y20KcNrvCB\nlwRelw8My9GyzgHXud4uJsBmwuje+OZCaF0xMtt0xsYhDEB9WxcPG8w9DmrA92/2\nUuWCiB4l2qRXpfJ9+xE13b/ymVgmCiYnQ0fOHaJwe0zfXP52mvmSvYl4pVQ/6c8f\nXwVanuvvVEf57cRSsiDXFvHMwdFwv+Y/bjhrDeMUNimHzmifKFA=\n=rDlE\n-----END PGP SIGNATURE-----", "payload": "tree c1f7dbaf71cea40e40e99b45a661d726b621397a\nparent 0eabba8c4ca0a65819b3a5a27b52193505f1259c\nauthor David Wood <david@davidtw.co> 1537298886 +0200\ncommitter David Wood <david@davidtw.co> 1537705115 +0200\n\nCorrectly handle named lifetimes.\n\nEnhances annotation logic to properly consider named lifetimes where\nlifetime elision rules that were previously implemented would not apply.\n\nFurther, adds new help and note messages to diagnostics and highlights\nonly lifetime when dealing with named lifetimes.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "html_url": "https://github.com/rust-lang/rust/commit/ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0eabba8c4ca0a65819b3a5a27b52193505f1259c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eabba8c4ca0a65819b3a5a27b52193505f1259c", "html_url": "https://github.com/rust-lang/rust/commit/0eabba8c4ca0a65819b3a5a27b52193505f1259c"}], "stats": {"total": 430, "additions": 319, "deletions": 111}, "files": [{"sha": "8fb5ed66a82ef311525424b086190e97d29e87fd", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "patch": "@@ -1324,6 +1324,23 @@ impl_stable_hash_for!(struct DebruijnIndex { private });\n \n /// Region utilities\n impl RegionKind {\n+    /// Is this region named by the user?\n+    pub fn has_name(&self) -> bool {\n+        match *self {\n+            RegionKind::ReEarlyBound(ebr) => ebr.has_name(),\n+            RegionKind::ReLateBound(_, br) => br.is_named(),\n+            RegionKind::ReFree(fr) => fr.bound_region.is_named(),\n+            RegionKind::ReScope(..) => false,\n+            RegionKind::ReStatic => true,\n+            RegionKind::ReVar(..) => false,\n+            RegionKind::ReSkolemized(_, br) => br.is_named(),\n+            RegionKind::ReEmpty => false,\n+            RegionKind::ReErased => false,\n+            RegionKind::ReClosureBound(..) => false,\n+            RegionKind::ReCanonical(..) => false,\n+        }\n+    }\n+\n     pub fn is_late_bound(&self) -> bool {\n         match *self {\n             ty::ReLateBound(..) => true,"}, {"sha": "cc1203a236d83f7960ca515cade0854eb43a07a4", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 189, "deletions": 91, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "patch": "@@ -17,6 +17,7 @@ use rustc::mir::{\n     LocalDecl, LocalKind, Location, Operand, Place, ProjectionElem, Rvalue, Statement,\n     StatementKind, VarBindingForm,\n };\n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n@@ -524,10 +525,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 err.span_label(\n                     drop_span,\n                     format!(\n-                        \"...but `{}` is only valid for the duration of the `{}` function, so it \\\n-                         is dropped here while still borrowed\",\n-                        name,\n-                        self.infcx.tcx.hir.name(fn_node_id),\n+                        \"but `{}` will be dropped here, when the function `{}` returns\",\n+                        name, self.infcx.tcx.hir.name(fn_node_id),\n                     )\n                 );\n \n@@ -1235,67 +1234,137 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let fn_node_id = self.infcx.tcx.hir.as_local_node_id(did)?;\n         let fn_decl = self.infcx.tcx.hir.fn_decl(fn_node_id)?;\n \n-        // If there is one argument and this error is being reported, that means\n-        // that the lifetime of the borrow could not be made to match the single\n-        // argument's lifetime. We can highlight it.\n+        // We need to work out which arguments to highlight. We do this by looking\n+        // at the return type, where there are three cases:\n         //\n-        // If there is more than one argument and this error is being reported, that\n-        // means there must be a self parameter - as otherwise there would be an error\n-        // from lifetime elision and not this. So we highlight the self parameter.\n-        let argument_span = fn_decl.inputs.first()?.span;\n-        let argument_ty = sig.inputs().skip_binder().first()?;\n-        if is_closure {\n-            // Closure arguments are wrapped in a tuple, so we need to get the first\n-            // from that.\n-            let argument_ty = if let ty::TyKind::Tuple(elems) = argument_ty.sty {\n-                let argument_ty = elems.first()?;\n-                if let ty::TyKind::Ref(_, _, _) = argument_ty.sty {\n-                    argument_ty\n-                } else {\n+        // 1. If there are named arguments, then we should highlight the return type and\n+        //    highlight any of the arguments that are also references with that lifetime.\n+        //    If there are no arguments that have the same lifetime as the return type,\n+        //    then don't highlight anything.\n+        // 2. The return type is a reference with an anonymous lifetime. If this is\n+        //    the case, then we can take advantage of (and teach) the lifetime elision\n+        //    rules.\n+        //\n+        //    We know that an error is being reported. So the arguments and return type\n+        //    must satisfy the elision rules. Therefore, if there is a single argument\n+        //    then that means the return type and first (and only) argument have the same\n+        //    lifetime and the borrow isn't meeting that, we can highlight the argument\n+        //    and return type.\n+        //\n+        //    If there are multiple arguments then the first argument must be self (else\n+        //    it would not satisfy the elision rules), so we can highlight self and the\n+        //    return type.\n+        // 3. The return type is not a reference. In this case, we don't highlight\n+        //    anything.\n+        let return_ty = sig.output();\n+        match return_ty.skip_binder().sty {\n+            ty::TyKind::Ref(return_region, _, _) if return_region.has_name() && !is_closure => {\n+                // This is case 1 from above, return type is a named reference so we need to\n+                // search for relevant arguments.\n+                let mut arguments = Vec::new();\n+                for (index, argument) in sig.inputs().skip_binder().iter().enumerate() {\n+                    if let ty::TyKind::Ref(argument_region, _, _) = argument.sty {\n+                        if argument_region == return_region {\n+                            // Need to use the `rustc::ty` types to compare against the\n+                            // `return_region`. Then use the `rustc::hir` type to get only\n+                            // the lifetime span.\n+                            match &fn_decl.inputs[index].node {\n+                                hir::TyKind::Rptr(lifetime, _) => {\n+                                    // With access to the lifetime, we can get\n+                                    // the span of it.\n+                                    arguments.push((*argument, lifetime.span));\n+                                },\n+                                _ => bug!(\"ty type is a ref but hir type is not\"),\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // We need to have arguments. This shouldn't happen, but it's worth checking.\n+                if arguments.is_empty() {\n                     return None;\n                 }\n-            } else {\n-                return None\n-            };\n \n-            Some(AnnotatedBorrowFnSignature::Closure {\n-                argument_ty,\n-                argument_span,\n-            })\n-        } else if let ty::TyKind::Ref(argument_region, _, _) = argument_ty.sty {\n-            // We only consider the return type for functions.\n-            let return_span = fn_decl.output.span();\n-\n-            let return_ty = sig.output();\n-            let (return_region, return_ty) = if let ty::TyKind::Ref(\n-                return_region, _, _\n-            ) = return_ty.skip_binder().sty {\n-                (return_region, *return_ty.skip_binder())\n-            } else {\n-                return None;\n-            };\n+                // We use a mix of the HIR and the Ty types to get information\n+                // as the HIR doesn't have full types for closure arguments.\n+                let return_ty = *sig.output().skip_binder();\n+                let mut return_span = fn_decl.output.span();\n+                if let hir::FunctionRetTy::Return(ty) = fn_decl.output {\n+                    if let hir::TyKind::Rptr(lifetime, _) = ty.into_inner().node {\n+                        return_span = lifetime.span;\n+                    }\n+                }\n \n-            Some(AnnotatedBorrowFnSignature::Function {\n-                argument_ty,\n-                argument_span,\n-                return_ty,\n-                return_span,\n-                regions_equal: return_region == argument_region,\n-            })\n-        } else {\n-            None\n+                Some(AnnotatedBorrowFnSignature::NamedFunction {\n+                    arguments,\n+                    return_ty,\n+                    return_span,\n+                })\n+            },\n+            ty::TyKind::Ref(_, _, _) if is_closure => {\n+                // This is case 2 from above but only for closures, return type is anonymous\n+                // reference so we select\n+                // the first argument.\n+                let argument_span = fn_decl.inputs.first()?.span;\n+                let argument_ty = sig.inputs().skip_binder().first()?;\n+\n+                // Closure arguments are wrapped in a tuple, so we need to get the first\n+                // from that.\n+                if let ty::TyKind::Tuple(elems) = argument_ty.sty {\n+                    let argument_ty = elems.first()?;\n+                    if let ty::TyKind::Ref(_, _, _) = argument_ty.sty {\n+                        return Some(AnnotatedBorrowFnSignature::Closure {\n+                            argument_ty,\n+                            argument_span,\n+                        });\n+                    }\n+                }\n+\n+                None\n+            },\n+            ty::TyKind::Ref(_, _, _) => {\n+                // This is also case 2 from above but for functions, return type is still an\n+                // anonymous reference so we select the first argument.\n+                let argument_span = fn_decl.inputs.first()?.span;\n+                let argument_ty = sig.inputs().skip_binder().first()?;\n+\n+                let return_span = fn_decl.output.span();\n+                let return_ty = *sig.output().skip_binder();\n+\n+                // We expect the first argument to be a reference.\n+                match argument_ty.sty {\n+                    ty::TyKind::Ref(_, _, _) => {},\n+                    _ => return None,\n+                }\n+\n+                Some(AnnotatedBorrowFnSignature::AnonymousFunction {\n+                    argument_ty,\n+                    argument_span,\n+                    return_ty,\n+                    return_span,\n+                })\n+            },\n+            _ => {\n+                // This is case 3 from above, return type is not a reference so don't highlight\n+                // anything.\n+                None\n+            },\n         }\n     }\n }\n \n #[derive(Debug)]\n enum AnnotatedBorrowFnSignature<'tcx> {\n-    Function {\n+    NamedFunction {\n+        arguments: Vec<(ty::Ty<'tcx>, Span)>,\n+        return_ty: ty::Ty<'tcx>,\n+        return_span: Span,\n+    },\n+    AnonymousFunction {\n         argument_ty: ty::Ty<'tcx>,\n         argument_span: Span,\n         return_ty: ty::Ty<'tcx>,\n         return_span: Span,\n-        regions_equal: bool,\n     },\n     Closure {\n         argument_ty: ty::Ty<'tcx>,\n@@ -1304,57 +1373,86 @@ enum AnnotatedBorrowFnSignature<'tcx> {\n }\n \n impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n+    /// Annotate the provided diagnostic with information about borrow from the fn signature that\n+    /// helps explain.\n     fn emit(\n         &self,\n         diag: &mut DiagnosticBuilder<'_>\n     ) -> String {\n-        let (argument_ty, argument_span) = match self {\n-            AnnotatedBorrowFnSignature::Function {\n-                argument_ty,\n-                argument_span,\n-                ..\n-            } => (argument_ty, argument_span),\n-            AnnotatedBorrowFnSignature::Closure {\n+        match self {\n+            AnnotatedBorrowFnSignature::Closure { argument_ty, argument_span } => {\n+                diag.span_label(\n+                    *argument_span,\n+                    format!(\"has type `{}`\", self.get_name_for_ty(argument_ty, 0)),\n+                );\n+\n+                self.get_region_name_for_ty(argument_ty, 0)\n+            },\n+            AnnotatedBorrowFnSignature::AnonymousFunction {\n                 argument_ty,\n                 argument_span,\n-            } => (argument_ty, argument_span),\n-        };\n+                return_ty,\n+                return_span,\n+            } => {\n+                let argument_ty_name = self.get_name_for_ty(argument_ty, 0);\n+                diag.span_label(\n+                    *argument_span,\n+                    format!(\"has type `{}`\", argument_ty_name)\n+                );\n \n-        let (argument_region_name, argument_ty_name) = (\n-            self.get_region_name_for_ty(argument_ty, 0),\n-            self.get_name_for_ty(argument_ty, 0),\n-        );\n-        diag.span_label(\n-            *argument_span,\n-            format!(\"has type `{}`\", argument_ty_name)\n-        );\n+                let return_ty_name = self.get_name_for_ty(return_ty, 0);\n+                let types_equal = return_ty_name == argument_ty_name;\n+                diag.span_label(\n+                    *return_span,\n+                    format!(\n+                        \"{}has type `{}`\",\n+                        if types_equal { \"also \" } else { \"\" },\n+                        return_ty_name,\n+                    )\n+                );\n \n-        // Only emit labels for the return value when we're annotating a function.\n-        if let AnnotatedBorrowFnSignature::Function {\n-            return_ty,\n-            return_span,\n-            regions_equal,\n-            ..\n-        } = self {\n-            let counter = if *regions_equal { 0 } else { 1 };\n-            let (return_region_name, return_ty_name) = (\n-                self.get_region_name_for_ty(return_ty, counter),\n-                self.get_name_for_ty(return_ty, counter)\n-            );\n+                diag.note(\n+                    \"argument and return type have the same lifetime due to lifetime elision rules\",\n+                );\n+                diag.note(\n+                    \"to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch10-03-\\\n+                     lifetime-syntax.html#lifetime-elision>\",\n+                );\n \n-            let types_equal = return_ty_name == argument_ty_name;\n-            diag.span_label(\n-                *return_span,\n-                format!(\n-                    \"{}has type `{}`\",\n-                    if types_equal { \"also \" } else { \"\" },\n-                    return_ty_name,\n-                )\n-            );\n+                self.get_region_name_for_ty(return_ty, 0)\n+            },\n+            AnnotatedBorrowFnSignature::NamedFunction {\n+                arguments,\n+                return_ty,\n+                return_span,\n+            } => {\n+                // Region of return type and arguments checked to be the same earlier.\n+                let region_name = self.get_region_name_for_ty(return_ty, 0);\n+                for (_, argument_span) in arguments {\n+                    diag.span_label(\n+                        *argument_span,\n+                        format!(\"has lifetime `{}`\", region_name)\n+                    );\n+                }\n \n-            return_region_name\n-        } else {\n-            argument_region_name\n+                diag.span_label(\n+                    *return_span,\n+                    format!(\n+                        \"also has lifetime `{}`\",\n+                        region_name,\n+                    )\n+                );\n+\n+                diag.help(\n+                    &format!(\n+                        \"use data from the highlighted arguments which match the `{}` lifetime of \\\n+                         the return type\",\n+                         region_name,\n+                    ),\n+                );\n+\n+                region_name\n+            },\n         }\n     }\n "}, {"sha": "71615333e649285ff5ef3069778985e4071957e3", "filename": "src/test/ui/issues/issue-30438-c.nll.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.nll.stderr?ref=ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "patch": "@@ -2,16 +2,17 @@ error[E0597]: `x` does not live long enough\n   --> $DIR/issue-30438-c.rs:19:5\n    |\n LL | fn silly<'y, 'z>(_s: &'y Test<'z>) -> &'y <Test<'z> as Trait>::Out where 'z: 'static {\n-   |                      ------------     ---------------------------- has type `&'y <Test<'z> as Trait>::Out`\n-   |                      |\n-   |                      has type `&'y Test<'z>`\n+   |                       --               -- also has lifetime `'y`\n+   |                       |\n+   |                       has lifetime `'y`\n LL |     let x = Test { s: \"this cannot last\" };\n LL |     &x\n    |     ^^ `x` would have to be valid for `'y`\n LL |     //~^ ERROR: `x` does not live long enough\n LL | }\n-   | - ...but `x` is only valid for the duration of the `silly` function, so it is dropped here while still borrowed\n+   | - but `x` will be dropped here, when the function `silly` returns\n    |\n+   = help: use data from the highlighted arguments which match the `'y` lifetime of the return type\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n "}, {"sha": "ae884c1a943e20343f96e27eff8877e6f204d3ec", "filename": "src/test/ui/nll/borrowed-universal-error-2.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr?ref=ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "patch": "@@ -2,16 +2,17 @@ error[E0597]: `v` does not live long enough\n   --> $DIR/borrowed-universal-error-2.rs:16:5\n    |\n LL | fn foo<'a>(x: &'a (u32,)) -> &'a u32 {\n-   |               ----------     ------- has type `&'a u32`\n-   |               |\n-   |               has type `&'a (u32,)`\n+   |                --             -- also has lifetime `'a`\n+   |                |\n+   |                has lifetime `'a`\n LL |     let v = 22;\n LL |     &v\n    |     ^^ `v` would have to be valid for `'a`\n LL |     //~^ ERROR `v` does not live long enough [E0597]\n LL | }\n-   | - ...but `v` is only valid for the duration of the `foo` function, so it is dropped here while still borrowed\n+   | - but `v` will be dropped here, when the function `foo` returns\n    |\n+   = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n "}, {"sha": "cd6c10335ccc672badcccdd47faee72e81f3b6c5", "filename": "src/test/ui/nll/issue-52534-1.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.rs?ref=ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "patch": "@@ -30,4 +30,24 @@ fn baz(x: &u32) -> &&u32 {\n     &&x\n }\n \n+fn foobazbar<'a>(x: u32, y: &'a u32) -> &'a u32 {\n+    let x = 22;\n+    &x\n+}\n+\n+fn foobar<'a>(x: &'a u32) -> &'a u32 {\n+    let x = 22;\n+    &x\n+}\n+\n+fn foobaz<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 {\n+    let x = 22;\n+    &x\n+}\n+\n+fn foobarbaz<'a, 'b>(x: &'a u32, y: &'b u32, z: &'a u32) -> &'a u32 {\n+    let x = 22;\n+    &x\n+}\n+\n fn main() { }"}, {"sha": "0f492884b83734a479cf0fa1bd080ad967022c73", "filename": "src/test/ui/nll/issue-52534-1.stderr", "status": "modified", "additions": 76, "deletions": 4, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.stderr?ref=ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "patch": "@@ -9,8 +9,10 @@ LL |         let x = 22;\n LL |         &x\n    |         ^^ `x` would have to be valid for `'0`\n LL |     }\n-   |     - ...but `x` is only valid for the duration of the `bar` function, so it is dropped here while still borrowed\n+   |     - but `x` will be dropped here, when the function `bar` returns\n    |\n+   = note: argument and return type have the same lifetime due to lifetime elision rules\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision>\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n \n@@ -25,8 +27,10 @@ LL |     let x = 22;\n LL |     &x\n    |     ^^ `x` would have to be valid for `'0`\n LL | }\n-   | - ...but `x` is only valid for the duration of the `foo` function, so it is dropped here while still borrowed\n+   | - but `x` will be dropped here, when the function `foo` returns\n    |\n+   = note: argument and return type have the same lifetime due to lifetime elision rules\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision>\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n \n@@ -41,8 +45,10 @@ LL |     let x = 22;\n LL |     &&x\n    |      ^^ `x` would have to be valid for `'0`\n LL | }\n-   | - ...but `x` is only valid for the duration of the `baz` function, so it is dropped here while still borrowed\n+   | - but `x` will be dropped here, when the function `baz` returns\n    |\n+   = note: argument and return type have the same lifetime due to lifetime elision rules\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision>\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n \n@@ -63,6 +69,72 @@ LL | |     &&x\n LL | | }\n    | |_^\n \n-error: aborting due to 4 previous errors\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:35:5\n+   |\n+LL | fn foobazbar<'a>(x: u32, y: &'a u32) -> &'a u32 {\n+   |                              --          -- also has lifetime `'a`\n+   |                              |\n+   |                              has lifetime `'a`\n+LL |     let x = 22;\n+LL |     &x\n+   |     ^^ `x` would have to be valid for `'a`\n+LL | }\n+   | - but `x` will be dropped here, when the function `foobazbar` returns\n+   |\n+   = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:40:5\n+   |\n+LL | fn foobar<'a>(x: &'a u32) -> &'a u32 {\n+   |                   --          -- also has lifetime `'a`\n+   |                   |\n+   |                   has lifetime `'a`\n+LL |     let x = 22;\n+LL |     &x\n+   |     ^^ `x` would have to be valid for `'a`\n+LL | }\n+   | - but `x` will be dropped here, when the function `foobar` returns\n+   |\n+   = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:45:5\n+   |\n+LL | fn foobaz<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 {\n+   |                       -- has lifetime `'a`    -- also has lifetime `'a`\n+LL |     let x = 22;\n+LL |     &x\n+   |     ^^ `x` would have to be valid for `'a`\n+LL | }\n+   | - but `x` will be dropped here, when the function `foobaz` returns\n+   |\n+   = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:50:5\n+   |\n+LL | fn foobarbaz<'a, 'b>(x: &'a u32, y: &'b u32, z: &'a u32) -> &'a u32 {\n+   |                          --                      --          -- also has lifetime `'a`\n+   |                          |                       |\n+   |                          has lifetime `'a`       has lifetime `'a`\n+LL |     let x = 22;\n+LL |     &x\n+   |     ^^ `x` would have to be valid for `'a`\n+LL | }\n+   | - but `x` will be dropped here, when the function `foobarbaz` returns\n+   |\n+   = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0597`."}, {"sha": "fafa216842dc8f28ca5fdd0270a7c98d54d52ed5", "filename": "src/test/ui/nll/issue-52534.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fnll%2Fissue-52534.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fnll%2Fissue-52534.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534.stderr?ref=ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "patch": "@@ -6,7 +6,7 @@ LL |     foo(|a| &x)\n    |          |\n    |          has type `&'0 u32`\n LL | }\n-   | - ...but `x` is only valid for the duration of the `bar` function, so it is dropped here while still borrowed\n+   | - but `x` will be dropped here, when the function `bar` returns\n    |\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n@@ -19,7 +19,7 @@ LL |     baz(|first, second| &y)\n    |          |\n    |          has type `&'0 u32`\n LL | }\n-   | - ...but `y` is only valid for the duration of the `foobar` function, so it is dropped here while still borrowed\n+   | - but `y` will be dropped here, when the function `foobar` returns\n    |\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>"}, {"sha": "30bdbad41139d57c5087cbd2af5bcae660d1e34f", "filename": "src/test/ui/regions/regions-nested-fns-2.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns-2.nll.stderr?ref=ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "patch": "@@ -8,7 +8,7 @@ LL |             if false { &y } else { z }\n    |                         ^ `y` would have to be valid for `'0`\n LL |         });\n LL | }\n-   | - ...but `y` is only valid for the duration of the `nested` function, so it is dropped here while still borrowed\n+   | - but `y` will be dropped here, when the function `nested` returns\n    |\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>"}, {"sha": "4bb602d572fa3e5a650bc335913f0901cfa50e29", "filename": "src/test/ui/regions/regions-nested-fns.nll.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef10e94993f6e4b04b283e414b04ed02ec9f6c99/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.nll.stderr?ref=ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "patch": "@@ -25,16 +25,15 @@ error[E0597]: `y` does not live long enough\n   --> $DIR/regions-nested-fns.rs:19:15\n    |\n LL |     ignore::<Box<for<'z> FnMut(&'z isize)>>(Box::new(|z| {\n-   |                                                       - has type `&'0 isize`\n+   |                                                      --- value captured here\n LL |         ay = x;\n LL |         ay = &y;\n-   |               ^ `y` would have to be valid for `'0`\n+   |               ^ borrowed value does not live long enough\n ...\n LL | }\n-   | - ...but `y` is only valid for the duration of the `nested` function, so it is dropped here while still borrowed\n+   | - `y` dropped here while still borrowed\n    |\n-   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+   = note: borrowed value must be valid for the static lifetime...\n \n error: unsatisfied lifetime constraints\n   --> $DIR/regions-nested-fns.rs:23:68"}]}