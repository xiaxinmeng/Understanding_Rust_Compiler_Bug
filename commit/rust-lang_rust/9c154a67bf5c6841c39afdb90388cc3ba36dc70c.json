{"sha": "9c154a67bf5c6841c39afdb90388cc3ba36dc70c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMTU0YTY3YmY1YzY4NDFjMzlhZmRiOTAzODhjYzNiYTM2ZGM3MGM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-01T17:46:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-02T20:21:55Z"}, "message": "rip out everything but `MirPass`, move the logic into suites", "tree": {"sha": "cdd3bc965cf0ffddae2959984fe74f1882ce697f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdd3bc965cf0ffddae2959984fe74f1882ce697f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c154a67bf5c6841c39afdb90388cc3ba36dc70c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c154a67bf5c6841c39afdb90388cc3ba36dc70c", "html_url": "https://github.com/rust-lang/rust/commit/9c154a67bf5c6841c39afdb90388cc3ba36dc70c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c253df5249b5f3c7d6f85e1ed28afbf0adc1390b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c253df5249b5f3c7d6f85e1ed28afbf0adc1390b", "html_url": "https://github.com/rust-lang/rust/commit/c253df5249b5f3c7d6f85e1ed28afbf0adc1390b"}], "stats": {"total": 322, "additions": 92, "deletions": 230}, "files": [{"sha": "df6f98297d0222ab2c27c5d334b31a9113213ec6", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=9c154a67bf5c6841c39afdb90388cc3ba36dc70c", "patch": "@@ -15,7 +15,6 @@ use hir::def_id::DefId;\n use hir::map::DefPathData;\n use mir::{Mir, Promoted};\n use ty::TyCtxt;\n-use std::cell::Ref;\n use std::rc::Rc;\n use syntax::ast::NodeId;\n \n@@ -83,29 +82,6 @@ pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n     }\n }\n \n-/// Gives you access to various bits of state during your MIR pass.\n-pub trait MirCtxt<'a, 'tcx: 'a> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-    fn def_id(&self) -> DefId;\n-    fn suite(&self) -> MirSuite;\n-    fn pass_num(&self) -> MirPassIndex;\n-    fn source(&self) -> MirSource;\n-\n-    // Get a read-only view on the MIR of this def-id from the\n-    // previous pass.\n-    fn read_previous_mir(&self) -> Ref<'tcx, Mir<'tcx>>;\n-\n-    // Steal the MIR of this def-id from the previous pass; any future\n-    // attempt to access the MIR from the previous pass is a bug.\n-    fn steal_previous_mir(&self) -> Mir<'tcx>;\n-\n-    // Same as `read_previous_mir()`, but for any def-id you want.\n-    fn read_previous_mir_of(&self, def_id: DefId) -> Ref<'tcx, Mir<'tcx>>;\n-\n-    // Same as `steal_previous_mir()`, but for any def-id you want.\n-    fn steal_previous_mir_of(&self, def_id: DefId) -> Mir<'tcx>;\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub struct MirSuite(pub usize);\n \n@@ -125,26 +101,19 @@ pub struct MirPassIndex(pub usize);\n /// the hook will be invoked once per output.\n pub trait PassHook {\n     fn on_mir_pass<'a, 'tcx: 'a>(&self,\n-                                 mir_cx: &MirCtxt<'a, 'tcx>,\n-                                 mir: Option<(DefId, &Mir<'tcx>)>);\n+                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 suite: MirSuite,\n+                                 pass_num: MirPassIndex,\n+                                 pass_name: &str,\n+                                 source: MirSource,\n+                                 mir: &Mir<'tcx>,\n+                                 is_after: bool);\n }\n \n /// The full suite of types that identifies a particular\n /// application of a pass to a def-id.\n pub type PassId = (MirSuite, MirPassIndex, DefId);\n \n-/// A streamlined trait that you can implement to create an\n-/// intraprocedural pass; the pass will be invoked to process the MIR\n-/// with the given `def_id`.  This lets you do things before we fetch\n-/// the MIR itself. You may prefer `MirPass`, which is even more streamlined.\n-pub trait DefIdPass {\n-    fn name<'a>(&'a self) -> Cow<'a, str> {\n-        default_name::<Self>()\n-    }\n-\n-    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>) -> Mir<'tcx>;\n-}\n-\n /// A streamlined trait that you can implement to create a pass; the\n /// pass will be named after the type, and it will consist of a main\n /// loop that goes over each available MIR and applies `run_pass`.\n@@ -159,32 +128,11 @@ pub trait MirPass {\n                           mir: &mut Mir<'tcx>);\n }\n \n-impl<T: MirPass> DefIdPass for T {\n-    fn name<'a>(&'a self) -> Cow<'a, str> {\n-        MirPass::name(self)\n-    }\n-\n-    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>) -> Mir<'tcx> {\n-        let tcx = mir_cx.tcx();\n-        let source = mir_cx.source();\n-        let mut mir = mir_cx.steal_previous_mir();\n-        MirPass::run_pass(self, tcx, source, &mut mir);\n-\n-        let item_id = source.item_id();\n-        for (promoted_index, promoted_mir) in mir.promoted.iter_enumerated_mut() {\n-            let promoted_source = MirSource::Promoted(item_id, promoted_index);\n-            MirPass::run_pass(self, tcx, promoted_source, promoted_mir);\n-        }\n-\n-        mir\n-    }\n-}\n-\n /// A manager for MIR passes.\n #[derive(Clone)]\n pub struct Passes {\n     pass_hooks: Vec<Rc<PassHook>>,\n-    suites: Vec<Vec<Rc<DefIdPass>>>,\n+    suites: Vec<Vec<Rc<MirPass>>>,\n }\n \n /// The number of \"pass suites\" that we have:\n@@ -212,7 +160,7 @@ impl<'a, 'tcx> Passes {\n     }\n \n     /// Pushes a built-in pass.\n-    pub fn push_pass<T: DefIdPass + 'static>(&mut self, suite: MirSuite, pass: T) {\n+    pub fn push_pass<T: MirPass + 'static>(&mut self, suite: MirSuite, pass: T) {\n         self.suites[suite.0].push(Rc::new(pass));\n     }\n \n@@ -225,7 +173,7 @@ impl<'a, 'tcx> Passes {\n         self.suites[suite.0].len()\n     }\n \n-    pub fn pass(&self, suite: MirSuite, pass: MirPassIndex) -> &DefIdPass {\n+    pub fn pass(&self, suite: MirSuite, pass: MirPassIndex) -> &MirPass {\n         &*self.suites[suite.0][pass.0]\n     }\n "}, {"sha": "b3ca61550d7c3e373d1b68bcdc5a088e7964a912", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=9c154a67bf5c6841c39afdb90388cc3ba36dc70c", "patch": "@@ -818,7 +818,7 @@ define_maps! { <'tcx>\n     /// manually, you're doing it wrong.\n     ///\n     /// See the README for the `mir` module for details.\n-    [multi] mir_pass: mir_pass((MirSuite, MirPassIndex, DefId)) -> &'tcx Steal<mir::Mir<'tcx>>,\n+    [] mir_pass: mir_pass((MirSuite, MirPassIndex, DefId)) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n     /// MIR after our optimization passes have run. This is MIR that is ready\n     /// for trans. This is also the only query that can fetch non-local MIR, at present."}, {"sha": "977b9d2e994473d8c6e66c14b309ecf66719f032", "filename": "src/librustc_mir/callgraph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc_mir%2Fcallgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc_mir%2Fcallgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fcallgraph.rs?ref=9c154a67bf5c6841c39afdb90388cc3ba36dc70c", "patch": "@@ -30,7 +30,7 @@ pub struct CallGraph {\n }\n \n impl CallGraph {\n-    pub fn build<'a, 'mir, 'tcx>(cx: &mut InterproceduralCx<'a, 'mir, 'tcx>) -> CallGraph {\n+    pub fn build<'a, 'tcx>(cx: &mut InterproceduralCx<'a, 'tcx>) -> CallGraph {\n         let mut callgraph = CallGraph {\n             node_map: DefIdMap(),\n             graph: graph::Graph::new()"}, {"sha": "67a3281dba48b0afacda60f88445690337336920", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 18, "deletions": 32, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=9c154a67bf5c6841c39afdb90388cc3ba36dc70c", "patch": "@@ -15,22 +15,24 @@ use std::fmt;\n use std::fs::File;\n use std::io;\n \n-use rustc::hir::def_id::DefId;\n use rustc::mir::Mir;\n-use rustc::mir::transform::{DefIdPass, MirCtxt, MirSource, PassHook};\n+use rustc::mir::transform::{MirPass, MirPassIndex, MirSource, MirSuite, PassHook};\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::ty::TyCtxt;\n use util as mir_util;\n \n pub struct Marker(pub &'static str);\n \n-impl DefIdPass for Marker {\n+impl MirPass for Marker {\n     fn name<'a>(&'a self) -> Cow<'a, str> {\n         Cow::Borrowed(self.0)\n     }\n \n-    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>) -> Mir<'tcx> {\n-        mir_cx.steal_previous_mir()\n+    fn run_pass<'a, 'tcx>(&self,\n+                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _source: MirSource,\n+                          _mir: &mut Mir<'tcx>)\n+    {\n     }\n }\n \n@@ -49,37 +51,21 @@ pub struct DumpMir;\n \n impl PassHook for DumpMir {\n     fn on_mir_pass<'a, 'tcx: 'a>(&self,\n-                                 mir_cx: &MirCtxt<'a, 'tcx>,\n-                                 mir: Option<(DefId, &Mir<'tcx>)>)\n+                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 suite: MirSuite,\n+                                 pass_num: MirPassIndex,\n+                                 pass_name: &str,\n+                                 source: MirSource,\n+                                 mir: &Mir<'tcx>,\n+                                 is_after: bool)\n     {\n-        let tcx = mir_cx.tcx();\n-        let suite = mir_cx.suite();\n-        let pass_num = mir_cx.pass_num();\n-        let pass = tcx.mir_passes.pass(suite, pass_num);\n-        let name = &pass.name();\n-        let source = match mir {\n-            None => mir_cx.source(),\n-            Some((def_id, _)) => {\n-                let id = tcx.hir.as_local_node_id(def_id)\n-                                .expect(\"mir source requires local def-id\");\n-                MirSource::from_node(tcx, id)\n-            }\n-        };\n-        if mir_util::dump_enabled(tcx, name, source) {\n-            let previous_mir;\n-            let mir_to_dump = match mir {\n-                Some((_, m)) => m,\n-                None => {\n-                    previous_mir = mir_cx.read_previous_mir();\n-                    &*previous_mir\n-                }\n-            };\n+        if mir_util::dump_enabled(tcx, pass_name, source) {\n             mir_util::dump_mir(tcx,\n                                Some((suite, pass_num)),\n-                               name,\n-                               &Disambiguator { is_after: mir.is_some() },\n+                               pass_name,\n+                               &Disambiguator { is_after },\n                                source,\n-                               mir_to_dump);\n+                               mir);\n         }\n     }\n }"}, {"sha": "caa2aa74ede199c4b912ecad81b0957a26c28f98", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=9c154a67bf5c6841c39afdb90388cc3ba36dc70c", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::graph;\n \n use rustc::dep_graph::DepNode;\n use rustc::mir::*;\n-use rustc::mir::transform::{MirCtxt, MirSource, PassId};\n+use rustc::mir::transform::{MirSource, PassId};\n use rustc::mir::visit::*;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -46,19 +46,14 @@ const UNKNOWN_SIZE_COST: usize = 10;\n pub struct Inline;\n \n pub trait Pass {\n-    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>)\n+    fn run_pass<'a, 'tcx: 'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                               -> Multi<PassId, &'tcx Steal<Mir<'tcx>>>;\n }\n \n impl Pass for Inline {\n-    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>)\n+    fn run_pass<'a, 'tcx: 'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                               -> Multi<PassId, &'tcx Steal<Mir<'tcx>>> {\n-        let tcx = mir_cx.tcx();\n-        if tcx.sess.opts.debugging_opts.mir_opt_level < 2 {\n-            return Multi::from(tcx.alloc_steal_mir(mir_cx.steal_previous_mir()));\n-        }\n-\n-        let mut cx = InterproceduralCx::new(mir_cx);\n+        let mut cx = InterproceduralCx::new(tcx);\n \n         let callgraph = callgraph::CallGraph::build(&mut cx);\n \n@@ -72,8 +67,8 @@ impl Pass for Inline {\n     }\n }\n \n-struct Inliner<'mir, 'tcx: 'mir> {\n-    tcx: TyCtxt<'mir, 'tcx, 'tcx>,\n+struct Inliner<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n #[derive(Copy, Clone)]\n@@ -85,11 +80,11 @@ struct CallSite<'tcx> {\n     location: SourceInfo,\n }\n \n-impl<'mir, 'tcx> Inliner<'mir, 'tcx> {\n-    fn inline_scc<'a>(&mut self,\n-                      cx: &mut InterproceduralCx<'a, 'mir, 'tcx>,\n-                      callgraph: &callgraph::CallGraph,\n-                      scc: &[graph::NodeIndex]) -> bool {\n+impl<'a, 'tcx> Inliner<'a, 'tcx> {\n+    fn inline_scc(&mut self,\n+                  cx: &mut InterproceduralCx<'a, 'tcx>,\n+                  callgraph: &callgraph::CallGraph,\n+                  scc: &[graph::NodeIndex]) -> bool {\n         let tcx = self.tcx;\n         let mut callsites = Vec::new();\n         let mut in_scc = DefIdSet();"}, {"sha": "7a2645567e24e8b8a45ffe16fe08f58a0c0ef6a6", "filename": "src/librustc_mir/transform/interprocedural.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc_mir%2Ftransform%2Finterprocedural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc_mir%2Ftransform%2Finterprocedural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finterprocedural.rs?ref=9c154a67bf5c6841c39afdb90388cc3ba36dc70c", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::hir::def_id::DefId;\n use rustc::mir::Mir;\n-use rustc::mir::transform::{MirCtxt, PassId};\n+use rustc::mir::transform::{PassId};\n use rustc::ty::steal::Steal;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n@@ -21,31 +21,21 @@ use rustc_data_structures::fx::FxHashMap;\n /// stolen and so forth. It is more of a placeholder meant to get\n /// inlining up and going again, and is probably going to need heavy\n /// revision as we scale up to more interesting optimizations.\n-pub struct InterproceduralCx<'a, 'mir: 'a, 'tcx: 'mir> {\n-    pub tcx: TyCtxt<'mir, 'tcx, 'tcx>,\n-    pub mir_cx: &'a MirCtxt<'mir, 'tcx>,\n+pub struct InterproceduralCx<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     local_cache: FxHashMap<DefId, Mir<'tcx>>,\n }\n \n-impl<'a, 'mir, 'tcx> InterproceduralCx<'a, 'mir, 'tcx> {\n-    pub fn new(mir_cx: &'a MirCtxt<'mir, 'tcx>) -> Self {\n+impl<'a, 'tcx> InterproceduralCx<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         InterproceduralCx {\n-            mir_cx,\n-            tcx: mir_cx.tcx(),\n+            tcx: tcx,\n             local_cache: FxHashMap::default(),\n         }\n     }\n \n     pub fn into_local_mirs(self) -> Vec<(PassId, &'tcx Steal<Mir<'tcx>>)> {\n-        let tcx = self.tcx;\n-        let suite = self.mir_cx.suite();\n-        let pass_num = self.mir_cx.pass_num();\n-        self.local_cache.into_iter()\n-                        .map(|(def_id, mir)| {\n-                            let mir = tcx.alloc_steal_mir(mir);\n-                            ((suite, pass_num, def_id), mir)\n-                        })\n-                        .collect()\n+        unimplemented!()\n     }\n \n     /// Ensures that the mir for `def_id` is available, if it can be\n@@ -93,8 +83,6 @@ impl<'a, 'mir, 'tcx> InterproceduralCx<'a, 'mir, 'tcx> {\n \n     pub fn mir_mut(&mut self, def_id: DefId) -> &mut Mir<'tcx> {\n         assert!(def_id.is_local(), \"cannot get mutable mir of remote entry\");\n-        let mir_cx = self.mir_cx;\n-        self.local_cache.entry(def_id)\n-                        .or_insert_with(|| mir_cx.steal_previous_mir_of(def_id))\n+        unimplemented!()\n     }\n }"}, {"sha": "dc67c6f1ef45f168567d396245a5b653e6c476bb", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 37, "deletions": 69, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=9c154a67bf5c6841c39afdb90388cc3ba36dc70c", "patch": "@@ -10,11 +10,11 @@\n \n use rustc::hir::def_id::DefId;\n use rustc::mir::Mir;\n-use rustc::mir::transform::{MirCtxt, MirPassIndex, MirSuite, MirSource, MIR_OPTIMIZED, PassId};\n+use rustc::mir::transform::{MirPassIndex, MirSuite, MirSource, MIR_VALIDATED, MIR_OPTIMIZED};\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::steal::Steal;\n-use rustc::ty::TyCtxt;\n-use rustc::ty::maps::{Multi, Providers};\n-use std::cell::Ref;\n+use rustc::ty::maps::Providers;\n+use syntax_pos::DUMMY_SP;\n \n pub mod simplify_branches;\n pub mod simplify;\n@@ -51,89 +51,57 @@ fn mir_suite<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        -> &'tcx Steal<Mir<'tcx>>\n {\n     let passes = &tcx.mir_passes;\n+\n+    if suite == MIR_VALIDATED {\n+        let id = tcx.hir.as_local_node_id(def_id).expect(\"mir source requires local def-id\");\n+        let source = MirSource::from_node(tcx, id);\n+        if let MirSource::Const(_) = source {\n+            // Ensure that we compute the `mir_const_qualif` for\n+            // constants at this point, before we do any further\n+            // optimization (and before we steal the previous\n+            // MIR). We don't directly need the result, so we can\n+            // just force it.\n+            ty::queries::mir_const_qualif::force(tcx, DUMMY_SP, def_id);\n+        }\n+    }\n+\n     let len = passes.len_passes(suite);\n     assert!(len > 0, \"no passes in {:?}\", suite);\n     tcx.mir_pass((suite, MirPassIndex(len - 1), def_id))\n }\n \n fn mir_pass<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       (suite, pass_num, def_id): (MirSuite, MirPassIndex, DefId))\n-                      -> Multi<PassId, &'tcx Steal<Mir<'tcx>>>\n+                      -> &'tcx Steal<Mir<'tcx>>\n {\n     let passes = &tcx.mir_passes;\n     let pass = passes.pass(suite, pass_num);\n-    let mir_ctxt = MirCtxtImpl { tcx, pass_num, suite, def_id };\n \n-    for hook in passes.hooks() {\n-        hook.on_mir_pass(&mir_ctxt, None);\n-    }\n+    let id = tcx.hir.as_local_node_id(def_id).expect(\"mir source requires local def-id\");\n+    let source = MirSource::from_node(tcx, id);\n \n-    let mir = pass.run_pass(&mir_ctxt);\n+    let mut mir = {\n+        let MirSuite(suite) = suite;\n+        let MirPassIndex(pass_num) = pass_num;\n+        if pass_num > 0 {\n+            tcx.mir_pass((MirSuite(suite), MirPassIndex(pass_num - 1), def_id)).steal()\n+        } else if suite > 0 {\n+            tcx.mir_suite((MirSuite(suite - 1), def_id)).steal()\n+        } else {\n+            tcx.mir_build(def_id).steal()\n+        }\n+    };\n \n     for hook in passes.hooks() {\n-        hook.on_mir_pass(&mir_ctxt, Some((def_id, &mir)));\n-    }\n-\n-    Multi::from(tcx.alloc_steal_mir(mir))\n-}\n-\n-struct MirCtxtImpl<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pass_num: MirPassIndex,\n-    suite: MirSuite,\n-    def_id: DefId\n-}\n-\n-impl<'a, 'tcx> MirCtxt<'a, 'tcx> for MirCtxtImpl<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn suite(&self) -> MirSuite {\n-        self.suite\n-    }\n-\n-    fn pass_num(&self) -> MirPassIndex {\n-        self.pass_num\n-    }\n-\n-    fn def_id(&self) -> DefId {\n-        self.def_id\n-    }\n-\n-    fn source(&self) -> MirSource {\n-        let id = self.tcx.hir.as_local_node_id(self.def_id)\n-                             .expect(\"mir source requires local def-id\");\n-        MirSource::from_node(self.tcx, id)\n-    }\n-\n-    fn read_previous_mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n-        self.previous_mir(self.def_id).borrow()\n+        hook.on_mir_pass(tcx, suite, pass_num, &pass.name(), source, &mir, false);\n     }\n \n-    fn steal_previous_mir(&self) -> Mir<'tcx> {\n-        self.previous_mir(self.def_id).steal()\n-    }\n+    pass.run_pass(tcx, source, &mut mir);\n \n-    fn read_previous_mir_of(&self, def_id: DefId) -> Ref<'tcx, Mir<'tcx>> {\n-        self.previous_mir(def_id).borrow()\n+    for hook in passes.hooks() {\n+        hook.on_mir_pass(tcx, suite, pass_num, &pass.name(), source, &mir, true);\n     }\n \n-    fn steal_previous_mir_of(&self, def_id: DefId) -> Mir<'tcx> {\n-        self.previous_mir(def_id).steal()\n-    }\n+    tcx.alloc_steal_mir(mir)\n }\n \n-impl<'a, 'tcx> MirCtxtImpl<'a, 'tcx> {\n-    fn previous_mir(&self, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n-        let MirSuite(suite) = self.suite;\n-        let MirPassIndex(pass_num) = self.pass_num;\n-        if pass_num > 0 {\n-            self.tcx.mir_pass((MirSuite(suite), MirPassIndex(pass_num - 1), def_id))\n-        } else if suite > 0 {\n-            self.tcx.mir_suite((MirSuite(suite - 1), def_id))\n-        } else {\n-            self.tcx.mir_build(def_id)\n-        }\n-    }\n-}"}, {"sha": "cd37372c2f1229754d51dc2caf105407063b06a2", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c154a67bf5c6841c39afdb90388cc3ba36dc70c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9c154a67bf5c6841c39afdb90388cc3ba36dc70c", "patch": "@@ -26,7 +26,7 @@ use rustc::ty::cast::CastTy;\n use rustc::ty::maps::Providers;\n use rustc::mir::*;\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::mir::transform::{DefIdPass, MirCtxt, MirSource, MIR_CONST};\n+use rustc::mir::transform::{MirPass, MirSource, MIR_CONST};\n use rustc::mir::visit::{LvalueContext, Visitor};\n use rustc::middle::lang_items;\n use syntax::abi::Abi;\n@@ -938,34 +938,11 @@ fn qualify_const_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub struct QualifyAndPromoteConstants;\n \n-impl DefIdPass for QualifyAndPromoteConstants {\n-    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>) -> Mir<'tcx> {\n-        let tcx = mir_cx.tcx();\n-        match mir_cx.source() {\n-            MirSource::Const(_) => {\n-                // Ensure that we compute the `mir_const_qualif` for\n-                // constants at this point, before we do any further\n-                // optimization (and before we steal the previous\n-                // MIR). We don't directly need the result, so we can\n-                // just force it.\n-                ty::queries::mir_const_qualif::force(tcx, DUMMY_SP, mir_cx.def_id());\n-                mir_cx.steal_previous_mir()\n-            }\n-\n-            src => {\n-                let mut mir = mir_cx.steal_previous_mir();\n-                self.run_pass(tcx, src, &mut mir);\n-                mir\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> QualifyAndPromoteConstants {\n-    fn run_pass(&self,\n-                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                src: MirSource,\n-                mir: &mut Mir<'tcx>) {\n+impl MirPass for QualifyAndPromoteConstants {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n         let id = src.item_id();\n         let def_id = tcx.hir.local_def_id(id);\n         let mode = match src {"}]}