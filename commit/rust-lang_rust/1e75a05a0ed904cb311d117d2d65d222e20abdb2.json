{"sha": "1e75a05a0ed904cb311d117d2d65d222e20abdb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNzVhMDVhMGVkOTA0Y2IzMTFkMTE3ZDJkNjVkMjIyZTIwYWJkYjI=", "commit": {"author": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-02-12T21:45:07Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-02-13T19:12:51Z"}, "message": "more int and cloned cleanup in collections", "tree": {"sha": "72fc33e29dde60abe2d6beb3b111ef3ca85c12ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72fc33e29dde60abe2d6beb3b111ef3ca85c12ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e75a05a0ed904cb311d117d2d65d222e20abdb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e75a05a0ed904cb311d117d2d65d222e20abdb2", "html_url": "https://github.com/rust-lang/rust/commit/1e75a05a0ed904cb311d117d2d65d222e20abdb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e75a05a0ed904cb311d117d2d65d222e20abdb2/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cca1cf613b8e535ab274d6ce5aecadf4708990bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/cca1cf613b8e535ab274d6ce5aecadf4708990bf", "html_url": "https://github.com/rust-lang/rust/commit/cca1cf613b8e535ab274d6ce5aecadf4708990bf"}], "stats": {"total": 170, "additions": 85, "deletions": 85}, "files": [{"sha": "66374b639c1a6eec82d7a77f7842d96786610a4a", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=1e75a05a0ed904cb311d117d2d65d222e20abdb2", "patch": "@@ -255,7 +255,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n     /// for x in heap.into_iter() {\n-    ///     // x has type int, not &int\n+    ///     // x has type i32, not &i32\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```"}, {"sha": "895fa076ab604e192224b6d38544d5d2f82cb892", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=1e75a05a0ed904cb311d117d2d65d222e20abdb2", "patch": "@@ -1783,7 +1783,7 @@ mod test {\n     fn test_entry(){\n         let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n-        let mut map: BTreeMap<_, _> = xs.iter().map(|&x| x).collect();\n+        let mut map: BTreeMap<_, _> = xs.iter().cloned().collect();\n \n         // Existing key (insert)\n         match map.entry(1) {"}, {"sha": "8628879295b83437988dcb76fa1027ed1910301c", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=1e75a05a0ed904cb311d117d2d65d222e20abdb2", "patch": "@@ -89,7 +89,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let mut set: BTreeSet<int> = BTreeSet::new();\n+    /// let mut set: BTreeSet<i32> = BTreeSet::new();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeSet<T> {\n@@ -114,13 +114,13 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().cloned().collect();\n     ///\n     /// for x in set.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n-    /// let v: Vec<usize> = set.iter().map(|&x| x).collect();\n+    /// let v: Vec<usize> = set.iter().cloned().collect();\n     /// assert_eq!(v, vec![1,2,3,4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -135,7 +135,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().cloned().collect();\n     ///\n     /// let v: Vec<usize> = set.into_iter().collect();\n     /// assert_eq!(v, vec![1,2,3,4]);\n@@ -331,7 +331,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let set: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n@@ -348,8 +348,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let a: BTreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut b: BTreeSet<int> = BTreeSet::new();\n+    /// let a: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut b = BTreeSet::new();\n     ///\n     /// assert_eq!(a.is_disjoint(&b), true);\n     /// b.insert(4);\n@@ -369,8 +369,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let sup: BTreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut set: BTreeSet<int> = BTreeSet::new();\n+    /// let sup: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut set = BTreeSet::new();\n     ///\n     /// assert_eq!(set.is_subset(&sup), true);\n     /// set.insert(2);\n@@ -411,8 +411,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let sub: BTreeSet<int> = [1, 2].iter().map(|&x| x).collect();\n-    /// let mut set: BTreeSet<int> = BTreeSet::new();\n+    /// let sub: BTreeSet<_> = [1, 2].iter().cloned().collect();\n+    /// let mut set = BTreeSet::new();\n     ///\n     /// assert_eq!(set.is_superset(&sub), false);\n     ///\n@@ -525,11 +525,11 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let a: BTreeSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![3, 4, 5].into_iter().collect();\n+    /// let a: BTreeSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: BTreeSet<_> = vec![3, 4, 5].into_iter().collect();\n     ///\n-    /// let result: BTreeSet<int> = &a - &b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n+    /// let result = &a - &b;\n+    /// let result_vec: Vec<_> = result.into_iter().collect();\n     /// assert_eq!(result_vec, vec![1, 2]);\n     /// ```\n     fn sub(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n@@ -548,11 +548,11 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let a: BTreeSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![2, 3, 4].into_iter().collect();\n+    /// let a: BTreeSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: BTreeSet<_> = vec![2, 3, 4].into_iter().collect();\n     ///\n-    /// let result: BTreeSet<int> = &a ^ &b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n+    /// let result = &a ^ &b;\n+    /// let result_vec: Vec<_> = result.into_iter().collect();\n     /// assert_eq!(result_vec, vec![1, 4]);\n     /// ```\n     fn bitxor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n@@ -571,11 +571,11 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let a: BTreeSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![2, 3, 4].into_iter().collect();\n+    /// let a: BTreeSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: BTreeSet<_> = vec![2, 3, 4].into_iter().collect();\n     ///\n-    /// let result: BTreeSet<int> = &a & &b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n+    /// let result = &a & &b;\n+    /// let result_vec: Vec<_> = result.into_iter().collect();\n     /// assert_eq!(result_vec, vec![2, 3]);\n     /// ```\n     fn bitand(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n@@ -594,11 +594,11 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let a: BTreeSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![3, 4, 5].into_iter().collect();\n+    /// let a: BTreeSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: BTreeSet<_> = vec![3, 4, 5].into_iter().collect();\n     ///\n-    /// let result: BTreeSet<int> = &a | &b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n+    /// let result = &a | &b;\n+    /// let result_vec: Vec<_> = result.into_iter().collect();\n     /// assert_eq!(result_vec, vec![1, 2, 3, 4, 5]);\n     /// ```\n     fn bitor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {"}, {"sha": "356df24611b379a579728d6c95c3d3cdaa618849", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=1e75a05a0ed904cb311d117d2d65d222e20abdb2", "patch": "@@ -756,7 +756,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// ```\n     /// use std::collections::DList;\n     ///\n-    /// let mut list: DList<int> = vec![1, 3, 4].into_iter().collect();\n+    /// let mut list: DList<_> = vec![1, 3, 4].into_iter().collect();\n     ///\n     /// {\n     ///     let mut it = list.iter_mut();\n@@ -765,7 +765,7 @@ impl<'a, A> IterMut<'a, A> {\n     ///     it.insert_next(2);\n     /// }\n     /// {\n-    ///     let vec: Vec<int> = list.into_iter().collect();\n+    ///     let vec: Vec<_> = list.into_iter().collect();\n     ///     assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// }\n     /// ```\n@@ -783,7 +783,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// ```\n     /// use std::collections::DList;\n     ///\n-    /// let mut list: DList<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let mut list: DList<_> = vec![1, 2, 3].into_iter().collect();\n     ///\n     /// let mut it = list.iter_mut();\n     /// assert_eq!(it.next().unwrap(), &1);"}, {"sha": "0892a1c2008858d0d6faa7ffd9ddc10096772ceb", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=1e75a05a0ed904cb311d117d2d65d222e20abdb2", "patch": "@@ -108,7 +108,7 @@\n //! There are various parameters which do require a particular type, however.\n //! Namely if the syntax `{:.*}` is used, then the number of characters to print\n //! precedes the actual object being formatted, and the number of characters\n-//! must have the type `uint`. Although a `uint` can be printed with `{}`, it is\n+//! must have the type `usize`. Although a `usize` can be printed with `{}`, it is\n //! illegal to reference an argument as such. For example this is another\n //! invalid format string:\n //!\n@@ -121,7 +121,7 @@\n //! When requesting that an argument be formatted with a particular type, you\n //! are actually requesting that an argument ascribes to a particular trait.\n //! This allows multiple actual types to be formatted via `{:x}` (like `i8` as\n-//! well as `int`).  The current mapping of types to traits is:\n+//! well as `isize`).  The current mapping of types to traits is:\n //!\n //! * *nothing* \u21d2 `Display`\n //! * `?` \u21d2 `Debug`\n@@ -173,8 +173,8 @@\n //!\n //! #[derive(Debug)]\n //! struct Vector2D {\n-//!     x: int,\n-//!     y: int,\n+//!     x: isize,\n+//!     y: isize,\n //! }\n //!\n //! impl fmt::Display for Vector2D {\n@@ -380,9 +380,9 @@\n //! the '0' flag is specified for numerics, then the implicit fill character is\n //! '0'.\n //!\n-//! The value for the width can also be provided as a `uint` in the list of\n+//! The value for the width can also be provided as a `usize` in the list of\n //! parameters by using the `2$` syntax indicating that the second argument is a\n-//! `uint` specifying the width.\n+//! `usize` specifying the width.\n //!\n //! ### Precision\n //!"}, {"sha": "945cceddfb5e17fd9dadfa438b1c12c3c7d2ab04", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=1e75a05a0ed904cb311d117d2d65d222e20abdb2", "patch": "@@ -73,7 +73,7 @@\n //!\n //! The method `iter()` returns an iteration value for a slice. The iterator\n //! yields references to the slice's elements, so if the element\n-//! type of the slice is `int`, the element type of the iterator is `&int`.\n+//! type of the slice is `isize`, the element type of the iterator is `&isize`.\n //!\n //! ```rust\n //! let numbers = [0, 1, 2];\n@@ -1218,7 +1218,7 @@ impl Iterator for ElementSwaps {\n         // Find the index of the largest mobile element:\n         // The direction should point into the vector, and the\n         // swap should be with a smaller `size` element.\n-        let max = self.sdir.iter().map(|&x| x).enumerate()\n+        let max = self.sdir.iter().cloned().enumerate()\n                            .filter(|&(i, sd)|\n                                 new_pos(i, sd.dir) < self.sdir.len() &&\n                                 self.sdir[new_pos(i, sd.dir)].size < sd.size)"}, {"sha": "8382acfe3da051ac892acd3fd9284e2ccab64345", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=1e75a05a0ed904cb311d117d2d65d222e20abdb2", "patch": "@@ -2705,22 +2705,22 @@ mod tests {\n \n         for &(s, g) in &test_same[] {\n             // test forward iterator\n-            assert!(order::equals(s.graphemes(true), g.iter().map(|&x| x)));\n-            assert!(order::equals(s.graphemes(false), g.iter().map(|&x| x)));\n+            assert!(order::equals(s.graphemes(true), g.iter().cloned()));\n+            assert!(order::equals(s.graphemes(false), g.iter().cloned()));\n \n             // test reverse iterator\n-            assert!(order::equals(s.graphemes(true).rev(), g.iter().rev().map(|&x| x)));\n-            assert!(order::equals(s.graphemes(false).rev(), g.iter().rev().map(|&x| x)));\n+            assert!(order::equals(s.graphemes(true).rev(), g.iter().rev().cloned()));\n+            assert!(order::equals(s.graphemes(false).rev(), g.iter().rev().cloned()));\n         }\n \n         for &(s, gt, gf) in &test_diff {\n             // test forward iterator\n-            assert!(order::equals(s.graphemes(true), gt.iter().map(|&x| x)));\n-            assert!(order::equals(s.graphemes(false), gf.iter().map(|&x| x)));\n+            assert!(order::equals(s.graphemes(true), gt.iter().cloned()));\n+            assert!(order::equals(s.graphemes(false), gf.iter().cloned()));\n \n             // test reverse iterator\n-            assert!(order::equals(s.graphemes(true).rev(), gt.iter().rev().map(|&x| x)));\n-            assert!(order::equals(s.graphemes(false).rev(), gf.iter().rev().map(|&x| x)));\n+            assert!(order::equals(s.graphemes(true).rev(), gt.iter().rev().cloned()));\n+            assert!(order::equals(s.graphemes(false).rev(), gf.iter().rev().cloned()));\n         }\n \n         // test the indices iterators"}, {"sha": "ad3adc0ddb5516d0bd149e26745f35069b75cb12", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=1e75a05a0ed904cb311d117d2d65d222e20abdb2", "patch": "@@ -158,7 +158,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = Vec::new();\n+    /// let mut vec: Vec<i32> = Vec::new();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -277,7 +277,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec: Vec<int> = Vec::with_capacity(10);\n+    /// let vec: Vec<i32> = Vec::with_capacity(10);\n     /// assert_eq!(vec.capacity(), 10);\n     /// ```\n     #[inline]\n@@ -296,7 +296,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = vec![1];\n+    /// let mut vec = vec![1];\n     /// vec.reserve(10);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n@@ -325,7 +325,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = vec![1];\n+    /// let mut vec = vec![1];\n     /// vec.reserve_exact(10);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n@@ -347,7 +347,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = Vec::with_capacity(10);\n+    /// let mut vec = Vec::with_capacity(10);\n     /// vec.push_all(&[1, 2, 3]);\n     /// assert_eq!(vec.capacity(), 10);\n     /// vec.shrink_to_fit();\n@@ -424,7 +424,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// fn foo(slice: &mut [int]) {}\n+    /// fn foo(slice: &mut [i32]) {}\n     ///\n     /// let mut vec = vec![1, 2];\n     /// foo(vec.as_mut_slice());\n@@ -845,7 +845,7 @@ impl<T> Vec<T> {\n             // This `as isize` cast is safe, because the size of the elements of the\n             // vector is not 0, and:\n             //\n-            // 1) If the size of the elements in the vector is 1, the `int` may\n+            // 1) If the size of the elements in the vector is 1, the `isize` may\n             //    overflow, but it has the correct bit pattern so that the\n             //    `.offset()` function will work.\n             //\n@@ -858,7 +858,7 @@ impl<T> Vec<T> {\n             //        (0x1 + 0x8 = 0x1 - 0x8)\n             //\n             // 2) If the size of the elements in the vector is >1, the `usize` ->\n-            //    `int` conversion can't overflow.\n+            //    `isize` conversion can't overflow.\n             let offset = vec.len() as isize;\n             let start = vec.as_mut_ptr();\n \n@@ -1518,7 +1518,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// fn foo(slice: &[int]) {}\n+    /// fn foo(slice: &[i32]) {}\n     ///\n     /// let vec = vec![1, 2];\n     /// foo(vec.as_slice());\n@@ -2162,7 +2162,7 @@ mod tests {\n     fn test_zip_unzip() {\n         let z1 = vec![(1, 4), (2, 5), (3, 6)];\n \n-        let (left, right): (Vec<_>, Vec<_>) = z1.iter().map(|&x| x).unzip();\n+        let (left, right): (Vec<_>, Vec<_>) = z1.iter().cloned().unzip();\n \n         assert_eq!((1, 4), (left[0], right[0]));\n         assert_eq!((2, 5), (left[1], right[1]));"}, {"sha": "96af556dbccb7209fe9f3d99925ce2e5b71c39c7", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=1e75a05a0ed904cb311d117d2d65d222e20abdb2", "patch": "@@ -104,7 +104,7 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let mut set: HashSet<int> = HashSet::new();\n+    /// let mut set: HashSet<i32> = HashSet::new();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -119,7 +119,7 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n+    /// let mut set: HashSet<i32> = HashSet::with_capacity(10);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -187,7 +187,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let set: HashSet<int> = HashSet::with_capacity(100);\n+    /// let set: HashSet<i32> = HashSet::with_capacity(100);\n     /// assert!(set.capacity() >= 100);\n     /// ```\n     #[inline]\n@@ -208,7 +208,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let mut set: HashSet<int> = HashSet::new();\n+    /// let mut set: HashSet<i32> = HashSet::new();\n     /// set.reserve(10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -225,7 +225,7 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let mut set: HashSet<int> = HashSet::with_capacity(100);\n+    /// let mut set = HashSet::with_capacity(100);\n     /// set.insert(1);\n     /// set.insert(2);\n     /// assert!(set.capacity() >= 100);\n@@ -292,21 +292,21 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n     ///\n     /// // Can be seen as `a - b`.\n     /// for x in a.difference(&b) {\n     ///     println!(\"{}\", x); // Print 1\n     /// }\n     ///\n-    /// let diff: HashSet<int> = a.difference(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1].iter().map(|&x| x).collect());\n+    /// let diff: HashSet<_> = a.difference(&b).cloned().collect();\n+    /// assert_eq!(diff, [1].iter().cloned().collect());\n     ///\n     /// // Note that difference is not symmetric,\n     /// // and `b - a` means something else:\n-    /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n-    /// assert_eq!(diff, [4].iter().map(|&x| x).collect());\n+    /// let diff: HashSet<_> = b.difference(&a).cloned().collect();\n+    /// assert_eq!(diff, [4].iter().cloned().collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n@@ -322,19 +322,19 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n     ///\n     /// // Print 1, 4 in arbitrary order.\n     /// for x in a.symmetric_difference(&b) {\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n-    /// let diff1: HashSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n-    /// let diff2: HashSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n+    /// let diff1: HashSet<_> = a.symmetric_difference(&b).cloned().collect();\n+    /// let diff2: HashSet<_> = b.symmetric_difference(&a).cloned().collect();\n     ///\n     /// assert_eq!(diff1, diff2);\n-    /// assert_eq!(diff1, [1, 4].iter().map(|&x| x).collect());\n+    /// assert_eq!(diff1, [1, 4].iter().cloned().collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n@@ -348,16 +348,16 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n     ///\n     /// // Print 2, 3 in arbitrary order.\n     /// for x in a.intersection(&b) {\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n-    /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n+    /// let diff: HashSet<_> = a.intersection(&b).cloned().collect();\n+    /// assert_eq!(diff, [2, 3].iter().cloned().collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n@@ -373,16 +373,16 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order.\n     /// for x in a.union(&b) {\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n-    /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1, 2, 3, 4].iter().map(|&x| x).collect());\n+    /// let diff: HashSet<_> = a.union(&b).cloned().collect();\n+    /// assert_eq!(diff, [1, 2, 3, 4].iter().cloned().collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {"}, {"sha": "be441bfec886500b1f850557f79d593e5d7b9b1a", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e75a05a0ed904cb311d117d2d65d222e20abdb2/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=1e75a05a0ed904cb311d117d2d65d222e20abdb2", "patch": "@@ -65,8 +65,8 @@\n //! * You want a sorted map.\n //!\n //! ### Use a `VecMap` when:\n-//! * You want a `HashMap` but with known to be small `uint` keys.\n-//! * You want a `BTreeMap`, but with known to be small `uint` keys.\n+//! * You want a `HashMap` but with known to be small `usize` keys.\n+//! * You want a `BTreeMap`, but with known to be small `usize` keys.\n //!\n //! ### Use the `Set` variant of any of these `Map`s when:\n //! * You just want to remember which keys you've seen.\n@@ -243,7 +243,7 @@\n //! use std::collections::RingBuf;\n //!\n //! let vec = vec![1, 2, 3, 4];\n-//! let buf: RingBuf<uint> = vec.into_iter().collect();\n+//! let buf: RingBuf<_> = vec.into_iter().collect();\n //! ```\n //!\n //! Iterators also provide a series of *adapter* methods for performing common tasks to"}]}