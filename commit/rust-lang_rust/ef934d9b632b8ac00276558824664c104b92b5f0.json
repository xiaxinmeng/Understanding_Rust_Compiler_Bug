{"sha": "ef934d9b632b8ac00276558824664c104b92b5f0", "node_id": "C_kwDOAAsO6NoAKGVmOTM0ZDliNjMyYjhhYzAwMjc2NTU4ODI0NjY0YzEwNGI5MmI1ZjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-08T20:11:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-08T20:11:35Z"}, "message": "Auto merge of #107811 - matthiaskrgr:rollup-rpjzshk, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #105641 (Implement cursors for BTreeMap)\n - #107271 (Treat Drop as a rmw operation)\n - #107710 (Update strip-ansi-escapes and vte)\n - #107758 (Change `arena_cache` to not alter the declared query result)\n - #107777 (Make `derive_const` derive properly const-if-const impls)\n - #107780 (Rename `replace_bound_vars_with_*` to `instantiate_binder_with_*`)\n - #107793 (Add missing tracking issue for `RawOsError`)\n - #107807 (Fix small debug typo)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "23937bd70e247cb2a377ba35b64b0390357047f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23937bd70e247cb2a377ba35b64b0390357047f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef934d9b632b8ac00276558824664c104b92b5f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef934d9b632b8ac00276558824664c104b92b5f0", "html_url": "https://github.com/rust-lang/rust/commit/ef934d9b632b8ac00276558824664c104b92b5f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef934d9b632b8ac00276558824664c104b92b5f0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9433ba63942a736f068baacf19e5cffaff6dccc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9433ba63942a736f068baacf19e5cffaff6dccc9", "html_url": "https://github.com/rust-lang/rust/commit/9433ba63942a736f068baacf19e5cffaff6dccc9"}, {"sha": "3eea052dbbebe491f0853ffcd7448215a33e1273", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eea052dbbebe491f0853ffcd7448215a33e1273", "html_url": "https://github.com/rust-lang/rust/commit/3eea052dbbebe491f0853ffcd7448215a33e1273"}], "stats": {"total": 1458, "additions": 1248, "deletions": 210}, "files": [{"sha": "ad01ef5e41f162a918ad976df5ec3beb88a80c13", "filename": "Cargo.lock", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -127,6 +127,12 @@ version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8f8cb5d814eb646a863c4f24978cff2880c4be96ad8cde2c0f0678732902e271\"\n \n+[[package]]\n+name = \"arrayvec\"\n+version = \"0.5.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"23b62fc65de8e4e7f52534fb52b0f3ed04746ae267519eef2a83941e8085068b\"\n+\n [[package]]\n name = \"arrayvec\"\n version = \"0.7.0\"\n@@ -791,7 +797,7 @@ dependencies = [\n name = \"clippy_utils\"\n version = \"0.1.69\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.7.0\",\n  \"if_chain\",\n  \"itertools\",\n  \"rustc-semver\",\n@@ -3912,7 +3918,7 @@ dependencies = [\n name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.7.0\",\n  \"bitflags\",\n  \"cfg-if\",\n  \"ena\",\n@@ -4169,7 +4175,7 @@ dependencies = [\n name = \"rustc_index\"\n version = \"0.0.0\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.7.0\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"smallvec\",\n@@ -4866,7 +4872,7 @@ dependencies = [\n name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.7.0\",\n  \"askama\",\n  \"expect-test\",\n  \"itertools\",\n@@ -5375,9 +5381,9 @@ dependencies = [\n \n [[package]]\n name = \"strip-ansi-escapes\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9d63676e2abafa709460982ddc02a3bb586b6d15a49b75c212e06edd3933acee\"\n+checksum = \"011cbb39cf7c1f62871aea3cc46e5817b0937b49e9447370c93cacbe93a766d8\"\n dependencies = [\n  \"vte\",\n ]\n@@ -6089,9 +6095,9 @@ checksum = \"05e42f7c18b8f902290b009cde6d651262f956c98bc51bca4cd1d511c9cd85c7\"\n \n [[package]]\n name = \"utf8parse\"\n-version = \"0.1.1\"\n+version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8772a4ccbb4e89959023bc5b7cb8623a795caa7092d99f3aa9501b9484d4557d\"\n+checksum = \"936e4b492acfd135421d8dca4b1aa80a7bfc26e702ef3af710e0752684df5372\"\n \n [[package]]\n name = \"uuid\"\n@@ -6122,11 +6128,23 @@ checksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n \n [[package]]\n name = \"vte\"\n-version = \"0.3.3\"\n+version = \"0.10.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4f42f536e22f7fcbb407639765c8fd78707a33109301f834a594758bedd6e8cf\"\n+checksum = \"6cbce692ab4ca2f1f3047fcf732430249c0e971bfdd2b234cf2c47ad93af5983\"\n dependencies = [\n+ \"arrayvec 0.5.2\",\n  \"utf8parse\",\n+ \"vte_generate_state_changes\",\n+]\n+\n+[[package]]\n+name = \"vte_generate_state_changes\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d257817081c7dffcdbab24b9e62d2def62e2ff7d00b1c20062551e6cccc145ff\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n ]\n \n [[package]]"}, {"sha": "cd621bc67a1de9328e4fec0d2ebc27fa721df944", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -1567,8 +1567,18 @@ impl<'a> State<'a> {\n \n             match bound {\n                 GenericBound::Trait(tref, modifier) => {\n-                    if modifier == &TraitBoundModifier::Maybe {\n-                        self.word(\"?\");\n+                    match modifier {\n+                        TraitBoundModifier::None => {}\n+                        TraitBoundModifier::Maybe => {\n+                            self.word(\"?\");\n+                        }\n+                        TraitBoundModifier::MaybeConst => {\n+                            self.word_space(\"~const\");\n+                        }\n+                        TraitBoundModifier::MaybeConstMaybe => {\n+                            self.word_space(\"~const\");\n+                            self.word(\"?\");\n+                        }\n                     }\n                     self.print_poly_trait_ref(tref);\n                 }"}, {"sha": "3006e27e1d5b53882bfaa8528bcee7b4f8ab849b", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -1139,7 +1139,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         if let ty::Adt(def, substs) = ty.kind()\n                             && Some(def.did()) == tcx.lang_items().pin_type()\n                             && let ty::Ref(_, _, hir::Mutability::Mut) = substs.type_at(0).kind()\n-                            && let self_ty = infcx.replace_bound_vars_with_fresh_vars(\n+                            && let self_ty = infcx.instantiate_binder_with_fresh_vars(\n                                 fn_call_span,\n                                 LateBoundRegionConversionTime::FnCall,\n                                 tcx.fn_sig(method_did).subst(tcx, method_substs).input(0),"}, {"sha": "c6b78df9a5ff033db5671483da5f41c53ae772c0", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // so that they represent the view from \"inside\" the closure.\n         let user_provided_sig = self\n             .instantiate_canonical_with_fresh_inference_vars(body.span, &user_provided_poly_sig);\n-        let user_provided_sig = self.infcx.replace_bound_vars_with_fresh_vars(\n+        let user_provided_sig = self.infcx.instantiate_binder_with_fresh_vars(\n             body.span,\n             LateBoundRegionConversionTime::FnCall,\n             user_provided_sig,"}, {"sha": "e8a353b1c8fcc61474ad64cb001971ede5a5b67a", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -153,7 +153,10 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         let path_debug = cx.path_global(span, cx.std_path(&[sym::fmt, sym::Debug]));\n         let ty_dyn_debug = cx.ty(\n             span,\n-            ast::TyKind::TraitObject(vec![cx.trait_bound(path_debug)], ast::TraitObjectSyntax::Dyn),\n+            ast::TyKind::TraitObject(\n+                vec![cx.trait_bound(path_debug, false)],\n+                ast::TraitObjectSyntax::Dyn,\n+            ),\n         );\n         let ty_slice = cx.ty(\n             span,"}, {"sha": "a8c0aeb787078140ba2cab22b851002e2bbdf3f6", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -605,18 +605,26 @@ impl<'a> TraitDef<'a> {\n                     let bounds: Vec<_> = self\n                         .additional_bounds\n                         .iter()\n-                        .map(|p| cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n+                        .map(|p| {\n+                            cx.trait_bound(\n+                                p.to_path(cx, self.span, type_ident, generics),\n+                                self.is_const,\n+                            )\n+                        })\n                         .chain(\n                             // Add a bound for the current trait.\n                             self.skip_path_as_bound\n                                 .not()\n-                                .then(|| cx.trait_bound(trait_path.clone())),\n+                                .then(|| cx.trait_bound(trait_path.clone(), self.is_const)),\n                         )\n                         .chain({\n                             // Add a `Copy` bound if required.\n                             if is_packed && self.needs_copy_as_bound_if_packed {\n                                 let p = deriving::path_std!(marker::Copy);\n-                                Some(cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n+                                Some(cx.trait_bound(\n+                                    p.to_path(cx, self.span, type_ident, generics),\n+                                    self.is_const,\n+                                ))\n                             } else {\n                                 None\n                             }\n@@ -694,18 +702,24 @@ impl<'a> TraitDef<'a> {\n                         let mut bounds: Vec<_> = self\n                             .additional_bounds\n                             .iter()\n-                            .map(|p| cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n+                            .map(|p| {\n+                                cx.trait_bound(\n+                                    p.to_path(cx, self.span, type_ident, generics),\n+                                    self.is_const,\n+                                )\n+                            })\n                             .collect();\n \n                         // Require the current trait.\n-                        bounds.push(cx.trait_bound(trait_path.clone()));\n+                        bounds.push(cx.trait_bound(trait_path.clone(), self.is_const));\n \n                         // Add a `Copy` bound if required.\n                         if is_packed && self.needs_copy_as_bound_if_packed {\n                             let p = deriving::path_std!(marker::Copy);\n-                            bounds.push(\n-                                cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)),\n-                            );\n+                            bounds.push(cx.trait_bound(\n+                                p.to_path(cx, self.span, type_ident, generics),\n+                                self.is_const,\n+                            ));\n                         }\n \n                         let predicate = ast::WhereBoundPredicate {"}, {"sha": "aabd5b1f773f70baa3691862eb4a190f8068a8fb", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -154,7 +154,7 @@ fn mk_ty_param(\n         .iter()\n         .map(|b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n-            cx.trait_bound(path)\n+            cx.trait_bound(path, false)\n         })\n         .collect();\n     cx.typaram(span, Ident::new(name, span), bounds, None)"}, {"sha": "b4c12651e7a2d36e7011fac4664f36d63f695c05", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -131,10 +131,14 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn trait_bound(&self, path: ast::Path) -> ast::GenericBound {\n+    pub fn trait_bound(&self, path: ast::Path, is_const: bool) -> ast::GenericBound {\n         ast::GenericBound::Trait(\n             self.poly_trait_ref(path.span, path),\n-            ast::TraitBoundModifier::None,\n+            if is_const {\n+                ast::TraitBoundModifier::MaybeConst\n+            } else {\n+                ast::TraitBoundModifier::None\n+            },\n         )\n     }\n "}, {"sha": "236e36f28ca474e5261a54a0b2565149811179d6", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -246,7 +246,7 @@ fn compare_method_predicate_entailment<'tcx>(\n \n     let mut wf_tys = FxIndexSet::default();\n \n-    let unnormalized_impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n+    let unnormalized_impl_sig = infcx.instantiate_binder_with_fresh_vars(\n         impl_m_span,\n         infer::HigherRankedType,\n         tcx.fn_sig(impl_m.def_id).subst_identity(),\n@@ -640,7 +640,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     let impl_sig = ocx.normalize(\n         &norm_cause,\n         param_env,\n-        infcx.replace_bound_vars_with_fresh_vars(\n+        infcx.instantiate_binder_with_fresh_vars(\n             return_span,\n             infer::HigherRankedType,\n             tcx.fn_sig(impl_m.def_id).subst_identity(),"}, {"sha": "089863a66e73be9843af6ea4a5f42098aeb81edf", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(substs).is_none() {\n                     let closure_sig = substs.as_closure().sig();\n-                    let closure_sig = self.replace_bound_vars_with_fresh_vars(\n+                    let closure_sig = self.instantiate_binder_with_fresh_vars(\n                         call_expr.span,\n                         infer::FnCall,\n                         closure_sig,\n@@ -437,7 +437,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // renormalize the associated types at this point, since they\n         // previously appeared within a `Binder<>` and hence would not\n         // have been normalized before.\n-        let fn_sig = self.replace_bound_vars_with_fresh_vars(call_expr.span, infer::FnCall, fn_sig);\n+        let fn_sig = self.instantiate_binder_with_fresh_vars(call_expr.span, infer::FnCall, fn_sig);\n         let fn_sig = self.normalize(call_expr.span, fn_sig);\n \n         // Call the generic checker."}, {"sha": "211fe477a2d8d77bd77890602796e55bfe103a80", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -544,7 +544,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             )\n             .map(|(hir_ty, &supplied_ty)| {\n                 // Instantiate (this part of..) S to S', i.e., with fresh variables.\n-                self.replace_bound_vars_with_fresh_vars(\n+                self.instantiate_binder_with_fresh_vars(\n                     hir_ty.span,\n                     LateBoundRegionConversionTime::FnCall,\n                     // (*) binder moved to here\n@@ -566,7 +566,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 all_obligations.extend(obligations);\n             }\n \n-            let supplied_output_ty = self.replace_bound_vars_with_fresh_vars(\n+            let supplied_output_ty = self.instantiate_binder_with_fresh_vars(\n                 decl.output.span(),\n                 LateBoundRegionConversionTime::FnCall,\n                 supplied_sig.output(),"}, {"sha": "bb235a4836153aedb9883677474e83942bdda263", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -568,7 +568,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // placeholder lifetimes with probing, we just replace higher lifetimes\n                     // with fresh vars.\n                     let span = args.get(i).map(|a| a.span).unwrap_or(expr.span);\n-                    let input = self.replace_bound_vars_with_fresh_vars(\n+                    let input = self.instantiate_binder_with_fresh_vars(\n                         span,\n                         infer::LateBoundRegionConversionTime::FnCall,\n                         fn_sig.input(i),\n@@ -586,7 +586,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Also, as we just want to check sizedness, instead of introducing\n             // placeholder lifetimes with probing, we just replace higher lifetimes\n             // with fresh vars.\n-            let output = self.replace_bound_vars_with_fresh_vars(\n+            let output = self.instantiate_binder_with_fresh_vars(\n                 expr.span,\n                 infer::LateBoundRegionConversionTime::FnCall,\n                 fn_sig.output(),"}, {"sha": "3814ddaf73f44b8e64ebeb89418f1c875dc1da16", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -289,7 +289,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         item_segment: &hir::PathSegment<'_>,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n-        let trait_ref = self.replace_bound_vars_with_fresh_vars(\n+        let trait_ref = self.instantiate_binder_with_fresh_vars(\n             span,\n             infer::LateBoundRegionConversionTime::AssocTypeProjection(item_def_id),\n             poly_trait_ref,"}, {"sha": "fa0dc4d84150636f57bcebd7014b102d8bd57596", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                     let original_poly_trait_ref = principal.with_self_ty(this.tcx, object_ty);\n                     let upcast_poly_trait_ref = this.upcast(original_poly_trait_ref, trait_def_id);\n                     let upcast_trait_ref =\n-                        this.replace_bound_vars_with_fresh_vars(upcast_poly_trait_ref);\n+                        this.instantiate_binder_with_fresh_vars(upcast_poly_trait_ref);\n                     debug!(\n                         \"original_poly_trait_ref={:?} upcast_trait_ref={:?} target_trait={:?}\",\n                         original_poly_trait_ref, upcast_trait_ref, trait_def_id\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             probe::WhereClausePick(poly_trait_ref) => {\n                 // Where clauses can have bound regions in them. We need to instantiate\n                 // those to convert from a poly-trait-ref to a trait-ref.\n-                self.replace_bound_vars_with_fresh_vars(poly_trait_ref).substs\n+                self.instantiate_binder_with_fresh_vars(poly_trait_ref).substs\n             }\n         }\n     }\n@@ -506,7 +506,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         let sig = self.tcx.fn_sig(def_id).subst(self.tcx, all_substs);\n         debug!(\"type scheme substituted, sig={:?}\", sig);\n \n-        let sig = self.replace_bound_vars_with_fresh_vars(sig);\n+        let sig = self.instantiate_binder_with_fresh_vars(sig);\n         debug!(\"late-bound lifetimes from method instantiated, sig={:?}\", sig);\n \n         (sig, method_predicates)\n@@ -625,10 +625,10 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         upcast_trait_refs.into_iter().next().unwrap()\n     }\n \n-    fn replace_bound_vars_with_fresh_vars<T>(&self, value: ty::Binder<'tcx, T>) -> T\n+    fn instantiate_binder_with_fresh_vars<T>(&self, value: ty::Binder<'tcx, T>) -> T\n     where\n         T: TypeFoldable<'tcx> + Copy,\n     {\n-        self.fcx.replace_bound_vars_with_fresh_vars(self.span, infer::FnCall, value)\n+        self.fcx.instantiate_binder_with_fresh_vars(self.span, infer::FnCall, value)\n     }\n }"}, {"sha": "d5d10cf272afad674cced63f4473b4c934562a5b", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // with bound regions.\n         let fn_sig = tcx.fn_sig(def_id).subst(self.tcx, substs);\n         let fn_sig =\n-            self.replace_bound_vars_with_fresh_vars(obligation.cause.span, infer::FnCall, fn_sig);\n+            self.instantiate_binder_with_fresh_vars(obligation.cause.span, infer::FnCall, fn_sig);\n \n         let InferOk { value, obligations: o } =\n             self.at(&obligation.cause, self.param_env).normalize(fn_sig);"}, {"sha": "4ce401b52bd269292890b3b9bd3da39132ef1825", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -924,7 +924,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             ty::AssocKind::Fn => self.probe(|_| {\n                 let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                 let fty = self.tcx.fn_sig(method.def_id).subst(self.tcx, substs);\n-                let fty = self.replace_bound_vars_with_fresh_vars(self.span, infer::FnCall, fty);\n+                let fty = self.instantiate_binder_with_fresh_vars(self.span, infer::FnCall, fty);\n \n                 if let Some(self_ty) = self_ty {\n                     if self"}, {"sha": "7db4d92a177a1b89b13e9c93f58a3a6f9babe43d", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -129,7 +129,7 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n                 let a_types = infcx.tcx.anonymize_bound_vars(a_types);\n                 let b_types = infcx.tcx.anonymize_bound_vars(b_types);\n                 if a_types.bound_vars() == b_types.bound_vars() {\n-                    let (a_types, b_types) = infcx.replace_bound_vars_with_placeholders(\n+                    let (a_types, b_types) = infcx.instantiate_binder_with_placeholders(\n                         a_types.map_bound(|a_types| (a_types, b_types.skip_binder())),\n                     );\n                     for (a, b) in std::iter::zip(a_types, b_types) {"}, {"sha": "412e52d8fd7e21bbd2f9143ba587dbabcb7fa7ad", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -38,13 +38,13 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n         // First, we instantiate each bound region in the supertype with a\n         // fresh placeholder region. Note that this automatically creates\n         // a new universe if needed.\n-        let sup_prime = self.infcx.replace_bound_vars_with_placeholders(sup);\n+        let sup_prime = self.infcx.instantiate_binder_with_placeholders(sup);\n \n         // Next, we instantiate each bound region in the subtype\n         // with a fresh region variable. These region variables --\n         // but no other pre-existing region variables -- can name\n         // the placeholders.\n-        let sub_prime = self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, sub);\n+        let sub_prime = self.infcx.instantiate_binder_with_fresh_vars(span, HigherRankedType, sub);\n \n         debug!(\"a_prime={:?}\", sub_prime);\n         debug!(\"b_prime={:?}\", sup_prime);\n@@ -70,7 +70,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n     #[instrument(level = \"debug\", skip(self), ret)]\n-    pub fn replace_bound_vars_with_placeholders<T>(&self, binder: ty::Binder<'tcx, T>) -> T\n+    pub fn instantiate_binder_with_placeholders<T>(&self, binder: ty::Binder<'tcx, T>) -> T\n     where\n         T: TypeFoldable<'tcx> + Copy,\n     {"}, {"sha": "35918b8bae1c20b10290401962683d9a88ed13df", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -995,7 +995,7 @@ impl<'tcx> InferCtxt<'tcx> {\n \n         Ok(self.commit_if_ok(|_snapshot| {\n             let ty::SubtypePredicate { a_is_expected, a, b } =\n-                self.replace_bound_vars_with_placeholders(predicate);\n+                self.instantiate_binder_with_placeholders(predicate);\n \n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n \n@@ -1008,7 +1008,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         cause: &traits::ObligationCause<'tcx>,\n         predicate: ty::PolyRegionOutlivesPredicate<'tcx>,\n     ) {\n-        let ty::OutlivesPredicate(r_a, r_b) = self.replace_bound_vars_with_placeholders(predicate);\n+        let ty::OutlivesPredicate(r_a, r_b) = self.instantiate_binder_with_placeholders(predicate);\n         let origin =\n             SubregionOrigin::from_obligation_cause(cause, || RelateRegionParamBound(cause.span));\n         self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n@@ -1447,7 +1447,14 @@ impl<'tcx> InferCtxt<'tcx> {\n         value\n     }\n \n-    pub fn replace_bound_vars_with_fresh_vars<T>(\n+    // Instantiates the bound variables in a given binder with fresh inference\n+    // variables in the current universe.\n+    //\n+    // Use this method if you'd like to find some substitution of the binder's\n+    // variables (e.g. during a method call). If there isn't a [`LateBoundRegionConversionTime`]\n+    // that corresponds to your use case, consider whether or not you should\n+    // use [`InferCtxt::instantiate_binder_with_placeholders`] instead.\n+    pub fn instantiate_binder_with_fresh_vars<T>(\n         &self,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,"}, {"sha": "532fbd0ffe4c40c685a47ef74098d5945fdacd60", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -161,7 +161,7 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                 let a_types = infcx.tcx.anonymize_bound_vars(a_types);\n                 let b_types = infcx.tcx.anonymize_bound_vars(b_types);\n                 if a_types.bound_vars() == b_types.bound_vars() {\n-                    let (a_types, b_types) = infcx.replace_bound_vars_with_placeholders(\n+                    let (a_types, b_types) = infcx.instantiate_binder_with_placeholders(\n                         a_types.map_bound(|a_types| (a_types, b_types.skip_binder())),\n                     );\n                     for (a, b) in std::iter::zip(a_types, b_types) {"}, {"sha": "0a16ede64991de8d36cd4adf23c1ac435a783e07", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -54,14 +54,14 @@ rustc_queries! {\n     /// This is because the `hir_crate` query gives you access to all other items.\n     /// To avoid this fate, do not call `tcx.hir().krate()`; instead,\n     /// prefer wrappers like `tcx.visit_all_items_in_krate()`.\n-    query hir_crate(key: ()) -> Crate<'tcx> {\n+    query hir_crate(key: ()) -> &'tcx Crate<'tcx> {\n         arena_cache\n         eval_always\n         desc { \"getting the crate HIR\" }\n     }\n \n     /// All items in the crate.\n-    query hir_crate_items(_: ()) -> rustc_middle::hir::ModuleItems {\n+    query hir_crate_items(_: ()) -> &'tcx rustc_middle::hir::ModuleItems {\n         arena_cache\n         eval_always\n         desc { \"getting HIR crate items\" }\n@@ -71,7 +71,7 @@ rustc_queries! {\n     ///\n     /// This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`.\n     /// Avoid calling this query directly.\n-    query hir_module_items(key: LocalDefId) -> rustc_middle::hir::ModuleItems {\n+    query hir_module_items(key: LocalDefId) -> &'tcx rustc_middle::hir::ModuleItems {\n         arena_cache\n         desc { |tcx| \"getting HIR module items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n@@ -183,7 +183,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query unsizing_params_for_adt(key: DefId) -> rustc_index::bit_set::BitSet<u32>\n+    query unsizing_params_for_adt(key: DefId) -> &'tcx rustc_index::bit_set::BitSet<u32>\n     {\n         arena_cache\n         desc { |tcx|\n@@ -218,7 +218,7 @@ rustc_queries! {\n \n     /// Maps from the `DefId` of an item (trait/struct/enum/fn) to its\n     /// associated generics.\n-    query generics_of(key: DefId) -> ty::Generics {\n+    query generics_of(key: DefId) -> &'tcx ty::Generics {\n         desc { |tcx| \"computing generics of `{}`\", tcx.def_path_str(key) }\n         arena_cache\n         cache_on_disk_if { key.is_local() }\n@@ -295,19 +295,19 @@ rustc_queries! {\n     /// These are assembled from the following places:\n     /// - `extern` blocks (depending on their `link` attributes)\n     /// - the `libs` (`-l`) option\n-    query native_libraries(_: CrateNum) -> Vec<NativeLib> {\n+    query native_libraries(_: CrateNum) -> &'tcx Vec<NativeLib> {\n         arena_cache\n         desc { \"looking up the native libraries of a linked crate\" }\n         separate_provide_extern\n     }\n \n-    query shallow_lint_levels_on(key: hir::OwnerId) -> rustc_middle::lint::ShallowLintLevelMap {\n+    query shallow_lint_levels_on(key: hir::OwnerId) -> &'tcx rustc_middle::lint::ShallowLintLevelMap {\n         eval_always // fetches `resolutions`\n         arena_cache\n         desc { |tcx| \"looking up lint levels for `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n-    query lint_expectations(_: ()) -> Vec<(LintExpectationId, LintExpectation)> {\n+    query lint_expectations(_: ()) -> &'tcx Vec<(LintExpectationId, LintExpectation)> {\n         arena_cache\n         desc { \"computing `#[expect]`ed lints in this crate\" }\n     }\n@@ -347,7 +347,7 @@ rustc_queries! {\n     }\n \n     /// Set of param indexes for type params that are in the type's representation\n-    query params_in_repr(key: DefId) -> rustc_index::bit_set::BitSet<u32> {\n+    query params_in_repr(key: DefId) -> &'tcx rustc_index::bit_set::BitSet<u32> {\n         desc { \"finding type parameters in the representation\" }\n         arena_cache\n         no_hash\n@@ -364,14 +364,14 @@ rustc_queries! {\n     }\n \n     /// Create a THIR tree for debugging.\n-    query thir_tree(key: ty::WithOptConstParam<LocalDefId>) -> String {\n+    query thir_tree(key: ty::WithOptConstParam<LocalDefId>) -> &'tcx String {\n         no_hash\n         arena_cache\n         desc { |tcx| \"constructing THIR tree for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n     }\n \n     /// Create a list-like THIR representation for debugging.\n-    query thir_flat(key: ty::WithOptConstParam<LocalDefId>) -> String {\n+    query thir_flat(key: ty::WithOptConstParam<LocalDefId>) -> &'tcx String {\n         no_hash\n         arena_cache\n         desc { |tcx| \"constructing flat THIR representation for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n@@ -380,7 +380,7 @@ rustc_queries! {\n     /// Set of all the `DefId`s in this crate that have MIR associated with\n     /// them. This includes all the body owners, but also things like struct\n     /// constructors.\n-    query mir_keys(_: ()) -> rustc_data_structures::fx::FxIndexSet<LocalDefId> {\n+    query mir_keys(_: ()) -> &'tcx rustc_data_structures::fx::FxIndexSet<LocalDefId> {\n         arena_cache\n         desc { \"getting a list of all mir_keys\" }\n     }\n@@ -478,7 +478,7 @@ rustc_queries! {\n \n     query symbols_for_closure_captures(\n         key: (LocalDefId, LocalDefId)\n-    ) -> Vec<rustc_span::Symbol> {\n+    ) -> &'tcx Vec<rustc_span::Symbol> {\n         arena_cache\n         desc {\n             |tcx| \"finding symbols for captures of closure `{}` in `{}`\",\n@@ -487,7 +487,7 @@ rustc_queries! {\n         }\n     }\n \n-    query mir_generator_witnesses(key: DefId) -> mir::GeneratorLayout<'tcx> {\n+    query mir_generator_witnesses(key: DefId) -> &'tcx mir::GeneratorLayout<'tcx> {\n         arena_cache\n         desc { |tcx| \"generator witness types for `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n@@ -508,14 +508,14 @@ rustc_queries! {\n \n     /// Returns coverage summary info for a function, after executing the `InstrumentCoverage`\n     /// MIR pass (assuming the -Cinstrument-coverage option is enabled).\n-    query coverageinfo(key: ty::InstanceDef<'tcx>) -> mir::CoverageInfo {\n+    query coverageinfo(key: ty::InstanceDef<'tcx>) -> &'tcx mir::CoverageInfo {\n         desc { |tcx| \"retrieving coverage info from MIR for `{}`\", tcx.def_path_str(key.def_id()) }\n         arena_cache\n     }\n \n     /// Returns the `CodeRegions` for a function that has instrumented coverage, in case the\n     /// function was optimized out before codegen, and before being added to the Coverage Map.\n-    query covered_code_regions(key: DefId) -> Vec<&'tcx mir::coverage::CodeRegion> {\n+    query covered_code_regions(key: DefId) -> &'tcx Vec<&'tcx mir::coverage::CodeRegion> {\n         desc {\n             |tcx| \"retrieving the covered `CodeRegion`s, if instrumented, for `{}`\",\n             tcx.def_path_str(key)\n@@ -557,7 +557,7 @@ rustc_queries! {\n         desc { \"erasing regions from `{}`\", ty }\n     }\n \n-    query wasm_import_module_map(_: CrateNum) -> FxHashMap<DefId, String> {\n+    query wasm_import_module_map(_: CrateNum) -> &'tcx FxHashMap<DefId, String> {\n         arena_cache\n         desc { \"getting wasm import module map\" }\n     }\n@@ -632,7 +632,7 @@ rustc_queries! {\n         desc { |tcx| \"computing the bounds for type parameter `{}`\", tcx.hir().ty_param_name(key.1) }\n     }\n \n-    query trait_def(key: DefId) -> ty::TraitDef {\n+    query trait_def(key: DefId) -> &'tcx ty::TraitDef {\n         desc { |tcx| \"computing trait definition for `{}`\", tcx.def_path_str(key) }\n         arena_cache\n         cache_on_disk_if { key.is_local() }\n@@ -703,7 +703,7 @@ rustc_queries! {\n     }\n \n     /// Gets a map with the variance of every item; use `item_variance` instead.\n-    query crate_variances(_: ()) -> ty::CrateVariancesMap<'tcx> {\n+    query crate_variances(_: ()) -> &'tcx ty::CrateVariancesMap<'tcx> {\n         arena_cache\n         desc { \"computing the variances for items in this crate\" }\n     }\n@@ -716,7 +716,7 @@ rustc_queries! {\n     }\n \n     /// Maps from thee `DefId` of a type to its (inferred) outlives.\n-    query inferred_outlives_crate(_: ()) -> ty::CratePredicatesMap<'tcx> {\n+    query inferred_outlives_crate(_: ()) -> &'tcx ty::CratePredicatesMap<'tcx> {\n         arena_cache\n         desc { \"computing the inferred outlives predicates for items in this crate\" }\n     }\n@@ -729,15 +729,15 @@ rustc_queries! {\n     }\n \n     /// Maps from a trait item to the trait item \"descriptor\".\n-    query associated_item(key: DefId) -> ty::AssocItem {\n+    query associated_item(key: DefId) -> &'tcx ty::AssocItem {\n         desc { |tcx| \"computing associated item data for `{}`\", tcx.def_path_str(key) }\n         arena_cache\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n \n     /// Collects the associated items defined on a trait or impl.\n-    query associated_items(key: DefId) -> ty::AssocItems<'tcx> {\n+    query associated_items(key: DefId) -> &'tcx ty::AssocItems<'tcx> {\n         arena_cache\n         desc { |tcx| \"collecting associated items of `{}`\", tcx.def_path_str(key) }\n     }\n@@ -763,7 +763,7 @@ rustc_queries! {\n     ///\n     /// The map returned for `tcx.impl_item_implementor_ids(impl_id)` would be\n     ///`{ trait_f: impl_f, trait_g: impl_g }`\n-    query impl_item_implementor_ids(impl_id: DefId) -> FxHashMap<DefId, DefId> {\n+    query impl_item_implementor_ids(impl_id: DefId) -> &'tcx FxHashMap<DefId, DefId> {\n         arena_cache\n         desc { |tcx| \"comparing impl items against trait for `{}`\", tcx.def_path_str(impl_id) }\n     }\n@@ -884,7 +884,7 @@ rustc_queries! {\n     ///\n     /// The second return value maps from ADTs to ignored derived traits (e.g. Debug and Clone) and\n     /// their respective impl (i.e., part of the derive macro)\n-    query live_symbols_and_ignored_derived_traits(_: ()) -> (\n+    query live_symbols_and_ignored_derived_traits(_: ()) -> &'tcx (\n         FxHashSet<LocalDefId>,\n         FxHashMap<LocalDefId, Vec<(DefId, DefId)>>\n     ) {\n@@ -964,7 +964,7 @@ rustc_queries! {\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n-    query crate_inherent_impls(k: ()) -> CrateInherentImpls {\n+    query crate_inherent_impls(k: ()) -> &'tcx CrateInherentImpls {\n         arena_cache\n         desc { \"finding all inherent impls defined in crate\" }\n     }\n@@ -1099,7 +1099,7 @@ rustc_queries! {\n         desc { \"checking for private elements in public interfaces\" }\n     }\n \n-    query reachable_set(_: ()) -> FxHashSet<LocalDefId> {\n+    query reachable_set(_: ()) -> &'tcx FxHashSet<LocalDefId> {\n         arena_cache\n         desc { \"reachability\" }\n     }\n@@ -1111,7 +1111,7 @@ rustc_queries! {\n     }\n \n     /// Generates a MIR body for the shim.\n-    query mir_shims(key: ty::InstanceDef<'tcx>) -> mir::Body<'tcx> {\n+    query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::Body<'tcx> {\n         arena_cache\n         desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n     }\n@@ -1191,7 +1191,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query codegen_fn_attrs(def_id: DefId) -> CodegenFnAttrs {\n+    query codegen_fn_attrs(def_id: DefId) -> &'tcx CodegenFnAttrs {\n         desc { |tcx| \"computing codegen attributes of `{}`\", tcx.def_path_str(def_id) }\n         arena_cache\n         cache_on_disk_if { def_id.is_local() }\n@@ -1209,7 +1209,7 @@ rustc_queries! {\n     }\n     /// Gets the rendered value of the specified constant or associated constant.\n     /// Used by rustdoc.\n-    query rendered_const(def_id: DefId) -> String {\n+    query rendered_const(def_id: DefId) -> &'tcx String {\n         arena_cache\n         desc { |tcx| \"rendering constant initializer of `{}`\", tcx.def_path_str(def_id) }\n         cache_on_disk_if { def_id.is_local() }\n@@ -1268,12 +1268,12 @@ rustc_queries! {\n     }\n \n     /// Given a trait `trait_id`, return all known `impl` blocks.\n-    query trait_impls_of(trait_id: DefId) -> ty::trait_def::TraitImpls {\n+    query trait_impls_of(trait_id: DefId) -> &'tcx ty::trait_def::TraitImpls {\n         arena_cache\n         desc { |tcx| \"finding trait impls of `{}`\", tcx.def_path_str(trait_id) }\n     }\n \n-    query specialization_graph_of(trait_id: DefId) -> specialization_graph::Graph {\n+    query specialization_graph_of(trait_id: DefId) -> &'tcx specialization_graph::Graph {\n         arena_cache\n         desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(trait_id) }\n         cache_on_disk_if { true }\n@@ -1403,7 +1403,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query dependency_formats(_: ()) -> Lrc<crate::middle::dependency_format::Dependencies> {\n+    query dependency_formats(_: ()) -> &'tcx Lrc<crate::middle::dependency_format::Dependencies> {\n         arena_cache\n         desc { \"getting the linkage format of all dependencies\" }\n     }\n@@ -1503,7 +1503,7 @@ rustc_queries! {\n     // Does not include external symbols that don't have a corresponding DefId,\n     // like the compiler-generated `main` function and so on.\n     query reachable_non_generics(_: CrateNum)\n-        -> DefIdMap<SymbolExportInfo> {\n+        -> &'tcx DefIdMap<SymbolExportInfo> {\n         arena_cache\n         desc { \"looking up the exported symbols of a crate\" }\n         separate_provide_extern\n@@ -1526,7 +1526,7 @@ rustc_queries! {\n     /// added or removed in any upstream crate. Instead use the narrower\n     /// `upstream_monomorphizations_for`, `upstream_drop_glue_for`, or, even\n     /// better, `Instance::upstream_monomorphization()`.\n-    query upstream_monomorphizations(_: ()) -> DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n+    query upstream_monomorphizations(_: ()) -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n         arena_cache\n         desc { \"collecting available upstream monomorphizations\" }\n     }\n@@ -1568,7 +1568,7 @@ rustc_queries! {\n     }\n \n     /// Returns a list of all `extern` blocks of a crate.\n-    query foreign_modules(_: CrateNum) -> FxHashMap<DefId, ForeignModule> {\n+    query foreign_modules(_: CrateNum) -> &'tcx FxHashMap<DefId, ForeignModule> {\n         arena_cache\n         desc { \"looking up the foreign modules of a linked crate\" }\n         separate_provide_extern\n@@ -1602,15 +1602,15 @@ rustc_queries! {\n \n     /// Gets the extra data to put in each output filename for a crate.\n     /// For example, compiling the `foo` crate with `extra-filename=-a` creates a `libfoo-b.rlib` file.\n-    query extra_filename(_: CrateNum) -> String {\n+    query extra_filename(_: CrateNum) -> &'tcx String {\n         arena_cache\n         eval_always\n         desc { \"looking up the extra filename for a crate\" }\n         separate_provide_extern\n     }\n \n     /// Gets the paths where the crate came from in the file system.\n-    query crate_extern_paths(_: CrateNum) -> Vec<PathBuf> {\n+    query crate_extern_paths(_: CrateNum) -> &'tcx Vec<PathBuf> {\n         arena_cache\n         eval_always\n         desc { \"looking up the paths for extern crates\" }\n@@ -1641,7 +1641,7 @@ rustc_queries! {\n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n     /// See `rustc_resolve::late::lifetimes for details.\n-    query resolve_lifetimes(_: hir::OwnerId) -> ResolveLifetimes {\n+    query resolve_lifetimes(_: hir::OwnerId) -> &'tcx ResolveLifetimes {\n         arena_cache\n         desc { \"resolving lifetimes\" }\n     }\n@@ -1712,15 +1712,15 @@ rustc_queries! {\n         desc { |tcx| \"computing crate imported by `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n \n-    query lib_features(_: ()) -> LibFeatures {\n+    query lib_features(_: ()) -> &'tcx LibFeatures {\n         arena_cache\n         desc { \"calculating the lib features map\" }\n     }\n     query defined_lib_features(_: CrateNum) -> &'tcx [(Symbol, Option<Symbol>)] {\n         desc { \"calculating the lib features defined in a crate\" }\n         separate_provide_extern\n     }\n-    query stability_implications(_: CrateNum) -> FxHashMap<Symbol, Symbol> {\n+    query stability_implications(_: CrateNum) -> &'tcx FxHashMap<Symbol, Symbol> {\n         arena_cache\n         desc { \"calculating the implications between `#[unstable]` features defined in a crate\" }\n         separate_provide_extern\n@@ -1731,14 +1731,14 @@ rustc_queries! {\n         separate_provide_extern\n     }\n     /// Returns the lang items defined in another crate by loading it from metadata.\n-    query get_lang_items(_: ()) -> LanguageItems {\n+    query get_lang_items(_: ()) -> &'tcx LanguageItems {\n         arena_cache\n         eval_always\n         desc { \"calculating the lang items map\" }\n     }\n \n     /// Returns all diagnostic items defined in all crates.\n-    query all_diagnostic_items(_: ()) -> rustc_hir::diagnostic_items::DiagnosticItems {\n+    query all_diagnostic_items(_: ()) -> &'tcx rustc_hir::diagnostic_items::DiagnosticItems {\n         arena_cache\n         eval_always\n         desc { \"calculating the diagnostic items map\" }\n@@ -1751,7 +1751,7 @@ rustc_queries! {\n     }\n \n     /// Returns the diagnostic items defined in a crate.\n-    query diagnostic_items(_: CrateNum) -> rustc_hir::diagnostic_items::DiagnosticItems {\n+    query diagnostic_items(_: CrateNum) -> &'tcx rustc_hir::diagnostic_items::DiagnosticItems {\n         arena_cache\n         desc { \"calculating the diagnostic items map in a crate\" }\n         separate_provide_extern\n@@ -1761,11 +1761,11 @@ rustc_queries! {\n         desc { \"calculating the missing lang items in a crate\" }\n         separate_provide_extern\n     }\n-    query visible_parent_map(_: ()) -> DefIdMap<DefId> {\n+    query visible_parent_map(_: ()) -> &'tcx DefIdMap<DefId> {\n         arena_cache\n         desc { \"calculating the visible parent map\" }\n     }\n-    query trimmed_def_paths(_: ()) -> FxHashMap<DefId, Symbol> {\n+    query trimmed_def_paths(_: ()) -> &'tcx FxHashMap<DefId, Symbol> {\n         arena_cache\n         desc { \"calculating trimmed def paths\" }\n     }\n@@ -1774,14 +1774,14 @@ rustc_queries! {\n         desc { \"seeing if we're missing an `extern crate` item for this crate\" }\n         separate_provide_extern\n     }\n-    query used_crate_source(_: CrateNum) -> Lrc<CrateSource> {\n+    query used_crate_source(_: CrateNum) -> &'tcx Lrc<CrateSource> {\n         arena_cache\n         eval_always\n         desc { \"looking at the source for a crate\" }\n         separate_provide_extern\n     }\n     /// Returns the debugger visualizers defined for this crate.\n-    query debugger_visualizers(_: CrateNum) -> Vec<rustc_span::DebuggerVisualizerFile> {\n+    query debugger_visualizers(_: CrateNum) -> &'tcx Vec<rustc_span::DebuggerVisualizerFile> {\n         arena_cache\n         desc { \"looking up the debugger visualizers for this crate\" }\n         separate_provide_extern\n@@ -1819,7 +1819,7 @@ rustc_queries! {\n         desc { |tcx| \"finding names imported by glob use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n \n-    query stability_index(_: ()) -> stability::Index {\n+    query stability_index(_: ()) -> &'tcx stability::Index {\n         arena_cache\n         eval_always\n         desc { \"calculating the stability index for the local crate\" }\n@@ -1883,7 +1883,7 @@ rustc_queries! {\n     ///\n     /// This query returns an `&Arc` because codegen backends need the value even after the `TyCtxt`\n     /// has been destroyed.\n-    query output_filenames(_: ()) -> Arc<OutputFilenames> {\n+    query output_filenames(_: ()) -> &'tcx Arc<OutputFilenames> {\n         feedable\n         desc { \"getting output filenames\" }\n         arena_cache\n@@ -2056,7 +2056,7 @@ rustc_queries! {\n         remap_env_constness\n     }\n \n-    query supported_target_features(_: CrateNum) -> FxHashMap<String, Option<Symbol>> {\n+    query supported_target_features(_: CrateNum) -> &'tcx FxHashMap<String, Option<Symbol>> {\n         arena_cache\n         eval_always\n         desc { \"looking up supported target features\" }\n@@ -2115,23 +2115,24 @@ rustc_queries! {\n     /// span) for an *existing* error. Therefore, it is best-effort, and may never handle\n     /// all of the cases that the normal `ty::Ty`-based wfcheck does. This is fine,\n     /// because the `ty::Ty`-based wfcheck is always run.\n-    query diagnostic_hir_wf_check(key: (ty::Predicate<'tcx>, traits::WellFormedLoc)) -> Option<traits::ObligationCause<'tcx>> {\n+    query diagnostic_hir_wf_check(\n+        key: (ty::Predicate<'tcx>, traits::WellFormedLoc)\n+    ) -> &'tcx Option<traits::ObligationCause<'tcx>> {\n         arena_cache\n         eval_always\n         no_hash\n         desc { \"performing HIR wf-checking for predicate `{:?}` at item `{:?}`\", key.0, key.1 }\n     }\n \n-\n     /// The list of backend features computed from CLI flags (`-Ctarget-cpu`, `-Ctarget-feature`,\n     /// `--target` and similar).\n-    query global_backend_features(_: ()) -> Vec<String> {\n+    query global_backend_features(_: ()) -> &'tcx Vec<String> {\n         arena_cache\n         eval_always\n         desc { \"computing the backend features for CLI flags\" }\n     }\n \n-    query generator_diagnostic_data(key: DefId) -> Option<GeneratorDiagnosticData<'tcx>> {\n+    query generator_diagnostic_data(key: DefId) -> &'tcx Option<GeneratorDiagnosticData<'tcx>> {\n         arena_cache\n         desc { |tcx| \"looking up generator diagnostic data of `{}`\", tcx.def_path_str(key) }\n         separate_provide_extern"}, {"sha": "933aaadd62e1dd4a34dfc36410a192d904b2f259", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -112,15 +112,15 @@ macro_rules! query_helper_param_ty {\n     ($K:ty) => { $K };\n }\n \n-macro_rules! query_storage {\n-    ([][$K:ty, $V:ty]) => {\n-        <<$K as Key>::CacheSelector as CacheSelector<'tcx, $V>>::Cache\n+macro_rules! query_if_arena {\n+    ([] $arena:ty, $no_arena:ty) => {\n+        $no_arena\n     };\n-    ([(arena_cache) $($rest:tt)*][$K:ty, $V:ty]) => {\n-        <<$K as Key>::CacheSelector as CacheSelector<'tcx, $V>>::ArenaCache\n+    ([(arena_cache) $($rest:tt)*] $arena:ty, $no_arena:ty) => {\n+        $arena\n     };\n-    ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n-        query_storage!([$($modifiers)*][$($args)*])\n+    ([$other:tt $($modifiers:tt)*]$($args:tt)*) => {\n+        query_if_arena!([$($modifiers)*]$($args)*)\n     };\n }\n \n@@ -184,23 +184,30 @@ macro_rules! define_callbacks {\n \n             $(pub type $name<'tcx> = $($K)*;)*\n         }\n-        #[allow(nonstandard_style, unused_lifetimes)]\n+        #[allow(nonstandard_style, unused_lifetimes, unused_parens)]\n         pub mod query_values {\n             use super::*;\n \n-            $(pub type $name<'tcx> = $V;)*\n+            $(pub type $name<'tcx> = query_if_arena!([$($modifiers)*] <$V as Deref>::Target, $V);)*\n         }\n-        #[allow(nonstandard_style, unused_lifetimes)]\n+        #[allow(nonstandard_style, unused_lifetimes, unused_parens)]\n         pub mod query_storage {\n             use super::*;\n \n-            $(pub type $name<'tcx> = query_storage!([$($modifiers)*][$($K)*, $V]);)*\n+            $(\n+                pub type $name<'tcx> = query_if_arena!([$($modifiers)*]\n+                    <<$($K)* as Key>::CacheSelector\n+                        as CacheSelector<'tcx, <$V as Deref>::Target>>::ArenaCache,\n+                    <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, $V>>::Cache\n+                );\n+            )*\n         }\n+\n         #[allow(nonstandard_style, unused_lifetimes)]\n         pub mod query_stored {\n             use super::*;\n \n-            $(pub type $name<'tcx> = <query_storage::$name<'tcx> as QueryStorage>::Stored;)*\n+            $(pub type $name<'tcx> = $V;)*\n         }\n \n         #[derive(Default)]\n@@ -226,7 +233,7 @@ macro_rules! define_callbacks {\n             $($(#[$attr])*\n             #[inline(always)]\n             #[must_use]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<'tcx>\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> $V\n             {\n                 self.at(DUMMY_SP).$name(key)\n             })*\n@@ -235,7 +242,7 @@ macro_rules! define_callbacks {\n         impl<'tcx> TyCtxtAt<'tcx> {\n             $($(#[$attr])*\n             #[inline(always)]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<'tcx>\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> $V\n             {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n@@ -306,7 +313,7 @@ macro_rules! define_callbacks {\n                 span: Span,\n                 key: query_keys::$name<'tcx>,\n                 mode: QueryMode,\n-            ) -> Option<query_stored::$name<'tcx>>;)*\n+            ) -> Option<$V>;)*\n         }\n     };\n }\n@@ -328,7 +335,7 @@ macro_rules! define_feedable {\n         $(impl<'tcx, K: IntoQueryParam<$($K)*> + Copy> TyCtxtFeed<'tcx, K> {\n             $(#[$attr])*\n             #[inline(always)]\n-            pub fn $name(self, value: $V) -> query_stored::$name<'tcx> {\n+            pub fn $name(self, value: query_values::$name<'tcx>) -> $V {\n                 let key = self.key().into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n "}, {"sha": "0d466bbe56e01d82b7d5550ca8dc2688495c3a0c", "filename": "compiler/rustc_mir_dataflow/src/drop_flag_effects.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -1,5 +1,5 @@\n use crate::elaborate_drops::DropFlagState;\n-use rustc_middle::mir::{self, Body, Location};\n+use rustc_middle::mir::{self, Body, Location, Terminator, TerminatorKind};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n@@ -194,6 +194,17 @@ pub fn drop_flag_effects_for_location<'tcx, F>(\n         on_all_children_bits(tcx, body, move_data, path, |mpi| callback(mpi, DropFlagState::Absent))\n     }\n \n+    // Drop does not count as a move but we should still consider the variable uninitialized.\n+    if let Some(Terminator { kind: TerminatorKind::Drop { place, .. }, .. }) =\n+        body.stmt_at(loc).right()\n+    {\n+        if let LookupResult::Exact(mpi) = move_data.rev_lookup.find(place.as_ref()) {\n+            on_all_children_bits(tcx, body, move_data, mpi, |mpi| {\n+                callback(mpi, DropFlagState::Absent)\n+            })\n+        }\n+    }\n+\n     debug!(\"drop_flag_effects: assignment for location({:?})\", loc);\n \n     for_location_inits(tcx, body, move_data, loc, |mpi| callback(mpi, DropFlagState::Present));"}, {"sha": "115c8afcce0cf7c15964bd53b175366c0ac6b7fd", "filename": "compiler/rustc_mir_dataflow/src/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -376,7 +376,8 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             | TerminatorKind::Resume\n             | TerminatorKind::Abort\n             | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::Unreachable => {}\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Drop { .. } => {}\n \n             TerminatorKind::Assert { ref cond, .. } => {\n                 self.gather_operand(cond);\n@@ -391,10 +392,6 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 self.create_move_path(place);\n                 self.gather_init(place.as_ref(), InitKind::Deep);\n             }\n-\n-            TerminatorKind::Drop { place, target: _, unwind: _ } => {\n-                self.gather_move(place);\n-            }\n             TerminatorKind::DropAndReplace { place, ref value, .. } => {\n                 self.create_move_path(place);\n                 self.gather_operand(value);"}, {"sha": "a6ef2a742c8736219f84946e85a8e6e44ee2c544", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -223,13 +223,13 @@ pub trait ValueAnalysis<'tcx> {\n         self.super_terminator(terminator, state)\n     }\n \n-    fn super_terminator(&self, terminator: &Terminator<'tcx>, _state: &mut State<Self::Value>) {\n+    fn super_terminator(&self, terminator: &Terminator<'tcx>, state: &mut State<Self::Value>) {\n         match &terminator.kind {\n             TerminatorKind::Call { .. } | TerminatorKind::InlineAsm { .. } => {\n                 // Effect is applied by `handle_call_return`.\n             }\n-            TerminatorKind::Drop { .. } => {\n-                // We don't track dropped places.\n+            TerminatorKind::Drop { place, .. } => {\n+                state.flood_with(place.as_ref(), self.map(), Self::Value::bottom());\n             }\n             TerminatorKind::DropAndReplace { .. } | TerminatorKind::Yield { .. } => {\n                 // They would have an effect, but are not allowed in this phase."}, {"sha": "c2ff8645635e01597ea6c0d55ece679df9e80f9f", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -18,6 +18,35 @@ use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use std::fmt;\n \n+/// During MIR building, Drop and DropAndReplace terminators are inserted in every place where a drop may occur.\n+/// However, in this phase, the presence of these terminators does not guarantee that a destructor will run,\n+/// as the target of the drop may be uninitialized.\n+/// In general, the compiler cannot determine at compile time whether a destructor will run or not.\n+///\n+/// At a high level, this pass refines Drop and DropAndReplace to only run the destructor if the\n+/// target is initialized. The way this is achievied is by inserting drop flags for every variable\n+/// that may be dropped, and then using those flags to determine whether a destructor should run.\n+/// This pass also removes DropAndReplace, replacing it with a Drop paired with an assign statement.\n+/// Once this is complete, Drop terminators in the MIR correspond to a call to the \"drop glue\" or\n+/// \"drop shim\" for the type of the dropped place.\n+///\n+/// This pass relies on dropped places having an associated move path, which is then used to determine\n+/// the initialization status of the place and its descendants.\n+/// It's worth noting that a MIR containing a Drop without an associated move path is probably ill formed,\n+/// as it would allow running a destructor on a place behind a reference:\n+///\n+/// ```text\n+// fn drop_term<T>(t: &mut T) {\n+//     mir!(\n+//         {\n+//             Drop(*t, exit)\n+//         }\n+//         exit = {\n+//             Return()\n+//         }\n+//     )\n+// }\n+/// ```\n pub struct ElaborateDrops;\n \n impl<'tcx> MirPass<'tcx> for ElaborateDrops {"}, {"sha": "c1936b7dbe41ec0743130a33af65837e39b92345", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                     )\n                                 }\n                                 ty::PredicateKind::Subtype(pred) => {\n-                                    let (a, b) = infcx.replace_bound_vars_with_placeholders(\n+                                    let (a, b) = infcx.instantiate_binder_with_placeholders(\n                                         goal.predicate.kind().rebind((pred.a, pred.b)),\n                                     );\n                                     let expected_found = ExpectedFound::new(true, a, b);\n@@ -84,7 +84,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                     )\n                                 }\n                                 ty::PredicateKind::Coerce(pred) => {\n-                                    let (a, b) = infcx.replace_bound_vars_with_placeholders(\n+                                    let (a, b) = infcx.instantiate_binder_with_placeholders(\n                                         goal.predicate.kind().rebind((pred.a, pred.b)),\n                                     );\n                                     let expected_found = ExpectedFound::new(false, a, b);\n@@ -94,7 +94,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                     )\n                                 }\n                                 ty::PredicateKind::ConstEquate(a, b) => {\n-                                    let (a, b) = infcx.replace_bound_vars_with_placeholders(\n+                                    let (a, b) = infcx.instantiate_binder_with_placeholders(\n                                         goal.predicate.kind().rebind((a, b)),\n                                     );\n                                     let expected_found = ExpectedFound::new(true, a, b);"}, {"sha": "36f987c9f9cb6d3e1a2db0bbcd2e588e9c40c373", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -26,7 +26,7 @@ pub(super) trait InferCtxtExt<'tcx> {\n         rhs: T,\n     ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution>;\n \n-    fn instantiate_bound_vars_with_infer<T: TypeFoldable<'tcx> + Copy>(\n+    fn instantiate_binder_with_infer<T: TypeFoldable<'tcx> + Copy>(\n         &self,\n         value: ty::Binder<'tcx, T>,\n     ) -> T;\n@@ -65,11 +65,11 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             })\n     }\n \n-    fn instantiate_bound_vars_with_infer<T: TypeFoldable<'tcx> + Copy>(\n+    fn instantiate_binder_with_infer<T: TypeFoldable<'tcx> + Copy>(\n         &self,\n         value: ty::Binder<'tcx, T>,\n     ) -> T {\n-        self.replace_bound_vars_with_fresh_vars(\n+        self.instantiate_binder_with_fresh_vars(\n             DUMMY_SP,\n             LateBoundRegionConversionTime::HigherRankedType,\n             value,"}, {"sha": "9f092b6018f483303bc1691784701619f33fff14", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -304,7 +304,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 }\n             }\n         } else {\n-            let kind = self.infcx.replace_bound_vars_with_placeholders(kind);\n+            let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n             let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n             let (_, certainty) = self.evaluate_goal(goal)?;\n             self.make_canonical_response(certainty)"}, {"sha": "e3ec71d1b4f7375643eef5d6393af37c1b140675", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -323,7 +323,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         {\n             ecx.infcx.probe(|_| {\n                 let assumption_projection_pred =\n-                    ecx.infcx.instantiate_bound_vars_with_infer(poly_projection_pred);\n+                    ecx.infcx.instantiate_binder_with_infer(poly_projection_pred);\n                 let nested_goals = ecx.infcx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,"}, {"sha": "06a72e95d4905461814477d70ad25e42d060f91b", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             // FIXME: Constness and polarity\n             ecx.infcx.probe(|_| {\n                 let assumption_trait_pred =\n-                    ecx.infcx.instantiate_bound_vars_with_infer(poly_trait_pred);\n+                    ecx.infcx.instantiate_binder_with_infer(poly_trait_pred);\n                 let nested_goals = ecx.infcx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,"}, {"sha": "1ee35a86e626424a3c6a0871f9b84f3f01145423", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -54,7 +54,7 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n         }\n \n         ty::GeneratorWitness(types) => {\n-            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n+            Ok(infcx.instantiate_binder_with_placeholders(types).to_vec())\n         }\n \n         ty::GeneratorWitnessMIR(..) => todo!(),\n@@ -174,7 +174,7 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n         }\n \n         ty::GeneratorWitness(types) => {\n-            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n+            Ok(infcx.instantiate_binder_with_placeholders(types).to_vec())\n         }\n \n         ty::GeneratorWitnessMIR(..) => todo!(),"}, {"sha": "84045c4d0edea11f5e61f766a0f1bc3cf1f607e8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/ambiguity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -22,7 +22,7 @@ pub fn recompute_applicable_impls<'tcx>(\n     let impl_may_apply = |impl_def_id| {\n         let ocx = ObligationCtxt::new_in_snapshot(infcx);\n         let placeholder_obligation =\n-            infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+            infcx.instantiate_binder_with_placeholders(obligation.predicate);\n         let obligation_trait_ref =\n             ocx.normalize(&ObligationCause::dummy(), param_env, placeholder_obligation.trait_ref);\n \n@@ -47,11 +47,11 @@ pub fn recompute_applicable_impls<'tcx>(\n     let param_env_candidate_may_apply = |poly_trait_predicate: ty::PolyTraitPredicate<'tcx>| {\n         let ocx = ObligationCtxt::new_in_snapshot(infcx);\n         let placeholder_obligation =\n-            infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+            infcx.instantiate_binder_with_placeholders(obligation.predicate);\n         let obligation_trait_ref =\n             ocx.normalize(&ObligationCause::dummy(), param_env, placeholder_obligation.trait_ref);\n \n-        let param_env_predicate = infcx.replace_bound_vars_with_fresh_vars(\n+        let param_env_predicate = infcx.instantiate_binder_with_fresh_vars(\n             DUMMY_SP,\n             LateBoundRegionConversionTime::HigherRankedType,\n             poly_trait_predicate,"}, {"sha": "cf1e05ada4713615087d28181215dd5dd9d95660", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -1716,7 +1716,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let (values, err) = if let ty::PredicateKind::Clause(ty::Clause::Projection(data)) =\n                 bound_predicate.skip_binder()\n             {\n-                let data = self.replace_bound_vars_with_fresh_vars(\n+                let data = self.instantiate_binder_with_fresh_vars(\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n                     bound_predicate.rebind(data),"}, {"sha": "59aef52910ee3f287b359383db57b2fcb1e31d61", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -898,7 +898,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             return false;\n         }\n \n-        let self_ty = self.replace_bound_vars_with_fresh_vars(\n+        let self_ty = self.instantiate_binder_with_fresh_vars(\n             DUMMY_SP,\n             LateBoundRegionConversionTime::FnCall,\n             trait_pred.self_ty(),\n@@ -1191,7 +1191,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n         }) else { return None; };\n \n-        let output = self.replace_bound_vars_with_fresh_vars(\n+        let output = self.instantiate_binder_with_fresh_vars(\n             DUMMY_SP,\n             LateBoundRegionConversionTime::FnCall,\n             output,\n@@ -1200,7 +1200,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             .skip_binder()\n             .iter()\n             .map(|ty| {\n-                self.replace_bound_vars_with_fresh_vars(\n+                self.instantiate_binder_with_fresh_vars(\n                     DUMMY_SP,\n                     LateBoundRegionConversionTime::FnCall,\n                     inputs.rebind(*ty),\n@@ -3806,13 +3806,13 @@ fn hint_missing_borrow<'tcx>(\n     err: &mut Diagnostic,\n ) {\n     let found_args = match found.kind() {\n-        ty::FnPtr(f) => infcx.replace_bound_vars_with_placeholders(*f).inputs().iter(),\n+        ty::FnPtr(f) => infcx.instantiate_binder_with_placeholders(*f).inputs().iter(),\n         kind => {\n             span_bug!(span, \"found was converted to a FnPtr above but is now {:?}\", kind)\n         }\n     };\n     let expected_args = match expected.kind() {\n-        ty::FnPtr(f) => infcx.replace_bound_vars_with_placeholders(*f).inputs().iter(),\n+        ty::FnPtr(f) => infcx.instantiate_binder_with_placeholders(*f).inputs().iter(),\n         kind => {\n             span_bug!(span, \"expected was converted to a FnPtr above but is now {:?}\", kind)\n         }"}, {"sha": "3adc1e62e0d4853368bb663dba6e88d5f978431d", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..) => {\n                     let pred =\n-                        ty::Binder::dummy(infcx.replace_bound_vars_with_placeholders(binder));\n+                        ty::Binder::dummy(infcx.instantiate_binder_with_placeholders(binder));\n                     ProcessResult::Changed(mk_pending(vec![obligation.with(infcx.tcx, pred)]))\n                 }\n                 ty::PredicateKind::Ambiguous => ProcessResult::Unchanged,"}, {"sha": "aa81bc640aa6c56367e4e9cdf87abf9e7e73984e", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -215,7 +215,7 @@ pub(super) fn poly_project_and_unify_type<'cx, 'tcx>(\n     let r = infcx.commit_if_ok(|_snapshot| {\n         let old_universe = infcx.universe();\n         let placeholder_predicate =\n-            infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+            infcx.instantiate_binder_with_placeholders(obligation.predicate);\n         let new_universe = infcx.universe();\n \n         let placeholder_obligation = obligation.with(infcx.tcx, placeholder_predicate);\n@@ -2046,7 +2046,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n     let cause = &obligation.cause;\n     let param_env = obligation.param_env;\n \n-    let cache_entry = infcx.replace_bound_vars_with_fresh_vars(\n+    let cache_entry = infcx.instantiate_binder_with_fresh_vars(\n         cause.span,\n         LateBoundRegionConversionTime::HigherRankedType,\n         poly_cache_entry,"}, {"sha": "e9f7c3bc4cca2ecb93a54bb13e454f2e46d12818", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -488,7 +488,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             let poly_trait_predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n             let placeholder_trait_predicate =\n-                self.infcx.replace_bound_vars_with_placeholders(poly_trait_predicate);\n+                self.infcx.instantiate_binder_with_placeholders(poly_trait_predicate);\n \n             // Count only those upcast versions that match the trait-ref\n             // we are looking for. Specifically, do not only check for the"}, {"sha": "fcc4820c2a6b6ff424131ceaac1a69ec4b5399a8", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -151,7 +151,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let trait_predicate = self.infcx.shallow_resolve(obligation.predicate);\n         let placeholder_trait_predicate =\n-            self.infcx.replace_bound_vars_with_placeholders(trait_predicate).trait_ref;\n+            self.infcx.instantiate_binder_with_placeholders(trait_predicate).trait_ref;\n         let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n         let placeholder_trait_predicate = ty::Binder::dummy(placeholder_trait_predicate);\n         let (def_id, substs) = match *placeholder_self_ty.kind() {\n@@ -336,7 +336,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n \n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-            let trait_ref = self.infcx.replace_bound_vars_with_placeholders(poly_trait_ref);\n+            let trait_ref = self.infcx.instantiate_binder_with_placeholders(poly_trait_ref);\n             let trait_obligations: Vec<PredicateObligation<'_>> = self.impl_or_trait_obligations(\n                 &cause,\n                 obligation.recursion_depth + 1,\n@@ -427,7 +427,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let tcx = self.tcx();\n         debug!(?obligation, ?index, \"confirm_object_candidate\");\n \n-        let trait_predicate = self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+        let trait_predicate = self.infcx.instantiate_binder_with_placeholders(obligation.predicate);\n         let self_ty = self.infcx.shallow_resolve(trait_predicate.self_ty());\n         let obligation_trait_ref = ty::Binder::dummy(trait_predicate.trait_ref);\n         let ty::Dynamic(data, ..) = *self_ty.kind() else {\n@@ -437,7 +437,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let object_trait_ref = data.principal().unwrap_or_else(|| {\n             span_bug!(obligation.cause.span, \"object candidate with no principal\")\n         });\n-        let object_trait_ref = self.infcx.replace_bound_vars_with_fresh_vars(\n+        let object_trait_ref = self.infcx.instantiate_binder_with_fresh_vars(\n             obligation.cause.span,\n             HigherRankedType,\n             object_trait_ref,\n@@ -629,7 +629,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // Confirm the `type Output: Sized;` bound that is present on `FnOnce`\n-        let output_ty = self.infcx.replace_bound_vars_with_placeholders(sig.output());\n+        let output_ty = self.infcx.instantiate_binder_with_placeholders(sig.output());\n         let output_ty = normalize_with_depth_to(\n             self,\n             obligation.param_env,\n@@ -652,7 +652,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?obligation, \"confirm_trait_alias_candidate\");\n \n         let alias_def_id = obligation.predicate.def_id();\n-        let predicate = self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+        let predicate = self.infcx.instantiate_binder_with_placeholders(obligation.predicate);\n         let trait_ref = predicate.trait_ref;\n         let trait_def_id = trait_ref.def_id;\n         let substs = trait_ref.substs;"}, {"sha": "984d6fde2686c58384a99a272062b95191794f84", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -1618,7 +1618,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> smallvec::SmallVec<[(usize, ty::BoundConstness); 2]> {\n         let poly_trait_predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n         let placeholder_trait_predicate =\n-            self.infcx.replace_bound_vars_with_placeholders(poly_trait_predicate);\n+            self.infcx.instantiate_binder_with_placeholders(poly_trait_predicate);\n         debug!(?placeholder_trait_predicate);\n \n         let tcx = self.infcx.tcx;\n@@ -1738,7 +1738,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         potentially_unnormalized_candidates: bool,\n     ) -> ProjectionMatchesProjection {\n         let mut nested_obligations = Vec::new();\n-        let infer_predicate = self.infcx.replace_bound_vars_with_fresh_vars(\n+        let infer_predicate = self.infcx.instantiate_binder_with_fresh_vars(\n             obligation.cause.span,\n             LateBoundRegionConversionTime::HigherRankedType,\n             env_predicate,\n@@ -2339,7 +2339,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .flat_map(|ty| {\n                 let ty: ty::Binder<'tcx, Ty<'tcx>> = types.rebind(*ty); // <----/\n \n-                let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(ty);\n+                let placeholder_ty = self.infcx.instantiate_binder_with_placeholders(ty);\n                 let Normalized { value: normalized_ty, mut obligations } =\n                     ensure_sufficient_stack(|| {\n                         project::normalize_with_depth(\n@@ -2418,7 +2418,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<Normalized<'tcx, SubstsRef<'tcx>>, ()> {\n         let placeholder_obligation =\n-            self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+            self.infcx.instantiate_binder_with_placeholders(obligation.predicate);\n         let placeholder_obligation_trait_ref = placeholder_obligation.trait_ref;\n \n         let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span, impl_def_id);"}, {"sha": "000b9bd0fab42408a790d5b811c06f94385eba8a", "filename": "library/alloc/src/collections/btree/borrow.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -41,6 +41,28 @@ impl<'a, T> DormantMutRef<'a, T> {\n         // SAFETY: our own safety conditions imply this reference is again unique.\n         unsafe { &mut *self.ptr.as_ptr() }\n     }\n+\n+    /// Borrows a new mutable reference from the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn reborrow(&mut self) -> &'a mut T {\n+        // SAFETY: our own safety conditions imply this reference is again unique.\n+        unsafe { &mut *self.ptr.as_ptr() }\n+    }\n+\n+    /// Borrows a new shared reference from the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn reborrow_shared(&self) -> &'a T {\n+        // SAFETY: our own safety conditions imply this reference is again unique.\n+        unsafe { &*self.ptr.as_ptr() }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "386cd1a1657e26f0dd9934dee92af16020cfe9fa", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 728, "deletions": 2, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -6,7 +6,7 @@ use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, FusedIterator};\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop};\n-use core::ops::{Index, RangeBounds};\n+use core::ops::{Bound, Index, RangeBounds};\n use core::ptr;\n \n use crate::alloc::{Allocator, Global};\n@@ -15,7 +15,7 @@ use super::borrow::DormantMutRef;\n use super::dedup_sorted_iter::DedupSortedIter;\n use super::navigate::{LazyLeafRange, LeafRange};\n use super::node::{self, marker, ForceResult::*, Handle, NodeRef, Root};\n-use super::search::SearchResult::*;\n+use super::search::{SearchBound, SearchResult::*};\n use super::set_val::SetValZST;\n \n mod entry;\n@@ -2422,6 +2422,732 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     pub const fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n+\n+    /// Returns a [`Cursor`] pointing at the first element that is above the\n+    /// given bound.\n+    ///\n+    /// If no such element exists then a cursor pointing at the \"ghost\"\n+    /// non-element is returned.\n+    ///\n+    /// Passing [`Bound::Unbounded`] will return a cursor pointing at the first\n+    /// element of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_cursors)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::ops::Bound;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"c\");\n+    /// let cursor = a.lower_bound(Bound::Excluded(&2));\n+    /// assert_eq!(cursor.key(), Some(&3));\n+    /// ```\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn lower_bound<Q>(&self, bound: Bound<&Q>) -> Cursor<'_, K, V>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord,\n+    {\n+        let root_node = match self.root.as_ref() {\n+            None => return Cursor { current: None, root: None },\n+            Some(root) => root.reborrow(),\n+        };\n+        let edge = root_node.lower_bound(SearchBound::from_range(bound));\n+        Cursor { current: edge.next_kv().ok(), root: self.root.as_ref() }\n+    }\n+\n+    /// Returns a [`CursorMut`] pointing at the first element that is above the\n+    /// given bound.\n+    ///\n+    /// If no such element exists then a cursor pointing at the \"ghost\"\n+    /// non-element is returned.\n+    ///\n+    /// Passing [`Bound::Unbounded`] will return a cursor pointing at the first\n+    /// element of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_cursors)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::ops::Bound;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"c\");\n+    /// let cursor = a.lower_bound_mut(Bound::Excluded(&2));\n+    /// assert_eq!(cursor.key(), Some(&3));\n+    /// ```\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn lower_bound_mut<Q>(&mut self, bound: Bound<&Q>) -> CursorMut<'_, K, V, A>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord,\n+    {\n+        let (root, dormant_root) = DormantMutRef::new(&mut self.root);\n+        let root_node = match root.as_mut() {\n+            None => {\n+                return CursorMut {\n+                    current: None,\n+                    root: dormant_root,\n+                    length: &mut self.length,\n+                    alloc: &mut *self.alloc,\n+                };\n+            }\n+            Some(root) => root.borrow_mut(),\n+        };\n+        let edge = root_node.lower_bound(SearchBound::from_range(bound));\n+        CursorMut {\n+            current: edge.next_kv().ok(),\n+            root: dormant_root,\n+            length: &mut self.length,\n+            alloc: &mut *self.alloc,\n+        }\n+    }\n+\n+    /// Returns a [`Cursor`] pointing at the last element that is below the\n+    /// given bound.\n+    ///\n+    /// If no such element exists then a cursor pointing at the \"ghost\"\n+    /// non-element is returned.\n+    ///\n+    /// Passing [`Bound::Unbounded`] will return a cursor pointing at the last\n+    /// element of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_cursors)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::ops::Bound;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"c\");\n+    /// let cursor = a.upper_bound(Bound::Excluded(&3));\n+    /// assert_eq!(cursor.key(), Some(&2));\n+    /// ```\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn upper_bound<Q>(&self, bound: Bound<&Q>) -> Cursor<'_, K, V>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord,\n+    {\n+        let root_node = match self.root.as_ref() {\n+            None => return Cursor { current: None, root: None },\n+            Some(root) => root.reborrow(),\n+        };\n+        let edge = root_node.upper_bound(SearchBound::from_range(bound));\n+        Cursor { current: edge.next_back_kv().ok(), root: self.root.as_ref() }\n+    }\n+\n+    /// Returns a [`CursorMut`] pointing at the last element that is below the\n+    /// given bound.\n+    ///\n+    /// If no such element exists then a cursor pointing at the \"ghost\"\n+    /// non-element is returned.\n+    ///\n+    /// Passing [`Bound::Unbounded`] will return a cursor pointing at the last\n+    /// element of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_cursors)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::ops::Bound;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"c\");\n+    /// let cursor = a.upper_bound_mut(Bound::Excluded(&3));\n+    /// assert_eq!(cursor.key(), Some(&2));\n+    /// ```\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn upper_bound_mut<Q>(&mut self, bound: Bound<&Q>) -> CursorMut<'_, K, V, A>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord,\n+    {\n+        let (root, dormant_root) = DormantMutRef::new(&mut self.root);\n+        let root_node = match root.as_mut() {\n+            None => {\n+                return CursorMut {\n+                    current: None,\n+                    root: dormant_root,\n+                    length: &mut self.length,\n+                    alloc: &mut *self.alloc,\n+                };\n+            }\n+            Some(root) => root.borrow_mut(),\n+        };\n+        let edge = root_node.upper_bound(SearchBound::from_range(bound));\n+        CursorMut {\n+            current: edge.next_back_kv().ok(),\n+            root: dormant_root,\n+            length: &mut self.length,\n+            alloc: &mut *self.alloc,\n+        }\n+    }\n+}\n+\n+/// A cursor over a `BTreeMap`.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth.\n+///\n+/// Cursors always point to an element in the tree, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the last and\n+/// first elements of the tree.\n+///\n+/// A `Cursor` is created with the [`BTreeMap::lower_bound`] and [`BTreeMap::upper_bound`] methods.\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+pub struct Cursor<'a, K: 'a, V: 'a> {\n+    current: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>, marker::KV>>,\n+    root: Option<&'a node::Root<K, V>>,\n+}\n+\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+impl<K, V> Clone for Cursor<'_, K, V> {\n+    fn clone(&self) -> Self {\n+        let Cursor { current, root } = *self;\n+        Cursor { current, root }\n+    }\n+}\n+\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+impl<K: Debug, V: Debug> Debug for Cursor<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Cursor\").field(&self.key_value()).finish()\n+    }\n+}\n+\n+/// A cursor over a `BTreeMap` with editing operations.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth, and can\n+/// safely mutate the tree during iteration. This is because the lifetime of its yielded\n+/// references is tied to its own lifetime, instead of just the underlying tree. This means\n+/// cursors cannot yield multiple elements at once.\n+///\n+/// Cursors always point to an element in the tree, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the last and\n+/// first elements of the tree.\n+///\n+/// A `Cursor` is created with the [`BTreeMap::lower_bound_mut`] and [`BTreeMap::upper_bound_mut`]\n+/// methods.\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+pub struct CursorMut<\n+    'a,\n+    K: 'a,\n+    V: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A = Global,\n+> {\n+    current: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>>,\n+    root: DormantMutRef<'a, Option<node::Root<K, V>>>,\n+    length: &'a mut usize,\n+    alloc: &'a mut A,\n+}\n+\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+impl<K: Debug, V: Debug, A> Debug for CursorMut<'_, K, V, A> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"CursorMut\").field(&self.key_value()).finish()\n+    }\n+}\n+\n+impl<'a, K, V> Cursor<'a, K, V> {\n+    /// Moves the cursor to the next element of the `BTreeMap`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `BTreeMap`. If it is pointing to the last\n+    /// element of the `BTreeMap` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            None => {\n+                self.current = self.root.and_then(|root| {\n+                    root.reborrow().first_leaf_edge().forget_node_type().right_kv().ok()\n+                });\n+            }\n+            Some(current) => {\n+                self.current = current.next_leaf_edge().next_kv().ok();\n+            }\n+        }\n+    }\n+\n+    /// Moves the cursor to the previous element of the `BTreeMap`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `BTreeMap`. If it is pointing to the first\n+    /// element of the `BTreeMap` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            None => {\n+                self.current = self.root.and_then(|root| {\n+                    root.reborrow().last_leaf_edge().forget_node_type().left_kv().ok()\n+                });\n+            }\n+            Some(current) => {\n+                self.current = current.next_back_leaf_edge().next_back_kv().ok();\n+            }\n+        }\n+    }\n+\n+    /// Returns a reference to the key of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key(&self) -> Option<&'a K> {\n+        self.current.as_ref().map(|current| current.into_kv().0)\n+    }\n+\n+    /// Returns a reference to the value of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn value(&self) -> Option<&'a V> {\n+        self.current.as_ref().map(|current| current.into_kv().1)\n+    }\n+\n+    /// Returns a reference to the key and value of the element that the cursor\n+    /// is currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key_value(&self) -> Option<(&'a K, &'a V)> {\n+        self.current.as_ref().map(|current| current.into_kv())\n+    }\n+\n+    /// Returns a reference to the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `BTreeMap`. If it is pointing to the last\n+    /// element of the `BTreeMap` then this returns `None`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn peek_next(&self) -> Option<(&'a K, &'a V)> {\n+        let mut next = self.clone();\n+        next.move_next();\n+        next.current.as_ref().map(|current| current.into_kv())\n+    }\n+\n+    /// Returns a reference to the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `BTreeMap`. If it is pointing to the first\n+    /// element of the `BTreeMap` then this returns `None`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn peek_prev(&self) -> Option<(&'a K, &'a V)> {\n+        let mut prev = self.clone();\n+        prev.move_prev();\n+        prev.current.as_ref().map(|current| current.into_kv())\n+    }\n+}\n+\n+impl<'a, K, V, A> CursorMut<'a, K, V, A> {\n+    /// Moves the cursor to the next element of the `BTreeMap`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `BTreeMap`. If it is pointing to the last\n+    /// element of the `BTreeMap` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            None => {\n+                // SAFETY: The previous borrow of root has ended.\n+                self.current = unsafe { self.root.reborrow() }.as_mut().and_then(|root| {\n+                    root.borrow_mut().first_leaf_edge().forget_node_type().right_kv().ok()\n+                });\n+            }\n+            Some(current) => {\n+                self.current = current.next_leaf_edge().next_kv().ok();\n+            }\n+        }\n+    }\n+\n+    /// Moves the cursor to the previous element of the `BTreeMap`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `BTreeMap`. If it is pointing to the first\n+    /// element of the `BTreeMap` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            None => {\n+                // SAFETY: The previous borrow of root has ended.\n+                self.current = unsafe { self.root.reborrow() }.as_mut().and_then(|root| {\n+                    root.borrow_mut().last_leaf_edge().forget_node_type().left_kv().ok()\n+                });\n+            }\n+            Some(current) => {\n+                self.current = current.next_back_leaf_edge().next_back_kv().ok();\n+            }\n+        }\n+    }\n+\n+    /// Returns a reference to the key of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key(&self) -> Option<&K> {\n+        self.current.as_ref().map(|current| current.reborrow().into_kv().0)\n+    }\n+\n+    /// Returns a reference to the value of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn value(&self) -> Option<&V> {\n+        self.current.as_ref().map(|current| current.reborrow().into_kv().1)\n+    }\n+\n+    /// Returns a reference to the key and value of the element that the cursor\n+    /// is currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key_value(&self) -> Option<(&K, &V)> {\n+        self.current.as_ref().map(|current| current.reborrow().into_kv())\n+    }\n+\n+    /// Returns a mutable reference to the value of the element that the cursor\n+    /// is currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn value_mut(&mut self) -> Option<&mut V> {\n+        self.current.as_mut().map(|current| current.kv_mut().1)\n+    }\n+\n+    /// Returns a reference to the key and mutable reference to the value of the\n+    /// element that the cursor is currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key_value_mut(&mut self) -> Option<(&K, &mut V)> {\n+        self.current.as_mut().map(|current| {\n+            let (k, v) = current.kv_mut();\n+            (&*k, v)\n+        })\n+    }\n+\n+    /// Returns a mutable reference to the of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This can be used to modify the key, but you must ensure that the\n+    /// `BTreeMap` invariants are maintained. Specifically:\n+    ///\n+    /// * The key must remain unique within the tree.\n+    /// * The key must remain in sorted order with regards to other elements in\n+    ///   the tree.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub unsafe fn key_mut_unchecked(&mut self) -> Option<&mut K> {\n+        self.current.as_mut().map(|current| current.kv_mut().0)\n+    }\n+\n+    /// Returns a reference to the key and value of the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `BTreeMap`. If it is pointing to the last\n+    /// element of the `BTreeMap` then this returns `None`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn peek_next(&mut self) -> Option<(&K, &mut V)> {\n+        let (k, v) = match self.current {\n+            None => {\n+                // SAFETY: The previous borrow of root has ended.\n+                unsafe { self.root.reborrow() }\n+                    .as_mut()?\n+                    .borrow_mut()\n+                    .first_leaf_edge()\n+                    .next_kv()\n+                    .ok()?\n+                    .into_kv_valmut()\n+            }\n+            // SAFETY: We're not using this to mutate the tree.\n+            Some(ref mut current) => {\n+                unsafe { current.reborrow_mut() }.next_leaf_edge().next_kv().ok()?.into_kv_valmut()\n+            }\n+        };\n+        Some((k, v))\n+    }\n+\n+    /// Returns a reference to the key and value of the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `BTreeMap`. If it is pointing to the first\n+    /// element of the `BTreeMap` then this returns `None`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn peek_prev(&mut self) -> Option<(&K, &mut V)> {\n+        let (k, v) = match self.current.as_mut() {\n+            None => {\n+                // SAFETY: The previous borrow of root has ended.\n+                unsafe { self.root.reborrow() }\n+                    .as_mut()?\n+                    .borrow_mut()\n+                    .first_leaf_edge()\n+                    .next_kv()\n+                    .ok()?\n+                    .into_kv_valmut()\n+            }\n+            Some(current) => {\n+                // SAFETY: We're not using this to mutate the tree.\n+                unsafe { current.reborrow_mut() }\n+                    .next_back_leaf_edge()\n+                    .next_back_kv()\n+                    .ok()?\n+                    .into_kv_valmut()\n+            }\n+        };\n+        Some((k, v))\n+    }\n+\n+    /// Returns a read-only cursor pointing to the current element.\n+    ///\n+    /// The lifetime of the returned `Cursor` is bound to that of the\n+    /// `CursorMut`, which means it cannot outlive the `CursorMut` and that the\n+    /// `CursorMut` is frozen for the lifetime of the `Cursor`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn as_cursor(&self) -> Cursor<'_, K, V> {\n+        Cursor {\n+            // SAFETY: The tree is immutable while the cursor exists.\n+            root: unsafe { self.root.reborrow_shared().as_ref() },\n+            current: self.current.as_ref().map(|current| current.reborrow()),\n+        }\n+    }\n+}\n+\n+// Now the tree editing operations\n+impl<'a, K: Ord, V, A: Allocator + Clone> CursorMut<'a, K, V, A> {\n+    /// Inserts a new element into the `BTreeMap` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the front of the `BTreeMap`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// You must ensure that the `BTreeMap` invariants are maintained.\n+    /// Specifically:\n+    ///\n+    /// * The key of the newly inserted element must be unique in the tree.\n+    /// * All keys in the tree must remain in sorted order.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub unsafe fn insert_after_unchecked(&mut self, key: K, value: V) {\n+        let edge = match self.current.take() {\n+            None => {\n+                // SAFETY: We have no other reference to the tree.\n+                match unsafe { self.root.reborrow() } {\n+                    root @ None => {\n+                        // Tree is empty, allocate a new root.\n+                        let mut node = NodeRef::new_leaf(self.alloc.clone());\n+                        node.borrow_mut().push(key, value);\n+                        *root = Some(node.forget_type());\n+                        *self.length += 1;\n+                        return;\n+                    }\n+                    Some(root) => root.borrow_mut().first_leaf_edge(),\n+                }\n+            }\n+            Some(current) => current.next_leaf_edge(),\n+        };\n+\n+        let handle = edge.insert_recursing(key, value, self.alloc.clone(), |ins| {\n+            drop(ins.left);\n+            // SAFETY: The handle to the newly inserted value is always on a\n+            // leaf node, so adding a new root node doesn't invalidate it.\n+            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n+            root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)\n+        });\n+        self.current = handle.left_edge().next_back_kv().ok();\n+        *self.length += 1;\n+    }\n+\n+    /// Inserts a new element into the `BTreeMap` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the end of the `BTreeMap`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// You must ensure that the `BTreeMap` invariants are maintained.\n+    /// Specifically:\n+    ///\n+    /// * The key of the newly inserted element must be unique in the tree.\n+    /// * All keys in the tree must remain in sorted order.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub unsafe fn insert_before_unchecked(&mut self, key: K, value: V) {\n+        let edge = match self.current.take() {\n+            None => {\n+                // SAFETY: We have no other reference to the tree.\n+                match unsafe { self.root.reborrow() } {\n+                    root @ None => {\n+                        // Tree is empty, allocate a new root.\n+                        let mut node = NodeRef::new_leaf(self.alloc.clone());\n+                        node.borrow_mut().push(key, value);\n+                        *root = Some(node.forget_type());\n+                        *self.length += 1;\n+                        return;\n+                    }\n+                    Some(root) => root.borrow_mut().last_leaf_edge(),\n+                }\n+            }\n+            Some(current) => current.next_back_leaf_edge(),\n+        };\n+\n+        let handle = edge.insert_recursing(key, value, self.alloc.clone(), |ins| {\n+            drop(ins.left);\n+            // SAFETY: The handle to the newly inserted value is always on a\n+            // leaf node, so adding a new root node doesn't invalidate it.\n+            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n+            root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)\n+        });\n+        self.current = handle.right_edge().next_kv().ok();\n+        *self.length += 1;\n+    }\n+\n+    /// Inserts a new element into the `BTreeMap` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the front of the `BTreeMap`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if:\n+    /// - the given key compares less than or equal to the current element (if\n+    ///   any).\n+    /// - the given key compares greater than or equal to the next element (if\n+    ///   any).\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn insert_after(&mut self, key: K, value: V) {\n+        if let Some(current) = self.key() {\n+            if &key <= current {\n+                panic!(\"key must be ordered above the current element\");\n+            }\n+        }\n+        if let Some((next, _)) = self.peek_prev() {\n+            if &key >= next {\n+                panic!(\"key must be ordered below the next element\");\n+            }\n+        }\n+        unsafe {\n+            self.insert_after_unchecked(key, value);\n+        }\n+    }\n+\n+    /// Inserts a new element into the `BTreeMap` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the end of the `BTreeMap`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if:\n+    /// - the given key compares greater than or equal to the current element\n+    ///   (if any).\n+    /// - the given key compares less than or equal to the previous element (if\n+    ///   any).\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn insert_before(&mut self, key: K, value: V) {\n+        if let Some(current) = self.key() {\n+            if &key >= current {\n+                panic!(\"key must be ordered below the current element\");\n+            }\n+        }\n+        if let Some((prev, _)) = self.peek_prev() {\n+            if &key <= prev {\n+                panic!(\"key must be ordered above the previous element\");\n+            }\n+        }\n+        unsafe {\n+            self.insert_before_unchecked(key, value);\n+        }\n+    }\n+\n+    /// Removes the current element from the `BTreeMap`.\n+    ///\n+    /// The element that was removed is returned, and the cursor is\n+    /// moved to point to the next element in the `BTreeMap`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned. The cursor is not moved in this case.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn remove_current(&mut self) -> Option<(K, V)> {\n+        let current = self.current.take()?;\n+        let mut emptied_internal_root = false;\n+        let (kv, pos) =\n+            current.remove_kv_tracking(|| emptied_internal_root = true, self.alloc.clone());\n+        self.current = pos.next_kv().ok();\n+        *self.length -= 1;\n+        if emptied_internal_root {\n+            // SAFETY: This is safe since current does not point within the now\n+            // empty root node.\n+            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n+            root.pop_internal_level(self.alloc.clone());\n+        }\n+        Some(kv)\n+    }\n+\n+    /// Removes the current element from the `BTreeMap`.\n+    ///\n+    /// The element that was removed is returned, and the cursor is\n+    /// moved to point to the previous element in the `BTreeMap`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned. The cursor is not moved in this case.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn remove_current_and_move_back(&mut self) -> Option<(K, V)> {\n+        let current = self.current.take()?;\n+        let mut emptied_internal_root = false;\n+        let (kv, pos) =\n+            current.remove_kv_tracking(|| emptied_internal_root = true, self.alloc.clone());\n+        self.current = pos.next_back_kv().ok();\n+        *self.length -= 1;\n+        if emptied_internal_root {\n+            // SAFETY: This is safe since current does not point within the now\n+            // empty root node.\n+            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n+            root.pop_internal_level(self.alloc.clone());\n+        }\n+        Some(kv)\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "e9366eec9cec3028a05635b62672beed4602f5d3", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -347,7 +347,7 @@ impl<'a, K: Ord, V, A: Allocator + Clone> VacantEntry<'a, K, V, A> {\n     /// assert_eq!(map[\"poneyland\"], 37);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(self, value: V) -> &'a mut V {\n+    pub fn insert(mut self, value: V) -> &'a mut V {\n         let out_ptr = match self.handle {\n             None => {\n                 // SAFETY: There is no tree yet so no reference to it exists.\n@@ -358,25 +358,27 @@ impl<'a, K: Ord, V, A: Allocator + Clone> VacantEntry<'a, K, V, A> {\n                 map.length = 1;\n                 val_ptr\n             }\n-            Some(handle) => match handle.insert_recursing(self.key, value, self.alloc.clone()) {\n-                (None, val_ptr) => {\n-                    // SAFETY: We have consumed self.handle.\n-                    let map = unsafe { self.dormant_map.awaken() };\n-                    map.length += 1;\n-                    val_ptr\n-                }\n-                (Some(ins), val_ptr) => {\n-                    drop(ins.left);\n-                    // SAFETY: We have consumed self.handle and dropped the\n-                    // remaining reference to the tree, ins.left.\n-                    let map = unsafe { self.dormant_map.awaken() };\n-                    let root = map.root.as_mut().unwrap(); // same as ins.left\n-                    root.push_internal_level(self.alloc).push(ins.kv.0, ins.kv.1, ins.right);\n-                    map.length += 1;\n-                    val_ptr\n-                }\n-            },\n+            Some(handle) => {\n+                let new_handle =\n+                    handle.insert_recursing(self.key, value, self.alloc.clone(), |ins| {\n+                        drop(ins.left);\n+                        // SAFETY: Pushing a new root node doesn't invalidate\n+                        // handles to existing nodes.\n+                        let map = unsafe { self.dormant_map.reborrow() };\n+                        let root = map.root.as_mut().unwrap(); // same as ins.left\n+                        root.push_internal_level(self.alloc).push(ins.kv.0, ins.kv.1, ins.right)\n+                    });\n+\n+                // Get the pointer to the value\n+                let val_ptr = new_handle.into_val_mut();\n+\n+                // SAFETY: We have consumed self.handle.\n+                let map = unsafe { self.dormant_map.awaken() };\n+                map.length += 1;\n+                val_ptr\n+            }\n         };\n+\n         // Now that we have finished growing the tree using borrowed references,\n         // dereference the pointer to a part of it, that we picked up along the way.\n         unsafe { &mut *out_ptr }"}, {"sha": "76c2f27b46634a885a663a6ba53595a74f79702c", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -2336,3 +2336,52 @@ fn from_array() {\n     let unordered_duplicates = BTreeMap::from([(3, 4), (1, 2), (1, 2)]);\n     assert_eq!(map, unordered_duplicates);\n }\n+\n+#[test]\n+fn test_cursor() {\n+    let map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+\n+    let mut cur = map.lower_bound(Bound::Unbounded);\n+    assert_eq!(cur.key(), Some(&1));\n+    cur.move_next();\n+    assert_eq!(cur.key(), Some(&2));\n+    assert_eq!(cur.peek_next(), Some((&3, &'c')));\n+    cur.move_prev();\n+    assert_eq!(cur.key(), Some(&1));\n+    assert_eq!(cur.peek_prev(), None);\n+\n+    let mut cur = map.upper_bound(Bound::Excluded(&1));\n+    assert_eq!(cur.key(), None);\n+    cur.move_next();\n+    assert_eq!(cur.key(), Some(&1));\n+    cur.move_prev();\n+    assert_eq!(cur.key(), None);\n+    assert_eq!(cur.peek_prev(), Some((&3, &'c')));\n+}\n+\n+#[test]\n+fn test_cursor_mut() {\n+    let mut map = BTreeMap::from([(1, 'a'), (3, 'c'), (5, 'e')]);\n+    let mut cur = map.lower_bound_mut(Bound::Excluded(&3));\n+    assert_eq!(cur.key(), Some(&5));\n+    cur.insert_before(4, 'd');\n+    assert_eq!(cur.key(), Some(&5));\n+    assert_eq!(cur.peek_prev(), Some((&4, &mut 'd')));\n+    cur.move_next();\n+    assert_eq!(cur.key(), None);\n+    cur.insert_before(6, 'f');\n+    assert_eq!(cur.key(), None);\n+    assert_eq!(cur.remove_current(), None);\n+    assert_eq!(cur.key(), None);\n+    cur.insert_after(0, '?');\n+    assert_eq!(cur.key(), None);\n+    assert_eq!(map, BTreeMap::from([(0, '?'), (1, 'a'), (3, 'c'), (4, 'd'), (5, 'e'), (6, 'f')]));\n+\n+    let mut cur = map.upper_bound_mut(Bound::Included(&5));\n+    assert_eq!(cur.key(), Some(&5));\n+    assert_eq!(cur.remove_current(), Some((5, 'e')));\n+    assert_eq!(cur.key(), Some(&6));\n+    assert_eq!(cur.remove_current_and_move_back(), Some((6, 'f')));\n+    assert_eq!(cur.key(), Some(&4));\n+    assert_eq!(map, BTreeMap::from([(0, '?'), (1, 'a'), (3, 'c'), (4, 'd')]));\n+}"}, {"sha": "b890717e50b2544b62dfbc73312ba9e975db3225", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -4,6 +4,7 @@ use core::ops::RangeBounds;\n use core::ptr;\n \n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n+use super::search::SearchBound;\n \n use crate::alloc::Allocator;\n // `front` and `back` are always both `None` or both `Some`.\n@@ -386,7 +387,7 @@ impl<BorrowType: marker::BorrowType, K, V>\n     /// Given a leaf edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n     /// on the left side, which is either in the same leaf node or in an ancestor node.\n     /// If the leaf edge is the first one in the tree, returns [`Result::Err`] with the root node.\n-    fn next_back_kv(\n+    pub fn next_back_kv(\n         self,\n     ) -> Result<\n         Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV>,\n@@ -707,7 +708,9 @@ impl<BorrowType: marker::BorrowType, K, V>\n     }\n \n     /// Returns the leaf edge closest to a KV for backward navigation.\n-    fn next_back_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+    pub fn next_back_leaf_edge(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n         match self.force() {\n             Leaf(leaf_kv) => leaf_kv.left_edge(),\n             Internal(internal_kv) => {\n@@ -717,3 +720,51 @@ impl<BorrowType: marker::BorrowType, K, V>\n         }\n     }\n }\n+\n+impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Returns the leaf edge corresponding to the first point at which the\n+    /// given bound is true.\n+    pub fn lower_bound<Q: ?Sized>(\n+        self,\n+        mut bound: SearchBound<&Q>,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>\n+    where\n+        Q: Ord,\n+        K: Borrow<Q>,\n+    {\n+        let mut node = self;\n+        loop {\n+            let (edge, new_bound) = node.find_lower_bound_edge(bound);\n+            match edge.force() {\n+                Leaf(edge) => return edge,\n+                Internal(edge) => {\n+                    node = edge.descend();\n+                    bound = new_bound;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Returns the leaf edge corresponding to the last point at which the\n+    /// given bound is true.\n+    pub fn upper_bound<Q: ?Sized>(\n+        self,\n+        mut bound: SearchBound<&Q>,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>\n+    where\n+        Q: Ord,\n+        K: Borrow<Q>,\n+    {\n+        let mut node = self;\n+        loop {\n+            let (edge, new_bound) = node.find_upper_bound_edge(bound);\n+            match edge.force() {\n+                Leaf(edge) => return edge,\n+                Internal(edge) => {\n+                    node = edge.descend();\n+                    bound = new_bound;\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "3233a575ecf254e73fe18c3d55679716d276f96c", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 84, "deletions": 18, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -442,6 +442,24 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         // SAFETY: we have exclusive access to the entire node.\n         unsafe { &mut *ptr }\n     }\n+\n+    /// Returns a dormant copy of this node with its lifetime erased which can\n+    /// be reawakened later.\n+    pub fn dormant(&self) -> NodeRef<marker::DormantMut, K, V, Type> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n+}\n+\n+impl<K, V, Type> NodeRef<marker::DormantMut, K, V, Type> {\n+    /// Revert to the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn awaken<'a>(self) -> NodeRef<marker::Mut<'a>, K, V, Type> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n }\n \n impl<K, V, Type> NodeRef<marker::Dying, K, V, Type> {\n@@ -798,6 +816,25 @@ impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeT\n         // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n         Handle { node: unsafe { self.node.reborrow_mut() }, idx: self.idx, _marker: PhantomData }\n     }\n+\n+    /// Returns a dormant copy of this handle which can be reawakened later.\n+    ///\n+    /// See `DormantMutRef` for more details.\n+    pub fn dormant(&self) -> Handle<NodeRef<marker::DormantMut, K, V, NodeType>, HandleType> {\n+        Handle { node: self.node.dormant(), idx: self.idx, _marker: PhantomData }\n+    }\n+}\n+\n+impl<K, V, NodeType, HandleType> Handle<NodeRef<marker::DormantMut, K, V, NodeType>, HandleType> {\n+    /// Revert to the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn awaken<'a>(self) -> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n+        Handle { node: unsafe { self.node.awaken() }, idx: self.idx, _marker: PhantomData }\n+    }\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n@@ -851,9 +888,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// Inserts a new key-value pair between the key-value pairs to the right and left of\n     /// this edge. This method assumes that there is enough space in the node for the new\n     /// pair to fit.\n-    ///\n-    /// The returned pointer points to the inserted value.\n-    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n+    unsafe fn insert_fit(\n+        mut self,\n+        key: K,\n+        val: V,\n+    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n         debug_assert!(self.node.len() < CAPACITY);\n         let new_len = self.node.len() + 1;\n \n@@ -862,7 +901,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n             slice_insert(self.node.val_area_mut(..new_len), self.idx, val);\n             *self.node.len_mut() = new_len as u16;\n \n-            self.node.val_area_mut(self.idx).assume_init_mut()\n+            Handle::new_kv(self.node, self.idx)\n         }\n     }\n }\n@@ -871,30 +910,37 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// Inserts a new key-value pair between the key-value pairs to the right and left of\n     /// this edge. This method splits the node if there isn't enough room.\n     ///\n-    /// The returned pointer points to the inserted value.\n+    /// Returns a dormant handle to the inserted node which can be reawakened\n+    /// once splitting is complete.\n     fn insert<A: Allocator + Clone>(\n-        mut self,\n+        self,\n         key: K,\n         val: V,\n         alloc: A,\n-    ) -> (Option<SplitResult<'a, K, V, marker::Leaf>>, *mut V) {\n+    ) -> (\n+        Option<SplitResult<'a, K, V, marker::Leaf>>,\n+        Handle<NodeRef<marker::DormantMut, K, V, marker::Leaf>, marker::KV>,\n+    ) {\n         if self.node.len() < CAPACITY {\n-            let val_ptr = self.insert_fit(key, val);\n-            (None, val_ptr)\n+            // SAFETY: There is enough space in the node for insertion.\n+            let handle = unsafe { self.insert_fit(key, val) };\n+            (None, handle.dormant())\n         } else {\n             let (middle_kv_idx, insertion) = splitpoint(self.idx);\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let mut result = middle.split(alloc);\n-            let mut insertion_edge = match insertion {\n+            let insertion_edge = match insertion {\n                 LeftOrRight::Left(insert_idx) => unsafe {\n                     Handle::new_edge(result.left.reborrow_mut(), insert_idx)\n                 },\n                 LeftOrRight::Right(insert_idx) => unsafe {\n                     Handle::new_edge(result.right.borrow_mut(), insert_idx)\n                 },\n             };\n-            let val_ptr = insertion_edge.insert_fit(key, val);\n-            (Some(result), val_ptr)\n+            // SAFETY: We just split the node, so there is enough space for\n+            // insertion.\n+            let handle = unsafe { insertion_edge.insert_fit(key, val).dormant() };\n+            (Some(result), handle)\n         }\n     }\n }\n@@ -976,21 +1022,31 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         key: K,\n         value: V,\n         alloc: A,\n-    ) -> (Option<SplitResult<'a, K, V, marker::LeafOrInternal>>, *mut V) {\n-        let (mut split, val_ptr) = match self.insert(key, value, alloc.clone()) {\n-            (None, val_ptr) => return (None, val_ptr),\n-            (Some(split), val_ptr) => (split.forget_node_type(), val_ptr),\n+        split_root: impl FnOnce(SplitResult<'a, K, V, marker::LeafOrInternal>),\n+    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n+        let (mut split, handle) = match self.insert(key, value, alloc.clone()) {\n+            // SAFETY: we have finished splitting and can now re-awaken the\n+            // handle to the inserted element.\n+            (None, handle) => return unsafe { handle.awaken() },\n+            (Some(split), handle) => (split.forget_node_type(), handle),\n         };\n \n         loop {\n             split = match split.left.ascend() {\n                 Ok(parent) => {\n                     match parent.insert(split.kv.0, split.kv.1, split.right, alloc.clone()) {\n-                        None => return (None, val_ptr),\n+                        // SAFETY: we have finished splitting and can now re-awaken the\n+                        // handle to the inserted element.\n+                        None => return unsafe { handle.awaken() },\n                         Some(split) => split.forget_node_type(),\n                     }\n                 }\n-                Err(root) => return (Some(SplitResult { left: root, ..split }), val_ptr),\n+                Err(root) => {\n+                    split_root(SplitResult { left: root, ..split });\n+                    // SAFETY: we have finished splitting and can now re-awaken the\n+                    // handle to the inserted element.\n+                    return unsafe { handle.awaken() };\n+                }\n             };\n         }\n     }\n@@ -1043,6 +1099,14 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n         let leaf = self.node.into_leaf_mut();\n         unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() }\n     }\n+\n+    pub fn into_kv_valmut(self) -> (&'a K, &'a mut V) {\n+        debug_assert!(self.idx < self.node.len());\n+        let leaf = self.node.into_leaf_mut();\n+        let k = unsafe { leaf.keys.get_unchecked(self.idx).assume_init_ref() };\n+        let v = unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() };\n+        (k, v)\n+    }\n }\n \n impl<'a, K, V, NodeType> Handle<NodeRef<marker::ValMut<'a>, K, V, NodeType>, marker::KV> {\n@@ -1667,6 +1731,7 @@ pub mod marker {\n \n     pub enum Owned {}\n     pub enum Dying {}\n+    pub enum DormantMut {}\n     pub struct Immut<'a>(PhantomData<&'a ()>);\n     pub struct Mut<'a>(PhantomData<&'a mut ()>);\n     pub struct ValMut<'a>(PhantomData<&'a mut ()>);\n@@ -1688,6 +1753,7 @@ pub mod marker {\n     impl<'a> BorrowType for Immut<'a> {}\n     impl<'a> BorrowType for Mut<'a> {}\n     impl<'a> BorrowType for ValMut<'a> {}\n+    impl BorrowType for DormantMut {}\n \n     pub enum KV {}\n     pub enum Edge {}"}, {"sha": "7f07e4fddef77ca7f0c0e51f5352a922b5d5b776", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -102,7 +102,7 @@ enum ErrorData<C> {\n /// portability.\n ///\n /// [`into`]: Into::into\n-#[unstable(feature = \"raw_os_error_ty\", issue = \"none\")]\n+#[unstable(feature = \"raw_os_error_ty\", issue = \"107792\")]\n pub type RawOsError = i32;\n \n // `#[repr(align(4))]` is probably redundant, it should have that value or"}, {"sha": "b2b6d86134b6292bff70b20964bd26584b1bcac8", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -262,7 +262,7 @@ use crate::sys_common::memchr;\n \n #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n pub use self::buffered::WriterPanicked;\n-#[unstable(feature = \"raw_os_error_ty\", issue = \"none\")]\n+#[unstable(feature = \"raw_os_error_ty\", issue = \"107792\")]\n pub use self::error::RawOsError;\n pub(crate) use self::stdio::attempt_print_to_stderr;\n #[unstable(feature = \"internal_output_capture\", issue = \"none\")]"}, {"sha": "7c5c6eb3d2bbf1b5ee5b713763a09d05749240cc", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -222,7 +222,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n     fn after_krate(&mut self) -> Result<(), Error> {\n         debug!(\"Done with crate\");\n \n-        debug!(\"Adding Primitve impls\");\n+        debug!(\"Adding Primitive impls\");\n         for primitive in Rc::clone(&self.cache).primitive_locations.values() {\n             self.get_impls(*primitive);\n         }"}, {"sha": "fdc2a7666d69b0a6ccbaad809fd933bf45124919", "filename": "tests/ui/macros/stringify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/tests%2Fui%2Fmacros%2Fstringify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/tests%2Fui%2Fmacros%2Fstringify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fstringify.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -626,7 +626,7 @@ fn test_item() {\n         stringify_item!(\n             impl ~const Struct {}\n         ),\n-        \"impl Struct {}\", // FIXME\n+        \"impl ~const Struct {}\",\n     );\n \n     // ItemKind::MacCall\n@@ -838,15 +838,15 @@ fn test_ty() {\n     assert_eq!(stringify_ty!(dyn Send + 'a), \"dyn Send + 'a\");\n     assert_eq!(stringify_ty!(dyn 'a + Send), \"dyn 'a + Send\");\n     assert_eq!(stringify_ty!(dyn ?Sized), \"dyn ?Sized\");\n-    assert_eq!(stringify_ty!(dyn ~const Clone), \"dyn Clone\"); // FIXME\n+    assert_eq!(stringify_ty!(dyn ~const Clone), \"dyn ~const Clone\");\n     assert_eq!(stringify_ty!(dyn for<'a> Send), \"dyn for<'a> Send\");\n \n     // TyKind::ImplTrait\n     assert_eq!(stringify_ty!(impl Send), \"impl Send\");\n     assert_eq!(stringify_ty!(impl Send + 'a), \"impl Send + 'a\");\n     assert_eq!(stringify_ty!(impl 'a + Send), \"impl 'a + Send\");\n     assert_eq!(stringify_ty!(impl ?Sized), \"impl ?Sized\");\n-    assert_eq!(stringify_ty!(impl ~const Clone), \"impl Clone\"); // FIXME\n+    assert_eq!(stringify_ty!(impl ~const Clone), \"impl ~const Clone\");\n     assert_eq!(stringify_ty!(impl for<'a> Send), \"impl for<'a> Send\");\n \n     // TyKind::Paren"}, {"sha": "72edfbc97e48fb0b3421cad2dfb19eda8e5b880e", "filename": "tests/ui/rfc-2632-const-trait-impl/const_derives/derive-const-with-params.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-with-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-with-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-with-params.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+#![feature(derive_const)]\n+#![feature(const_trait_impl)]\n+\n+#[derive_const(PartialEq)]\n+pub struct Reverse<T>(T);\n+\n+const fn foo(a: Reverse<i32>, b: Reverse<i32>) -> bool {\n+    a == b\n+}\n+\n+fn main() {}"}, {"sha": "dbcba7871ec96fdd86ce86d0fb4263cf783b451a", "filename": "tests/ui/unpretty/ast-const-trait-bound.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/tests%2Fui%2Funpretty%2Fast-const-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/tests%2Fui%2Funpretty%2Fast-const-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funpretty%2Fast-const-trait-bound.rs?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: -Zunpretty=normal\n+// check-pass\n+\n+fn foo() where T: ~const Bar {}"}, {"sha": "dbcba7871ec96fdd86ce86d0fb4263cf783b451a", "filename": "tests/ui/unpretty/ast-const-trait-bound.stdout", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef934d9b632b8ac00276558824664c104b92b5f0/tests%2Fui%2Funpretty%2Fast-const-trait-bound.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ef934d9b632b8ac00276558824664c104b92b5f0/tests%2Fui%2Funpretty%2Fast-const-trait-bound.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funpretty%2Fast-const-trait-bound.stdout?ref=ef934d9b632b8ac00276558824664c104b92b5f0", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: -Zunpretty=normal\n+// check-pass\n+\n+fn foo() where T: ~const Bar {}"}]}