{"sha": "56f0fbeafcb42cf1b07a316e6d91895144a5043b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZjBmYmVhZmNiNDJjZjFiMDdhMzE2ZTZkOTE4OTUxNDRhNTA0M2I=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-29T21:56:43Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-30T01:22:41Z"}, "message": "Initial trans of lambdas. Doesn't work with polymorphism yet.", "tree": {"sha": "40c78ab316dc578ead0b28fb185b828fe9553bc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40c78ab316dc578ead0b28fb185b828fe9553bc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56f0fbeafcb42cf1b07a316e6d91895144a5043b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56f0fbeafcb42cf1b07a316e6d91895144a5043b", "html_url": "https://github.com/rust-lang/rust/commit/56f0fbeafcb42cf1b07a316e6d91895144a5043b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56f0fbeafcb42cf1b07a316e6d91895144a5043b/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "766e93985784ee8f24d70a16751c3cb265bbeb69", "url": "https://api.github.com/repos/rust-lang/rust/commits/766e93985784ee8f24d70a16751c3cb265bbeb69", "html_url": "https://github.com/rust-lang/rust/commit/766e93985784ee8f24d70a16751c3cb265bbeb69"}], "stats": {"total": 69, "additions": 61, "deletions": 8}, "files": [{"sha": "63bed8b2ba2f4f8c4ef0cd3ce8951b26d7c130c9", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/56f0fbeafcb42cf1b07a316e6d91895144a5043b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56f0fbeafcb42cf1b07a316e6d91895144a5043b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=56f0fbeafcb42cf1b07a316e6d91895144a5043b", "patch": "@@ -3720,6 +3720,19 @@ fn build_environment_heap(bcx: @block_ctxt, lltydescs: ValueRef[],\n     ret {ptr: r.box, ptrty: closure_ty, bcx: bcx};\n }\n \n+fn build_copying_closure(cx: &@block_ctxt, upvars: &@ast::node_id[])\n+    -> {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n+        let closure_vals: lval_result[] = ~[];\n+        let closure_tys: ty::t[] = ~[];\n+        for nid: ast::node_id  in *upvars {\n+            closure_vals += ~[trans_var(cx, cx.sp, nid)];\n+            closure_tys += ~[ty::node_id_to_monotype(bcx_tcx(cx), nid)];\n+        }\n+\n+        ret build_environment_heap(cx, cx.fcx.lltydescs,\n+                                   closure_tys, closure_vals);\n+}\n+\n // Given a block context and a list of upvars, construct a closure that\n // contains pointers to all of the upvars and all of the tydescs in\n // scope. Return the ValueRef and TypeRef corresponding to the closure.\n@@ -3785,6 +3798,43 @@ fn build_environment(cx: &@block_ctxt, upvars: &@ast::node_id[]) ->\n     ret {ptr: llenvptr, ptrty: llenvptrty};\n }\n \n+fn load_environment_heap(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt,\n+                         envty: &ty::t, upvars: &@ast::node_id[]) {\n+    let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n+\n+    let llenvptr =\n+        bcx.build.GEP(fcx.llenv, ~[C_int(0), C_int(abi::box_rc_field_body)]);\n+    let llenvptrty = T_ptr(type_of(bcx_ccx(bcx), bcx.sp, envty));;\n+    llenvptr = bcx.build.PointerCast(llenvptr, llenvptrty);\n+\n+    // Populate the upvars from the environment.\n+    let llbindingsptr =\n+        bcx.build.GEP(llenvptr,\n+                      ~[C_int(0), C_int(abi::closure_elt_bindings)]);\n+    let i = 0u;\n+    for upvar_id: ast::node_id  in *upvars {\n+        let llupvarptr =\n+            bcx.build.GEP(llbindingsptr, ~[C_int(0), C_int(i as int)]);\n+        let def_id = ast::def_id_of_def(bcx_tcx(bcx).def_map.get(upvar_id));\n+        fcx.llupvars.insert(def_id.node, llupvarptr);\n+        i += 1u;\n+    }\n+\n+    // Populate the type parameters from the environment.\n+    let lltydescsptr =\n+        bcx.build.GEP(llenvptr,\n+                      ~[C_int(0), C_int(abi::closure_elt_ty_params)]);\n+    let tydesc_count = std::ivec::len(enclosing_cx.fcx.lltydescs);\n+    i = 0u;\n+    while i < tydesc_count {\n+        let lltydescptr =\n+            bcx.build.GEP(lltydescsptr, ~[C_int(0), C_int(i as int)]);\n+        fcx.lltydescs += ~[bcx.build.Load(lltydescptr)];\n+        i += 1u;\n+    }\n+}\n+\n+\n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n@@ -6399,21 +6449,24 @@ fn trans_closure(bcx_maybe: &option::t[@block_ctxt],\n     // Figure out if we need to build a closure and act accordingly\n     let closure = none;\n     alt f.proto {\n-      ast::proto_block. {\n+      ast::proto_block. | ast::proto_closure. {\n         let bcx = option::get(bcx_maybe);\n         let upvars = get_freevars(cx.ccx.tcx, id);\n \n-        let llenv = build_environment(bcx, upvars);\n+        let llenvptr = if (f.proto == ast::proto_block) {\n+            let llenv = build_environment(bcx, upvars);\n+            load_environment(bcx, fcx, llenv.ptrty, upvars);\n+            llenv.ptr\n+        } else {\n+            let llenv = build_copying_closure(bcx, upvars);\n+            load_environment_heap(bcx, fcx, llenv.ptrty, upvars);\n+            llenv.ptr\n+        };\n \n-        // Generate code to load the environment out of the\n-        // environment pointer.\n-        load_environment(bcx, fcx, llenv.ptrty, upvars);\n-        // Build the closure.\n         closure =\n             some(create_real_fn_pair(bcx, option::get(llfnty), llfndecl,\n-                                     llenv.ptr));\n+                                     llenvptr));\n       }\n-      ast::proto_closure. { fail \"copy capture not implemented yet\"; }\n       _ { }\n     }\n "}]}