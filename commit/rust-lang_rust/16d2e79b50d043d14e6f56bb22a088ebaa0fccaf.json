{"sha": "16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "node_id": "C_kwDOAAsO6NoAKDE2ZDJlNzliNTBkMDQzZDE0ZTZmNTZiYjIyYTA4OGViYWEwZmNjYWY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-05-05T13:49:03Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-05-05T13:50:40Z"}, "message": "internal: Remove unqualified_path completions module", "tree": {"sha": "4a64d0783aa08c639a4e5710d4da90ad1dee7f59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a64d0783aa08c639a4e5710d4da90ad1dee7f59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "html_url": "https://github.com/rust-lang/rust/commit/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25d133e3b8bc1241063db18ea2e47ba893a7260f", "url": "https://api.github.com/repos/rust-lang/rust/commits/25d133e3b8bc1241063db18ea2e47ba893a7260f", "html_url": "https://github.com/rust-lang/rust/commit/25d133e3b8bc1241063db18ea2e47ba893a7260f"}], "stats": {"total": 885, "additions": 464, "deletions": 421}, "files": [{"sha": "b22124cc695db1b16fedc4db6083aad498c0a50e", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -2,6 +2,7 @@\n \n pub(crate) mod attribute;\n pub(crate) mod dot;\n+pub(crate) mod expr;\n pub(crate) mod extern_abi;\n pub(crate) mod flyimport;\n pub(crate) mod fn_param;\n@@ -16,7 +17,7 @@ pub(crate) mod qualified_path;\n pub(crate) mod record;\n pub(crate) mod snippet;\n pub(crate) mod trait_impl;\n-pub(crate) mod unqualified_path;\n+pub(crate) mod r#type;\n pub(crate) mod use_;\n pub(crate) mod vis;\n "}, {"sha": "f9717f1c2c17f3ce2a0c7e161ee849ec8e0fe54a", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -0,0 +1,49 @@\n+//! Completion of names from the current scope in expression position.\n+\n+use hir::ScopeDef;\n+\n+use crate::{\n+    context::{PathCompletionCtx, PathKind, PathQualifierCtx},\n+    CompletionContext, Completions,\n+};\n+\n+pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext) {\n+    let _p = profile::span(\"complete_expr_path\");\n+    if ctx.is_path_disallowed() {\n+        return;\n+    }\n+\n+    let (&is_absolute_path, qualifier) = match &ctx.path_context {\n+        Some(PathCompletionCtx {\n+            kind: Some(PathKind::Expr), is_absolute_path, qualifier, ..\n+        }) => (is_absolute_path, qualifier),\n+        _ => return,\n+    };\n+\n+    match qualifier {\n+        Some(PathQualifierCtx { .. }) => return,\n+        None if is_absolute_path => acc.add_crate_roots(ctx),\n+        None => {\n+            acc.add_nameref_keywords_with_colon(ctx);\n+            if let Some(hir::Adt::Enum(e)) =\n+                ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n+            {\n+                super::enum_variants_with_paths(acc, ctx, e, |acc, ctx, variant, path| {\n+                    acc.add_qualified_enum_variant(ctx, variant, path)\n+                });\n+            }\n+            ctx.process_all_names(&mut |name, def| {\n+                use hir::{GenericParam::*, ModuleDef::*};\n+                let add_resolution = match def {\n+                    ScopeDef::GenericParam(LifetimeParam(_)) | ScopeDef::Label(_) => false,\n+                    // Don't suggest attribute macros and derives.\n+                    ScopeDef::ModuleDef(Macro(mac)) => mac.is_fn_like(ctx.db),\n+                    _ => true,\n+                };\n+                if add_resolution {\n+                    acc.add_resolution(ctx, name, def);\n+                }\n+            });\n+        }\n+    }\n+}"}, {"sha": "ff1abd715dc7a871fcde49757c6397d79c9e38cc", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -7,7 +7,7 @@ use crate::{\n };\n \n pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext) {\n-    let _p = profile::span(\"complete_unqualified_path\");\n+    let _p = profile::span(\"complete_item_list\");\n     if ctx.is_path_disallowed() || ctx.has_unfinished_impl_or_trait_prev_sibling() {\n         return;\n     }"}, {"sha": "4d0e2fb59ac8d591b0cf4e6ee5b3dbc867b9d61e", "filename": "crates/ide-completion/src/completions/type.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -0,0 +1,90 @@\n+//! Completion of names from the current scope in type position.\n+\n+use hir::ScopeDef;\n+use syntax::{ast, AstNode};\n+\n+use crate::{\n+    context::{PathCompletionCtx, PathKind, PathQualifierCtx},\n+    patterns::ImmediateLocation,\n+    CompletionContext, Completions,\n+};\n+\n+pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext) {\n+    let _p = profile::span(\"complete_type_path\");\n+    if ctx.is_path_disallowed() {\n+        return;\n+    }\n+\n+    let (&is_absolute_path, qualifier) = match &ctx.path_context {\n+        Some(PathCompletionCtx {\n+            kind: Some(PathKind::Type), is_absolute_path, qualifier, ..\n+        }) => (is_absolute_path, qualifier),\n+        _ => return,\n+    };\n+\n+    match qualifier {\n+        Some(PathQualifierCtx { .. }) => return,\n+        None if is_absolute_path => acc.add_crate_roots(ctx),\n+        None => {\n+            acc.add_nameref_keywords_with_colon(ctx);\n+            if let Some(ImmediateLocation::TypeBound) = &ctx.completion_location {\n+                ctx.process_all_names(&mut |name, res| {\n+                    let add_resolution = match res {\n+                        ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n+                        ScopeDef::ModuleDef(\n+                            hir::ModuleDef::Trait(_) | hir::ModuleDef::Module(_),\n+                        ) => true,\n+                        _ => false,\n+                    };\n+                    if add_resolution {\n+                        acc.add_resolution(ctx, name, res);\n+                    }\n+                });\n+                return;\n+            }\n+            if let Some(ImmediateLocation::GenericArgList(arg_list)) = &ctx.completion_location {\n+                if let Some(path_seg) = arg_list.syntax().parent().and_then(ast::PathSegment::cast)\n+                {\n+                    if let Some(hir::PathResolution::Def(hir::ModuleDef::Trait(trait_))) =\n+                        ctx.sema.resolve_path(&path_seg.parent_path())\n+                    {\n+                        trait_.items(ctx.sema.db).into_iter().for_each(|it| {\n+                            if let hir::AssocItem::TypeAlias(alias) = it {\n+                                acc.add_type_alias_with_eq(ctx, alias)\n+                            }\n+                        });\n+                    }\n+                }\n+            }\n+            ctx.process_all_names(&mut |name, def| {\n+                use hir::{GenericParam::*, ModuleDef::*};\n+                let add_resolution = match def {\n+                    ScopeDef::GenericParam(LifetimeParam(_)) | ScopeDef::Label(_) => false,\n+                    // no values in type places\n+                    ScopeDef::ModuleDef(Function(_) | Variant(_) | Static(_))\n+                    | ScopeDef::Local(_) => false,\n+                    // unless its a constant in a generic arg list position\n+                    ScopeDef::ModuleDef(Const(_)) | ScopeDef::GenericParam(ConstParam(_)) => {\n+                        ctx.expects_generic_arg()\n+                    }\n+                    ScopeDef::ImplSelfType(_) => {\n+                        !ctx.previous_token_is(syntax::T![impl])\n+                            && !ctx.previous_token_is(syntax::T![for])\n+                    }\n+                    // Don't suggest attribute macros and derives.\n+                    ScopeDef::ModuleDef(Macro(mac)) => mac.is_fn_like(ctx.db),\n+                    // Type things are fine\n+                    ScopeDef::ModuleDef(\n+                        BuiltinType(_) | Adt(_) | Module(_) | Trait(_) | TypeAlias(_),\n+                    )\n+                    | ScopeDef::AdtSelfType(_)\n+                    | ScopeDef::Unknown\n+                    | ScopeDef::GenericParam(TypeParam(_)) => true,\n+                };\n+                if add_resolution {\n+                    acc.add_resolution(ctx, name, def);\n+                }\n+            });\n+        }\n+    }\n+}"}, {"sha": "5de602e6138237510d9b2c3cd761d6defc8d9467", "filename": "crates/ide-completion/src/completions/unqualified_path.rs", "status": "removed", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/25d133e3b8bc1241063db18ea2e47ba893a7260f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d133e3b8bc1241063db18ea2e47ba893a7260f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=25d133e3b8bc1241063db18ea2e47ba893a7260f", "patch": "@@ -1,289 +0,0 @@\n-//! Completion of names from the current scope, e.g. locals and imported items.\n-\n-use hir::ScopeDef;\n-use syntax::{ast, AstNode};\n-\n-use crate::{\n-    context::{PathCompletionCtx, PathKind},\n-    patterns::ImmediateLocation,\n-    CompletionContext, Completions,\n-};\n-\n-pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n-    let _p = profile::span(\"complete_unqualified_path\");\n-    if ctx.is_path_disallowed() || ctx.has_unfinished_impl_or_trait_prev_sibling() {\n-        return;\n-    }\n-\n-    match &ctx.path_context {\n-        Some(PathCompletionCtx {\n-            is_absolute_path: false,\n-            qualifier: None,\n-            kind: None | Some(PathKind::Expr | PathKind::Type),\n-            ..\n-        }) => (),\n-        _ => return,\n-    }\n-\n-    acc.add_nameref_keywords(ctx);\n-\n-    match &ctx.completion_location {\n-        Some(ImmediateLocation::TypeBound) => {\n-            ctx.process_all_names(&mut |name, res| {\n-                let add_resolution = match res {\n-                    ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n-                    ScopeDef::ModuleDef(hir::ModuleDef::Trait(_) | hir::ModuleDef::Module(_)) => {\n-                        true\n-                    }\n-                    _ => false,\n-                };\n-                if add_resolution {\n-                    acc.add_resolution(ctx, name, res);\n-                }\n-            });\n-            return;\n-        }\n-        _ => (),\n-    }\n-\n-    if !ctx.expects_type() {\n-        if let Some(hir::Adt::Enum(e)) =\n-            ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n-        {\n-            super::enum_variants_with_paths(acc, ctx, e, |acc, ctx, variant, path| {\n-                acc.add_qualified_enum_variant(ctx, variant, path)\n-            });\n-        }\n-    }\n-\n-    if let Some(ImmediateLocation::GenericArgList(arg_list)) = &ctx.completion_location {\n-        if let Some(path_seg) = arg_list.syntax().parent().and_then(ast::PathSegment::cast) {\n-            if let Some(hir::PathResolution::Def(hir::ModuleDef::Trait(trait_))) =\n-                ctx.sema.resolve_path(&path_seg.parent_path())\n-            {\n-                trait_.items(ctx.sema.db).into_iter().for_each(|it| {\n-                    if let hir::AssocItem::TypeAlias(alias) = it {\n-                        acc.add_type_alias_with_eq(ctx, alias)\n-                    }\n-                });\n-            }\n-        }\n-    }\n-\n-    ctx.process_all_names(&mut |name, res| {\n-        let add_resolution = match res {\n-            ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) | ScopeDef::Label(_) => {\n-                cov_mark::hit!(unqualified_skip_lifetime_completion);\n-                return;\n-            }\n-            ScopeDef::ImplSelfType(_) => {\n-                !ctx.previous_token_is(syntax::T![impl]) && !ctx.previous_token_is(syntax::T![for])\n-            }\n-            // Don't suggest attribute macros and derives.\n-            ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n-            // no values in type places\n-            ScopeDef::ModuleDef(\n-                hir::ModuleDef::Function(_)\n-                | hir::ModuleDef::Variant(_)\n-                | hir::ModuleDef::Static(_),\n-            )\n-            | ScopeDef::Local(_) => !ctx.expects_type(),\n-            // unless its a constant in a generic arg list position\n-            ScopeDef::ModuleDef(hir::ModuleDef::Const(_))\n-            | ScopeDef::GenericParam(hir::GenericParam::ConstParam(_)) => {\n-                !ctx.expects_type() || ctx.expects_generic_arg()\n-            }\n-            _ => true,\n-        };\n-        if add_resolution {\n-            acc.add_resolution(ctx, name, res);\n-        }\n-    });\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use expect_test::{expect, Expect};\n-\n-    use crate::tests::{check_edit, completion_list_no_kw};\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = completion_list_no_kw(ra_fixture);\n-        expect.assert_eq(&actual)\n-    }\n-\n-    #[test]\n-    fn completes_if_prefix_is_keyword() {\n-        check_edit(\n-            \"wherewolf\",\n-            r#\"\n-fn main() {\n-    let wherewolf = 92;\n-    drop(where$0)\n-}\n-\"#,\n-            r#\"\n-fn main() {\n-    let wherewolf = 92;\n-    drop(wherewolf)\n-}\n-\"#,\n-        )\n-    }\n-\n-    /// Regression test for issue #6091.\n-    #[test]\n-    fn correctly_completes_module_items_prefixed_with_underscore() {\n-        check_edit(\n-            \"_alpha\",\n-            r#\"\n-fn main() {\n-    _$0\n-}\n-fn _alpha() {}\n-\"#,\n-            r#\"\n-fn main() {\n-    _alpha()$0\n-}\n-fn _alpha() {}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_prelude() {\n-        check(\n-            r#\"\n-//- /main.rs crate:main deps:std\n-fn foo() { let x: $0 }\n-\n-//- /std/lib.rs crate:std\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub struct Option;\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                md std\n-                st Option\n-                bt u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_prelude_macros() {\n-        check(\n-            r#\"\n-//- /main.rs crate:main deps:std\n-fn f() {$0}\n-\n-//- /std/lib.rs crate:std\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub use crate::concat;\n-    }\n-}\n-\n-mod macros {\n-    #[rustc_builtin_macro]\n-    #[macro_export]\n-    macro_rules! concat { }\n-}\n-\"#,\n-            expect![[r#\"\n-                fn f()        fn()\n-                ma concat!(\u2026) macro_rules! concat\n-                md std\n-                bt u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_std_prelude_if_core_is_defined() {\n-        check(\n-            r#\"\n-//- /main.rs crate:main deps:core,std\n-fn foo() { let x: $0 }\n-\n-//- /core/lib.rs crate:core\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub struct Option;\n-    }\n-}\n-\n-//- /std/lib.rs crate:std deps:core\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub struct String;\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                md core\n-                md std\n-                st String\n-                bt u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn respects_doc_hidden() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:lib deps:std\n-fn f() {\n-    format_$0\n-}\n-\n-//- /std.rs crate:std\n-#[doc(hidden)]\n-#[macro_export]\n-macro_rules! format_args_nl {\n-    () => {}\n-}\n-\n-pub mod prelude {\n-    pub mod rust_2018 {}\n-}\n-            \"#,\n-            expect![[r#\"\n-                fn f() fn()\n-                md std\n-                bt u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn respects_doc_hidden_in_assoc_item_list() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:lib deps:std\n-struct S;\n-impl S {\n-    format_$0\n-}\n-\n-//- /std.rs crate:std\n-#[doc(hidden)]\n-#[macro_export]\n-macro_rules! format_args_nl {\n-    () => {}\n-}\n-\n-pub mod prelude {\n-    pub mod rust_2018 {}\n-}\n-            \"#,\n-            expect![[r#\"\n-                md std\n-            \"#]],\n-        );\n-    }\n-}"}, {"sha": "87677e28e85885dfb8052a72ab59ce983fd88c02", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -71,6 +71,10 @@ pub(crate) struct PathCompletionCtx {\n     pub(super) is_absolute_path: bool,\n     /// The qualifier of the current path if it exists.\n     pub(super) qualifier: Option<PathQualifierCtx>,\n+    #[allow(dead_code)]\n+    // FIXME: use this\n+    /// The parent of the path we are completing.\n+    pub(super) parent: Option<ast::Path>,\n     pub(super) kind: Option<PathKind>,\n     /// Whether the path segment has type args or not.\n     pub(super) has_type_args: bool,\n@@ -949,13 +953,14 @@ impl<'a> CompletionContext<'a> {\n \n         let mut path_ctx = PathCompletionCtx {\n             has_call_parens: false,\n+            has_macro_bang: false,\n             is_absolute_path: false,\n             qualifier: None,\n+            parent: path.parent_path(),\n+            kind: None,\n             has_type_args: false,\n             can_be_stmt: false,\n             in_loop_body: false,\n-            has_macro_bang: false,\n-            kind: None,\n         };\n         let mut pat_ctx = None;\n         path_ctx.in_loop_body = is_in_loop_body(name_ref.syntax());"}, {"sha": "3a0bd042daf241346f41a2cb009e3e09ec029fd3", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -144,34 +144,38 @@ pub fn completions(\n     config: &CompletionConfig,\n     position: FilePosition,\n ) -> Option<Completions> {\n-    let ctx = CompletionContext::new(db, position, config)?;\n-\n+    let ctx = &CompletionContext::new(db, position, config)?;\n     let mut acc = Completions::default();\n-    completions::attribute::complete_attribute(&mut acc, &ctx);\n-    completions::attribute::complete_derive(&mut acc, &ctx);\n-    completions::attribute::complete_known_attribute_input(&mut acc, &ctx);\n-    completions::dot::complete_dot(&mut acc, &ctx);\n-    completions::extern_abi::complete_extern_abi(&mut acc, &ctx);\n-    completions::flyimport::import_on_the_fly(&mut acc, &ctx);\n-    completions::fn_param::complete_fn_param(&mut acc, &ctx);\n-    completions::format_string::format_string(&mut acc, &ctx);\n-    completions::item_list::complete_item_list(&mut acc, &ctx);\n-    completions::inferred_type(&mut acc, &ctx);\n-    completions::keyword::complete_expr_keyword(&mut acc, &ctx);\n-    completions::lifetime::complete_label(&mut acc, &ctx);\n-    completions::lifetime::complete_lifetime(&mut acc, &ctx);\n-    completions::mod_::complete_mod(&mut acc, &ctx);\n-    completions::pattern::complete_pattern(&mut acc, &ctx);\n-    completions::postfix::complete_postfix(&mut acc, &ctx);\n-    completions::qualified_path::complete_qualified_path(&mut acc, &ctx);\n-    completions::record::complete_record_literal(&mut acc, &ctx);\n-    completions::record::complete_record(&mut acc, &ctx);\n-    completions::snippet::complete_expr_snippet(&mut acc, &ctx);\n-    completions::snippet::complete_item_snippet(&mut acc, &ctx);\n-    completions::trait_impl::complete_trait_impl(&mut acc, &ctx);\n-    completions::unqualified_path::complete_unqualified_path(&mut acc, &ctx);\n-    completions::use_::complete_use_tree(&mut acc, &ctx);\n-    completions::vis::complete_vis(&mut acc, &ctx);\n+\n+    {\n+        let acc = &mut acc;\n+        completions::attribute::complete_attribute(acc, ctx);\n+        completions::attribute::complete_derive(acc, ctx);\n+        completions::attribute::complete_known_attribute_input(acc, ctx);\n+        completions::dot::complete_dot(acc, ctx);\n+        completions::expr::complete_expr_path(acc, ctx);\n+        completions::extern_abi::complete_extern_abi(acc, ctx);\n+        completions::flyimport::import_on_the_fly(acc, ctx);\n+        completions::fn_param::complete_fn_param(acc, ctx);\n+        completions::format_string::format_string(acc, ctx);\n+        completions::item_list::complete_item_list(acc, ctx);\n+        completions::inferred_type(acc, ctx);\n+        completions::keyword::complete_expr_keyword(acc, ctx);\n+        completions::lifetime::complete_label(acc, ctx);\n+        completions::lifetime::complete_lifetime(acc, ctx);\n+        completions::mod_::complete_mod(acc, ctx);\n+        completions::pattern::complete_pattern(acc, ctx);\n+        completions::postfix::complete_postfix(acc, ctx);\n+        completions::qualified_path::complete_qualified_path(acc, ctx);\n+        completions::record::complete_record_literal(acc, ctx);\n+        completions::record::complete_record(acc, ctx);\n+        completions::snippet::complete_expr_snippet(acc, ctx);\n+        completions::snippet::complete_item_snippet(acc, ctx);\n+        completions::trait_impl::complete_trait_impl(acc, ctx);\n+        completions::r#type::complete_type_path(acc, ctx);\n+        completions::use_::complete_use_tree(acc, ctx);\n+        completions::vis::complete_vis(acc, ctx);\n+    }\n \n     Some(acc)\n }"}, {"sha": "8d9d1bc4b958d0aa9d826fb1147d57bc7f2d68bd", "filename": "crates/ide-completion/src/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -10,17 +10,18 @@\n \n mod attribute;\n mod expression;\n+mod flyimport;\n mod fn_param;\n mod item_list;\n mod item;\n mod pattern;\n mod predicate;\n mod proc_macros;\n mod record;\n+mod special;\n mod type_pos;\n mod use_tree;\n mod visibility;\n-mod flyimport;\n \n use std::mem;\n "}, {"sha": "61246b963e15f552e7407f58518a03b3c5a5466f", "filename": "crates/ide-completion/src/tests/expression.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -48,7 +48,7 @@ fn baz() {\n             un Union\n             ev TupleV(\u2026)     TupleV(u32)\n             bt u32\n-            kw crate\n+            kw crate::\n             kw false\n             kw for\n             kw if\n@@ -57,8 +57,8 @@ fn baz() {\n             kw match\n             kw mut\n             kw return\n-            kw self\n-            kw super\n+            kw self::\n+            kw super::\n             kw true\n             kw unsafe\n             kw while\n@@ -91,16 +91,16 @@ fn func(param0 @ (param1, param2): (i32, i32)) {\n             lc param1     i32\n             lc param2     i32\n             bt u32\n-            kw crate\n+            kw crate::\n             kw false\n             kw for\n             kw if\n             kw if let\n             kw loop\n             kw match\n             kw return\n-            kw self\n-            kw super\n+            kw self::\n+            kw super::\n             kw true\n             kw unsafe\n             kw while\n@@ -111,7 +111,6 @@ fn func(param0 @ (param1, param2): (i32, i32)) {\n \n #[test]\n fn completes_all_the_things_in_fn_body() {\n-    cov_mark::check!(unqualified_skip_lifetime_completion);\n     check(\n         r#\"\n use non_existant::Unresolved;\n@@ -146,7 +145,7 @@ impl Unit {\n             ev TupleV(\u2026)    TupleV(u32)\n             bt u32\n             kw const\n-            kw crate\n+            kw crate::\n             kw enum\n             kw extern\n             kw false\n@@ -160,10 +159,10 @@ impl Unit {\n             kw match\n             kw mod\n             kw return\n-            kw self\n+            kw self::\n             kw static\n             kw struct\n-            kw super\n+            kw super::\n             kw trait\n             kw true\n             kw type\n@@ -224,7 +223,7 @@ fn complete_in_block() {\n             fn foo()       fn()\n             bt u32\n             kw const\n-            kw crate\n+            kw crate::\n             kw enum\n             kw extern\n             kw false\n@@ -238,10 +237,10 @@ fn complete_in_block() {\n             kw match\n             kw mod\n             kw return\n-            kw self\n+            kw self::\n             kw static\n             kw struct\n-            kw super\n+            kw super::\n             kw trait\n             kw true\n             kw type\n@@ -270,7 +269,7 @@ fn complete_after_if_expr() {\n             fn foo()       fn()\n             bt u32\n             kw const\n-            kw crate\n+            kw crate::\n             kw else\n             kw else if\n             kw enum\n@@ -286,10 +285,10 @@ fn complete_after_if_expr() {\n             kw match\n             kw mod\n             kw return\n-            kw self\n+            kw self::\n             kw static\n             kw struct\n-            kw super\n+            kw super::\n             kw trait\n             kw true\n             kw type\n@@ -318,16 +317,16 @@ fn complete_in_match_arm() {\n         expect![[r#\"\n             fn foo()     fn()\n             bt u32\n-            kw crate\n+            kw crate::\n             kw false\n             kw for\n             kw if\n             kw if let\n             kw loop\n             kw match\n             kw return\n-            kw self\n-            kw super\n+            kw self::\n+            kw super::\n             kw true\n             kw unsafe\n             kw while\n@@ -346,7 +345,7 @@ fn completes_in_loop_ctx() {\n             kw break\n             kw const\n             kw continue\n-            kw crate\n+            kw crate::\n             kw enum\n             kw extern\n             kw false\n@@ -360,10 +359,10 @@ fn completes_in_loop_ctx() {\n             kw match\n             kw mod\n             kw return\n-            kw self\n+            kw self::\n             kw static\n             kw struct\n-            kw super\n+            kw super::\n             kw trait\n             kw true\n             kw type\n@@ -386,16 +385,16 @@ fn completes_in_let_initializer() {\n         expect![[r#\"\n             fn main()    fn()\n             bt u32\n-            kw crate\n+            kw crate::\n             kw false\n             kw for\n             kw if\n             kw if let\n             kw loop\n             kw match\n             kw return\n-            kw self\n-            kw super\n+            kw self::\n+            kw super::\n             kw true\n             kw unsafe\n             kw while\n@@ -421,16 +420,16 @@ fn foo() {\n             fn foo()     fn()\n             st Foo\n             bt u32\n-            kw crate\n+            kw crate::\n             kw false\n             kw for\n             kw if\n             kw if let\n             kw loop\n             kw match\n             kw return\n-            kw self\n-            kw super\n+            kw self::\n+            kw super::\n             kw true\n             kw unsafe\n             kw while\n@@ -457,16 +456,16 @@ fn foo() {\n             fn foo()     fn()\n             lc bar       i32\n             bt u32\n-            kw crate\n+            kw crate::\n             kw false\n             kw for\n             kw if\n             kw if let\n             kw loop\n             kw match\n             kw return\n-            kw self\n-            kw super\n+            kw self::\n+            kw super::\n             kw true\n             kw unsafe\n             kw while\n@@ -489,16 +488,16 @@ fn quux(x: i32) {\n             lc x         i32\n             ma m!(\u2026)     macro_rules! m\n             bt u32\n-            kw crate\n+            kw crate::\n             kw false\n             kw for\n             kw if\n             kw if let\n             kw loop\n             kw match\n             kw return\n-            kw self\n-            kw super\n+            kw self::\n+            kw super::\n             kw true\n             kw unsafe\n             kw while\n@@ -517,16 +516,16 @@ fn quux(x: i32) {\n             lc x         i32\n             ma m!(\u2026)     macro_rules! m\n             bt u32\n-            kw crate\n+            kw crate::\n             kw false\n             kw for\n             kw if\n             kw if let\n             kw loop\n             kw match\n             kw return\n-            kw self\n-            kw super\n+            kw self::\n+            kw super::\n             kw true\n             kw unsafe\n             kw while"}, {"sha": "e4b70f97e31c4ac7802f136c147683d95bdd3219", "filename": "crates/ide-completion/src/tests/item.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -27,9 +27,9 @@ impl Tra$0\n             tt Trait\n             un Union\n             bt u32\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     )\n }\n@@ -50,9 +50,9 @@ impl Trait for Str$0\n             tt Trait\n             un Union\n             bt u32\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     )\n }"}, {"sha": "f2b9c061dc5e2f2cd226dafd7d44b470e14da969", "filename": "crates/ide-completion/src/tests/predicate.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -26,9 +26,9 @@ struct Foo<'lt, T, const C: usize> where $0 {}\n             tt Trait\n             un Union\n             bt u32\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -43,9 +43,9 @@ struct Foo<'lt, T, const C: usize> where T: $0 {}\n             ma makro!(\u2026) macro_rules! makro\n             md module\n             tt Trait\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -62,9 +62,9 @@ struct Foo<'lt, T, const C: usize> where 'lt: $0 {}\n             ma makro!(\u2026) macro_rules! makro\n             md module\n             tt Trait\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -79,9 +79,9 @@ struct Foo<'lt, T, const C: usize> where for<'a> T: $0 {}\n             ma makro!(\u2026) macro_rules! makro\n             md module\n             tt Trait\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -103,9 +103,9 @@ struct Foo<'lt, T, const C: usize> where for<'a> $0 {}\n             tt Trait\n             un Union\n             bt u32\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -129,9 +129,9 @@ impl Record {\n             tt Trait\n             un Union\n             bt u32\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }"}, {"sha": "a0f8b248672c912f42d2c705bdf738a934aabd72", "filename": "crates/ide-completion/src/tests/record.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -167,16 +167,16 @@ fn main() {\n             tt Default\n             tt Sized\n             bt u32\n-            kw crate\n+            kw crate::\n             kw false\n             kw for\n             kw if\n             kw if let\n             kw loop\n             kw match\n             kw return\n-            kw self\n-            kw super\n+            kw self::\n+            kw super::\n             kw true\n             kw unsafe\n             kw while"}, {"sha": "79235e5ca017678bd782177f8e75d3cf516d2f09", "filename": "crates/ide-completion/src/tests/special.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -0,0 +1,183 @@\n+use expect_test::{expect, Expect};\n+\n+use crate::tests::{check_edit, completion_list_no_kw};\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list_no_kw(ra_fixture);\n+    expect.assert_eq(&actual)\n+}\n+\n+#[test]\n+fn completes_if_prefix_is_keyword() {\n+    check_edit(\n+        \"wherewolf\",\n+        r#\"\n+fn main() {\n+    let wherewolf = 92;\n+    drop(where$0)\n+}\n+\"#,\n+        r#\"\n+fn main() {\n+    let wherewolf = 92;\n+    drop(wherewolf)\n+}\n+\"#,\n+    )\n+}\n+\n+/// Regression test for issue #6091.\n+#[test]\n+fn correctly_completes_module_items_prefixed_with_underscore() {\n+    check_edit(\n+        \"_alpha\",\n+        r#\"\n+fn main() {\n+    _$0\n+}\n+fn _alpha() {}\n+\"#,\n+        r#\"\n+fn main() {\n+    _alpha()$0\n+}\n+fn _alpha() {}\n+\"#,\n+    )\n+}\n+\n+#[test]\n+fn completes_prelude() {\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+fn foo() { let x: $0 }\n+\n+//- /std/lib.rs crate:std\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub struct Option;\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+                md std\n+                st Option\n+                bt u32\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_prelude_macros() {\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+fn f() {$0}\n+\n+//- /std/lib.rs crate:std\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub use crate::concat;\n+    }\n+}\n+\n+mod macros {\n+    #[rustc_builtin_macro]\n+    #[macro_export]\n+    macro_rules! concat { }\n+}\n+\"#,\n+        expect![[r#\"\n+                fn f()        fn()\n+                ma concat!(\u2026) macro_rules! concat\n+                md std\n+                bt u32\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_std_prelude_if_core_is_defined() {\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:core,std\n+fn foo() { let x: $0 }\n+\n+//- /core/lib.rs crate:core\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub struct Option;\n+    }\n+}\n+\n+//- /std/lib.rs crate:std deps:core\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub struct String;\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+                md core\n+                md std\n+                st String\n+                bt u32\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn respects_doc_hidden() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:lib deps:std\n+fn f() {\n+    format_$0\n+}\n+\n+//- /std.rs crate:std\n+#[doc(hidden)]\n+#[macro_export]\n+macro_rules! format_args_nl {\n+    () => {}\n+}\n+\n+pub mod prelude {\n+    pub mod rust_2018 {}\n+}\n+            \"#,\n+        expect![[r#\"\n+                fn f() fn()\n+                md std\n+                bt u32\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn respects_doc_hidden_in_assoc_item_list() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:lib deps:std\n+struct S;\n+impl S {\n+    format_$0\n+}\n+\n+//- /std.rs crate:std\n+#[doc(hidden)]\n+#[macro_export]\n+macro_rules! format_args_nl {\n+    () => {}\n+}\n+\n+pub mod prelude {\n+    pub mod rust_2018 {}\n+}\n+            \"#,\n+        expect![[r#\"\n+                md std\n+            \"#]],\n+    );\n+}"}, {"sha": "5224bc4b4886e55aab57c73c24a20a16ce5e9b3e", "filename": "crates/ide-completion/src/tests/type_pos.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d2e79b50d043d14e6f56bb22a088ebaa0fccaf/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs?ref=16d2e79b50d043d14e6f56bb22a088ebaa0fccaf", "patch": "@@ -29,9 +29,9 @@ struct Foo<'lt, T, const C: usize> {\n             tp T\n             un Union\n             bt u32\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     )\n }\n@@ -55,12 +55,12 @@ struct Foo<'lt, T, const C: usize>(f$0);\n             tp T\n             un Union\n             bt u32\n-            kw crate\n+            kw crate::\n             kw pub\n             kw pub(crate)\n             kw pub(super)\n-            kw self\n-            kw super\n+            kw self::\n+            kw super::\n         \"#]],\n     )\n }\n@@ -82,9 +82,9 @@ fn x<'lt, T, const C: usize>() -> $0\n             tp T\n             un Union\n             bt u32\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -108,9 +108,9 @@ const FOO: $0 = Foo(2);\n             un Union\n             bt u32\n             it Foo<i32>\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -135,9 +135,9 @@ fn f2() {\n             un Union\n             bt u32\n             it i32\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -164,9 +164,9 @@ fn f2() {\n             un Union\n             bt u32\n             it u64\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -190,9 +190,9 @@ fn f2(x: u64) -> $0 {\n             un Union\n             bt u32\n             it u64\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -217,9 +217,9 @@ fn f2(x: $0) {\n             un Union\n             bt u32\n             it i32\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -252,9 +252,9 @@ fn foo<'lt, T, const C: usize>() {\n             un Union\n             bt u32\n             it a::Foo<a::Foo<i32>>\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -282,9 +282,9 @@ fn foo<'lt, T, const C: usize>() {\n             un Union\n             bt u32\n             it Foo<i32>\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n }\n@@ -309,9 +309,9 @@ fn foo<'lt, T, const C: usize>() {\n             tp T\n             un Union\n             bt u32\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n     check(\n@@ -359,9 +359,9 @@ fn foo<'lt, T: Trait2<$0>, const CONST_PARAM: usize>(_: T) {}\n             tp T\n             un Union\n             bt u32\n-            kw crate\n-            kw self\n-            kw super\n+            kw crate::\n+            kw self::\n+            kw super::\n         \"#]],\n     );\n     check("}]}