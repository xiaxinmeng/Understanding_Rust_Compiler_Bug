{"sha": "eecfdfb8a12367cb292a85b6a30981eb35a56379", "node_id": "C_kwDOAAsO6NoAKGVlY2ZkZmI4YTEyMzY3Y2IyOTJhODViNmEzMDk4MWViMzVhNTYzNzk", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-20T10:47:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-20T10:47:19Z"}, "message": "Rollup merge of #99383 - ouz-a:issue_57961, r=oli-obk\n\nFormalize defining_use_anchor\n\nThis tackles issue #57961\n\nIntroduces new enum called `DefiningAnchor` that replaces `Option<LocalDefId>` of `defining_use_anchor`. Now every use of it is explicit and exhaustively matched, catching errors like one in the linked issue. This is not a perfect fix but it's a step in the right direction.\n\nr? `@oli-obk`", "tree": {"sha": "5450ed5b247533c39a063456dbc71de8e2156f78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5450ed5b247533c39a063456dbc71de8e2156f78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eecfdfb8a12367cb292a85b6a30981eb35a56379", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi1903CRBK7hj4Ov3rIwAAGg8IABufWN2I7lh8QzFmdshiRp6S\nney4RmI1nw+kAddhQzQZ/fFQyW7ELme0jqSVCROmE0sX5xcKbAW+Ed5cP+KbWGZ4\nhH7EipZGCygQcAqnRDUTsHnRzjusg6CGwhLj59lghEcodQrMdkctfrfUeCGtW16q\ncAeXvDtXzHT8thMGj28OPsr3z2aEuP7T6bU7SHbBYbzHtHTKb4ZHIItSDVNRfcZV\nDPsoBN3h/+0Yo0acaU7GvQZOb1LiXlB5rwtTt8IYym9D6iY9VpdRSsNNRiuwZ39r\n6ua7TQFRm5QJMjyu4P5SUT3JhkeBiB7qGr/kx6w8P3WkE1WvlWHextpOuaM4fXM=\n=uMk+\n-----END PGP SIGNATURE-----\n", "payload": "tree 5450ed5b247533c39a063456dbc71de8e2156f78\nparent 3c3c5da9adfdf308b5189b8034c07e0dc5492a54\nparent 64dc377a103c0d377b3e60e08d29f69fcf7ba2c5\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1658314039 +0530\ncommitter GitHub <noreply@github.com> 1658314039 +0530\n\nRollup merge of #99383 - ouz-a:issue_57961, r=oli-obk\n\nFormalize defining_use_anchor\n\nThis tackles issue #57961\n\nIntroduces new enum called `DefiningAnchor` that replaces `Option<LocalDefId>` of `defining_use_anchor`. Now every use of it is explicit and exhaustively matched, catching errors like one in the linked issue. This is not a perfect fix but it's a step in the right direction.\n\nr? `@oli-obk`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eecfdfb8a12367cb292a85b6a30981eb35a56379", "html_url": "https://github.com/rust-lang/rust/commit/eecfdfb8a12367cb292a85b6a30981eb35a56379", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eecfdfb8a12367cb292a85b6a30981eb35a56379/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c3c5da9adfdf308b5189b8034c07e0dc5492a54", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c3c5da9adfdf308b5189b8034c07e0dc5492a54", "html_url": "https://github.com/rust-lang/rust/commit/3c3c5da9adfdf308b5189b8034c07e0dc5492a54"}, {"sha": "64dc377a103c0d377b3e60e08d29f69fcf7ba2c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/64dc377a103c0d377b3e60e08d29f69fcf7ba2c5", "html_url": "https://github.com/rust-lang/rust/commit/64dc377a103c0d377b3e60e08d29f69fcf7ba2c5"}], "stats": {"total": 476, "additions": 292, "deletions": 184}, "files": [{"sha": "efc17a173f4d308f539c7c19d59b9f457b6f3f3e", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_hir::def_id::LocalDefId;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n use rustc_middle::mir::Body;\n use rustc_middle::ty::{self, TyCtxt};\n \n@@ -31,7 +31,7 @@ pub fn get_body_with_borrowck_facts<'tcx>(\n     def: ty::WithOptConstParam<LocalDefId>,\n ) -> BodyWithBorrowckFacts<'tcx> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n-    tcx.infer_ctxt().with_opaque_type_inference(def.did).enter(|infcx| {\n+    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def.did)).enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n         let promoted: &IndexVec<_, _> = &promoted.borrow();\n         *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()"}, {"sha": "a5a8ded373fbabd94e31c2d24488ea09dc40d078", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -24,7 +24,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::{\n     traversal, Body, ClearCrossCrate, Local, Location, Mutability, Operand, Place, PlaceElem,\n     PlaceRef, VarDebugInfoContents,\n@@ -130,11 +130,14 @@ fn mir_borrowck<'tcx>(\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n     let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n \n-    let opt_closure_req = tcx.infer_ctxt().with_opaque_type_inference(hir_owner).enter(|infcx| {\n-        let input_body: &Body<'_> = &input_body.borrow();\n-        let promoted: &IndexVec<_, _> = &promoted.borrow();\n-        do_mir_borrowck(&infcx, input_body, promoted, false).0\n-    });\n+    let opt_closure_req = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner))\n+        .enter(|infcx| {\n+            let input_body: &Body<'_> = &input_body.borrow();\n+            let promoted: &IndexVec<_, _> = &promoted.borrow();\n+            do_mir_borrowck(&infcx, input_body, promoted, false).0\n+        });\n     debug!(\"mir_borrowck done\");\n \n     tcx.arena.alloc(opt_closure_req)"}, {"sha": "407bbf48813c35fb0e3d55d13a901174be38cea4", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -3,8 +3,8 @@ use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n-use rustc_infer::infer::InferCtxt;\n use rustc_infer::infer::TyCtxtInferExt as _;\n+use rustc_infer::infer::{DefiningAnchor, InferCtxt};\n use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n@@ -269,59 +269,65 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n             let param_env = self.tcx.param_env(def_id);\n             let body_id = self.tcx.local_def_id_to_hir_id(def_id);\n-            self.tcx.infer_ctxt().enter(move |infcx| {\n-                // Require the hidden type to be well-formed with only the generics of the opaque type.\n-                // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-                // hidden type is well formed even without those bounds.\n-                let predicate =\n-                    ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n-                        .to_predicate(infcx.tcx);\n-                let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-\n-                // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n-                // the bounds that the function supplies.\n-                match infcx.register_hidden_type(\n-                    OpaqueTypeKey { def_id, substs: id_substs },\n-                    ObligationCause::misc(instantiated_ty.span, body_id),\n-                    param_env,\n-                    definition_ty,\n-                    origin,\n-                ) {\n-                    Ok(infer_ok) => {\n-                        for obligation in infer_ok.obligations {\n-                            fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+            // HACK This bubble is required for this tests to pass:\n+            // type-alias-impl-trait/issue-67844-nested-opaque.rs\n+            self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter(\n+                move |infcx| {\n+                    // Require the hidden type to be well-formed with only the generics of the opaque type.\n+                    // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+                    // hidden type is well formed even without those bounds.\n+                    let predicate =\n+                        ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n+                            .to_predicate(infcx.tcx);\n+                    let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+\n+                    // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n+                    // the bounds that the function supplies.\n+                    match infcx.register_hidden_type(\n+                        OpaqueTypeKey { def_id, substs: id_substs },\n+                        ObligationCause::misc(instantiated_ty.span, body_id),\n+                        param_env,\n+                        definition_ty,\n+                        origin,\n+                    ) {\n+                        Ok(infer_ok) => {\n+                            for obligation in infer_ok.obligations {\n+                                fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+                            }\n+                        }\n+                        Err(err) => {\n+                            infcx\n+                                .report_mismatched_types(\n+                                    &ObligationCause::misc(instantiated_ty.span, body_id),\n+                                    self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n+                                    definition_ty,\n+                                    err,\n+                                )\n+                                .emit();\n                         }\n                     }\n-                    Err(err) => {\n-                        infcx\n-                            .report_mismatched_types(\n-                                &ObligationCause::misc(instantiated_ty.span, body_id),\n-                                self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n-                                definition_ty,\n-                                err,\n-                            )\n-                            .emit();\n-                    }\n-                }\n \n-                fulfillment_cx.register_predicate_obligation(\n-                    &infcx,\n-                    Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n-                );\n+                    fulfillment_cx.register_predicate_obligation(\n+                        &infcx,\n+                        Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n+                    );\n \n-                // Check that all obligations are satisfied by the implementation's\n-                // version.\n-                let errors = fulfillment_cx.select_all_or_error(&infcx);\n+                    // Check that all obligations are satisfied by the implementation's\n+                    // version.\n+                    let errors = fulfillment_cx.select_all_or_error(&infcx);\n \n-                let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+                    // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n+                    // tests to pass\n+                    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n-                if errors.is_empty() {\n-                    definition_ty\n-                } else {\n-                    infcx.report_fulfillment_errors(&errors, None, false);\n-                    self.tcx.ty_error()\n-                }\n-            })\n+                    if errors.is_empty() {\n+                        definition_ty\n+                    } else {\n+                        infcx.report_fulfillment_errors(&errors, None, false);\n+                        self.tcx.ty_error()\n+                    }\n+                },\n+            )\n         } else {\n             definition_ty\n         }"}, {"sha": "0e44d4e7c972b392eccd9228cc0e40a2b71a581c", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -239,17 +239,31 @@ impl<'tcx> InferCtxtInner<'tcx> {\n     }\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum DefiningAnchor {\n+    /// `DefId` of the item.\n+    Bind(LocalDefId),\n+    /// When opaque types are not resolved, we `Bubble` up, meaning\n+    /// return the opaque/hidden type pair from query, for caller of query to handle it.\n+    Bubble,\n+    /// Used to catch type mismatch errors when handling opaque types.\n+    Error,\n+}\n+\n pub struct InferCtxt<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n     /// The `DefId` of the item in whose context we are performing inference or typeck.\n     /// It is used to check whether an opaque type use is a defining use.\n     ///\n-    /// If it is `None`, we can't resolve opaque types here and need to bubble up\n+    /// If it is `DefiningAnchor::Bubble`, we can't resolve opaque types here and need to bubble up\n     /// the obligation. This frequently happens for\n     /// short lived InferCtxt within queries. The opaque type obligations are forwarded\n     /// to the outside until the end up in an `InferCtxt` for typeck or borrowck.\n-    pub defining_use_anchor: Option<LocalDefId>,\n+    ///\n+    /// It is default value is `DefiningAnchor::Error`, this way it is easier to catch errors that\n+    /// might come up during inference or typeck.\n+    pub defining_use_anchor: DefiningAnchor,\n \n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n@@ -526,7 +540,7 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n-    defining_use_anchor: Option<LocalDefId>,\n+    defining_use_anchor: DefiningAnchor,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -535,7 +549,11 @@ pub trait TyCtxtInferExt<'tcx> {\n \n impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n     fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder { tcx: self, defining_use_anchor: None, fresh_typeck_results: None }\n+        InferCtxtBuilder {\n+            tcx: self,\n+            defining_use_anchor: DefiningAnchor::Error,\n+            fresh_typeck_results: None,\n+        }\n     }\n }\n \n@@ -545,7 +563,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// Will also change the scope for opaque type defining use checks to the given owner.\n     pub fn with_fresh_in_progress_typeck_results(mut self, table_owner: LocalDefId) -> Self {\n         self.fresh_typeck_results = Some(RefCell::new(ty::TypeckResults::new(table_owner)));\n-        self.with_opaque_type_inference(table_owner)\n+        self.with_opaque_type_inference(DefiningAnchor::Bind(table_owner))\n     }\n \n     /// Whenever the `InferCtxt` should be able to handle defining uses of opaque types,\n@@ -554,8 +572,8 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// It is only meant to be called in two places, for typeck\n     /// (via `with_fresh_in_progress_typeck_results`) and for the inference context used\n     /// in mir borrowck.\n-    pub fn with_opaque_type_inference(mut self, defining_use_anchor: LocalDefId) -> Self {\n-        self.defining_use_anchor = Some(defining_use_anchor);\n+    pub fn with_opaque_type_inference(mut self, defining_use_anchor: DefiningAnchor) -> Self {\n+        self.defining_use_anchor = defining_use_anchor;\n         self\n     }\n "}, {"sha": "7b0ff9552a3a407ff852fa97c15758dc3da9bfa8", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::{InferCtxt, InferOk};\n+use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n use hir::def_id::{DefId, LocalDefId};\n use hir::{HirId, OpaqueTyOrigin};\n@@ -101,44 +101,46 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let process = |a: Ty<'tcx>, b: Ty<'tcx>| match *a.kind() {\n             ty::Opaque(def_id, substs) if def_id.is_local() => {\n                 let def_id = def_id.expect_local();\n-                let origin = if self.defining_use_anchor.is_some() {\n-                    // Check that this is `impl Trait` type is\n-                    // declared by `parent_def_id` -- i.e., one whose\n-                    // value we are inferring.  At present, this is\n-                    // always true during the first phase of\n-                    // type-check, but not always true later on during\n-                    // NLL. Once we support named opaque types more fully,\n-                    // this same scenario will be able to arise during all phases.\n-                    //\n-                    // Here is an example using type alias `impl Trait`\n-                    // that indicates the distinction we are checking for:\n-                    //\n-                    // ```rust\n-                    // mod a {\n-                    //   pub type Foo = impl Iterator;\n-                    //   pub fn make_foo() -> Foo { .. }\n-                    // }\n-                    //\n-                    // mod b {\n-                    //   fn foo() -> a::Foo { a::make_foo() }\n-                    // }\n-                    // ```\n-                    //\n-                    // Here, the return type of `foo` references an\n-                    // `Opaque` indeed, but not one whose value is\n-                    // presently being inferred. You can get into a\n-                    // similar situation with closure return types\n-                    // today:\n-                    //\n-                    // ```rust\n-                    // fn foo() -> impl Iterator { .. }\n-                    // fn bar() {\n-                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n-                    // }\n-                    // ```\n-                    self.opaque_type_origin(def_id, cause.span)?\n-                } else {\n-                    self.opaque_ty_origin_unchecked(def_id, cause.span)\n+                let origin = match self.defining_use_anchor {\n+                    DefiningAnchor::Bind(_) => {\n+                        // Check that this is `impl Trait` type is\n+                        // declared by `parent_def_id` -- i.e., one whose\n+                        // value we are inferring.  At present, this is\n+                        // always true during the first phase of\n+                        // type-check, but not always true later on during\n+                        // NLL. Once we support named opaque types more fully,\n+                        // this same scenario will be able to arise during all phases.\n+                        //\n+                        // Here is an example using type alias `impl Trait`\n+                        // that indicates the distinction we are checking for:\n+                        //\n+                        // ```rust\n+                        // mod a {\n+                        //   pub type Foo = impl Iterator;\n+                        //   pub fn make_foo() -> Foo { .. }\n+                        // }\n+                        //\n+                        // mod b {\n+                        //   fn foo() -> a::Foo { a::make_foo() }\n+                        // }\n+                        // ```\n+                        //\n+                        // Here, the return type of `foo` references an\n+                        // `Opaque` indeed, but not one whose value is\n+                        // presently being inferred. You can get into a\n+                        // similar situation with closure return types\n+                        // today:\n+                        //\n+                        // ```rust\n+                        // fn foo() -> impl Iterator { .. }\n+                        // fn bar() {\n+                        //     let x = || foo(); // returns the Opaque assoc with `foo`\n+                        // }\n+                        // ```\n+                        self.opaque_type_origin(def_id, cause.span)?\n+                    }\n+                    DefiningAnchor::Bubble => self.opaque_ty_origin_unchecked(def_id, cause.span),\n+                    DefiningAnchor::Error => return None,\n                 };\n                 if let ty::Opaque(did2, _) = *b.kind() {\n                     // We could accept this, but there are various ways to handle this situation, and we don't\n@@ -407,7 +409,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[instrument(skip(self), level = \"trace\")]\n     pub fn opaque_type_origin(&self, def_id: LocalDefId, span: Span) -> Option<OpaqueTyOrigin> {\n         let opaque_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-        let parent_def_id = self.defining_use_anchor?;\n+        let parent_def_id = match self.defining_use_anchor {\n+            DefiningAnchor::Bubble | DefiningAnchor::Error => return None,\n+            DefiningAnchor::Bind(bind) => bind,\n+        };\n         let item_kind = &self.tcx.hir().expect_item(def_id).kind;\n \n         let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {"}, {"sha": "c2b2e3199511e403b8a3c39b1532f8ce679ac492", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -3,7 +3,7 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use crate::infer::TyCtxtInferExt;\n+use crate::infer::{DefiningAnchor, TyCtxtInferExt};\n use crate::traits::{\n     FulfillmentContext, ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngine,\n     Unimplemented,\n@@ -30,7 +30,9 @@ pub fn codegen_fulfill_obligation<'tcx>(\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    tcx.infer_ctxt().enter(|infcx| {\n+    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter(|infcx| {\n+        //~^ HACK `Bubble` is required for\n+        // this test to pass: type-alias-impl-trait/assoc-projection-ice.rs\n         let mut selcx = SelectionContext::new(&infcx);\n \n         let obligation_cause = ObligationCause::dummy();\n@@ -69,7 +71,8 @@ pub fn codegen_fulfill_obligation<'tcx>(\n \n         // Opaque types may have gotten their hidden types constrained, but we can ignore them safely\n         // as they will get constrained elsewhere, too.\n-        let _opaque_types = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+        // (ouz-a) This is required for `type-alias-impl-trait/assoc-projection-ice.rs` to pass\n+        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n         debug!(\"Cache miss: {trait_ref:?} => {impl_source:?}\");\n         Ok(&*tcx.arena.alloc(impl_source))"}, {"sha": "9497d5c4528cc9e85eb4b6c842e12c4a01b8f92b", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ItemKind, Node, PathSegment};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n+use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n use rustc_lint::builtin::REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS;\n use rustc_middle::hir::nested_filter;\n@@ -731,52 +731,52 @@ fn check_opaque_meets_bounds<'tcx>(\n     };\n     let param_env = tcx.param_env(defining_use_anchor);\n \n-    tcx.infer_ctxt().with_opaque_type_inference(defining_use_anchor).enter(move |infcx| {\n-        let ocx = ObligationCtxt::new(&infcx);\n-        let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n+    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(defining_use_anchor)).enter(\n+        move |infcx| {\n+            let ocx = ObligationCtxt::new(&infcx);\n+            let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n \n-        let misc_cause = traits::ObligationCause::misc(span, hir_id);\n+            let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n-        match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n-            Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n-            Err(ty_err) => {\n-                tcx.sess.delay_span_bug(\n-                    span,\n-                    &format!(\"could not unify `{hidden_type}` with revealed type:\\n{ty_err}\"),\n-                );\n+            match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n+                Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n+                Err(ty_err) => {\n+                    tcx.sess.delay_span_bug(\n+                        span,\n+                        &format!(\"could not unify `{hidden_type}` with revealed type:\\n{ty_err}\"),\n+                    );\n+                }\n             }\n-        }\n \n-        // Additionally require the hidden type to be well-formed with only the generics of the opaque type.\n-        // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-        // hidden type is well formed even without those bounds.\n-        let predicate =\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_type.into())).to_predicate(tcx);\n-        ocx.register_obligation(Obligation::new(misc_cause, param_env, predicate));\n-\n-        // Check that all obligations are satisfied by the implementation's\n-        // version.\n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            infcx.report_fulfillment_errors(&errors, None, false);\n-        }\n-\n-        match origin {\n-            // Checked when type checking the function containing them.\n-            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n-            // Can have different predicates to their defining use\n-            hir::OpaqueTyOrigin::TyAlias => {\n-                let outlives_environment = OutlivesEnvironment::new(param_env);\n-                infcx.check_region_obligations_and_report_errors(\n-                    defining_use_anchor,\n-                    &outlives_environment,\n-                );\n+            // Additionally require the hidden type to be well-formed with only the generics of the opaque type.\n+            // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+            // hidden type is well formed even without those bounds.\n+            let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_type.into()))\n+                .to_predicate(tcx);\n+            ocx.register_obligation(Obligation::new(misc_cause, param_env, predicate));\n+\n+            // Check that all obligations are satisfied by the implementation's\n+            // version.\n+            let errors = ocx.select_all_or_error();\n+            if !errors.is_empty() {\n+                infcx.report_fulfillment_errors(&errors, None, false);\n             }\n-        }\n-\n-        // Clean up after ourselves\n-        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-    });\n+            match origin {\n+                // Checked when type checking the function containing them.\n+                hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n+                // Can have different predicates to their defining use\n+                hir::OpaqueTyOrigin::TyAlias => {\n+                    let outlives_environment = OutlivesEnvironment::new(param_env);\n+                    infcx.check_region_obligations_and_report_errors(\n+                        defining_use_anchor,\n+                        &outlives_environment,\n+                    );\n+                }\n+            }\n+            // Clean up after ourselves\n+            let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+        },\n+    );\n }\n \n fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {"}, {"sha": "020aa95d0be215067415e1fe6cc59be7a4f9f597", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -1460,6 +1460,7 @@ pub fn check_type_bounds<'tcx>(\n             .map(|e| e.map_bound(|e| *e).transpose_tuple2())\n             .map(|(bound, span)| {\n                 debug!(?bound);\n+                // this is where opaque type is found\n                 let concrete_ty_bound = bound.subst(tcx, rebased_substs);\n                 debug!(\"check_type_bounds: concrete_ty_bound = {:?}\", concrete_ty_bound);\n \n@@ -1481,7 +1482,6 @@ pub fn check_type_bounds<'tcx>(\n             ocx.register_obligations(obligations);\n             ocx.register_obligation(obligation);\n         }\n-\n         // Check that all obligations are satisfied by the implementation's\n         // version.\n         let errors = ocx.select_all_or_error();"}, {"sha": "b05579f216620d7b1635f5bc389d102f8f2add7a", "filename": "src/test/ui/impl-trait/issues/issue-99348-impl-compatibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-99348-impl-compatibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-99348-impl-compatibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-99348-impl-compatibility.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -6,7 +6,7 @@ type Tait = impl Sized;\n \n impl Foo for Concrete {\n     type Item = Concrete;\n-    //~^ mismatched types\n+    //~^ type mismatch resolving\n }\n \n impl Bar for Concrete {"}, {"sha": "f0dceb1b11a5ddbc245e48747f02fffc9c6bc6e5", "filename": "src/test/ui/impl-trait/issues/issue-99348-impl-compatibility.stderr", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-99348-impl-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-99348-impl-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-99348-impl-compatibility.stderr?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -1,15 +1,25 @@\n-error[E0308]: mismatched types\n+error[E0271]: type mismatch resolving `<Concrete as Bar>::Other == Concrete`\n   --> $DIR/issue-99348-impl-compatibility.rs:8:17\n    |\n LL | type Tait = impl Sized;\n-   |             ---------- the expected opaque type\n+   |             ---------- the found opaque type\n ...\n LL |     type Item = Concrete;\n-   |                 ^^^^^^^^ types differ\n+   |                 ^^^^^^^^ type mismatch resolving `<Concrete as Bar>::Other == Concrete`\n    |\n-   = note: expected opaque type `Tait`\n-                   found struct `Concrete`\n+note: expected this to be `Concrete`\n+  --> $DIR/issue-99348-impl-compatibility.rs:13:18\n+   |\n+LL |     type Other = Tait;\n+   |                  ^^^^\n+   = note:   expected struct `Concrete`\n+           found opaque type `Tait`\n+note: required by a bound in `Foo::Item`\n+  --> $DIR/issue-99348-impl-compatibility.rs:17:20\n+   |\n+LL |     type Item: Bar<Other = Self>;\n+   |                    ^^^^^^^^^^^^ required by this bound in `Foo::Item`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "8ff14fb1f304aee283b93b1bf8256a9d90c1ad83", "filename": "src/test/ui/parser/fn-header-semantic-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -27,7 +27,7 @@ fn main() {\n     struct Y;\n     impl X for Y {\n         async fn ft1() {} //~ ERROR functions in traits cannot be declared `async`\n-        //~^ ERROR impl has stricter requirements than trait\n+        //~^ ERROR has an incompatible type for trait\n         unsafe fn ft2() {} // OK.\n         const fn ft3() {} //~ ERROR functions in traits cannot be declared const\n         extern \"C\" fn ft4() {}\n@@ -36,7 +36,7 @@ fn main() {\n         //~| ERROR functions in traits cannot be declared const\n         //~| ERROR functions cannot be both `const` and `async`\n         //~| ERROR cycle detected\n-        //~| ERROR impl has stricter requirements than trait\n+        //~| ERROR has an incompatible type for trait\n     }\n \n     impl Y {"}, {"sha": "bc51ba8b8c5c51971799f77b3dea857c71f7243d", "filename": "src/test/ui/parser/fn-header-semantic-fail.stderr", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -216,23 +216,41 @@ LL | |     }\n LL | | }\n    | |_^\n \n-error[E0276]: impl has stricter requirements than trait\n-  --> $DIR/fn-header-semantic-fail.rs:29:9\n+error[E0053]: method `ft1` has an incompatible type for trait\n+  --> $DIR/fn-header-semantic-fail.rs:29:24\n    |\n-LL |         async fn ft1();\n-   |         --------------- definition of `ft1` from trait\n-...\n LL |         async fn ft1() {}\n-   |         ^^^^^^^^^^^^^^ impl has extra requirement `(): Future`\n+   |                        ^\n+   |                        |\n+   |                        checked the `Output` of this `async fn`, found opaque type\n+   |                        expected `()`, found opaque type\n+   |\n+   = note: while checking the return type of the `async fn`\n+note: type in trait\n+  --> $DIR/fn-header-semantic-fail.rs:17:23\n+   |\n+LL |         async fn ft1();\n+   |                       ^\n+   = note: expected fn pointer `fn()`\n+              found fn pointer `fn() -> impl Future<Output = ()>`\n \n-error[E0276]: impl has stricter requirements than trait\n-  --> $DIR/fn-header-semantic-fail.rs:34:9\n+error[E0053]: method `ft5` has an incompatible type for trait\n+  --> $DIR/fn-header-semantic-fail.rs:34:48\n    |\n-LL |         const async unsafe extern \"C\" fn ft5();\n-   |         --------------------------------------- definition of `ft5` from trait\n-...\n LL |         const async unsafe extern \"C\" fn ft5() {}\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `(): Future`\n+   |                                                ^\n+   |                                                |\n+   |                                                checked the `Output` of this `async fn`, found opaque type\n+   |                                                expected `()`, found opaque type\n+   |\n+   = note: while checking the return type of the `async fn`\n+note: type in trait\n+  --> $DIR/fn-header-semantic-fail.rs:21:47\n+   |\n+LL |         const async unsafe extern \"C\" fn ft5();\n+   |                                               ^\n+   = note: expected fn pointer `unsafe extern \"C\" fn()`\n+              found fn pointer `unsafe extern \"C\" fn() -> impl Future<Output = ()>`\n \n error[E0391]: cycle detected when computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 28:17>::ft5::{opaque#0}`\n   --> $DIR/fn-header-semantic-fail.rs:34:48\n@@ -308,5 +326,5 @@ LL | | }\n \n error: aborting due to 23 previous errors\n \n-Some errors have detailed explanations: E0276, E0379, E0391, E0706.\n-For more information about an error, try `rustc --explain E0276`.\n+Some errors have detailed explanations: E0053, E0379, E0391, E0706.\n+For more information about an error, try `rustc --explain E0053`."}, {"sha": "aaf0f7eaef0dcdd3969dcb3d743d0b4fba8f69f0", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -14,7 +14,7 @@ trait B {\n impl B for A {\n     async fn associated(); //~ ERROR without body\n     //~^ ERROR cannot be declared `async`\n-    //~| ERROR impl has stricter requirements than trait\n+    //~| ERROR has an incompatible type for trait\n }\n \n fn main() {}"}, {"sha": "d3214458eac13cc8f89bedfcf498812c5aad6116", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.stderr", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -44,16 +44,25 @@ LL |     async fn associated();\n    = note: `async` trait functions are not currently supported\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n-error[E0276]: impl has stricter requirements than trait\n-  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:15:5\n+error[E0053]: method `associated` has an incompatible type for trait\n+  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:15:26\n    |\n LL |     async fn associated();\n-   |     ---------------------- definition of `associated` from trait\n-...\n+   |                          ^\n+   |                          |\n+   |                          checked the `Output` of this `async fn`, found opaque type\n+   |                          expected `()`, found opaque type\n+   |\n+   = note: while checking the return type of the `async fn`\n+note: type in trait\n+  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:11:26\n+   |\n LL |     async fn associated();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `(): Future`\n+   |                          ^\n+   = note: expected fn pointer `fn()`\n+              found fn pointer `fn() -> impl Future<Output = ()>`\n \n error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0276, E0706.\n-For more information about an error, try `rustc --explain E0276`.\n+Some errors have detailed explanations: E0053, E0706.\n+For more information about an error, try `rustc --explain E0053`."}, {"sha": "4a11bb5020e6d21aa3a0da8725a843b5b4684f9b", "filename": "src/test/ui/type-alias-impl-trait/issue-53398-cyclic-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53398-cyclic-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53398-cyclic-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53398-cyclic-types.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -3,7 +3,7 @@\n type Foo = impl Fn() -> Foo;\n \n fn foo() -> Foo {\n-//~^ ERROR: overflow evaluating the requirement `fn() -> Foo {foo}: Sized`\n+//~^ ERROR: overflow evaluating the requirement\n     foo\n }\n "}, {"sha": "00c682b21939c81a461f5754cde9ce41d9e56495", "filename": "src/test/ui/type-alias-impl-trait/issue-53398-cyclic-types.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53398-cyclic-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53398-cyclic-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53398-cyclic-types.stderr?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -1,10 +1,8 @@\n-error[E0275]: overflow evaluating the requirement `fn() -> Foo {foo}: Sized`\n+error[E0275]: overflow evaluating the requirement `<fn() -> Foo {foo} as FnOnce<()>>::Output == fn() -> Foo {foo}`\n   --> $DIR/issue-53398-cyclic-types.rs:5:13\n    |\n LL | fn foo() -> Foo {\n    |             ^^^\n-   |\n-   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_53398_cyclic_types`)\n \n error: aborting due to previous error\n "}, {"sha": "472886c9caa23f0ff11101c545c83b6a4b591406", "filename": "src/test/ui/type-alias-impl-trait/issue-57961.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -0,0 +1,18 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type X = impl Sized;\n+\n+trait Foo {\n+    type Bar: Iterator<Item = X>;\n+}\n+\n+impl Foo for () {\n+    type Bar = std::vec::IntoIter<u32>;\n+    //~^ ERROR type mismatch resolving `<std::vec::IntoIter<u32> as Iterator>::Item == X\n+}\n+\n+fn incoherent() {\n+    let f: X = 22_i32;\n+}\n+\n+fn main() {}"}, {"sha": "ed4caf6ce68d6e6cf3e778c88512deda0c0a2037", "filename": "src/test/ui/type-alias-impl-trait/issue-57961.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eecfdfb8a12367cb292a85b6a30981eb35a56379/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr?ref=eecfdfb8a12367cb292a85b6a30981eb35a56379", "patch": "@@ -0,0 +1,20 @@\n+error[E0271]: type mismatch resolving `<std::vec::IntoIter<u32> as Iterator>::Item == X`\n+  --> $DIR/issue-57961.rs:10:16\n+   |\n+LL | type X = impl Sized;\n+   |          ---------- the expected opaque type\n+...\n+LL |     type Bar = std::vec::IntoIter<u32>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found `u32`\n+   |\n+   = note: expected opaque type `X`\n+                     found type `u32`\n+note: required by a bound in `Foo::Bar`\n+  --> $DIR/issue-57961.rs:6:24\n+   |\n+LL |     type Bar: Iterator<Item = X>;\n+   |                        ^^^^^^^^ required by this bound in `Foo::Bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}]}