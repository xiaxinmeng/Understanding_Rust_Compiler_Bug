{"sha": "cb882fa998571e8a7ec1c06bb5d9dd9bc3423629", "node_id": "C_kwDOAAsO6NoAKGNiODgyZmE5OTg1NzFlOGE3ZWMxYzA2YmI1ZDlkZDliYzM0MjM2Mjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-12T10:08:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-12T10:08:45Z"}, "message": "Auto merge of #112543 - GuillaumeGomez:revert-112429, r=lcnr\n\n[rustdoc] Fix infinite loop when retrieving impls for type alias\n\nFixes #112515.\nReverts #112429.\n\nr? `@lcnr`", "tree": {"sha": "134c65ef9c18965844b6e367357b41ad572f5d1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/134c65ef9c18965844b6e367357b41ad572f5d1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb882fa998571e8a7ec1c06bb5d9dd9bc3423629", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb882fa998571e8a7ec1c06bb5d9dd9bc3423629", "html_url": "https://github.com/rust-lang/rust/commit/cb882fa998571e8a7ec1c06bb5d9dd9bc3423629", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb882fa998571e8a7ec1c06bb5d9dd9bc3423629/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd0a3313f7a64cb16533030e49a271db449368c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd0a3313f7a64cb16533030e49a271db449368c3", "html_url": "https://github.com/rust-lang/rust/commit/fd0a3313f7a64cb16533030e49a271db449368c3"}, {"sha": "b93ca0146af3a8adeee286d3d4dbd561e534a8bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b93ca0146af3a8adeee286d3d4dbd561e534a8bf", "html_url": "https://github.com/rust-lang/rust/commit/b93ca0146af3a8adeee286d3d4dbd561e534a8bf"}], "stats": {"total": 245, "additions": 67, "deletions": 178}, "files": [{"sha": "c6f43857887c96e02e71bc25caea546a07a6673d", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb882fa998571e8a7ec1c06bb5d9dd9bc3423629/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb882fa998571e8a7ec1c06bb5d9dd9bc3423629/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=cb882fa998571e8a7ec1c06bb5d9dd9bc3423629", "patch": "@@ -106,7 +106,7 @@ impl<T: ?Sized> *mut T {\n     /// with [`cast_mut`] on `*const T` and may have documentation value if used instead of implicit\n     /// coercion.\n     ///\n-    /// [`cast_mut`]: pointer::cast_mut\n+    /// [`cast_mut`]: #method.cast_mut\n     #[stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n     #[rustc_const_stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n     #[inline(always)]\n@@ -117,7 +117,7 @@ impl<T: ?Sized> *mut T {\n     /// Casts a pointer to its raw bits.\n     ///\n     /// This is equivalent to `as usize`, but is more specific to enhance readability.\n-    /// The inverse method is [`from_bits`](pointer#method.from_bits-1).\n+    /// The inverse method is [`from_bits`](#method.from_bits-1).\n     ///\n     /// In particular, `*p as usize` and `p as usize` will both compile for\n     /// pointers to numeric types but do very different things, so using this\n@@ -153,7 +153,7 @@ impl<T: ?Sized> *mut T {\n     /// Creates a pointer from its raw bits.\n     ///\n     /// This is equivalent to `as *mut T`, but is more specific to enhance readability.\n-    /// The inverse method is [`to_bits`](pointer#method.to_bits-1).\n+    /// The inverse method is [`to_bits`](#method.to_bits-1).\n     ///\n     /// # Examples\n     ///\n@@ -303,7 +303,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// For the mutable counterpart see [`as_mut`].\n     ///\n-    /// [`as_uninit_ref`]: pointer#method.as_uninit_ref-1\n+    /// [`as_uninit_ref`]: #method.as_uninit_ref-1\n     /// [`as_mut`]: #method.as_mut\n     ///\n     /// # Safety\n@@ -369,7 +369,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// For the mutable counterpart see [`as_uninit_mut`].\n     ///\n-    /// [`as_ref`]: pointer#method.as_ref-1\n+    /// [`as_ref`]: #method.as_ref-1\n     /// [`as_uninit_mut`]: #method.as_uninit_mut\n     ///\n     /// # Safety\n@@ -624,7 +624,7 @@ impl<T: ?Sized> *mut T {\n     /// For the shared counterpart see [`as_ref`].\n     ///\n     /// [`as_uninit_mut`]: #method.as_uninit_mut\n-    /// [`as_ref`]: pointer#method.as_ref-1\n+    /// [`as_ref`]: #method.as_ref-1\n     ///\n     /// # Safety\n     ///\n@@ -689,7 +689,7 @@ impl<T: ?Sized> *mut T {\n     /// For the shared counterpart see [`as_uninit_ref`].\n     ///\n     /// [`as_mut`]: #method.as_mut\n-    /// [`as_uninit_ref`]: pointer#method.as_uninit_ref-1\n+    /// [`as_uninit_ref`]: #method.as_uninit_ref-1\n     ///\n     /// # Safety\n     ///\n@@ -779,7 +779,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This function is the inverse of [`offset`].\n     ///\n-    /// [`offset`]: pointer#method.offset-1\n+    /// [`offset`]: #method.offset-1\n     ///\n     /// # Safety\n     ///\n@@ -2051,7 +2051,7 @@ impl<T> *mut [T] {\n     ///\n     /// For the mutable counterpart see [`as_uninit_slice_mut`].\n     ///\n-    /// [`as_ref`]: pointer#method.as_ref-1\n+    /// [`as_ref`]: #method.as_ref-1\n     /// [`as_uninit_slice_mut`]: #method.as_uninit_slice_mut\n     ///\n     /// # Safety"}, {"sha": "f205ff15ec3d030ae7d3d8bc334378b5bb13881a", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 12, "deletions": 78, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/cb882fa998571e8a7ec1c06bb5d9dd9bc3423629/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb882fa998571e8a7ec1c06bb5d9dd9bc3423629/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=cb882fa998571e8a7ec1c06bb5d9dd9bc3423629", "patch": "@@ -53,15 +53,12 @@ use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_hir::Mutability;\n-use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::{ParamEnv, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::{\n     symbol::{sym, Symbol},\n     BytePos, FileName, RealFileName,\n };\n-use rustc_trait_selection::traits::ObligationCtxt;\n use serde::ser::{SerializeMap, SerializeSeq};\n use serde::{Serialize, Serializer};\n \n@@ -1115,76 +1112,28 @@ fn render_assoc_items<'a, 'cx: 'a>(\n     containing_item: &'a clean::Item,\n     it: DefId,\n     what: AssocItemRender<'a>,\n-    aliased_type: Option<DefId>,\n ) -> impl fmt::Display + 'a + Captures<'cx> {\n     let mut derefs = DefIdSet::default();\n     derefs.insert(it);\n     display_fn(move |f| {\n-        render_assoc_items_inner(f, cx, containing_item, it, what, &mut derefs, aliased_type);\n+        render_assoc_items_inner(f, cx, containing_item, it, what, &mut derefs);\n         Ok(())\n     })\n }\n \n-/// Check whether `impl_def_id` may apply to *some instantiation* of `item_def_id`.\n-fn is_valid_impl_for(tcx: TyCtxt<'_>, item_def_id: DefId, impl_def_id: DefId) -> bool {\n-    let infcx = tcx.infer_ctxt().intercrate(true).build();\n-    let ocx = ObligationCtxt::new(&infcx);\n-    let param_env = ParamEnv::empty();\n-\n-    let alias_substs = infcx.fresh_substs_for_item(rustc_span::DUMMY_SP, item_def_id);\n-    let alias_ty = tcx.type_of(item_def_id).subst(tcx, alias_substs);\n-    let alias_bounds = tcx.predicates_of(item_def_id).instantiate(tcx, alias_substs);\n-\n-    let impl_substs = infcx.fresh_substs_for_item(rustc_span::DUMMY_SP, impl_def_id);\n-    let impl_self_ty = tcx.type_of(impl_def_id).subst(tcx, impl_substs);\n-    let impl_bounds = tcx.predicates_of(impl_def_id).instantiate(tcx, impl_substs);\n-\n-    if ocx.eq(&ObligationCause::dummy(), param_env, impl_self_ty, alias_ty).is_err() {\n-        return false;\n-    }\n-    ocx.register_obligations(\n-        alias_bounds\n-            .iter()\n-            .chain(impl_bounds)\n-            .map(|(p, _)| Obligation::new(tcx, ObligationCause::dummy(), param_env, p)),\n-    );\n-\n-    let errors = ocx.select_where_possible();\n-    errors.is_empty()\n-}\n-\n-// If `aliased_type` is `Some`, it means `it` is a type alias and `aliased_type` is the \"actual\"\n-// type aliased behind `it`. It is used to check whether or not the implementation of the aliased\n-// type can be displayed on the alias doc page.\n fn render_assoc_items_inner(\n     mut w: &mut dyn fmt::Write,\n     cx: &mut Context<'_>,\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n     derefs: &mut DefIdSet,\n-    aliased_type: Option<DefId>,\n ) {\n     info!(\"Documenting associated items of {:?}\", containing_item.name);\n     let shared = Rc::clone(&cx.shared);\n     let cache = &shared.cache;\n-    let empty = Vec::new();\n-    let v = match cache.impls.get(&it) {\n-        Some(v) => v,\n-        None => &empty,\n-    };\n-    let v2 = match aliased_type {\n-        Some(aliased_type) => cache.impls.get(&aliased_type).unwrap_or(&empty),\n-        None => &empty,\n-    };\n-    if v.is_empty() && v2.is_empty() {\n-        return;\n-    }\n-    let mut saw_impls = FxHashSet::default();\n-    let (non_trait, traits): (Vec<_>, _) =\n-        v.iter().chain(v2).partition(|i| i.inner_impl().trait_.is_none());\n-    let tcx = cx.tcx();\n-    let is_alias = aliased_type.is_some();\n+    let Some(v) = cache.impls.get(&it) else { return };\n+    let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n     if !non_trait.is_empty() {\n         let mut tmp_buf = Buffer::html();\n         let (render_mode, id, class_html) = match what {\n@@ -1216,12 +1165,6 @@ fn render_assoc_items_inner(\n         };\n         let mut impls_buf = Buffer::html();\n         for i in &non_trait {\n-            if !saw_impls.insert(i.def_id()) {\n-                continue;\n-            }\n-            if is_alias && !is_valid_impl_for(tcx, it, i.def_id()) {\n-                continue;\n-            }\n             render_impl(\n                 &mut impls_buf,\n                 cx,\n@@ -1250,14 +1193,9 @@ fn render_assoc_items_inner(\n     if !traits.is_empty() {\n         let deref_impl =\n             traits.iter().find(|t| t.trait_did() == cx.tcx().lang_items().deref_trait());\n-        if let Some(impl_) = deref_impl &&\n-            (!is_alias || is_valid_impl_for(tcx, it, impl_.def_id()))\n-        {\n+        if let Some(impl_) = deref_impl {\n             let has_deref_mut =\n-                traits.iter().any(|t| {\n-                    t.trait_did() == cx.tcx().lang_items().deref_mut_trait() &&\n-                    (!is_alias || is_valid_impl_for(tcx, it, t.def_id()))\n-                });\n+                traits.iter().any(|t| t.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n             render_deref_methods(&mut w, cx, impl_, containing_item, has_deref_mut, derefs);\n         }\n \n@@ -1267,14 +1205,10 @@ fn render_assoc_items_inner(\n             return;\n         }\n \n-        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) = traits\n-            .into_iter()\n-            .filter(|t| saw_impls.insert(t.def_id()))\n-            .partition(|t| t.inner_impl().kind.is_auto());\n-        let (blanket_impl, concrete): (Vec<&Impl>, _) = concrete\n-            .into_iter()\n-            .filter(|t| !is_alias || is_valid_impl_for(tcx, it, t.def_id()))\n-            .partition(|t| t.inner_impl().kind.is_blanket());\n+        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+            traits.into_iter().partition(|t| t.inner_impl().kind.is_auto());\n+        let (blanket_impl, concrete): (Vec<&Impl>, _) =\n+            concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n \n         render_all_impls(w, cx, containing_item, &concrete, &synthetic, &blanket_impl);\n     }\n@@ -1313,10 +1247,10 @@ fn render_deref_methods(\n                 return;\n             }\n         }\n-        render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs, None);\n+        render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n     } else if let Some(prim) = target.primitive_type() {\n         if let Some(&did) = cache.primitive_locations.get(&prim) {\n-            render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs, None);\n+            render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n         }\n     }\n }"}, {"sha": "383e3c170881a20ca9301dd867acf246b9ff25a4", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cb882fa998571e8a7ec1c06bb5d9dd9bc3423629/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb882fa998571e8a7ec1c06bb5d9dd9bc3423629/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=cb882fa998571e8a7ec1c06bb5d9dd9bc3423629", "patch": "@@ -129,7 +129,7 @@ macro_rules! item_template_methods {\n             display_fn(move |f| {\n                 let (item, mut cx) = self.item_and_mut_cx();\n                 let def_id = item.item_id.expect_def_id();\n-                let v = render_assoc_items(*cx, item, def_id, AssocItemRender::All, None);\n+                let v = render_assoc_items(*cx, item, def_id, AssocItemRender::All);\n                 write!(f, \"{v}\")\n             })\n         }\n@@ -953,11 +953,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    write!(\n-        w,\n-        \"{}\",\n-        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n-    );\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All));\n \n     let cloned_shared = Rc::clone(&cx.shared);\n     let cache = &cloned_shared.cache;\n@@ -1189,12 +1185,8 @@ fn item_trait_alias(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    write!(\n-        w,\n-        \"{}\",\n-        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n-    )\n-    .unwrap();\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n+        .unwrap();\n }\n \n fn item_opaque_ty(\n@@ -1222,12 +1214,8 @@ fn item_opaque_ty(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    write!(\n-        w,\n-        \"{}\",\n-        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n-    )\n-    .unwrap();\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n+        .unwrap();\n }\n \n fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n@@ -1251,11 +1239,11 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     let def_id = it.item_id.expect_def_id();\n-    write!(\n-        w,\n-        \"{}\",\n-        render_assoc_items(cx, it, def_id, AssocItemRender::All, t.type_.def_id(&cx.cache()))\n-    );\n+    // Render any items associated directly to this alias, as otherwise they\n+    // won't be visible anywhere in the docs. It would be nice to also show\n+    // associated items from the aliased type (see discussion in #32077), but\n+    // we need #14072 to make sense of the generics.\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1494,7 +1482,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n         write!(w, \"</div>\");\n     }\n     let def_id = it.item_id.expect_def_id();\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None));\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1537,7 +1525,7 @@ fn item_primitive(w: &mut impl fmt::Write, cx: &mut Context<'_>, it: &clean::Ite\n     let def_id = it.item_id.expect_def_id();\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2)).unwrap();\n     if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n-        write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None)).unwrap();\n+        write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All)).unwrap();\n     } else {\n         // We handle the \"reference\" primitive type on its own because we only want to list\n         // implementations on generic types.\n@@ -1642,7 +1630,7 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n         }\n     }\n     let def_id = it.item_id.expect_def_id();\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None));\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1677,12 +1665,8 @@ fn item_foreign_type(w: &mut impl fmt::Write, cx: &mut Context<'_>, it: &clean::\n     });\n \n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2)).unwrap();\n-    write!(\n-        w,\n-        \"{}\",\n-        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n-    )\n-    .unwrap();\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n+        .unwrap();\n }\n \n fn item_keyword(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {"}, {"sha": "161188ee5762f9b4442e23a2f71d47c5c21e291d", "filename": "tests/rustdoc/issue-112515-impl-ty-alias.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cb882fa998571e8a7ec1c06bb5d9dd9bc3423629/tests%2Frustdoc%2Fissue-112515-impl-ty-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb882fa998571e8a7ec1c06bb5d9dd9bc3423629/tests%2Frustdoc%2Fissue-112515-impl-ty-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-112515-impl-ty-alias.rs?ref=cb882fa998571e8a7ec1c06bb5d9dd9bc3423629", "patch": "@@ -0,0 +1,30 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/112515>.\n+// It's to ensure that this code doesn't have infinite loop in rustdoc when\n+// trying to retrive type alias implementations.\n+\n+// ignore-tidy-linelength\n+\n+pub type Boom = S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<S<u64, u8>, ()>, ()>, ()>, u8>, ()>, u8>, ()>, u8>, u8>, ()>, ()>, ()>, u8>, u8>, u8>, ()>, ()>, u8>, ()>, ()>, ()>, u8>, u8>, ()>, ()>, ()>, ()>, ()>, u8>, ()>, ()>, u8>, ()>, ()>, ()>, u8>, ()>, ()>, u8>, u8>, u8>, u8>, ()>, u8>, ()>, ()>, ()>, ()>, ()>, ()>, ()>, ()>, ()>, ()>, ()>, ()>, ()>, ()>, ()>, ()>, ()>, ()>, ()>;\n+pub struct S<T, U>(T, U);\n+\n+pub trait A {}\n+\n+pub trait B<T> {\n+    type P;\n+}\n+\n+impl A for u64 {}\n+\n+impl<T, U> A for S<T, U> {}\n+\n+impl<T> B<u8> for S<T, ()>\n+where\n+    T: B<u8>,\n+    <T as B<u8>>::P: A,\n+{\n+    type P = ();\n+}\n+\n+impl<T: A, U, V> B<T> for S<U, V> {\n+    type P = ();\n+}"}, {"sha": "555d0579bee79b174570baee4c317f4004f859e4", "filename": "tests/rustdoc/issue-32077-type-alias-impls.rs", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fd0a3313f7a64cb16533030e49a271db449368c3/tests%2Frustdoc%2Fissue-32077-type-alias-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd0a3313f7a64cb16533030e49a271db449368c3/tests%2Frustdoc%2Fissue-32077-type-alias-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-32077-type-alias-impls.rs?ref=fd0a3313f7a64cb16533030e49a271db449368c3", "patch": "@@ -1,59 +0,0 @@\n-// Regression test for <https://github.com/rust-lang/rust/issues/32077>.\n-\n-#![crate_name = \"foo\"]\n-\n-pub struct GenericStruct<T>(T);\n-\n-impl<T> GenericStruct<T> {\n-    pub fn on_gen(arg: T) {}\n-}\n-\n-impl GenericStruct<u32> {\n-    pub fn on_u32(arg: u32) {}\n-}\n-\n-pub trait Foo {}\n-pub trait Bar {}\n-\n-impl<T> Foo for GenericStruct<T> {}\n-impl Bar for GenericStruct<u32> {}\n-\n-// @has 'foo/type.TypedefStruct.html'\n-// We check that we have the implementation of the type alias itself.\n-// @has - '//*[@id=\"impl-TypedefStruct\"]/h3' 'impl TypedefStruct'\n-// @has - '//*[@id=\"method.on_alias\"]/h4' 'pub fn on_alias()'\n-// @has - '//*[@id=\"impl-GenericStruct%3CT%3E\"]/h3' 'impl<T> GenericStruct<T>'\n-// @has - '//*[@id=\"method.on_gen\"]/h4' 'pub fn on_gen(arg: T)'\n-// @has - '//*[@id=\"impl-Foo-for-GenericStruct%3CT%3E\"]/h3' 'impl<T> Foo for GenericStruct<T>'\n-// This trait implementation doesn't match the type alias parameters so shouldn't appear in docs.\n-// @!has - '//h3' 'impl Bar for GenericStruct<u32> {}'\n-// Same goes for the `Deref` impl.\n-// @!has - '//h2' 'Methods from Deref<Target = u32>'\n-pub type TypedefStruct = GenericStruct<u8>;\n-\n-impl TypedefStruct {\n-    pub fn on_alias() {}\n-}\n-\n-impl std::ops::Deref for GenericStruct<u32> {\n-    type Target = u32;\n-\n-    fn deref(&self) -> &Self::Target {\n-        &self.0\n-    }\n-}\n-\n-pub struct Wrap<T>(GenericStruct<T>);\n-\n-// @has 'foo/type.Alias.html'\n-// @has - '//h2' 'Methods from Deref<Target = u32>'\n-// @has - '//*[@id=\"impl-Deref-for-Wrap%3CT%3E\"]/h3' 'impl<T> Deref for Wrap<T>'\n-pub type Alias = Wrap<u32>;\n-\n-impl<T> std::ops::Deref for Wrap<T> {\n-    type Target = GenericStruct<T>;\n-\n-    fn deref(&self) -> &Self::Target {\n-        &self.0\n-    }\n-}"}]}