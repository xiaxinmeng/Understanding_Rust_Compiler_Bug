{"sha": "15d6325747d9e37b5e8f19718eada0d5307fdef2", "node_id": "C_kwDOAAsO6NoAKDE1ZDYzMjU3NDdkOWUzN2I1ZThmMTk3MThlYWRhMGQ1MzA3ZmRlZjI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-05T15:33:58Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-01-28T09:55:26Z"}, "message": "Remove `HirId -> LocalDefId` map from HIR.", "tree": {"sha": "4f9f440116faf5cc07b04518a2195cb6b917cc26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f9f440116faf5cc07b04518a2195cb6b917cc26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15d6325747d9e37b5e8f19718eada0d5307fdef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15d6325747d9e37b5e8f19718eada0d5307fdef2", "html_url": "https://github.com/rust-lang/rust/commit/15d6325747d9e37b5e8f19718eada0d5307fdef2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15d6325747d9e37b5e8f19718eada0d5307fdef2/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3175d03d3b07eb7a16455477117796ff76b8e691", "url": "https://api.github.com/repos/rust-lang/rust/commits/3175d03d3b07eb7a16455477117796ff76b8e691", "html_url": "https://github.com/rust-lang/rust/commit/3175d03d3b07eb7a16455477117796ff76b8e691"}], "stats": {"total": 703, "additions": 321, "deletions": 382}, "files": [{"sha": "2865082bd7a47c5322019389fa660118b1a99cc9", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -67,7 +67,6 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             current_hir_id_owner: hir::CRATE_OWNER_ID,\n             item_local_id_counter: hir::ItemLocalId::new(0),\n             node_id_to_local_id: Default::default(),\n-            local_id_to_def_id: SortedMap::new(),\n             trait_map: Default::default(),\n \n             // Lowering state."}, {"sha": "a04a259529310959009d81dec2ca644f71548d31", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -119,7 +119,6 @@ struct LoweringContext<'a, 'hir> {\n \n     current_hir_id_owner: hir::OwnerId,\n     item_local_id_counter: hir::ItemLocalId,\n-    local_id_to_def_id: SortedMap<ItemLocalId, LocalDefId>,\n     trait_map: FxHashMap<ItemLocalId, Box<[TraitCandidate]>>,\n \n     impl_trait_defs: Vec<hir::GenericParam<'hir>>,\n@@ -567,7 +566,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let current_attrs = std::mem::take(&mut self.attrs);\n         let current_bodies = std::mem::take(&mut self.bodies);\n         let current_node_ids = std::mem::take(&mut self.node_id_to_local_id);\n-        let current_id_to_def_id = std::mem::take(&mut self.local_id_to_def_id);\n         let current_trait_map = std::mem::take(&mut self.trait_map);\n         let current_owner =\n             std::mem::replace(&mut self.current_hir_id_owner, hir::OwnerId { def_id });\n@@ -594,7 +592,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.attrs = current_attrs;\n         self.bodies = current_bodies;\n         self.node_id_to_local_id = current_node_ids;\n-        self.local_id_to_def_id = current_id_to_def_id;\n         self.trait_map = current_trait_map;\n         self.current_hir_id_owner = current_owner;\n         self.item_local_id_counter = current_local_counter;\n@@ -629,7 +626,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn make_owner_info(&mut self, node: hir::OwnerNode<'hir>) -> &'hir hir::OwnerInfo<'hir> {\n         let attrs = std::mem::take(&mut self.attrs);\n         let mut bodies = std::mem::take(&mut self.bodies);\n-        let local_id_to_def_id = std::mem::take(&mut self.local_id_to_def_id);\n         let trait_map = std::mem::take(&mut self.trait_map);\n \n         #[cfg(debug_assertions)]\n@@ -645,13 +641,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let (hash_including_bodies, hash_without_bodies) = self.hash_owner(node, &bodies);\n         let (nodes, parenting) =\n             index::index_hir(self.tcx.sess, &*self.tcx.definitions_untracked(), node, &bodies);\n-        let nodes = hir::OwnerNodes {\n-            hash_including_bodies,\n-            hash_without_bodies,\n-            nodes,\n-            bodies,\n-            local_id_to_def_id,\n-        };\n+        let nodes = hir::OwnerNodes { hash_including_bodies, hash_without_bodies, nodes, bodies };\n         let attrs = {\n             let hash = self.tcx.with_stable_hashing_context(|mut hcx| {\n                 let mut stable_hasher = StableHasher::new();\n@@ -710,7 +700,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 assert_ne!(local_id, hir::ItemLocalId::new(0));\n                 if let Some(def_id) = self.opt_local_def_id(ast_node_id) {\n                     self.children.push((def_id, hir::MaybeOwner::NonOwner(hir_id)));\n-                    self.local_id_to_def_id.insert(local_id, def_id);\n                 }\n \n                 if let Some(traits) = self.resolver.trait_map.remove(&ast_node_id) {"}, {"sha": "4696a4bd9ab63aeab10c4291c451fc93d1eddce4", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -831,8 +831,6 @@ pub struct OwnerNodes<'tcx> {\n     pub nodes: IndexVec<ItemLocalId, Option<ParentedNode<'tcx>>>,\n     /// Content of local bodies.\n     pub bodies: SortedMap<ItemLocalId, &'tcx Body<'tcx>>,\n-    /// Non-owning definitions contained in this owner.\n-    pub local_id_to_def_id: SortedMap<ItemLocalId, LocalDefId>,\n }\n \n impl<'tcx> OwnerNodes<'tcx> {\n@@ -862,7 +860,6 @@ impl fmt::Debug for OwnerNodes<'_> {\n                     .collect::<Vec<_>>(),\n             )\n             .field(\"bodies\", &self.bodies)\n-            .field(\"local_id_to_def_id\", &self.local_id_to_def_id)\n             .field(\"hash_without_bodies\", &self.hash_without_bodies)\n             .field(\"hash_including_bodies\", &self.hash_including_bodies)\n             .finish()"}, {"sha": "85d0e02d0b6834004ca51eacdd1bf62093e600e7", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -100,13 +100,8 @@ impl<'tcx, HirCtx: crate::HashStableContext> HashStable<HirCtx> for OwnerNodes<'\n         // `local_id_to_def_id` is also ignored because is dependent on the body, then just hashing\n         // the body satisfies the condition of two nodes being different have different\n         // `hash_stable` results.\n-        let OwnerNodes {\n-            hash_including_bodies,\n-            hash_without_bodies: _,\n-            nodes: _,\n-            bodies: _,\n-            local_id_to_def_id: _,\n-        } = *self;\n+        let OwnerNodes { hash_including_bodies, hash_without_bodies: _, nodes: _, bodies: _ } =\n+            *self;\n         hash_including_bodies.hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "6f4ebc987e6a97ee0951550e5c894f76a68f8f41", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -665,7 +665,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n         DefKind::GlobalAsm => {\n             let it = tcx.hir().item(id);\n             let hir::ItemKind::GlobalAsm(asm) = it.kind else { span_bug!(it.span, \"DefKind::GlobalAsm but got {:#?}\", it) };\n-            InlineAsmCtxt::new_global_asm(tcx).check_asm(asm, id.hir_id());\n+            InlineAsmCtxt::new_global_asm(tcx).check_asm(asm, id.owner_id.def_id);\n         }\n         _ => {}\n     }"}, {"sha": "122b6ead8e9d7f8432a6078cf2b58a318b63db93", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -3,6 +3,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_middle::ty::{self, Article, FloatTy, IntTy, Ty, TyCtxt, TypeVisitable, UintTy};\n use rustc_session::lint;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::{Symbol, DUMMY_SP};\n use rustc_target::asm::{InlineAsmReg, InlineAsmRegClass, InlineAsmRegOrRegClass, InlineAsmType};\n \n@@ -253,10 +254,8 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n         Some(asm_ty)\n     }\n \n-    pub fn check_asm(&self, asm: &hir::InlineAsm<'tcx>, enclosing_id: hir::HirId) {\n-        let hir = self.tcx.hir();\n-        let enclosing_def_id = hir.local_def_id(enclosing_id).to_def_id();\n-        let target_features = self.tcx.asm_target_features(enclosing_def_id);\n+    pub fn check_asm(&self, asm: &hir::InlineAsm<'tcx>, enclosing_id: LocalDefId) {\n+        let target_features = self.tcx.asm_target_features(enclosing_id.to_def_id());\n         let Some(asm_arch) = self.tcx.sess.asm_arch else {\n             self.tcx.sess.delay_span_bug(DUMMY_SP, \"target architecture does not support asm\");\n             return;"}, {"sha": "e15b7c897302458692029128b25b579b6653b8e6", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -391,7 +391,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                         gather_gat_bounds(\n                             tcx,\n                             param_env,\n-                            item_def_id.def_id,\n+                            item_def_id,\n                             sig.inputs_and_output,\n                             // We also assume that all of the function signature's parameter types\n                             // are well formed.\n@@ -413,7 +413,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                         gather_gat_bounds(\n                             tcx,\n                             param_env,\n-                            item_def_id.def_id,\n+                            item_def_id,\n                             tcx.explicit_item_bounds(item_def_id).to_vec(),\n                             &FxIndexSet::default(),\n                             gat_def_id.def_id,\n@@ -563,7 +563,7 @@ fn augment_param_env<'tcx>(\n fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    item_def_id: LocalDefId,\n+    item_def_id: hir::OwnerId,\n     to_check: T,\n     wf_tys: &FxIndexSet<Ty<'tcx>>,\n     gat_def_id: LocalDefId,\n@@ -596,7 +596,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n         // reflected in a where clause on the GAT itself.\n         for (ty, ty_idx) in &types {\n             // In our example, requires that `Self: 'a`\n-            if ty_known_to_outlive(tcx, item_def_id, param_env, &wf_tys, *ty, *region_a) {\n+            if ty_known_to_outlive(tcx, item_def_id.def_id, param_env, &wf_tys, *ty, *region_a) {\n                 debug!(?ty_idx, ?region_a_idx);\n                 debug!(\"required clause: {ty} must outlive {region_a}\");\n                 // Translate into the generic parameters of the GAT. In\n@@ -634,7 +634,14 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n             if ty::ReStatic == **region_b || region_a == region_b {\n                 continue;\n             }\n-            if region_known_to_outlive(tcx, item_def_id, param_env, &wf_tys, *region_a, *region_b) {\n+            if region_known_to_outlive(\n+                tcx,\n+                item_def_id.def_id,\n+                param_env,\n+                &wf_tys,\n+                *region_a,\n+                *region_b,\n+            ) {\n                 debug!(?region_a_idx, ?region_b_idx);\n                 debug!(\"required clause: {region_a} must outlive {region_b}\");\n                 // Translate into the generic parameters of the GAT."}, {"sha": "3c67722b637bfa93aa9c33d5c0a3ea1955c2dbf5", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -1264,14 +1264,21 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n                 match self.tcx.hir().get(fn_id) {\n-                    Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n+                    Node::Item(hir::Item { owner_id, kind: hir::ItemKind::Fn(..), .. })\n                     | Node::TraitItem(hir::TraitItem {\n-                        kind: hir::TraitItemKind::Fn(..), ..\n+                        owner_id,\n+                        kind: hir::TraitItemKind::Fn(..),\n+                        ..\n                     })\n-                    | Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. })\n-                    | Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => {\n-                        let scope = self.tcx.hir().local_def_id(fn_id);\n-                        def = Region::Free(scope.to_def_id(), def.id().unwrap());\n+                    | Node::ImplItem(hir::ImplItem {\n+                        owner_id,\n+                        kind: hir::ImplItemKind::Fn(..),\n+                        ..\n+                    }) => {\n+                        def = Region::Free(owner_id.to_def_id(), def.id().unwrap());\n+                    }\n+                    Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(closure), .. }) => {\n+                        def = Region::Free(closure.def_id.to_def_id(), def.id().unwrap());\n                     }\n                     _ => {}\n                 }\n@@ -1658,10 +1665,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// \"Constrained\" basically means that it appears in any type but\n /// not amongst the inputs to a projection. In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n-fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<LocalDefId>> {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let decl = tcx.hir().fn_decl_by_hir_id(hir_id)?;\n-    let generics = tcx.hir().get_generics(def_id)?;\n+fn is_late_bound_map(\n+    tcx: TyCtxt<'_>,\n+    owner_id: hir::OwnerId,\n+) -> Option<&FxIndexSet<hir::ItemLocalId>> {\n+    let decl = tcx.hir().fn_decl_by_hir_id(owner_id.into())?;\n+    let generics = tcx.hir().get_generics(owner_id.def_id)?;\n \n     let mut late_bound = FxIndexSet::default();\n \n@@ -1695,24 +1704,22 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n             hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => continue,\n         }\n \n-        let param_def_id = tcx.hir().local_def_id(param.hir_id);\n-\n         // appears in the where clauses? early-bound.\n-        if appears_in_where_clause.regions.contains(&param_def_id) {\n+        if appears_in_where_clause.regions.contains(&param.def_id) {\n             continue;\n         }\n \n         // does not appear in the inputs, but appears in the return type? early-bound.\n-        if !constrained_by_input.regions.contains(&param_def_id)\n-            && appears_in_output.regions.contains(&param_def_id)\n+        if !constrained_by_input.regions.contains(&param.def_id)\n+            && appears_in_output.regions.contains(&param.def_id)\n         {\n             continue;\n         }\n \n-        debug!(\"lifetime {:?} with id {:?} is late-bound\", param.name.ident(), param.hir_id);\n+        debug!(\"lifetime {:?} with id {:?} is late-bound\", param.name.ident(), param.def_id);\n \n-        let inserted = late_bound.insert(param_def_id);\n-        assert!(inserted, \"visited lifetime {:?} twice\", param.hir_id);\n+        let inserted = late_bound.insert(param.hir_id.local_id);\n+        assert!(inserted, \"visited lifetime {:?} twice\", param.def_id);\n     }\n \n     debug!(?late_bound);"}, {"sha": "d0d67ae9257c5ddcb959b28ee5f0e752c6fccc01", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -280,7 +280,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n             }\n \n             let hir::GenericParamKind::Lifetime { .. } = duplicate.kind else { continue };\n-            let dup_def = tcx.hir().local_def_id(duplicate.hir_id).to_def_id();\n+            let dup_def = duplicate.def_id.to_def_id();\n \n             let Some(dup_index) = generics.param_def_id_to_index(tcx, dup_def) else { bug!() };\n "}, {"sha": "e7b0846e10352b1093b1d7efdd2174629513267e", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -54,15 +54,14 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             // ty which is a fully resolved projection.\n             // For the code example above, this would mean converting Self::Assoc<3>\n             // into a ty::Alias(ty::Projection, <Self as Foo>::Assoc<3>)\n-            let item_hir_id = tcx\n+            let item_def_id = tcx\n                 .hir()\n-                .parent_iter(hir_id)\n-                .filter(|(_, node)| matches!(node, Node::Item(_)))\n-                .map(|(id, _)| id)\n-                .next()\n-                .unwrap();\n-            let item_did = tcx.hir().local_def_id(item_hir_id).to_def_id();\n-            let item_ctxt = &ItemCtxt::new(tcx, item_did) as &dyn crate::astconv::AstConv<'_>;\n+                .parent_owner_iter(hir_id)\n+                .find(|(_, node)| matches!(node, OwnerNode::Item(_)))\n+                .unwrap()\n+                .0\n+                .to_def_id();\n+            let item_ctxt = &ItemCtxt::new(tcx, item_def_id) as &dyn crate::astconv::AstConv<'_>;\n             let ty = item_ctxt.ast_ty_to_ty(hir_ty);\n \n             // Iterate through the generics of the projection to find the one that corresponds to"}, {"sha": "88fb26535868603907dfdd4ec89c8678f301c024", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -186,6 +186,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         prior_arm: Option<(Option<hir::HirId>, Ty<'tcx>, Span)>,\n     ) {\n         let hir = self.tcx.hir();\n+\n         // First, check that we're actually in the tail of a function.\n         let Some(body_id) = hir.maybe_body_owned_by(self.body_id) else { return; };\n         let body = hir.body(body_id);"}, {"sha": "1c70c1b71e7639315f741329413e96be905b73b3", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -130,7 +130,12 @@ pub(super) fn check_fn<'a, 'tcx>(\n     let gen_ty = if let (Some(_), Some(gen_kind)) = (can_be_generator, body.generator_kind) {\n         let interior = fcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::MiscVariable, span });\n-        fcx.deferred_generator_interiors.borrow_mut().push((fn_id, body.id(), interior, gen_kind));\n+        fcx.deferred_generator_interiors.borrow_mut().push((\n+            fn_def_id,\n+            body.id(),\n+            interior,\n+            gen_kind,\n+        ));\n \n         let (resume_ty, yield_ty) = fcx.resume_yield_tys.unwrap();\n         Some(GeneratorTypes {\n@@ -167,12 +172,12 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n     if let Some(panic_impl_did) = tcx.lang_items().panic_impl()\n-        && panic_impl_did == hir.local_def_id(fn_id).to_def_id()\n+        && panic_impl_did == fn_def_id.to_def_id()\n     {\n         check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n     }\n \n-    if let Some(lang_start_defid) = tcx.lang_items().start_fn() && lang_start_defid == hir.local_def_id(fn_id).to_def_id() {\n+    if let Some(lang_start_defid) = tcx.lang_items().start_fn() && lang_start_defid == fn_def_id.to_def_id() {\n         check_lang_start_fn(tcx, fn_sig, decl, fn_def_id);\n     }\n "}, {"sha": "a355a54d6959abb5570144e9c40b53f2e973ce3f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -549,8 +549,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let generators = std::mem::take(&mut *self.deferred_generator_interiors.borrow_mut());\n         debug!(?generators);\n \n-        for &(expr_hir_id, body_id, interior, _) in generators.iter() {\n-            let expr_def_id = self.tcx.hir().local_def_id(expr_hir_id);\n+        for &(expr_def_id, body_id, interior, _) in generators.iter() {\n             debug!(?expr_def_id);\n \n             // Create the `GeneratorWitness` type that we will unify with `interior`."}, {"sha": "47ef106e750321470003d3b25103cbcb25b98d9c", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n             InlineAsmCtxt::new_in_fn(self.tcx, self.param_env, get_operand_ty)\n-                .check_asm(asm, self.tcx.hir().local_def_id_to_hir_id(enclosing_id));\n+                .check_asm(asm, enclosing_id);\n         }\n     }\n "}, {"sha": "87e54025330e8a928873fc3295a31dd5e17d1a78", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -56,7 +56,7 @@ pub struct Inherited<'tcx> {\n     pub(super) deferred_asm_checks: RefCell<Vec<(&'tcx hir::InlineAsm<'tcx>, hir::HirId)>>,\n \n     pub(super) deferred_generator_interiors:\n-        RefCell<Vec<(hir::HirId, hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n+        RefCell<Vec<(LocalDefId, hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n \n     pub(super) body_id: Option<hir::BodyId>,\n "}, {"sha": "0aa34f9dd70724d2b0588fec4de21bbe150d0b57", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -40,8 +40,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         body: &'tcx hir::Body<'tcx>,\n     ) -> &'tcx ty::TypeckResults<'tcx> {\n-        let item_id = self.tcx.hir().body_owner(body.id());\n-        let item_def_id = self.tcx.hir().local_def_id(item_id);\n+        let item_def_id = self.tcx.hir().body_owner_def_id(body.id());\n \n         // This attribute causes us to dump some writeback information\n         // in the form of errors, which is used for unit tests.\n@@ -55,7 +54,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Type only exists for constants and statics, not functions.\n         match self.tcx.hir().body_owner_kind(item_def_id) {\n             hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => {\n-                wbcx.visit_node_id(body.value.span, item_id);\n+                let item_hir_id = self.tcx.hir().local_def_id_to_hir_id(item_def_id);\n+                wbcx.visit_node_id(body.value.span, item_hir_id);\n             }\n             hir::BodyOwnerKind::Closure | hir::BodyOwnerKind::Fn => (),\n         }"}, {"sha": "6703d53f3805cfe2884d2a649d4c033b5149d9e5", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -38,7 +38,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{Direction, NodeIndex, INCOMING, OUTGOING};\n use rustc_graphviz as dot;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_middle::dep_graph::{\n     DepGraphQuery, DepKind, DepNode, DepNodeExt, DepNodeFilter, EdgeFilter,\n@@ -74,7 +74,7 @@ pub fn assert_dep_graph(tcx: TyCtxt<'_>) {\n         let (if_this_changed, then_this_would_need) = {\n             let mut visitor =\n                 IfThisChanged { tcx, if_this_changed: vec![], then_this_would_need: vec![] };\n-            visitor.process_attrs(hir::CRATE_HIR_ID);\n+            visitor.process_attrs(CRATE_DEF_ID);\n             tcx.hir().visit_all_item_likes_in_crate(&mut visitor);\n             (visitor.if_this_changed, visitor.then_this_would_need)\n         };\n@@ -119,9 +119,9 @@ impl<'tcx> IfThisChanged<'tcx> {\n         value\n     }\n \n-    fn process_attrs(&mut self, hir_id: hir::HirId) {\n-        let def_id = self.tcx.hir().local_def_id(hir_id);\n+    fn process_attrs(&mut self, def_id: LocalDefId) {\n         let def_path_hash = self.tcx.def_path_hash(def_id.to_def_id());\n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let attrs = self.tcx.hir().attrs(hir_id);\n         for attr in attrs {\n             if attr.has_name(sym::rustc_if_this_changed) {\n@@ -180,22 +180,22 @@ impl<'tcx> Visitor<'tcx> for IfThisChanged<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.process_attrs(item.hir_id());\n+        self.process_attrs(item.owner_id.def_id);\n         intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.process_attrs(trait_item.hir_id());\n+        self.process_attrs(trait_item.owner_id.def_id);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.process_attrs(impl_item.hir_id());\n+        self.process_attrs(impl_item.owner_id.def_id);\n         intravisit::walk_impl_item(self, impl_item);\n     }\n \n     fn visit_field_def(&mut self, s: &'tcx hir::FieldDef<'tcx>) {\n-        self.process_attrs(s.hir_id);\n+        self.process_attrs(s.def_id);\n         intravisit::walk_field_def(self, s);\n     }\n }"}, {"sha": "77a1bca69b527cccb913d786d399f7119bb12426", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -56,9 +56,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n use rustc_hir::intravisit::FnKind as HirFnKind;\n-use rustc_hir::{\n-    Body, FnDecl, ForeignItemKind, GenericParamKind, HirId, Node, PatKind, PredicateOrigin,\n-};\n+use rustc_hir::{Body, FnDecl, ForeignItemKind, GenericParamKind, Node, PatKind, PredicateOrigin};\n use rustc_index::vec::Idx;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n@@ -2661,7 +2659,7 @@ pub struct ClashingExternDeclarations {\n     /// the symbol should be reported as a clashing declaration.\n     // FIXME: Technically, we could just store a &'tcx str here without issue; however, the\n     // `impl_lint_pass` macro doesn't currently support lints parametric over a lifetime.\n-    seen_decls: FxHashMap<Symbol, HirId>,\n+    seen_decls: FxHashMap<Symbol, hir::OwnerId>,\n }\n \n /// Differentiate between whether the name for an extern decl came from the link_name attribute or\n@@ -2687,19 +2685,20 @@ impl ClashingExternDeclarations {\n     pub(crate) fn new() -> Self {\n         ClashingExternDeclarations { seen_decls: FxHashMap::default() }\n     }\n+\n     /// Insert a new foreign item into the seen set. If a symbol with the same name already exists\n     /// for the item, return its HirId without updating the set.\n-    fn insert(&mut self, tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> Option<HirId> {\n+    fn insert(&mut self, tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> Option<hir::OwnerId> {\n         let did = fi.owner_id.to_def_id();\n         let instance = Instance::new(did, ty::List::identity_for_item(tcx, did));\n         let name = Symbol::intern(tcx.symbol_name(instance).name);\n-        if let Some(&hir_id) = self.seen_decls.get(&name) {\n+        if let Some(&existing_id) = self.seen_decls.get(&name) {\n             // Avoid updating the map with the new entry when we do find a collision. We want to\n             // make sure we're always pointing to the first definition as the previous declaration.\n             // This lets us avoid emitting \"knock-on\" diagnostics.\n-            Some(hir_id)\n+            Some(existing_id)\n         } else {\n-            self.seen_decls.insert(name, fi.hir_id())\n+            self.seen_decls.insert(name, fi.owner_id)\n         }\n     }\n \n@@ -2926,16 +2925,16 @@ impl ClashingExternDeclarations {\n impl_lint_pass!(ClashingExternDeclarations => [CLASHING_EXTERN_DECLARATIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n+    #[instrument(level = \"trace\", skip(self, cx))]\n     fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, this_fi: &hir::ForeignItem<'_>) {\n-        trace!(\"ClashingExternDeclarations: check_foreign_item: {:?}\", this_fi);\n         if let ForeignItemKind::Fn(..) = this_fi.kind {\n             let tcx = cx.tcx;\n-            if let Some(existing_hid) = self.insert(tcx, this_fi) {\n-                let existing_decl_ty = tcx.type_of(tcx.hir().local_def_id(existing_hid));\n+            if let Some(existing_did) = self.insert(tcx, this_fi) {\n+                let existing_decl_ty = tcx.type_of(existing_did);\n                 let this_decl_ty = tcx.type_of(this_fi.owner_id);\n                 debug!(\n                     \"ClashingExternDeclarations: Comparing existing {:?}: {:?} to this {:?}: {:?}\",\n-                    existing_hid, existing_decl_ty, this_fi.owner_id, this_decl_ty\n+                    existing_did, existing_decl_ty, this_fi.owner_id, this_decl_ty\n                 );\n                 // Check that the declarations match.\n                 if !Self::structurally_same_type(\n@@ -2944,7 +2943,7 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                     this_decl_ty,\n                     CItemKind::Declaration,\n                 ) {\n-                    let orig_fi = tcx.hir().expect_foreign_item(existing_hid.expect_owner());\n+                    let orig_fi = tcx.hir().expect_foreign_item(existing_did);\n                     let orig = Self::name_of_extern_decl(tcx, orig_fi);\n \n                     // We want to ensure that we use spans for both decls that include where the"}, {"sha": "b42878a02ee02985408d41e21ac7efd4aaf7392a", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -66,13 +66,12 @@ impl<'tcx, T: LateLintPass<'tcx>> LateContextAndPass<'tcx, T> {\n         self.context.last_node_with_lint_attrs = prev;\n     }\n \n-    fn with_param_env<F>(&mut self, id: hir::HirId, f: F)\n+    fn with_param_env<F>(&mut self, id: hir::OwnerId, f: F)\n     where\n         F: FnOnce(&mut Self),\n     {\n         let old_param_env = self.context.param_env;\n-        self.context.param_env =\n-            self.context.tcx.param_env(self.context.tcx.hir().local_def_id(id));\n+        self.context.param_env = self.context.tcx.param_env(id);\n         f(self);\n         self.context.param_env = old_param_env;\n     }\n@@ -132,7 +131,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         let old_cached_typeck_results = self.context.cached_typeck_results.take();\n         let old_enclosing_body = self.context.enclosing_body.take();\n         self.with_lint_attrs(it.hir_id(), |cx| {\n-            cx.with_param_env(it.hir_id(), |cx| {\n+            cx.with_param_env(it.owner_id, |cx| {\n                 lint_callback!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n                 lint_callback!(cx, check_item_post, it);\n@@ -145,7 +144,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n         self.with_lint_attrs(it.hir_id(), |cx| {\n-            cx.with_param_env(it.hir_id(), |cx| {\n+            cx.with_param_env(it.owner_id, |cx| {\n                 lint_callback!(cx, check_foreign_item, it);\n                 hir_visit::walk_foreign_item(cx, it);\n             });\n@@ -268,7 +267,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         let generics = self.context.generics.take();\n         self.context.generics = Some(&trait_item.generics);\n         self.with_lint_attrs(trait_item.hir_id(), |cx| {\n-            cx.with_param_env(trait_item.hir_id(), |cx| {\n+            cx.with_param_env(trait_item.owner_id, |cx| {\n                 lint_callback!(cx, check_trait_item, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n             });\n@@ -280,7 +279,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         let generics = self.context.generics.take();\n         self.context.generics = Some(&impl_item.generics);\n         self.with_lint_attrs(impl_item.hir_id(), |cx| {\n-            cx.with_param_env(impl_item.hir_id(), |cx| {\n+            cx.with_param_env(impl_item.owner_id, |cx| {\n                 lint_callback!(cx, check_impl_item, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n                 lint_callback!(cx, check_impl_item_post, impl_item);"}, {"sha": "71e2e66bdebc2786b0459478b5bfa7b54954a222", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -22,8 +22,8 @@ pub enum MethodLateContext {\n     PlainImpl,\n }\n \n-pub fn method_context(cx: &LateContext<'_>, def_id: LocalDefId) -> MethodLateContext {\n-    let item = cx.tcx.associated_item(def_id);\n+pub fn method_context(cx: &LateContext<'_>, id: LocalDefId) -> MethodLateContext {\n+    let item = cx.tcx.associated_item(id);\n     match item.container {\n         ty::TraitContainer => MethodLateContext::TraitAutoImpl,\n         ty::ImplContainer => match cx.tcx.impl_trait_ref(item.container_id(cx.tcx)) {"}, {"sha": "b0a5d3674ad2795d75fdcefe041c68c2db19f7de", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -1239,9 +1239,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_foreign_static(&mut self, id: hir::HirId, span: Span) {\n-        let def_id = self.cx.tcx.hir().local_def_id(id);\n-        let ty = self.cx.tcx.type_of(def_id);\n+    fn check_foreign_static(&mut self, id: hir::OwnerId, span: Span) {\n+        let ty = self.cx.tcx.type_of(id);\n         self.check_type_for_ffi_and_report_errors(span, ty, true, false);\n     }\n \n@@ -1264,7 +1263,7 @@ impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDeclarations {\n                     vis.check_foreign_fn(it.owner_id.def_id, decl);\n                 }\n                 hir::ForeignItemKind::Static(ref ty, _) => {\n-                    vis.check_foreign_static(it.hir_id(), ty.span);\n+                    vis.check_foreign_static(it.owner_id, ty.span);\n                 }\n                 hir::ForeignItemKind::Type => (),\n             }"}, {"sha": "68335a9b01a56c2ce9d669c7f619098eb2b299ba", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -1310,8 +1310,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         hir::ItemKind::Struct(ref vdata, _) => {\n                             yield item_id.owner_id.def_id.local_def_index;\n                             // Encode constructors which take a separate slot in value namespace.\n-                            if let Some(ctor_hir_id) = vdata.ctor_hir_id() {\n-                                yield tcx.hir().local_def_id(ctor_hir_id).local_def_index;\n+                            if let Some(ctor_def_id) = vdata.ctor_def_id() {\n+                                yield ctor_def_id.local_def_index;\n                             }\n                         }\n                         _ if tcx.def_key(item_id.owner_id.to_def_id()).get_opt_name().is_some() => {"}, {"sha": "72f4f6e649bcf178e51017fc2fb8a57bb81b52a0", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -105,7 +105,7 @@ macro_rules! arena_types {\n             // (during lowering) and the `librustc_middle` arena (for decoding MIR)\n             [decode] asm_template: rustc_ast::InlineAsmTemplatePiece,\n             [decode] used_trait_imports: rustc_data_structures::unord::UnordSet<rustc_hir::def_id::LocalDefId>,\n-            [decode] is_late_bound_map: rustc_data_structures::fx::FxIndexSet<rustc_hir::def_id::LocalDefId>,\n+            [decode] is_late_bound_map: rustc_data_structures::fx::FxIndexSet<rustc_hir::ItemLocalId>,\n             [decode] impl_source: rustc_middle::traits::ImplSource<'tcx, ()>,\n \n             [] dep_kind: rustc_middle::dep_graph::DepKindStruct<'tcx>,"}, {"sha": "5bd6b0704426b667b4e0435cd4ac3bb30f5f66a8", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 19, "deletions": 40, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -18,32 +18,38 @@ use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n #[inline]\n-pub fn associated_body(node: Node<'_>) -> Option<BodyId> {\n+pub fn associated_body(node: Node<'_>) -> Option<(LocalDefId, BodyId)> {\n     match node {\n         Node::Item(Item {\n+            owner_id,\n             kind: ItemKind::Const(_, body) | ItemKind::Static(.., body) | ItemKind::Fn(.., body),\n             ..\n         })\n         | Node::TraitItem(TraitItem {\n+            owner_id,\n             kind:\n                 TraitItemKind::Const(_, Some(body)) | TraitItemKind::Fn(_, TraitFn::Provided(body)),\n             ..\n         })\n         | Node::ImplItem(ImplItem {\n+            owner_id,\n             kind: ImplItemKind::Const(_, body) | ImplItemKind::Fn(_, body),\n             ..\n-        })\n-        | Node::Expr(Expr { kind: ExprKind::Closure(Closure { body, .. }), .. }) => Some(*body),\n+        }) => Some((owner_id.def_id, *body)),\n+\n+        Node::Expr(Expr { kind: ExprKind::Closure(Closure { def_id, body, .. }), .. }) => {\n+            Some((*def_id, *body))\n+        }\n \n-        Node::AnonConst(constant) => Some(constant.body),\n+        Node::AnonConst(constant) => Some((constant.def_id, constant.body)),\n \n         _ => None,\n     }\n }\n \n fn is_body_owner(node: Node<'_>, hir_id: HirId) -> bool {\n     match associated_body(node) {\n-        Some(b) => b.hir_id == hir_id,\n+        Some((_, b)) => b.hir_id == hir_id,\n         None => false,\n     }\n }\n@@ -154,10 +160,6 @@ impl<'hir> Map<'hir> {\n         self.tcx.definitions_untracked().def_key(def_id)\n     }\n \n-    pub fn def_path_from_hir_id(self, id: HirId) -> Option<DefPath> {\n-        self.opt_local_def_id(id).map(|def_id| self.def_path(def_id))\n-    }\n-\n     pub fn def_path(self, def_id: LocalDefId) -> DefPath {\n         // Accessing the DefPath is ok, since it is part of DefPathHash.\n         self.tcx.definitions_untracked().def_path(def_id)\n@@ -169,32 +171,6 @@ impl<'hir> Map<'hir> {\n         self.tcx.definitions_untracked().def_path_hash(def_id)\n     }\n \n-    #[inline]\n-    #[track_caller]\n-    pub fn local_def_id(self, hir_id: HirId) -> LocalDefId {\n-        self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n-            bug!(\n-                \"local_def_id: no entry for `{:?}`, which has a map of `{:?}`\",\n-                hir_id,\n-                self.find(hir_id)\n-            )\n-        })\n-    }\n-\n-    #[inline]\n-    pub fn opt_local_def_id(self, hir_id: HirId) -> Option<LocalDefId> {\n-        if hir_id.local_id == ItemLocalId::new(0) {\n-            Some(hir_id.owner.def_id)\n-        } else {\n-            self.tcx\n-                .hir_owner_nodes(hir_id.owner)\n-                .as_owner()?\n-                .local_id_to_def_id\n-                .get(&hir_id.local_id)\n-                .copied()\n-        }\n-    }\n-\n     #[inline]\n     pub fn local_def_id_to_hir_id(self, def_id: LocalDefId) -> HirId {\n         self.tcx.local_def_id_to_hir_id(def_id)\n@@ -410,8 +386,8 @@ impl<'hir> Map<'hir> {\n     #[track_caller]\n     pub fn enclosing_body_owner(self, hir_id: HirId) -> LocalDefId {\n         for (_, node) in self.parent_iter(hir_id) {\n-            if let Some(body) = associated_body(node) {\n-                return self.body_owner_def_id(body);\n+            if let Some((def_id, _)) = associated_body(node) {\n+                return def_id;\n             }\n         }\n \n@@ -427,14 +403,17 @@ impl<'hir> Map<'hir> {\n         parent\n     }\n \n-    pub fn body_owner_def_id(self, id: BodyId) -> LocalDefId {\n-        self.local_def_id(self.body_owner(id))\n+    pub fn body_owner_def_id(self, BodyId { hir_id }: BodyId) -> LocalDefId {\n+        let parent = self.parent_id(hir_id);\n+        associated_body(self.get(parent)).unwrap().0\n     }\n \n     /// Given a `LocalDefId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(self, id: LocalDefId) -> Option<BodyId> {\n-        self.find_by_def_id(id).and_then(associated_body)\n+        let node = self.find_by_def_id(id)?;\n+        let (_, body_id) = associated_body(node)?;\n+        Some(body_id)\n     }\n \n     /// Given a body owner's id, returns the `BodyId` associated with it."}, {"sha": "bc3c38fdb1c2ad8427222062882f1f1823b5645d", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -2506,7 +2506,7 @@ impl<'tcx> ConstantKind<'tcx> {\n \n         let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n         let parent_substs = if let Some(parent_hir_id) = tcx.hir().opt_parent_id(hir_id) {\n-            if let Some(parent_did) = tcx.hir().opt_local_def_id(parent_hir_id) {\n+            if let Some(parent_did) = parent_hir_id.as_owner() {\n                 InternalSubsts::identity_for_item(tcx, parent_did.to_def_id())\n             } else {\n                 tcx.mk_substs(Vec::<GenericArg<'tcx>>::new().into_iter())"}, {"sha": "fb1e3d233a2a5e8f00d29f4801a505dcd79b2933", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -670,7 +670,7 @@ fn fn_span(tcx: TyCtxt<'_>, def_id: DefId) -> Span {\n \n fn hir_body(tcx: TyCtxt<'_>, def_id: DefId) -> Option<&rustc_hir::Body<'_>> {\n     let hir_node = tcx.hir().get_if_local(def_id).expect(\"expected DefId is local\");\n-    hir::map::associated_body(hir_node).map(|fn_body_id| tcx.hir().body(fn_body_id))\n+    hir::map::associated_body(hir_node).map(|(_, fn_body_id)| tcx.hir().body(fn_body_id))\n }\n \n fn escape_html(s: &str) -> String {"}, {"sha": "460a5147766b59e52515ad24581f96297ef83d27", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -1640,7 +1640,7 @@ rustc_queries! {\n         Option<&'tcx FxHashMap<ItemLocalId, Region>> {\n         desc { \"looking up a named region\" }\n     }\n-    query is_late_bound_map(_: LocalDefId) -> Option<&'tcx FxIndexSet<LocalDefId>> {\n+    query is_late_bound_map(_: hir::OwnerId) -> Option<&'tcx FxIndexSet<ItemLocalId>> {\n         desc { \"testing if a region is late bound\" }\n     }\n     /// For a given item's generic parameter, gets the default lifetimes to be used"}, {"sha": "526df090a3cd90f1a7e9a77d30caac14a88d7b5e", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -2157,10 +2157,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn is_late_bound(self, id: HirId) -> bool {\n-        self.is_late_bound_map(id.owner.def_id).map_or(false, |set| {\n-            let def_id = self.hir().local_def_id(id);\n-            set.contains(&def_id)\n-        })\n+        self.is_late_bound_map(id.owner).map_or(false, |set| set.contains(&id.local_id))\n     }\n \n     pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {"}, {"sha": "1be819ca610c7c644f7b3c9c9325f4c52bf81494", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -118,6 +118,7 @@ fn copy<T: Copy>(x: &T) -> T {\n \n macro_rules! query_helper_param_ty {\n     (DefId) => { impl IntoQueryParam<DefId> };\n+    (LocalDefId) => { impl IntoQueryParam<LocalDefId> };\n     ($K:ty) => { $K };\n }\n \n@@ -418,6 +419,13 @@ mod sealed {\n         }\n     }\n \n+    impl IntoQueryParam<LocalDefId> for OwnerId {\n+        #[inline(always)]\n+        fn into_query_param(self) -> LocalDefId {\n+            self.def_id\n+        }\n+    }\n+\n     impl IntoQueryParam<DefId> for LocalDefId {\n         #[inline(always)]\n         fn into_query_param(self) -> DefId {"}, {"sha": "ff88d00135173ec90be84ffdef34170ea2d1f005", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -5,7 +5,6 @@ use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint;\n-use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::Span;\n use rustc_trait_selection::traits::predicate_for_trait_def;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -190,11 +189,10 @@ impl<'tcx> ConstToPat<'tcx> {\n         // using `PartialEq::eq` in this scenario in the past.)\n         let partial_eq_trait_id =\n             self.tcx().require_lang_item(hir::LangItem::PartialEq, Some(self.span));\n-        let def_id = self.tcx().hir().opt_local_def_id(self.id).unwrap_or(CRATE_DEF_ID);\n         let obligation: PredicateObligation<'_> = predicate_for_trait_def(\n             self.tcx(),\n             self.param_env,\n-            ObligationCause::misc(self.span, def_id),\n+            ObligationCause::misc(self.span, self.id.owner.def_id),\n             partial_eq_trait_id,\n             0,\n             [ty, ty],"}, {"sha": "9a617159813caeca77f5342ffebcf714a5b9643b", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -540,7 +540,8 @@ fn fn_sig_and_body(\n     // FIXME(#79625): Consider improving MIR to provide the information needed, to avoid going back\n     // to HIR for it.\n     let hir_node = tcx.hir().get_if_local(def_id).expect(\"expected DefId is local\");\n-    let fn_body_id = hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n+    let (_, fn_body_id) =\n+        hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n     (hir_node.fn_sig(), tcx.hir().body(fn_body_id))\n }\n "}, {"sha": "25cc65ba04c8b7ca083695b7426179bf41208939", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -453,7 +453,9 @@ impl CheckAttrVisitor<'_> {\n     /// Debugging aid for `object_lifetime_default` query.\n     fn check_object_lifetime_default(&self, hir_id: HirId) {\n         let tcx = self.tcx;\n-        if let Some(generics) = tcx.hir().get_generics(tcx.hir().local_def_id(hir_id)) {\n+        if let Some(owner_id) = hir_id.as_owner()\n+            && let Some(generics) = tcx.hir().get_generics(owner_id.def_id)\n+        {\n             for p in generics.params {\n                 let hir::GenericParamKind::Type { .. } = p.kind else { continue };\n                 let default = tcx.object_lifetime_default(p.def_id);\n@@ -1943,7 +1945,7 @@ impl CheckAttrVisitor<'_> {\n     ) -> bool {\n         match target {\n             Target::Fn | Target::Method(_)\n-                if self.tcx.is_const_fn_raw(self.tcx.hir().local_def_id(hir_id).to_def_id()) =>\n+                if self.tcx.is_const_fn_raw(hir_id.expect_owner().to_def_id()) =>\n             {\n                 true\n             }"}, {"sha": "127acb46e9242c36de20f6d42ddb098020d5445c", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -451,29 +451,23 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n         // referenced by it should be considered as used.\n         let in_pat = mem::replace(&mut self.in_pat, false);\n \n-        self.live_symbols.insert(self.tcx.hir().local_def_id(c.hir_id));\n+        self.live_symbols.insert(c.def_id);\n         intravisit::walk_anon_const(self, c);\n \n         self.in_pat = in_pat;\n     }\n }\n \n-fn has_allow_dead_code_or_lang_attr_helper(\n-    tcx: TyCtxt<'_>,\n-    id: hir::HirId,\n-    lint: &'static lint::Lint,\n-) -> bool {\n-    let attrs = tcx.hir().attrs(id);\n-    if tcx.sess.contains_name(attrs, sym::lang) {\n+fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n+    if tcx.has_attr(def_id.to_def_id(), sym::lang) {\n         return true;\n     }\n \n     // Stable attribute for #[lang = \"panic_impl\"]\n-    if tcx.sess.contains_name(attrs, sym::panic_handler) {\n+    if tcx.has_attr(def_id.to_def_id(), sym::panic_handler) {\n         return true;\n     }\n \n-    let def_id = tcx.hir().local_def_id(id);\n     if tcx.def_kind(def_id).has_codegen_attrs() {\n         let cg_attrs = tcx.codegen_fn_attrs(def_id);\n \n@@ -487,11 +481,8 @@ fn has_allow_dead_code_or_lang_attr_helper(\n         }\n     }\n \n-    tcx.lint_level_at_node(lint, id).0 == lint::Allow\n-}\n-\n-fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n-    has_allow_dead_code_or_lang_attr_helper(tcx, id, lint::builtin::DEAD_CODE)\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    tcx.lint_level_at_node(lint::builtin::DEAD_CODE, hir_id).0 == lint::Allow\n }\n \n // These check_* functions seeds items that\n@@ -513,7 +504,7 @@ fn check_item<'tcx>(\n     struct_constructors: &mut FxHashMap<LocalDefId, LocalDefId>,\n     id: hir::ItemId,\n ) {\n-    let allow_dead_code = has_allow_dead_code_or_lang_attr(tcx, id.hir_id());\n+    let allow_dead_code = has_allow_dead_code_or_lang_attr(tcx, id.owner_id.def_id);\n     if allow_dead_code {\n         worklist.push(id.owner_id.def_id);\n     }\n@@ -548,19 +539,17 @@ fn check_item<'tcx>(\n \n             // And we access the Map here to get HirId from LocalDefId\n             for id in local_def_ids {\n-                if of_trait.is_some()\n-                    || has_allow_dead_code_or_lang_attr(tcx, tcx.hir().local_def_id_to_hir_id(id))\n-                {\n+                if of_trait.is_some() || has_allow_dead_code_or_lang_attr(tcx, id) {\n                     worklist.push(id);\n                 }\n             }\n         }\n         DefKind::Struct => {\n             let item = tcx.hir().item(id);\n             if let hir::ItemKind::Struct(ref variant_data, _) = item.kind\n-                && let Some(ctor_hir_id) = variant_data.ctor_hir_id()\n+                && let Some(ctor_def_id) = variant_data.ctor_def_id()\n             {\n-                struct_constructors.insert(tcx.hir().local_def_id(ctor_hir_id), item.owner_id.def_id);\n+                struct_constructors.insert(ctor_def_id, item.owner_id.def_id);\n             }\n         }\n         DefKind::GlobalAsm => {\n@@ -576,7 +565,7 @@ fn check_trait_item(tcx: TyCtxt<'_>, worklist: &mut Vec<LocalDefId>, id: hir::Tr\n     if matches!(tcx.def_kind(id.owner_id), DefKind::AssocConst | DefKind::AssocFn) {\n         let trait_item = tcx.hir().trait_item(id);\n         if matches!(trait_item.kind, Const(_, Some(_)) | Fn(_, hir::TraitFn::Provided(_)))\n-            && has_allow_dead_code_or_lang_attr(tcx, trait_item.hir_id())\n+            && has_allow_dead_code_or_lang_attr(tcx, trait_item.owner_id.def_id)\n         {\n             worklist.push(trait_item.owner_id.def_id);\n         }\n@@ -585,7 +574,7 @@ fn check_trait_item(tcx: TyCtxt<'_>, worklist: &mut Vec<LocalDefId>, id: hir::Tr\n \n fn check_foreign_item(tcx: TyCtxt<'_>, worklist: &mut Vec<LocalDefId>, id: hir::ForeignItemId) {\n     if matches!(tcx.def_kind(id.owner_id), DefKind::Static(_) | DefKind::Fn)\n-        && has_allow_dead_code_or_lang_attr(tcx, id.hir_id())\n+        && has_allow_dead_code_or_lang_attr(tcx, id.owner_id.def_id)\n     {\n         worklist.push(id.owner_id.def_id);\n     }\n@@ -806,8 +795,7 @@ impl<'tcx> DeadVisitor<'tcx> {\n         if self.live_symbols.contains(&def_id) {\n             return;\n         }\n-        let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-        if has_allow_dead_code_or_lang_attr(self.tcx, hir_id) {\n+        if has_allow_dead_code_or_lang_attr(self.tcx, def_id) {\n             return;\n         }\n         let Some(name) = self.tcx.opt_item_name(def_id.to_def_id()) else {"}, {"sha": "fdd0e5dab705cb17691d0a45b489f6d54dbcaf1c", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -15,9 +15,9 @@ use crate::weak_lang_items;\n \n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::{extract, GenericRequirement};\n-use rustc_hir::{HirId, LangItem, LanguageItems, Target};\n+use rustc_hir::{LangItem, LanguageItems, Target};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cstore::ExternCrate;\n use rustc_span::{symbol::kw::Empty, Span};\n@@ -40,13 +40,13 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n         LanguageItemCollector { tcx, items: LanguageItems::new() }\n     }\n \n-    fn check_for_lang(&mut self, actual_target: Target, hir_id: HirId) {\n-        let attrs = self.tcx.hir().attrs(hir_id);\n+    fn check_for_lang(&mut self, actual_target: Target, def_id: LocalDefId) {\n+        let attrs = self.tcx.hir().attrs(self.tcx.hir().local_def_id_to_hir_id(def_id));\n         if let Some((name, span)) = extract(&attrs) {\n             match LangItem::from_name(name) {\n                 // Known lang item with attribute on correct target.\n                 Some(lang_item) if actual_target == lang_item.target() => {\n-                    self.collect_item_extended(lang_item, hir_id, span);\n+                    self.collect_item_extended(lang_item, def_id, span);\n                 }\n                 // Known lang item with attribute on incorrect target.\n                 Some(lang_item) => {\n@@ -142,8 +142,7 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n \n     // Like collect_item() above, but also checks whether the lang item is declared\n     // with the right number of generic arguments.\n-    fn collect_item_extended(&mut self, lang_item: LangItem, hir_id: HirId, span: Span) {\n-        let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n+    fn collect_item_extended(&mut self, lang_item: LangItem, item_def_id: LocalDefId, span: Span) {\n         let name = lang_item.name();\n \n         // Now check whether the lang_item has the expected number of generic\n@@ -154,7 +153,8 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n         // Some other types like Box and various functions like drop_in_place\n         // have minimum requirements.\n \n-        if let hir::Node::Item(hir::Item { kind, span: item_span, .. }) = self.tcx.hir().get(hir_id)\n+        if let hir::Node::Item(hir::Item { kind, span: item_span, .. }) =\n+            self.tcx.hir().get_by_def_id(item_def_id)\n         {\n             let (actual_num, generics_span) = match kind.generics() {\n                 Some(generics) => (generics.params.len(), generics.span),\n@@ -191,7 +191,7 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n             }\n         }\n \n-        self.collect_item(lang_item, item_def_id);\n+        self.collect_item(lang_item, item_def_id.to_def_id());\n     }\n }\n \n@@ -211,13 +211,14 @@ fn get_lang_items(tcx: TyCtxt<'_>, (): ()) -> LanguageItems {\n     let crate_items = tcx.hir_crate_items(());\n \n     for id in crate_items.items() {\n-        collector.check_for_lang(Target::from_def_kind(tcx.def_kind(id.owner_id)), id.hir_id());\n+        collector\n+            .check_for_lang(Target::from_def_kind(tcx.def_kind(id.owner_id)), id.owner_id.def_id);\n \n         if matches!(tcx.def_kind(id.owner_id), DefKind::Enum) {\n             let item = tcx.hir().item(id);\n             if let hir::ItemKind::Enum(def, ..) = &item.kind {\n                 for variant in def.variants {\n-                    collector.check_for_lang(Target::Variant, variant.hir_id);\n+                    collector.check_for_lang(Target::Variant, variant.def_id);\n                 }\n             }\n         }\n@@ -226,13 +227,13 @@ fn get_lang_items(tcx: TyCtxt<'_>, (): ()) -> LanguageItems {\n     // FIXME: avoid calling trait_item() when possible\n     for id in crate_items.trait_items() {\n         let item = tcx.hir().trait_item(id);\n-        collector.check_for_lang(Target::from_trait_item(item), item.hir_id())\n+        collector.check_for_lang(Target::from_trait_item(item), item.owner_id.def_id)\n     }\n \n     // FIXME: avoid calling impl_item() when possible\n     for id in crate_items.impl_items() {\n         let item = tcx.hir().impl_item(id);\n-        collector.check_for_lang(target_from_impl_item(tcx, item), item.hir_id())\n+        collector.check_for_lang(target_from_impl_item(tcx, item), item.owner_id.def_id)\n     }\n \n     // Extract out the found lang items."}, {"sha": "0bde7502e3991665a0af77a14c9552e2edcb618e", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -855,7 +855,8 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n /// See issue #94972 for details on why this is a special case\n fn is_unstable_reexport(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n     // Get the LocalDefId so we can lookup the item to check the kind.\n-    let Some(def_id) = tcx.hir().opt_local_def_id(id) else { return false; };\n+    let Some(owner) = id.as_owner() else { return false; };\n+    let def_id = owner.def_id;\n \n     let Some(stab) = tcx.stability().local_stability(def_id) else {\n         return false;"}, {"sha": "43552861532235ef5c78d931a75bcf2f9f27b2d1", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{AssocItemKind, HirIdSet, ItemId, Node, PatKind};\n use rustc_middle::bug;\n@@ -1879,7 +1879,7 @@ impl<'tcx> DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n \n struct PrivateItemsInPublicInterfacesChecker<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    old_error_set_ancestry: LocalDefIdSet,\n+    old_error_set_ancestry: HirIdSet,\n }\n \n impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n@@ -1892,7 +1892,9 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n             tcx: self.tcx,\n             item_def_id: def_id,\n             required_visibility,\n-            has_old_errors: self.old_error_set_ancestry.contains(&def_id),\n+            has_old_errors: self\n+                .old_error_set_ancestry\n+                .contains(&self.tcx.hir().local_def_id_to_hir_id(def_id)),\n             in_assoc_ty: false,\n         }\n     }\n@@ -2158,15 +2160,7 @@ fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n     }\n \n     // Check for private types and traits in public interfaces.\n-    let mut checker = PrivateItemsInPublicInterfacesChecker {\n-        tcx,\n-        // Only definition IDs are ever searched in `old_error_set_ancestry`,\n-        // so we can filter away all non-definition IDs at this point.\n-        old_error_set_ancestry: old_error_set_ancestry\n-            .into_iter()\n-            .filter_map(|hir_id| tcx.hir().opt_local_def_id(hir_id))\n-            .collect(),\n-    };\n+    let mut checker = PrivateItemsInPublicInterfacesChecker { tcx, old_error_set_ancestry };\n \n     for id in tcx.hir().items() {\n         checker.check_item(id);"}, {"sha": "3982111e38e08307f6aaacebe270a3c947f2cd78", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -211,7 +211,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     None => continue,\n                 };\n                 if !self.span.filter_generated(ident.span) {\n-                    let id = id_from_hir_id(hir_id, &self.save_ctxt);\n+                    let id = id_from_hir_id(hir_id);\n                     let span = self.span_from_span(ident.span);\n \n                     self.dumper.dump_def(\n@@ -240,27 +240,28 @@ impl<'tcx> DumpVisitor<'tcx> {\n         &mut self,\n         sig: &'tcx hir::FnSig<'tcx>,\n         body: Option<hir::BodyId>,\n-        def_id: LocalDefId,\n+        owner_id: hir::OwnerId,\n         ident: Ident,\n         generics: &'tcx hir::Generics<'tcx>,\n         span: Span,\n     ) {\n-        debug!(\"process_method: {:?}:{}\", def_id, ident);\n+        debug!(\"process_method: {:?}:{}\", owner_id, ident);\n \n         let map = self.tcx.hir();\n-        let hir_id = map.local_def_id_to_hir_id(def_id);\n-        self.nest_typeck_results(def_id, |v| {\n-            if let Some(mut method_data) = v.save_ctxt.get_method_data(hir_id, ident, span) {\n+        let hir_id: hir::HirId = owner_id.into();\n+        self.nest_typeck_results(owner_id.def_id, |v| {\n+            if let Some(mut method_data) = v.save_ctxt.get_method_data(owner_id, ident, span) {\n                 if let Some(body) = body {\n                     v.process_formals(map.body(body).params, &method_data.qualname);\n                 }\n                 v.process_generic_params(&generics, &method_data.qualname, hir_id);\n \n                 method_data.value =\n                     fn_to_string(sig.decl, sig.header, Some(ident.name), generics, &[], None);\n-                method_data.sig = sig::method_signature(hir_id, ident, generics, sig, &v.save_ctxt);\n+                method_data.sig =\n+                    sig::method_signature(owner_id, ident, generics, sig, &v.save_ctxt);\n \n-                v.dumper.dump_def(&access_from!(v.save_ctxt, def_id), method_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, owner_id.def_id), method_data);\n             }\n \n             // walk arg and return types\n@@ -282,14 +283,11 @@ impl<'tcx> DumpVisitor<'tcx> {\n     fn process_struct_field_def(\n         &mut self,\n         field: &'tcx hir::FieldDef<'tcx>,\n-        parent_id: hir::HirId,\n+        parent_id: LocalDefId,\n     ) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, self.tcx.hir().local_def_id(field.hir_id)),\n-                field_data,\n-            );\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, field.def_id), field_data);\n         }\n     }\n \n@@ -309,7 +307,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     // Append $id to name to make sure each one is unique.\n                     let qualname = format!(\"{}::{}${}\", prefix, name, id);\n                     if !self.span.filter_generated(param_ss) {\n-                        let id = id_from_hir_id(param.hir_id, &self.save_ctxt);\n+                        let id = id_from_def_id(param.def_id.to_def_id());\n                         let span = self.span_from_span(param_ss);\n \n                         self.dumper.dump_def(\n@@ -387,25 +385,24 @@ impl<'tcx> DumpVisitor<'tcx> {\n \n     fn process_assoc_const(\n         &mut self,\n-        def_id: LocalDefId,\n+        owner_id: hir::OwnerId,\n         ident: Ident,\n         typ: &'tcx hir::Ty<'tcx>,\n         expr: Option<&'tcx hir::Expr<'tcx>>,\n         parent_id: DefId,\n         attrs: &'tcx [ast::Attribute],\n     ) {\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id.to_def_id()));\n+        let qualname = format!(\"::{}\", self.tcx.def_path_str(owner_id.to_def_id()));\n \n         if !self.span.filter_generated(ident.span) {\n-            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-            let sig = sig::assoc_const_signature(hir_id, ident.name, typ, expr, &self.save_ctxt);\n+            let sig = sig::assoc_const_signature(owner_id, ident.name, typ, expr, &self.save_ctxt);\n             let span = self.span_from_span(ident.span);\n \n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, def_id),\n+                &access_from!(self.save_ctxt, owner_id.def_id),\n                 Def {\n                     kind: DefKind::Const,\n-                    id: id_from_hir_id(hir_id, &self.save_ctxt),\n+                    id: id_from_def_id(owner_id.to_def_id()),\n                     span,\n                     name: ident.name.to_string(),\n                     qualname,\n@@ -421,7 +418,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         }\n \n         // walk type and init value\n-        self.nest_typeck_results(def_id, |v| {\n+        self.nest_typeck_results(owner_id.def_id, |v| {\n             v.visit_ty(typ);\n             if let Some(expr) = expr {\n                 v.visit_expr(expr);\n@@ -456,8 +453,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                         if include_priv_fields {\n                             return Some(f.ident.to_string());\n                         }\n-                        let def_id = self.save_ctxt.tcx.hir().local_def_id(f.hir_id);\n-                        if self.save_ctxt.tcx.visibility(def_id).is_public() {\n+                        if self.save_ctxt.tcx.visibility(f.def_id).is_public() {\n                             Some(f.ident.to_string())\n                         } else {\n                             None\n@@ -466,7 +462,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     .collect::<Vec<_>>()\n                     .join(\", \");\n                 let value = format!(\"{} {{ {} }}\", name, fields_str);\n-                (value, fields.iter().map(|f| id_from_hir_id(f.hir_id, &self.save_ctxt)).collect())\n+                (value, fields.iter().map(|f| id_from_def_id(f.def_id.to_def_id())).collect())\n             }\n             _ => (String::new(), vec![]),\n         };\n@@ -495,7 +491,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n \n         self.nest_typeck_results(item.owner_id.def_id, |v| {\n             for field in def.fields() {\n-                v.process_struct_field_def(field, item.hir_id());\n+                v.process_struct_field_def(field, item.owner_id.def_id);\n                 v.visit_ty(&field.ty);\n             }\n \n@@ -529,7 +525,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_hir_id(variant.hir_id, &self.save_ctxt);\n+                        let id = id_from_def_id(variant.def_id.to_def_id());\n                         let parent = Some(id_from_def_id(item.owner_id.to_def_id()));\n                         let attrs = self.tcx.hir().attrs(variant.hir_id);\n \n@@ -567,7 +563,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     }\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_hir_id(variant.hir_id, &self.save_ctxt);\n+                        let id = id_from_def_id(variant.def_id.to_def_id());\n                         let parent = Some(id_from_def_id(item.owner_id.to_def_id()));\n                         let attrs = self.tcx.hir().attrs(variant.hir_id);\n \n@@ -593,7 +589,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             }\n \n             for field in variant.data.fields() {\n-                self.process_struct_field_def(field, variant.hir_id);\n+                self.process_struct_field_def(field, variant.def_id);\n                 self.visit_ty(field.ty);\n             }\n         }\n@@ -883,7 +879,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     // Rust uses the id of the pattern for var lookups, so we'll use it too.\n                     if !self.span.filter_generated(ident.span) {\n                         let qualname = format!(\"{}${}\", ident, hir_id);\n-                        let id = id_from_hir_id(hir_id, &self.save_ctxt);\n+                        let id = id_from_hir_id(hir_id);\n                         let span = self.span_from_span(ident.span);\n \n                         self.dumper.dump_def(\n@@ -983,7 +979,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let body = body.map(|b| self.tcx.hir().body(b).value);\n                 let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n                 self.process_assoc_const(\n-                    trait_item.owner_id.def_id,\n+                    trait_item.owner_id,\n                     trait_item.ident,\n                     &ty,\n                     body,\n@@ -997,7 +993,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.process_method(\n                     sig,\n                     body,\n-                    trait_item.owner_id.def_id,\n+                    trait_item.owner_id,\n                     trait_item.ident,\n                     &trait_item.generics,\n                     trait_item.span,\n@@ -1028,7 +1024,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                             decl_id: None,\n                             docs: self.save_ctxt.docs_for_attrs(attrs),\n                             sig: sig::assoc_type_signature(\n-                                trait_item.hir_id(),\n+                                trait_item.owner_id,\n                                 trait_item.ident,\n                                 Some(bounds),\n                                 default_ty.as_deref(),\n@@ -1053,7 +1049,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let body = self.tcx.hir().body(body);\n                 let attrs = self.tcx.hir().attrs(impl_item.hir_id());\n                 self.process_assoc_const(\n-                    impl_item.owner_id.def_id,\n+                    impl_item.owner_id,\n                     impl_item.ident,\n                     &ty,\n                     Some(&body.value),\n@@ -1065,7 +1061,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.process_method(\n                     sig,\n                     Some(body),\n-                    impl_item.owner_id.def_id,\n+                    impl_item.owner_id,\n                     impl_item.ident,\n                     &impl_item.generics,\n                     impl_item.span,\n@@ -1081,18 +1077,16 @@ impl<'tcx> DumpVisitor<'tcx> {\n     }\n \n     pub(crate) fn process_crate(&mut self) {\n-        let id = hir::CRATE_HIR_ID;\n-        let qualname =\n-            format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id(id).to_def_id()));\n+        let qualname = format!(\"::{}\", self.tcx.def_path_str(CRATE_DEF_ID.to_def_id()));\n \n         let sm = self.tcx.sess.source_map();\n         let krate_mod = self.tcx.hir().root_module();\n         let filename = sm.span_to_filename(krate_mod.spans.inner_span);\n-        let data_id = id_from_hir_id(id, &self.save_ctxt);\n+        let data_id = id_from_def_id(CRATE_DEF_ID.to_def_id());\n         let children =\n             krate_mod.item_ids.iter().map(|i| id_from_def_id(i.owner_id.to_def_id())).collect();\n         let span = self.span_from_span(krate_mod.spans.inner_span);\n-        let attrs = self.tcx.hir().attrs(id);\n+        let attrs = self.tcx.hir().attrs(hir::CRATE_HIR_ID);\n \n         self.dumper.dump_def(\n             &Access { public: true, reachable: true },\n@@ -1319,7 +1313,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                     // output the inferred type here? :shrug:\n                     hir::ArrayLen::Infer(..) => {}\n                     hir::ArrayLen::Body(anon_const) => self\n-                        .nest_typeck_results(self.tcx.hir().local_def_id(anon_const.hir_id), |v| {\n+                        .nest_typeck_results(anon_const.def_id, |v| {\n                             v.visit_expr(&map.body(anon_const.body).value)\n                         }),\n                 }\n@@ -1361,7 +1355,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprKind::Closure(&hir::Closure { ref fn_decl, body, .. }) => {\n+            hir::ExprKind::Closure(&hir::Closure { ref fn_decl, body, def_id, .. }) => {\n                 let id = format!(\"${}\", ex.hir_id);\n \n                 // walk arg and return types\n@@ -1375,7 +1369,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n \n                 // walk the body\n                 let map = self.tcx.hir();\n-                self.nest_typeck_results(self.tcx.hir().local_def_id(ex.hir_id), |v| {\n+                self.nest_typeck_results(def_id, |v| {\n                     let body = map.body(body);\n                     v.process_formals(body.params, &id);\n                     v.visit_expr(&body.value)\n@@ -1389,7 +1383,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                     // output the inferred type here? :shrug:\n                     hir::ArrayLen::Infer(..) => {}\n                     hir::ArrayLen::Body(anon_const) => self\n-                        .nest_typeck_results(self.tcx.hir().local_def_id(anon_const.hir_id), |v| {\n+                        .nest_typeck_results(anon_const.def_id, |v| {\n                             v.visit_expr(&map.body(anon_const.body).value)\n                         }),\n                 }"}, {"sha": "a9a92cc4f62ed9102a3039f58f01657f60eaef8d", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -21,7 +21,7 @@ use rustc_ast::util::comments::beautify_doc_string;\n use rustc_ast_pretty::pprust::attribute_to_string;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind as HirDefKind, Res};\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Node;\n use rustc_hir_pretty::{enum_def_to_string, fn_to_string, ty_to_string};\n@@ -318,7 +318,7 @@ impl<'tcx> SaveContext<'tcx> {\n                     qualname,\n                     value,\n                     parent: None,\n-                    children: def.variants.iter().map(|v| id_from_hir_id(v.hir_id, self)).collect(),\n+                    children: def.variants.iter().map(|v| id_from_def_id(v.def_id.to_def_id())).collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(attrs),\n                     sig: sig::item_signature(item, self),\n@@ -379,12 +379,11 @@ impl<'tcx> SaveContext<'tcx> {\n         }\n     }\n \n-    pub fn get_field_data(&self, field: &hir::FieldDef<'_>, scope: hir::HirId) -> Option<Def> {\n+    pub fn get_field_data(&self, field: &hir::FieldDef<'_>, scope: LocalDefId) -> Option<Def> {\n         let name = field.ident.to_string();\n-        let scope_def_id = self.tcx.hir().local_def_id(scope).to_def_id();\n-        let qualname = format!(\"::{}::{}\", self.tcx.def_path_str(scope_def_id), field.ident);\n+        let qualname = format!(\"::{}::{}\", self.tcx.def_path_str(scope.to_def_id()), field.ident);\n         filter!(self.span_utils, field.ident.span);\n-        let field_def_id = self.tcx.hir().local_def_id(field.hir_id).to_def_id();\n+        let field_def_id = field.def_id.to_def_id();\n         let typ = self.tcx.type_of(field_def_id).to_string();\n \n         let id = id_from_def_id(field_def_id);\n@@ -398,7 +397,7 @@ impl<'tcx> SaveContext<'tcx> {\n             name,\n             qualname,\n             value: typ,\n-            parent: Some(id_from_def_id(scope_def_id)),\n+            parent: Some(id_from_def_id(scope.to_def_id())),\n             children: vec![],\n             decl_id: None,\n             docs: self.docs_for_attrs(attrs),\n@@ -409,12 +408,11 @@ impl<'tcx> SaveContext<'tcx> {\n \n     // FIXME would be nice to take a MethodItem here, but the ast provides both\n     // trait and impl flavours, so the caller must do the disassembly.\n-    pub fn get_method_data(&self, hir_id: hir::HirId, ident: Ident, span: Span) -> Option<Def> {\n+    pub fn get_method_data(&self, owner_id: hir::OwnerId, ident: Ident, span: Span) -> Option<Def> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n         let (qualname, parent_scope, decl_id, docs, attributes) =\n-            match self.tcx.impl_of_method(def_id) {\n+            match self.tcx.impl_of_method(owner_id.to_def_id()) {\n                 Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n                     Some(Node::Item(item)) => match item.kind {\n                         hir::ItemKind::Impl(hir::Impl { ref self_ty, .. }) => {\n@@ -427,8 +425,8 @@ impl<'tcx> SaveContext<'tcx> {\n                             let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                             let mut docs = String::new();\n                             let mut attrs = vec![];\n-                            if let Some(Node::ImplItem(_)) = hir.find(hir_id) {\n-                                attrs = self.tcx.hir().attrs(hir_id).to_vec();\n+                            if let Some(Node::ImplItem(_)) = hir.find(owner_id.into()) {\n+                                attrs = self.tcx.hir().attrs(owner_id.into()).to_vec();\n                                 docs = self.docs_for_attrs(&attrs);\n                             }\n \n@@ -452,29 +450,29 @@ impl<'tcx> SaveContext<'tcx> {\n                         _ => {\n                             span_bug!(\n                                 span,\n-                                \"Container {:?} for method {} not an impl?\",\n+                                \"Container {:?} for method {:?} not an impl?\",\n                                 impl_id,\n-                                hir_id\n+                                owner_id,\n                             );\n                         }\n                     },\n                     r => {\n                         span_bug!(\n                             span,\n-                            \"Container {:?} for method {} is not a node item {:?}\",\n+                            \"Container {:?} for method {:?} is not a node item {:?}\",\n                             impl_id,\n-                            hir_id,\n+                            owner_id,\n                             r\n                         );\n                     }\n                 },\n-                None => match self.tcx.trait_of_item(def_id) {\n+                None => match self.tcx.trait_of_item(owner_id.to_def_id()) {\n                     Some(def_id) => {\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n \n-                        if let Some(Node::TraitItem(_)) = self.tcx.hir().find(hir_id) {\n-                            attrs = self.tcx.hir().attrs(hir_id).to_vec();\n+                        if let Some(Node::TraitItem(_)) = self.tcx.hir().find(owner_id.into()) {\n+                            attrs = self.tcx.hir().attrs(owner_id.into()).to_vec();\n                             docs = self.docs_for_attrs(&attrs);\n                         }\n \n@@ -487,7 +485,7 @@ impl<'tcx> SaveContext<'tcx> {\n                         )\n                     }\n                     None => {\n-                        debug!(\"could not find container for method {} at {:?}\", hir_id, span);\n+                        debug!(\"could not find container for method {:?} at {:?}\", owner_id, span);\n                         // This is not necessarily a bug, if there was a compilation error,\n                         // the typeck results we need might not exist.\n                         return None;\n@@ -501,7 +499,7 @@ impl<'tcx> SaveContext<'tcx> {\n \n         Some(Def {\n             kind: DefKind::Method,\n-            id: id_from_def_id(def_id),\n+            id: id_from_def_id(owner_id.to_def_id()),\n             span: self.span_from_span(ident.span),\n             name: ident.name.to_string(),\n             qualname,\n@@ -669,7 +667,7 @@ impl<'tcx> SaveContext<'tcx> {\n \n         match res {\n             Res::Local(id) => {\n-                Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_hir_id(id, self) })\n+                Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_hir_id(id) })\n             }\n             Res::Def(HirDefKind::Trait, def_id) if fn_type(path_seg) => {\n                 Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(def_id) })\n@@ -1033,18 +1031,15 @@ fn id_from_def_id(id: DefId) -> rls_data::Id {\n     rls_data::Id { krate: id.krate.as_u32(), index: id.index.as_u32() }\n }\n \n-fn id_from_hir_id(id: hir::HirId, scx: &SaveContext<'_>) -> rls_data::Id {\n-    let def_id = scx.tcx.hir().opt_local_def_id(id);\n-    def_id.map(|id| id_from_def_id(id.to_def_id())).unwrap_or_else(|| {\n-        // Create a *fake* `DefId` out of a `HirId` by combining the owner\n-        // `local_def_index` and the `local_id`.\n-        // This will work unless you have *billions* of definitions in a single\n-        // crate (very unlikely to actually happen).\n-        rls_data::Id {\n-            krate: LOCAL_CRATE.as_u32(),\n-            index: id.owner.def_id.local_def_index.as_u32() | id.local_id.as_u32().reverse_bits(),\n-        }\n-    })\n+fn id_from_hir_id(id: hir::HirId) -> rls_data::Id {\n+    // Create a *fake* `DefId` out of a `HirId` by combining the owner\n+    // `local_def_index` and the `local_id`.\n+    // This will work unless you have *billions* of definitions in a single\n+    // crate (very unlikely to actually happen).\n+    rls_data::Id {\n+        krate: LOCAL_CRATE.as_u32(),\n+        index: id.owner.def_id.local_def_index.as_u32() | id.local_id.as_u32().reverse_bits(),\n+    }\n }\n \n fn null_id() -> rls_data::Id {"}, {"sha": "979305547c14b23afe616ee78f6d9d88993aed5a", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 45, "deletions": 35, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -25,7 +25,7 @@\n //\n // FIXME where clauses need implementing, defs/refs in generics are mostly missing.\n \n-use crate::{id_from_def_id, id_from_hir_id, SaveContext};\n+use crate::{id_from_def_id, SaveContext};\n \n use rls_data::{SigElement, Signature};\n \n@@ -34,6 +34,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir_pretty::id_to_string;\n use rustc_hir_pretty::{bounds_to_string, path_segment_to_string, path_to_string, ty_to_string};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{Ident, Symbol};\n \n pub fn item_signature(item: &hir::Item<'_>, scx: &SaveContext<'_>) -> Option<Signature> {\n@@ -71,7 +72,7 @@ pub fn variant_signature(variant: &hir::Variant<'_>, scx: &SaveContext<'_>) -> O\n }\n \n pub fn method_signature(\n-    id: hir::HirId,\n+    id: hir::OwnerId,\n     ident: Ident,\n     generics: &hir::Generics<'_>,\n     m: &hir::FnSig<'_>,\n@@ -84,7 +85,7 @@ pub fn method_signature(\n }\n \n pub fn assoc_const_signature(\n-    id: hir::HirId,\n+    id: hir::OwnerId,\n     ident: Symbol,\n     ty: &hir::Ty<'_>,\n     default: Option<&hir::Expr<'_>>,\n@@ -97,7 +98,7 @@ pub fn assoc_const_signature(\n }\n \n pub fn assoc_type_signature(\n-    id: hir::HirId,\n+    id: hir::OwnerId,\n     ident: Ident,\n     bounds: Option<hir::GenericBounds<'_>>,\n     default: Option<&hir::Ty<'_>>,\n@@ -112,7 +113,8 @@ pub fn assoc_type_signature(\n type Result = std::result::Result<Signature, &'static str>;\n \n trait Sig {\n-    fn make(&self, offset: usize, id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result;\n+    type Parent;\n+    fn make(&self, offset: usize, id: Option<Self::Parent>, scx: &SaveContext<'_>) -> Result;\n }\n \n fn extend_sig(\n@@ -148,6 +150,7 @@ fn text_sig(text: String) -> Signature {\n }\n \n impl<'hir> Sig for hir::Ty<'hir> {\n+    type Parent = hir::HirId;\n     fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n         let id = Some(self.hir_id);\n         match self.kind {\n@@ -326,6 +329,7 @@ impl<'hir> Sig for hir::Ty<'hir> {\n }\n \n impl<'hir> Sig for hir::Item<'hir> {\n+    type Parent = hir::HirId;\n     fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n         let id = Some(self.hir_id());\n \n@@ -391,7 +395,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 text.push_str(\"fn \");\n \n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n \n                 sig.text.push('(');\n                 for i in decl.inputs {\n@@ -441,7 +445,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n             hir::ItemKind::TyAlias(ref ty, ref generics) => {\n                 let text = \"type \".to_owned();\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n \n                 sig.text.push_str(\" = \");\n                 let ty = ty.make(offset + sig.text.len(), id, scx)?;\n@@ -453,21 +457,21 @@ impl<'hir> Sig for hir::Item<'hir> {\n             hir::ItemKind::Enum(_, ref generics) => {\n                 let text = \"enum \".to_owned();\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n             hir::ItemKind::Struct(_, ref generics) => {\n                 let text = \"struct \".to_owned();\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n             hir::ItemKind::Union(_, ref generics) => {\n                 let text = \"union \".to_owned();\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n@@ -483,7 +487,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 }\n                 text.push_str(\"trait \");\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n \n                 if !bounds.is_empty() {\n                     sig.text.push_str(\": \");\n@@ -498,7 +502,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 let mut text = String::new();\n                 text.push_str(\"trait \");\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n \n                 if !bounds.is_empty() {\n                     sig.text.push_str(\" = \");\n@@ -532,7 +536,8 @@ impl<'hir> Sig for hir::Item<'hir> {\n                     text.push_str(\" const\");\n                 }\n \n-                let generics_sig = generics.make(offset + text.len(), id, scx)?;\n+                let generics_sig =\n+                    generics.make(offset + text.len(), Some(self.owner_id.def_id), scx)?;\n                 text.push_str(&generics_sig.text);\n \n                 text.push(' ');\n@@ -575,6 +580,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n }\n \n impl<'hir> Sig for hir::Path<'hir> {\n+    type Parent = hir::HirId;\n     fn make(&self, offset: usize, id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n         let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n \n@@ -609,7 +615,8 @@ impl<'hir> Sig for hir::Path<'hir> {\n \n // This does not cover the where clause, which must be processed separately.\n impl<'hir> Sig for hir::Generics<'hir> {\n-    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n+    type Parent = LocalDefId;\n+    fn make(&self, offset: usize, _parent_id: Option<LocalDefId>, scx: &SaveContext<'_>) -> Result {\n         if self.params.is_empty() {\n             return Ok(text_sig(String::new()));\n         }\n@@ -624,7 +631,7 @@ impl<'hir> Sig for hir::Generics<'hir> {\n             }\n             param_text.push_str(param.name.ident().as_str());\n             defs.push(SigElement {\n-                id: id_from_hir_id(param.hir_id, scx),\n+                id: id_from_def_id(param.def_id.to_def_id()),\n                 start: offset + text.len(),\n                 end: offset + text.len() + param_text.as_str().len(),\n             });\n@@ -646,12 +653,13 @@ impl<'hir> Sig for hir::Generics<'hir> {\n }\n \n impl<'hir> Sig for hir::FieldDef<'hir> {\n-    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n+    type Parent = LocalDefId;\n+    fn make(&self, offset: usize, _parent_id: Option<LocalDefId>, scx: &SaveContext<'_>) -> Result {\n         let mut text = String::new();\n \n         text.push_str(&self.ident.to_string());\n         let defs = Some(SigElement {\n-            id: id_from_hir_id(self.hir_id, scx),\n+            id: id_from_def_id(self.def_id.to_def_id()),\n             start: offset,\n             end: offset + text.len(),\n         });\n@@ -666,13 +674,14 @@ impl<'hir> Sig for hir::FieldDef<'hir> {\n }\n \n impl<'hir> Sig for hir::Variant<'hir> {\n-    fn make(&self, offset: usize, parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n+    type Parent = LocalDefId;\n+    fn make(&self, offset: usize, parent_id: Option<LocalDefId>, scx: &SaveContext<'_>) -> Result {\n         let mut text = self.ident.to_string();\n         match self.data {\n             hir::VariantData::Struct(fields, r) => {\n                 let id = parent_id.ok_or(\"Missing id for Variant's parent\")?;\n                 let name_def = SigElement {\n-                    id: id_from_hir_id(id, scx),\n+                    id: id_from_def_id(id.to_def_id()),\n                     start: offset,\n                     end: offset + text.len(),\n                 };\n@@ -693,17 +702,17 @@ impl<'hir> Sig for hir::Variant<'hir> {\n                 text.push('}');\n                 Ok(Signature { text, defs, refs })\n             }\n-            hir::VariantData::Tuple(fields, id, _) => {\n+            hir::VariantData::Tuple(fields, _, def_id) => {\n                 let name_def = SigElement {\n-                    id: id_from_hir_id(id, scx),\n+                    id: id_from_def_id(def_id.to_def_id()),\n                     start: offset,\n                     end: offset + text.len(),\n                 };\n                 text.push('(');\n                 let mut defs = vec![name_def];\n                 let mut refs = vec![];\n                 for f in fields {\n-                    let field_sig = f.make(offset + text.len(), Some(id), scx)?;\n+                    let field_sig = f.make(offset + text.len(), Some(def_id), scx)?;\n                     text.push_str(&field_sig.text);\n                     text.push_str(\", \");\n                     defs.extend(field_sig.defs.into_iter());\n@@ -712,9 +721,9 @@ impl<'hir> Sig for hir::Variant<'hir> {\n                 text.push(')');\n                 Ok(Signature { text, defs, refs })\n             }\n-            hir::VariantData::Unit(id, _) => {\n+            hir::VariantData::Unit(_, def_id) => {\n                 let name_def = SigElement {\n-                    id: id_from_hir_id(id, scx),\n+                    id: id_from_def_id(def_id.to_def_id()),\n                     start: offset,\n                     end: offset + text.len(),\n                 };\n@@ -725,6 +734,7 @@ impl<'hir> Sig for hir::Variant<'hir> {\n }\n \n impl<'hir> Sig for hir::ForeignItem<'hir> {\n+    type Parent = hir::HirId;\n     fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n         let id = Some(self.hir_id());\n         match self.kind {\n@@ -733,7 +743,7 @@ impl<'hir> Sig for hir::ForeignItem<'hir> {\n                 text.push_str(\"fn \");\n \n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n \n                 sig.text.push('(');\n                 for i in decl.inputs {\n@@ -797,25 +807,25 @@ fn name_and_generics(\n     mut text: String,\n     offset: usize,\n     generics: &hir::Generics<'_>,\n-    id: hir::HirId,\n+    id: hir::OwnerId,\n     name: Ident,\n     scx: &SaveContext<'_>,\n ) -> Result {\n     let name = name.to_string();\n     let def = SigElement {\n-        id: id_from_hir_id(id, scx),\n+        id: id_from_def_id(id.to_def_id()),\n         start: offset + text.len(),\n         end: offset + text.len() + name.len(),\n     };\n     text.push_str(&name);\n-    let generics: Signature = generics.make(offset + text.len(), Some(id), scx)?;\n+    let generics: Signature = generics.make(offset + text.len(), Some(id.def_id), scx)?;\n     // FIXME where clause\n     let text = format!(\"{}{}\", text, generics.text);\n     Ok(extend_sig(generics, text, vec![def], vec![]))\n }\n \n fn make_assoc_type_signature(\n-    id: hir::HirId,\n+    id: hir::OwnerId,\n     ident: Ident,\n     bounds: Option<hir::GenericBounds<'_>>,\n     default: Option<&hir::Ty<'_>>,\n@@ -824,7 +834,7 @@ fn make_assoc_type_signature(\n     let mut text = \"type \".to_owned();\n     let name = ident.to_string();\n     let mut defs = vec![SigElement {\n-        id: id_from_hir_id(id, scx),\n+        id: id_from_def_id(id.to_def_id()),\n         start: text.len(),\n         end: text.len() + name.len(),\n     }];\n@@ -837,7 +847,7 @@ fn make_assoc_type_signature(\n     }\n     if let Some(default) = default {\n         text.push_str(\" = \");\n-        let ty_sig = default.make(text.len(), Some(id), scx)?;\n+        let ty_sig = default.make(text.len(), Some(id.into()), scx)?;\n         text.push_str(&ty_sig.text);\n         defs.extend(ty_sig.defs.into_iter());\n         refs.extend(ty_sig.refs.into_iter());\n@@ -847,7 +857,7 @@ fn make_assoc_type_signature(\n }\n \n fn make_assoc_const_signature(\n-    id: hir::HirId,\n+    id: hir::OwnerId,\n     ident: Symbol,\n     ty: &hir::Ty<'_>,\n     default: Option<&hir::Expr<'_>>,\n@@ -856,15 +866,15 @@ fn make_assoc_const_signature(\n     let mut text = \"const \".to_owned();\n     let name = ident.to_string();\n     let mut defs = vec![SigElement {\n-        id: id_from_hir_id(id, scx),\n+        id: id_from_def_id(id.to_def_id()),\n         start: text.len(),\n         end: text.len() + name.len(),\n     }];\n     let mut refs = vec![];\n     text.push_str(&name);\n     text.push_str(\": \");\n \n-    let ty_sig = ty.make(text.len(), Some(id), scx)?;\n+    let ty_sig = ty.make(text.len(), Some(id.into()), scx)?;\n     text.push_str(&ty_sig.text);\n     defs.extend(ty_sig.defs.into_iter());\n     refs.extend(ty_sig.refs.into_iter());\n@@ -878,7 +888,7 @@ fn make_assoc_const_signature(\n }\n \n fn make_method_signature(\n-    id: hir::HirId,\n+    id: hir::OwnerId,\n     ident: Ident,\n     generics: &hir::Generics<'_>,\n     m: &hir::FnSig<'_>,"}, {"sha": "4aac3d71d0c533656454395210398678b75563e4", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -399,7 +399,7 @@ fn predicate_constraint(generics: &hir::Generics<'_>, pred: ty::Predicate<'_>) -\n /// param for cleaner code.\n fn suggest_restriction<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    hir_id: HirId,\n+    item_id: LocalDefId,\n     hir_generics: &hir::Generics<'tcx>,\n     msg: &str,\n     err: &mut Diagnostic,\n@@ -418,7 +418,6 @@ fn suggest_restriction<'tcx>(\n     {\n         return;\n     }\n-    let Some(item_id) = hir_id.as_owner() else { return; };\n     let generics = tcx.generics_of(item_id);\n     // Given `fn foo(t: impl Trait)` where `Trait` requires assoc type `A`...\n     if let Some((param, bound_str, fn_sig)) =\n@@ -523,7 +522,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         mut err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n         associated_ty: Option<(&'static str, Ty<'tcx>)>,\n-        body_id: LocalDefId,\n+        mut body_id: LocalDefId,\n     ) {\n         let trait_pred = self.resolve_numeric_literals_with_default(trait_pred);\n \n@@ -536,9 +535,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n         //        don't suggest `T: Sized + ?Sized`.\n-        let mut body_id = body_id;\n         while let Some(node) = self.tcx.hir().find_by_def_id(body_id) {\n-            let hir_id = self.tcx.hir().local_def_id_to_hir_id(body_id);\n             match node {\n                 hir::Node::Item(hir::Item {\n                     ident,\n@@ -549,7 +546,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(\n                         self.tcx,\n-                        hir_id,\n+                        body_id,\n                         &generics,\n                         \"`Self`\",\n                         err,\n@@ -569,7 +566,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     assert!(param_ty);\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(\n-                        self.tcx, hir_id, &generics, \"`Self`\", err, None, projection, trait_pred,\n+                        self.tcx, body_id, &generics, \"`Self`\", err, None, projection, trait_pred,\n                         None,\n                     );\n                     return;\n@@ -591,7 +588,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     // Missing restriction on associated type of type parameter (unmet projection).\n                     suggest_restriction(\n                         self.tcx,\n-                        hir_id,\n+                        body_id,\n                         &generics,\n                         \"the associated type\",\n                         err,\n@@ -611,7 +608,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     // Missing restriction on associated type of type parameter (unmet projection).\n                     suggest_restriction(\n                         self.tcx,\n-                        hir_id,\n+                        body_id,\n                         &generics,\n                         \"the associated type\",\n                         err,"}, {"sha": "e2ced191a00c0e267eaf71e3d353eed379d7bd6b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 20, "deletions": 35, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -383,13 +383,10 @@ fn clean_middle_term<'tcx>(\n fn clean_hir_term<'tcx>(term: &hir::Term<'tcx>, cx: &mut DocContext<'tcx>) -> Term {\n     match term {\n         hir::Term::Ty(ty) => Term::Type(clean_ty(ty, cx)),\n-        hir::Term::Const(c) => {\n-            let def_id = cx.tcx.hir().local_def_id(c.hir_id);\n-            Term::Constant(clean_middle_const(\n-                ty::Binder::dummy(ty::Const::from_anon_const(cx.tcx, def_id)),\n-                cx,\n-            ))\n-        }\n+        hir::Term::Const(c) => Term::Constant(clean_middle_const(\n+            ty::Binder::dummy(ty::Const::from_anon_const(cx.tcx, c.def_id)),\n+            cx,\n+        )),\n     }\n }\n \n@@ -524,12 +521,11 @@ fn clean_generic_param<'tcx>(\n     generics: Option<&hir::Generics<'tcx>>,\n     param: &hir::GenericParam<'tcx>,\n ) -> GenericParamDef {\n-    let did = cx.tcx.hir().local_def_id(param.hir_id);\n     let (name, kind) = match param.kind {\n         hir::GenericParamKind::Lifetime { .. } => {\n             let outlives = if let Some(generics) = generics {\n                 generics\n-                    .outlives_for_param(did)\n+                    .outlives_for_param(param.def_id)\n                     .filter(|bp| !bp.in_where_clause)\n                     .flat_map(|bp| bp.bounds)\n                     .map(|bound| match bound {\n@@ -545,7 +541,7 @@ fn clean_generic_param<'tcx>(\n         hir::GenericParamKind::Type { ref default, synthetic } => {\n             let bounds = if let Some(generics) = generics {\n                 generics\n-                    .bounds_for_param(did)\n+                    .bounds_for_param(param.def_id)\n                     .filter(|bp| bp.origin != PredicateOrigin::WhereClause)\n                     .flat_map(|bp| bp.bounds)\n                     .filter_map(|x| clean_generic_bound(x, cx))\n@@ -556,7 +552,7 @@ fn clean_generic_param<'tcx>(\n             (\n                 param.name.ident().name,\n                 GenericParamDefKind::Type {\n-                    did: did.to_def_id(),\n+                    did: param.def_id.to_def_id(),\n                     bounds,\n                     default: default.map(|t| clean_ty(t, cx)).map(Box::new),\n                     synthetic,\n@@ -566,12 +562,10 @@ fn clean_generic_param<'tcx>(\n         hir::GenericParamKind::Const { ty, default } => (\n             param.name.ident().name,\n             GenericParamDefKind::Const {\n-                did: did.to_def_id(),\n+                did: param.def_id.to_def_id(),\n                 ty: Box::new(clean_ty(ty, cx)),\n-                default: default.map(|ct| {\n-                    let def_id = cx.tcx.hir().local_def_id(ct.hir_id);\n-                    Box::new(ty::Const::from_anon_const(cx.tcx, def_id).to_string())\n-                }),\n+                default: default\n+                    .map(|ct| Box::new(ty::Const::from_anon_const(cx.tcx, ct.def_id).to_string())),\n             },\n         ),\n     };\n@@ -1548,18 +1542,16 @@ fn maybe_expand_private_type_alias<'tcx>(\n                     _ => None,\n                 });\n                 if let Some(lt) = lifetime {\n-                    let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n                     let cleaned = if !lt.is_anonymous() {\n                         clean_lifetime(lt, cx)\n                     } else {\n                         Lifetime::elided()\n                     };\n-                    substs.insert(lt_def_id.to_def_id(), SubstParam::Lifetime(cleaned));\n+                    substs.insert(param.def_id.to_def_id(), SubstParam::Lifetime(cleaned));\n                 }\n                 indices.lifetimes += 1;\n             }\n             hir::GenericParamKind::Type { ref default, .. } => {\n-                let ty_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n                 let mut j = 0;\n                 let type_ = generic_args.args.iter().find_map(|arg| match arg {\n                     hir::GenericArg::Type(ty) => {\n@@ -1572,17 +1564,14 @@ fn maybe_expand_private_type_alias<'tcx>(\n                     _ => None,\n                 });\n                 if let Some(ty) = type_ {\n-                    substs.insert(ty_param_def_id.to_def_id(), SubstParam::Type(clean_ty(ty, cx)));\n+                    substs.insert(param.def_id.to_def_id(), SubstParam::Type(clean_ty(ty, cx)));\n                 } else if let Some(default) = *default {\n-                    substs.insert(\n-                        ty_param_def_id.to_def_id(),\n-                        SubstParam::Type(clean_ty(default, cx)),\n-                    );\n+                    substs\n+                        .insert(param.def_id.to_def_id(), SubstParam::Type(clean_ty(default, cx)));\n                 }\n                 indices.types += 1;\n             }\n             hir::GenericParamKind::Const { .. } => {\n-                let const_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n                 let mut j = 0;\n                 let const_ = generic_args.args.iter().find_map(|arg| match arg {\n                     hir::GenericArg::Const(ct) => {\n@@ -1596,7 +1585,7 @@ fn maybe_expand_private_type_alias<'tcx>(\n                 });\n                 if let Some(ct) = const_ {\n                     substs.insert(\n-                        const_param_def_id.to_def_id(),\n+                        param.def_id.to_def_id(),\n                         SubstParam::Constant(clean_const(ct, cx)),\n                     );\n                 }\n@@ -1624,16 +1613,15 @@ pub(crate) fn clean_ty<'tcx>(ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> T\n             let length = match length {\n                 hir::ArrayLen::Infer(_, _) => \"_\".to_string(),\n                 hir::ArrayLen::Body(anon_const) => {\n-                    let def_id = cx.tcx.hir().local_def_id(anon_const.hir_id);\n                     // NOTE(min_const_generics): We can't use `const_eval_poly` for constants\n                     // as we currently do not supply the parent generics to anonymous constants\n                     // but do allow `ConstKind::Param`.\n                     //\n                     // `const_eval_poly` tries to first substitute generic parameters which\n                     // results in an ICE while manually constructing the constant and using `eval`\n                     // does nothing for `ConstKind::Param`.\n-                    let ct = ty::Const::from_anon_const(cx.tcx, def_id);\n-                    let param_env = cx.tcx.param_env(def_id);\n+                    let ct = ty::Const::from_anon_const(cx.tcx, anon_const.def_id);\n+                    let param_env = cx.tcx.param_env(anon_const.def_id);\n                     print_const(cx, ct.eval(cx.tcx, param_env))\n                 }\n             };\n@@ -1930,8 +1918,7 @@ fn clean_middle_opaque_bounds<'tcx>(\n }\n \n pub(crate) fn clean_field<'tcx>(field: &hir::FieldDef<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n-    let def_id = cx.tcx.hir().local_def_id(field.hir_id).to_def_id();\n-    clean_field_with_def_id(def_id, field.ident.name, clean_ty(field.ty, cx), cx)\n+    clean_field_with_def_id(field.def_id.to_def_id(), field.ident.name, clean_ty(field.ty, cx), cx)\n }\n \n pub(crate) fn clean_middle_field<'tcx>(field: &ty::FieldDef, cx: &mut DocContext<'tcx>) -> Item {\n@@ -1981,10 +1968,8 @@ fn clean_variant_data<'tcx>(\n     disr_expr: &Option<hir::AnonConst>,\n     cx: &mut DocContext<'tcx>,\n ) -> Variant {\n-    let discriminant = disr_expr.map(|disr| Discriminant {\n-        expr: Some(disr.body),\n-        value: cx.tcx.hir().local_def_id(disr.hir_id).to_def_id(),\n-    });\n+    let discriminant = disr_expr\n+        .map(|disr| Discriminant { expr: Some(disr.body), value: disr.def_id.to_def_id() });\n \n     let kind = match variant {\n         hir::VariantData::Struct(..) => VariantKind::Struct(VariantStruct {"}, {"sha": "6c333afacc648b41d567d36b9b782095d8936fce", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -778,20 +778,20 @@ fn walk_parents<'tcx>(\n \n             Node::Expr(parent) if parent.span.ctxt() == ctxt => match parent.kind {\n                 ExprKind::Ret(_) => {\n-                    let owner_id = cx.tcx.hir().body_owner(cx.enclosing_body.unwrap());\n+                    let owner_id = cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap());\n                     Some(\n                         if let Node::Expr(\n                             closure_expr @ Expr {\n                                 kind: ExprKind::Closure(closure),\n                                 ..\n                             },\n-                        ) = cx.tcx.hir().get(owner_id)\n+                        ) = cx.tcx.hir().get_by_def_id(owner_id)\n                         {\n                             closure_result_position(cx, closure, cx.typeck_results().expr_ty(closure_expr), precedence)\n                         } else {\n                             let output = cx\n                                 .tcx\n-                                .erase_late_bound_regions(cx.tcx.fn_sig(cx.tcx.hir().local_def_id(owner_id)).subst_identity().output());\n+                                .erase_late_bound_regions(cx.tcx.fn_sig(owner_id).subst_identity().output());\n                             ty_auto_deref_stability(cx, output, precedence).position_for_result(cx)\n                         },\n                     )"}, {"sha": "9a84068d4487b3054607d5babc643b30aa15f5ac", "filename": "src/tools/clippy/clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -157,7 +157,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n             && def.variants.len() > 1\n         {\n             let mut iter = def.variants.iter().filter_map(|v| {\n-                (matches!(v.data, hir::VariantData::Unit(..))\n+                (matches!(v.data, hir::VariantData::Unit(_, _))\n                     && v.ident.as_str().starts_with('_')\n                     && is_doc_hidden(cx.tcx.hir().attrs(v.hir_id)))\n                 .then_some((v.def_id, v.span))"}, {"sha": "0dc7fe2a2c5a36d900e9a43b61829a86d664ab1d", "filename": "src/tools/clippy/clippy_lints/src/methods/suspicious_map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -11,8 +11,7 @@ use super::SUSPICIOUS_MAP;\n pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, count_recv: &hir::Expr<'_>, map_arg: &hir::Expr<'_>) {\n     if_chain! {\n         if is_trait_method(cx, count_recv, sym::Iterator);\n-        let closure = expr_or_init(cx, map_arg);\n-        if let hir::ExprKind::Closure(closure) = closure.kind;\n+        if let hir::ExprKind::Closure(closure) = expr_or_init(cx, map_arg).kind;\n         let closure_body = cx.tcx.hir().body(closure.body);\n         if !cx.typeck_results().expr_ty(closure_body.value).is_unit();\n         then {"}, {"sha": "0db3b93e7cc9fe3a9c7c06ab6b0ebdac61528516", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -1119,9 +1119,8 @@ pub fn can_move_expr_to_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'\n                         self.captures.entry(l).and_modify(|e| *e |= cap).or_insert(cap);\n                     }\n                 },\n-                ExprKind::Closure { .. } => {\n-                    let closure_id = self.cx.tcx.hir().local_def_id(e.hir_id);\n-                    for capture in self.cx.typeck_results().closure_min_captures_flattened(closure_id) {\n+                ExprKind::Closure(closure) => {\n+                    for capture in self.cx.typeck_results().closure_min_captures_flattened(closure.def_id) {\n                         let local_id = match capture.place.base {\n                             PlaceBase::Local(id) => id,\n                             PlaceBase::Upvar(var) => var.var_path.hir_id,\n@@ -1584,8 +1583,7 @@ pub fn return_ty<'tcx>(cx: &LateContext<'tcx>, fn_def_id: hir::OwnerId) -> Ty<'t\n }\n \n /// Convenience function to get the nth argument type of a function.\n-pub fn nth_arg<'tcx>(cx: &LateContext<'tcx>, fn_item: hir::HirId, nth: usize) -> Ty<'tcx> {\n-    let fn_def_id = cx.tcx.hir().local_def_id(fn_item);\n+pub fn nth_arg<'tcx>(cx: &LateContext<'tcx>, fn_def_id: hir::OwnerId, nth: usize) -> Ty<'tcx> {\n     let arg = cx.tcx.fn_sig(fn_def_id).subst_identity().input(nth);\n     cx.tcx.erase_late_bound_regions(arg)\n }"}, {"sha": "b8c87aa5e1e423ab02d0593d679afe235f1c4a71", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15d6325747d9e37b5e8f19718eada0d5307fdef2/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d6325747d9e37b5e8f19718eada0d5307fdef2/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=15d6325747d9e37b5e8f19718eada0d5307fdef2", "patch": "@@ -809,7 +809,7 @@ pub struct DerefClosure {\n ///\n /// note: this only works on single line immutable closures with exactly one input parameter.\n pub fn deref_closure_args(cx: &LateContext<'_>, closure: &hir::Expr<'_>) -> Option<DerefClosure> {\n-    if let hir::ExprKind::Closure(&Closure { fn_decl, body, .. }) = closure.kind {\n+    if let hir::ExprKind::Closure(&Closure { fn_decl, def_id, body, .. }) = closure.kind {\n         let closure_body = cx.tcx.hir().body(body);\n         // is closure arg a type annotated double reference (i.e.: `|x: &&i32| ...`)\n         // a type annotation is present if param `kind` is different from `TyKind::Infer`\n@@ -829,10 +829,8 @@ pub fn deref_closure_args(cx: &LateContext<'_>, closure: &hir::Expr<'_>) -> Opti\n             applicability: Applicability::MachineApplicable,\n         };\n \n-        let fn_def_id = cx.tcx.hir().local_def_id(closure.hir_id);\n         let infcx = cx.tcx.infer_ctxt().build();\n-        ExprUseVisitor::new(&mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n-            .consume_body(closure_body);\n+        ExprUseVisitor::new(&mut visitor, &infcx, def_id, cx.param_env, cx.typeck_results()).consume_body(closure_body);\n \n         if !visitor.suggestion_start.is_empty() {\n             return Some(DerefClosure {"}]}