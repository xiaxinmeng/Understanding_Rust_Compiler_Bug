{"sha": "de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlOGVkNmExZDZhZTNiMmYyYzdmMTAzNWVmM2I3MWFiZGE3YTZhODQ=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-07T09:45:22Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-21T07:45:18Z"}, "message": "Move non-allocating [u8] inherent methods to libcore\n\nFixes #45803", "tree": {"sha": "96e8fb816f10da7f1ecc2b79d1ad94c3d815fd81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96e8fb816f10da7f1ecc2b79d1ad94c3d815fd81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "html_url": "https://github.com/rust-lang/rust/commit/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "572256772e10513ff61e9932d421d0a1e4656e02", "url": "https://api.github.com/repos/rust-lang/rust/commits/572256772e10513ff61e9932d421d0a1e4656e02", "html_url": "https://github.com/rust-lang/rust/commit/572256772e10513ff61e9932d421d0a1e4656e02"}], "stats": {"total": 157, "additions": 101, "deletions": 56}, "files": [{"sha": "70945a791f64ac1f3610046402a2f92e5298c67c", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 4, "deletions": 54, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "patch": "@@ -1782,16 +1782,10 @@ impl<T> [T] {\n     }\n }\n \n-#[lang = \"slice_u8\"]\n+#[cfg_attr(stage0, lang = \"slice_u8\")]\n+#[cfg_attr(not(stage0), lang = \"slice_u8_alloc\")]\n #[cfg(not(test))]\n impl [u8] {\n-    /// Checks if all bytes in this slice are within the ASCII range.\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[inline]\n-    pub fn is_ascii(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii())\n-    }\n-\n     /// Returns a vector containing a copy of this slice where each byte\n     /// is mapped to its ASCII upper case equivalent.\n     ///\n@@ -1826,52 +1820,8 @@ impl [u8] {\n         me\n     }\n \n-    /// Checks that two slices are an ASCII case-insensitive match.\n-    ///\n-    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n-    /// but without allocating and copying temporaries.\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[inline]\n-    pub fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().zip(other).all(|(a, b)| {\n-                a.eq_ignore_ascii_case(b)\n-            })\n-    }\n-\n-    /// Converts this slice to its ASCII upper case equivalent in-place.\n-    ///\n-    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n-    /// but non-ASCII letters are unchanged.\n-    ///\n-    /// To return a new uppercased value without modifying the existing one, use\n-    /// [`to_ascii_uppercase`].\n-    ///\n-    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[inline]\n-    pub fn make_ascii_uppercase(&mut self) {\n-        for byte in self {\n-            byte.make_ascii_uppercase();\n-        }\n-    }\n-\n-    /// Converts this slice to its ASCII lower case equivalent in-place.\n-    ///\n-    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n-    /// but non-ASCII letters are unchanged.\n-    ///\n-    /// To return a new lowercased value without modifying the existing one, use\n-    /// [`to_ascii_lowercase`].\n-    ///\n-    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[inline]\n-    pub fn make_ascii_lowercase(&mut self) {\n-        for byte in self {\n-            byte.make_ascii_lowercase();\n-        }\n-    }\n+    #[cfg(stage0)]\n+    slice_u8_core_methods!();\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "88bd0444233c9535c3847cfe7a61de8cb96d8fb8", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "patch": "@@ -92,6 +92,7 @@\n #![feature(rustc_attrs)]\n #![feature(rustc_const_unstable)]\n #![feature(simd_ffi)]\n+#![feature(core_slice_ext)]\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "4cda1c8778a176c227660027e7e59c3b2ab4de2c", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "patch": "@@ -755,6 +755,71 @@ impl<T> SliceExt for [T] {\n     }\n }\n \n+#[cfg_attr(stage0, macro_export)]\n+#[unstable(feature = \"core_slice_ext\", issue = \"32110\")]\n+macro_rules! slice_u8_core_methods { () => {\n+    /// Checks if all bytes in this slice are within the ASCII range.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii())\n+    }\n+\n+    /// Checks that two slices are an ASCII case-insensitive match.\n+    ///\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n+    /// but without allocating and copying temporaries.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n+        self.len() == other.len() &&\n+            self.iter().zip(other).all(|(a, b)| {\n+                a.eq_ignore_ascii_case(b)\n+            })\n+    }\n+\n+    /// Converts this slice to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_uppercase();\n+        }\n+    }\n+\n+    /// Converts this slice to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_lowercase();\n+        }\n+    }\n+}}\n+\n+#[lang = \"slice_u8\"]\n+#[cfg(not(test))]\n+#[cfg(not(stage0))]\n+impl [u8] {\n+    slice_u8_core_methods!();\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n impl<T, I> ops::Index<I> for [T]"}, {"sha": "f8cff8b186c1e448cc8ed169a0cd78ab2a581717", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "patch": "@@ -214,6 +214,7 @@ language_item_table! {\n     StrImplItem,                     \"str\",                     str_impl;\n     SliceImplItem,                   \"slice\",                   slice_impl;\n     SliceU8ImplItem,                 \"slice_u8\",                slice_u8_impl;\n+    SliceU8AllocImplItem,            \"slice_u8_alloc\",          slice_u8_alloc_impl;\n     ConstPtrImplItem,                \"const_ptr\",               const_ptr_impl;\n     MutPtrImplItem,                  \"mut_ptr\",                 mut_ptr_impl;\n     I8ImplItem,                      \"i8\",                      i8_impl;"}, {"sha": "7ba60f6279177d24e07c6d48dbff975c8403a628", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "patch": "@@ -478,6 +478,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n                 let lang_def_id = lang_items.slice_u8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n+\n+                let lang_def_id = lang_items.slice_u8_alloc_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n                 let lang_def_id = lang_items.const_ptr_impl();"}, {"sha": "d7657bae8c5f6af4d5bb7258fb6542859b257021", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "patch": "@@ -114,139 +114,159 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n             ty::TyChar => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.char_impl(),\n+                                          None,\n                                           \"char\",\n                                           \"char\",\n                                           item.span);\n             }\n             ty::TyStr => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.str_impl(),\n+                                          None,\n                                           \"str\",\n                                           \"str\",\n                                           item.span);\n             }\n             ty::TySlice(slice_item) if slice_item == self.tcx.types.u8 => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.slice_u8_impl(),\n+                                          lang_items.slice_u8_alloc_impl(),\n                                           \"slice_u8\",\n                                           \"[u8]\",\n                                           item.span);\n             }\n             ty::TySlice(_) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.slice_impl(),\n+                                          None,\n                                           \"slice\",\n                                           \"[T]\",\n                                           item.span);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.const_ptr_impl(),\n+                                          None,\n                                           \"const_ptr\",\n                                           \"*const T\",\n                                           item.span);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.mut_ptr_impl(),\n+                                          None,\n                                           \"mut_ptr\",\n                                           \"*mut T\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I8) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i8_impl(),\n+                                          None,\n                                           \"i8\",\n                                           \"i8\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I16) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i16_impl(),\n+                                          None,\n                                           \"i16\",\n                                           \"i16\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I32) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i32_impl(),\n+                                          None,\n                                           \"i32\",\n                                           \"i32\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I64) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i64_impl(),\n+                                          None,\n                                           \"i64\",\n                                           \"i64\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I128) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i128_impl(),\n+                                          None,\n                                           \"i128\",\n                                           \"i128\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::Isize) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.isize_impl(),\n+                                          None,\n                                           \"isize\",\n                                           \"isize\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U8) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u8_impl(),\n+                                          None,\n                                           \"u8\",\n                                           \"u8\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U16) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u16_impl(),\n+                                          None,\n                                           \"u16\",\n                                           \"u16\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U32) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u32_impl(),\n+                                          None,\n                                           \"u32\",\n                                           \"u32\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U64) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u64_impl(),\n+                                          None,\n                                           \"u64\",\n                                           \"u64\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U128) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u128_impl(),\n+                                          None,\n                                           \"u128\",\n                                           \"u128\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::Usize) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.usize_impl(),\n+                                          None,\n                                           \"usize\",\n                                           \"usize\",\n                                           item.span);\n             }\n             ty::TyFloat(ast::FloatTy::F32) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.f32_impl(),\n+                                          None,\n                                           \"f32\",\n                                           \"f32\",\n                                           item.span);\n             }\n             ty::TyFloat(ast::FloatTy::F64) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.f64_impl(),\n+                                          None,\n                                           \"f64\",\n                                           \"f64\",\n                                           item.span);\n@@ -305,11 +325,15 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n     fn check_primitive_impl(&self,\n                             impl_def_id: DefId,\n                             lang_def_id: Option<DefId>,\n+                            lang_def_id2: Option<DefId>,\n                             lang: &str,\n                             ty: &str,\n                             span: Span) {\n-        match lang_def_id {\n-            Some(lang_def_id) if lang_def_id == impl_def_id => {\n+        match (lang_def_id, lang_def_id2) {\n+            (Some(lang_def_id), _) if lang_def_id == impl_def_id => {\n+                // OK\n+            }\n+            (_, Some(lang_def_id)) if lang_def_id == impl_def_id => {\n                 // OK\n             }\n             _ => {"}, {"sha": "4acd12e5862b3b9af0c764c5a7185a3d24927d8c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "patch": "@@ -290,6 +290,7 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n         lang_items.str_impl(),\n         lang_items.slice_impl(),\n         lang_items.slice_u8_impl(),\n+        lang_items.slice_u8_alloc_impl(),\n         lang_items.const_ptr_impl(),\n         lang_items.mut_ptr_impl(),\n     ];"}]}