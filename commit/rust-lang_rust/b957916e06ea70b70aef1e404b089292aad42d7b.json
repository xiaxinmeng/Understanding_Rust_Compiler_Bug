{"sha": "b957916e06ea70b70aef1e404b089292aad42d7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NTc5MTZlMDZlYTcwYjcwYWVmMWU0MDRiMDg5MjkyYWFkNDJkN2I=", "commit": {"author": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2011-12-20T06:55:15Z"}, "committer": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2011-12-20T17:07:36Z"}, "message": "removed math leftovers from std", "tree": {"sha": "2f962e68d62d68d12b59f816d581565acd2af8e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f962e68d62d68d12b59f816d581565acd2af8e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b957916e06ea70b70aef1e404b089292aad42d7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b957916e06ea70b70aef1e404b089292aad42d7b", "html_url": "https://github.com/rust-lang/rust/commit/b957916e06ea70b70aef1e404b089292aad42d7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b957916e06ea70b70aef1e404b089292aad42d7b/comments", "author": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28b825d8469c5b6f92f367cb4aae2ea2607bc886", "url": "https://api.github.com/repos/rust-lang/rust/commits/28b825d8469c5b6f92f367cb4aae2ea2607bc886", "html_url": "https://github.com/rust-lang/rust/commit/28b825d8469c5b6f92f367cb4aae2ea2607bc886"}], "stats": {"total": 858, "additions": 8, "deletions": 850}, "files": [{"sha": "1e32794da5fae0fe56f9225505265e6937c8aa78", "filename": "src/comp/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b957916e06ea70b70aef1e404b089292aad42d7b/src%2Fcomp%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b957916e06ea70b70aef1e404b089292aad42d7b/src%2Fcomp%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Frpath.rs?ref=b957916e06ea70b70aef1e404b089292aad42d7b", "patch": "@@ -3,7 +3,6 @@ import std::fs;\n import std::os_fs;\n import vec;\n import std::map;\n-import std::math;\n import str;\n import uint;\n import metadata::cstore;\n@@ -129,7 +128,7 @@ fn get_relative_to(abs1: fs::path, abs2: fs::path) -> fs::path {\n     assert len1 > 0u;\n     assert len2 > 0u;\n \n-    let max_common_path = math::min(len1, len2) - 1u;\n+    let max_common_path = float::min(len1, len2) - 1u;\n     let start_idx = 0u;\n     while start_idx < max_common_path\n         && split1[start_idx] == split2[start_idx] {"}, {"sha": "cd7e3abd54c83508263d7d1485ef802ae1440ef4", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b957916e06ea70b70aef1e404b089292aad42d7b/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b957916e06ea70b70aef1e404b089292aad42d7b/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=b957916e06ea70b70aef1e404b089292aad42d7b", "patch": "@@ -4,7 +4,6 @@ import uint;\n import std::ufind;\n import std::map;\n import std::map::hashmap;\n-import std::math;\n import option;\n import option::none;\n import option::some;\n@@ -1754,7 +1753,7 @@ mod unify {\n     // Unifies two sets.\n     fn union(cx: @ctxt, set_a: uint, set_b: uint,\n              variance: variance) -> union_result {\n-        ufind::grow(cx.vb.sets, math::max(set_a, set_b) + 1u);\n+        ufind::grow(cx.vb.sets, float::max(set_a, set_b) + 1u);\n         let root_a = ufind::find(cx.vb.sets, set_a);\n         let root_b = ufind::find(cx.vb.sets, set_b);\n "}, {"sha": "6c436dbe8fb5679c8e246dab7a31a27a2e607659", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b957916e06ea70b70aef1e404b089292aad42d7b/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b957916e06ea70b70aef1e404b089292aad42d7b/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=b957916e06ea70b70aef1e404b089292aad42d7b", "patch": "@@ -1,5 +1,5 @@\n import core::{str, option};\n-import std::math::{max, min};\n+import core::float::{max, min};\n import std::map::hashmap;\n import option::{some};\n import syntax::ast;"}, {"sha": "43208bbcb0c02e9e30f3d63e9e69cd0364d492c5", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b957916e06ea70b70aef1e404b089292aad42d7b/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b957916e06ea70b70aef1e404b089292aad42d7b/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=b957916e06ea70b70aef1e404b089292aad42d7b", "patch": "@@ -1,5 +1,5 @@\n import core::{vec, str, int, uint, option, result};\n-import std::{fs, io, math};\n+import std::{fs, io};\n \n import rustc::syntax::{ast, ast_util, fold, visit, codemap};\n import rustc::syntax::parse::parser;\n@@ -241,9 +241,9 @@ fn check_variants_T<copy T>(\n     let L = vec::len(things);\n \n     if L < 100u {\n-        under(math::min(L, 20u)) {|i|\n+        under(float::min(L, 20u)) {|i|\n             log_err \"Replacing... #\" + uint::str(i);\n-            under(math::min(L, 30u)) {|j|\n+            under(float::min(L, 30u)) {|j|\n                 log_err \"With... \" + stringifier(@things[j]);\n                 let crate2 = @replacer(crate, i, things[j], cx.mode);\n                 // It would be best to test the *crate* for stability, but testing the"}, {"sha": "1e4ee49763e989ffcf584c4f4001c8ccd9e5cb25", "filename": "src/libstd/cmath.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/28b825d8469c5b6f92f367cb4aae2ea2607bc886/src%2Flibstd%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b825d8469c5b6f92f367cb4aae2ea2607bc886/src%2Flibstd%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmath.rs?ref=28b825d8469c5b6f92f367cb4aae2ea2607bc886", "patch": "@@ -1,71 +0,0 @@\n-import ctypes::c_int;\n-\n-#[link_name = \"m\"]\n-#[abi = \"cdecl\"]\n-native mod f64 {\n-\n-    // Alpabetically sorted by link_name\n-\n-    pure fn acos(n: f64) -> f64;\n-    pure fn asin(n: f64) -> f64;\n-    pure fn atan(n: f64) -> f64;\n-    pure fn atan2(a: f64, b: f64) -> f64;\n-    pure fn ceil(n: f64) -> f64;\n-    pure fn cos(n: f64) -> f64;\n-    pure fn cosh(n: f64) -> f64;\n-    pure fn exp(n: f64) -> f64;\n-    #[link_name=\"fabs\"] pure fn abs(n: f64) -> f64;\n-    pure fn floor(n: f64) -> f64;\n-    pure fn fmod(x: f64, y: f64) -> f64;\n-    pure fn frexp(n: f64, &value: c_int) -> f64;\n-    pure fn ldexp(x: f64, n: c_int) -> f64;\n-    #[link_name=\"log\"] pure fn ln(n: f64) -> f64;\n-    #[link_name=\"log1p\"] pure fn ln1p(n: f64) -> f64;\n-    pure fn log10(n: f64) -> f64;\n-    pure fn log2(n: f64) -> f64;\n-    pure fn modf(n: f64, iptr: *f64) -> f64;\n-    pure fn pow(n: f64, e: f64) -> f64;\n-    pure fn rint(n: f64) -> f64;\n-    pure fn round(n: f64) -> f64;\n-    pure fn sin(n: f64) -> f64;\n-    pure fn sinh(n: f64) -> f64;\n-    pure fn sqrt(n: f64) -> f64;\n-    pure fn tan(n: f64) -> f64;\n-    pure fn tanh(n: f64) -> f64;\n-    pure fn trunc(n: f64) -> f64;\n-}\n-\n-#[link_name = \"m\"]\n-#[abi = \"cdecl\"]\n-native mod f32 {\n-\n-    // Alpabetically sorted by link_name\n-\n-    #[link_name=\"acosf\"] pure fn acos(n: f32) -> f32;\n-    #[link_name=\"asinf\"] pure fn asin(n: f32) -> f32;\n-    #[link_name=\"atanf\"] pure fn atan(n: f32) -> f32;\n-    #[link_name=\"atan2f\"] pure fn atan2(a: f32, b: f32) -> f32;\n-    #[link_name=\"ceilf\"] pure fn ceil(n: f32) -> f32;\n-    #[link_name=\"cosf\"] pure fn cos(n: f32) -> f32;\n-    #[link_name=\"coshf\"] pure fn cosh(n: f32) -> f32;\n-    #[link_name=\"expf\"] pure fn exp(n: f32) -> f32;\n-    #[link_name=\"fabsf\"] pure fn abs(n: f32) -> f32;\n-    #[link_name=\"floorf\"] pure fn floor(n: f32) -> f32;\n-    #[link_name=\"frexpf\"] pure fn frexp(n: f64, &value: c_int) -> f32;\n-    #[link_name=\"fmodf\"] pure fn fmod(x: f32, y: f32) -> f32;\n-    #[link_name=\"ldexpf\"] pure fn ldexp(x: f32, n: c_int) -> f32;\n-    #[link_name=\"logf\"] pure fn ln(n: f32) -> f32;\n-    #[link_name=\"log1p\"] pure fn ln1p(n: f64) -> f64;\n-    #[link_name=\"log2f\"] pure fn log2(n: f32) -> f32;\n-    #[link_name=\"log10f\"] pure fn log10(n: f32) -> f32;\n-    #[link_name=\"modff\"] pure fn modf(n: f32, iptr: *f32) -> f32;\n-    #[link_name=\"powf\"] pure fn pow(n: f32, e: f32) -> f32;\n-    #[link_name=\"rintf\"] pure fn rint(n: f32) -> f32;\n-    #[link_name=\"roundf\"] pure fn round(n: f32) -> f32;\n-    #[link_name=\"sinf\"] pure fn sin(n: f32) -> f32;\n-    #[link_name=\"sinhf\"] pure fn sinh(n: f32) -> f32;\n-    #[link_name=\"sqrtf\"] pure fn sqrt(n: f32) -> f32;\n-    #[link_name=\"tanf\"] pure fn tan(n: f32) -> f32;\n-    #[link_name=\"tanhf\"] pure fn tanh(n: f32) -> f32;\n-    #[link_name=\"truncf\"] pure fn trunc(n: f32) -> f32;\n-}"}, {"sha": "509eb3ef05762a61d6609216672713d9dc7656d2", "filename": "src/libstd/ctypes.rs", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/28b825d8469c5b6f92f367cb4aae2ea2607bc886/src%2Flibstd%2Fctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b825d8469c5b6f92f367cb4aae2ea2607bc886/src%2Flibstd%2Fctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fctypes.rs?ref=28b825d8469c5b6f92f367cb4aae2ea2607bc886", "patch": "@@ -1,146 +0,0 @@\n-/*\n-Module: ctypes\n-\n-Definitions useful for C interop\n-*/\n-\n-/*\n-FIXME: Add a test that uses some native code to verify these sizes,\n-which are not obviously correct for all potential platforms.\n-*/\n-\n-/*\n-Type: c_int\n-\n-A signed integer with the same size as a C `int`\n-*/\n-type c_int = i32;\n-\n-/*\n-Type: c_uint\n-\n-An unsigned integer with the same size as a C `unsigned int`\n-*/\n-type c_uint = u32;\n-\n-/*\n-Type: long\n-\n-A signed integer with the same size as a C `long`\n-*/\n-type long = int;\n-\n-/*\n-Type: unsigned\n-\n-An unsigned integer with the same size as a C `unsigned int`\n-*/\n-type unsigned = u32;\n-\n-/*\n-Type: ulong\n-\n-An unsigned integer with the same size as a C `unsigned long`\n-*/\n-type ulong = uint;\n-\n-/*\n-Type: intptr_t\n-\n-A signed integer with the same size as a pointer. This is\n-guaranteed to always be the same type as a Rust `int`\n-*/\n-type intptr_t = uint; // FIXME: int\n-\n-/*\n-Type: uintptr_t\n-\n-An unsigned integer with the same size as a pointer. This is\n-guaranteed to always be the same type as a Rust `uint`.\n-*/\n-type uintptr_t = uint;\n-type uint32_t = u32;\n-\n-/*\n-Type: void\n-\n-A type, a pointer to which can be used as C `void *`\n-\n-Note that this does not directly correspond to the C `void` type,\n-which is an incomplete type. Using pointers to this type\n-when interoperating with C void pointers can help in documentation.\n-*/\n-type void = int;\n-\n-// machine type equivalents of rust int, uint, float\n-\n-/*\n-Type: m_int\n-\n-FIXME: What C type does this represent?\n-*/\n-#[cfg(target_arch=\"x86\")]\n-type m_int = i32;\n-#[cfg(target_arch=\"x86_64\")]\n-type m_int = i64;\n-\n-/*\n-Type: m_uint\n-\n-FIXME: What C type does this represent?\n-*/\n-#[cfg(target_arch=\"x86\")]\n-type m_uint = u32;\n-#[cfg(target_arch=\"x86_64\")]\n-type m_uint = u64;\n-\n-// This *must* match with \"import m_float = fXX\" in std::math per arch\n-/*\n-Type: m_float\n-\n-FIXME: What C type does this represent?\n-*/\n-type m_float = f64;\n-\n-/*\n-Type: size_t\n-\n-An unsigned integer corresponding to the C `size_t`\n-*/\n-type size_t = uint;\n-\n-/*\n-Type: ssize_t\n-\n-A signed integer correpsonding to the C `ssize_t`\n-*/\n-type ssize_t = int;\n-\n-/*\n-Type: off_t\n-\n-An unsigned integer corresponding to the C `off_t`\n-*/\n-type off_t = uint;\n-\n-/*\n-Type: fd_t\n-\n-A type that can be used for C file descriptors\n-*/\n-type fd_t = i32;      // not actually a C type, but should be.\n-\n-/*\n-Type: pid_t\n-\n-A type for representing process ID's, corresponding to C `pid_t`\n-*/\n-type pid_t = i32;\n-\n-// enum is implementation-defined, but is 32-bits in practice\n-/*\n-Type: enum\n-\n-An unsigned integer with the same size as a C enum\n-*/\n-type enum = u32;"}, {"sha": "4dba290b6a4e1a0b47a84b660633e6611de6d181", "filename": "src/libstd/math.rs", "status": "removed", "additions": 0, "deletions": 390, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/28b825d8469c5b6f92f367cb4aae2ea2607bc886/src%2Flibstd%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b825d8469c5b6f92f367cb4aae2ea2607bc886/src%2Flibstd%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmath.rs?ref=28b825d8469c5b6f92f367cb4aae2ea2607bc886", "patch": "@@ -1,390 +0,0 @@\n-/*\n-\n-Module: math\n-\n-Floating point operations and constants for `float`s\n-*/\n-\n-export consts;\n-export min, max;\n-\n-// Currently this module supports from -lmath:\n-// C95 + log2 + log1p + trunc + round + rint\n-\n-export\n-    acos, asin, atan, atan2, ceil, cos, cosh, exp, abs, floor, fmod, frexp,\n-    ldexp, ln, ln1p, log10, log2, modf, rint, round, pow, sin, sinh, sqrt,\n-    tan, tanh, trunc;\n-\n-export f64, f32;\n-\n-import f64 = math_f64;\n-import f32 = math_f32;\n-\n-// These two must match in width according to architecture\n-\n-import core::mtypes::m_float;\n-import core::ctypes::c_int;\n-import core::ptr;\n-import m_float = math_f64;\n-\n-/*\n-Module: consts\n-*/\n-mod consts {\n-    /*\n-    Const: pi\n-\n-    Archimedes' constant\n-    */\n-    const pi: float = 3.14159265358979323846264338327950288;\n-\n-    /*\n-    Const: frac_pi_2\n-\n-    pi/2.0\n-    */\n-    const frac_pi_2: float = 1.57079632679489661923132169163975144;\n-\n-    /*\n-    Const: frac_pi_4\n-\n-    pi/4.0\n-    */\n-    const frac_pi_4: float = 0.785398163397448309615660845819875721;\n-\n-    /*\n-    Const: frac_1_pi\n-\n-    1.0/pi\n-    */\n-    const frac_1_pi: float = 0.318309886183790671537767526745028724;\n-\n-    /*\n-    Const: frac_2_pi\n-\n-    2.0/pi\n-    */\n-    const frac_2_pi: float = 0.636619772367581343075535053490057448;\n-\n-    /*\n-    Const: frac_2_sqrtpi\n-\n-    2.0/sqrt(pi)\n-    */\n-    const frac_2_sqrtpi: float = 1.12837916709551257389615890312154517;\n-\n-    /*\n-    Const: sqrt2\n-\n-    sqrt(2.0)\n-    */\n-    const sqrt2: float = 1.41421356237309504880168872420969808;\n-\n-    /*\n-    Const: frac_1_sqrt2\n-\n-    1.0/sqrt(2.0)\n-    */\n-    const frac_1_sqrt2: float = 0.707106781186547524400844362104849039;\n-\n-    /*\n-    Const: e\n-\n-    Euler's number\n-    */\n-    const e: float = 2.71828182845904523536028747135266250;\n-\n-    /*\n-    Const: log2_e\n-\n-    log2(e)\n-    */\n-    const log2_e: float = 1.44269504088896340735992468100189214;\n-\n-    /*\n-    Const: log10_e\n-\n-    log10(e)\n-    */\n-    const log10_e: float = 0.434294481903251827651128918916605082;\n-\n-    /*\n-    Const: ln_2\n-\n-    ln(2.0)\n-    */\n-    const ln_2: float = 0.693147180559945309417232121458176568;\n-\n-    /*\n-    Const: ln_10\n-\n-    ln(10.0)\n-    */\n-    const ln_10: float = 2.30258509299404568401799145468436421;\n-}\n-\n-\n-// FIXME min/max type specialize via libm when overloading works\n-// (in theory fmax/fmin, fmaxf, fminf /should/ be faster)\n-\n-/*\n-Function: min\n-\n-Returns the minimum of two values\n-*/\n-pure fn min<copy T>(x: T, y: T) -> T { x < y ? x : y }\n-\n-/*\n-Function: max\n-\n-Returns the maximum of two values\n-*/\n-pure fn max<copy T>(x: T, y: T) -> T { x < y ? y : x }\n-\n-/*\n-Function: acos\n-\n-Returns the arccosine of an angle (measured in rad)\n-*/\n-pure fn acos(x: float) -> float\n-    { be m_float::acos(x as m_float) as float }\n-\n-/*\n-Function: asin\n-\n-Returns the arcsine of an angle (measured in rad)\n-*/\n-pure fn asin(x: float) -> float\n-    { be m_float::asin(x as m_float) as float }\n-\n-/*\n-Function: atan\n-\n-Returns the arctangents of an angle (measured in rad)\n-*/\n-pure fn atan(x: float) -> float\n-    { be m_float::atan(x as m_float) as float }\n-\n-\n-/*\n-Function: atan2\n-\n-Returns the arctangent of an angle (measured in rad)\n-*/\n-pure fn atan2(y: float, x: float) -> float\n-    { be m_float::atan2(y as m_float, x as m_float) as float }\n-\n-/*\n-Function: ceil\n-\n-Returns the smallest integral value less than or equal to `n`\n-*/\n-pure fn ceil(n: float) -> float\n-    { be m_float::ceil(n as m_float) as float }\n-\n-/*\n-Function: cos\n-\n-Returns the cosine of an angle `x` (measured in rad)\n-*/\n-pure fn cos(x: float) -> float\n-    { be m_float::cos(x as m_float) as float }\n-\n-/*\n-Function: cosh\n-\n-Returns the hyperbolic cosine of `x`\n-\n-*/\n-pure fn cosh(x: float) -> float\n-    { be m_float::cosh(x as m_float) as float }\n-\n-\n-/*\n-Function: exp\n-\n-Returns `consts::e` to the power of `n*\n-*/\n-pure fn exp(n: float) -> float\n-    { be m_float::exp(n as m_float) as float }\n-\n-/*\n-Function: abs\n-\n-Returns the absolute value of  `n`\n-*/\n-pure fn abs(n: float) -> float\n-    { be m_float::abs(n as m_float) as float }\n-\n-/*\n-Function: floor\n-\n-Returns the largest integral value less than or equal to `n`\n-*/\n-pure fn floor(n: float) -> float\n-    { be m_float::floor(n as m_float) as float }\n-\n-/*\n-Function: fmod\n-\n-Returns the floating-point remainder of `x/y`\n-*/\n-pure fn fmod(x: float, y: float) -> float\n-    { be m_float::fmod(x as m_float, y as m_float) as float }\n-\n-/*\n-Function: ln\n-\n-Returns the natural logaritm of `n`\n-*/\n-pure fn ln(n: float) -> float\n-    { be m_float::ln(n as m_float) as float }\n-\n-/*\n-Function: ldexp\n-\n-Returns `x` multiplied by 2 to the power of `n`\n-*/\n-pure fn ldexp(n: float, i: int) -> float\n-    { be m_float::ldexp(n as m_float, i as c_int) as float }\n-\n-/*\n-Function: ln1p\n-\n-Returns the natural logarithm of `1+n` accurately,\n-even for very small values of `n`\n-*/\n-pure fn ln1p(n: float) -> float\n-    { be m_float::ln1p(n as m_float) as float }\n-\n-/*\n-Function: log10\n-\n-Returns the logarithm to base 10 of `n`\n-*/\n-pure fn log10(n: float) -> float\n-    { be m_float::log10(n as m_float) as float }\n-\n-/*\n-Function: log2\n-\n-Returns the logarithm to base 2 of `n`\n-*/\n-pure fn log2(n: float) -> float\n-    { be m_float::log2(n as m_float) as float }\n-\n-/*\n-Function: modf\n-\n-Breaks `n` into integral and fractional parts such that both\n-have the same sign as `n`\n-\n-The integral part is stored in `iptr`.\n-\n-Returns:\n-\n-The fractional part of `n`\n-*/\n-#[no(warn_trivial_casts)] // FIXME Implement\n-pure fn modf(n: float, &iptr: float) -> float { unsafe {\n-    be m_float::modf(n as m_float, ptr::addr_of(iptr) as *m_float) as float\n-} }\n-\n-/*\n-Function: frexp\n-\n-Breaks `n` into a normalized fraction and an integral power of 2\n-\n-The inegral part is stored in iptr.\n-\n-The functions return a number x such that x has a magnitude in the interval\n-[1/2, 1) or 0, and `n == x*(2 to the power of exp)`.\n-\n-Returns:\n-\n-The fractional part of `n`\n-*/\n-pure fn frexp(n: float, &exp: c_int) -> float\n-    { be m_float::frexp(n as m_float, exp) as float }\n-\n-/*\n-Function: pow\n-*/\n-pure fn pow(v: float, e: float) -> float\n-    { be m_float::pow(v as m_float, e as m_float) as float }\n-\n-\n-/*\n-Function: rint\n-\n-Returns the integral value nearest to `x` (according to the\n-prevailing rounding mode) in floating-point format\n-*/\n-pure fn rint(x: float) -> float\n-    { be m_float::rint(x as m_float) as float }\n-\n-/*\n-Function: round\n-\n-\n-Return the integral value nearest to `x` rounding half-way\n-cases away from zero, regardless of the current rounding direction.\n-*/\n-pure fn round(x: float) -> float\n-    { be m_float::round(x as m_float) as float }\n-\n-/*\n-Function: sin\n-\n-Returns the sine of an angle `x` (measured in rad)\n-*/\n-pure fn sin(x: float) -> float\n-    { be m_float::sin(x as m_float) as float }\n-\n-/*\n-Function: sinh\n-\n-Returns the hyperbolic sine of an angle `x` (measured in rad)\n-*/\n-pure fn sinh(x: float) -> float\n-    { be m_float::sinh(x as m_float) as float }\n-\n-/*\n-Function: sqrt\n-\n-Returns the square root of `x`\n-*/\n-pure fn sqrt(x: float) -> float\n-    { be m_float::sqrt(x as m_float) as float }\n-\n-/*\n-Function: tan\n-\n-Returns the tangent of an angle `x` (measured in rad)\n-\n-*/\n-pure fn tan(x: float) -> float\n-    { be m_float::tan(x as m_float) as float }\n-\n-/*\n-Function: tanh\n-\n-Returns the hyperbolic tangent of an angle `x` (measured in rad)\n-\n-*/\n-pure fn tanh(x: float) -> float\n-    { be m_float::tanh(x as m_float) as float }\n-\n-/*\n-Function: trunc\n-\n-Returns the integral value nearest to but no larger in magnitude than `x`\n-\n-*/\n-pure fn trunc(x: float) -> float\n-    { be m_float::trunc(x as m_float) as float }\n-\n-\n-\n-"}, {"sha": "6c36db51a67c1ef255802bde17f655d9aa4a1244", "filename": "src/libstd/math_f32.rs", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/28b825d8469c5b6f92f367cb4aae2ea2607bc886/src%2Flibstd%2Fmath_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b825d8469c5b6f92f367cb4aae2ea2607bc886/src%2Flibstd%2Fmath_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmath_f32.rs?ref=28b825d8469c5b6f92f367cb4aae2ea2607bc886", "patch": "@@ -1,113 +0,0 @@\n-\n-/*\n-Module: math_f32\n-\n-Floating point operations and constants for `f32`\n-\n-This exposes the same operations as `math`, just for `f32` even though\n-they do not show up in the docs right now!\n-*/\n-\n-import cmath::f32::*;\n-\n-export\n-    acos, asin, atan, atan2, ceil, cos, cosh, exp, abs, floor, fmod,\n-    frexp, ldexp, ln, ln1p, log10, log2, modf, rint, round, pow, sin,\n-    sinh, sqrt, tan, tanh, trunc;\n-\n-export consts;\n-\n-/* Module: consts */\n-mod consts {\n-\n-    /*\n-    Const: pi\n-\n-    Archimedes' constant\n-    */\n-    const pi: f32 = 3.14159265358979323846264338327950288f32;\n-\n-    /*\n-    Const: frac_pi_2\n-\n-    pi/2.0\n-    */\n-    const frac_pi_2: f32 = 1.57079632679489661923132169163975144f32;\n-\n-    /*\n-    Const: frac_pi_4\n-\n-    pi/4.0\n-    */\n-    const frac_pi_4: f32 = 0.785398163397448309615660845819875721f32;\n-\n-    /*\n-    Const: frac_1_pi\n-\n-    1.0/pi\n-    */\n-    const frac_1_pi: f32 = 0.318309886183790671537767526745028724f32;\n-\n-    /*\n-    Const: frac_2_pi\n-\n-    2.0/pi\n-    */\n-    const frac_2_pi: f32 = 0.636619772367581343075535053490057448f32;\n-\n-    /*\n-    Const: frac_2_sqrtpi\n-\n-    2.0/sqrt(pi)\n-    */\n-    const frac_2_sqrtpi: f32 = 1.12837916709551257389615890312154517f32;\n-\n-    /*\n-    Const: sqrt2\n-\n-    sqrt(2.0)\n-    */\n-    const sqrt2: f32 = 1.41421356237309504880168872420969808f32;\n-\n-    /*\n-    Const: frac_1_sqrt2\n-\n-    1.0/sqrt(2.0)\n-    */\n-    const frac_1_sqrt2: f32 = 0.707106781186547524400844362104849039f32;\n-\n-    /*\n-    Const: e\n-\n-    Euler's number\n-    */\n-    const e: f32 = 2.71828182845904523536028747135266250f32;\n-\n-    /*\n-    Const: log2_e\n-\n-    log2(e)\n-    */\n-    const log2_e: f32 = 1.44269504088896340735992468100189214f32;\n-\n-    /*\n-    Const: log10_e\n-\n-    log10(e)\n-    */\n-    const log10_e: f32 = 0.434294481903251827651128918916605082f32;\n-\n-    /*\n-    Const: ln_2\n-\n-    ln(2.0)\n-    */\n-    const ln_2: f32 = 0.693147180559945309417232121458176568f32;\n-\n-    /*\n-    Const: ln_10\n-\n-    ln(10.0)\n-    */\n-    const ln_10: f32 = 2.30258509299404568401799145468436421f32;\n-}\n\\ No newline at end of file"}, {"sha": "659bf2c5b1402cbb251f25df8660a2c24bdfa419", "filename": "src/libstd/math_f64.rs", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/28b825d8469c5b6f92f367cb4aae2ea2607bc886/src%2Flibstd%2Fmath_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b825d8469c5b6f92f367cb4aae2ea2607bc886/src%2Flibstd%2Fmath_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmath_f64.rs?ref=28b825d8469c5b6f92f367cb4aae2ea2607bc886", "patch": "@@ -1,114 +0,0 @@\n-\n-/*\n-Module: math_f64\n-\n-Floating point operations and constants for `f64`s\n-\n-This exposes the same operations as `math`, just for `f64` even though\n-they do not show up in the docs right now!\n-*/\n-\n-import cmath::f64::*;\n-\n-export\n-    acos, asin, atan, atan2, ceil, cos, cosh, exp, abs, floor, fmod,\n-    frexp, ldexp, ln, ln1p, log10, log2, modf, rint, round, pow, sin,\n-    sinh, sqrt, tan, tanh, trunc;\n-\n-export consts;\n-\n-\n-/* Module: consts */\n-mod consts {\n-\n-    /*\n-    Const: pi\n-\n-    Archimedes' constant\n-    */\n-    const pi: f64 = 3.14159265358979323846264338327950288f64;\n-\n-    /*\n-    Const: frac_pi_2\n-\n-    pi/2.0\n-    */\n-    const frac_pi_2: f64 = 1.57079632679489661923132169163975144f64;\n-\n-    /*\n-    Const: frac_pi_4\n-\n-    pi/4.0\n-    */\n-    const frac_pi_4: f64 = 0.785398163397448309615660845819875721f64;\n-\n-    /*\n-    Const: frac_1_pi\n-\n-    1.0/pi\n-    */\n-    const frac_1_pi: f64 = 0.318309886183790671537767526745028724f64;\n-\n-    /*\n-    Const: frac_2_pi\n-\n-    2.0/pi\n-    */\n-    const frac_2_pi: f64 = 0.636619772367581343075535053490057448f64;\n-\n-    /*\n-    Const: frac_2_sqrtpi\n-\n-    2.0/sqrt(pi)\n-    */\n-    const frac_2_sqrtpi: f64 = 1.12837916709551257389615890312154517f64;\n-\n-    /*\n-    Const: sqrt2\n-\n-    sqrt(2.0)\n-    */\n-    const sqrt2: f64 = 1.41421356237309504880168872420969808f64;\n-\n-    /*\n-    Const: frac_1_sqrt2\n-\n-    1.0/sqrt(2.0)\n-    */\n-    const frac_1_sqrt2: f64 = 0.707106781186547524400844362104849039f64;\n-\n-    /*\n-    Const: e\n-\n-    Euler's number\n-    */\n-    const e: f64 = 2.71828182845904523536028747135266250f64;\n-\n-    /*\n-    Const: log2_e\n-\n-    log2(e)\n-    */\n-    const log2_e: f64 = 1.44269504088896340735992468100189214f64;\n-\n-    /*\n-    Const: log10_e\n-\n-    log10(e)\n-    */\n-    const log10_e: f64 = 0.434294481903251827651128918916605082f64;\n-\n-    /*\n-    Const: ln_2\n-\n-    ln(2.0)\n-    */\n-    const ln_2: f64 = 0.693147180559945309417232121458176568f64;\n-\n-    /*\n-    Const: ln_10\n-\n-    ln(10.0)\n-    */\n-    const ln_10: f64 = 2.30258509299404568401799145468436421f64;\n-}\n\\ No newline at end of file"}, {"sha": "bcd2b82cf1a1af5654c50e0d30c681af5173e529", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b957916e06ea70b70aef1e404b089292aad42d7b/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b957916e06ea70b70aef1e404b089292aad42d7b/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=b957916e06ea70b70aef1e404b089292aad42d7b", "patch": "@@ -8,10 +8,9 @@\n #[crate_type = \"lib\"];\n \n export comm, fs, io, net, run, uv;\n-export c_vec, ctypes, four, tri, util;\n+export c_vec, four, tri, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n export rope;\n-export math;\n export ebml, dbg, getopts, json, rand, sha1, term, time;\n export extfmt, test, tempfile;\n // FIXME: generic_os and os_fs shouldn't be exported\n@@ -32,10 +31,6 @@ mod uv;\n // Utility modules\n \n mod c_vec;\n-mod ctypes;\n-mod cmath; /* unexported */\n-mod math_f32;\n-mod math_f64;\n mod four;\n mod tri;\n mod util;\n@@ -61,7 +56,6 @@ mod ebml;\n mod dbg;\n mod getopts;\n mod json;\n-mod math;\n mod rand;\n mod sha1;\n mod tempfile;"}, {"sha": "51531f0863d6e41176f378ae244f72bc150c1afe", "filename": "src/test/stdtest/math.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b957916e06ea70b70aef1e404b089292aad42d7b/src%2Ftest%2Fstdtest%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b957916e06ea70b70aef1e404b089292aad42d7b/src%2Ftest%2Fstdtest%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmath.rs?ref=b957916e06ea70b70aef1e404b089292aad42d7b", "patch": "@@ -251,7 +251,7 @@ fn test_angle() {\n         alt vec {\n           (0f, y) when y < 0f { 1.5 * consts::pi }\n           (0f, y) { 0.5 * consts::pi }\n-          (x, y) { std::math::atan(y / x) }\n+          (x, y) { float::atan(y / x) }\n         }\n     }\n     assert angle((1f, 0f)) == 0f;"}]}