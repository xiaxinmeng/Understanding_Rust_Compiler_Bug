{"sha": "fdbd56ca38c4a58377056c63e0b03b0d4e131f2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkYmQ1NmNhMzhjNGE1ODM3NzA1NmM2M2UwYjAzYjBkNGUxMzFmMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-20T09:16:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-20T09:16:41Z"}, "message": "auto merge of #7419 : catamorphism/rust/default-package, r=graydon\n\nr? @brson `rustpkg build`, if executed in a package source directory inside\r\na workspace, will now build that package. By \"inside a workspace\"\r\nI mean that the parent directory has to be called `src`, and rustpkg\r\nwill create a `build` directory in .. if there isn't already one.\r\n\r\nSame goes for `rustpkg install` and `rustpkg clean`.\r\n\r\nFor the time being, `rustpkg build` (etc.) will still error out if\r\nyou run it inside a directory whose parent isn't called `src`.\r\nI'm not sure whether or not it's desirable to have it do something\r\nin a non-workspace directory.", "tree": {"sha": "7c6cad3f140361d7939bc3d45c8c4ff6a14aefcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c6cad3f140361d7939bc3d45c8c4ff6a14aefcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c", "html_url": "https://github.com/rust-lang/rust/commit/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "098709aa638bb29998b5e6f2700997b13c2c6712", "url": "https://api.github.com/repos/rust-lang/rust/commits/098709aa638bb29998b5e6f2700997b13c2c6712", "html_url": "https://github.com/rust-lang/rust/commit/098709aa638bb29998b5e6f2700997b13c2c6712"}, {"sha": "e39ea2a5c880b252abbf37dade7a9b7ce7b2cb40", "url": "https://api.github.com/repos/rust-lang/rust/commits/e39ea2a5c880b252abbf37dade7a9b7ce7b2cb40", "html_url": "https://github.com/rust-lang/rust/commit/e39ea2a5c880b252abbf37dade7a9b7ce7b2cb40"}], "stats": {"total": 280, "additions": 210, "deletions": 70}, "files": [{"sha": "5f1e0594c47cd1659bbd5ec2b88528894b31076e", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=fdbd56ca38c4a58377056c63e0b03b0d4e131f2c", "patch": "@@ -18,11 +18,18 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n     for workspaces.iter().advance |p| {\n         let binfiles = os::list_dir(&p.push(\"bin\"));\n         for binfiles.iter().advance() |exec| {\n-            f(&PkgId::new(*exec, p));\n+            let exec_path = Path(*exec).filestem();\n+            do exec_path.iter().advance |s| {\n+                f(&PkgId::new(*s, p))\n+            };\n         }\n         let libfiles = os::list_dir(&p.push(\"lib\"));\n         for libfiles.iter().advance() |lib| {\n-            f(&PkgId::new(*lib, p));\n+            debug!(\"Full name: %s\", *lib);\n+            let lib_path = Path(*lib).filestem();\n+            do lib_path.iter().advance |s| {\n+                f(&PkgId::new(*s, p))\n+            };\n         }\n     }\n     true"}, {"sha": "ed5b1118a9c7c7d90426406f86bf3639274a9b15", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=fdbd56ca38c4a58377056c63e0b03b0d4e131f2c", "patch": "@@ -54,11 +54,17 @@ pub fn rust_path() -> ~[Path] {\n     };\n     let cwd = os::getcwd();\n     // now add in default entries\n-    env_rust_path.push(cwd.push(\".rust\"));\n     env_rust_path.push(cwd.clone());\n     do cwd.each_parent() |p| { push_if_exists(&mut env_rust_path, p) };\n     let h = os::homedir();\n-    for h.iter().advance |h| { push_if_exists(&mut env_rust_path, h); }\n+    // Avoid adding duplicates\n+    // could still add dups if someone puts one of these in the RUST_PATH\n+    // manually, though...\n+    for h.iter().advance |hdir| {\n+        if !(cwd.is_ancestor_of(hdir) || hdir.is_ancestor_of(&cwd)) {\n+            push_if_exists(&mut env_rust_path, hdir);\n+        }\n+    }\n     env_rust_path\n }\n "}, {"sha": "f2e39a8e5ed70be08709ed6290d41d66382082ab", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 52, "deletions": 38, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=fdbd56ca38c4a58377056c63e0b03b0d4e131f2c", "patch": "@@ -42,7 +42,7 @@ use path_util::{U_RWX, rust_path, in_rust_path};\n use path_util::{built_executable_in_workspace, built_library_in_workspace, default_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n use source_control::is_git_dir;\n-use workspace::{each_pkg_parent_workspace, pkg_parent_workspaces};\n+use workspace::{each_pkg_parent_workspace, pkg_parent_workspaces, in_workspace, cwd_to_workspace};\n use context::Ctx;\n use package_id::PkgId;\n use package_source::PkgSrc;\n@@ -199,26 +199,41 @@ impl CtxMethods for Ctx {\n         match cmd {\n             \"build\" => {\n                 if args.len() < 1 {\n-                    return usage::build();\n+                    if !in_workspace(|| { usage::build() } ) {\n+                        return;\n+                    }\n+                    let (workspace, pkgid) = cwd_to_workspace();\n+                    self.build(&workspace, &pkgid);\n                 }\n-                // The package id is presumed to be the first command-line\n-                // argument\n-                let pkgid = PkgId::new(args[0].clone(), &os::getcwd());\n-                for each_pkg_parent_workspace(&pkgid) |workspace| {\n-                    debug!(\"found pkg %s in workspace %s, trying to build\",\n-                           pkgid.to_str(), workspace.to_str());\n-                    self.build(workspace, &pkgid);\n+                else {\n+                    // The package id is presumed to be the first command-line\n+                    // argument\n+                    let pkgid = PkgId::new(args[0].clone(), &os::getcwd());\n+                    for each_pkg_parent_workspace(&pkgid) |workspace| {\n+                        debug!(\"found pkg %s in workspace %s, trying to build\",\n+                               pkgid.to_str(), workspace.to_str());\n+                        self.build(workspace, &pkgid);\n+                    }\n                 }\n             }\n             \"clean\" => {\n                 if args.len() < 1 {\n-                    return usage::build();\n+                    if !in_workspace(|| { usage::clean() } ) {\n+                        return;\n+                    }\n+                    // tjc: Maybe clean should clean all the packages in the\n+                    // current workspace, though?\n+                    let (workspace, pkgid) = cwd_to_workspace();\n+                    self.clean(&workspace, &pkgid);\n+\n+                }\n+                else {\n+                    // The package id is presumed to be the first command-line\n+                    // argument\n+                    let pkgid = PkgId::new(args[0].clone(), &os::getcwd());\n+                    let cwd = os::getcwd();\n+                    self.clean(&cwd, &pkgid); // tjc: should use workspace, not cwd\n                 }\n-                // The package id is presumed to be the first command-line\n-                // argument\n-                let pkgid = PkgId::new(args[0].clone(), &os::getcwd());\n-                let cwd = os::getcwd();\n-                self.clean(&cwd, &pkgid); // tjc: should use workspace, not cwd\n             }\n             \"do\" => {\n                 if args.len() < 2 {\n@@ -232,37 +247,36 @@ impl CtxMethods for Ctx {\n             }\n             \"install\" => {\n                 if args.len() < 1 {\n-                    return usage::install();\n-                }\n-\n-                // The package id is presumed to be the first command-line\n-                // argument\n-                let pkgid = PkgId::new(args[0], &os::getcwd());\n-                let workspaces = pkg_parent_workspaces(&pkgid);\n-                if workspaces.is_empty() {\n-                    debug!(\"install! workspaces was empty\");\n-                    let rp = rust_path();\n-                    assert!(!rp.is_empty());\n-                    let src = PkgSrc::new(&rp[0], &build_pkg_id_in_workspace(&pkgid, &rp[0]),\n-                                          &pkgid);\n-                    src.fetch_git();\n-                    self.install(&rp[0], &pkgid);\n+                    if !in_workspace(|| { usage::install() }) {\n+                        return;\n+                    }\n+                    let (workspace, pkgid) = cwd_to_workspace();\n+                    self.install(&workspace, &pkgid);\n                 }\n                 else {\n-                    for each_pkg_parent_workspace(&pkgid) |workspace| {\n-                        debug!(\"install: found pkg %s in workspace %s, trying to build\",\n-                               pkgid.to_str(), workspace.to_str());\n-\n-                        self.install(workspace, &pkgid);\n+                    // The package id is presumed to be the first command-line\n+                    // argument\n+                    let pkgid = PkgId::new(args[0], &os::getcwd());\n+                    let workspaces = pkg_parent_workspaces(&pkgid);\n+                    if workspaces.is_empty() {\n+                        let rp = rust_path();\n+                        assert!(!rp.is_empty());\n+                        let src = PkgSrc::new(&rp[0], &build_pkg_id_in_workspace(&pkgid, &rp[0]),\n+                                              &pkgid);\n+                        src.fetch_git();\n+                        self.install(&rp[0], &pkgid);\n+                    }\n+                    else {\n+                        for each_pkg_parent_workspace(&pkgid) |workspace| {\n+                            self.install(workspace, &pkgid);\n+                        }\n                     }\n                 }\n             }\n             \"list\" => {\n                 io::println(\"Installed packages:\");\n                 for installed_packages::list_installed_packages |pkg_id| {\n-                    io::println(fmt!(\"%s-%s\",\n-                                     pkg_id.local_path.to_str(),\n-                                     pkg_id.version.to_str()));\n+                    io::println(pkg_id.local_path.to_str());\n                 }\n             }\n             \"prefer\" => {"}, {"sha": "7953d4545a8458844088bdf58b4607ab074b99f4", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 73, "deletions": 23, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=fdbd56ca38c4a58377056c63e0b03b0d4e131f2c", "patch": "@@ -218,7 +218,6 @@ fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~str)]>)\n     -> ProcessOutput {\n     let cmd = test_sysroot().push(\"bin\").push(\"rustpkg\").to_str();\n-    let cwd = normalize(RemotePath((*cwd).clone()));\n     debug!(\"About to run command: %? %? in %s\", cmd, args, cwd.to_str());\n     assert!(os::path_is_dir(&*cwd));\n     let cwd = (*cwd).clone();\n@@ -322,6 +321,14 @@ fn assert_executable_exists(repo: &Path, short_name: &str) {\n     assert!(is_rwx(&exec));\n }\n \n+fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n+    debug!(\"assert_built_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    let exec = built_executable_in_workspace(&PkgId::new(short_name, repo),\n+                                             repo).expect(\"assert_built_executable_exists failed\");\n+    assert!(os::path_exists(&exec));\n+    assert!(is_rwx(&exec));\n+}\n+\n fn command_line_test_output(args: &[~str]) -> ~[~str] {\n     let mut result = ~[];\n     let p_output = command_line_test(args, &os::getcwd());\n@@ -490,30 +497,29 @@ fn test_install_git() {\n     // should have test, bench, lib, and main\n     command_line_test([~\"install\", temp_pkg_id.local_path.to_str()], &repo);\n     // Check that all files exist\n-    let ws = repo.push(\".rust\");\n-    debug!(\"Checking for files in %s\", ws.to_str());\n-    let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n+    debug!(\"Checking for files in %s\", repo.to_str());\n+    let exec = target_executable_in_workspace(&temp_pkg_id, &repo);\n     debug!(\"exec = %s\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n     let _built_lib =\n         built_library_in_workspace(&temp_pkg_id,\n-                                   &ws).expect(\"test_install_git: built lib should exist\");\n-    let lib = target_library_in_workspace(&temp_pkg_id, &ws);\n+                                   &repo).expect(\"test_install_git: built lib should exist\");\n+    let lib = target_library_in_workspace(&temp_pkg_id, &repo);\n     debug!(\"lib = %s\", lib.to_str());\n     assert!(os::path_exists(&lib));\n     assert!(is_rwx(&lib));\n     let built_test = built_test_in_workspace(&temp_pkg_id,\n-                         &ws).expect(\"test_install_git: built test should exist\");\n+                         &repo).expect(\"test_install_git: built test should exist\");\n     assert!(os::path_exists(&built_test));\n     let built_bench = built_bench_in_workspace(&temp_pkg_id,\n-                          &ws).expect(\"test_install_git: built bench should exist\");\n+                          &repo).expect(\"test_install_git: built bench should exist\");\n     assert!(os::path_exists(&built_bench));\n     // And that the test and bench executables aren't installed\n-    let test = target_test_in_workspace(&temp_pkg_id, &ws);\n+    let test = target_test_in_workspace(&temp_pkg_id, &repo);\n     assert!(!os::path_exists(&test));\n     debug!(\"test = %s\", test.to_str());\n-    let bench = target_bench_in_workspace(&temp_pkg_id, &ws);\n+    let bench = target_bench_in_workspace(&temp_pkg_id, &repo);\n     debug!(\"bench = %s\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n }\n@@ -586,12 +592,12 @@ fn test_package_version() {\n     command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg_version\"],\n                       &repo);\n     assert!(match built_library_in_workspace(&temp_pkg_id,\n-                                             &repo.push(\".rust\")) {\n+                                             &repo) {\n         Some(p) => p.to_str().ends_with(fmt!(\"0.4%s\", os::consts::DLL_SUFFIX)),\n         None    => false\n     });\n-    assert!(built_executable_in_workspace(&temp_pkg_id, &repo.push(\".rust\"))\n-            == Some(repo.push(\".rust\").push(\"build\").\n+    assert!(built_executable_in_workspace(&temp_pkg_id, &repo)\n+            == Some(repo.push(\"build\").\n                     push(\"mockgithub.com\").\n                     push(\"catamorphism\").\n                     push(\"test_pkg_version\").\n@@ -689,7 +695,7 @@ fn rustpkg_library_target() {\n \n     add_git_tag(&package_dir, ~\"1.0\");\n     command_line_test([~\"install\", ~\"foo\"], &foo_repo);\n-    assert_lib_exists(&foo_repo.push(\".rust\"), \"foo\", ExactRevision(~\"1.0\"));\n+    assert_lib_exists(&foo_repo, \"foo\", ExactRevision(~\"1.0\"));\n }\n \n #[test]\n@@ -716,14 +722,55 @@ fn package_script_with_default_build() {\n     assert!(os::path_exists(&dir.push(\"build\").push(\"fancy_lib\").push(\"generated.rs\")));\n }\n \n+#[test]\n+fn rustpkg_build_no_arg() {\n+    let tmp = mkdtemp(&os::tmpdir(), \"rustpkg_build_no_arg\").expect(\"rustpkg_build_no_arg failed\");\n+    let package_dir = tmp.push(\"src\").push(\"foo\");\n+    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+\n+    writeFile(&package_dir.push(\"main.rs\"),\n+              \"fn main() { let _x = (); }\");\n+    debug!(\"build_no_arg: dir = %s\", package_dir.to_str());\n+    command_line_test([~\"build\"], &package_dir);\n+    assert_built_executable_exists(&tmp, \"foo\");\n+}\n+\n+#[test]\n+fn rustpkg_install_no_arg() {\n+    let tmp = mkdtemp(&os::tmpdir(),\n+                      \"rustpkg_install_no_arg\").expect(\"rustpkg_build_no_arg failed\");\n+    let package_dir = tmp.push(\"src\").push(\"foo\");\n+    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    writeFile(&package_dir.push(\"lib.rs\"),\n+              \"fn main() { let _x = (); }\");\n+    debug!(\"install_no_arg: dir = %s\", package_dir.to_str());\n+    command_line_test([~\"install\"], &package_dir);\n+    assert_lib_exists(&tmp, \"foo\", NoVersion);\n+}\n+\n+#[test]\n+fn rustpkg_clean_no_arg() {\n+    let tmp = mkdtemp(&os::tmpdir(), \"rustpkg_clean_no_arg\").expect(\"rustpkg_clean_no_arg failed\");\n+    let package_dir = tmp.push(\"src\").push(\"foo\");\n+    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+\n+    writeFile(&package_dir.push(\"main.rs\"),\n+              \"fn main() { let _x = (); }\");\n+    debug!(\"clean_no_arg: dir = %s\", package_dir.to_str());\n+    command_line_test([~\"build\"], &package_dir);\n+    assert_built_executable_exists(&tmp, \"foo\");\n+    command_line_test([~\"clean\"], &package_dir);\n+    assert!(!built_executable_in_workspace(&PkgId::new(\"foo\", &package_dir),\n+                &tmp).map_default(false, |m| { os::path_exists(m) }));\n+}\n+\n #[test]\n #[ignore (reason = \"Un-ignore when #7071 is fixed\")]\n fn rust_path_test() {\n     let dir_for_path = mkdtemp(&os::tmpdir(), \"more_rust\").expect(\"rust_path_test failed\");\n     let dir = mk_workspace(&dir_for_path, &normalize(RemotePath(Path(\"foo\"))), &NoVersion);\n     debug!(\"dir = %s\", dir.to_str());\n-    writeFile(&Path(\"/Users/tjc/more_rust/src/foo-0.1/main.rs\"),\n-              \"fn main() { let _x = (); }\");\n+    writeFile(&dir.push(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n     let cwd = os::getcwd();\n     debug!(\"cwd = %s\", cwd.to_str());\n@@ -781,21 +828,24 @@ fn test_list() {\n     let quux = PkgId::new(\"quux\", &dir);\n     create_local_package_in(&quux, &dir);\n \n+// NOTE Not really great output, though...\n+// NOTE do any tests need to be unignored?\n     command_line_test([~\"install\", ~\"foo\"], &dir);\n     let env_arg = ~[(~\"RUST_PATH\", dir.to_str())];\n+    debug!(\"RUST_PATH = %s\", dir.to_str());\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg.clone());\n-    assert!(list_output.iter().any(|x| x.starts_with(\"foo-\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"libfoo_\")));\n \n     command_line_test([~\"install\", ~\"bar\"], &dir);\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg.clone());\n-    assert!(list_output.iter().any(|x| x.starts_with(\"foo-\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"bar-\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"libfoo_\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"libbar_\")));\n \n     command_line_test([~\"install\", ~\"quux\"], &dir);\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg);\n-    assert!(list_output.iter().any(|x| x.starts_with(\"foo-\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"bar-\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"quux-\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"libfoo_\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"libbar_\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"libquux_\")));\n }\n \n #[test]\n@@ -836,7 +886,7 @@ fn install_check_duplicates() {\n     let mut contents = ~[];\n     let check_dups = |p: &PkgId| {\n         if contents.contains(p) {\n-            fail!(\"package database contains duplicate ID\");\n+            fail!(\"package %s appears in `list` output more than once\", p.local_path.to_str());\n         }\n         else {\n             contents.push((*p).clone());"}, {"sha": "87ab3882df19618cb4f685eb4cbcb72307f954ad", "filename": "src/librustpkg/usage.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=fdbd56ca38c4a58377056c63e0b03b0d4e131f2c", "patch": "@@ -23,10 +23,11 @@ Options:\n }\n \n pub fn build() {\n-    io::println(\"rustpkg [options..] build\n+    io::println(\"rustpkg [options..] build [package-ID]\n \n-Build all targets described in the package script in the current\n-directory.\n+Build the given package ID if specified. With no package ID argument,\n+build the package in the current directory. In that case, the current\n+directory must be a direct child of an `src` directory in a workspace.\n \n Options:\n     -c, --cfg      Pass a cfg flag to the package script\");"}, {"sha": "952352a02a5fc43b45b8bd8fd742c73b74cacbc6", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=fdbd56ca38c4a58377056c63e0b03b0d4e131f2c", "patch": "@@ -10,9 +10,10 @@\n \n // rustpkg utilities having to do with workspaces\n \n+use std::os;\n+use std::path::Path;\n use path_util::{rust_path, workspace_contains_package_id};\n use package_id::PkgId;\n-use std::path::Path;\n \n pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n@@ -38,3 +39,24 @@ pub fn pkg_parent_workspaces(pkgid: &PkgId) -> ~[Path] {\n         .filter(|ws| workspace_contains_package_id(pkgid, ws))\n         .collect()\n }\n+\n+pub fn in_workspace(complain: &fn()) -> bool {\n+    let dir_part = os::getcwd().pop().components.clone();\n+    if  *(dir_part.last()) != ~\"src\" {\n+        complain();\n+        false\n+    }\n+    else {\n+        true\n+    }\n+}\n+\n+/// Construct a workspace and package-ID name based on the current directory.\n+/// This gets used when rustpkg gets invoked without a package-ID argument.\n+pub fn cwd_to_workspace() -> (Path, PkgId) {\n+    let cwd = os::getcwd();\n+    let ws = cwd.pop().pop();\n+    let cwd_ = cwd.clone();\n+    let pkgid = cwd_.components.last().to_str();\n+    (ws, PkgId::new(pkgid, &cwd))\n+}"}, {"sha": "3ec3407b1cc55c2bd88261fafe945eb58eba5051", "filename": "src/libstd/path.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdbd56ca38c4a58377056c63e0b03b0d4e131f2c/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=fdbd56ca38c4a58377056c63e0b03b0d4e131f2c", "patch": "@@ -122,6 +122,9 @@ pub trait GenericPath {\n \n     /// Returns `true` if `self` is an absolute path.\n     fn is_absolute(&self) -> bool;\n+\n+    /// True if `self` is an ancestor of `other`. See `test_is_ancestor_of` for examples\n+    fn is_ancestor_of(&self, (&Self)) -> bool;\n }\n \n #[cfg(target_os = \"linux\")]\n@@ -698,6 +701,15 @@ impl GenericPath for PosixPath {\n     fn is_absolute(&self) -> bool {\n         self.is_absolute\n     }\n+\n+    fn is_ancestor_of(&self, other: &PosixPath) -> bool {\n+        debug!(\"%s / %s %? %?\", self.to_str(), other.to_str(), self.is_absolute,\n+               self.components.len());\n+        self == other ||\n+            (!other.components.is_empty() && !(self.components.is_empty() && !self.is_absolute) &&\n+             self.is_ancestor_of(&other.pop()))\n+    }\n+\n }\n \n \n@@ -974,8 +986,13 @@ impl GenericPath for WindowsPath {\n     fn is_absolute(&self) -> bool {\n         self.is_absolute\n     }\n-}\n \n+    fn is_ancestor_of(&self, other: &WindowsPath) -> bool {\n+        self == other ||\n+            (!other.components.is_empty() && !(self.components.is_empty() && !self.is_absolute) &&\n+             self.is_ancestor_of(&other.pop()))\n+    }\n+}\n \n pub fn normalize(components: &[~str]) -> ~[~str] {\n     let mut cs = ~[];\n@@ -1290,4 +1307,27 @@ mod tests {\n         assert_eq!(WindowsPath(\"C:\\\\COM1.TXT\").is_restricted(), true);\n         assert_eq!(WindowsPath(\"c:\\\\prn.exe\").is_restricted(), true);\n     }\n+\n+    #[test]\n+    fn test_is_ancestor_of() {\n+        assert!(&PosixPath(\"/a/b\").is_ancestor_of(&PosixPath(\"/a/b/c/d\")));\n+        assert!(!&PosixPath(\"/a/b/c/d\").is_ancestor_of(&PosixPath(\"/a/b\")));\n+        assert!(!&PosixPath(\"/a/b\").is_ancestor_of(&PosixPath(\"/c/d\")));\n+        assert!(&PosixPath(\"/a/b\").is_ancestor_of(&PosixPath(\"/a/b/c/d\")));\n+        assert!(&PosixPath(\"/\").is_ancestor_of(&PosixPath(\"/a/b/c\")));\n+        assert!(!&PosixPath(\"/\").is_ancestor_of(&PosixPath(\"\")));\n+        assert!(!&PosixPath(\"/a/b/c\").is_ancestor_of(&PosixPath(\"\")));\n+        assert!(!&PosixPath(\"\").is_ancestor_of(&PosixPath(\"/a/b/c\")));\n+\n+        assert!(&WindowsPath(\"C:\\\\a\\\\b\").is_ancestor_of(&WindowsPath(\"C:\\\\a\\\\b\\\\c\\\\d\")));\n+        assert!(!&WindowsPath(\"C:\\\\a\\\\b\\\\c\\\\d\").is_ancestor_of(&WindowsPath(\"C:\\\\a\\\\b\")));\n+        assert!(!&WindowsPath(\"C:\\\\a\\\\b\").is_ancestor_of(&WindowsPath(\"C:\\\\c\\\\d\")));\n+        assert!(&WindowsPath(\"C:\\\\a\\\\b\").is_ancestor_of(&WindowsPath(\"C:\\\\a\\\\b\\\\c\\\\d\")));\n+        assert!(&WindowsPath(\"C:\\\\\").is_ancestor_of(&WindowsPath(\"C:\\\\a\\\\b\\\\c\")));\n+        assert!(!&WindowsPath(\"C:\\\\\").is_ancestor_of(&WindowsPath(\"\")));\n+        assert!(!&WindowsPath(\"C:\\\\a\\\\b\\\\c\").is_ancestor_of(&WindowsPath(\"\")));\n+        assert!(!&WindowsPath(\"\").is_ancestor_of(&WindowsPath(\"C:\\\\a\\\\b\\\\c\")));\n+\n+    }\n+\n }"}]}