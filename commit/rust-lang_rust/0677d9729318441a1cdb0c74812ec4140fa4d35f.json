{"sha": "0677d9729318441a1cdb0c74812ec4140fa4d35f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NzdkOTcyOTMxODQ0MWExY2RiMGM3NDgxMmVjNDE0MGZhNGQzNWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-18T05:44:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-18T05:44:40Z"}, "message": "Auto merge of #80865 - oliviacrain:proj_based, r=RalfJung\n\nUse PlaceRef projection abstractions more consistently in rustc_mir\n\nPlaceRef contains abstractions for dealing with the `projections` array. This PR uses these abstractions more consistently within the `rustc_mir` crate.\n\nSee associated issue: rust-lang/rust#80647.\n\nr? `@RalfJung`", "tree": {"sha": "0a41236ac75a51206bff2340a8d3d677e44db434", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a41236ac75a51206bff2340a8d3d677e44db434"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0677d9729318441a1cdb0c74812ec4140fa4d35f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0677d9729318441a1cdb0c74812ec4140fa4d35f", "html_url": "https://github.com/rust-lang/rust/commit/0677d9729318441a1cdb0c74812ec4140fa4d35f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0677d9729318441a1cdb0c74812ec4140fa4d35f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93e0aedb0710f3636ccb7ab48690af9d3b8a87f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/93e0aedb0710f3636ccb7ab48690af9d3b8a87f8", "html_url": "https://github.com/rust-lang/rust/commit/93e0aedb0710f3636ccb7ab48690af9d3b8a87f8"}, {"sha": "65b5e4386b5462e8c086b7d00e5ea1eab00d2914", "url": "https://api.github.com/repos/rust-lang/rust/commits/65b5e4386b5462e8c086b7d00e5ea1eab00d2914", "html_url": "https://github.com/rust-lang/rust/commit/65b5e4386b5462e8c086b7d00e5ea1eab00d2914"}], "stats": {"total": 227, "additions": 103, "deletions": 124}, "files": [{"sha": "8f41bfae2fdf5d6d3423f9f9b01748f3f8690452", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=0677d9729318441a1cdb0c74812ec4140fa4d35f", "patch": "@@ -1616,28 +1616,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn classify_drop_access_kind(&self, place: PlaceRef<'tcx>) -> StorageDeadOrDrop<'tcx> {\n         let tcx = self.infcx.tcx;\n-        match place.projection {\n-            [] => StorageDeadOrDrop::LocalStorageDead,\n-            [proj_base @ .., elem] => {\n+        match place.last_projection() {\n+            None => StorageDeadOrDrop::LocalStorageDead,\n+            Some((place_base, elem)) => {\n                 // FIXME(spastorino) make this iterate\n-                let base_access = self.classify_drop_access_kind(PlaceRef {\n-                    local: place.local,\n-                    projection: proj_base,\n-                });\n+                let base_access = self.classify_drop_access_kind(place_base);\n                 match elem {\n                     ProjectionElem::Deref => match base_access {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                Place::ty_from(place.local, proj_base, self.body, tcx).ty.is_box(),\n+                                place_base.ty(self.body, tcx).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = Place::ty_from(place.local, proj_base, self.body, tcx).ty;\n+                        let base_ty = place_base.ty(self.body, tcx).ty;\n                         match base_ty.kind() {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor\n@@ -1652,7 +1649,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             _ => base_access,\n                         }\n                     }\n-\n                     ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n                     | ProjectionElem::Index(_) => base_access,"}, {"sha": "6d98bf554f1cf34c7046659239c318cbb8ea978f", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=0677d9729318441a1cdb0c74812ec4140fa4d35f", "patch": "@@ -338,8 +338,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     self.describe_field(PlaceRef { local, projection: proj_base }, field)\n                 }\n                 ProjectionElem::Downcast(_, variant_index) => {\n-                    let base_ty =\n-                        Place::ty_from(place.local, place.projection, self.body, self.infcx.tcx).ty;\n+                    let base_ty = place.ty(self.body, self.infcx.tcx).ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n@@ -473,7 +472,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // If we didn't find an overloaded deref or index, then assume it's a\n         // built in deref and check the type of the base.\n-        let base_ty = Place::ty_from(deref_base.local, deref_base.projection, self.body, tcx).ty;\n+        let base_ty = deref_base.ty(self.body, tcx).ty;\n         if base_ty.is_unsafe_ptr() {\n             BorrowedContentSource::DerefRawPointer\n         } else if base_ty.is_mutable_ptr() {"}, {"sha": "fa3ae2367e08e524279725965ec7eec546107cdf", "filename": "compiler/rustc_mir/src/borrow_check/path_utils.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fpath_utils.rs?ref=0677d9729318441a1cdb0c74812ec4140fa4d35f", "patch": "@@ -147,27 +147,25 @@ pub(crate) fn is_upvar_field_projection(\n     place_ref: PlaceRef<'tcx>,\n     body: &Body<'tcx>,\n ) -> Option<Field> {\n-    let mut place_projection = place_ref.projection;\n+    let mut place_ref = place_ref;\n     let mut by_ref = false;\n \n-    if let [proj_base @ .., ProjectionElem::Deref] = place_projection {\n-        place_projection = proj_base;\n+    if let Some((place_base, ProjectionElem::Deref)) = place_ref.last_projection() {\n+        place_ref = place_base;\n         by_ref = true;\n     }\n \n-    match place_projection {\n-        [base @ .., ProjectionElem::Field(field, _ty)] => {\n-            let base_ty = Place::ty_from(place_ref.local, base, body, tcx).ty;\n-\n+    match place_ref.last_projection() {\n+        Some((place_base, ProjectionElem::Field(field, _ty))) => {\n+            let base_ty = place_base.ty(body, tcx).ty;\n             if (base_ty.is_closure() || base_ty.is_generator())\n                 && (!by_ref || upvars[field.index()].by_ref)\n             {\n-                Some(*field)\n+                Some(field)\n             } else {\n                 None\n             }\n         }\n-\n         _ => None,\n     }\n }"}, {"sha": "ee78ff00c9b2baa022045ee9a5db2483bbe7fac9", "filename": "compiler/rustc_mir/src/dataflow/move_paths/builder.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=0677d9729318441a1cdb0c74812ec4140fa4d35f", "patch": "@@ -518,14 +518,10 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n \n         // Check if we are assigning into a field of a union, if so, lookup the place\n         // of the union so it is marked as initialized again.\n-        if let [proj_base @ .., ProjectionElem::Field(_, _)] = place.projection {\n-            if let ty::Adt(def, _) =\n-                Place::ty_from(place.local, proj_base, self.builder.body, self.builder.tcx)\n-                    .ty\n-                    .kind()\n-            {\n+        if let Some((place_base, ProjectionElem::Field(_, _))) = place.last_projection() {\n+            if let ty::Adt(def, _) = place_base.ty(self.builder.body, self.builder.tcx).ty.kind() {\n                 if def.is_union() {\n-                    place = PlaceRef { local: place.local, projection: proj_base }\n+                    place = place_base;\n                 }\n             }\n         }"}, {"sha": "0ce1980f10a1186645e16747b7c6891a410ad7ce", "filename": "compiler/rustc_mir/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=0677d9729318441a1cdb0c74812ec4140fa4d35f", "patch": "@@ -174,14 +174,10 @@ where\n \n         Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n             // Special-case reborrows to be more like a copy of the reference.\n-            if let &[ref proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                let base_ty = Place::ty_from(place.local, proj_base, cx.body, cx.tcx).ty;\n+            if let Some((place_base, ProjectionElem::Deref)) = place.as_ref().last_projection() {\n+                let base_ty = place_base.ty(cx.body, cx.tcx).ty;\n                 if let ty::Ref(..) = base_ty.kind() {\n-                    return in_place::<Q, _>(\n-                        cx,\n-                        in_local,\n-                        PlaceRef { local: place.local, projection: proj_base },\n-                    );\n+                    return in_place::<Q, _>(cx, in_local, place_base);\n                 }\n             }\n \n@@ -209,9 +205,9 @@ where\n     Q: Qualif,\n     F: FnMut(Local) -> bool,\n {\n-    let mut projection = place.projection;\n-    while let &[ref proj_base @ .., proj_elem] = projection {\n-        match proj_elem {\n+    let mut place = place;\n+    while let Some((place_base, elem)) = place.last_projection() {\n+        match elem {\n             ProjectionElem::Index(index) if in_local(index) => return true,\n \n             ProjectionElem::Deref\n@@ -222,16 +218,16 @@ where\n             | ProjectionElem::Index(_) => {}\n         }\n \n-        let base_ty = Place::ty_from(place.local, proj_base, cx.body, cx.tcx);\n-        let proj_ty = base_ty.projection_ty(cx.tcx, proj_elem).ty;\n+        let base_ty = place_base.ty(cx.body, cx.tcx);\n+        let proj_ty = base_ty.projection_ty(cx.tcx, elem).ty;\n         if !Q::in_any_value_of_ty(cx, proj_ty) {\n             return false;\n         }\n \n-        projection = proj_base;\n+        place = place_base;\n     }\n \n-    assert!(projection.is_empty());\n+    assert!(place.projection.is_empty());\n     in_local(place.local)\n }\n "}, {"sha": "3d8192649a01fecfb7b9fe6515a4044a8bf82a0f", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=0677d9729318441a1cdb0c74812ec4140fa4d35f", "patch": "@@ -1007,27 +1007,26 @@ fn place_as_reborrow(\n     body: &Body<'tcx>,\n     place: Place<'tcx>,\n ) -> Option<&'a [PlaceElem<'tcx>]> {\n-    place.projection.split_last().and_then(|(outermost, inner)| {\n-        if outermost != &ProjectionElem::Deref {\n-            return None;\n-        }\n-\n-        // A borrow of a `static` also looks like `&(*_1)` in the MIR, but `_1` is a `const`\n-        // that points to the allocation for the static. Don't treat these as reborrows.\n-        if body.local_decls[place.local].is_ref_to_static() {\n-            return None;\n-        }\n-\n-        // Ensure the type being derefed is a reference and not a raw pointer.\n-        //\n-        // This is sufficient to prevent an access to a `static mut` from being marked as a\n-        // reborrow, even if the check above were to disappear.\n-        let inner_ty = Place::ty_from(place.local, inner, body, tcx).ty;\n-        match inner_ty.kind() {\n-            ty::Ref(..) => Some(inner),\n-            _ => None,\n+    match place.as_ref().last_projection() {\n+        Some((place_base, ProjectionElem::Deref)) => {\n+            // A borrow of a `static` also looks like `&(*_1)` in the MIR, but `_1` is a `const`\n+            // that points to the allocation for the static. Don't treat these as reborrows.\n+            if body.local_decls[place_base.local].is_ref_to_static() {\n+                None\n+            } else {\n+                // Ensure the type being derefed is a reference and not a raw pointer.\n+                //\n+                // This is sufficient to prevent an access to a `static mut` from being marked as a\n+                // reborrow, even if the check above were to disappear.\n+                let inner_ty = place_base.ty(body, tcx).ty;\n+                match inner_ty.kind() {\n+                    ty::Ref(..) => Some(place_base.projection),\n+                    _ => None,\n+                }\n+            }\n         }\n-    })\n+        _ => None,\n+    }\n }\n \n fn is_int_bool_or_char(ty: Ty<'_>) -> bool {"}, {"sha": "bac47d0b547e9a8564539e465347ba567f20c12c", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=0677d9729318441a1cdb0c74812ec4140fa4d35f", "patch": "@@ -399,17 +399,13 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         place: Place<'tcx>,\n         is_mut_use: bool,\n     ) {\n-        let mut cursor = place.projection.as_ref();\n-        while let &[ref proj_base @ .., elem] = cursor {\n-            cursor = proj_base;\n-\n+        for (place_base, elem) in place.iter_projections().rev() {\n             match elem {\n                 // Modifications behind a dereference don't affect the value of\n                 // the pointer.\n                 ProjectionElem::Deref => return,\n                 ProjectionElem::Field(..) => {\n-                    let ty =\n-                        Place::ty_from(place.local, proj_base, &self.body.local_decls, self.tcx).ty;\n+                    let ty = place_base.ty(&self.body.local_decls, self.tcx).ty;\n                     if let ty::Adt(def, _) = ty.kind() {\n                         if self.tcx.layout_scalar_valid_range(def.did)\n                             != (Bound::Unbounded, Bound::Unbounded)"}, {"sha": "b0c70372b161abab76d7bfb6c7e9a29062cb2829", "filename": "compiler/rustc_mir/src/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs?ref=0677d9729318441a1cdb0c74812ec4140fa4d35f", "patch": "@@ -277,11 +277,9 @@ impl OptimizationFinder<'b, 'tcx> {\n impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, place) = rvalue {\n-            if let PlaceRef { local, projection: &[ref proj_base @ .., ProjectionElem::Deref] } =\n-                place.as_ref()\n-            {\n+            if let Some((place_base, ProjectionElem::Deref)) = place.as_ref().last_projection() {\n                 // The dereferenced place must have type `&_`.\n-                let ty = Place::ty_from(local, proj_base, self.body, self.tcx).ty;\n+                let ty = place_base.ty(self.body, self.tcx).ty;\n                 if let ty::Ref(_, _, Mutability::Not) = ty.kind() {\n                     self.optimizations.and_stars.insert(location);\n                 }"}, {"sha": "cac5abb1059a88169ad355964d9e26a8710a660c", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=0677d9729318441a1cdb0c74812ec4140fa4d35f", "patch": "@@ -445,43 +445,50 @@ impl<'tcx> Validator<'_, 'tcx> {\n     }\n \n     fn validate_place(&self, place: PlaceRef<'tcx>) -> Result<(), Unpromotable> {\n-        match place {\n-            PlaceRef { local, projection: [] } => self.validate_local(local),\n-            PlaceRef { local, projection: [proj_base @ .., elem] } => {\n+        match place.last_projection() {\n+            None => self.validate_local(place.local),\n+            Some((place_base, elem)) => {\n                 // Validate topmost projection, then recurse.\n-                match *elem {\n+                match elem {\n                     ProjectionElem::Deref => {\n                         let mut promotable = false;\n-                        // This is a special treatment for cases like *&STATIC where STATIC is a\n-                        // global static variable.\n-                        // This pattern is generated only when global static variables are directly\n-                        // accessed and is qualified for promotion safely.\n-                        if let TempState::Defined { location, .. } = self.temps[local] {\n-                            let def_stmt =\n-                                self.body[location.block].statements.get(location.statement_index);\n-                            if let Some(Statement {\n-                                kind:\n-                                    StatementKind::Assign(box (_, Rvalue::Use(Operand::Constant(c)))),\n-                                ..\n-                            }) = def_stmt\n+                        // The `is_empty` predicate is introduced to exclude the case\n+                        // where the projection operations are [ .field, * ].\n+                        // The reason is because promotion will be illegal if field\n+                        // accesses precede the dereferencing.\n+                        // Discussion can be found at\n+                        // https://github.com/rust-lang/rust/pull/74945#discussion_r463063247\n+                        // There may be opportunity for generalization, but this needs to be\n+                        // accounted for.\n+                        if place_base.projection.is_empty() {\n+                            // This is a special treatment for cases like *&STATIC where STATIC is a\n+                            // global static variable.\n+                            // This pattern is generated only when global static variables are directly\n+                            // accessed and is qualified for promotion safely.\n+                            if let TempState::Defined { location, .. } =\n+                                self.temps[place_base.local]\n                             {\n-                                if let Some(did) = c.check_static_ptr(self.tcx) {\n-                                    // Evaluating a promoted may not read statics except if it got\n-                                    // promoted from a static (this is a CTFE check). So we\n-                                    // can only promote static accesses inside statics.\n-                                    if let Some(hir::ConstContext::Static(..)) = self.const_kind {\n-                                        // The `is_empty` predicate is introduced to exclude the case\n-                                        // where the projection operations are [ .field, * ].\n-                                        // The reason is because promotion will be illegal if field\n-                                        // accesses precede the dereferencing.\n-                                        // Discussion can be found at\n-                                        // https://github.com/rust-lang/rust/pull/74945#discussion_r463063247\n-                                        // There may be opportunity for generalization, but this needs to be\n-                                        // accounted for.\n-                                        if proj_base.is_empty()\n-                                            && !self.tcx.is_thread_local_static(did)\n+                                let def_stmt = self.body[location.block]\n+                                    .statements\n+                                    .get(location.statement_index);\n+                                if let Some(Statement {\n+                                    kind:\n+                                        StatementKind::Assign(box (\n+                                            _,\n+                                            Rvalue::Use(Operand::Constant(c)),\n+                                        )),\n+                                    ..\n+                                }) = def_stmt\n+                                {\n+                                    if let Some(did) = c.check_static_ptr(self.tcx) {\n+                                        // Evaluating a promoted may not read statics except if it got\n+                                        // promoted from a static (this is a CTFE check). So we\n+                                        // can only promote static accesses inside statics.\n+                                        if let Some(hir::ConstContext::Static(..)) = self.const_kind\n                                         {\n-                                            promotable = true;\n+                                            if !self.tcx.is_thread_local_static(did) {\n+                                                promotable = true;\n+                                            }\n                                         }\n                                     }\n                                 }\n@@ -502,8 +509,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     }\n \n                     ProjectionElem::Field(..) => {\n-                        let base_ty =\n-                            Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n+                        let base_ty = place_base.ty(self.body, self.tcx).ty;\n                         if let Some(def) = base_ty.ty_adt_def() {\n                             // No promotion of union field accesses.\n                             if def.is_union() {\n@@ -513,7 +519,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     }\n                 }\n \n-                self.validate_place(PlaceRef { local: place.local, projection: proj_base })\n+                self.validate_place(place_base)\n             }\n         }\n     }\n@@ -660,13 +666,11 @@ impl<'tcx> Validator<'_, 'tcx> {\n             Rvalue::AddressOf(_, place) => {\n                 // We accept `&raw *`, i.e., raw reborrows -- creating a raw pointer is\n                 // no problem, only using it is.\n-                if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                    let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n+                if let Some((place_base, ProjectionElem::Deref)) = place.as_ref().last_projection()\n+                {\n+                    let base_ty = place_base.ty(self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind() {\n-                        return self.validate_place(PlaceRef {\n-                            local: place.local,\n-                            projection: proj_base,\n-                        });\n+                        return self.validate_place(place_base);\n                     }\n                 }\n                 return Err(Unpromotable);\n@@ -675,12 +679,12 @@ impl<'tcx> Validator<'_, 'tcx> {\n             Rvalue::Ref(_, kind, place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 let mut place_simplified = place.as_ref();\n-                if let [proj_base @ .., ProjectionElem::Deref] = &place_simplified.projection {\n-                    let base_ty =\n-                        Place::ty_from(place_simplified.local, proj_base, self.body, self.tcx).ty;\n+                if let Some((place_base, ProjectionElem::Deref)) =\n+                    place_simplified.last_projection()\n+                {\n+                    let base_ty = place_base.ty(self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind() {\n-                        place_simplified =\n-                            PlaceRef { local: place_simplified.local, projection: proj_base };\n+                        place_simplified = place_base;\n                     }\n                 }\n "}, {"sha": "f567c9cfaab86263b332cec31f4ef56c059e3506", "filename": "compiler/rustc_mir/src/util/alignment.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677d9729318441a1cdb0c74812ec4140fa4d35f/compiler%2Frustc_mir%2Fsrc%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Falignment.rs?ref=0677d9729318441a1cdb0c74812ec4140fa4d35f", "patch": "@@ -38,15 +38,12 @@ fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: Place<'t\n where\n     L: HasLocalDecls<'tcx>,\n {\n-    let mut cursor = place.projection.as_ref();\n-    while let &[ref proj_base @ .., elem] = cursor {\n-        cursor = proj_base;\n-\n+    for (place_base, elem) in place.iter_projections().rev() {\n         match elem {\n             // encountered a Deref, which is ABI-aligned\n             ProjectionElem::Deref => break,\n             ProjectionElem::Field(..) => {\n-                let ty = Place::ty_from(place.local, proj_base, local_decls, tcx).ty;\n+                let ty = place_base.ty(local_decls, tcx).ty;\n                 match ty.kind() {\n                     ty::Adt(def, _) if def.repr.packed() => return true,\n                     _ => {}"}]}