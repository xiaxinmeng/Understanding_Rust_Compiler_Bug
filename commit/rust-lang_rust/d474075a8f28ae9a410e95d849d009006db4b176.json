{"sha": "d474075a8f28ae9a410e95d849d009006db4b176", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NzQwNzVhOGYyOGFlOWE0MTBlOTVkODQ5ZDAwOTAwNmRiNGIxNzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-01T16:29:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-01T16:29:33Z"}, "message": "Auto merge of #82780 - cjgillot:dep-stream, r=michaelwoerister\n\nStream the dep-graph to a file instead of storing it in-memory.\n\nThis is a reimplementation of #60035.\n\nInstead of storing the dep-graph in-memory, the nodes are encoded as they come\ninto the a temporary file as they come. At the end of a successful the compilation,\nthis file is renamed to be the persistent dep-graph, to be decoded during the next\ncompilation session.\n\nThis two-files scheme avoids overwriting the dep-graph on unsuccessful or crashing compilations.\n\nThe structure of the file is modified to be the sequence of `(DepNode, Fingerprint, EdgesVec)`.\nThe deserialization is responsible for going to the more compressed representation.\nThe `node_count` and `edge_count` are stored in the last 16 bytes of the file,\nin order to accurately reserve capacity for the vectors.\n\nAt the end of the compilation, the encoder is flushed and dropped.\nThe graph is not usable after this point: any creation of a node will ICE.\n\nI had to retrofit the debugging options, which is not really pretty.", "tree": {"sha": "4334803e553593faa77f0954fa48de7477c9de45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4334803e553593faa77f0954fa48de7477c9de45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d474075a8f28ae9a410e95d849d009006db4b176", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d474075a8f28ae9a410e95d849d009006db4b176", "html_url": "https://github.com/rust-lang/rust/commit/d474075a8f28ae9a410e95d849d009006db4b176", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d474075a8f28ae9a410e95d849d009006db4b176/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "803ddb83598838fb9de308d283b759ba463e5e80", "url": "https://api.github.com/repos/rust-lang/rust/commits/803ddb83598838fb9de308d283b759ba463e5e80", "html_url": "https://github.com/rust-lang/rust/commit/803ddb83598838fb9de308d283b759ba463e5e80"}, {"sha": "f3dde45d2a963c32994a78f3ea0119a2da973c14", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3dde45d2a963c32994a78f3ea0119a2da973c14", "html_url": "https://github.com/rust-lang/rust/commit/f3dde45d2a963c32994a78f3ea0119a2da973c14"}], "stats": {"total": 1595, "additions": 656, "deletions": 939}, "files": [{"sha": "b5680beae142d503f6afef41bc540a6b0926e4f4", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -40,8 +40,9 @@ use rustc_graphviz as dot;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_middle::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n-use rustc_middle::dep_graph::{DepGraphQuery, DepKind, DepNode, DepNodeExt};\n+use rustc_middle::dep_graph::{\n+    DepGraphQuery, DepKind, DepNode, DepNodeExt, DepNodeFilter, EdgeFilter,\n+};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n@@ -54,7 +55,7 @@ use std::io::{BufWriter, Write};\n pub fn assert_dep_graph(tcx: TyCtxt<'_>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.debugging_opts.dump_dep_graph {\n-            dump_graph(tcx);\n+            tcx.dep_graph.with_query(dump_graph);\n         }\n \n         if !tcx.sess.opts.debugging_opts.query_dep_graph {\n@@ -200,29 +201,29 @@ fn check_paths<'tcx>(tcx: TyCtxt<'tcx>, if_this_changed: &Sources, then_this_wou\n         }\n         return;\n     }\n-    let query = tcx.dep_graph.query();\n-    for &(_, source_def_id, ref source_dep_node) in if_this_changed {\n-        let dependents = query.transitive_predecessors(source_dep_node);\n-        for &(target_span, ref target_pass, _, ref target_dep_node) in then_this_would_need {\n-            if !dependents.contains(&target_dep_node) {\n-                tcx.sess.span_err(\n-                    target_span,\n-                    &format!(\n-                        \"no path from `{}` to `{}`\",\n-                        tcx.def_path_str(source_def_id),\n-                        target_pass\n-                    ),\n-                );\n-            } else {\n-                tcx.sess.span_err(target_span, \"OK\");\n+    tcx.dep_graph.with_query(|query| {\n+        for &(_, source_def_id, ref source_dep_node) in if_this_changed {\n+            let dependents = query.transitive_predecessors(source_dep_node);\n+            for &(target_span, ref target_pass, _, ref target_dep_node) in then_this_would_need {\n+                if !dependents.contains(&target_dep_node) {\n+                    tcx.sess.span_err(\n+                        target_span,\n+                        &format!(\n+                            \"no path from `{}` to `{}`\",\n+                            tcx.def_path_str(source_def_id),\n+                            target_pass\n+                        ),\n+                    );\n+                } else {\n+                    tcx.sess.span_err(target_span, \"OK\");\n+                }\n             }\n         }\n-    }\n+    });\n }\n \n-fn dump_graph(tcx: TyCtxt<'_>) {\n+fn dump_graph(query: &DepGraphQuery) {\n     let path: String = env::var(\"RUST_DEP_GRAPH\").unwrap_or_else(|_| \"dep_graph\".to_string());\n-    let query = tcx.dep_graph.query();\n \n     let nodes = match env::var(\"RUST_DEP_GRAPH_FILTER\") {\n         Ok(string) => {"}, {"sha": "f089cbcfca6e5f150a2bdc40776eb3ab0d1bbc6f", "filename": "compiler/rustc_incremental/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Flib.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -14,7 +14,7 @@ mod assert_dep_graph;\n pub mod assert_module_sources;\n mod persist;\n \n-pub use assert_dep_graph::assert_dep_graph;\n+use assert_dep_graph::assert_dep_graph;\n pub use persist::copy_cgu_workproduct_to_incr_comp_cache_dir;\n pub use persist::delete_workproduct_files;\n pub use persist::finalize_session_directory;\n@@ -26,4 +26,4 @@ pub use persist::prepare_session_directory;\n pub use persist::save_dep_graph;\n pub use persist::save_work_product_index;\n pub use persist::LoadResult;\n-pub use persist::{load_dep_graph, DepGraphFuture};\n+pub use persist::{build_dep_graph, load_dep_graph, DepGraphFuture};"}, {"sha": "e7bd488af8ebf69cbd654ce5c4a0baa78b488099", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -14,7 +14,6 @@\n //! the required condition is not met.\n \n use rustc_ast::{self as ast, Attribute, NestedMetaItem};\n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -381,39 +380,18 @@ impl DirtyCleanVisitor<'tcx> {\n     fn assert_dirty(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n-        let current_fingerprint = self.get_fingerprint(&dep_node);\n-        let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n-\n-        if current_fingerprint == prev_fingerprint {\n+        if self.tcx.dep_graph.is_green(&dep_node) {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx\n                 .sess\n                 .span_err(item_span, &format!(\"`{}` should be dirty but is not\", dep_node_str));\n         }\n     }\n \n-    fn get_fingerprint(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n-        if self.tcx.dep_graph.dep_node_exists(dep_node) {\n-            let dep_node_index = self.tcx.dep_graph.dep_node_index_of(dep_node);\n-            Some(self.tcx.dep_graph.fingerprint_of(dep_node_index))\n-        } else {\n-            None\n-        }\n-    }\n-\n     fn assert_clean(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n-        let current_fingerprint = self.get_fingerprint(&dep_node);\n-        let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n-\n-        // if the node wasn't previously evaluated and now is (or vice versa),\n-        // then the node isn't actually clean or dirty.\n-        if (current_fingerprint == None) ^ (prev_fingerprint == None) {\n-            return;\n-        }\n-\n-        if current_fingerprint != prev_fingerprint {\n+        if self.tcx.dep_graph.is_red(&dep_node) {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx\n                 .sess"}, {"sha": "30c6c408bc7c00f033a830945c6abf7f360e4e58", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -122,6 +122,7 @@ mod tests;\n \n const LOCK_FILE_EXT: &str = \".lock\";\n const DEP_GRAPH_FILENAME: &str = \"dep-graph.bin\";\n+const STAGING_DEP_GRAPH_FILENAME: &str = \"dep-graph.part.bin\";\n const WORK_PRODUCTS_FILENAME: &str = \"work-products.bin\";\n const QUERY_CACHE_FILENAME: &str = \"query-cache.bin\";\n \n@@ -134,6 +135,9 @@ const INT_ENCODE_BASE: usize = base_n::CASE_INSENSITIVE;\n pub fn dep_graph_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, DEP_GRAPH_FILENAME)\n }\n+pub fn staging_dep_graph_path(sess: &Session) -> PathBuf {\n+    in_incr_comp_dir_sess(sess, STAGING_DEP_GRAPH_FILENAME)\n+}\n pub fn dep_graph_path_from(incr_comp_session_dir: &Path) -> PathBuf {\n     in_incr_comp_dir(incr_comp_session_dir, DEP_GRAPH_FILENAME)\n }"}, {"sha": "259e540c6125e15b0bb3c2346b1383d2b4683d34", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::definitions::Definitions;\n use rustc_middle::dep_graph::{PreviousDepGraph, SerializedDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::query::OnDiskCache;\n use rustc_serialize::opaque::Decoder;\n-use rustc_serialize::Decodable as RustcDecodable;\n+use rustc_serialize::Decodable;\n use rustc_session::Session;\n use std::path::Path;\n \n@@ -120,7 +120,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n             // Decode the list of work_products\n             let mut work_product_decoder = Decoder::new(&work_products_data[..], start_pos);\n             let work_products: Vec<SerializedWorkProduct> =\n-                RustcDecodable::decode(&mut work_product_decoder).unwrap_or_else(|e| {\n+                Decodable::decode(&mut work_product_decoder).unwrap_or_else(|e| {\n                     let msg = format!(\n                         \"Error decoding `work-products` from incremental \\\n                                     compilation session directory: {}\","}, {"sha": "1336189bc0d26118586dcf1f891d2798c95f2005", "filename": "compiler/rustc_incremental/src/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -18,6 +18,7 @@ pub use fs::prepare_session_directory;\n pub use load::load_query_result_cache;\n pub use load::LoadResult;\n pub use load::{load_dep_graph, DepGraphFuture};\n+pub use save::build_dep_graph;\n pub use save::save_dep_graph;\n pub use save::save_work_product_index;\n pub use work_product::copy_cgu_workproduct_to_incr_comp_cache_dir;"}, {"sha": "d558af3c1d558cffffeb7451b0dcee9f483b063f", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 82, "deletions": 23, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::join;\n-use rustc_middle::dep_graph::{DepGraph, WorkProduct, WorkProductId};\n+use rustc_middle::dep_graph::{DepGraph, PreviousDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::TyCtxt;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_serialize::Encodable as RustcEncodable;\n@@ -15,6 +15,9 @@ use super::file_format;\n use super::fs::*;\n use super::work_product;\n \n+/// Save and dump the DepGraph.\n+///\n+/// No query must be invoked after this function.\n pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n     debug!(\"save_dep_graph()\");\n     tcx.dep_graph.with_ignore(|| {\n@@ -29,23 +32,41 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n \n         let query_cache_path = query_cache_path(sess);\n         let dep_graph_path = dep_graph_path(sess);\n+        let staging_dep_graph_path = staging_dep_graph_path(sess);\n+\n+        sess.time(\"assert_dep_graph\", || crate::assert_dep_graph(tcx));\n+        sess.time(\"check_dirty_clean\", || dirty_clean::check_dirty_clean_annotations(tcx));\n+\n+        if sess.opts.debugging_opts.incremental_info {\n+            tcx.dep_graph.print_incremental_info()\n+        }\n \n         join(\n             move || {\n                 sess.time(\"incr_comp_persist_result_cache\", || {\n                     save_in(sess, query_cache_path, \"query cache\", |e| encode_query_cache(tcx, e));\n                 });\n             },\n-            || {\n+            move || {\n                 sess.time(\"incr_comp_persist_dep_graph\", || {\n-                    save_in(sess, dep_graph_path, \"dependency graph\", |e| {\n-                        sess.time(\"incr_comp_encode_dep_graph\", || encode_dep_graph(tcx, e))\n-                    });\n+                    if let Err(err) = tcx.dep_graph.encode(&tcx.sess.prof) {\n+                        sess.err(&format!(\n+                            \"failed to write dependency graph to `{}`: {}\",\n+                            staging_dep_graph_path.display(),\n+                            err\n+                        ));\n+                    }\n+                    if let Err(err) = fs::rename(&staging_dep_graph_path, &dep_graph_path) {\n+                        sess.err(&format!(\n+                            \"failed to move dependency graph from `{}` to `{}`: {}\",\n+                            staging_dep_graph_path.display(),\n+                            dep_graph_path.display(),\n+                            err\n+                        ));\n+                    }\n                 });\n             },\n         );\n-\n-        dirty_clean::check_dirty_clean_annotations(tcx);\n     })\n }\n \n@@ -92,7 +113,7 @@ pub fn save_work_product_index(\n     });\n }\n \n-fn save_in<F>(sess: &Session, path_buf: PathBuf, name: &str, encode: F)\n+pub(crate) fn save_in<F>(sess: &Session, path_buf: PathBuf, name: &str, encode: F)\n where\n     F: FnOnce(&mut FileEncoder) -> FileEncodeResult,\n {\n@@ -144,21 +165,6 @@ where\n     debug!(\"save: data written to disk successfully\");\n }\n \n-fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut FileEncoder) -> FileEncodeResult {\n-    // First encode the commandline arguments hash\n-    tcx.sess.opts.dep_tracking_hash().encode(encoder)?;\n-\n-    if tcx.sess.opts.debugging_opts.incremental_info {\n-        tcx.dep_graph.print_incremental_info();\n-    }\n-\n-    // There is a tiny window between printing the incremental info above and encoding the dep\n-    // graph below in which the dep graph could change, thus making the printed incremental info\n-    // slightly out of date. If this matters to you, please feel free to submit a patch. :)\n-\n-    tcx.sess.time(\"incr_comp_encode_serialized_dep_graph\", || tcx.dep_graph.encode(encoder))\n-}\n-\n fn encode_work_product_index(\n     work_products: &FxHashMap<WorkProductId, WorkProduct>,\n     encoder: &mut FileEncoder,\n@@ -177,3 +183,56 @@ fn encode_work_product_index(\n fn encode_query_cache(tcx: TyCtxt<'_>, encoder: &mut FileEncoder) -> FileEncodeResult {\n     tcx.sess.time(\"incr_comp_serialize_result_cache\", || tcx.serialize_query_result_cache(encoder))\n }\n+\n+pub fn build_dep_graph(\n+    sess: &Session,\n+    prev_graph: PreviousDepGraph,\n+    prev_work_products: FxHashMap<WorkProductId, WorkProduct>,\n+) -> Option<DepGraph> {\n+    if sess.opts.incremental.is_none() {\n+        // No incremental compilation.\n+        return None;\n+    }\n+\n+    // Stream the dep-graph to an alternate file, to avoid overwriting anything in case of errors.\n+    let path_buf = staging_dep_graph_path(sess);\n+\n+    let mut encoder = match FileEncoder::new(&path_buf) {\n+        Ok(encoder) => encoder,\n+        Err(err) => {\n+            sess.err(&format!(\n+                \"failed to create dependency graph at `{}`: {}\",\n+                path_buf.display(),\n+                err\n+            ));\n+            return None;\n+        }\n+    };\n+\n+    if let Err(err) = file_format::write_file_header(&mut encoder, sess.is_nightly_build()) {\n+        sess.err(&format!(\n+            \"failed to write dependency graph header to `{}`: {}\",\n+            path_buf.display(),\n+            err\n+        ));\n+        return None;\n+    }\n+\n+    // First encode the commandline arguments hash\n+    if let Err(err) = sess.opts.dep_tracking_hash().encode(&mut encoder) {\n+        sess.err(&format!(\n+            \"failed to write dependency graph hash `{}`: {}\",\n+            path_buf.display(),\n+            err\n+        ));\n+        return None;\n+    }\n+\n+    Some(DepGraph::new(\n+        prev_graph,\n+        prev_work_products,\n+        encoder,\n+        sess.opts.debugging_opts.query_dep_graph,\n+        sess.opts.debugging_opts.incremental_info,\n+    ))\n+}"}, {"sha": "c693155994f56abfad9e80c7fd897a3188be78ae", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1021,9 +1021,6 @@ pub fn start_codegen<'tcx>(\n         rustc_symbol_mangling::test::report_symbol_names(tcx);\n     }\n \n-    tcx.sess.time(\"assert_dep_graph\", || rustc_incremental::assert_dep_graph(tcx));\n-    tcx.sess.time(\"serialize_dep_graph\", || rustc_incremental::save_dep_graph(tcx));\n-\n     info!(\"Post-codegen\\n{:?}\", tcx.debug_stats());\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {"}, {"sha": "01853eab530dad437b644270e2f5086354aa7391", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -207,7 +207,13 @@ impl<'tcx> Queries<'tcx> {\n                                 })\n                                 .open(self.session())\n                         });\n-                    DepGraph::new(prev_graph, prev_work_products)\n+\n+                    rustc_incremental::build_dep_graph(\n+                        self.session(),\n+                        prev_graph,\n+                        prev_work_products,\n+                    )\n+                    .unwrap_or_else(DepGraph::new_disabled)\n                 }\n             })\n         })\n@@ -435,6 +441,9 @@ impl Compiler {\n             if self.session().opts.debugging_opts.query_stats {\n                 gcx.enter(rustc_query_impl::print_stats);\n             }\n+\n+            self.session()\n+                .time(\"serialize_dep_graph\", || gcx.enter(rustc_incremental::save_dep_graph));\n         }\n \n         _timer = Some(self.session().timer(\"free_global_ctxt\"));"}, {"sha": "d2fe9af34fb625a8a88ae9e94cd4f89f661ddaec", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -8,8 +8,8 @@ use rustc_session::Session;\n mod dep_node;\n \n pub use rustc_query_system::dep_graph::{\n-    debug, hash_result, DepContext, DepNodeColor, DepNodeIndex, SerializedDepNodeIndex,\n-    WorkProduct, WorkProductId,\n+    debug::DepNodeFilter, hash_result, DepContext, DepNodeColor, DepNodeIndex,\n+    SerializedDepNodeIndex, WorkProduct, WorkProductId,\n };\n \n crate use dep_node::make_compile_codegen_unit;\n@@ -20,6 +20,7 @@ pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;\n pub type DepGraphQuery = rustc_query_system::dep_graph::DepGraphQuery<DepKind>;\n pub type PreviousDepGraph = rustc_query_system::dep_graph::PreviousDepGraph<DepKind>;\n pub type SerializedDepGraph = rustc_query_system::dep_graph::SerializedDepGraph<DepKind>;\n+pub type EdgeFilter = rustc_query_system::dep_graph::debug::EdgeFilter<DepKind>;\n \n impl rustc_query_system::dep_graph::DepKind for DepKind {\n     const NULL: Self = DepKind::Null;"}, {"sha": "4194b28dc7d681fc485c0e765a55430a7745f6dc", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -477,10 +477,7 @@ macro_rules! define_queries {\n                         return\n                     }\n \n-                    debug_assert!(tcx.dep_graph\n-                                     .node_color(dep_node)\n-                                     .map(|c| c.is_green())\n-                                     .unwrap_or(false));\n+                    debug_assert!(tcx.dep_graph.is_green(dep_node));\n \n                     let key = recover(*tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n                     if queries::$name::cache_on_disk(tcx, &key, None) {"}, {"sha": "a544ac2c343aeeab2d5fbd4e9e60061a1f88cdd0", "filename": "compiler/rustc_query_system/src/dep_graph/debug.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,6 +1,8 @@\n //! Code for debugging the dep-graph.\n \n-use super::{DepKind, DepNode};\n+use super::{DepKind, DepNode, DepNodeIndex};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lock;\n use std::error::Error;\n \n /// A dep-node filter goes from a user-defined string to a query over\n@@ -34,26 +36,28 @@ impl DepNodeFilter {\n \n /// A filter like `F -> G` where `F` and `G` are valid dep-node\n /// filters. This can be used to test the source/target independently.\n-pub struct EdgeFilter {\n+pub struct EdgeFilter<K: DepKind> {\n     pub source: DepNodeFilter,\n     pub target: DepNodeFilter,\n+    pub index_to_node: Lock<FxHashMap<DepNodeIndex, DepNode<K>>>,\n }\n \n-impl EdgeFilter {\n-    pub fn new(test: &str) -> Result<EdgeFilter, Box<dyn Error>> {\n+impl<K: DepKind> EdgeFilter<K> {\n+    pub fn new(test: &str) -> Result<EdgeFilter<K>, Box<dyn Error>> {\n         let parts: Vec<_> = test.split(\"->\").collect();\n         if parts.len() != 2 {\n             Err(format!(\"expected a filter like `a&b -> c&d`, not `{}`\", test).into())\n         } else {\n             Ok(EdgeFilter {\n                 source: DepNodeFilter::new(parts[0]),\n                 target: DepNodeFilter::new(parts[1]),\n+                index_to_node: Lock::new(FxHashMap::default()),\n             })\n         }\n     }\n \n     #[cfg(debug_assertions)]\n-    pub fn test<K: DepKind>(&self, source: &DepNode<K>, target: &DepNode<K>) -> bool {\n+    pub fn test(&self, source: &DepNode<K>, target: &DepNode<K>) -> bool {\n         self.source.test(source) && self.target.test(target)\n     }\n }"}, {"sha": "7a0fc320663f764d1aedd0cfb48f19dd3b72effe", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 214, "deletions": 745, "changes": 959, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,31 +1,33 @@\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::QueryInvocationId;\n+use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, LockGuard, Lrc, Ordering};\n+use rustc_data_structures::steal::Steal;\n+use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n use rustc_data_structures::unlikely;\n use rustc_errors::Diagnostic;\n-use rustc_index::vec::{Idx, IndexVec};\n-use rustc_serialize::{Encodable, Encoder};\n+use rustc_index::vec::IndexVec;\n+use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n \n use parking_lot::{Condvar, Mutex};\n use smallvec::{smallvec, SmallVec};\n use std::collections::hash_map::Entry;\n-use std::env;\n use std::hash::Hash;\n use std::marker::PhantomData;\n use std::mem;\n-use std::ops::Range;\n use std::sync::atomic::Ordering::Relaxed;\n \n-use super::debug::EdgeFilter;\n use super::prev::PreviousDepGraph;\n use super::query::DepGraphQuery;\n-use super::serialized::SerializedDepNodeIndex;\n+use super::serialized::{GraphEncoder, SerializedDepNodeIndex};\n use super::{DepContext, DepKind, DepNode, HasDepContext, WorkProductId};\n use crate::query::QueryContext;\n \n+#[cfg(debug_assertions)]\n+use {super::debug::EdgeFilter, std::env};\n+\n #[derive(Clone)]\n pub struct DepGraph<K: DepKind> {\n     data: Option<Lrc<DepGraphData<K>>>,\n@@ -109,14 +111,22 @@ impl<K: DepKind> DepGraph<K> {\n     pub fn new(\n         prev_graph: PreviousDepGraph<K>,\n         prev_work_products: FxHashMap<WorkProductId, WorkProduct>,\n+        encoder: FileEncoder,\n+        record_graph: bool,\n+        record_stats: bool,\n     ) -> DepGraph<K> {\n         let prev_graph_node_count = prev_graph.node_count();\n \n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n-                current: CurrentDepGraph::new(prev_graph_node_count),\n+                current: CurrentDepGraph::new(\n+                    prev_graph_node_count,\n+                    encoder,\n+                    record_graph,\n+                    record_stats,\n+                ),\n                 emitting_diagnostics: Default::default(),\n                 emitting_diagnostics_cond_var: Condvar::new(),\n                 previous: prev_graph,\n@@ -136,62 +146,10 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.is_some()\n     }\n \n-    pub fn query(&self) -> DepGraphQuery<K> {\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-\n-        // Note locking order: `prev_index_to_index`, then `data`.\n-        let prev_index_to_index = data.current.prev_index_to_index.lock();\n-        let data = data.current.data.lock();\n-        let node_count = data.hybrid_indices.len();\n-        let edge_count = self.edge_count(&data);\n-\n-        let mut nodes = Vec::with_capacity(node_count);\n-        let mut edge_list_indices = Vec::with_capacity(node_count);\n-        let mut edge_list_data = Vec::with_capacity(edge_count);\n-\n-        // See `DepGraph`'s `Encodable` implementation for notes on the approach used here.\n-\n-        edge_list_data.extend(data.unshared_edges.iter().map(|i| i.index()));\n-\n-        for &hybrid_index in data.hybrid_indices.iter() {\n-            match hybrid_index.into() {\n-                HybridIndex::New(new_index) => {\n-                    nodes.push(data.new.nodes[new_index]);\n-                    let edges = &data.new.edges[new_index];\n-                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n-                }\n-                HybridIndex::Red(red_index) => {\n-                    nodes.push(previous.index_to_node(data.red.node_indices[red_index]));\n-                    let edges = &data.red.edges[red_index];\n-                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n-                }\n-                HybridIndex::LightGreen(lg_index) => {\n-                    nodes.push(previous.index_to_node(data.light_green.node_indices[lg_index]));\n-                    let edges = &data.light_green.edges[lg_index];\n-                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n-                }\n-                HybridIndex::DarkGreen(prev_index) => {\n-                    nodes.push(previous.index_to_node(prev_index));\n-\n-                    let edges_iter = previous\n-                        .edge_targets_from(prev_index)\n-                        .iter()\n-                        .map(|&dst| prev_index_to_index[dst].unwrap().index());\n-\n-                    let start = edge_list_data.len();\n-                    edge_list_data.extend(edges_iter);\n-                    let end = edge_list_data.len();\n-                    edge_list_indices.push((start, end));\n-                }\n-            }\n+    pub fn with_query(&self, f: impl Fn(&DepGraphQuery<K>)) {\n+        if let Some(data) = &self.data {\n+            data.current.encoder.borrow().with_query(f)\n         }\n-\n-        debug_assert_eq!(nodes.len(), node_count);\n-        debug_assert_eq!(edge_list_indices.len(), node_count);\n-        debug_assert_eq!(edge_list_data.len(), edge_count);\n-\n-        DepGraphQuery::new(&nodes[..], &edge_list_indices[..], &edge_list_data[..])\n     }\n \n     pub fn assert_ignored(&self) {\n@@ -283,56 +241,16 @@ impl<K: DepKind> DepGraph<K> {\n             let print_status = cfg!(debug_assertions) && dcx.sess().opts.debugging_opts.dep_tasks;\n \n             // Intern the new `DepNode`.\n-            let dep_node_index = if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n-                // Determine the color and index of the new `DepNode`.\n-                let (color, dep_node_index) = if let Some(current_fingerprint) = current_fingerprint\n-                {\n-                    if current_fingerprint == data.previous.fingerprint_by_index(prev_index) {\n-                        if print_status {\n-                            eprintln!(\"[task::green] {:?}\", key);\n-                        }\n-\n-                        // This is a light green node: it existed in the previous compilation,\n-                        // its query was re-executed, and it has the same result as before.\n-                        let dep_node_index =\n-                            data.current.intern_light_green_node(&data.previous, prev_index, edges);\n-\n-                        (DepNodeColor::Green(dep_node_index), dep_node_index)\n-                    } else {\n-                        if print_status {\n-                            eprintln!(\"[task::red] {:?}\", key);\n-                        }\n-\n-                        // This is a red node: it existed in the previous compilation, its query\n-                        // was re-executed, but it has a different result from before.\n-                        let dep_node_index = data.current.intern_red_node(\n-                            &data.previous,\n-                            prev_index,\n-                            edges,\n-                            current_fingerprint,\n-                        );\n-\n-                        (DepNodeColor::Red, dep_node_index)\n-                    }\n-                } else {\n-                    if print_status {\n-                        eprintln!(\"[task::unknown] {:?}\", key);\n-                    }\n-\n-                    // This is a red node, effectively: it existed in the previous compilation\n-                    // session, its query was re-executed, but it doesn't compute a result hash\n-                    // (i.e. it represents a `no_hash` query), so we have no way of determining\n-                    // whether or not the result was the same as before.\n-                    let dep_node_index = data.current.intern_red_node(\n-                        &data.previous,\n-                        prev_index,\n-                        edges,\n-                        Fingerprint::ZERO,\n-                    );\n-\n-                    (DepNodeColor::Red, dep_node_index)\n-                };\n+            let (dep_node_index, prev_and_color) = data.current.intern_node(\n+                dcx.profiler(),\n+                &data.previous,\n+                key,\n+                edges,\n+                current_fingerprint,\n+                print_status,\n+            );\n \n+            if let Some((prev_index, color)) = prev_and_color {\n                 debug_assert!(\n                     data.colors.get(prev_index).is_none(),\n                     \"DepGraph::with_task() - Duplicate DepNodeColor \\\n@@ -341,20 +259,7 @@ impl<K: DepKind> DepGraph<K> {\n                 );\n \n                 data.colors.insert(prev_index, color);\n-                dep_node_index\n-            } else {\n-                if print_status {\n-                    eprintln!(\"[task::new] {:?}\", key);\n-                }\n-\n-                // This is a new node: it didn't exist in the previous compilation session.\n-                data.current.intern_new_node(\n-                    &data.previous,\n-                    key,\n-                    edges,\n-                    current_fingerprint.unwrap_or(Fingerprint::ZERO),\n-                )\n-            };\n+            }\n \n             (result, dep_node_index)\n         } else {\n@@ -368,7 +273,12 @@ impl<K: DepKind> DepGraph<K> {\n \n     /// Executes something within an \"anonymous\" task, that is, a task the\n     /// `DepNode` of which is determined by the list of inputs it read from.\n-    pub fn with_anon_task<OP, R>(&self, dep_kind: K, op: OP) -> (R, DepNodeIndex)\n+    pub fn with_anon_task<Ctxt: DepContext<DepKind = K>, OP, R>(\n+        &self,\n+        cx: Ctxt,\n+        dep_kind: K,\n+        op: OP,\n+    ) -> (R, DepNodeIndex)\n     where\n         OP: FnOnce() -> R,\n     {\n@@ -396,7 +306,7 @@ impl<K: DepKind> DepGraph<K> {\n             };\n \n             let dep_node_index = data.current.intern_new_node(\n-                &data.previous,\n+                cx.profiler(),\n                 target_dep_node,\n                 task_deps.reads,\n                 Fingerprint::ZERO,\n@@ -451,7 +361,7 @@ impl<K: DepKind> DepGraph<K> {\n                         {\n                             if let Some(target) = task_deps.node {\n                                 if let Some(ref forbidden_edge) = data.current.forbidden_edge {\n-                                    let src = self.dep_node_of(dep_node_index);\n+                                    let src = forbidden_edge.index_to_node.lock()[&dep_node_index];\n                                     if forbidden_edge.test(&src, &target) {\n                                         panic!(\"forbidden edge {:?} -> {:?} created\", src, target)\n                                     }\n@@ -488,38 +398,6 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.is_some() && self.dep_node_index_of_opt(dep_node).is_some()\n     }\n \n-    #[cfg(debug_assertions)]\n-    fn dep_node_of(&self, dep_node_index: DepNodeIndex) -> DepNode<K> {\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-        let data = data.current.data.lock();\n-\n-        match data.hybrid_indices[dep_node_index].into() {\n-            HybridIndex::New(new_index) => data.new.nodes[new_index],\n-            HybridIndex::Red(red_index) => previous.index_to_node(data.red.node_indices[red_index]),\n-            HybridIndex::LightGreen(light_green_index) => {\n-                previous.index_to_node(data.light_green.node_indices[light_green_index])\n-            }\n-            HybridIndex::DarkGreen(prev_index) => previous.index_to_node(prev_index),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-        let data = data.current.data.lock();\n-\n-        match data.hybrid_indices[dep_node_index].into() {\n-            HybridIndex::New(new_index) => data.new.fingerprints[new_index],\n-            HybridIndex::Red(red_index) => data.red.fingerprints[red_index],\n-            HybridIndex::LightGreen(light_green_index) => {\n-                previous.fingerprint_by_index(data.light_green.node_indices[light_green_index])\n-            }\n-            HybridIndex::DarkGreen(prev_index) => previous.fingerprint_by_index(prev_index),\n-        }\n-    }\n-\n     pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n         self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n@@ -554,29 +432,13 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.as_ref()?.dep_node_debug.borrow().get(&dep_node).cloned()\n     }\n \n-    fn edge_count(&self, node_data: &LockGuard<'_, DepNodeData<K>>) -> usize {\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-\n-        let mut edge_count = node_data.unshared_edges.len();\n-\n-        for &hybrid_index in node_data.hybrid_indices.iter() {\n-            if let HybridIndex::DarkGreen(prev_index) = hybrid_index.into() {\n-                edge_count += previous.edge_targets_from(prev_index).len()\n-            }\n-        }\n-\n-        edge_count\n-    }\n-\n-    pub fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n+    fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n         if let Some(ref data) = self.data {\n             if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n                 return data.colors.get(prev_index);\n             } else {\n-                // This is a node that did not exist in the previous compilation\n-                // session, so we consider it to be red.\n-                return Some(DepNodeColor::Red);\n+                // This is a node that did not exist in the previous compilation session.\n+                return None;\n             }\n         }\n \n@@ -775,11 +637,13 @@ impl<K: DepKind> DepGraph<K> {\n \n         // There may be multiple threads trying to mark the same dep node green concurrently\n \n-        let dep_node_index = {\n-            // We allocating an entry for the node in the current dependency graph and\n-            // adding all the appropriate edges imported from the previous graph\n-            data.current.intern_dark_green_node(&data.previous, prev_dep_node_index)\n-        };\n+        // We allocating an entry for the node in the current dependency graph and\n+        // adding all the appropriate edges imported from the previous graph\n+        let dep_node_index = data.current.promote_node_and_deps_to_current(\n+            tcx.dep_context().profiler(),\n+            &data.previous,\n+            prev_dep_node_index,\n+        );\n \n         // ... emitting any stored diagnostic ...\n \n@@ -862,6 +726,12 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    // Returns true if the given node has been marked as red during the\n+    // current compilation session. Used in various assertions\n+    pub fn is_red(&self, dep_node: &DepNode<K>) -> bool {\n+        self.node_color(dep_node) == Some(DepNodeColor::Red)\n+    }\n+\n     // Returns true if the given node has been marked as green during the\n     // current compilation session. Used in various assertions\n     pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n@@ -911,106 +781,20 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     pub fn print_incremental_info(&self) {\n-        #[derive(Clone)]\n-        struct Stat<Kind: DepKind> {\n-            kind: Kind,\n-            node_counter: u64,\n-            edge_counter: u64,\n+        if let Some(data) = &self.data {\n+            data.current.encoder.borrow().print_incremental_info(\n+                data.current.total_read_count.load(Relaxed),\n+                data.current.total_duplicate_read_count.load(Relaxed),\n+            )\n         }\n+    }\n \n-        let data = self.data.as_ref().unwrap();\n-        let prev = &data.previous;\n-        let current = &data.current;\n-        let data = current.data.lock();\n-\n-        let mut stats: FxHashMap<_, Stat<K>> = FxHashMap::with_hasher(Default::default());\n-\n-        for &hybrid_index in data.hybrid_indices.iter() {\n-            let (kind, edge_count) = match hybrid_index.into() {\n-                HybridIndex::New(new_index) => {\n-                    let kind = data.new.nodes[new_index].kind;\n-                    let edge_range = &data.new.edges[new_index];\n-                    (kind, edge_range.end.as_usize() - edge_range.start.as_usize())\n-                }\n-                HybridIndex::Red(red_index) => {\n-                    let kind = prev.index_to_node(data.red.node_indices[red_index]).kind;\n-                    let edge_range = &data.red.edges[red_index];\n-                    (kind, edge_range.end.as_usize() - edge_range.start.as_usize())\n-                }\n-                HybridIndex::LightGreen(lg_index) => {\n-                    let kind = prev.index_to_node(data.light_green.node_indices[lg_index]).kind;\n-                    let edge_range = &data.light_green.edges[lg_index];\n-                    (kind, edge_range.end.as_usize() - edge_range.start.as_usize())\n-                }\n-                HybridIndex::DarkGreen(prev_index) => {\n-                    let kind = prev.index_to_node(prev_index).kind;\n-                    let edge_count = prev.edge_targets_from(prev_index).len();\n-                    (kind, edge_count)\n-                }\n-            };\n-\n-            let stat = stats.entry(kind).or_insert(Stat { kind, node_counter: 0, edge_counter: 0 });\n-            stat.node_counter += 1;\n-            stat.edge_counter += edge_count as u64;\n-        }\n-\n-        let total_node_count = data.hybrid_indices.len();\n-        let total_edge_count = self.edge_count(&data);\n-\n-        // Drop the lock guard.\n-        std::mem::drop(data);\n-\n-        let mut stats: Vec<_> = stats.values().cloned().collect();\n-        stats.sort_by_key(|s| -(s.node_counter as i64));\n-\n-        const SEPARATOR: &str = \"[incremental] --------------------------------\\\n-                                 ----------------------------------------------\\\n-                                 ------------\";\n-\n-        eprintln!(\"[incremental]\");\n-        eprintln!(\"[incremental] DepGraph Statistics\");\n-        eprintln!(\"{}\", SEPARATOR);\n-        eprintln!(\"[incremental]\");\n-        eprintln!(\"[incremental] Total Node Count: {}\", total_node_count);\n-        eprintln!(\"[incremental] Total Edge Count: {}\", total_edge_count);\n-\n-        if cfg!(debug_assertions) {\n-            let total_edge_reads = current.total_read_count.load(Relaxed);\n-            let total_duplicate_edge_reads = current.total_duplicate_read_count.load(Relaxed);\n-\n-            eprintln!(\"[incremental] Total Edge Reads: {}\", total_edge_reads);\n-            eprintln!(\"[incremental] Total Duplicate Edge Reads: {}\", total_duplicate_edge_reads);\n-        }\n-\n-        eprintln!(\"[incremental]\");\n-\n-        eprintln!(\n-            \"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n-            \"Node Kind\", \"Node Frequency\", \"Node Count\", \"Avg. Edge Count\"\n-        );\n-\n-        eprintln!(\n-            \"[incremental] -------------------------------------\\\n-                  |------------------\\\n-                  |-------------\\\n-                  |------------------|\"\n-        );\n-\n-        for stat in stats {\n-            let node_kind_ratio = (100.0 * (stat.node_counter as f64)) / (total_node_count as f64);\n-            let node_kind_avg_edges = (stat.edge_counter as f64) / (stat.node_counter as f64);\n-\n-            eprintln!(\n-                \"[incremental]  {:<36}|{:>16.1}% |{:>12} |{:>17.1} |\",\n-                format!(\"{:?}\", stat.kind),\n-                node_kind_ratio,\n-                stat.node_counter,\n-                node_kind_avg_edges,\n-            );\n+    pub fn encode(&self, profiler: &SelfProfilerRef) -> FileEncodeResult {\n+        if let Some(data) = &self.data {\n+            data.current.encoder.steal().finish(profiler)\n+        } else {\n+            Ok(())\n         }\n-\n-        eprintln!(\"{}\", SEPARATOR);\n-        eprintln!(\"[incremental]\");\n     }\n \n     fn next_virtual_depnode_index(&self) -> DepNodeIndex {\n@@ -1019,142 +803,6 @@ impl<K: DepKind> DepGraph<K> {\n     }\n }\n \n-impl<E: Encoder, K: DepKind + Encodable<E>> Encodable<E> for DepGraph<K> {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        // We used to serialize the dep graph by creating and serializing a `SerializedDepGraph`\n-        // using data copied from the `DepGraph`. But copying created a large memory spike, so we\n-        // now serialize directly from the `DepGraph` as if it's a `SerializedDepGraph`. Because we\n-        // deserialize that data into a `SerializedDepGraph` in the next compilation session, we\n-        // need `DepGraph`'s `Encodable` and `SerializedDepGraph`'s `Decodable` implementations to\n-        // be in sync. If you update this encoding, be sure to update the decoding, and vice-versa.\n-\n-        let data = self.data.as_ref().unwrap();\n-        let prev = &data.previous;\n-\n-        // Note locking order: `prev_index_to_index`, then `data`.\n-        let prev_index_to_index = data.current.prev_index_to_index.lock();\n-        let data = data.current.data.lock();\n-        let new = &data.new;\n-        let red = &data.red;\n-        let lg = &data.light_green;\n-\n-        let node_count = data.hybrid_indices.len();\n-        let edge_count = self.edge_count(&data);\n-\n-        // `rustc_middle::ty::query::OnDiskCache` expects nodes to be encoded in `DepNodeIndex`\n-        // order. The edges in `edge_list_data` don't need to be in a particular order, as long as\n-        // each node references its edges as a contiguous range within it. Therefore, we can encode\n-        // `edge_list_data` directly from `unshared_edges`. It meets the above requirements, as\n-        // each non-dark-green node already knows the range of edges to reference within it, which\n-        // they'll encode in `edge_list_indices`. Dark green nodes, however, don't have their edges\n-        // in `unshared_edges`, so need to add them to `edge_list_data`.\n-\n-        use HybridIndex::*;\n-\n-        // Encoded values (nodes, etc.) are explicitly typed below to avoid inadvertently\n-        // serializing data in the wrong format (i.e. one incompatible with `SerializedDepGraph`).\n-        e.emit_struct(\"SerializedDepGraph\", 4, |e| {\n-            e.emit_struct_field(\"nodes\", 0, |e| {\n-                // `SerializedDepGraph` expects this to be encoded as a sequence of `DepNode`s.\n-                e.emit_seq(node_count, |e| {\n-                    for (seq_index, &hybrid_index) in data.hybrid_indices.iter().enumerate() {\n-                        let node: DepNode<K> = match hybrid_index.into() {\n-                            New(i) => new.nodes[i],\n-                            Red(i) => prev.index_to_node(red.node_indices[i]),\n-                            LightGreen(i) => prev.index_to_node(lg.node_indices[i]),\n-                            DarkGreen(prev_index) => prev.index_to_node(prev_index),\n-                        };\n-\n-                        e.emit_seq_elt(seq_index, |e| node.encode(e))?;\n-                    }\n-\n-                    Ok(())\n-                })\n-            })?;\n-\n-            e.emit_struct_field(\"fingerprints\", 1, |e| {\n-                // `SerializedDepGraph` expects this to be encoded as a sequence of `Fingerprints`s.\n-                e.emit_seq(node_count, |e| {\n-                    for (seq_index, &hybrid_index) in data.hybrid_indices.iter().enumerate() {\n-                        let fingerprint: Fingerprint = match hybrid_index.into() {\n-                            New(i) => new.fingerprints[i],\n-                            Red(i) => red.fingerprints[i],\n-                            LightGreen(i) => prev.fingerprint_by_index(lg.node_indices[i]),\n-                            DarkGreen(prev_index) => prev.fingerprint_by_index(prev_index),\n-                        };\n-\n-                        e.emit_seq_elt(seq_index, |e| fingerprint.encode(e))?;\n-                    }\n-\n-                    Ok(())\n-                })\n-            })?;\n-\n-            e.emit_struct_field(\"edge_list_indices\", 2, |e| {\n-                // `SerializedDepGraph` expects this to be encoded as a sequence of `(u32, u32)`s.\n-                e.emit_seq(node_count, |e| {\n-                    // Dark green node edges start after the unshared (all other nodes') edges.\n-                    let mut dark_green_edge_index = data.unshared_edges.len();\n-\n-                    for (seq_index, &hybrid_index) in data.hybrid_indices.iter().enumerate() {\n-                        let edge_indices: (u32, u32) = match hybrid_index.into() {\n-                            New(i) => (new.edges[i].start.as_u32(), new.edges[i].end.as_u32()),\n-                            Red(i) => (red.edges[i].start.as_u32(), red.edges[i].end.as_u32()),\n-                            LightGreen(i) => (lg.edges[i].start.as_u32(), lg.edges[i].end.as_u32()),\n-                            DarkGreen(prev_index) => {\n-                                let edge_count = prev.edge_targets_from(prev_index).len();\n-                                let start = dark_green_edge_index as u32;\n-                                dark_green_edge_index += edge_count;\n-                                let end = dark_green_edge_index as u32;\n-                                (start, end)\n-                            }\n-                        };\n-\n-                        e.emit_seq_elt(seq_index, |e| edge_indices.encode(e))?;\n-                    }\n-\n-                    assert_eq!(dark_green_edge_index, edge_count);\n-\n-                    Ok(())\n-                })\n-            })?;\n-\n-            e.emit_struct_field(\"edge_list_data\", 3, |e| {\n-                // `SerializedDepGraph` expects this to be encoded as a sequence of\n-                // `SerializedDepNodeIndex`.\n-                e.emit_seq(edge_count, |e| {\n-                    for (seq_index, &edge) in data.unshared_edges.iter().enumerate() {\n-                        let serialized_edge = SerializedDepNodeIndex::new(edge.index());\n-                        e.emit_seq_elt(seq_index, |e| serialized_edge.encode(e))?;\n-                    }\n-\n-                    let mut seq_index = data.unshared_edges.len();\n-\n-                    for &hybrid_index in data.hybrid_indices.iter() {\n-                        if let DarkGreen(prev_index) = hybrid_index.into() {\n-                            for &edge in prev.edge_targets_from(prev_index) {\n-                                // Dark green node edges are stored in the previous graph\n-                                // and must be converted to edges in the current graph,\n-                                // and then serialized as `SerializedDepNodeIndex`.\n-                                let serialized_edge = SerializedDepNodeIndex::new(\n-                                    prev_index_to_index[edge].as_ref().unwrap().index(),\n-                                );\n-\n-                                e.emit_seq_elt(seq_index, |e| serialized_edge.encode(e))?;\n-                                seq_index += 1;\n-                            }\n-                        }\n-                    }\n-\n-                    assert_eq!(seq_index, edge_count);\n-\n-                    Ok(())\n-                })\n-            })\n-        })\n-    }\n-}\n-\n /// A \"work product\" is an intermediate result that we save into the\n /// incremental directory for later re-use. The primary example are\n /// the object files that we save for each partition at code\n@@ -1193,216 +841,20 @@ pub struct WorkProduct {\n     pub saved_file: Option<String>,\n }\n \n-// The maximum value of the follow index types leaves the upper two bits unused\n-// so that we can store multiple index types in `CompressedHybridIndex`, and use\n-// those bits to encode which index type it contains.\n-\n-// Index type for `NewDepNodeData`.\n-rustc_index::newtype_index! {\n-    struct NewDepNodeIndex {\n-        MAX = 0x7FFF_FFFF\n-    }\n-}\n-\n-// Index type for `RedDepNodeData`.\n-rustc_index::newtype_index! {\n-    struct RedDepNodeIndex {\n-        MAX = 0x7FFF_FFFF\n-    }\n-}\n-\n-// Index type for `LightGreenDepNodeData`.\n-rustc_index::newtype_index! {\n-    struct LightGreenDepNodeIndex {\n-        MAX = 0x7FFF_FFFF\n-    }\n-}\n-\n-/// Compressed representation of `HybridIndex` enum. Bits unused by the\n-/// contained index types are used to encode which index type it contains.\n-#[derive(Copy, Clone)]\n-struct CompressedHybridIndex(u32);\n-\n-impl CompressedHybridIndex {\n-    const NEW_TAG: u32 = 0b0000_0000_0000_0000_0000_0000_0000_0000;\n-    const RED_TAG: u32 = 0b0100_0000_0000_0000_0000_0000_0000_0000;\n-    const LIGHT_GREEN_TAG: u32 = 0b1000_0000_0000_0000_0000_0000_0000_0000;\n-    const DARK_GREEN_TAG: u32 = 0b1100_0000_0000_0000_0000_0000_0000_0000;\n-\n-    const TAG_MASK: u32 = 0b1100_0000_0000_0000_0000_0000_0000_0000;\n-    const INDEX_MASK: u32 = !Self::TAG_MASK;\n-}\n-\n-impl From<NewDepNodeIndex> for CompressedHybridIndex {\n-    #[inline]\n-    fn from(index: NewDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::NEW_TAG | index.as_u32())\n-    }\n-}\n-\n-impl From<RedDepNodeIndex> for CompressedHybridIndex {\n-    #[inline]\n-    fn from(index: RedDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::RED_TAG | index.as_u32())\n-    }\n-}\n-\n-impl From<LightGreenDepNodeIndex> for CompressedHybridIndex {\n-    #[inline]\n-    fn from(index: LightGreenDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::LIGHT_GREEN_TAG | index.as_u32())\n-    }\n-}\n-\n-impl From<SerializedDepNodeIndex> for CompressedHybridIndex {\n-    #[inline]\n-    fn from(index: SerializedDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::DARK_GREEN_TAG | index.as_u32())\n-    }\n-}\n-\n-/// Contains an index into one of several node data collections. Elsewhere, we\n-/// store `CompressedHyridIndex` instead of this to save space, but convert to\n-/// this type during processing to take advantage of the enum match ergonomics.\n-enum HybridIndex {\n-    New(NewDepNodeIndex),\n-    Red(RedDepNodeIndex),\n-    LightGreen(LightGreenDepNodeIndex),\n-    DarkGreen(SerializedDepNodeIndex),\n-}\n-\n-impl From<CompressedHybridIndex> for HybridIndex {\n-    #[inline]\n-    fn from(hybrid_index: CompressedHybridIndex) -> Self {\n-        let index = hybrid_index.0 & CompressedHybridIndex::INDEX_MASK;\n-\n-        match hybrid_index.0 & CompressedHybridIndex::TAG_MASK {\n-            CompressedHybridIndex::NEW_TAG => HybridIndex::New(NewDepNodeIndex::from_u32(index)),\n-            CompressedHybridIndex::RED_TAG => HybridIndex::Red(RedDepNodeIndex::from_u32(index)),\n-            CompressedHybridIndex::LIGHT_GREEN_TAG => {\n-                HybridIndex::LightGreen(LightGreenDepNodeIndex::from_u32(index))\n-            }\n-            CompressedHybridIndex::DARK_GREEN_TAG => {\n-                HybridIndex::DarkGreen(SerializedDepNodeIndex::from_u32(index))\n-            }\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n // Index type for `DepNodeData`'s edges.\n rustc_index::newtype_index! {\n     struct EdgeIndex { .. }\n }\n \n-/// Data for nodes in the current graph, divided into different collections\n-/// based on their presence in the previous graph, and if present, their color.\n-/// We divide nodes this way because different types of nodes are able to share\n-/// more or less data with the previous graph.\n-///\n-/// To enable more sharing, we distinguish between two kinds of green nodes.\n-/// Light green nodes are nodes in the previous graph that have been marked\n-/// green because we re-executed their queries and the results were the same as\n-/// in the previous session. Dark green nodes are nodes in the previous graph\n-/// that have been marked green because we were able to mark all of their\n-/// dependencies green.\n-///\n-/// Both light and dark green nodes can share the dep node and fingerprint with\n-/// the previous graph, but for light green nodes, we can't be sure that the\n-/// edges may be shared without comparing them against the previous edges, so we\n-/// store them directly (an approach in which we compare edges with the previous\n-/// edges to see if they can be shared was evaluated, but was not found to be\n-/// very profitable).\n-///\n-/// For dark green nodes, we can share everything with the previous graph, which\n-/// is why the `HybridIndex::DarkGreen` enum variant contains the index of the\n-/// node in the previous graph, and why we don't have a separate collection for\n-/// dark green node data--the collection is the `PreviousDepGraph` itself.\n-///\n-/// (Note that for dark green nodes, the edges in the previous graph\n-/// (`SerializedDepNodeIndex`s) must be converted to edges in the current graph\n-/// (`DepNodeIndex`s). `CurrentDepGraph` contains `prev_index_to_index`, which\n-/// can perform this conversion. It should always be possible, as by definition,\n-/// a dark green node is one whose dependencies from the previous session have\n-/// all been marked green--which means `prev_index_to_index` contains them.)\n-///\n-/// Node data is stored in parallel vectors to eliminate the padding between\n-/// elements that would be needed to satisfy alignment requirements of the\n-/// structure that would contain all of a node's data. We could group tightly\n-/// packing subsets of node data together and use fewer vectors, but for\n-/// consistency's sake, we use separate vectors for each piece of data.\n-struct DepNodeData<K> {\n-    /// Data for nodes not in previous graph.\n-    new: NewDepNodeData<K>,\n-\n-    /// Data for nodes in previous graph that have been marked red.\n-    red: RedDepNodeData,\n-\n-    /// Data for nodes in previous graph that have been marked light green.\n-    light_green: LightGreenDepNodeData,\n-\n-    // Edges for all nodes other than dark-green ones. Edges for each node\n-    // occupy a contiguous region of this collection, which a node can reference\n-    // using two indices. Storing edges this way rather than using an `EdgesVec`\n-    // for each node reduces memory consumption by a not insignificant amount\n-    // when compiling large crates. The downside is that we have to copy into\n-    // this collection the edges from the `EdgesVec`s that are built up during\n-    // query execution. But this is mostly balanced out by the more efficient\n-    // implementation of `DepGraph::serialize` enabled by this representation.\n-    unshared_edges: IndexVec<EdgeIndex, DepNodeIndex>,\n-\n-    /// Mapping from `DepNodeIndex` to an index into a collection above.\n-    /// Indicates which of the above collections contains a node's data.\n-    ///\n-    /// This collection is wasteful in time and space during incr-full builds,\n-    /// because for those, all nodes are new. However, the waste is relatively\n-    /// small, and the maintenance cost of avoiding using this for incr-full\n-    /// builds is somewhat high and prone to bugginess. It does not seem worth\n-    /// it at the time of this writing, but we may want to revisit the idea.\n-    hybrid_indices: IndexVec<DepNodeIndex, CompressedHybridIndex>,\n-}\n-\n-/// Data for nodes not in previous graph. Since we cannot share any data with\n-/// the previous graph, so we must store all of such a node's data here.\n-struct NewDepNodeData<K> {\n-    nodes: IndexVec<NewDepNodeIndex, DepNode<K>>,\n-    edges: IndexVec<NewDepNodeIndex, Range<EdgeIndex>>,\n-    fingerprints: IndexVec<NewDepNodeIndex, Fingerprint>,\n-}\n-\n-/// Data for nodes in previous graph that have been marked red. We can share the\n-/// dep node with the previous graph, but the edges may be different, and the\n-/// fingerprint is known to be different, so we store the latter two directly.\n-struct RedDepNodeData {\n-    node_indices: IndexVec<RedDepNodeIndex, SerializedDepNodeIndex>,\n-    edges: IndexVec<RedDepNodeIndex, Range<EdgeIndex>>,\n-    fingerprints: IndexVec<RedDepNodeIndex, Fingerprint>,\n-}\n-\n-/// Data for nodes in previous graph that have been marked green because we\n-/// re-executed their queries and the results were the same as in the previous\n-/// session. We can share the dep node and the fingerprint with the previous\n-/// graph, but the edges may be different, so we store them directly.\n-struct LightGreenDepNodeData {\n-    node_indices: IndexVec<LightGreenDepNodeIndex, SerializedDepNodeIndex>,\n-    edges: IndexVec<LightGreenDepNodeIndex, Range<EdgeIndex>>,\n-}\n-\n /// `CurrentDepGraph` stores the dependency graph for the current session. It\n /// will be populated as we run queries or tasks. We never remove nodes from the\n /// graph: they are only added.\n ///\n-/// The nodes in it are identified by a `DepNodeIndex`. Internally, this maps to\n-/// a `HybridIndex`, which identifies which collection in the `data` field\n-/// contains a node's data. Which collection is used for a node depends on\n-/// whether the node was present in the `PreviousDepGraph`, and if so, the color\n-/// of the node. Each type of node can share more or less data with the previous\n-/// graph. When possible, we can store just the index of the node in the\n-/// previous graph, rather than duplicating its data in our own collections.\n-/// This is important, because these graph structures are some of the largest in\n-/// the compiler.\n+/// The nodes in it are identified by a `DepNodeIndex`. We avoid keeping the nodes\n+/// in memory.  This is important, because these graph structures are some of the\n+/// largest in the compiler.\n ///\n-/// For the same reason, we also avoid storing `DepNode`s more than once as map\n+/// For this reason, we avoid storing `DepNode`s more than once as map\n /// keys. The `new_node_to_index` map only contains nodes not in the previous\n /// graph, and we map nodes in the previous graph to indices via a two-step\n /// mapping. `PreviousDepGraph` maps from `DepNode` to `SerializedDepNodeIndex`,\n@@ -1417,15 +869,15 @@ struct LightGreenDepNodeData {\n /// `new_node_to_index` and `data`, or `prev_index_to_index` and `data`. When\n /// manipulating both, we acquire `new_node_to_index` or `prev_index_to_index`\n /// first, and `data` second.\n-pub(super) struct CurrentDepGraph<K> {\n-    data: Lock<DepNodeData<K>>,\n+pub(super) struct CurrentDepGraph<K: DepKind> {\n+    encoder: Steal<GraphEncoder<K>>,\n     new_node_to_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n     prev_index_to_index: Lock<IndexVec<SerializedDepNodeIndex, Option<DepNodeIndex>>>,\n \n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n-    #[allow(dead_code)]\n-    forbidden_edge: Option<EdgeFilter>,\n+    #[cfg(debug_assertions)]\n+    forbidden_edge: Option<EdgeFilter<K>>,\n \n     /// Anonymous `DepNode`s are nodes whose IDs we compute from the list of\n     /// their edges. This has the beneficial side-effect that multiple anonymous\n@@ -1447,78 +899,42 @@ pub(super) struct CurrentDepGraph<K> {\n }\n \n impl<K: DepKind> CurrentDepGraph<K> {\n-    fn new(prev_graph_node_count: usize) -> CurrentDepGraph<K> {\n+    fn new(\n+        prev_graph_node_count: usize,\n+        encoder: FileEncoder,\n+        record_graph: bool,\n+        record_stats: bool,\n+    ) -> CurrentDepGraph<K> {\n         use std::time::{SystemTime, UNIX_EPOCH};\n \n         let duration = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n         let nanos = duration.as_secs() * 1_000_000_000 + duration.subsec_nanos() as u64;\n         let mut stable_hasher = StableHasher::new();\n         nanos.hash(&mut stable_hasher);\n \n-        let forbidden_edge = if cfg!(debug_assertions) {\n-            match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n-                Ok(s) => match EdgeFilter::new(&s) {\n-                    Ok(f) => Some(f),\n-                    Err(err) => panic!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n-                },\n-                Err(_) => None,\n-            }\n-        } else {\n-            None\n+        #[cfg(debug_assertions)]\n+        let forbidden_edge = match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n+            Ok(s) => match EdgeFilter::new(&s) {\n+                Ok(f) => Some(f),\n+                Err(err) => panic!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n+            },\n+            Err(_) => None,\n         };\n \n-        // Pre-allocate the dep node structures. We over-allocate a little so\n-        // that we hopefully don't have to re-allocate during this compilation\n-        // session. The over-allocation for new nodes is 2% plus a small\n-        // constant to account for the fact that in very small crates 2% might\n-        // not be enough. The allocation for red and green node data doesn't\n-        // include a constant, as we don't want to allocate anything for these\n-        // structures during full incremental builds, where they aren't used.\n-        //\n-        // These estimates are based on the distribution of node and edge counts\n-        // seen in rustc-perf benchmarks, adjusted somewhat to account for the\n-        // fact that these benchmarks aren't perfectly representative.\n-        //\n-        // FIXME Use a collection type that doesn't copy node and edge data and\n-        // grow multiplicatively on reallocation. Without such a collection or\n-        // solution having the same effect, there is a performance hazard here\n-        // in both time and space, as growing these collections means copying a\n-        // large amount of data and doubling already large buffer capacities. A\n-        // solution for this will also mean that it's less important to get\n-        // these estimates right.\n-        let new_node_count_estimate = (prev_graph_node_count * 2) / 100 + 200;\n-        let red_node_count_estimate = (prev_graph_node_count * 3) / 100;\n-        let light_green_node_count_estimate = (prev_graph_node_count * 25) / 100;\n-        let total_node_count_estimate = prev_graph_node_count + new_node_count_estimate;\n-\n-        let average_edges_per_node_estimate = 6;\n-        let unshared_edge_count_estimate = average_edges_per_node_estimate\n-            * (new_node_count_estimate + red_node_count_estimate + light_green_node_count_estimate);\n-\n         // We store a large collection of these in `prev_index_to_index` during\n         // non-full incremental builds, and want to ensure that the element size\n         // doesn't inadvertently increase.\n         static_assert_size!(Option<DepNodeIndex>, 4);\n \n+        let new_node_count_estimate = 102 * prev_graph_node_count / 100 + 200;\n+\n         CurrentDepGraph {\n-            data: Lock::new(DepNodeData {\n-                new: NewDepNodeData {\n-                    nodes: IndexVec::with_capacity(new_node_count_estimate),\n-                    edges: IndexVec::with_capacity(new_node_count_estimate),\n-                    fingerprints: IndexVec::with_capacity(new_node_count_estimate),\n-                },\n-                red: RedDepNodeData {\n-                    node_indices: IndexVec::with_capacity(red_node_count_estimate),\n-                    edges: IndexVec::with_capacity(red_node_count_estimate),\n-                    fingerprints: IndexVec::with_capacity(red_node_count_estimate),\n-                },\n-                light_green: LightGreenDepNodeData {\n-                    node_indices: IndexVec::with_capacity(light_green_node_count_estimate),\n-                    edges: IndexVec::with_capacity(light_green_node_count_estimate),\n-                },\n-                unshared_edges: IndexVec::with_capacity(unshared_edge_count_estimate),\n-                hybrid_indices: IndexVec::with_capacity(total_node_count_estimate),\n-            }),\n+            encoder: Steal::new(GraphEncoder::new(\n+                encoder,\n+                prev_graph_node_count,\n+                record_graph,\n+                record_stats,\n+            )),\n             new_node_to_index: Sharded::new(|| {\n                 FxHashMap::with_capacity_and_hasher(\n                     new_node_count_estimate / sharded::SHARDS,\n@@ -1527,89 +943,143 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             }),\n             prev_index_to_index: Lock::new(IndexVec::from_elem_n(None, prev_graph_node_count)),\n             anon_id_seed: stable_hasher.finish(),\n+            #[cfg(debug_assertions)]\n             forbidden_edge,\n             total_read_count: AtomicU64::new(0),\n             total_duplicate_read_count: AtomicU64::new(0),\n         }\n     }\n \n+    #[cfg(debug_assertions)]\n+    fn record_edge(&self, dep_node_index: DepNodeIndex, key: DepNode<K>) {\n+        if let Some(forbidden_edge) = &self.forbidden_edge {\n+            forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n+        }\n+    }\n+\n+    /// Writes the node to the current dep-graph and allocates a `DepNodeIndex` for it.\n+    /// Assumes that this is a node that has no equivalent in the previous dep-graph.\n     fn intern_new_node(\n         &self,\n-        prev_graph: &PreviousDepGraph<K>,\n-        dep_node: DepNode<K>,\n+        profiler: &SelfProfilerRef,\n+        key: DepNode<K>,\n         edges: EdgesVec,\n-        fingerprint: Fingerprint,\n+        current_fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n-        debug_assert!(\n-            prev_graph.node_to_index_opt(&dep_node).is_none(),\n-            \"node in previous graph should be interned using one \\\n-            of `intern_red_node`, `intern_light_green_node`, etc.\"\n-        );\n-\n-        match self.new_node_to_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n+        match self.new_node_to_index.get_shard_by_value(&key).lock().entry(key) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n-                let data = &mut *self.data.lock();\n-                let new_index = data.new.nodes.push(dep_node);\n-                add_edges(&mut data.unshared_edges, &mut data.new.edges, edges);\n-                data.new.fingerprints.push(fingerprint);\n-                let dep_node_index = data.hybrid_indices.push(new_index.into());\n+                let dep_node_index =\n+                    self.encoder.borrow().send(profiler, key, current_fingerprint, edges);\n                 entry.insert(dep_node_index);\n+                #[cfg(debug_assertions)]\n+                self.record_edge(dep_node_index, key);\n                 dep_node_index\n             }\n         }\n     }\n \n-    fn intern_red_node(\n+    fn intern_node(\n         &self,\n+        profiler: &SelfProfilerRef,\n         prev_graph: &PreviousDepGraph<K>,\n-        prev_index: SerializedDepNodeIndex,\n+        key: DepNode<K>,\n         edges: EdgesVec,\n-        fingerprint: Fingerprint,\n-    ) -> DepNodeIndex {\n-        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n+        fingerprint: Option<Fingerprint>,\n+        print_status: bool,\n+    ) -> (DepNodeIndex, Option<(SerializedDepNodeIndex, DepNodeColor)>) {\n+        let print_status = cfg!(debug_assertions) && print_status;\n+\n+        if let Some(prev_index) = prev_graph.node_to_index_opt(&key) {\n+            // Determine the color and index of the new `DepNode`.\n+            if let Some(fingerprint) = fingerprint {\n+                if fingerprint == prev_graph.fingerprint_by_index(prev_index) {\n+                    if print_status {\n+                        eprintln!(\"[task::green] {:?}\", key);\n+                    }\n \n-        let mut prev_index_to_index = self.prev_index_to_index.lock();\n+                    // This is a green node: it existed in the previous compilation,\n+                    // its query was re-executed, and it has the same result as before.\n+                    let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+                    let dep_node_index = match prev_index_to_index[prev_index] {\n+                        Some(dep_node_index) => dep_node_index,\n+                        None => {\n+                            let dep_node_index =\n+                                self.encoder.borrow().send(profiler, key, fingerprint, edges);\n+                            prev_index_to_index[prev_index] = Some(dep_node_index);\n+                            dep_node_index\n+                        }\n+                    };\n \n-        match prev_index_to_index[prev_index] {\n-            Some(dep_node_index) => dep_node_index,\n-            None => {\n-                let data = &mut *self.data.lock();\n-                let red_index = data.red.node_indices.push(prev_index);\n-                add_edges(&mut data.unshared_edges, &mut data.red.edges, edges);\n-                data.red.fingerprints.push(fingerprint);\n-                let dep_node_index = data.hybrid_indices.push(red_index.into());\n-                prev_index_to_index[prev_index] = Some(dep_node_index);\n-                dep_node_index\n-            }\n-        }\n-    }\n+                    #[cfg(debug_assertions)]\n+                    self.record_edge(dep_node_index, key);\n+                    (dep_node_index, Some((prev_index, DepNodeColor::Green(dep_node_index))))\n+                } else {\n+                    if print_status {\n+                        eprintln!(\"[task::red] {:?}\", key);\n+                    }\n \n-    fn intern_light_green_node(\n-        &self,\n-        prev_graph: &PreviousDepGraph<K>,\n-        prev_index: SerializedDepNodeIndex,\n-        edges: EdgesVec,\n-    ) -> DepNodeIndex {\n-        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n+                    // This is a red node: it existed in the previous compilation, its query\n+                    // was re-executed, but it has a different result from before.\n+                    let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+                    let dep_node_index = match prev_index_to_index[prev_index] {\n+                        Some(dep_node_index) => dep_node_index,\n+                        None => {\n+                            let dep_node_index =\n+                                self.encoder.borrow().send(profiler, key, fingerprint, edges);\n+                            prev_index_to_index[prev_index] = Some(dep_node_index);\n+                            dep_node_index\n+                        }\n+                    };\n \n-        let mut prev_index_to_index = self.prev_index_to_index.lock();\n+                    #[cfg(debug_assertions)]\n+                    self.record_edge(dep_node_index, key);\n+                    (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n+                }\n+            } else {\n+                if print_status {\n+                    eprintln!(\"[task::unknown] {:?}\", key);\n+                }\n \n-        match prev_index_to_index[prev_index] {\n-            Some(dep_node_index) => dep_node_index,\n-            None => {\n-                let data = &mut *self.data.lock();\n-                let light_green_index = data.light_green.node_indices.push(prev_index);\n-                add_edges(&mut data.unshared_edges, &mut data.light_green.edges, edges);\n-                let dep_node_index = data.hybrid_indices.push(light_green_index.into());\n-                prev_index_to_index[prev_index] = Some(dep_node_index);\n-                dep_node_index\n+                // This is a red node, effectively: it existed in the previous compilation\n+                // session, its query was re-executed, but it doesn't compute a result hash\n+                // (i.e. it represents a `no_hash` query), so we have no way of determining\n+                // whether or not the result was the same as before.\n+                let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+                let dep_node_index = match prev_index_to_index[prev_index] {\n+                    Some(dep_node_index) => dep_node_index,\n+                    None => {\n+                        let dep_node_index =\n+                            self.encoder.borrow().send(profiler, key, Fingerprint::ZERO, edges);\n+                        prev_index_to_index[prev_index] = Some(dep_node_index);\n+                        dep_node_index\n+                    }\n+                };\n+\n+                #[cfg(debug_assertions)]\n+                self.record_edge(dep_node_index, key);\n+                (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n+            }\n+        } else {\n+            if print_status {\n+                eprintln!(\"[task::new] {:?}\", key);\n             }\n+\n+            let fingerprint = fingerprint.unwrap_or(Fingerprint::ZERO);\n+\n+            // This is a new node: it didn't exist in the previous compilation session.\n+            let dep_node_index = self.intern_new_node(profiler, key, edges, fingerprint);\n+\n+            (dep_node_index, None)\n         }\n     }\n \n-    fn intern_dark_green_node(\n+    fn promote_node_and_deps_to_current(\n         &self,\n+        profiler: &SelfProfilerRef,\n         prev_graph: &PreviousDepGraph<K>,\n         prev_index: SerializedDepNodeIndex,\n     ) -> DepNodeIndex {\n@@ -1620,9 +1090,20 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         match prev_index_to_index[prev_index] {\n             Some(dep_node_index) => dep_node_index,\n             None => {\n-                let mut data = self.data.lock();\n-                let dep_node_index = data.hybrid_indices.push(prev_index.into());\n+                let key = prev_graph.index_to_node(prev_index);\n+                let dep_node_index = self.encoder.borrow().send(\n+                    profiler,\n+                    key,\n+                    prev_graph.fingerprint_by_index(prev_index),\n+                    prev_graph\n+                        .edge_targets_from(prev_index)\n+                        .iter()\n+                        .map(|i| prev_index_to_index[*i].unwrap())\n+                        .collect(),\n+                );\n                 prev_index_to_index[prev_index] = Some(dep_node_index);\n+                #[cfg(debug_assertions)]\n+                self.record_edge(dep_node_index, key);\n                 dep_node_index\n             }\n         }\n@@ -1642,18 +1123,6 @@ impl<K: DepKind> CurrentDepGraph<K> {\n     }\n }\n \n-#[inline]\n-fn add_edges<I: Idx>(\n-    edges: &mut IndexVec<EdgeIndex, DepNodeIndex>,\n-    edge_indices: &mut IndexVec<I, Range<EdgeIndex>>,\n-    new_edges: EdgesVec,\n-) {\n-    let start = edges.next_index();\n-    edges.extend(new_edges);\n-    let end = edges.next_index();\n-    edge_indices.push(start..end);\n-}\n-\n /// The capacity of the `reads` field `SmallVec`\n const TASK_DEPS_READS_CAP: usize = 8;\n type EdgesVec = SmallVec<[DepNodeIndex; TASK_DEPS_READS_CAP]>;"}, {"sha": "1b6ecf3e637f3ff5e753aaa59ec39b6df63bce07", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -13,6 +13,7 @@ pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n \n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n+use rustc_serialize::{opaque::FileEncoder, Encodable};\n use rustc_session::Session;\n \n use std::fmt;\n@@ -59,7 +60,7 @@ impl<T: DepContext> HasDepContext for T {\n }\n \n /// Describe the different families of dependency nodes.\n-pub trait DepKind: Copy + fmt::Debug + Eq + Hash {\n+pub trait DepKind: Copy + fmt::Debug + Eq + Hash + Send + Encodable<FileEncoder> + 'static {\n     const NULL: Self;\n \n     /// Return whether this kind always require evaluation."}, {"sha": "27b3b5e13667e44bd47b52e2f93fab83538373f1", "filename": "compiler/rustc_query_system/src/dep_graph/query.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,34 +1,43 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::implementation::{Direction, Graph, NodeIndex, INCOMING};\n+use rustc_index::vec::IndexVec;\n \n-use super::{DepKind, DepNode};\n+use super::{DepKind, DepNode, DepNodeIndex};\n \n pub struct DepGraphQuery<K> {\n     pub graph: Graph<DepNode<K>, ()>,\n     pub indices: FxHashMap<DepNode<K>, NodeIndex>,\n+    pub dep_index_to_index: IndexVec<DepNodeIndex, Option<NodeIndex>>,\n }\n \n impl<K: DepKind> DepGraphQuery<K> {\n-    pub fn new(\n-        nodes: &[DepNode<K>],\n-        edge_list_indices: &[(usize, usize)],\n-        edge_list_data: &[usize],\n-    ) -> DepGraphQuery<K> {\n-        let mut graph = Graph::with_capacity(nodes.len(), edge_list_data.len());\n-        let mut indices = FxHashMap::default();\n-        for node in nodes {\n-            indices.insert(*node, graph.add_node(*node));\n+    pub fn new(prev_node_count: usize) -> DepGraphQuery<K> {\n+        let node_count = prev_node_count + prev_node_count / 4;\n+        let edge_count = 6 * node_count;\n+\n+        let graph = Graph::with_capacity(node_count, edge_count);\n+        let indices = FxHashMap::default();\n+        let dep_index_to_index = IndexVec::new();\n+\n+        DepGraphQuery { graph, indices, dep_index_to_index }\n+    }\n+\n+    pub fn push(&mut self, index: DepNodeIndex, node: DepNode<K>, edges: &[DepNodeIndex]) {\n+        let source = self.graph.add_node(node);\n+        if index.index() >= self.dep_index_to_index.len() {\n+            self.dep_index_to_index.resize(index.index() + 1, None);\n         }\n+        self.dep_index_to_index[index] = Some(source);\n+        self.indices.insert(node, source);\n \n-        for (source, &(start, end)) in edge_list_indices.iter().enumerate() {\n-            for &target in &edge_list_data[start..end] {\n-                let source = indices[&nodes[source]];\n-                let target = indices[&nodes[target]];\n-                graph.add_edge(source, target, ());\n+        for &target in edges.iter() {\n+            let target = self.dep_index_to_index[target];\n+            // We may miss the edges that are pushed while the `DepGraphQuery` is being accessed.\n+            // Skip them to issues.\n+            if let Some(target) = target {\n+                self.graph.add_edge(source, target, ());\n             }\n         }\n-\n-        DepGraphQuery { graph, indices }\n     }\n \n     pub fn nodes(&self) -> Vec<&DepNode<K>> {"}, {"sha": "6f3d1fb71994e11b78a72a63c7af61c8d44128ec", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 249, "deletions": 69, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,9 +1,28 @@\n //! The data that we will serialize and deserialize.\n+//!\n+//! The dep-graph is serialized as a sequence of NodeInfo, with the dependencies\n+//! specified inline.  The total number of nodes and edges are stored as the last\n+//! 16 bytes of the file, so we can find them easily at decoding time.\n+//!\n+//! The serialisation is performed on-demand when each node is emitted. Using this\n+//! scheme, we do not need to keep the current graph in memory.\n+//!\n+//! The deserisalisation is performed manually, in order to convert from the stored\n+//! sequence of NodeInfos to the different arrays in SerializedDepGraph.  Since the\n+//! node and edge count are stored at the end of the file, all the arrays can be\n+//! pre-allocated with the right length.\n \n-use super::{DepKind, DepNode};\n+use super::query::DepGraphQuery;\n+use super::{DepKind, DepNode, DepNodeIndex};\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_index::vec::IndexVec;\n-use rustc_serialize::{Decodable, Decoder};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::sync::Lock;\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_serialize::opaque::{self, FileEncodeResult, FileEncoder, IntEncodedWithFixedSize};\n+use rustc_serialize::{Decodable, Decoder, Encodable};\n+use smallvec::SmallVec;\n+use std::convert::TryInto;\n \n // The maximum value of `SerializedDepNodeIndex` leaves the upper two bits\n // unused so that we can store multiple index types in `CompressedHybridIndex`,\n@@ -50,78 +69,239 @@ impl<K: DepKind> SerializedDepGraph<K> {\n     }\n }\n \n-impl<D: Decoder, K: DepKind + Decodable<D>> Decodable<D> for SerializedDepGraph<K> {\n-    fn decode(d: &mut D) -> Result<SerializedDepGraph<K>, D::Error> {\n-        // We used to serialize the dep graph by creating and serializing a `SerializedDepGraph`\n-        // using data copied from the `DepGraph`. But copying created a large memory spike, so we\n-        // now serialize directly from the `DepGraph` as if it's a `SerializedDepGraph`. Because we\n-        // deserialize that data into a `SerializedDepGraph` in the next compilation session, we\n-        // need `DepGraph`'s `Encodable` and `SerializedDepGraph`'s `Decodable` implementations to\n-        // be in sync. If you update this decoding, be sure to update the encoding, and vice-versa.\n-        //\n-        // We mimic the sequence of `Encode` and `Encodable` method calls used by the `DepGraph`'s\n-        // `Encodable` implementation with the corresponding sequence of `Decode` and `Decodable`\n-        // method calls. E.g. `Decode::read_struct` pairs with `Encode::emit_struct`, `DepNode`'s\n-        // `decode` pairs with `DepNode`'s `encode`, and so on. Any decoding methods not associated\n-        // with corresponding encoding methods called in `DepGraph`'s `Encodable` implementation\n-        // are off limits, because we'd be relying on their implementation details.\n-        //\n-        // For example, because we know it happens to do the right thing, its tempting to just use\n-        // `IndexVec`'s `Decodable` implementation to decode into some of the collections below,\n-        // even though `DepGraph` doesn't use its `Encodable` implementation. But the `IndexVec`\n-        // implementation could change, and we'd have a bug.\n-        //\n-        // Variables below are explicitly typed so that anyone who changes the `SerializedDepGraph`\n-        // representation without updating this function will encounter a compilation error, and\n-        // know to update this and possibly the `DepGraph` `Encodable` implementation accordingly\n-        // (the latter should serialize data in a format compatible with our representation).\n-\n-        d.read_struct(\"SerializedDepGraph\", 4, |d| {\n-            let nodes: IndexVec<SerializedDepNodeIndex, DepNode<K>> =\n-                d.read_struct_field(\"nodes\", 0, |d| {\n-                    d.read_seq(|d, len| {\n-                        let mut v = IndexVec::with_capacity(len);\n-                        for i in 0..len {\n-                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n-                        }\n-                        Ok(v)\n-                    })\n-                })?;\n+impl<'a, K: DepKind + Decodable<opaque::Decoder<'a>>> Decodable<opaque::Decoder<'a>>\n+    for SerializedDepGraph<K>\n+{\n+    #[instrument(skip(d))]\n+    fn decode(d: &mut opaque::Decoder<'a>) -> Result<SerializedDepGraph<K>, String> {\n+        let start_position = d.position();\n \n-            let fingerprints: IndexVec<SerializedDepNodeIndex, Fingerprint> =\n-                d.read_struct_field(\"fingerprints\", 1, |d| {\n-                    d.read_seq(|d, len| {\n-                        let mut v = IndexVec::with_capacity(len);\n-                        for i in 0..len {\n-                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n-                        }\n-                        Ok(v)\n-                    })\n-                })?;\n+        // The last 16 bytes are the node count and edge count.\n+        debug!(\"position: {:?}\", d.position());\n+        d.set_position(d.data.len() - 2 * IntEncodedWithFixedSize::ENCODED_SIZE);\n+        debug!(\"position: {:?}\", d.position());\n \n-            let edge_list_indices: IndexVec<SerializedDepNodeIndex, (u32, u32)> = d\n-                .read_struct_field(\"edge_list_indices\", 2, |d| {\n-                    d.read_seq(|d, len| {\n-                        let mut v = IndexVec::with_capacity(len);\n-                        for i in 0..len {\n-                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n-                        }\n-                        Ok(v)\n-                    })\n-                })?;\n+        let node_count = IntEncodedWithFixedSize::decode(d)?.0 as usize;\n+        let edge_count = IntEncodedWithFixedSize::decode(d)?.0 as usize;\n+        debug!(?node_count, ?edge_count);\n+\n+        debug!(\"position: {:?}\", d.position());\n+        d.set_position(start_position);\n+        debug!(\"position: {:?}\", d.position());\n+\n+        let mut nodes = IndexVec::with_capacity(node_count);\n+        let mut fingerprints = IndexVec::with_capacity(node_count);\n+        let mut edge_list_indices = IndexVec::with_capacity(node_count);\n+        let mut edge_list_data = Vec::with_capacity(edge_count);\n+\n+        for _index in 0..node_count {\n+            d.read_struct(\"NodeInfo\", 3, |d| {\n+                let dep_node: DepNode<K> = d.read_struct_field(\"node\", 0, Decodable::decode)?;\n+                let _i: SerializedDepNodeIndex = nodes.push(dep_node);\n+                debug_assert_eq!(_i.index(), _index);\n \n-            let edge_list_data: Vec<SerializedDepNodeIndex> =\n-                d.read_struct_field(\"edge_list_data\", 3, |d| {\n+                let fingerprint: Fingerprint =\n+                    d.read_struct_field(\"fingerprint\", 1, Decodable::decode)?;\n+                let _i: SerializedDepNodeIndex = fingerprints.push(fingerprint);\n+                debug_assert_eq!(_i.index(), _index);\n+\n+                d.read_struct_field(\"edges\", 2, |d| {\n                     d.read_seq(|d, len| {\n-                        let mut v = Vec::with_capacity(len);\n-                        for i in 0..len {\n-                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+                        let start = edge_list_data.len().try_into().unwrap();\n+                        for e in 0..len {\n+                            let edge = d.read_seq_elt(e, Decodable::decode)?;\n+                            edge_list_data.push(edge);\n                         }\n-                        Ok(v)\n+                        let end = edge_list_data.len().try_into().unwrap();\n+                        let _i: SerializedDepNodeIndex = edge_list_indices.push((start, end));\n+                        debug_assert_eq!(_i.index(), _index);\n+                        Ok(())\n                     })\n-                })?;\n+                })\n+            })?;\n+        }\n+\n+        Ok(SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data })\n+    }\n+}\n+\n+#[derive(Debug, Encodable, Decodable)]\n+pub struct NodeInfo<K: DepKind> {\n+    node: DepNode<K>,\n+    fingerprint: Fingerprint,\n+    edges: SmallVec<[DepNodeIndex; 8]>,\n+}\n+\n+struct Stat<K: DepKind> {\n+    kind: K,\n+    node_counter: u64,\n+    edge_counter: u64,\n+}\n+\n+struct EncoderState<K: DepKind> {\n+    encoder: FileEncoder,\n+    total_node_count: usize,\n+    total_edge_count: usize,\n+    result: FileEncodeResult,\n+    stats: Option<FxHashMap<K, Stat<K>>>,\n+}\n+\n+impl<K: DepKind> EncoderState<K> {\n+    fn new(encoder: FileEncoder, record_stats: bool) -> Self {\n+        Self {\n+            encoder,\n+            total_edge_count: 0,\n+            total_node_count: 0,\n+            result: Ok(()),\n+            stats: if record_stats { Some(FxHashMap::default()) } else { None },\n+        }\n+    }\n+\n+    #[instrument(skip(self, record_graph))]\n+    fn encode_node(\n+        &mut self,\n+        node: &NodeInfo<K>,\n+        record_graph: &Option<Lock<DepGraphQuery<K>>>,\n+    ) -> DepNodeIndex {\n+        let index = DepNodeIndex::new(self.total_node_count);\n+        self.total_node_count += 1;\n+\n+        let edge_count = node.edges.len();\n+        self.total_edge_count += edge_count;\n+\n+        if let Some(record_graph) = &record_graph {\n+            // Do not ICE when a query is called from within `with_query`.\n+            if let Some(record_graph) = &mut record_graph.try_lock() {\n+                record_graph.push(index, node.node, &node.edges);\n+            }\n+        }\n+\n+        if let Some(stats) = &mut self.stats {\n+            let kind = node.node.kind;\n+\n+            let stat = stats.entry(kind).or_insert(Stat { kind, node_counter: 0, edge_counter: 0 });\n+            stat.node_counter += 1;\n+            stat.edge_counter += edge_count as u64;\n+        }\n+\n+        debug!(?index, ?node);\n+        let encoder = &mut self.encoder;\n+        if self.result.is_ok() {\n+            self.result = node.encode(encoder);\n+        }\n+        index\n+    }\n+\n+    fn finish(self) -> FileEncodeResult {\n+        let Self { mut encoder, total_node_count, total_edge_count, result, stats: _ } = self;\n+        let () = result?;\n+\n+        let node_count = total_node_count.try_into().unwrap();\n+        let edge_count = total_edge_count.try_into().unwrap();\n+\n+        debug!(?node_count, ?edge_count);\n+        debug!(\"position: {:?}\", encoder.position());\n+        IntEncodedWithFixedSize(node_count).encode(&mut encoder)?;\n+        IntEncodedWithFixedSize(edge_count).encode(&mut encoder)?;\n+        debug!(\"position: {:?}\", encoder.position());\n+        // Drop the encoder so that nothing is written after the counts.\n+        encoder.flush()\n+    }\n+}\n+\n+pub struct GraphEncoder<K: DepKind> {\n+    status: Lock<EncoderState<K>>,\n+    record_graph: Option<Lock<DepGraphQuery<K>>>,\n+}\n+\n+impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n+    pub fn new(\n+        encoder: FileEncoder,\n+        prev_node_count: usize,\n+        record_graph: bool,\n+        record_stats: bool,\n+    ) -> Self {\n+        let record_graph =\n+            if record_graph { Some(Lock::new(DepGraphQuery::new(prev_node_count))) } else { None };\n+        let status = Lock::new(EncoderState::new(encoder, record_stats));\n+        GraphEncoder { status, record_graph }\n+    }\n+\n+    pub(crate) fn with_query(&self, f: impl Fn(&DepGraphQuery<K>)) {\n+        if let Some(record_graph) = &self.record_graph {\n+            f(&record_graph.lock())\n+        }\n+    }\n+\n+    pub(crate) fn print_incremental_info(\n+        &self,\n+        total_read_count: u64,\n+        total_duplicate_read_count: u64,\n+    ) {\n+        let status = self.status.lock();\n+        if let Some(record_stats) = &status.stats {\n+            let mut stats: Vec<_> = record_stats.values().collect();\n+            stats.sort_by_key(|s| -(s.node_counter as i64));\n+\n+            const SEPARATOR: &str = \"[incremental] --------------------------------\\\n+                                     ----------------------------------------------\\\n+                                     ------------\";\n+\n+            eprintln!(\"[incremental]\");\n+            eprintln!(\"[incremental] DepGraph Statistics\");\n+            eprintln!(\"{}\", SEPARATOR);\n+            eprintln!(\"[incremental]\");\n+            eprintln!(\"[incremental] Total Node Count: {}\", status.total_node_count);\n+            eprintln!(\"[incremental] Total Edge Count: {}\", status.total_edge_count);\n+\n+            if cfg!(debug_assertions) {\n+                eprintln!(\"[incremental] Total Edge Reads: {}\", total_read_count);\n+                eprintln!(\n+                    \"[incremental] Total Duplicate Edge Reads: {}\",\n+                    total_duplicate_read_count\n+                );\n+            }\n+\n+            eprintln!(\"[incremental]\");\n+            eprintln!(\n+                \"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n+                \"Node Kind\", \"Node Frequency\", \"Node Count\", \"Avg. Edge Count\"\n+            );\n+            eprintln!(\"{}\", SEPARATOR);\n+\n+            for stat in stats {\n+                let node_kind_ratio =\n+                    (100.0 * (stat.node_counter as f64)) / (status.total_node_count as f64);\n+                let node_kind_avg_edges = (stat.edge_counter as f64) / (stat.node_counter as f64);\n+\n+                eprintln!(\n+                    \"[incremental]  {:<36}|{:>16.1}% |{:>12} |{:>17.1} |\",\n+                    format!(\"{:?}\", stat.kind),\n+                    node_kind_ratio,\n+                    stat.node_counter,\n+                    node_kind_avg_edges,\n+                );\n+            }\n+\n+            eprintln!(\"{}\", SEPARATOR);\n+            eprintln!(\"[incremental]\");\n+        }\n+    }\n+\n+    pub(crate) fn send(\n+        &self,\n+        profiler: &SelfProfilerRef,\n+        node: DepNode<K>,\n+        fingerprint: Fingerprint,\n+        edges: SmallVec<[DepNodeIndex; 8]>,\n+    ) -> DepNodeIndex {\n+        let _prof_timer = profiler.generic_activity(\"incr_comp_encode_dep_graph\");\n+        let node = NodeInfo { node, fingerprint, edges };\n+        self.status.lock().encode_node(&node, &self.record_graph)\n+    }\n \n-            Ok(SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data })\n-        })\n+    pub fn finish(self, profiler: &SelfProfilerRef) -> FileEncodeResult {\n+        let _prof_timer = profiler.generic_activity(\"incr_comp_encode_dep_graph\");\n+        self.status.into_inner().finish()\n     }\n }"}, {"sha": "071144f38e702f2459a45f58fd5f10e57b6dff85", "filename": "compiler/rustc_query_system/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Flib.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -2,6 +2,7 @@\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(core_intrinsics)]\n+#![feature(drain_filter)]\n #![feature(hash_raw_entry)]\n #![feature(iter_zip)]\n #![feature(min_specialization)]"}, {"sha": "fb8a53048fabaa4a5073e8a3fd60a2d2db3254d1", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -449,9 +449,11 @@ where\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n             tcx.start_query(job.id, diagnostics, || {\n-                tcx.dep_context()\n-                    .dep_graph()\n-                    .with_anon_task(query.dep_kind, || query.compute(tcx, key))\n+                tcx.dep_context().dep_graph().with_anon_task(\n+                    *tcx.dep_context(),\n+                    query.dep_kind,\n+                    || query.compute(tcx, key),\n+                )\n             })\n         });\n \n@@ -537,7 +539,7 @@ where\n         // If `-Zincremental-verify-ich` is specified, re-hash results from\n         // the cache and make sure that they have the expected fingerprint.\n         if unlikely!(tcx.dep_context().sess().opts.debugging_opts.incremental_verify_ich) {\n-            incremental_verify_ich(*tcx.dep_context(), &result, dep_node, dep_node_index, query);\n+            incremental_verify_ich(*tcx.dep_context(), &result, dep_node, query);\n         }\n \n         result\n@@ -560,7 +562,7 @@ where\n         //\n         // See issue #82920 for an example of a miscompilation that would get turned into\n         // an ICE by this check\n-        incremental_verify_ich(*tcx.dep_context(), &result, dep_node, dep_node_index, query);\n+        incremental_verify_ich(*tcx.dep_context(), &result, dep_node, query);\n \n         result\n     }\n@@ -570,14 +572,12 @@ fn incremental_verify_ich<CTX, K, V: Debug>(\n     tcx: CTX::DepContext,\n     result: &V,\n     dep_node: &DepNode<CTX::DepKind>,\n-    dep_node_index: DepNodeIndex,\n     query: &QueryVtable<CTX, K, V>,\n ) where\n     CTX: QueryContext,\n {\n     assert!(\n-        Some(tcx.dep_graph().fingerprint_of(dep_node_index))\n-            == tcx.dep_graph().prev_fingerprint_of(dep_node),\n+        tcx.dep_graph().is_green(dep_node),\n         \"fingerprint for green query instance not loaded from cache: {:?}\",\n         dep_node,\n     );\n@@ -588,9 +588,15 @@ fn incremental_verify_ich<CTX, K, V: Debug>(\n     let new_hash = query.hash_result(&mut hcx, result).unwrap_or(Fingerprint::ZERO);\n     debug!(\"END verify_ich({:?})\", dep_node);\n \n-    let old_hash = tcx.dep_graph().fingerprint_of(dep_node_index);\n+    let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n \n-    assert!(new_hash == old_hash, \"found unstable fingerprints for {:?}: {:?}\", dep_node, result);\n+    assert_eq!(\n+        Some(new_hash),\n+        old_hash,\n+        \"found unstable fingerprints for {:?}: {:?}\",\n+        dep_node,\n+        result\n+    );\n }\n \n fn force_query_with_job<C, CTX>("}, {"sha": "f441246909b45a80da6a41a978a76350eb34f22a", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -981,7 +981,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         OP: FnOnce(&mut Self) -> R,\n     {\n         let (result, dep_node) =\n-            self.tcx().dep_graph.with_anon_task(DepKind::TraitSelect, || op(self));\n+            self.tcx().dep_graph.with_anon_task(self.tcx(), DepKind::TraitSelect, || op(self));\n         self.tcx().dep_graph.read_index(dep_node);\n         (result, dep_node)\n     }"}, {"sha": "5313d1715c4835574c22bcddf63ff88cba76510c", "filename": "src/test/ui/async-await/issues/issue-64964.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64964.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64964.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64964.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,5 +1,5 @@\n // check-pass\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -C incremental=tmp/issue-64964\n // edition:2018\n \n // Regression test for ICE related to `await`ing in a method + incr. comp. (#64964)"}, {"sha": "a0ee3ad31e6976f2899f146405ee5ba5454f69d8", "filename": "src/test/ui/dep-graph/dep-graph-assoc-type-codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,7 +1,7 @@\n // Test that when a trait impl changes, fns whose body uses that trait\n // must also be recompiled.\n \n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -C incremental=tmp/dep-graph-assoc-type-codegen\n \n #![feature(rustc_attrs)]\n #![allow(warnings)]"}, {"sha": "c95ea53650b479b78abbc6dd1344366089d43178", "filename": "src/test/ui/dep-graph/dep-graph-caller-callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,7 +1,7 @@\n // Test that immediate callers have to change when callee changes, but\n // not callers' callers.\n \n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -C incremental=tmp/dep-graph-caller-callee\n \n #![feature(rustc_attrs)]\n #![allow(dead_code)]"}, {"sha": "50a670b87723826eacd976d93747d085f243f894", "filename": "src/test/ui/dep-graph/dep-graph-struct-signature.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,7 +1,7 @@\n // Test cases where a changing struct appears in the signature of fns\n // and methods.\n \n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -C incremental=tmp/dep-graph-struct-signature\n \n #![feature(rustc_attrs)]\n #![allow(dead_code)]"}, {"sha": "c0a6617316b8dc9994c991cc5a9e52175262a32a", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits-same-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,7 +1,7 @@\n // Test that adding an impl to a trait `Foo` DOES affect functions\n // that only use `Bar` if they have methods in common.\n \n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -C incremental=tmp/dep-graph-trait-impl-two-traits-same-method\n \n #![feature(rustc_attrs)]\n #![allow(dead_code)]"}, {"sha": "56e9762ddb26c1740b55ee185748175e31b97d7c", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,7 +1,7 @@\n // Test that adding an impl to a trait `Foo` does not affect functions\n // that only use `Bar`, so long as they do not have methods in common.\n \n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -C incremental=tmp/dep-graph-trait-impl-two-traits\n \n #![feature(rustc_attrs)]\n #![allow(warnings)]"}, {"sha": "3bbe3e745ca691c7ad266f3946996b82a4ca642a", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,7 +1,7 @@\n // Test that when a trait impl changes, fns whose body uses that trait\n // must also be recompiled.\n \n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -C incremental=tmp/dep-graph-trait-impl\n \n #![feature(rustc_attrs)]\n #![allow(warnings)]"}, {"sha": "5c5e24693a4f563039c99a0edc55f840fc613203", "filename": "src/test/ui/dep-graph/dep-graph-type-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,6 +1,6 @@\n // Test that changing what a `type` points to does not go unnoticed.\n \n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -C incremental=tmp/dep-graph-type-alias\n \n #![feature(rustc_attrs)]\n #![allow(dead_code)]"}, {"sha": "6cc1f44104a097c023f0d4b90ffe6ad8a027644f", "filename": "src/test/ui/dep-graph/dep-graph-variance-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d474075a8f28ae9a410e95d849d009006db4b176/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.rs?ref=d474075a8f28ae9a410e95d849d009006db4b176", "patch": "@@ -1,7 +1,7 @@\n // Test that changing what a `type` points to does not go unnoticed\n // by the variance analysis.\n \n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -C incremental=tmp/dep-graph-variance-alias\n \n #![feature(rustc_attrs)]\n #![allow(dead_code)]"}]}