{"sha": "cb6ed427174031f67f226da292aa85f8127f4513", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNmVkNDI3MTc0MDMxZjY3ZjIyNmRhMjkyYWE4NWY4MTI3ZjQ1MTM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-16T05:50:29Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-16T05:50:35Z"}, "message": "core: Generalize uint-string conversions to all uint types\n\nIssue #2239", "tree": {"sha": "439c464588b9a01dadbd9620548fdfa3a556965e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/439c464588b9a01dadbd9620548fdfa3a556965e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb6ed427174031f67f226da292aa85f8127f4513", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb6ed427174031f67f226da292aa85f8127f4513", "html_url": "https://github.com/rust-lang/rust/commit/cb6ed427174031f67f226da292aa85f8127f4513", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb6ed427174031f67f226da292aa85f8127f4513/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e21a05e6c0bc0bfa905291a916b38bdb9daf90d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d", "html_url": "https://github.com/rust-lang/rust/commit/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d"}], "stats": {"total": 286, "additions": 120, "deletions": 166}, "files": [{"sha": "2b769b4d028d1d7beb843929b9903c3cd1e59c51", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb6ed427174031f67f226da292aa85f8127f4513/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cb6ed427174031f67f226da292aa85f8127f4513/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=cb6ed427174031f67f226da292aa85f8127f4513", "patch": "@@ -95,10 +95,10 @@ mod i64 {\n mod uint {\n     import inst::{\n         div_ceil, div_round, div_floor, hash, iterate,\n-        next_power_of_two, parse_buf, from_str, to_str, str\n+        next_power_of_two\n     };\n     export div_ceil, div_round, div_floor, hash, iterate,\n-    next_power_of_two, parse_buf, from_str, to_str, str;\n+    next_power_of_two;\n \n     #[path = \"uint.rs\"]\n     mod inst;\n@@ -131,9 +131,6 @@ mod u32 {\n #[doc = \"Operations and constants for `u64`\"]\n #[path = \"uint-template\"]\n mod u64 {\n-    import inst::{ to_str, str, from_str };\n-    export to_str, str, from_str;\n-\n     #[path = \"u64.rs\"]\n     mod inst;\n }"}, {"sha": "7c4a5439dfc057fd60129c6810f3b58baff7cf21", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/cb6ed427174031f67f226da292aa85f8127f4513/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb6ed427174031f67f226da292aa85f8127f4513/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=cb6ed427174031f67f226da292aa85f8127f4513", "patch": "@@ -8,6 +8,7 @@ export is_positive, is_negative;\n export is_nonpositive, is_nonnegative;\n export range;\n export compl;\n+export to_str, from_str, from_str_radix, str, parse_buf;\n \n const min_value: T = 0 as T;\n const max_value: T = 0 as T - 1 as T;\n@@ -43,3 +44,118 @@ fn range(lo: T, hi: T, it: fn(T)) {\n pure fn compl(i: T) -> T {\n     max_value ^ i\n }\n+\n+#[doc = \"\n+Parse a buffer of bytes\n+\n+# Arguments\n+\n+* buf - A byte buffer\n+* radix - The base of the number\n+\n+# Failure\n+\n+`buf` must not be empty\n+\"]\n+fn parse_buf(buf: [u8], radix: uint) -> option<T> {\n+    if vec::len(buf) == 0u { ret none; }\n+    let mut i = vec::len(buf) - 1u;\n+    let mut power = 1u as T;\n+    let mut n = 0u as T;\n+    loop {\n+        alt char::to_digit(buf[i] as char, radix) {\n+          some(d) { n += d as T * power; }\n+          none { ret none; }\n+        }\n+        power *= radix as T;\n+        if i == 0u { ret some(n); }\n+        i -= 1u;\n+    };\n+}\n+\n+#[doc = \"Parse a string to an int\"]\n+fn from_str(s: str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n+\n+#[doc = \"Parse a string as an unsigned integer.\"]\n+fn from_str_radix(buf: str, radix: u64) -> option<u64> {\n+    if str::len(buf) == 0u { ret none; }\n+    let mut i = str::len(buf) - 1u;\n+    let mut power = 1u64, n = 0u64;\n+    loop {\n+        alt char::to_digit(buf[i] as char, radix as uint) {\n+          some(d) { n += d as u64 * power; }\n+          none { ret none; }\n+        }\n+        power *= radix;\n+        if i == 0u { ret some(n); }\n+        i -= 1u;\n+    };\n+}\n+\n+#[doc = \"Convert to a string in a given base\"]\n+fn to_str(num: T, radix: uint) -> str {\n+    assert (0u < radix && radix <= 16u);\n+    let mut n = num;\n+    let radix = radix as T;\n+    fn digit(n: T) -> char {\n+        ret alt n {\n+              0u as T { '0' }\n+              1u as T { '1' }\n+              2u as T { '2' }\n+              3u as T { '3' }\n+              4u as T { '4' }\n+              5u as T { '5' }\n+              6u as T { '6' }\n+              7u as T { '7' }\n+              8u as T { '8' }\n+              9u as T { '9' }\n+              10u as T { 'a' }\n+              11u as T { 'b' }\n+              12u as T { 'c' }\n+              13u as T { 'd' }\n+              14u as T { 'e' }\n+              15u as T { 'f' }\n+              _ { fail }\n+            };\n+    }\n+    if n == 0u as T { ret \"0\"; }\n+    let mut s: str = \"\";\n+    while n != 0u as T {\n+        s += str::from_byte(digit(n % radix) as u8);\n+        n /= radix;\n+    }\n+    let mut s1: str = \"\";\n+    let mut len: uint = str::len(s);\n+    while len != 0u { len -= 1u; s1 += str::from_byte(s[len]); }\n+    ret s1;\n+}\n+\n+#[doc = \"Convert to a string\"]\n+fn str(i: T) -> str { ret to_str(i, 10u); }\n+\n+#[test]\n+fn test_from_str() {\n+    assert from_str(\"0\") == some(0u as T);\n+    assert from_str(\"3\") == some(3u as T);\n+    assert from_str(\"10\") == some(10u as T);\n+    assert from_str(\"123456789\") == some(123456789u as T);\n+    assert from_str(\"00100\") == some(100u as T);\n+\n+    assert from_str(\"\") == none;\n+    assert from_str(\" \") == none;\n+    assert from_str(\"x\") == none;\n+}\n+\n+#[test]\n+fn test_parse_buf() {\n+    import str::bytes;\n+    assert parse_buf(bytes(\"123\"), 10u) == some(123u as T);\n+    assert parse_buf(bytes(\"1001\"), 2u) == some(9u as T);\n+    assert parse_buf(bytes(\"123\"), 8u) == some(83u as T);\n+    assert parse_buf(bytes(\"123\"), 16u) == some(291u as T);\n+    assert parse_buf(bytes(\"ffff\"), 16u) == some(65535u as T);\n+    assert parse_buf(bytes(\"z\"), 36u) == some(35u as T);\n+\n+    assert parse_buf(str::bytes(\"Z\"), 10u) == none;\n+    assert parse_buf(str::bytes(\"_\"), 2u) == none;\n+}"}, {"sha": "4e83ebd49768c189cecdb369bddd652803e48d88", "filename": "src/libcore/uint-template/u64.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cb6ed427174031f67f226da292aa85f8127f4513/src%2Flibcore%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb6ed427174031f67f226da292aa85f8127f4513/src%2Flibcore%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu64.rs?ref=cb6ed427174031f67f226da292aa85f8127f4513", "patch": "@@ -1,62 +1 @@\n type T = u64;\n-\n-// Type-specific functions here. These must be reexported by the\n-// parent module so that they appear in core::u8 and not core::u8::u8;\n-\n-\n-// FIXME: Surely we can generalize this to apply to all uint types\n-#[doc = \"Convert to a string in a given base\"]\n-fn to_str(n: u64, radix: uint) -> str {\n-    assert (0u < radix && radix <= 16u);\n-\n-    let r64 = radix as u64;\n-\n-    fn digit(n: u64) -> str {\n-        ret alt n {\n-              0u64 { \"0\" }\n-              1u64 { \"1\" }\n-              2u64 { \"2\" }\n-              3u64 { \"3\" }\n-              4u64 { \"4\" }\n-              5u64 { \"5\" }\n-              6u64 { \"6\" }\n-              7u64 { \"7\" }\n-              8u64 { \"8\" }\n-              9u64 { \"9\" }\n-              10u64 { \"a\" }\n-              11u64 { \"b\" }\n-              12u64 { \"c\" }\n-              13u64 { \"d\" }\n-              14u64 { \"e\" }\n-              15u64 { \"f\" }\n-              _ { fail }\n-            };\n-    }\n-\n-    if n == 0u64 { ret \"0\"; }\n-\n-    let mut s = \"\";\n-\n-    let mut n = n;\n-    while n > 0u64 { s = digit(n % r64) + s; n /= r64; }\n-    ret s;\n-}\n-\n-#[doc = \"Convert to a string\"]\n-fn str(n: u64) -> str { ret to_str(n, 10u); }\n-\n-#[doc = \"Parse a string as an unsigned integer.\"]\n-fn from_str(buf: str, radix: u64) -> option<u64> {\n-    if str::len(buf) == 0u { ret none; }\n-    let mut i = str::len(buf) - 1u;\n-    let mut power = 1u64, n = 0u64;\n-    loop {\n-        alt char::to_digit(buf[i] as char, radix as uint) {\n-          some(d) { n += d as u64 * power; }\n-          none { ret none; }\n-        }\n-        power *= radix;\n-        if i == 0u { ret some(n); }\n-        i -= 1u;\n-    };\n-}"}, {"sha": "c8fb9731d472fd7dc43d8d3ac2363ae64db7e169", "filename": "src/libcore/uint-template/uint.rs", "status": "modified", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/cb6ed427174031f67f226da292aa85f8127f4513/src%2Flibcore%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb6ed427174031f67f226da292aa85f8127f4513/src%2Flibcore%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fuint.rs?ref=cb6ed427174031f67f226da292aa85f8127f4513", "patch": "@@ -89,104 +89,6 @@ fn next_power_of_two(n: uint) -> uint {\n     ret tmp + 1u;\n }\n \n-#[doc = \"\n-Parse a buffer of bytes\n-\n-# Arguments\n-\n-* buf - A byte buffer\n-* radix - The base of the number\n-\n-# Failure\n-\n-`buf` must not be empty\n-\"]\n-fn parse_buf(buf: [u8], radix: uint) -> option<uint> {\n-    if vec::len(buf) == 0u { ret none; }\n-    let mut i = vec::len(buf) - 1u;\n-    let mut power = 1u;\n-    let mut n = 0u;\n-    loop {\n-        alt char::to_digit(buf[i] as char, radix) {\n-          some(d) { n += d * power; }\n-          none { ret none; }\n-        }\n-        power *= radix;\n-        if i == 0u { ret some(n); }\n-        i -= 1u;\n-    };\n-}\n-\n-#[doc = \"Parse a string to an int\"]\n-fn from_str(s: str) -> option<uint> { parse_buf(str::bytes(s), 10u) }\n-\n-#[doc = \"Convert to a string in a given base\"]\n-fn to_str(num: uint, radix: uint) -> str {\n-    let mut n = num;\n-    assert (0u < radix && radix <= 16u);\n-    fn digit(n: uint) -> char {\n-        ret alt n {\n-              0u { '0' }\n-              1u { '1' }\n-              2u { '2' }\n-              3u { '3' }\n-              4u { '4' }\n-              5u { '5' }\n-              6u { '6' }\n-              7u { '7' }\n-              8u { '8' }\n-              9u { '9' }\n-              10u { 'a' }\n-              11u { 'b' }\n-              12u { 'c' }\n-              13u { 'd' }\n-              14u { 'e' }\n-              15u { 'f' }\n-              _ { fail }\n-            };\n-    }\n-    if n == 0u { ret \"0\"; }\n-    let mut s: str = \"\";\n-    while n != 0u {\n-        s += str::from_byte(digit(n % radix) as u8);\n-        n /= radix;\n-    }\n-    let mut s1: str = \"\";\n-    let mut len: uint = str::len(s);\n-    while len != 0u { len -= 1u; s1 += str::from_byte(s[len]); }\n-    ret s1;\n-}\n-\n-#[doc = \"Convert to a string\"]\n-fn str(i: uint) -> str { ret to_str(i, 10u); }\n-\n-#[test]\n-fn test_from_str() {\n-    assert uint::from_str(\"0\") == some(0u);\n-    assert uint::from_str(\"3\") == some(3u);\n-    assert uint::from_str(\"10\") == some(10u);\n-    assert uint::from_str(\"123456789\") == some(123456789u);\n-    assert uint::from_str(\"00100\") == some(100u);\n-\n-    assert uint::from_str(\"\") == none;\n-    assert uint::from_str(\" \") == none;\n-    assert uint::from_str(\"x\") == none;\n-}\n-\n-#[Test]\n-fn test_parse_buf() {\n-    import str::bytes;\n-    assert uint::parse_buf(bytes(\"123\"), 10u) == some(123u);\n-    assert uint::parse_buf(bytes(\"1001\"), 2u) == some(9u);\n-    assert uint::parse_buf(bytes(\"123\"), 8u) == some(83u);\n-    assert uint::parse_buf(bytes(\"123\"), 16u) == some(291u);\n-    assert uint::parse_buf(bytes(\"ffff\"), 16u) == some(65535u);\n-    assert uint::parse_buf(bytes(\"z\"), 36u) == some(35u);\n-\n-    assert uint::parse_buf(str::bytes(\"Z\"), 10u) == none;\n-    assert uint::parse_buf(str::bytes(\"_\"), 2u) == none;\n-}\n-\n #[test]\n fn test_next_power_of_two() {\n     assert (uint::next_power_of_two(0u) == 0u);"}, {"sha": "e486355501f5d04c7a70cc3afcd9f108c858aac2", "filename": "src/librustsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb6ed427174031f67f226da292aa85f8127f4513/src%2Flibrustsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb6ed427174031f67f226da292aa85f8127f4513/src%2Flibrustsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Flexer.rs?ref=cb6ed427174031f67f226da292aa85f8127f4513", "patch": "@@ -223,7 +223,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n         if str::len(num_str) == 0u {\n             rdr.fatal(\"no valid digits found for number\");\n         }\n-        let parsed = option::get(u64::from_str(num_str, base as u64));\n+        let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n         alt tp {\n           either::left(t) { ret token::LIT_INT(parsed as i64, t); }\n           either::right(t) { ret token::LIT_UINT(parsed, t); }\n@@ -271,7 +271,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n         if str::len(num_str) == 0u {\n             rdr.fatal(\"no valid digits found for number\");\n         }\n-        let parsed = option::get(u64::from_str(num_str, base as u64));\n+        let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n         ret token::LIT_INT(parsed as i64, ast::ty_i);\n     }\n }"}]}