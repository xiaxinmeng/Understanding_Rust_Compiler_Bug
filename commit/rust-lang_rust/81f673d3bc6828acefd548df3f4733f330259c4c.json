{"sha": "81f673d3bc6828acefd548df3f4733f330259c4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZjY3M2QzYmM2ODI4YWNlZmQ1NDhkZjNmNDczM2YzMzAyNTljNGM=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-02-16T18:48:28Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-02-22T19:07:09Z"}, "message": "Simplify search-index serialization", "tree": {"sha": "2840cd44e0111bd946271869401439b942c6816f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2840cd44e0111bd946271869401439b942c6816f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81f673d3bc6828acefd548df3f4733f330259c4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81f673d3bc6828acefd548df3f4733f330259c4c", "html_url": "https://github.com/rust-lang/rust/commit/81f673d3bc6828acefd548df3f4733f330259c4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81f673d3bc6828acefd548df3f4733f330259c4c/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "810a51402917672a6dd8a3f063ea118c79016481", "url": "https://api.github.com/repos/rust-lang/rust/commits/810a51402917672a6dd8a3f063ea118c79016481", "html_url": "https://github.com/rust-lang/rust/commit/810a51402917672a6dd8a3f063ea118c79016481"}], "stats": {"total": 206, "additions": 94, "deletions": 112}, "files": [{"sha": "692d230446cda7b356b028021237f610c28bb141", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 94, "deletions": 112, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/81f673d3bc6828acefd548df3f4733f330259c4c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f673d3bc6828acefd548df3f4733f330259c4c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=81f673d3bc6828acefd548df3f4733f330259c4c", "patch": "@@ -52,7 +52,7 @@ use std::sync::Arc;\n \n use externalfiles::ExternalHtml;\n \n-use serialize::json::as_json;\n+use serialize::json::{ToJson, Json, as_json};\n use syntax::{abi, ast};\n use syntax::feature_gate::UnstableFeatures;\n use rustc::middle::cstore::LOCAL_CRATE;\n@@ -290,22 +290,40 @@ struct IndexItem {\n     path: String,\n     desc: String,\n     parent: Option<DefId>,\n+    parent_idx: Option<usize>,\n     search_type: Option<IndexItemFunctionType>,\n }\n \n+impl ToJson for IndexItem {\n+    fn to_json(&self) -> Json {\n+        assert_eq!(self.parent.is_some(), self.parent_idx.is_some());\n+\n+        let mut data = Vec::with_capacity(6);\n+        data.push((self.ty as usize).to_json());\n+        data.push(self.name.to_json());\n+        data.push(self.path.to_json());\n+        data.push(self.desc.to_json());\n+        data.push(self.parent_idx.to_json());\n+        data.push(self.search_type.to_json());\n+\n+        Json::Array(data)\n+    }\n+}\n+\n /// A type used for the search index.\n struct Type {\n     name: Option<String>,\n }\n \n-impl fmt::Display for Type {\n-    /// Formats type as {name: $name}.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // Wrapping struct fmt should never call us when self.name is None,\n-        // but just to be safe we write `null` in that case.\n+impl ToJson for Type {\n+    fn to_json(&self) -> Json {\n         match self.name {\n-            Some(ref n) => write!(f, \"{{\\\"name\\\":\\\"{}\\\"}}\", n),\n-            None => write!(f, \"null\")\n+            Some(ref name) => {\n+                let mut data = BTreeMap::new();\n+                data.insert(\"name\".to_owned(), name.to_json());\n+                Json::Object(data)\n+            },\n+            None => Json::Null\n         }\n     }\n }\n@@ -316,26 +334,17 @@ struct IndexItemFunctionType {\n     output: Option<Type>\n }\n \n-impl fmt::Display for IndexItemFunctionType {\n-    /// Formats a full fn type as a JSON {inputs: [Type], outputs: Type/null}.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl ToJson for IndexItemFunctionType {\n+    fn to_json(&self) -> Json {\n         // If we couldn't figure out a type, just write `null`.\n-        if self.inputs.iter().any(|ref i| i.name.is_none()) ||\n-           (self.output.is_some() && self.output.as_ref().unwrap().name.is_none()) {\n-            return write!(f, \"null\")\n+        if self.inputs.iter().chain(self.output.iter()).any(|ref i| i.name.is_none()) {\n+            Json::Null\n+        } else {\n+            let mut data = BTreeMap::new();\n+            data.insert(\"inputs\".to_owned(), self.inputs.to_json());\n+            data.insert(\"output\".to_owned(), self.output.to_json());\n+            Json::Object(data)\n         }\n-\n-        let inputs: Vec<String> = self.inputs.iter().map(|ref t| {\n-            format!(\"{}\", t)\n-        }).collect();\n-        try!(write!(f, \"{{\\\"inputs\\\":[{}],\\\"output\\\":\", inputs.join(\",\")));\n-\n-        match self.output {\n-            Some(ref t) => try!(write!(f, \"{}\", t)),\n-            None => try!(write!(f, \"null\"))\n-        };\n-\n-        Ok(try!(write!(f, \"}}\")))\n     }\n }\n \n@@ -537,104 +546,76 @@ pub fn run(mut krate: clean::Crate,\n /// Build the search index from the collected metadata\n fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut nodeid_to_pathid = HashMap::new();\n-    let mut pathid_to_nodeid = Vec::new();\n-    {\n-        let Cache { ref mut search_index,\n-                    ref orphan_methods,\n-                    ref mut paths, .. } = *cache;\n-\n-        // Attach all orphan methods to the type's definition if the type\n-        // has since been learned.\n-        for &(did, ref item) in orphan_methods {\n-            match paths.get(&did) {\n-                Some(&(ref fqp, _)) => {\n-                    // Needed to determine `self` type.\n-                    let parent_basename = Some(fqp[fqp.len() - 1].clone());\n-                    search_index.push(IndexItem {\n-                        ty: shortty(item),\n-                        name: item.name.clone().unwrap(),\n-                        path: fqp[..fqp.len() - 1].join(\"::\"),\n-                        desc: Escape(&shorter(item.doc_value())).to_string(),\n-                        parent: Some(did),\n-                        search_type: get_index_search_type(&item, parent_basename),\n-                    });\n-                },\n-                None => {}\n-            }\n-        }\n-\n-        // Reduce `NodeId` in paths into smaller sequential numbers,\n-        // and prune the paths that do not appear in the index.\n-        for item in search_index.iter() {\n-            match item.parent {\n-                Some(nodeid) => {\n-                    if !nodeid_to_pathid.contains_key(&nodeid) {\n-                        let pathid = pathid_to_nodeid.len();\n-                        nodeid_to_pathid.insert(nodeid, pathid);\n-                        pathid_to_nodeid.push(nodeid);\n-                    }\n-                }\n-                None => {}\n-            }\n+    let mut crate_items = Vec::with_capacity(cache.search_index.len());\n+    let mut crate_paths = Vec::<Json>::new();\n+\n+    let Cache { ref mut search_index,\n+                ref orphan_methods,\n+                ref mut paths, .. } = *cache;\n+\n+    // Attach all orphan methods to the type's definition if the type\n+    // has since been learned.\n+    for &(did, ref item) in orphan_methods {\n+        match paths.get(&did) {\n+            Some(&(ref fqp, _)) => {\n+                // Needed to determine `self` type.\n+                let parent_basename = Some(fqp[fqp.len() - 1].clone());\n+                search_index.push(IndexItem {\n+                    ty: shortty(item),\n+                    name: item.name.clone().unwrap(),\n+                    path: fqp[..fqp.len() - 1].join(\"::\"),\n+                    desc: Escape(&shorter(item.doc_value())).to_string(),\n+                    parent: Some(did),\n+                    parent_idx: None,\n+                    search_type: get_index_search_type(&item, parent_basename),\n+                });\n+            },\n+            None => {}\n         }\n-        assert_eq!(nodeid_to_pathid.len(), pathid_to_nodeid.len());\n     }\n \n-    // Collect the index into a string\n-    let mut w = io::Cursor::new(Vec::new());\n-    let krate_doc = krate.module.as_ref().map(|module| {\n-        Escape(&shorter(module.doc_value())).to_string()\n-    }).unwrap_or(\"\".to_owned());\n+    // Reduce `NodeId` in paths into smaller sequential numbers,\n+    // and prune the paths that do not appear in the index.\n+    let mut lastpath = String::new();\n+    let mut lastpathid = 0usize;\n+\n+    for item in search_index {\n+        item.parent_idx = item.parent.map(|nodeid| {\n+            if nodeid_to_pathid.contains_key(&nodeid) {\n+                *nodeid_to_pathid.get(&nodeid).unwrap()\n+            } else {\n+                let pathid = lastpathid;\n+                nodeid_to_pathid.insert(nodeid, pathid);\n+                lastpathid += 1;\n \n-    write!(&mut w, r#\"searchIndex[{}] = {{doc: {}, \"items\":[\"#,\n-                   as_json(&krate.name),\n-                   as_json(&krate_doc)).unwrap();\n+                let &(ref fqp, short) = paths.get(&nodeid).unwrap();\n+                crate_paths.push(((short as usize), fqp.last().unwrap().clone()).to_json());\n+                pathid\n+            }\n+        });\n \n-    let mut lastpath = \"\".to_string();\n-    for (i, item) in cache.search_index.iter().enumerate() {\n-        // Omit the path if it is same to that of the prior item.\n-        let path;\n+        // Omit the parent path if it is same to that of the prior item.\n         if lastpath == item.path {\n-            path = \"\";\n+            item.path.clear();\n         } else {\n-            lastpath = item.path.to_string();\n-            path = &item.path;\n-        };\n-\n-        if i > 0 {\n-            write!(&mut w, \",\").unwrap();\n-        }\n-        write!(&mut w, \"[{},{},{},{}\",\n-               item.ty as usize,\n-               as_json(&item.name), as_json(&path), as_json(&item.desc)).unwrap();\n-        match item.parent {\n-            Some(nodeid) => {\n-                let pathid = *nodeid_to_pathid.get(&nodeid).unwrap();\n-                write!(&mut w, \",{}\", pathid).unwrap();\n-            }\n-            None => write!(&mut w, \",null\").unwrap()\n-        }\n-        match item.search_type {\n-            Some(ref t) => write!(&mut w, \",{}\", t).unwrap(),\n-            None => write!(&mut w, \",null\").unwrap()\n+            lastpath = item.path.clone();\n         }\n-        write!(&mut w, \"]\").unwrap();\n+        crate_items.push(item.to_json());\n     }\n \n-    write!(&mut w, r#\"],\"paths\":[\"#).unwrap();\n-\n-    for (i, &did) in pathid_to_nodeid.iter().enumerate() {\n-        let &(ref fqp, short) = cache.paths.get(&did).unwrap();\n-        if i > 0 {\n-            write!(&mut w, \",\").unwrap();\n-        }\n-        write!(&mut w, r#\"[{},\"{}\"]\"#,\n-               short as usize, *fqp.last().unwrap()).unwrap();\n-    }\n+    let crate_doc = krate.module.as_ref().map(|module| {\n+        Escape(&shorter(module.doc_value())).to_string()\n+    }).unwrap_or(String::new());\n \n-    write!(&mut w, \"]}};\").unwrap();\n+    let mut crate_data = BTreeMap::new();\n+    crate_data.insert(\"doc\".to_owned(), Json::String(crate_doc));\n+    crate_data.insert(\"items\".to_owned(), Json::Array(crate_items));\n+    crate_data.insert(\"paths\".to_owned(), Json::Array(crate_paths));\n \n-    String::from_utf8(w.into_inner()).unwrap()\n+    // Collect the index into a string\n+    format!(\"searchIndex[{}] = {};\",\n+            as_json(&krate.name),\n+            Json::Object(crate_data))\n }\n \n fn write_shared(cx: &Context,\n@@ -1073,6 +1054,7 @@ impl DocFolder for Cache {\n                             path: path.join(\"::\").to_string(),\n                             desc: Escape(&shorter(item.doc_value())).to_string(),\n                             parent: parent,\n+                            parent_idx: None,\n                             search_type: get_index_search_type(&item, parent_basename),\n                         });\n                     }"}]}