{"sha": "4dfdc697e9ec79ed9f8b79246a4042bed58c201e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkZmRjNjk3ZTllYzc5ZWQ5ZjhiNzkyNDZhNDA0MmJlZDU4YzIwMWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-21T00:51:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-21T00:51:00Z"}, "message": "auto merge of #16331 : steveklabnik/rust/guide_macros_and_unsafe, r=brson\n\nThe last two sections of the guide, and a small conclusion. I suck at conclusions.\r\n\r\nI also realized I never covered strings, so I'm going to put that section up before we're actually 'done.'", "tree": {"sha": "032a5e420620b41766cc250b6152fc1683033e75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/032a5e420620b41766cc250b6152fc1683033e75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dfdc697e9ec79ed9f8b79246a4042bed58c201e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dfdc697e9ec79ed9f8b79246a4042bed58c201e", "html_url": "https://github.com/rust-lang/rust/commit/4dfdc697e9ec79ed9f8b79246a4042bed58c201e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dfdc697e9ec79ed9f8b79246a4042bed58c201e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33037fd23bbe7d1417a440e03e6e0d31ed36c37a", "url": "https://api.github.com/repos/rust-lang/rust/commits/33037fd23bbe7d1417a440e03e6e0d31ed36c37a", "html_url": "https://github.com/rust-lang/rust/commit/33037fd23bbe7d1417a440e03e6e0d31ed36c37a"}, {"sha": "139516685b59f3669d2b1e1b828b64bcd94aad97", "url": "https://api.github.com/repos/rust-lang/rust/commits/139516685b59f3669d2b1e1b828b64bcd94aad97", "html_url": "https://github.com/rust-lang/rust/commit/139516685b59f3669d2b1e1b828b64bcd94aad97"}], "stats": {"total": 181, "additions": 177, "deletions": 4}, "files": [{"sha": "af4b4ff6565fbd111a832bf65039cb9903c41933", "filename": "src/doc/guide.md", "status": "modified", "additions": 177, "deletions": 4, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/4dfdc697e9ec79ed9f8b79246a4042bed58c201e/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/4dfdc697e9ec79ed9f8b79246a4042bed58c201e/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=4dfdc697e9ec79ed9f8b79246a4042bed58c201e", "patch": "@@ -535,7 +535,7 @@ arguments we pass to functions and macros, if you're passing more than one.\n When you just use the curly braces, Rust will attempt to display the\n value in a meaningful way by checking out its type. If you want to specify the\n format in a more detailed manner, there are a [wide number of options\n-available](/std/fmt/index.html). For now, we'll just stick to the default:\n+available](std/fmt/index.html). For now, we'll just stick to the default:\n integers aren't very complicated to print.\n \n So, we've cleared up all of the confusion around bindings, with one exception:\n@@ -3520,15 +3520,15 @@ out.\n In systems programming, pointers are an incredibly important topic. Rust has a\n very rich set of pointers, and they operate differently than in many other\n languages. They are important enough that we have a specific [Pointer\n-Guide](/guide-pointers.html) that goes into pointers in much detail. In fact,\n+Guide](guide-pointers.html) that goes into pointers in much detail. In fact,\n while you're currently reading this guide, which covers the language in broad\n overview, there are a number of other guides that put a specific topic under a\n microscope. You can find the list of guides on the [documentation index\n-page](/index.html#guides).\n+page](index.html#guides).\n \n In this section, we'll assume that you're familiar with pointers as a general\n concept. If you aren't, please read the [introduction to\n-pointers](/guide-pointers.html#an-introduction) section of the Pointer Guide,\n+pointers](guide-pointers.html#an-introduction) section of the Pointer Guide,\n and then come back here. We'll wait.\n \n Got the gist? Great. Let's talk about pointers in Rust.\n@@ -5211,4 +5211,177 @@ fail.\n \n # Macros\n \n+One of Rust's most advanced features is its system of **macro**s. While\n+functions allow you to provide abstractions over values and operations, macros\n+allow you to provide abstractions over syntax. Do you wish Rust had the ability\n+to do something that it can't currently do? You may be able to write a macro\n+to extend Rust's capabilities.\n+\n+You've already used one macro extensively: `println!`. When we invoke\n+a Rust macro, we need to use the exclamation mark (`!`). There's two reasons\n+that this is true: the first is that it makes it clear when you're using a\n+macro. The second is that macros allow for flexible syntax, and so Rust must\n+be able to tell where a macro starts and ends. The `!(...)` helps with this.\n+\n+Let's talk some more about `println!`. We could have implemented `println!` as\n+a function, but it would be worse. Why? Well, what macros allow you to do\n+is write code that generates more code. So when we call `println!` like this:\n+\n+```{rust}\n+let x = 5i;\n+println!(\"x is: {}\", x);\n+```\n+\n+The `println!` macro does a few things:\n+\n+1. It parses the string to find any `{}`s\n+2. It checks that the number of `{}`s matches the number of other arguments.\n+3. It generates a bunch of Rust code, taking this in mind.\n+\n+What this means is that you get type checking at compile time, because\n+Rust will generate code that takes all of the types into account. If\n+`println!` was a function, it could still do this type checking, but it\n+would happen at run time rather than compile time.\n+\n+We can check this out using a special flag to `rustc`. This code, in a file\n+`print.rs`:\n+\n+```{rust}\n+fn main() {\n+    let x = \"Hello\";\n+    println!(\"x is: {:s}\", x);\n+}\n+```\n+\n+Can have its macros expanded like this: `rustc print.rs --pretty=expanded`, will\n+give us this huge result:\n+\n+```{rust,ignore}\n+#![feature(phase)]\n+#![no_std]\n+#![feature(globs)]\n+#[phase(plugin, link)]\n+extern crate std = \"std\";\n+extern crate rt = \"native\";\n+use std::prelude::*;\n+fn main() {\n+    let x = \"Hello\";\n+    match (&x,) {\n+        (__arg0,) => {\n+            #[inline]\n+            #[allow(dead_code)]\n+            static __STATIC_FMTSTR: [::std::fmt::rt::Piece<'static>, ..2u] =\n+                [::std::fmt::rt::String(\"x is: \"),\n+                 ::std::fmt::rt::Argument(::std::fmt::rt::Argument{position:\n+                                                                       ::std::fmt::rt::ArgumentNext,\n+                                                                   format:\n+                                                                       ::std::fmt::rt::FormatSpec{fill:\n+                                                                                                      ' ',\n+                                                                                                  align:\n+                                                                                                      ::std::fmt::rt::AlignUnknown,\n+                                                                                                  flags:\n+                                                                                                      0u,\n+                                                                                                  precision:\n+                                                                                                      ::std::fmt::rt::CountImplied,\n+                                                                                                  width:\n+                                                                                                      ::std::fmt::rt::CountImplied,},})];\n+            let __args_vec =\n+                &[::std::fmt::argument(::std::fmt::secret_string, __arg0)];\n+            let __args =\n+                unsafe {\n+                    ::std::fmt::Arguments::new(__STATIC_FMTSTR, __args_vec)\n+                };\n+            ::std::io::stdio::println_args(&__args)\n+        }\n+    };\n+}\n+```\n+\n+Intense. Here's a trimmed down version that's a bit easier to read:\n+\n+```{rust,ignore}\n+fn main() {\n+    let x = 5i;\n+    match (&x,) {\n+        (__arg0,) => {\n+            static __STATIC_FMTSTR:  =\n+                [String(\"x is: \"),\n+                 Argument(Argument {\n+                    position: ArgumentNext,\n+                    format: FormatSpec {\n+                        fill: ' ',\n+                        align: AlignUnknown,\n+                        flags: 0u,\n+                        precision: CountImplied,\n+                        width: CountImplied,\n+                    },\n+                },\n+               ];\n+            let __args_vec = &[argument(secret_string, __arg0)];\n+            let __args = unsafe { Arguments::new(__STATIC_FMTSTR, __args_vec) };\n+\n+            println_args(&__args)\n+        }\n+    };\n+}\n+```\n+\n+Whew! This isn't too terrible. You can see that we still `let x = 5i`, \n+but then things get a little bit hairy. Three more bindings get set: a\n+static format string, an argument vector, and the aruments. We then\n+invoke the `println_args` function with the generated arguments.\n+\n+This is the code (well, the full version) that Rust actually compiles. You can\n+see all of the extra information that's here. We get all of the type safety and\n+options that it provides, but at compile time, and without needing to type all\n+of this out. This is how macros are powerful. Without them, you would need to\n+type all of this by hand to get a type checked `println`.\n+\n+For more on macros, please consult [the Macros Guide](guide-macros.html).\n+Macros are a very advanced and still slightly experimental feature, but don't\n+require a deep understanding to call, since they look just like functions. The\n+Guide can help you if you want to write your own.\n+\n # Unsafe\n+\n+Finally, there's one more concept that you should be aware in Rust: `unsafe`.\n+There are two circumstances where Rust's safety provisions don't work well.\n+The first is when interfacing with C code, and the second is when building\n+certain kinds of abstractions.\n+\n+Rust has support for FFI, (which you can read about in the [FFI\n+Guide](guide-ffi.html)) but Rust can't guarantee that the C code will be safe,\n+like Rust's will. Therefore, Rust marks such functions with the `unsafe`\n+keyword, which indicates that the function may not behave properly.\n+\n+Second, if you'd like to create some sort of shared-memory data structure, Rust\n+won't allow it, because memory must be owned by a single owner. However, if\n+you're planning on making access to that shared memory safe, such as with a\n+mutex, _you_ know that it's safe, but Rust can't know. Writing an `unsafe`\n+block allows you to ask the compiler to trust you. In this case, the _internal_\n+implementation of the mutex is considered unsafe, but the _external_ interface\n+we present is safe. This allows it to be effectively used in normal Rust, while\n+being able to implement functionality that the compiler can't double check for\n+us.\n+\n+Doesn't an escape hatch undermine the safety of the entire system? Well, if\n+Rust code segfaults, it _must_ be because of unsafe code somewhere. By\n+annotating exactly where that is, you have a significantly smaller area to\n+search.\n+\n+We haven't even talked about any examples here, and that's because I want to\n+emphasize that you should not be writing unsafe code unless you know exactly\n+what you're doing. The vast majority of Rust developers will only interact with\n+it when doing FFI, and advanced library authors may use it to build certain\n+kinds of abstraction.\n+\n+# Conclusion\n+\n+We covered a lot of ground here. When you've mastered everything in this Guide,\n+you will have a firm grasp of basic Rust development. There's a whole lot more\n+out there, we've just covered the surface. There's tons of topics that you can\n+dig deeper into, and we've built specialized guides for many of them. To learn\n+more, dig into the [full documentation\n+index](http://doc.rust-lang.org/index.html).\n+\n+Happy hacking!"}]}