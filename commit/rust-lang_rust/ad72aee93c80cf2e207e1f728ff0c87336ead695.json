{"sha": "ad72aee93c80cf2e207e1f728ff0c87336ead695", "node_id": "C_kwDOAAsO6NoAKGFkNzJhZWU5M2M4MGNmMmUyMDdlMWY3MjhmZjBjODczMzZlYWQ2OTU", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2022-06-05T08:44:14Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2022-09-02T20:17:39Z"}, "message": "add `--explain` subcommand", "tree": {"sha": "634a7c3c980a657c26c24cdc39b4eebd5cbc47af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/634a7c3c980a657c26c24cdc39b4eebd5cbc47af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad72aee93c80cf2e207e1f728ff0c87336ead695", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad72aee93c80cf2e207e1f728ff0c87336ead695", "html_url": "https://github.com/rust-lang/rust/commit/ad72aee93c80cf2e207e1f728ff0c87336ead695", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad72aee93c80cf2e207e1f728ff0c87336ead695/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c36696ac0229ed706d3640177d6d90e232c6d615", "url": "https://api.github.com/repos/rust-lang/rust/commits/c36696ac0229ed706d3640177d6d90e232c6d615", "html_url": "https://github.com/rust-lang/rust/commit/c36696ac0229ed706d3640177d6d90e232c6d615"}], "stats": {"total": 13845, "additions": 13817, "deletions": 28}, "files": [{"sha": "b95061bf81a25e3b5290a95571cf50d87f0e235f", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 160, "deletions": 28, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -3,7 +3,7 @@ use aho_corasick::AhoCorasickBuilder;\n use indoc::writedoc;\n use itertools::Itertools;\n use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n-use std::collections::{HashMap, HashSet};\n+use std::collections::{BTreeSet, HashMap, HashSet};\n use std::ffi::OsStr;\n use std::fmt::Write;\n use std::fs::{self, OpenOptions};\n@@ -124,6 +124,8 @@ fn generate_lint_files(\n     let content = gen_lint_group_list(\"all\", all_group_lints);\n     process_file(\"clippy_lints/src/lib.register_all.rs\", update_mode, &content);\n \n+    update_docs(update_mode, &usable_lints);\n+\n     for (lint_group, lints) in Lint::by_lint_group(usable_lints.into_iter().chain(internal_lints)) {\n         let content = gen_lint_group_list(&lint_group, lints.iter());\n         process_file(\n@@ -140,6 +142,62 @@ fn generate_lint_files(\n     process_file(\"tests/ui/rename.rs\", update_mode, &content);\n }\n \n+fn update_docs(update_mode: UpdateMode, usable_lints: &[Lint]) {\n+    replace_region_in_file(update_mode, Path::new(\"src/docs.rs\"), \"docs! {\\n\", \"\\n}\\n\", |res| {\n+        for name in usable_lints.iter().map(|lint| lint.name.clone()).sorted() {\n+            writeln!(res, r#\"    \"{name}\",\"#).unwrap();\n+        }\n+    });\n+\n+    if update_mode == UpdateMode::Check {\n+        let mut extra = BTreeSet::new();\n+        let mut lint_names = usable_lints\n+            .iter()\n+            .map(|lint| lint.name.clone())\n+            .collect::<BTreeSet<_>>();\n+        for file in std::fs::read_dir(\"src/docs\").unwrap() {\n+            let filename = file.unwrap().file_name().into_string().unwrap();\n+            if let Some(name) = filename.strip_suffix(\".txt\") {\n+                if !lint_names.remove(name) {\n+                    extra.insert(name.to_string());\n+                }\n+            }\n+        }\n+\n+        let failed = print_lint_names(\"extra lint docs:\", &extra) | print_lint_names(\"missing lint docs:\", &lint_names);\n+\n+        if failed {\n+            exit_with_failure();\n+        }\n+    } else {\n+        if std::fs::remove_dir_all(\"src/docs\").is_err() {\n+            eprintln!(\"could not remove src/docs directory\");\n+        }\n+        if std::fs::create_dir(\"src/docs\").is_err() {\n+            eprintln!(\"could not recreate src/docs directory\");\n+        }\n+    }\n+    for lint in usable_lints {\n+        process_file(\n+            Path::new(\"src/docs\").join(lint.name.clone() + \".txt\"),\n+            update_mode,\n+            &lint.documentation,\n+        );\n+    }\n+}\n+\n+fn print_lint_names(header: &str, lints: &BTreeSet<String>) -> bool {\n+    if lints.is_empty() {\n+        return false;\n+    }\n+    println!(\"{}\", header);\n+    for lint in lints.iter().sorted() {\n+        println!(\"    {}\", lint);\n+    }\n+    println!();\n+    true\n+}\n+\n pub fn print_lints() {\n     let (lint_list, _, _) = gather_all();\n     let usable_lints = Lint::usable_lints(&lint_list);\n@@ -589,17 +647,26 @@ struct Lint {\n     desc: String,\n     module: String,\n     declaration_range: Range<usize>,\n+    documentation: String,\n }\n \n impl Lint {\n     #[must_use]\n-    fn new(name: &str, group: &str, desc: &str, module: &str, declaration_range: Range<usize>) -> Self {\n+    fn new(\n+        name: &str,\n+        group: &str,\n+        desc: &str,\n+        module: &str,\n+        declaration_range: Range<usize>,\n+        documentation: String,\n+    ) -> Self {\n         Self {\n             name: name.to_lowercase(),\n             group: group.into(),\n             desc: remove_line_splices(desc),\n             module: module.into(),\n             declaration_range,\n+            documentation,\n         }\n     }\n \n@@ -852,27 +919,35 @@ fn parse_contents(contents: &str, module: &str, lints: &mut Vec<Lint>) {\n          }| token_kind == &TokenKind::Ident && *content == \"declare_clippy_lint\",\n     ) {\n         let start = range.start;\n-\n-        let mut iter = iter\n-            .by_ref()\n-            .filter(|t| !matches!(t.token_kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n+        let mut docs = String::with_capacity(128);\n+        let mut iter = iter.by_ref().filter(|t| !matches!(t.token_kind, TokenKind::Whitespace));\n         // matches `!{`\n         match_tokens!(iter, Bang OpenBrace);\n-        match iter.next() {\n-            // #[clippy::version = \"version\"] pub\n-            Some(LintDeclSearchResult {\n-                token_kind: TokenKind::Pound,\n-                ..\n-            }) => {\n-                match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);\n-            },\n-            // pub\n-            Some(LintDeclSearchResult {\n-                token_kind: TokenKind::Ident,\n-                ..\n-            }) => (),\n-            _ => continue,\n+        let mut in_code = false;\n+        while let Some(t) = iter.next() {\n+            match t.token_kind {\n+                TokenKind::LineComment { .. } => {\n+                    if let Some(line) = t.content.strip_prefix(\"/// \").or_else(|| t.content.strip_prefix(\"///\")) {\n+                        if line.starts_with(\"```\") {\n+                            docs += \"```\\n\";\n+                            in_code = !in_code;\n+                        } else if !(in_code && line.starts_with(\"# \")) {\n+                            docs += line;\n+                            docs.push('\\n');\n+                        }\n+                    }\n+                },\n+                TokenKind::Pound => {\n+                    match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);\n+                    break;\n+                },\n+                TokenKind::Ident => {\n+                    break;\n+                },\n+                _ => {},\n+            }\n         }\n+        docs.pop(); // remove final newline\n \n         let (name, group, desc) = match_tokens!(\n             iter,\n@@ -890,7 +965,7 @@ fn parse_contents(contents: &str, module: &str, lints: &mut Vec<Lint>) {\n             ..\n         }) = iter.next()\n         {\n-            lints.push(Lint::new(name, group, desc, module, start..range.end));\n+            lints.push(Lint::new(name, group, desc, module, start..range.end, docs));\n         }\n     }\n }\n@@ -1120,13 +1195,15 @@ mod tests {\n                 \"\\\"really long text\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n             ),\n             Lint::new(\n                 \"doc_markdown\",\n                 \"pedantic\",\n                 \"\\\"single line\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n             ),\n         ];\n         assert_eq!(expected, result);\n@@ -1166,20 +1243,23 @@ mod tests {\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n             ),\n             Lint::new(\n                 \"should_assert_eq2\",\n                 \"internal\",\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n             ),\n             Lint::new(\n                 \"should_assert_eq2\",\n                 \"internal_style\",\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n             ),\n         ];\n         let expected = vec![Lint::new(\n@@ -1188,29 +1268,59 @@ mod tests {\n             \"\\\"abc\\\"\",\n             \"module_name\",\n             Range::default(),\n+            String::new(),\n         )];\n         assert_eq!(expected, Lint::usable_lints(&lints));\n     }\n \n     #[test]\n     fn test_by_lint_group() {\n         let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\n+                \"should_assert_eq\",\n+                \"group1\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+                String::new(),\n+            ),\n             Lint::new(\n                 \"should_assert_eq2\",\n                 \"group2\",\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n+            ),\n+            Lint::new(\n+                \"incorrect_match\",\n+                \"group1\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+                String::new(),\n             ),\n-            Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n         ];\n         let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();\n         expected.insert(\n             \"group1\".to_string(),\n             vec![\n-                Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n-                Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+                Lint::new(\n+                    \"should_assert_eq\",\n+                    \"group1\",\n+                    \"\\\"abc\\\"\",\n+                    \"module_name\",\n+                    Range::default(),\n+                    String::new(),\n+                ),\n+                Lint::new(\n+                    \"incorrect_match\",\n+                    \"group1\",\n+                    \"\\\"abc\\\"\",\n+                    \"module_name\",\n+                    Range::default(),\n+                    String::new(),\n+                ),\n             ],\n         );\n         expected.insert(\n@@ -1221,6 +1331,7 @@ mod tests {\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n             )],\n         );\n         assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));\n@@ -1259,9 +1370,30 @@ mod tests {\n     #[test]\n     fn test_gen_lint_group_list() {\n         let lints = vec![\n-            Lint::new(\"abc\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n-            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n-            Lint::new(\"internal\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\n+                \"abc\",\n+                \"group1\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+                String::new(),\n+            ),\n+            Lint::new(\n+                \"should_assert_eq\",\n+                \"group1\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+                String::new(),\n+            ),\n+            Lint::new(\n+                \"internal\",\n+                \"internal_style\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+                String::new(),\n+            ),\n         ];\n         let expected = GENERATED_FILE_COMMENT.to_string()\n             + &["}, {"sha": "69243bf4d9c95c92664833740373ff1c0499fbda", "filename": "src/docs.rs", "status": "added", "additions": 596, "deletions": 0, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs.rs?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,596 @@\n+// autogenerated. Please look at /clippy_dev/src/update_lints.rs\n+\n+macro_rules! include_lint {\n+    ($file_name: expr) => {\n+        include_str!($file_name)\n+    };\n+}\n+\n+macro_rules! docs {\n+    ($($lint_name: expr,)*) => {\n+        pub fn explain(lint: &str) {\n+            println!(\"{}\", match lint {\n+                $(\n+                    $lint_name => include_lint!(concat!(\"docs/\", concat!($lint_name, \".txt\"))),\n+                )*\n+                _ => \"unknown lint\",\n+            })\n+        }\n+    }\n+}\n+\n+docs! {\n+    \"absurd_extreme_comparisons\",\n+    \"alloc_instead_of_core\",\n+    \"allow_attributes_without_reason\",\n+    \"almost_complete_letter_range\",\n+    \"almost_swapped\",\n+    \"approx_constant\",\n+    \"arithmetic\",\n+    \"as_conversions\",\n+    \"as_underscore\",\n+    \"assertions_on_constants\",\n+    \"assertions_on_result_states\",\n+    \"assign_op_pattern\",\n+    \"async_yields_async\",\n+    \"await_holding_invalid_type\",\n+    \"await_holding_lock\",\n+    \"await_holding_refcell_ref\",\n+    \"bad_bit_mask\",\n+    \"bind_instead_of_map\",\n+    \"blanket_clippy_restriction_lints\",\n+    \"blocks_in_if_conditions\",\n+    \"bool_assert_comparison\",\n+    \"bool_comparison\",\n+    \"bool_to_int_with_if\",\n+    \"borrow_as_ptr\",\n+    \"borrow_deref_ref\",\n+    \"borrow_interior_mutable_const\",\n+    \"borrowed_box\",\n+    \"box_collection\",\n+    \"boxed_local\",\n+    \"branches_sharing_code\",\n+    \"builtin_type_shadow\",\n+    \"bytes_count_to_len\",\n+    \"bytes_nth\",\n+    \"cargo_common_metadata\",\n+    \"case_sensitive_file_extension_comparisons\",\n+    \"cast_abs_to_unsigned\",\n+    \"cast_enum_constructor\",\n+    \"cast_enum_truncation\",\n+    \"cast_lossless\",\n+    \"cast_possible_truncation\",\n+    \"cast_possible_wrap\",\n+    \"cast_precision_loss\",\n+    \"cast_ptr_alignment\",\n+    \"cast_ref_to_mut\",\n+    \"cast_sign_loss\",\n+    \"cast_slice_different_sizes\",\n+    \"cast_slice_from_raw_parts\",\n+    \"char_lit_as_u8\",\n+    \"chars_last_cmp\",\n+    \"chars_next_cmp\",\n+    \"checked_conversions\",\n+    \"clone_double_ref\",\n+    \"clone_on_copy\",\n+    \"clone_on_ref_ptr\",\n+    \"cloned_instead_of_copied\",\n+    \"cmp_nan\",\n+    \"cmp_null\",\n+    \"cmp_owned\",\n+    \"cognitive_complexity\",\n+    \"collapsible_else_if\",\n+    \"collapsible_if\",\n+    \"collapsible_match\",\n+    \"collapsible_str_replace\",\n+    \"comparison_chain\",\n+    \"comparison_to_empty\",\n+    \"copy_iterator\",\n+    \"crate_in_macro_def\",\n+    \"create_dir\",\n+    \"crosspointer_transmute\",\n+    \"dbg_macro\",\n+    \"debug_assert_with_mut_call\",\n+    \"decimal_literal_representation\",\n+    \"declare_interior_mutable_const\",\n+    \"default_instead_of_iter_empty\",\n+    \"default_numeric_fallback\",\n+    \"default_trait_access\",\n+    \"default_union_representation\",\n+    \"deprecated_cfg_attr\",\n+    \"deprecated_semver\",\n+    \"deref_addrof\",\n+    \"deref_by_slicing\",\n+    \"derivable_impls\",\n+    \"derive_hash_xor_eq\",\n+    \"derive_ord_xor_partial_ord\",\n+    \"derive_partial_eq_without_eq\",\n+    \"disallowed_methods\",\n+    \"disallowed_names\",\n+    \"disallowed_script_idents\",\n+    \"disallowed_types\",\n+    \"diverging_sub_expression\",\n+    \"doc_link_with_quotes\",\n+    \"doc_markdown\",\n+    \"double_comparisons\",\n+    \"double_must_use\",\n+    \"double_neg\",\n+    \"double_parens\",\n+    \"drop_copy\",\n+    \"drop_non_drop\",\n+    \"drop_ref\",\n+    \"duplicate_mod\",\n+    \"duplicate_underscore_argument\",\n+    \"duration_subsec\",\n+    \"else_if_without_else\",\n+    \"empty_drop\",\n+    \"empty_enum\",\n+    \"empty_line_after_outer_attr\",\n+    \"empty_loop\",\n+    \"empty_structs_with_brackets\",\n+    \"enum_clike_unportable_variant\",\n+    \"enum_glob_use\",\n+    \"enum_variant_names\",\n+    \"eq_op\",\n+    \"equatable_if_let\",\n+    \"erasing_op\",\n+    \"err_expect\",\n+    \"excessive_precision\",\n+    \"exhaustive_enums\",\n+    \"exhaustive_structs\",\n+    \"exit\",\n+    \"expect_fun_call\",\n+    \"expect_used\",\n+    \"expl_impl_clone_on_copy\",\n+    \"explicit_auto_deref\",\n+    \"explicit_counter_loop\",\n+    \"explicit_deref_methods\",\n+    \"explicit_into_iter_loop\",\n+    \"explicit_iter_loop\",\n+    \"explicit_write\",\n+    \"extend_with_drain\",\n+    \"extra_unused_lifetimes\",\n+    \"fallible_impl_from\",\n+    \"field_reassign_with_default\",\n+    \"filetype_is_file\",\n+    \"filter_map_identity\",\n+    \"filter_map_next\",\n+    \"filter_next\",\n+    \"flat_map_identity\",\n+    \"flat_map_option\",\n+    \"float_arithmetic\",\n+    \"float_cmp\",\n+    \"float_cmp_const\",\n+    \"float_equality_without_abs\",\n+    \"fn_address_comparisons\",\n+    \"fn_params_excessive_bools\",\n+    \"fn_to_numeric_cast\",\n+    \"fn_to_numeric_cast_any\",\n+    \"fn_to_numeric_cast_with_truncation\",\n+    \"for_kv_map\",\n+    \"for_loops_over_fallibles\",\n+    \"forget_copy\",\n+    \"forget_non_drop\",\n+    \"forget_ref\",\n+    \"format_in_format_args\",\n+    \"format_push_string\",\n+    \"from_iter_instead_of_collect\",\n+    \"from_over_into\",\n+    \"from_str_radix_10\",\n+    \"future_not_send\",\n+    \"get_first\",\n+    \"get_last_with_len\",\n+    \"get_unwrap\",\n+    \"identity_op\",\n+    \"if_let_mutex\",\n+    \"if_not_else\",\n+    \"if_same_then_else\",\n+    \"if_then_some_else_none\",\n+    \"ifs_same_cond\",\n+    \"implicit_clone\",\n+    \"implicit_hasher\",\n+    \"implicit_return\",\n+    \"implicit_saturating_sub\",\n+    \"imprecise_flops\",\n+    \"inconsistent_digit_grouping\",\n+    \"inconsistent_struct_constructor\",\n+    \"index_refutable_slice\",\n+    \"indexing_slicing\",\n+    \"ineffective_bit_mask\",\n+    \"inefficient_to_string\",\n+    \"infallible_destructuring_match\",\n+    \"infinite_iter\",\n+    \"inherent_to_string\",\n+    \"inherent_to_string_shadow_display\",\n+    \"init_numbered_fields\",\n+    \"inline_always\",\n+    \"inline_asm_x86_att_syntax\",\n+    \"inline_asm_x86_intel_syntax\",\n+    \"inline_fn_without_body\",\n+    \"inspect_for_each\",\n+    \"int_plus_one\",\n+    \"integer_arithmetic\",\n+    \"integer_division\",\n+    \"into_iter_on_ref\",\n+    \"invalid_null_ptr_usage\",\n+    \"invalid_regex\",\n+    \"invalid_upcast_comparisons\",\n+    \"invalid_utf8_in_unchecked\",\n+    \"invisible_characters\",\n+    \"is_digit_ascii_radix\",\n+    \"items_after_statements\",\n+    \"iter_cloned_collect\",\n+    \"iter_count\",\n+    \"iter_next_loop\",\n+    \"iter_next_slice\",\n+    \"iter_not_returning_iterator\",\n+    \"iter_nth\",\n+    \"iter_nth_zero\",\n+    \"iter_on_empty_collections\",\n+    \"iter_on_single_items\",\n+    \"iter_overeager_cloned\",\n+    \"iter_skip_next\",\n+    \"iter_with_drain\",\n+    \"iterator_step_by_zero\",\n+    \"just_underscores_and_digits\",\n+    \"large_const_arrays\",\n+    \"large_digit_groups\",\n+    \"large_enum_variant\",\n+    \"large_include_file\",\n+    \"large_stack_arrays\",\n+    \"large_types_passed_by_value\",\n+    \"len_without_is_empty\",\n+    \"len_zero\",\n+    \"let_and_return\",\n+    \"let_underscore_drop\",\n+    \"let_underscore_lock\",\n+    \"let_underscore_must_use\",\n+    \"let_unit_value\",\n+    \"linkedlist\",\n+    \"lossy_float_literal\",\n+    \"macro_use_imports\",\n+    \"main_recursion\",\n+    \"manual_assert\",\n+    \"manual_async_fn\",\n+    \"manual_bits\",\n+    \"manual_filter_map\",\n+    \"manual_find\",\n+    \"manual_find_map\",\n+    \"manual_flatten\",\n+    \"manual_instant_elapsed\",\n+    \"manual_map\",\n+    \"manual_memcpy\",\n+    \"manual_non_exhaustive\",\n+    \"manual_ok_or\",\n+    \"manual_range_contains\",\n+    \"manual_rem_euclid\",\n+    \"manual_retain\",\n+    \"manual_saturating_arithmetic\",\n+    \"manual_split_once\",\n+    \"manual_str_repeat\",\n+    \"manual_string_new\",\n+    \"manual_strip\",\n+    \"manual_swap\",\n+    \"manual_unwrap_or\",\n+    \"many_single_char_names\",\n+    \"map_clone\",\n+    \"map_collect_result_unit\",\n+    \"map_entry\",\n+    \"map_err_ignore\",\n+    \"map_flatten\",\n+    \"map_identity\",\n+    \"map_unwrap_or\",\n+    \"match_as_ref\",\n+    \"match_bool\",\n+    \"match_like_matches_macro\",\n+    \"match_on_vec_items\",\n+    \"match_overlapping_arm\",\n+    \"match_ref_pats\",\n+    \"match_result_ok\",\n+    \"match_same_arms\",\n+    \"match_single_binding\",\n+    \"match_str_case_mismatch\",\n+    \"match_wild_err_arm\",\n+    \"match_wildcard_for_single_variants\",\n+    \"maybe_infinite_iter\",\n+    \"mem_forget\",\n+    \"mem_replace_option_with_none\",\n+    \"mem_replace_with_default\",\n+    \"mem_replace_with_uninit\",\n+    \"min_max\",\n+    \"mismatched_target_os\",\n+    \"mismatching_type_param_order\",\n+    \"misrefactored_assign_op\",\n+    \"missing_const_for_fn\",\n+    \"missing_docs_in_private_items\",\n+    \"missing_enforced_import_renames\",\n+    \"missing_errors_doc\",\n+    \"missing_inline_in_public_items\",\n+    \"missing_panics_doc\",\n+    \"missing_safety_doc\",\n+    \"missing_spin_loop\",\n+    \"mistyped_literal_suffixes\",\n+    \"mixed_case_hex_literals\",\n+    \"mixed_read_write_in_expression\",\n+    \"mod_module_files\",\n+    \"module_inception\",\n+    \"module_name_repetitions\",\n+    \"modulo_arithmetic\",\n+    \"modulo_one\",\n+    \"multi_assignments\",\n+    \"multiple_crate_versions\",\n+    \"multiple_inherent_impl\",\n+    \"must_use_candidate\",\n+    \"must_use_unit\",\n+    \"mut_from_ref\",\n+    \"mut_mut\",\n+    \"mut_mutex_lock\",\n+    \"mut_range_bound\",\n+    \"mutable_key_type\",\n+    \"mutex_atomic\",\n+    \"mutex_integer\",\n+    \"naive_bytecount\",\n+    \"needless_arbitrary_self_type\",\n+    \"needless_bitwise_bool\",\n+    \"needless_bool\",\n+    \"needless_borrow\",\n+    \"needless_borrowed_reference\",\n+    \"needless_collect\",\n+    \"needless_continue\",\n+    \"needless_doctest_main\",\n+    \"needless_for_each\",\n+    \"needless_late_init\",\n+    \"needless_lifetimes\",\n+    \"needless_match\",\n+    \"needless_option_as_deref\",\n+    \"needless_option_take\",\n+    \"needless_parens_on_range_literals\",\n+    \"needless_pass_by_value\",\n+    \"needless_question_mark\",\n+    \"needless_range_loop\",\n+    \"needless_return\",\n+    \"needless_splitn\",\n+    \"needless_update\",\n+    \"neg_cmp_op_on_partial_ord\",\n+    \"neg_multiply\",\n+    \"negative_feature_names\",\n+    \"never_loop\",\n+    \"new_ret_no_self\",\n+    \"new_without_default\",\n+    \"no_effect\",\n+    \"no_effect_replace\",\n+    \"no_effect_underscore_binding\",\n+    \"non_ascii_literal\",\n+    \"non_octal_unix_permissions\",\n+    \"non_send_fields_in_send_ty\",\n+    \"nonminimal_bool\",\n+    \"nonsensical_open_options\",\n+    \"nonstandard_macro_braces\",\n+    \"not_unsafe_ptr_arg_deref\",\n+    \"obfuscated_if_else\",\n+    \"octal_escapes\",\n+    \"ok_expect\",\n+    \"only_used_in_recursion\",\n+    \"op_ref\",\n+    \"option_as_ref_deref\",\n+    \"option_env_unwrap\",\n+    \"option_filter_map\",\n+    \"option_if_let_else\",\n+    \"option_map_or_none\",\n+    \"option_map_unit_fn\",\n+    \"option_option\",\n+    \"or_fun_call\",\n+    \"or_then_unwrap\",\n+    \"out_of_bounds_indexing\",\n+    \"overflow_check_conditional\",\n+    \"overly_complex_bool_expr\",\n+    \"panic\",\n+    \"panic_in_result_fn\",\n+    \"panicking_unwrap\",\n+    \"partialeq_ne_impl\",\n+    \"partialeq_to_none\",\n+    \"path_buf_push_overwrite\",\n+    \"pattern_type_mismatch\",\n+    \"positional_named_format_parameters\",\n+    \"possible_missing_comma\",\n+    \"precedence\",\n+    \"print_in_format_impl\",\n+    \"print_literal\",\n+    \"print_stderr\",\n+    \"print_stdout\",\n+    \"print_with_newline\",\n+    \"println_empty_string\",\n+    \"ptr_arg\",\n+    \"ptr_as_ptr\",\n+    \"ptr_eq\",\n+    \"ptr_offset_with_cast\",\n+    \"pub_use\",\n+    \"question_mark\",\n+    \"range_minus_one\",\n+    \"range_plus_one\",\n+    \"range_zip_with_len\",\n+    \"rc_buffer\",\n+    \"rc_clone_in_vec_init\",\n+    \"rc_mutex\",\n+    \"read_zero_byte_vec\",\n+    \"recursive_format_impl\",\n+    \"redundant_allocation\",\n+    \"redundant_clone\",\n+    \"redundant_closure\",\n+    \"redundant_closure_call\",\n+    \"redundant_closure_for_method_calls\",\n+    \"redundant_else\",\n+    \"redundant_feature_names\",\n+    \"redundant_field_names\",\n+    \"redundant_pattern\",\n+    \"redundant_pattern_matching\",\n+    \"redundant_pub_crate\",\n+    \"redundant_slicing\",\n+    \"redundant_static_lifetimes\",\n+    \"ref_binding_to_reference\",\n+    \"ref_option_ref\",\n+    \"repeat_once\",\n+    \"rest_pat_in_fully_bound_structs\",\n+    \"result_large_err\",\n+    \"result_map_or_into_option\",\n+    \"result_map_unit_fn\",\n+    \"result_unit_err\",\n+    \"return_self_not_must_use\",\n+    \"reversed_empty_ranges\",\n+    \"same_functions_in_if_condition\",\n+    \"same_item_push\",\n+    \"same_name_method\",\n+    \"search_is_some\",\n+    \"self_assignment\",\n+    \"self_named_constructors\",\n+    \"self_named_module_files\",\n+    \"semicolon_if_nothing_returned\",\n+    \"separated_literal_suffix\",\n+    \"serde_api_misuse\",\n+    \"shadow_reuse\",\n+    \"shadow_same\",\n+    \"shadow_unrelated\",\n+    \"short_circuit_statement\",\n+    \"should_implement_trait\",\n+    \"significant_drop_in_scrutinee\",\n+    \"similar_names\",\n+    \"single_char_add_str\",\n+    \"single_char_lifetime_names\",\n+    \"single_char_pattern\",\n+    \"single_component_path_imports\",\n+    \"single_element_loop\",\n+    \"single_match\",\n+    \"single_match_else\",\n+    \"size_of_in_element_count\",\n+    \"skip_while_next\",\n+    \"slow_vector_initialization\",\n+    \"stable_sort_primitive\",\n+    \"std_instead_of_alloc\",\n+    \"std_instead_of_core\",\n+    \"str_to_string\",\n+    \"string_add\",\n+    \"string_add_assign\",\n+    \"string_extend_chars\",\n+    \"string_from_utf8_as_bytes\",\n+    \"string_lit_as_bytes\",\n+    \"string_slice\",\n+    \"string_to_string\",\n+    \"strlen_on_c_strings\",\n+    \"struct_excessive_bools\",\n+    \"suboptimal_flops\",\n+    \"suspicious_arithmetic_impl\",\n+    \"suspicious_assignment_formatting\",\n+    \"suspicious_else_formatting\",\n+    \"suspicious_map\",\n+    \"suspicious_op_assign_impl\",\n+    \"suspicious_operation_groupings\",\n+    \"suspicious_splitn\",\n+    \"suspicious_to_owned\",\n+    \"suspicious_unary_op_formatting\",\n+    \"swap_ptr_to_ref\",\n+    \"tabs_in_doc_comments\",\n+    \"temporary_assignment\",\n+    \"to_digit_is_some\",\n+    \"to_string_in_format_args\",\n+    \"todo\",\n+    \"too_many_arguments\",\n+    \"too_many_lines\",\n+    \"toplevel_ref_arg\",\n+    \"trailing_empty_array\",\n+    \"trait_duplication_in_bounds\",\n+    \"transmute_bytes_to_str\",\n+    \"transmute_float_to_int\",\n+    \"transmute_int_to_bool\",\n+    \"transmute_int_to_char\",\n+    \"transmute_int_to_float\",\n+    \"transmute_num_to_bytes\",\n+    \"transmute_ptr_to_ptr\",\n+    \"transmute_ptr_to_ref\",\n+    \"transmute_undefined_repr\",\n+    \"transmutes_expressible_as_ptr_casts\",\n+    \"transmuting_null\",\n+    \"trim_split_whitespace\",\n+    \"trivial_regex\",\n+    \"trivially_copy_pass_by_ref\",\n+    \"try_err\",\n+    \"type_complexity\",\n+    \"type_repetition_in_bounds\",\n+    \"undocumented_unsafe_blocks\",\n+    \"undropped_manually_drops\",\n+    \"unicode_not_nfc\",\n+    \"unimplemented\",\n+    \"uninit_assumed_init\",\n+    \"uninit_vec\",\n+    \"unit_arg\",\n+    \"unit_cmp\",\n+    \"unit_hash\",\n+    \"unit_return_expecting_ord\",\n+    \"unnecessary_cast\",\n+    \"unnecessary_filter_map\",\n+    \"unnecessary_find_map\",\n+    \"unnecessary_fold\",\n+    \"unnecessary_join\",\n+    \"unnecessary_lazy_evaluations\",\n+    \"unnecessary_mut_passed\",\n+    \"unnecessary_operation\",\n+    \"unnecessary_owned_empty_strings\",\n+    \"unnecessary_self_imports\",\n+    \"unnecessary_sort_by\",\n+    \"unnecessary_to_owned\",\n+    \"unnecessary_unwrap\",\n+    \"unnecessary_wraps\",\n+    \"unneeded_field_pattern\",\n+    \"unneeded_wildcard_pattern\",\n+    \"unnested_or_patterns\",\n+    \"unreachable\",\n+    \"unreadable_literal\",\n+    \"unsafe_derive_deserialize\",\n+    \"unsafe_removed_from_name\",\n+    \"unseparated_literal_suffix\",\n+    \"unsound_collection_transmute\",\n+    \"unused_async\",\n+    \"unused_io_amount\",\n+    \"unused_peekable\",\n+    \"unused_rounding\",\n+    \"unused_self\",\n+    \"unused_unit\",\n+    \"unusual_byte_groupings\",\n+    \"unwrap_in_result\",\n+    \"unwrap_or_else_default\",\n+    \"unwrap_used\",\n+    \"upper_case_acronyms\",\n+    \"use_debug\",\n+    \"use_self\",\n+    \"used_underscore_binding\",\n+    \"useless_asref\",\n+    \"useless_attribute\",\n+    \"useless_conversion\",\n+    \"useless_format\",\n+    \"useless_let_if_seq\",\n+    \"useless_transmute\",\n+    \"useless_vec\",\n+    \"vec_box\",\n+    \"vec_init_then_push\",\n+    \"vec_resize_to_zero\",\n+    \"verbose_bit_mask\",\n+    \"verbose_file_reads\",\n+    \"vtable_address_comparisons\",\n+    \"while_immutable_condition\",\n+    \"while_let_loop\",\n+    \"while_let_on_iterator\",\n+    \"wildcard_dependencies\",\n+    \"wildcard_enum_match_arm\",\n+    \"wildcard_imports\",\n+    \"wildcard_in_or_patterns\",\n+    \"write_literal\",\n+    \"write_with_newline\",\n+    \"writeln_empty_string\",\n+    \"wrong_self_convention\",\n+    \"wrong_transmute\",\n+    \"zero_divided_by_zero\",\n+    \"zero_prefixed_literal\",\n+    \"zero_ptr\",\n+    \"zero_sized_map_values\",\n+    \"zst_offset\",\n+\n+}"}, {"sha": "590bee28aa2376be4492aa4c9a53e918ec63805b", "filename": "src/docs/absurd_extreme_comparisons.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fabsurd_extreme_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fabsurd_extreme_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fabsurd_extreme_comparisons.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for comparisons where one side of the relation is\n+either the minimum or maximum value for its type and warns if it involves a\n+case that is always true or always false. Only integer and boolean types are\n+checked.\n+\n+### Why is this bad?\n+An expression like `min <= x` may misleadingly imply\n+that it is possible for `x` to be less than the minimum. Expressions like\n+`max < x` are probably mistakes.\n+\n+### Known problems\n+For `usize` the size of the current compile target will\n+be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n+a comparison to detect target pointer width will trigger this lint. One can\n+use `mem::sizeof` and compare its value or conditional compilation\n+attributes\n+like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n+\n+### Example\n+```\n+let vec: Vec<isize> = Vec::new();\n+if vec.len() <= 0 {}\n+if 100 > i32::MAX {}\n+```\n\\ No newline at end of file"}, {"sha": "488a36e9276c24d1bd1ded86983a6c423b39c9cb", "filename": "src/docs/alloc_instead_of_core.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Falloc_instead_of_core.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Falloc_instead_of_core.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Falloc_instead_of_core.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+\n+Finds items imported through `alloc` when available through `core`.\n+\n+### Why is this bad?\n+\n+Crates which have `no_std` compatibility and may optionally require alloc may wish to ensure types are\n+imported from core to ensure disabling `alloc` does not cause the crate to fail to compile. This lint\n+is also useful for crates migrating to become `no_std` compatible.\n+\n+### Example\n+```\n+use alloc::slice::from_ref;\n+```\n+Use instead:\n+```\n+use core::slice::from_ref;\n+```\n\\ No newline at end of file"}, {"sha": "fcc4f49b08b37be204fdc034de517c8ba7f1f747", "filename": "src/docs/allow_attributes_without_reason.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fallow_attributes_without_reason.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fallow_attributes_without_reason.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fallow_attributes_without_reason.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for attributes that allow lints without a reason.\n+\n+(This requires the `lint_reasons` feature)\n+\n+### Why is this bad?\n+Allowing a lint should always have a reason. This reason should be documented to\n+ensure that others understand the reasoning\n+\n+### Example\n+```\n+#![feature(lint_reasons)]\n+\n+#![allow(clippy::some_lint)]\n+```\n+\n+Use instead:\n+```\n+#![feature(lint_reasons)]\n+\n+#![allow(clippy::some_lint, reason = \"False positive rust-lang/rust-clippy#1002020\")]\n+```\n\\ No newline at end of file"}, {"sha": "01cbaf9eae259e26155ea29a65fd71addcbd1825", "filename": "src/docs/almost_complete_letter_range.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Falmost_complete_letter_range.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Falmost_complete_letter_range.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Falmost_complete_letter_range.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for ranges which almost include the entire range of letters from 'a' to 'z', but\n+don't because they're a half open range.\n+\n+### Why is this bad?\n+This (`'a'..'z'`) is almost certainly a typo meant to include all letters.\n+\n+### Example\n+```\n+let _ = 'a'..'z';\n+```\n+Use instead:\n+```\n+let _ = 'a'..='z';\n+```\n\\ No newline at end of file"}, {"sha": "cd10a8d5409b10afab8778ac88d91e4e5bbdbbfb", "filename": "src/docs/almost_swapped.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Falmost_swapped.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Falmost_swapped.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Falmost_swapped.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for `foo = bar; bar = foo` sequences.\n+\n+### Why is this bad?\n+This looks like a failed attempt to swap.\n+\n+### Example\n+```\n+a = b;\n+b = a;\n+```\n+If swapping is intended, use `swap()` instead:\n+```\n+std::mem::swap(&mut a, &mut b);\n+```\n\\ No newline at end of file"}, {"sha": "393fa4b5ef7ecd6734a6a78c64694646c45505be", "filename": "src/docs/approx_constant.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fapprox_constant.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fapprox_constant.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fapprox_constant.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for floating point literals that approximate\n+constants which are defined in\n+[`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\n+or\n+[`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\n+respectively, suggesting to use the predefined constant.\n+\n+### Why is this bad?\n+Usually, the definition in the standard library is more\n+precise than what people come up with. If you find that your definition is\n+actually more precise, please [file a Rust\n+issue](https://github.com/rust-lang/rust/issues).\n+\n+### Example\n+```\n+let x = 3.14;\n+let y = 1_f64 / x;\n+```\n+Use instead:\n+```\n+let x = std::f32::consts::PI;\n+let y = std::f64::consts::FRAC_1_PI;\n+```\n\\ No newline at end of file"}, {"sha": "0b3f07d95056db45749cfbadf4cfb500ddda301b", "filename": "src/docs/arithmetic.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Farithmetic.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Farithmetic.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Farithmetic.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for any kind of arithmetic operation of any type.\n+\n+Operators like `+`, `-`, `*` or `<<` are usually capable of overflowing according to the [Rust\n+Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n+or can panic (`/`, `%`). Known safe built-in types like `Wrapping` or `Saturing` are filtered\n+away.\n+\n+### Why is this bad?\n+Integer overflow will trigger a panic in debug builds or will wrap in\n+release mode. Division by zero will cause a panic in either mode. In some applications one\n+wants explicitly checked, wrapping or saturating arithmetic.\n+\n+#### Example\n+```\n+a + 1;\n+```\n+\n+Third-party types also tend to overflow.\n+\n+#### Example\n+```\n+use rust_decimal::Decimal;\n+let _n = Decimal::MAX + Decimal::MAX;\n+```\n+\n+### Allowed types\n+Custom allowed types can be specified through the \"arithmetic-allowed\" filter.\n\\ No newline at end of file"}, {"sha": "4af479bd8111cd213e98fc7a7b14a172a9714b87", "filename": "src/docs/as_conversions.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fas_conversions.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fas_conversions.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fas_conversions.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks for usage of `as` conversions.\n+\n+Note that this lint is specialized in linting *every single* use of `as`\n+regardless of whether good alternatives exist or not.\n+If you want more precise lints for `as`, please consider using these separate lints:\n+`unnecessary_cast`, `cast_lossless/cast_possible_truncation/cast_possible_wrap/cast_precision_loss/cast_sign_loss`,\n+`fn_to_numeric_cast(_with_truncation)`, `char_lit_as_u8`, `ref_to_mut` and `ptr_as_ptr`.\n+There is a good explanation the reason why this lint should work in this way and how it is useful\n+[in this issue](https://github.com/rust-lang/rust-clippy/issues/5122).\n+\n+### Why is this bad?\n+`as` conversions will perform many kinds of\n+conversions, including silently lossy conversions and dangerous coercions.\n+There are cases when it makes sense to use `as`, so the lint is\n+Allow by default.\n+\n+### Example\n+```\n+let a: u32;\n+...\n+f(a as u16);\n+```\n+\n+Use instead:\n+```\n+f(a.try_into()?);\n+\n+// or\n+\n+f(a.try_into().expect(\"Unexpected u16 overflow in f\"));\n+```\n\\ No newline at end of file"}, {"sha": "2d9b0c358936bc7c04d4c708da7a0bf72641cecf", "filename": "src/docs/as_underscore.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fas_underscore.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fas_underscore.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fas_underscore.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Check for the usage of `as _` conversion using inferred type.\n+\n+### Why is this bad?\n+The conversion might include lossy conversion and dangerous cast that might go\n+undetected due to the type being inferred.\n+\n+The lint is allowed by default as using `_` is less wordy than always specifying the type.\n+\n+### Example\n+```\n+fn foo(n: usize) {}\n+let n: u16 = 256;\n+foo(n as _);\n+```\n+Use instead:\n+```\n+fn foo(n: usize) {}\n+let n: u16 = 256;\n+foo(n as usize);\n+```\n\\ No newline at end of file"}, {"sha": "270c1e3b639d96fe496986e003eb62b3dae41f0c", "filename": "src/docs/assertions_on_constants.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fassertions_on_constants.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fassertions_on_constants.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fassertions_on_constants.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks for `assert!(true)` and `assert!(false)` calls.\n+\n+### Why is this bad?\n+Will be optimized out by the compiler or should probably be replaced by a\n+`panic!()` or `unreachable!()`\n+\n+### Example\n+```\n+assert!(false)\n+assert!(true)\n+const B: bool = false;\n+assert!(B)\n+```\n\\ No newline at end of file"}, {"sha": "0889084fd3ad61447b36aaf81a7fde499afd3577", "filename": "src/docs/assertions_on_result_states.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fassertions_on_result_states.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fassertions_on_result_states.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fassertions_on_result_states.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks for `assert!(r.is_ok())` or `assert!(r.is_err())` calls.\n+\n+### Why is this bad?\n+An assertion failure cannot output an useful message of the error.\n+\n+### Known problems\n+The suggested replacement decreases the readability of code and log output.\n+\n+### Example\n+```\n+assert!(r.is_ok());\n+assert!(r.is_err());\n+```\n\\ No newline at end of file"}, {"sha": "f355c0cc18d37d69bf4563727d65ce09c28f5a4c", "filename": "src/docs/assign_op_pattern.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fassign_op_pattern.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fassign_op_pattern.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fassign_op_pattern.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for `a = a op b` or `a = b commutative_op a`\n+patterns.\n+\n+### Why is this bad?\n+These can be written as the shorter `a op= b`.\n+\n+### Known problems\n+While forbidden by the spec, `OpAssign` traits may have\n+implementations that differ from the regular `Op` impl.\n+\n+### Example\n+```\n+let mut a = 5;\n+let b = 0;\n+// ...\n+\n+a = a + b;\n+```\n+\n+Use instead:\n+```\n+let mut a = 5;\n+let b = 0;\n+// ...\n+\n+a += b;\n+```\n\\ No newline at end of file"}, {"sha": "a40de6d2e473642505f16e46054228bf658eb885", "filename": "src/docs/async_yields_async.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fasync_yields_async.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fasync_yields_async.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fasync_yields_async.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for async blocks that yield values of types\n+that can themselves be awaited.\n+\n+### Why is this bad?\n+An await is likely missing.\n+\n+### Example\n+```\n+async fn foo() {}\n+\n+fn bar() {\n+  let x = async {\n+    foo()\n+  };\n+}\n+```\n+\n+Use instead:\n+```\n+async fn foo() {}\n+\n+fn bar() {\n+  let x = async {\n+    foo().await\n+  };\n+}\n+```\n\\ No newline at end of file"}, {"sha": "e9c768772ff6b8ec4485802bb64d4fe9db265598", "filename": "src/docs/await_holding_invalid_type.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fawait_holding_invalid_type.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fawait_holding_invalid_type.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fawait_holding_invalid_type.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Allows users to configure types which should not be held across `await`\n+suspension points.\n+\n+### Why is this bad?\n+There are some types which are perfectly \"safe\" to be used concurrently\n+from a memory access perspective but will cause bugs at runtime if they\n+are held in such a way.\n+\n+### Example\n+\n+```\n+await-holding-invalid-types = [\n+  # You can specify a type name\n+  \"CustomLockType\",\n+  # You can (optionally) specify a reason\n+  { path = \"OtherCustomLockType\", reason = \"Relies on a thread local\" }\n+]\n+```\n+\n+```\n+struct CustomLockType;\n+struct OtherCustomLockType;\n+async fn foo() {\n+  let _x = CustomLockType;\n+  let _y = OtherCustomLockType;\n+  baz().await; // Lint violation\n+}\n+```\n\\ No newline at end of file"}, {"sha": "0f450a11160ccca10c011e7fef781770c421a372", "filename": "src/docs/await_holding_lock.txt", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fawait_holding_lock.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fawait_holding_lock.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fawait_holding_lock.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,51 @@\n+### What it does\n+Checks for calls to await while holding a non-async-aware MutexGuard.\n+\n+### Why is this bad?\n+The Mutex types found in std::sync and parking_lot\n+are not designed to operate in an async context across await points.\n+\n+There are two potential solutions. One is to use an async-aware Mutex\n+type. Many asynchronous foundation crates provide such a Mutex type. The\n+other solution is to ensure the mutex is unlocked before calling await,\n+either by introducing a scope or an explicit call to Drop::drop.\n+\n+### Known problems\n+Will report false positive for explicitly dropped guards\n+([#6446](https://github.com/rust-lang/rust-clippy/issues/6446)). A workaround for this is\n+to wrap the `.lock()` call in a block instead of explicitly dropping the guard.\n+\n+### Example\n+```\n+async fn foo(x: &Mutex<u32>) {\n+  let mut guard = x.lock().unwrap();\n+  *guard += 1;\n+  baz().await;\n+}\n+\n+async fn bar(x: &Mutex<u32>) {\n+  let mut guard = x.lock().unwrap();\n+  *guard += 1;\n+  drop(guard); // explicit drop\n+  baz().await;\n+}\n+```\n+\n+Use instead:\n+```\n+async fn foo(x: &Mutex<u32>) {\n+  {\n+    let mut guard = x.lock().unwrap();\n+    *guard += 1;\n+  }\n+  baz().await;\n+}\n+\n+async fn bar(x: &Mutex<u32>) {\n+  {\n+    let mut guard = x.lock().unwrap();\n+    *guard += 1;\n+  } // guard dropped here at end of scope\n+  baz().await;\n+}\n+```\n\\ No newline at end of file"}, {"sha": "226a261b9cc5208dcf26ea386ac9898f77685fdb", "filename": "src/docs/await_holding_refcell_ref.txt", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fawait_holding_refcell_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fawait_holding_refcell_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fawait_holding_refcell_ref.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,47 @@\n+### What it does\n+Checks for calls to await while holding a `RefCell` `Ref` or `RefMut`.\n+\n+### Why is this bad?\n+`RefCell` refs only check for exclusive mutable access\n+at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n+risks panics from a mutable ref shared while other refs are outstanding.\n+\n+### Known problems\n+Will report false positive for explicitly dropped refs\n+([#6353](https://github.com/rust-lang/rust-clippy/issues/6353)). A workaround for this is\n+to wrap the `.borrow[_mut]()` call in a block instead of explicitly dropping the ref.\n+\n+### Example\n+```\n+async fn foo(x: &RefCell<u32>) {\n+  let mut y = x.borrow_mut();\n+  *y += 1;\n+  baz().await;\n+}\n+\n+async fn bar(x: &RefCell<u32>) {\n+  let mut y = x.borrow_mut();\n+  *y += 1;\n+  drop(y); // explicit drop\n+  baz().await;\n+}\n+```\n+\n+Use instead:\n+```\n+async fn foo(x: &RefCell<u32>) {\n+  {\n+     let mut y = x.borrow_mut();\n+     *y += 1;\n+  }\n+  baz().await;\n+}\n+\n+async fn bar(x: &RefCell<u32>) {\n+  {\n+    let mut y = x.borrow_mut();\n+    *y += 1;\n+  } // y dropped here at end of scope\n+  baz().await;\n+}\n+```\n\\ No newline at end of file"}, {"sha": "d40024ee56209f060cf84cb763ac9aa8911a1f7e", "filename": "src/docs/bad_bit_mask.txt", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbad_bit_mask.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbad_bit_mask.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbad_bit_mask.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,30 @@\n+### What it does\n+Checks for incompatible bit masks in comparisons.\n+\n+The formula for detecting if an expression of the type `_ <bit_op> m\n+<cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n+{`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n+table:\n+\n+|Comparison  |Bit Op|Example      |is always|Formula               |\n+|------------|------|-------------|---------|----------------------|\n+|`==` or `!=`| `&`  |`x & 2 == 3` |`false`  |`c & m != c`          |\n+|`<`  or `>=`| `&`  |`x & 2 < 3`  |`true`   |`m < c`               |\n+|`>`  or `<=`| `&`  |`x & 1 > 1`  |`false`  |`m <= c`              |\n+|`==` or `!=`| `\\|` |`x \\| 1 == 0`|`false`  |`c \\| m != c`         |\n+|`<`  or `>=`| `\\|` |`x \\| 1 < 1` |`false`  |`m >= c`              |\n+|`<=` or `>` | `\\|` |`x \\| 1 > 0` |`true`   |`m > c`               |\n+\n+### Why is this bad?\n+If the bits that the comparison cares about are always\n+set to zero or one by the bit mask, the comparison is constant `true` or\n+`false` (depending on mask, compared value, and operators).\n+\n+So the code is actively misleading, and the only reason someone would write\n+this intentionally is to win an underhanded Rust contest or create a\n+test-case for this lint.\n+\n+### Example\n+```\n+if (x & 1 == 2) { }\n+```\n\\ No newline at end of file"}, {"sha": "148575803d389de69b51e7e832d713d792c957df", "filename": "src/docs/bind_instead_of_map.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbind_instead_of_map.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbind_instead_of_map.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbind_instead_of_map.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for usage of `_.and_then(|x| Some(y))`, `_.and_then(|x| Ok(y))` or\n+`_.or_else(|x| Err(y))`.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely as\n+`_.map(|x| y)` or `_.map_err(|x| y)`.\n+\n+### Example\n+```\n+let _ = opt().and_then(|s| Some(s.len()));\n+let _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });\n+let _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });\n+```\n+\n+The correct use would be:\n+\n+```\n+let _ = opt().map(|s| s.len());\n+let _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });\n+let _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });\n+```\n\\ No newline at end of file"}, {"sha": "28a4ebf7169bfa744c691d707c06f0cbce55bfaf", "filename": "src/docs/blanket_clippy_restriction_lints.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fblanket_clippy_restriction_lints.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fblanket_clippy_restriction_lints.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fblanket_clippy_restriction_lints.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for `warn`/`deny`/`forbid` attributes targeting the whole clippy::restriction category.\n+\n+### Why is this bad?\n+Restriction lints sometimes are in contrast with other lints or even go against idiomatic rust.\n+These lints should only be enabled on a lint-by-lint basis and with careful consideration.\n+\n+### Example\n+```\n+#![deny(clippy::restriction)]\n+```\n+\n+Use instead:\n+```\n+#![deny(clippy::as_conversions)]\n+```\n\\ No newline at end of file"}, {"sha": "3afa14853fd216139e4ff8d891fcfab8b57e1eaf", "filename": "src/docs/blocks_in_if_conditions.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fblocks_in_if_conditions.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fblocks_in_if_conditions.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fblocks_in_if_conditions.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for `if` conditions that use blocks containing an\n+expression, statements or conditions that use closures with blocks.\n+\n+### Why is this bad?\n+Style, using blocks in the condition makes it hard to read.\n+\n+### Examples\n+```\n+if { true } { /* ... */ }\n+\n+if { let x = somefunc(); x } { /* ... */ }\n+```\n+\n+Use instead:\n+```\n+if true { /* ... */ }\n+\n+let res = { let x = somefunc(); x };\n+if res { /* ... */ }\n+```\n\\ No newline at end of file"}, {"sha": "df7ca00cc2ba497488c8e5b8ffcb2696e6eee7bb", "filename": "src/docs/bool_assert_comparison.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbool_assert_comparison.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbool_assert_comparison.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbool_assert_comparison.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+This lint warns about boolean comparisons in assert-like macros.\n+\n+### Why is this bad?\n+It is shorter to use the equivalent.\n+\n+### Example\n+```\n+assert_eq!(\"a\".is_empty(), false);\n+assert_ne!(\"a\".is_empty(), true);\n+```\n+\n+Use instead:\n+```\n+assert!(!\"a\".is_empty());\n+```\n\\ No newline at end of file"}, {"sha": "0996f60cec44ca3dc32c65c5810e743d146a3129", "filename": "src/docs/bool_comparison.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbool_comparison.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbool_comparison.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbool_comparison.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for expressions of the form `x == true`,\n+`x != true` and order comparisons such as `x < true` (or vice versa) and\n+suggest using the variable directly.\n+\n+### Why is this bad?\n+Unnecessary code.\n+\n+### Example\n+```\n+if x == true {}\n+if y == false {}\n+```\n+use `x` directly:\n+```\n+if x {}\n+if !y {}\n+```\n\\ No newline at end of file"}, {"sha": "63535b454c9f12b961a6f1e0ed3de83335f80bb0", "filename": "src/docs/bool_to_int_with_if.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbool_to_int_with_if.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbool_to_int_with_if.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbool_to_int_with_if.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Instead of using an if statement to convert a bool to an int,\n+this lint suggests using a `from()` function or an `as` coercion.\n+\n+### Why is this bad?\n+Coercion or `from()` is idiomatic way to convert bool to a number.\n+Both methods are guaranteed to return 1 for true, and 0 for false.\n+\n+See https://doc.rust-lang.org/std/primitive.bool.html#impl-From%3Cbool%3E\n+\n+### Example\n+```\n+if condition {\n+    1_i64\n+} else {\n+    0\n+};\n+```\n+Use instead:\n+```\n+i64::from(condition);\n+```\n+or\n+```\n+condition as i64;\n+```\n\\ No newline at end of file"}, {"sha": "0be865abd578095f3ec4c54651d234eb40d382ae", "filename": "src/docs/borrow_as_ptr.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fborrow_as_ptr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fborrow_as_ptr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fborrow_as_ptr.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for the usage of `&expr as *const T` or\n+`&mut expr as *mut T`, and suggest using `ptr::addr_of` or\n+`ptr::addr_of_mut` instead.\n+\n+### Why is this bad?\n+This would improve readability and avoid creating a reference\n+that points to an uninitialized value or unaligned place.\n+Read the `ptr::addr_of` docs for more information.\n+\n+### Example\n+```\n+let val = 1;\n+let p = &val as *const i32;\n+\n+let mut val_mut = 1;\n+let p_mut = &mut val_mut as *mut i32;\n+```\n+Use instead:\n+```\n+let val = 1;\n+let p = std::ptr::addr_of!(val);\n+\n+let mut val_mut = 1;\n+let p_mut = std::ptr::addr_of_mut!(val_mut);\n+```\n\\ No newline at end of file"}, {"sha": "352480d3f26a723cab9c783a631cab10c5f91e65", "filename": "src/docs/borrow_deref_ref.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fborrow_deref_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fborrow_deref_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fborrow_deref_ref.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,27 @@\n+### What it does\n+Checks for `&*(&T)`.\n+\n+### Why is this bad?\n+Dereferencing and then borrowing a reference value has no effect in most cases.\n+\n+### Known problems\n+False negative on such code:\n+```\n+let x = &12;\n+let addr_x = &x as *const _ as usize;\n+let addr_y = &&*x as *const _ as usize; // assert ok now, and lint triggered.\n+                                        // But if we fix it, assert will fail.\n+assert_ne!(addr_x, addr_y);\n+```\n+\n+### Example\n+```\n+let s = &String::new();\n+\n+let a: &String = &* s;\n+```\n+\n+Use instead:\n+```\n+let a: &String = s;\n+```\n\\ No newline at end of file"}, {"sha": "e55b6a77e6667aa7679e1e35c5b033f24be3b1a1", "filename": "src/docs/borrow_interior_mutable_const.txt", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fborrow_interior_mutable_const.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fborrow_interior_mutable_const.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fborrow_interior_mutable_const.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,40 @@\n+### What it does\n+Checks if `const` items which is interior mutable (e.g.,\n+contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.) has been borrowed directly.\n+\n+### Why is this bad?\n+Consts are copied everywhere they are referenced, i.e.,\n+every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n+or `AtomicXxxx` will be created, which defeats the whole purpose of using\n+these types in the first place.\n+\n+The `const` value should be stored inside a `static` item.\n+\n+### Known problems\n+When an enum has variants with interior mutability, use of its non\n+interior mutable variants can generate false positives. See issue\n+[#3962](https://github.com/rust-lang/rust-clippy/issues/3962)\n+\n+Types that have underlying or potential interior mutability trigger the lint whether\n+the interior mutable field is used or not. See issues\n+[#5812](https://github.com/rust-lang/rust-clippy/issues/5812) and\n+[#3825](https://github.com/rust-lang/rust-clippy/issues/3825)\n+\n+### Example\n+```\n+use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n+\n+CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n+assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n+```\n+\n+Use instead:\n+```\n+use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n+\n+static STATIC_ATOM: AtomicUsize = CONST_ATOM;\n+STATIC_ATOM.store(9, SeqCst);\n+assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n+```\n\\ No newline at end of file"}, {"sha": "d7089be662a581bd9cf9718b2be607eb172d259f", "filename": "src/docs/borrowed_box.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fborrowed_box.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fborrowed_box.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fborrowed_box.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for use of `&Box<T>` anywhere in the code.\n+Check the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n+\n+### Why is this bad?\n+A `&Box<T>` parameter requires the function caller to box `T` first before passing it to a function.\n+Using `&T` defines a concrete type for the parameter and generalizes the function, this would also\n+auto-deref to `&T` at the function call site if passed a `&Box<T>`.\n+\n+### Example\n+```\n+fn foo(bar: &Box<T>) { ... }\n+```\n+\n+Better:\n+\n+```\n+fn foo(bar: &T) { ... }\n+```\n\\ No newline at end of file"}, {"sha": "053f24c46281d397f8a1fbbe661a1cfdd1037a3e", "filename": "src/docs/box_collection.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbox_collection.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbox_collection.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbox_collection.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for use of `Box<T>` where T is a collection such as Vec anywhere in the code.\n+Check the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n+\n+### Why is this bad?\n+Collections already keeps their contents in a separate area on\n+the heap. So if you `Box` them, you just add another level of indirection\n+without any benefit whatsoever.\n+\n+### Example\n+```\n+struct X {\n+    values: Box<Vec<Foo>>,\n+}\n+```\n+\n+Better:\n+\n+```\n+struct X {\n+    values: Vec<Foo>,\n+}\n+```\n\\ No newline at end of file"}, {"sha": "8b1febf1455fdc359e520db3c9f95f5c14bdb282", "filename": "src/docs/boxed_local.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fboxed_local.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fboxed_local.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fboxed_local.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for usage of `Box<T>` where an unboxed `T` would\n+work fine.\n+\n+### Why is this bad?\n+This is an unnecessary allocation, and bad for\n+performance. It is only necessary to allocate if you wish to move the box\n+into something.\n+\n+### Example\n+```\n+fn foo(x: Box<u32>) {}\n+```\n+\n+Use instead:\n+```\n+fn foo(x: u32) {}\n+```\n\\ No newline at end of file"}, {"sha": "79be6124798a254ec8db803b30ea7ba4e9676168", "filename": "src/docs/branches_sharing_code.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbranches_sharing_code.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbranches_sharing_code.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbranches_sharing_code.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks if the `if` and `else` block contain shared code that can be\n+moved out of the blocks.\n+\n+### Why is this bad?\n+Duplicate code is less maintainable.\n+\n+### Known problems\n+* The lint doesn't check if the moved expressions modify values that are being used in\n+  the if condition. The suggestion can in that case modify the behavior of the program.\n+  See [rust-clippy#7452](https://github.com/rust-lang/rust-clippy/issues/7452)\n+\n+### Example\n+```\n+let foo = if \u2026 {\n+    println!(\"Hello World\");\n+    13\n+} else {\n+    println!(\"Hello World\");\n+    42\n+};\n+```\n+\n+Use instead:\n+```\n+println!(\"Hello World\");\n+let foo = if \u2026 {\n+    13\n+} else {\n+    42\n+};\n+```\n\\ No newline at end of file"}, {"sha": "15b1c9df7baab0738c2bb707218955b11d4db60f", "filename": "src/docs/builtin_type_shadow.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbuiltin_type_shadow.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbuiltin_type_shadow.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbuiltin_type_shadow.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Warns if a generic shadows a built-in type.\n+\n+### Why is this bad?\n+This gives surprising type errors.\n+\n+### Example\n+\n+```\n+impl<u32> Foo<u32> {\n+    fn impl_func(&self) -> u32 {\n+        42\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "ca7bf9a38da8e25262eb0b4f761bcb622a3db13d", "filename": "src/docs/bytes_count_to_len.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbytes_count_to_len.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbytes_count_to_len.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbytes_count_to_len.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+It checks for `str::bytes().count()` and suggests replacing it with\n+`str::len()`.\n+\n+### Why is this bad?\n+`str::bytes().count()` is longer and may not be as performant as using\n+`str::len()`.\n+\n+### Example\n+```\n+\"hello\".bytes().count();\n+String::from(\"hello\").bytes().count();\n+```\n+Use instead:\n+```\n+\"hello\".len();\n+String::from(\"hello\").len();\n+```\n\\ No newline at end of file"}, {"sha": "260de343353d8d3c1807cf47e79d5dbfad8640cd", "filename": "src/docs/bytes_nth.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbytes_nth.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fbytes_nth.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbytes_nth.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for the use of `.bytes().nth()`.\n+\n+### Why is this bad?\n+`.as_bytes().get()` is more efficient and more\n+readable.\n+\n+### Example\n+```\n+\"Hello\".bytes().nth(3);\n+```\n+\n+Use instead:\n+```\n+\"Hello\".as_bytes().get(3);\n+```\n\\ No newline at end of file"}, {"sha": "1998647a92740b7ad0f99d6c2d42cc5424c4f9d3", "filename": "src/docs/cargo_common_metadata.txt", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcargo_common_metadata.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcargo_common_metadata.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcargo_common_metadata.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,33 @@\n+### What it does\n+Checks to see if all common metadata is defined in\n+`Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n+\n+### Why is this bad?\n+It will be more difficult for users to discover the\n+purpose of the crate, and key information related to it.\n+\n+### Example\n+```\n+[package]\n+name = \"clippy\"\n+version = \"0.0.212\"\n+repository = \"https://github.com/rust-lang/rust-clippy\"\n+readme = \"README.md\"\n+license = \"MIT OR Apache-2.0\"\n+keywords = [\"clippy\", \"lint\", \"plugin\"]\n+categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+```\n+\n+Should include a description field like:\n+\n+```\n+[package]\n+name = \"clippy\"\n+version = \"0.0.212\"\n+description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n+repository = \"https://github.com/rust-lang/rust-clippy\"\n+readme = \"README.md\"\n+license = \"MIT OR Apache-2.0\"\n+keywords = [\"clippy\", \"lint\", \"plugin\"]\n+categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+```\n\\ No newline at end of file"}, {"sha": "8e6e18ed4e23a94da0e12c6a38c3064871fcc723", "filename": "src/docs/case_sensitive_file_extension_comparisons.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcase_sensitive_file_extension_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcase_sensitive_file_extension_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcase_sensitive_file_extension_comparisons.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for calls to `ends_with` with possible file extensions\n+and suggests to use a case-insensitive approach instead.\n+\n+### Why is this bad?\n+`ends_with` is case-sensitive and may not detect files with a valid extension.\n+\n+### Example\n+```\n+fn is_rust_file(filename: &str) -> bool {\n+    filename.ends_with(\".rs\")\n+}\n+```\n+Use instead:\n+```\n+fn is_rust_file(filename: &str) -> bool {\n+    let filename = std::path::Path::new(filename);\n+    filename.extension()\n+        .map_or(false, |ext| ext.eq_ignore_ascii_case(\"rs\"))\n+}\n+```\n\\ No newline at end of file"}, {"sha": "c5d8ee034ce596d89a8ce62ae83d5962d7f892dc", "filename": "src/docs/cast_abs_to_unsigned.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_abs_to_unsigned.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_abs_to_unsigned.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_abs_to_unsigned.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for uses of the `abs()` method that cast the result to unsigned.\n+\n+### Why is this bad?\n+The `unsigned_abs()` method avoids panic when called on the MIN value.\n+\n+### Example\n+```\n+let x: i32 = -42;\n+let y: u32 = x.abs() as u32;\n+```\n+Use instead:\n+```\n+let x: i32 = -42;\n+let y: u32 = x.unsigned_abs();\n+```\n\\ No newline at end of file"}, {"sha": "675c03a42bc23679e2132be6d00b43a1735c188a", "filename": "src/docs/cast_enum_constructor.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_enum_constructor.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_enum_constructor.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_enum_constructor.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,11 @@\n+### What it does\n+Checks for casts from an enum tuple constructor to an integer.\n+\n+### Why is this bad?\n+The cast is easily confused with casting a c-like enum value to an integer.\n+\n+### Example\n+```\n+enum E { X(i32) };\n+let _ = E::X as usize;\n+```\n\\ No newline at end of file"}, {"sha": "abe32a8296da228ff5447d8f715aa6425abcfbe9", "filename": "src/docs/cast_enum_truncation.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_enum_truncation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_enum_truncation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_enum_truncation.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks for casts from an enum type to an integral type which will definitely truncate the\n+value.\n+\n+### Why is this bad?\n+The resulting integral value will not match the value of the variant it came from.\n+\n+### Example\n+```\n+enum E { X = 256 };\n+let _ = E::X as u8;\n+```\n\\ No newline at end of file"}, {"sha": "c3a61dd470fc9b4feabd4d4db2612e8ca8c71f4f", "filename": "src/docs/cast_lossless.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_lossless.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_lossless.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_lossless.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for casts between numerical types that may\n+be replaced by safe conversion functions.\n+\n+### Why is this bad?\n+Rust's `as` keyword will perform many kinds of\n+conversions, including silently lossy conversions. Conversion functions such\n+as `i32::from` will only perform lossless conversions. Using the conversion\n+functions prevents conversions from turning into silent lossy conversions if\n+the types of the input expressions ever change, and make it easier for\n+people reading the code to know that the conversion is lossless.\n+\n+### Example\n+```\n+fn as_u64(x: u8) -> u64 {\n+    x as u64\n+}\n+```\n+\n+Using `::from` would look like this:\n+\n+```\n+fn as_u64(x: u8) -> u64 {\n+    u64::from(x)\n+}\n+```\n\\ No newline at end of file"}, {"sha": "0b164848cc7c23647a27ac5138e5f82346c876bb", "filename": "src/docs/cast_possible_truncation.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_possible_truncation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_possible_truncation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_possible_truncation.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for casts between numerical types that may\n+truncate large values. This is expected behavior, so the cast is `Allow` by\n+default.\n+\n+### Why is this bad?\n+In some problem domains, it is good practice to avoid\n+truncation. This lint can be activated to help assess where additional\n+checks could be beneficial.\n+\n+### Example\n+```\n+fn as_u8(x: u64) -> u8 {\n+    x as u8\n+}\n+```\n\\ No newline at end of file"}, {"sha": "f883fc9cfb994793e5520453df94f183d2230319", "filename": "src/docs/cast_possible_wrap.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_possible_wrap.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_possible_wrap.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_possible_wrap.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for casts from an unsigned type to a signed type of\n+the same size. Performing such a cast is a 'no-op' for the compiler,\n+i.e., nothing is changed at the bit level, and the binary representation of\n+the value is reinterpreted. This can cause wrapping if the value is too big\n+for the target signed type. However, the cast works as defined, so this lint\n+is `Allow` by default.\n+\n+### Why is this bad?\n+While such a cast is not bad in itself, the results can\n+be surprising when this is not the intended behavior, as demonstrated by the\n+example below.\n+\n+### Example\n+```\n+u32::MAX as i32; // will yield a value of `-1`\n+```\n\\ No newline at end of file"}, {"sha": "f915d9f8a6d0d2bd191bfd7ea43e3b17fa36c22c", "filename": "src/docs/cast_precision_loss.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_precision_loss.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_precision_loss.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_precision_loss.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for casts from any numerical to a float type where\n+the receiving type cannot store all values from the original type without\n+rounding errors. This possible rounding is to be expected, so this lint is\n+`Allow` by default.\n+\n+Basically, this warns on casting any integer with 32 or more bits to `f32`\n+or any 64-bit integer to `f64`.\n+\n+### Why is this bad?\n+It's not bad at all. But in some applications it can be\n+helpful to know where precision loss can take place. This lint can help find\n+those places in the code.\n+\n+### Example\n+```\n+let x = u64::MAX;\n+x as f64;\n+```\n\\ No newline at end of file"}, {"sha": "6a6d4dcaa2ae5ecdce3d53b2cc2f9f51d59e2281", "filename": "src/docs/cast_ptr_alignment.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_ptr_alignment.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_ptr_alignment.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_ptr_alignment.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for casts, using `as` or `pointer::cast`,\n+from a less-strictly-aligned pointer to a more-strictly-aligned pointer\n+\n+### Why is this bad?\n+Dereferencing the resulting pointer may be undefined\n+behavior.\n+\n+### Known problems\n+Using `std::ptr::read_unaligned` and `std::ptr::write_unaligned` or similar\n+on the resulting pointer is fine. Is over-zealous: Casts with manual alignment checks or casts like\n+u64-> u8 -> u16 can be fine. Miri is able to do a more in-depth analysis.\n+\n+### Example\n+```\n+let _ = (&1u8 as *const u8) as *const u16;\n+let _ = (&mut 1u8 as *mut u8) as *mut u16;\n+\n+(&1u8 as *const u8).cast::<u16>();\n+(&mut 1u8 as *mut u8).cast::<u16>();\n+```\n\\ No newline at end of file"}, {"sha": "fb5b4dbb62d82386ab073958a1a97ded27bddeb9", "filename": "src/docs/cast_ref_to_mut.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_ref_to_mut.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_ref_to_mut.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_ref_to_mut.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for casts of `&T` to `&mut T` anywhere in the code.\n+\n+### Why is this bad?\n+It\u2019s basically guaranteed to be undefined behavior.\n+`UnsafeCell` is the only way to obtain aliasable data that is considered\n+mutable.\n+\n+### Example\n+```\n+fn x(r: &i32) {\n+    unsafe {\n+        *(r as *const _ as *mut _) += 1;\n+    }\n+}\n+```\n+\n+Instead consider using interior mutability types.\n+\n+```\n+use std::cell::UnsafeCell;\n+\n+fn x(r: &UnsafeCell<i32>) {\n+    unsafe {\n+        *r.get() += 1;\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "d64fe1b07f46932d14dc2569ee8dab845a9b62ab", "filename": "src/docs/cast_sign_loss.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_sign_loss.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_sign_loss.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_sign_loss.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for casts from a signed to an unsigned numerical\n+type. In this case, negative values wrap around to large positive values,\n+which can be quite surprising in practice. However, as the cast works as\n+defined, this lint is `Allow` by default.\n+\n+### Why is this bad?\n+Possibly surprising results. You can activate this lint\n+as a one-time check to see where numerical wrapping can arise.\n+\n+### Example\n+```\n+let y: i8 = -1;\n+y as u128; // will return 18446744073709551615\n+```\n\\ No newline at end of file"}, {"sha": "c01ef0ba92c03d0c66381a52e5506f7b9bfddeec", "filename": "src/docs/cast_slice_different_sizes.txt", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_slice_different_sizes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_slice_different_sizes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_slice_different_sizes.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,38 @@\n+### What it does\n+Checks for `as` casts between raw pointers to slices with differently sized elements.\n+\n+### Why is this bad?\n+The produced raw pointer to a slice does not update its length metadata. The produced\n+pointer will point to a different number of bytes than the original pointer because the\n+length metadata of a raw slice pointer is in elements rather than bytes.\n+Producing a slice reference from the raw pointer will either create a slice with\n+less data (which can be surprising) or create a slice with more data and cause Undefined Behavior.\n+\n+### Example\n+// Missing data\n+```\n+let a = [1_i32, 2, 3, 4];\n+let p = &a as *const [i32] as *const [u8];\n+unsafe {\n+    println!(\"{:?}\", &*p);\n+}\n+```\n+// Undefined Behavior (note: also potential alignment issues)\n+```\n+let a = [1_u8, 2, 3, 4];\n+let p = &a as *const [u8] as *const [u32];\n+unsafe {\n+    println!(\"{:?}\", &*p);\n+}\n+```\n+Instead use `ptr::slice_from_raw_parts` to construct a slice from a data pointer and the correct length\n+```\n+let a = [1_i32, 2, 3, 4];\n+let old_ptr = &a as *const [i32];\n+// The data pointer is cast to a pointer to the target `u8` not `[u8]`\n+// The length comes from the known length of 4 i32s times the 4 bytes per i32\n+let new_ptr = core::ptr::slice_from_raw_parts(old_ptr as *const u8, 16);\n+unsafe {\n+    println!(\"{:?}\", &*new_ptr);\n+}\n+```\n\\ No newline at end of file"}, {"sha": "b58c739766aab1d482014b8b69f882151ea5da41", "filename": "src/docs/cast_slice_from_raw_parts.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_slice_from_raw_parts.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcast_slice_from_raw_parts.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_slice_from_raw_parts.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for a raw slice being cast to a slice pointer\n+\n+### Why is this bad?\n+This can result in multiple `&mut` references to the same location when only a pointer is\n+required.\n+`ptr::slice_from_raw_parts` is a safe alternative that doesn't require\n+the same [safety requirements] to be upheld.\n+\n+### Example\n+```\n+let _: *const [u8] = std::slice::from_raw_parts(ptr, len) as *const _;\n+let _: *mut [u8] = std::slice::from_raw_parts_mut(ptr, len) as *mut _;\n+```\n+Use instead:\n+```\n+let _: *const [u8] = std::ptr::slice_from_raw_parts(ptr, len);\n+let _: *mut [u8] = std::ptr::slice_from_raw_parts_mut(ptr, len);\n+```\n+[safety requirements]: https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html#safety\n\\ No newline at end of file"}, {"sha": "00d60b9a451b9f4b82be87cded214d1a7b930b55", "filename": "src/docs/char_lit_as_u8.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fchar_lit_as_u8.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fchar_lit_as_u8.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fchar_lit_as_u8.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for expressions where a character literal is cast\n+to `u8` and suggests using a byte literal instead.\n+\n+### Why is this bad?\n+In general, casting values to smaller types is\n+error-prone and should be avoided where possible. In the particular case of\n+converting a character literal to u8, it is easy to avoid by just using a\n+byte literal instead. As an added bonus, `b'a'` is even slightly shorter\n+than `'a' as u8`.\n+\n+### Example\n+```\n+'x' as u8\n+```\n+\n+A better version, using the byte literal:\n+\n+```\n+b'x'\n+```\n\\ No newline at end of file"}, {"sha": "4c1d8838973a73d2c2699b68787cfe55d062901c", "filename": "src/docs/chars_last_cmp.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fchars_last_cmp.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fchars_last_cmp.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fchars_last_cmp.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for usage of `_.chars().last()` or\n+`_.chars().next_back()` on a `str` to check if it ends with a given char.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely as\n+`_.ends_with(_)`.\n+\n+### Example\n+```\n+name.chars().last() == Some('_') || name.chars().next_back() == Some('-');\n+```\n+\n+Use instead:\n+```\n+name.ends_with('_') || name.ends_with('-');\n+```\n\\ No newline at end of file"}, {"sha": "77cbce2de00f91f65298aacf0daddc3d3f6613d8", "filename": "src/docs/chars_next_cmp.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fchars_next_cmp.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fchars_next_cmp.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fchars_next_cmp.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for usage of `.chars().next()` on a `str` to check\n+if it starts with a given char.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely as\n+`_.starts_with(_)`.\n+\n+### Example\n+```\n+let name = \"foo\";\n+if name.chars().next() == Some('_') {};\n+```\n+\n+Use instead:\n+```\n+let name = \"foo\";\n+if name.starts_with('_') {};\n+```\n\\ No newline at end of file"}, {"sha": "536b01294ee170493d4c6f6acee6813dbe79a9a6", "filename": "src/docs/checked_conversions.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fchecked_conversions.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fchecked_conversions.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fchecked_conversions.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for explicit bounds checking when casting.\n+\n+### Why is this bad?\n+Reduces the readability of statements & is error prone.\n+\n+### Example\n+```\n+foo <= i32::MAX as u32;\n+```\n+\n+Use instead:\n+```\n+i32::try_from(foo).is_ok();\n+```\n\\ No newline at end of file"}, {"sha": "2729635bd246f0710c1c2b8cbd9a4f4a35165023", "filename": "src/docs/clone_double_ref.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fclone_double_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fclone_double_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fclone_double_ref.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of `.clone()` on an `&&T`.\n+\n+### Why is this bad?\n+Cloning an `&&T` copies the inner `&T`, instead of\n+cloning the underlying `T`.\n+\n+### Example\n+```\n+fn main() {\n+    let x = vec![1];\n+    let y = &&x;\n+    let z = y.clone();\n+    println!(\"{:p} {:p}\", *y, z); // prints out the same pointer\n+}\n+```\n\\ No newline at end of file"}, {"sha": "99a0bdb4c4ac0f668c16d2e650b66af7289c4b07", "filename": "src/docs/clone_on_copy.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fclone_on_copy.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fclone_on_copy.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fclone_on_copy.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,11 @@\n+### What it does\n+Checks for usage of `.clone()` on a `Copy` type.\n+\n+### Why is this bad?\n+The only reason `Copy` types implement `Clone` is for\n+generics, not for using the `clone` method on a concrete type.\n+\n+### Example\n+```\n+42u64.clone();\n+```\n\\ No newline at end of file"}, {"sha": "2d83f8fefc12239c201a135679543a418f9ed02b", "filename": "src/docs/clone_on_ref_ptr.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fclone_on_ref_ptr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fclone_on_ref_ptr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fclone_on_ref_ptr.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for usage of `.clone()` on a ref-counted pointer,\n+(`Rc`, `Arc`, `rc::Weak`, or `sync::Weak`), and suggests calling Clone via unified\n+function syntax instead (e.g., `Rc::clone(foo)`).\n+\n+### Why is this bad?\n+Calling '.clone()' on an Rc, Arc, or Weak\n+can obscure the fact that only the pointer is being cloned, not the underlying\n+data.\n+\n+### Example\n+```\n+let x = Rc::new(1);\n+\n+x.clone();\n+```\n+\n+Use instead:\n+```\n+Rc::clone(&x);\n+```\n\\ No newline at end of file"}, {"sha": "2f2014d5fd2990e7d559cf95e675d8d4fa1a9a17", "filename": "src/docs/cloned_instead_of_copied.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcloned_instead_of_copied.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcloned_instead_of_copied.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcloned_instead_of_copied.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usages of `cloned()` on an `Iterator` or `Option` where\n+`copied()` could be used instead.\n+\n+### Why is this bad?\n+`copied()` is better because it guarantees that the type being cloned\n+implements `Copy`.\n+\n+### Example\n+```\n+[1, 2, 3].iter().cloned();\n+```\n+Use instead:\n+```\n+[1, 2, 3].iter().copied();\n+```\n\\ No newline at end of file"}, {"sha": "e2ad04d932359aa55e6cf5b1e0fd03e93aeeb8ec", "filename": "src/docs/cmp_nan.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcmp_nan.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcmp_nan.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcmp_nan.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for comparisons to NaN.\n+\n+### Why is this bad?\n+NaN does not compare meaningfully to anything \u2013 not\n+even itself \u2013 so those comparisons are simply wrong.\n+\n+### Example\n+```\n+if x == f32::NAN { }\n+```\n+\n+Use instead:\n+```\n+if x.is_nan() { }\n+```\n\\ No newline at end of file"}, {"sha": "02fd15124f0389b6e7c0ba637fddb737d39f8df2", "filename": "src/docs/cmp_null.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcmp_null.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcmp_null.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcmp_null.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+This lint checks for equality comparisons with `ptr::null`\n+\n+### Why is this bad?\n+It's easier and more readable to use the inherent\n+`.is_null()`\n+method instead\n+\n+### Example\n+```\n+use std::ptr;\n+\n+if x == ptr::null {\n+    // ..\n+}\n+```\n+\n+Use instead:\n+```\n+if x.is_null() {\n+    // ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "f8d4956ff1d4b7b010df92dffb8ccc7a16dc1684", "filename": "src/docs/cmp_owned.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcmp_owned.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcmp_owned.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcmp_owned.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for conversions to owned values just for the sake\n+of a comparison.\n+\n+### Why is this bad?\n+The comparison can operate on a reference, so creating\n+an owned value effectively throws it away directly afterwards, which is\n+needlessly consuming code and heap space.\n+\n+### Example\n+```\n+if x.to_owned() == y {}\n+```\n+\n+Use instead:\n+```\n+if x == y {}\n+```\n\\ No newline at end of file"}, {"sha": "fdd75f6479cd00cf24d503b37b9f3d48c38249da", "filename": "src/docs/cognitive_complexity.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcognitive_complexity.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcognitive_complexity.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcognitive_complexity.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for methods with high cognitive complexity.\n+\n+### Why is this bad?\n+Methods of high cognitive complexity tend to be hard to\n+both read and maintain. Also LLVM will tend to optimize small methods better.\n+\n+### Known problems\n+Sometimes it's hard to find a way to reduce the\n+complexity.\n+\n+### Example\n+You'll see it when you get the warning.\n\\ No newline at end of file"}, {"sha": "4ddfca17731f7b95a2622c2255e8c75ff16ea89e", "filename": "src/docs/collapsible_else_if.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcollapsible_else_if.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcollapsible_else_if.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcollapsible_else_if.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Checks for collapsible `else { if ... }` expressions\n+that can be collapsed to `else if ...`.\n+\n+### Why is this bad?\n+Each `if`-statement adds one level of nesting, which\n+makes code look more complex than it really is.\n+\n+### Example\n+```\n+\n+if x {\n+    \u2026\n+} else {\n+    if y {\n+        \u2026\n+    }\n+}\n+```\n+\n+Should be written:\n+\n+```\n+if x {\n+    \u2026\n+} else if y {\n+    \u2026\n+}\n+```\n\\ No newline at end of file"}, {"sha": "e1264ee062e955437c7199981de2dd21a2eaa135", "filename": "src/docs/collapsible_if.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcollapsible_if.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcollapsible_if.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcollapsible_if.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for nested `if` statements which can be collapsed\n+by `&&`-combining their conditions.\n+\n+### Why is this bad?\n+Each `if`-statement adds one level of nesting, which\n+makes code look more complex than it really is.\n+\n+### Example\n+```\n+if x {\n+    if y {\n+        // \u2026\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+if x && y {\n+    // \u2026\n+}\n+```\n\\ No newline at end of file"}, {"sha": "0d59594a03a27c2f1957912613c548ec7cde34dd", "filename": "src/docs/collapsible_match.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcollapsible_match.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcollapsible_match.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcollapsible_match.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,31 @@\n+### What it does\n+Finds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\n+without adding any branches.\n+\n+Note that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\n+cases where merging would most likely make the code more readable.\n+\n+### Why is this bad?\n+It is unnecessarily verbose and complex.\n+\n+### Example\n+```\n+fn func(opt: Option<Result<u64, String>>) {\n+    let n = match opt {\n+        Some(n) => match n {\n+            Ok(n) => n,\n+            _ => return,\n+        }\n+        None => return,\n+    };\n+}\n+```\n+Use instead:\n+```\n+fn func(opt: Option<Result<u64, String>>) {\n+    let n = match opt {\n+        Some(Ok(n)) => n,\n+        _ => return,\n+    };\n+}\n+```\n\\ No newline at end of file"}, {"sha": "c24c25a3028a5d5dce4806d16b028aa46125c7e2", "filename": "src/docs/collapsible_str_replace.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcollapsible_str_replace.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcollapsible_str_replace.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcollapsible_str_replace.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for consecutive calls to `str::replace` (2 or more)\n+that can be collapsed into a single call.\n+\n+### Why is this bad?\n+Consecutive `str::replace` calls scan the string multiple times\n+with repetitive code.\n+\n+### Example\n+```\n+let hello = \"hesuo worpd\"\n+    .replace('s', \"l\")\n+    .replace(\"u\", \"l\")\n+    .replace('p', \"l\");\n+```\n+Use instead:\n+```\n+let hello = \"hesuo worpd\".replace(&['s', 'u', 'p'], \"l\");\n+```\n\\ No newline at end of file"}, {"sha": "43b09f31ff4aa7a6596db9d2456d6c19f63185fa", "filename": "src/docs/comparison_chain.txt", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcomparison_chain.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcomparison_chain.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcomparison_chain.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,36 @@\n+### What it does\n+Checks comparison chains written with `if` that can be\n+rewritten with `match` and `cmp`.\n+\n+### Why is this bad?\n+`if` is not guaranteed to be exhaustive and conditionals can get\n+repetitive\n+\n+### Known problems\n+The match statement may be slower due to the compiler\n+not inlining the call to cmp. See issue [#5354](https://github.com/rust-lang/rust-clippy/issues/5354)\n+\n+### Example\n+```\n+fn f(x: u8, y: u8) {\n+    if x > y {\n+        a()\n+    } else if x < y {\n+        b()\n+    } else {\n+        c()\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+use std::cmp::Ordering;\n+fn f(x: u8, y: u8) {\n+     match x.cmp(&y) {\n+         Ordering::Greater => a(),\n+         Ordering::Less => b(),\n+         Ordering::Equal => c()\n+     }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "db6f74fe2706b5bbca627b24980f86865d219bc7", "filename": "src/docs/comparison_to_empty.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcomparison_to_empty.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcomparison_to_empty.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcomparison_to_empty.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,31 @@\n+### What it does\n+Checks for comparing to an empty slice such as `\"\"` or `[]`,\n+and suggests using `.is_empty()` where applicable.\n+\n+### Why is this bad?\n+Some structures can answer `.is_empty()` much faster\n+than checking for equality. So it is good to get into the habit of using\n+`.is_empty()`, and having it is cheap.\n+Besides, it makes the intent clearer than a manual comparison in some contexts.\n+\n+### Example\n+\n+```\n+if s == \"\" {\n+    ..\n+}\n+\n+if arr == [] {\n+    ..\n+}\n+```\n+Use instead:\n+```\n+if s.is_empty() {\n+    ..\n+}\n+\n+if arr.is_empty() {\n+    ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "5f9a2a015b86c7bd9bd2c3956bfeff4fe6702e31", "filename": "src/docs/copy_iterator.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcopy_iterator.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcopy_iterator.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcopy_iterator.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for types that implement `Copy` as well as\n+`Iterator`.\n+\n+### Why is this bad?\n+Implicit copies can be confusing when working with\n+iterator combinators.\n+\n+### Example\n+```\n+#[derive(Copy, Clone)]\n+struct Countdown(u8);\n+\n+impl Iterator for Countdown {\n+    // ...\n+}\n+\n+let a: Vec<_> = my_iterator.take(1).collect();\n+let b: Vec<_> = my_iterator.collect();\n+```\n\\ No newline at end of file"}, {"sha": "047e986dee71fae10dd59b6faf35eabbbff50db7", "filename": "src/docs/crate_in_macro_def.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcrate_in_macro_def.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcrate_in_macro_def.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcrate_in_macro_def.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,35 @@\n+### What it does\n+Checks for use of `crate` as opposed to `$crate` in a macro definition.\n+\n+### Why is this bad?\n+`crate` refers to the macro call's crate, whereas `$crate` refers to the macro definition's\n+crate. Rarely is the former intended. See:\n+https://doc.rust-lang.org/reference/macros-by-example.html#hygiene\n+\n+### Example\n+```\n+#[macro_export]\n+macro_rules! print_message {\n+    () => {\n+        println!(\"{}\", crate::MESSAGE);\n+    };\n+}\n+pub const MESSAGE: &str = \"Hello!\";\n+```\n+Use instead:\n+```\n+#[macro_export]\n+macro_rules! print_message {\n+    () => {\n+        println!(\"{}\", $crate::MESSAGE);\n+    };\n+}\n+pub const MESSAGE: &str = \"Hello!\";\n+```\n+\n+Note that if the use of `crate` is intentional, an `allow` attribute can be applied to the\n+macro definition, e.g.:\n+```\n+#[allow(clippy::crate_in_macro_def)]\n+macro_rules! ok { ... crate::foo ... }\n+```\n\\ No newline at end of file"}, {"sha": "e4e7937684e6efebae130aed520866705fda8e77", "filename": "src/docs/create_dir.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcreate_dir.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcreate_dir.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcreate_dir.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks usage of `std::fs::create_dir` and suggest using `std::fs::create_dir_all` instead.\n+\n+### Why is this bad?\n+Sometimes `std::fs::create_dir` is mistakenly chosen over `std::fs::create_dir_all`.\n+\n+### Example\n+```\n+std::fs::create_dir(\"foo\");\n+```\n+\n+Use instead:\n+```\n+std::fs::create_dir_all(\"foo\");\n+```\n\\ No newline at end of file"}, {"sha": "49dea154970e50ab216792d52a157dfd24e2f960", "filename": "src/docs/crosspointer_transmute.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcrosspointer_transmute.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fcrosspointer_transmute.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcrosspointer_transmute.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks for transmutes between a type `T` and `*T`.\n+\n+### Why is this bad?\n+It's easy to mistakenly transmute between a type and a\n+pointer to that type.\n+\n+### Example\n+```\n+core::intrinsics::transmute(t) // where the result type is the same as\n+                               // `*t` or `&t`'s\n+```\n\\ No newline at end of file"}, {"sha": "3e1a9a043f9f41617cefd86d3b2c044620856525", "filename": "src/docs/dbg_macro.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdbg_macro.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdbg_macro.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdbg_macro.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of dbg!() macro.\n+\n+### Why is this bad?\n+`dbg!` macro is intended as a debugging tool. It\n+should not be in version control.\n+\n+### Example\n+```\n+dbg!(true)\n+```\n+\n+Use instead:\n+```\n+true\n+```\n\\ No newline at end of file"}, {"sha": "2c44abe1f05c806108d329d07ccb021a0011a20b", "filename": "src/docs/debug_assert_with_mut_call.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdebug_assert_with_mut_call.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdebug_assert_with_mut_call.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdebug_assert_with_mut_call.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for function/method calls with a mutable\n+parameter in `debug_assert!`, `debug_assert_eq!` and `debug_assert_ne!` macros.\n+\n+### Why is this bad?\n+In release builds `debug_assert!` macros are optimized out by the\n+compiler.\n+Therefore mutating something in a `debug_assert!` macro results in different behavior\n+between a release and debug build.\n+\n+### Example\n+```\n+debug_assert_eq!(vec![3].pop(), Some(3));\n+\n+// or\n+\n+debug_assert!(takes_a_mut_parameter(&mut x));\n+```\n\\ No newline at end of file"}, {"sha": "daca9bbb3a848c7dd2b9314b952ee68760230ae5", "filename": "src/docs/decimal_literal_representation.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdecimal_literal_representation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdecimal_literal_representation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdecimal_literal_representation.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Warns if there is a better representation for a numeric literal.\n+\n+### Why is this bad?\n+Especially for big powers of 2 a hexadecimal representation is more\n+readable than a decimal representation.\n+\n+### Example\n+```\n+`255` => `0xFF`\n+`65_535` => `0xFFFF`\n+`4_042_322_160` => `0xF0F0_F0F0`\n+```\n\\ No newline at end of file"}, {"sha": "2801b5ccff8028aaa4dc0c8899e28bf01915d3ca", "filename": "src/docs/declare_interior_mutable_const.txt", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdeclare_interior_mutable_const.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdeclare_interior_mutable_const.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdeclare_interior_mutable_const.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,46 @@\n+### What it does\n+Checks for declaration of `const` items which is interior\n+mutable (e.g., contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.).\n+\n+### Why is this bad?\n+Consts are copied everywhere they are referenced, i.e.,\n+every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n+or `AtomicXxxx` will be created, which defeats the whole purpose of using\n+these types in the first place.\n+\n+The `const` should better be replaced by a `static` item if a global\n+variable is wanted, or replaced by a `const fn` if a constructor is wanted.\n+\n+### Known problems\n+A \"non-constant\" const item is a legacy way to supply an\n+initialized value to downstream `static` items (e.g., the\n+`std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\n+and this lint should be suppressed.\n+\n+Even though the lint avoids triggering on a constant whose type has enums that have variants\n+with interior mutability, and its value uses non interior mutable variants (see\n+[#3962](https://github.com/rust-lang/rust-clippy/issues/3962) and\n+[#3825](https://github.com/rust-lang/rust-clippy/issues/3825) for examples);\n+it complains about associated constants without default values only based on its types;\n+which might not be preferable.\n+There're other enums plus associated constants cases that the lint cannot handle.\n+\n+Types that have underlying or potential interior mutability trigger the lint whether\n+the interior mutable field is used or not. See issues\n+[#5812](https://github.com/rust-lang/rust-clippy/issues/5812) and\n+\n+### Example\n+```\n+use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+\n+const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n+CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n+assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n+```\n+\n+Use instead:\n+```\n+static STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);\n+STATIC_ATOM.store(9, SeqCst);\n+assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n+```\n\\ No newline at end of file"}, {"sha": "b63ef3d18fc411d16f22e1f70f801b50d87a443f", "filename": "src/docs/default_instead_of_iter_empty.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdefault_instead_of_iter_empty.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdefault_instead_of_iter_empty.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdefault_instead_of_iter_empty.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+It checks for `std::iter::Empty::default()` and suggests replacing it with\n+`std::iter::empty()`.\n+### Why is this bad?\n+`std::iter::empty()` is the more idiomatic way.\n+### Example\n+```\n+let _ = std::iter::Empty::<usize>::default();\n+let iter: std::iter::Empty<usize> = std::iter::Empty::default();\n+```\n+Use instead:\n+```\n+let _ = std::iter::empty::<usize>();\n+let iter: std::iter::Empty<usize> = std::iter::empty();\n+```\n\\ No newline at end of file"}, {"sha": "15076a0a68bf6717c884c45cd79bb90f076b1700", "filename": "src/docs/default_numeric_fallback.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdefault_numeric_fallback.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdefault_numeric_fallback.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdefault_numeric_fallback.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for usage of unconstrained numeric literals which may cause default numeric fallback in type\n+inference.\n+\n+Default numeric fallback means that if numeric types have not yet been bound to concrete\n+types at the end of type inference, then integer type is bound to `i32`, and similarly\n+floating type is bound to `f64`.\n+\n+See [RFC0212](https://github.com/rust-lang/rfcs/blob/master/text/0212-restore-int-fallback.md) for more information about the fallback.\n+\n+### Why is this bad?\n+For those who are very careful about types, default numeric fallback\n+can be a pitfall that cause unexpected runtime behavior.\n+\n+### Known problems\n+This lint can only be allowed at the function level or above.\n+\n+### Example\n+```\n+let i = 10;\n+let f = 1.23;\n+```\n+\n+Use instead:\n+```\n+let i = 10i32;\n+let f = 1.23f64;\n+```\n\\ No newline at end of file"}, {"sha": "e69298969c8ed807f08c6023713ede2b5d5c4af2", "filename": "src/docs/default_trait_access.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdefault_trait_access.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdefault_trait_access.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdefault_trait_access.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for literal calls to `Default::default()`.\n+\n+### Why is this bad?\n+It's easier for the reader if the name of the type is used, rather than the\n+generic `Default`.\n+\n+### Example\n+```\n+let s: String = Default::default();\n+```\n+\n+Use instead:\n+```\n+let s = String::default();\n+```\n\\ No newline at end of file"}, {"sha": "f79ff9760e57ebaf1dfea011d14fb91cdf3d837c", "filename": "src/docs/default_union_representation.txt", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdefault_union_representation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdefault_union_representation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdefault_union_representation.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,36 @@\n+### What it does\n+Displays a warning when a union is declared with the default representation (without a `#[repr(C)]` attribute).\n+\n+### Why is this bad?\n+Unions in Rust have unspecified layout by default, despite many people thinking that they\n+lay out each field at the start of the union (like C does). That is, there are no guarantees\n+about the offset of the fields for unions with multiple non-ZST fields without an explicitly\n+specified layout. These cases may lead to undefined behavior in unsafe blocks.\n+\n+### Example\n+```\n+union Foo {\n+    a: i32,\n+    b: u32,\n+}\n+\n+fn main() {\n+    let _x: u32 = unsafe {\n+        Foo { a: 0_i32 }.b // Undefined behavior: `b` is allowed to be padding\n+    };\n+}\n+```\n+Use instead:\n+```\n+#[repr(C)]\n+union Foo {\n+    a: i32,\n+    b: u32,\n+}\n+\n+fn main() {\n+    let _x: u32 = unsafe {\n+        Foo { a: 0_i32 }.b // Now defined behavior, this is just an i32 -> u32 transmute\n+    };\n+}\n+```\n\\ No newline at end of file"}, {"sha": "9f264887a057e3c4eb347abef608a7ab7dcc8c73", "filename": "src/docs/deprecated_cfg_attr.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdeprecated_cfg_attr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdeprecated_cfg_attr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdeprecated_cfg_attr.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\n+with `#[rustfmt::skip]`.\n+\n+### Why is this bad?\n+Since tool_attributes ([rust-lang/rust#44690](https://github.com/rust-lang/rust/issues/44690))\n+are stable now, they should be used instead of the old `cfg_attr(rustfmt)` attributes.\n+\n+### Known problems\n+This lint doesn't detect crate level inner attributes, because they get\n+processed before the PreExpansionPass lints get executed. See\n+[#3123](https://github.com/rust-lang/rust-clippy/pull/3123#issuecomment-422321765)\n+\n+### Example\n+```\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n+fn main() { }\n+```\n+\n+Use instead:\n+```\n+#[rustfmt::skip]\n+fn main() { }\n+```\n\\ No newline at end of file"}, {"sha": "c9574a99b2bec22abdd5b766a55f04b1dd41b494", "filename": "src/docs/deprecated_semver.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdeprecated_semver.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdeprecated_semver.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdeprecated_semver.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for `#[deprecated]` annotations with a `since`\n+field that is not a valid semantic version.\n+\n+### Why is this bad?\n+For checking the version of the deprecation, it must be\n+a valid semver. Failing that, the contained information is useless.\n+\n+### Example\n+```\n+#[deprecated(since = \"forever\")]\n+fn something_else() { /* ... */ }\n+```\n\\ No newline at end of file"}, {"sha": "fa711b924d48015fd81c79f45f0a4303f9ffb2fb", "filename": "src/docs/deref_addrof.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fderef_addrof.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fderef_addrof.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fderef_addrof.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for usage of `*&` and `*&mut` in expressions.\n+\n+### Why is this bad?\n+Immediately dereferencing a reference is no-op and\n+makes the code less clear.\n+\n+### Known problems\n+Multiple dereference/addrof pairs are not handled so\n+the suggested fix for `x = **&&y` is `x = *&y`, which is still incorrect.\n+\n+### Example\n+```\n+let a = f(*&mut b);\n+let c = *&d;\n+```\n+\n+Use instead:\n+```\n+let a = f(b);\n+let c = d;\n+```\n\\ No newline at end of file"}, {"sha": "4dad24ac00cad9ae2532af665ccb2516d939c1bb", "filename": "src/docs/deref_by_slicing.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fderef_by_slicing.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fderef_by_slicing.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fderef_by_slicing.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for slicing expressions which are equivalent to dereferencing the\n+value.\n+\n+### Why is this bad?\n+Some people may prefer to dereference rather than slice.\n+\n+### Example\n+```\n+let vec = vec![1, 2, 3];\n+let slice = &vec[..];\n+```\n+Use instead:\n+```\n+let vec = vec![1, 2, 3];\n+let slice = &*vec;\n+```\n\\ No newline at end of file"}, {"sha": "8e4a80a672cc438b6b16dd442ba33dc4f1016c94", "filename": "src/docs/derivable_impls.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fderivable_impls.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fderivable_impls.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fderivable_impls.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,35 @@\n+### What it does\n+Detects manual `std::default::Default` implementations that are identical to a derived implementation.\n+\n+### Why is this bad?\n+It is less concise.\n+\n+### Example\n+```\n+struct Foo {\n+    bar: bool\n+}\n+\n+impl Default for Foo {\n+    fn default() -> Self {\n+        Self {\n+            bar: false\n+        }\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+#[derive(Default)]\n+struct Foo {\n+    bar: bool\n+}\n+```\n+\n+### Known problems\n+Derive macros [sometimes use incorrect bounds](https://github.com/rust-lang/rust/issues/26925)\n+in generic types and the user defined `impl` maybe is more generalized or\n+specialized than what derive will produce. This lint can't detect the manual `impl`\n+has exactly equal bounds, and therefore this lint is disabled for types with\n+generic parameters.\n\\ No newline at end of file"}, {"sha": "fbf623d5adbc10a0fa3890059c1522cca9f51940", "filename": "src/docs/derive_hash_xor_eq.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fderive_hash_xor_eq.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fderive_hash_xor_eq.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fderive_hash_xor_eq.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for deriving `Hash` but implementing `PartialEq`\n+explicitly or vice versa.\n+\n+### Why is this bad?\n+The implementation of these traits must agree (for\n+example for use with `HashMap`) so it\u2019s probably a bad idea to use a\n+default-generated `Hash` implementation with an explicitly defined\n+`PartialEq`. In particular, the following must hold for any type:\n+\n+```\n+k1 == k2 \u21d2 hash(k1) == hash(k2)\n+```\n+\n+### Example\n+```\n+#[derive(Hash)]\n+struct Foo;\n+\n+impl PartialEq for Foo {\n+    ...\n+}\n+```\n\\ No newline at end of file"}, {"sha": "f2107a5f69eea93e87e2c7544940bf5020407629", "filename": "src/docs/derive_ord_xor_partial_ord.txt", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fderive_ord_xor_partial_ord.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fderive_ord_xor_partial_ord.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fderive_ord_xor_partial_ord.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,44 @@\n+### What it does\n+Checks for deriving `Ord` but implementing `PartialOrd`\n+explicitly or vice versa.\n+\n+### Why is this bad?\n+The implementation of these traits must agree (for\n+example for use with `sort`) so it\u2019s probably a bad idea to use a\n+default-generated `Ord` implementation with an explicitly defined\n+`PartialOrd`. In particular, the following must hold for any type\n+implementing `Ord`:\n+\n+```\n+k1.cmp(&k2) == k1.partial_cmp(&k2).unwrap()\n+```\n+\n+### Example\n+```\n+#[derive(Ord, PartialEq, Eq)]\n+struct Foo;\n+\n+impl PartialOrd for Foo {\n+    ...\n+}\n+```\n+Use instead:\n+```\n+#[derive(PartialEq, Eq)]\n+struct Foo;\n+\n+impl PartialOrd for Foo {\n+    fn partial_cmp(&self, other: &Foo) -> Option<Ordering> {\n+       Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Foo {\n+    ...\n+}\n+```\n+or, if you don't need a custom ordering:\n+```\n+#[derive(Ord, PartialOrd, PartialEq, Eq)]\n+struct Foo;\n+```\n\\ No newline at end of file"}, {"sha": "932fabad666c3431d3fdd39c3168cda2d418b900", "filename": "src/docs/derive_partial_eq_without_eq.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fderive_partial_eq_without_eq.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fderive_partial_eq_without_eq.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fderive_partial_eq_without_eq.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for types that derive `PartialEq` and could implement `Eq`.\n+\n+### Why is this bad?\n+If a type `T` derives `PartialEq` and all of its members implement `Eq`,\n+then `T` can always implement `Eq`. Implementing `Eq` allows `T` to be used\n+in APIs that require `Eq` types. It also allows structs containing `T` to derive\n+`Eq` themselves.\n+\n+### Example\n+```\n+#[derive(PartialEq)]\n+struct Foo {\n+    i_am_eq: i32,\n+    i_am_eq_too: Vec<String>,\n+}\n+```\n+Use instead:\n+```\n+#[derive(PartialEq, Eq)]\n+struct Foo {\n+    i_am_eq: i32,\n+    i_am_eq_too: Vec<String>,\n+}\n+```\n\\ No newline at end of file"}, {"sha": "d8ad5b6a6674cd2c4bb0a79f3b13ca391b1e06ce", "filename": "src/docs/disallowed_methods.txt", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdisallowed_methods.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdisallowed_methods.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdisallowed_methods.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,41 @@\n+### What it does\n+Denies the configured methods and functions in clippy.toml\n+\n+Note: Even though this lint is warn-by-default, it will only trigger if\n+methods are defined in the clippy.toml file.\n+\n+### Why is this bad?\n+Some methods are undesirable in certain contexts, and it's beneficial to\n+lint for them as needed.\n+\n+### Example\n+An example clippy.toml configuration:\n+```\n+disallowed-methods = [\n+    # Can use a string as the path of the disallowed method.\n+    \"std::boxed::Box::new\",\n+    # Can also use an inline table with a `path` key.\n+    { path = \"std::time::Instant::now\" },\n+    # When using an inline table, can add a `reason` for why the method\n+    # is disallowed.\n+    { path = \"std::vec::Vec::leak\", reason = \"no leaking memory\" },\n+]\n+```\n+\n+```\n+// Example code where clippy issues a warning\n+let xs = vec![1, 2, 3, 4];\n+xs.leak(); // Vec::leak is disallowed in the config.\n+// The diagnostic contains the message \"no leaking memory\".\n+\n+let _now = Instant::now(); // Instant::now is disallowed in the config.\n+\n+let _box = Box::new(3); // Box::new is disallowed in the config.\n+```\n+\n+Use instead:\n+```\n+// Example code which does not raise clippy warning\n+let mut xs = Vec::new(); // Vec::new is _not_ disallowed in the config.\n+xs.push(123); // Vec::push is _not_ disallowed in the config.\n+```\n\\ No newline at end of file"}, {"sha": "f4aaee9c77b7baed6014435108a093d22b4cb55f", "filename": "src/docs/disallowed_names.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdisallowed_names.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdisallowed_names.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdisallowed_names.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks for usage of disallowed names for variables, such\n+as `foo`.\n+\n+### Why is this bad?\n+These names are usually placeholder names and should be\n+avoided.\n+\n+### Example\n+```\n+let foo = 3.14;\n+```\n\\ No newline at end of file"}, {"sha": "2151b7a20dedc0bd92841cdc550c96f1c05b45ba", "filename": "src/docs/disallowed_script_idents.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdisallowed_script_idents.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdisallowed_script_idents.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdisallowed_script_idents.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks for usage of unicode scripts other than those explicitly allowed\n+by the lint config.\n+\n+This lint doesn't take into account non-text scripts such as `Unknown` and `Linear_A`.\n+It also ignores the `Common` script type.\n+While configuring, be sure to use official script name [aliases] from\n+[the list of supported scripts][supported_scripts].\n+\n+See also: [`non_ascii_idents`].\n+\n+[aliases]: http://www.unicode.org/reports/tr24/tr24-31.html#Script_Value_Aliases\n+[supported_scripts]: https://www.unicode.org/iso15924/iso15924-codes.html\n+\n+### Why is this bad?\n+It may be not desired to have many different scripts for\n+identifiers in the codebase.\n+\n+Note that if you only want to allow plain English, you might want to use\n+built-in [`non_ascii_idents`] lint instead.\n+\n+[`non_ascii_idents`]: https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#non-ascii-idents\n+\n+### Example\n+```\n+// Assuming that `clippy.toml` contains the following line:\n+// allowed-locales = [\"Latin\", \"Cyrillic\"]\n+let counter = 10; // OK, latin is allowed.\n+let \u0441\u0447\u0451\u0442\u0447\u0438\u043a = 10; // OK, cyrillic is allowed.\n+let z\u00e4hler = 10; // OK, it's still latin.\n+let \u30ab\u30a6\u30f3\u30bf = 10; // Will spawn the lint.\n+```\n\\ No newline at end of file"}, {"sha": "2bcbcddee5666d10d749568713f34c185e057afb", "filename": "src/docs/disallowed_types.txt", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdisallowed_types.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdisallowed_types.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdisallowed_types.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,33 @@\n+### What it does\n+Denies the configured types in clippy.toml.\n+\n+Note: Even though this lint is warn-by-default, it will only trigger if\n+types are defined in the clippy.toml file.\n+\n+### Why is this bad?\n+Some types are undesirable in certain contexts.\n+\n+### Example:\n+An example clippy.toml configuration:\n+```\n+disallowed-types = [\n+    # Can use a string as the path of the disallowed type.\n+    \"std::collections::BTreeMap\",\n+    # Can also use an inline table with a `path` key.\n+    { path = \"std::net::TcpListener\" },\n+    # When using an inline table, can add a `reason` for why the type\n+    # is disallowed.\n+    { path = \"std::net::Ipv4Addr\", reason = \"no IPv4 allowed\" },\n+]\n+```\n+\n+```\n+use std::collections::BTreeMap;\n+// or its use\n+let x = std::collections::BTreeMap::new();\n+```\n+Use instead:\n+```\n+// A similar type that is allowed by the config\n+use std::collections::HashMap;\n+```\n\\ No newline at end of file"}, {"sha": "19436221802512d51c30904ba06904eada8a8de0", "filename": "src/docs/diverging_sub_expression.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdiverging_sub_expression.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdiverging_sub_expression.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdiverging_sub_expression.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for diverging calls that are not match arms or\n+statements.\n+\n+### Why is this bad?\n+It is often confusing to read. In addition, the\n+sub-expression evaluation order for Rust is not well documented.\n+\n+### Known problems\n+Someone might want to use `some_bool || panic!()` as a\n+shorthand.\n+\n+### Example\n+```\n+let a = b() || panic!() || c();\n+// `c()` is dead, `panic!()` is only called if `b()` returns `false`\n+let x = (a, b, c, panic!());\n+// can simply be replaced by `panic!()`\n+```\n\\ No newline at end of file"}, {"sha": "107c8ac116d93bb836d29cacbff9d86f46b2fb96", "filename": "src/docs/doc_link_with_quotes.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdoc_link_with_quotes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdoc_link_with_quotes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdoc_link_with_quotes.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Detects the syntax `['foo']` in documentation comments (notice quotes instead of backticks)\n+outside of code blocks\n+### Why is this bad?\n+It is likely a typo when defining an intra-doc link\n+\n+### Example\n+```\n+/// See also: ['foo']\n+fn bar() {}\n+```\n+Use instead:\n+```\n+/// See also: [`foo`]\n+fn bar() {}\n+```\n\\ No newline at end of file"}, {"sha": "94f54c587e3021ab81cfe05aa1b5834cc3e2ad97", "filename": "src/docs/doc_markdown.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdoc_markdown.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdoc_markdown.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdoc_markdown.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,35 @@\n+### What it does\n+Checks for the presence of `_`, `::` or camel-case words\n+outside ticks in documentation.\n+\n+### Why is this bad?\n+*Rustdoc* supports markdown formatting, `_`, `::` and\n+camel-case probably indicates some code which should be included between\n+ticks. `_` can also be used for emphasis in markdown, this lint tries to\n+consider that.\n+\n+### Known problems\n+Lots of bad docs won\u2019t be fixed, what the lint checks\n+for is limited, and there are still false positives. HTML elements and their\n+content are not linted.\n+\n+In addition, when writing documentation comments, including `[]` brackets\n+inside a link text would trip the parser. Therefore, documenting link with\n+`[`SmallVec<[T; INLINE_CAPACITY]>`]` and then [`SmallVec<[T; INLINE_CAPACITY]>`]: SmallVec\n+would fail.\n+\n+### Examples\n+```\n+/// Do something with the foo_bar parameter. See also\n+/// that::other::module::foo.\n+// ^ `foo_bar` and `that::other::module::foo` should be ticked.\n+fn doit(foo_bar: usize) {}\n+```\n+\n+```\n+// Link text with `[]` brackets should be written as following:\n+/// Consume the array and return the inner\n+/// [`SmallVec<[T; INLINE_CAPACITY]>`][SmallVec].\n+/// [SmallVec]: SmallVec\n+fn main() {}\n+```\n\\ No newline at end of file"}, {"sha": "7dc6818779f4b168e9e6d38e7b58fc75d074c53a", "filename": "src/docs/double_comparisons.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdouble_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdouble_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdouble_comparisons.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for double comparisons that could be simplified to a single expression.\n+\n+\n+### Why is this bad?\n+Readability.\n+\n+### Example\n+```\n+if x == y || x < y {}\n+```\n+\n+Use instead:\n+\n+```\n+if x <= y {}\n+```\n\\ No newline at end of file"}, {"sha": "0017d10d40d339344e8c1f4a7aec32fa2227a818", "filename": "src/docs/double_must_use.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdouble_must_use.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdouble_must_use.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdouble_must_use.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for a `#[must_use]` attribute without\n+further information on functions and methods that return a type already\n+marked as `#[must_use]`.\n+\n+### Why is this bad?\n+The attribute isn't needed. Not using the result\n+will already be reported. Alternatively, one can add some text to the\n+attribute to improve the lint message.\n+\n+### Examples\n+```\n+#[must_use]\n+fn double_must_use() -> Result<(), ()> {\n+    unimplemented!();\n+}\n+```\n\\ No newline at end of file"}, {"sha": "a07f67496d7ccec92f2b90254a8bb68bd0632a1c", "filename": "src/docs/double_neg.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdouble_neg.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdouble_neg.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdouble_neg.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Detects expressions of the form `--x`.\n+\n+### Why is this bad?\n+It can mislead C/C++ programmers to think `x` was\n+decremented.\n+\n+### Example\n+```\n+let mut x = 3;\n+--x;\n+```\n\\ No newline at end of file"}, {"sha": "260d7dd575e55049891e8cdd4aae82da7675e507", "filename": "src/docs/double_parens.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdouble_parens.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdouble_parens.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdouble_parens.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for unnecessary double parentheses.\n+\n+### Why is this bad?\n+This makes code harder to read and might indicate a\n+mistake.\n+\n+### Example\n+```\n+fn simple_double_parens() -> i32 {\n+    ((0))\n+}\n+\n+foo((0));\n+```\n+\n+Use instead:\n+```\n+fn simple_no_parens() -> i32 {\n+    0\n+}\n+\n+foo(0);\n+```\n\\ No newline at end of file"}, {"sha": "f917ca8ed21a69592c822db3bb9ca07dc863a006", "filename": "src/docs/drop_copy.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdrop_copy.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdrop_copy.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdrop_copy.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for calls to `std::mem::drop` with a value\n+that derives the Copy trait\n+\n+### Why is this bad?\n+Calling `std::mem::drop` [does nothing for types that\n+implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html), since the\n+value will be copied and moved into the function on invocation.\n+\n+### Example\n+```\n+let x: i32 = 42; // i32 implements Copy\n+std::mem::drop(x) // A copy of x is passed to the function, leaving the\n+                  // original unaffected\n+```\n\\ No newline at end of file"}, {"sha": "ee1e3a6c216efc33146496d279267cddb3f1e148", "filename": "src/docs/drop_non_drop.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdrop_non_drop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdrop_non_drop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdrop_non_drop.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for calls to `std::mem::drop` with a value that does not implement `Drop`.\n+\n+### Why is this bad?\n+Calling `std::mem::drop` is no different than dropping such a type. A different value may\n+have been intended.\n+\n+### Example\n+```\n+struct Foo;\n+let x = Foo;\n+std::mem::drop(x);\n+```\n\\ No newline at end of file"}, {"sha": "c4f7adf0cfa33d9359bfa54fa878950b62da84da", "filename": "src/docs/drop_ref.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdrop_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fdrop_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdrop_ref.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for calls to `std::mem::drop` with a reference\n+instead of an owned value.\n+\n+### Why is this bad?\n+Calling `drop` on a reference will only drop the\n+reference itself, which is a no-op. It will not call the `drop` method (from\n+the `Drop` trait implementation) on the underlying referenced value, which\n+is likely what was intended.\n+\n+### Example\n+```\n+let mut lock_guard = mutex.lock();\n+std::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex\n+// still locked\n+operation_that_requires_mutex_to_be_unlocked();\n+```\n\\ No newline at end of file"}, {"sha": "709a9aba03ad29d1519993a1fd689e6c9855da9c", "filename": "src/docs/duplicate_mod.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fduplicate_mod.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fduplicate_mod.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fduplicate_mod.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,31 @@\n+### What it does\n+Checks for files that are included as modules multiple times.\n+\n+### Why is this bad?\n+Loading a file as a module more than once causes it to be compiled\n+multiple times, taking longer and putting duplicate content into the\n+module tree.\n+\n+### Example\n+```\n+// lib.rs\n+mod a;\n+mod b;\n+```\n+```\n+// a.rs\n+#[path = \"./b.rs\"]\n+mod b;\n+```\n+\n+Use instead:\n+\n+```\n+// lib.rs\n+mod a;\n+mod b;\n+```\n+```\n+// a.rs\n+use crate::b;\n+```\n\\ No newline at end of file"}, {"sha": "a8fcd6a9fbe680cc7cd987ac16ff2d733879a15f", "filename": "src/docs/duplicate_underscore_argument.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fduplicate_underscore_argument.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fduplicate_underscore_argument.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fduplicate_underscore_argument.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for function arguments having the similar names\n+differing by an underscore.\n+\n+### Why is this bad?\n+It affects code readability.\n+\n+### Example\n+```\n+fn foo(a: i32, _a: i32) {}\n+```\n+\n+Use instead:\n+```\n+fn bar(a: i32, _b: i32) {}\n+```\n\\ No newline at end of file"}, {"sha": "e7e0ca88745ee1e616baf3b40734906fd72f05cb", "filename": "src/docs/duration_subsec.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fduration_subsec.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fduration_subsec.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fduration_subsec.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for calculation of subsecond microseconds or milliseconds\n+from other `Duration` methods.\n+\n+### Why is this bad?\n+It's more concise to call `Duration::subsec_micros()` or\n+`Duration::subsec_millis()` than to calculate them.\n+\n+### Example\n+```\n+let micros = duration.subsec_nanos() / 1_000;\n+let millis = duration.subsec_nanos() / 1_000_000;\n+```\n+\n+Use instead:\n+```\n+let micros = duration.subsec_micros();\n+let millis = duration.subsec_millis();\n+```\n\\ No newline at end of file"}, {"sha": "33f5d0f9185920519b53728ed28ad90ee8dff1d0", "filename": "src/docs/else_if_without_else.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Felse_if_without_else.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Felse_if_without_else.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Felse_if_without_else.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,27 @@\n+### What it does\n+Checks for usage of if expressions with an `else if` branch,\n+but without a final `else` branch.\n+\n+### Why is this bad?\n+Some coding guidelines require this (e.g., MISRA-C:2004 Rule 14.10).\n+\n+### Example\n+```\n+if x.is_positive() {\n+    a();\n+} else if x.is_negative() {\n+    b();\n+}\n+```\n+\n+Use instead:\n+\n+```\n+if x.is_positive() {\n+    a();\n+} else if x.is_negative() {\n+    b();\n+} else {\n+    // We don't care about zero.\n+}\n+```\n\\ No newline at end of file"}, {"sha": "d0c0c24a9c8802460603c23d738cf4dfda2be435", "filename": "src/docs/empty_drop.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fempty_drop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fempty_drop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fempty_drop.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for empty `Drop` implementations.\n+\n+### Why is this bad?\n+Empty `Drop` implementations have no effect when dropping an instance of the type. They are\n+most likely useless. However, an empty `Drop` implementation prevents a type from being\n+destructured, which might be the intention behind adding the implementation as a marker.\n+\n+### Example\n+```\n+struct S;\n+\n+impl Drop for S {\n+    fn drop(&mut self) {}\n+}\n+```\n+Use instead:\n+```\n+struct S;\n+```\n\\ No newline at end of file"}, {"sha": "f7b41c41ee5a1c146475336cd786ef70038120ae", "filename": "src/docs/empty_enum.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fempty_enum.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fempty_enum.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fempty_enum.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,27 @@\n+### What it does\n+Checks for `enum`s with no variants.\n+\n+As of this writing, the `never_type` is still a\n+nightly-only experimental API. Therefore, this lint is only triggered\n+if the `never_type` is enabled.\n+\n+### Why is this bad?\n+If you want to introduce a type which\n+can't be instantiated, you should use `!` (the primitive type \"never\"),\n+or a wrapper around it, because `!` has more extensive\n+compiler support (type inference, etc...) and wrappers\n+around it are the conventional way to define an uninhabited type.\n+For further information visit [never type documentation](https://doc.rust-lang.org/std/primitive.never.html)\n+\n+\n+### Example\n+```\n+enum Test {}\n+```\n+\n+Use instead:\n+```\n+#![feature(never_type)]\n+\n+struct Test(!);\n+```\n\\ No newline at end of file"}, {"sha": "c85242bbee0ec503c806db781256ea270c6a166a", "filename": "src/docs/empty_line_after_outer_attr.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fempty_line_after_outer_attr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fempty_line_after_outer_attr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fempty_line_after_outer_attr.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,35 @@\n+### What it does\n+Checks for empty lines after outer attributes\n+\n+### Why is this bad?\n+Most likely the attribute was meant to be an inner attribute using a '!'.\n+If it was meant to be an outer attribute, then the following item\n+should not be separated by empty lines.\n+\n+### Known problems\n+Can cause false positives.\n+\n+From the clippy side it's difficult to detect empty lines between an attributes and the\n+following item because empty lines and comments are not part of the AST. The parsing\n+currently works for basic cases but is not perfect.\n+\n+### Example\n+```\n+#[allow(dead_code)]\n+\n+fn not_quite_good_code() { }\n+```\n+\n+Use instead:\n+```\n+// Good (as inner attribute)\n+#![allow(dead_code)]\n+\n+fn this_is_fine() { }\n+\n+// or\n+\n+// Good (as outer attribute)\n+#[allow(dead_code)]\n+fn this_is_fine_too() { }\n+```\n\\ No newline at end of file"}, {"sha": "fea49a74d04e0cfebe15598e7848293327f02527", "filename": "src/docs/empty_loop.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fempty_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fempty_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fempty_loop.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,27 @@\n+### What it does\n+Checks for empty `loop` expressions.\n+\n+### Why is this bad?\n+These busy loops burn CPU cycles without doing\n+anything. It is _almost always_ a better idea to `panic!` than to have\n+a busy loop.\n+\n+If panicking isn't possible, think of the environment and either:\n+  - block on something\n+  - sleep the thread for some microseconds\n+  - yield or pause the thread\n+\n+For `std` targets, this can be done with\n+[`std::thread::sleep`](https://doc.rust-lang.org/std/thread/fn.sleep.html)\n+or [`std::thread::yield_now`](https://doc.rust-lang.org/std/thread/fn.yield_now.html).\n+\n+For `no_std` targets, doing this is more complicated, especially because\n+`#[panic_handler]`s can't panic. To stop/pause the thread, you will\n+probably need to invoke some target-specific intrinsic. Examples include:\n+  - [`x86_64::instructions::hlt`](https://docs.rs/x86_64/0.12.2/x86_64/instructions/fn.hlt.html)\n+  - [`cortex_m::asm::wfi`](https://docs.rs/cortex-m/0.6.3/cortex_m/asm/fn.wfi.html)\n+\n+### Example\n+```\n+loop {}\n+```\n\\ No newline at end of file"}, {"sha": "ab5e35ae2ada8c475775f307275790b1bd7e16a2", "filename": "src/docs/empty_structs_with_brackets.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fempty_structs_with_brackets.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fempty_structs_with_brackets.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fempty_structs_with_brackets.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Finds structs without fields (a so-called \"empty struct\") that are declared with brackets.\n+\n+### Why is this bad?\n+Empty brackets after a struct declaration can be omitted.\n+\n+### Example\n+```\n+struct Cookie {}\n+```\n+Use instead:\n+```\n+struct Cookie;\n+```\n\\ No newline at end of file"}, {"sha": "d30a973a5a1357eab121909c688ad05f160de47e", "filename": "src/docs/enum_clike_unportable_variant.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fenum_clike_unportable_variant.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fenum_clike_unportable_variant.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fenum_clike_unportable_variant.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for C-like enumerations that are\n+`repr(isize/usize)` and have values that don't fit into an `i32`.\n+\n+### Why is this bad?\n+This will truncate the variant value on 32 bit\n+architectures, but works fine on 64 bit.\n+\n+### Example\n+```\n+#[repr(usize)]\n+enum NonPortable {\n+    X = 0x1_0000_0000,\n+    Y = 0,\n+}\n+```\n\\ No newline at end of file"}, {"sha": "3776822c35b0c21a9d6330c1b7a374c14cf8d232", "filename": "src/docs/enum_glob_use.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fenum_glob_use.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fenum_glob_use.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fenum_glob_use.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for `use Enum::*`.\n+\n+### Why is this bad?\n+It is usually better style to use the prefixed name of\n+an enumeration variant, rather than importing variants.\n+\n+### Known problems\n+Old-style enumerations that prefix the variants are\n+still around.\n+\n+### Example\n+```\n+use std::cmp::Ordering::*;\n+\n+foo(Less);\n+```\n+\n+Use instead:\n+```\n+use std::cmp::Ordering;\n+\n+foo(Ordering::Less)\n+```\n\\ No newline at end of file"}, {"sha": "e726925edda82ca777546cf7e613ee78304c10a0", "filename": "src/docs/enum_variant_names.txt", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fenum_variant_names.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fenum_variant_names.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fenum_variant_names.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,30 @@\n+### What it does\n+Detects enumeration variants that are prefixed or suffixed\n+by the same characters.\n+\n+### Why is this bad?\n+Enumeration variant names should specify their variant,\n+not repeat the enumeration name.\n+\n+### Limitations\n+Characters with no casing will be considered when comparing prefixes/suffixes\n+This applies to numbers and non-ascii characters without casing\n+e.g. `Foo1` and `Foo2` is considered to have different prefixes\n+(the prefixes are `Foo1` and `Foo2` respectively), as also `Bar\u8783`, `Bar\u87f9`\n+\n+### Example\n+```\n+enum Cake {\n+    BlackForestCake,\n+    HummingbirdCake,\n+    BattenbergCake,\n+}\n+```\n+Use instead:\n+```\n+enum Cake {\n+    BlackForest,\n+    Hummingbird,\n+    Battenberg,\n+}\n+```\n\\ No newline at end of file"}, {"sha": "2d75a0ec546e72043fb085d8cdfa4406311bc856", "filename": "src/docs/eq_op.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Feq_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Feq_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Feq_op.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for equal operands to comparison, logical and\n+bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n+`||`, `&`, `|`, `^`, `-` and `/`).\n+\n+### Why is this bad?\n+This is usually just a typo or a copy and paste error.\n+\n+### Known problems\n+False negatives: We had some false positives regarding\n+calls (notably [racer](https://github.com/phildawes/racer) had one instance\n+of `x.pop() && x.pop()`), so we removed matching any function or method\n+calls. We may introduce a list of known pure functions in the future.\n+\n+### Example\n+```\n+if x + 1 == x + 1 {}\n+\n+// or\n+\n+assert_eq!(a, a);\n+```\n\\ No newline at end of file"}, {"sha": "9997046954c20d3779fe82a2384579dfc6ca8be0", "filename": "src/docs/equatable_if_let.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fequatable_if_let.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fequatable_if_let.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fequatable_if_let.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for pattern matchings that can be expressed using equality.\n+\n+### Why is this bad?\n+\n+* It reads better and has less cognitive load because equality won't cause binding.\n+* It is a [Yoda condition](https://en.wikipedia.org/wiki/Yoda_conditions). Yoda conditions are widely\n+criticized for increasing the cognitive load of reading the code.\n+* Equality is a simple bool expression and can be merged with `&&` and `||` and\n+reuse if blocks\n+\n+### Example\n+```\n+if let Some(2) = x {\n+    do_thing();\n+}\n+```\n+Use instead:\n+```\n+if x == Some(2) {\n+    do_thing();\n+}\n+```\n\\ No newline at end of file"}, {"sha": "3d285a6d86e48f8e7e7ebbebd97b83ad5489c6f5", "filename": "src/docs/erasing_op.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ferasing_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ferasing_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ferasing_op.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for erasing operations, e.g., `x * 0`.\n+\n+### Why is this bad?\n+The whole expression can be replaced by zero.\n+This is most likely not the intended outcome and should probably be\n+corrected\n+\n+### Example\n+```\n+let x = 1;\n+0 / x;\n+0 * x;\n+x & 0;\n+```\n\\ No newline at end of file"}, {"sha": "1dc83c5ce0ee05ded2a906da263f6f2cdbedcfe2", "filename": "src/docs/err_expect.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ferr_expect.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ferr_expect.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ferr_expect.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for `.err().expect()` calls on the `Result` type.\n+\n+### Why is this bad?\n+`.expect_err()` can be called directly to avoid the extra type conversion from `err()`.\n+\n+### Example\n+```\n+let x: Result<u32, &str> = Ok(10);\n+x.err().expect(\"Testing err().expect()\");\n+```\n+Use instead:\n+```\n+let x: Result<u32, &str> = Ok(10);\n+x.expect_err(\"Testing expect_err\");\n+```\n\\ No newline at end of file"}, {"sha": "517879c47152b20fb30798b191cb0d627e403ca3", "filename": "src/docs/excessive_precision.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexcessive_precision.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexcessive_precision.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexcessive_precision.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for float literals with a precision greater\n+than that supported by the underlying type.\n+\n+### Why is this bad?\n+Rust will truncate the literal silently.\n+\n+### Example\n+```\n+let v: f32 = 0.123_456_789_9;\n+println!(\"{}\", v); //  0.123_456_789\n+```\n+\n+Use instead:\n+```\n+let v: f64 = 0.123_456_789_9;\n+println!(\"{}\", v); //  0.123_456_789_9\n+```\n\\ No newline at end of file"}, {"sha": "d1032a7a29aa04d68b3384edfc0dcc9dd4b310a2", "filename": "src/docs/exhaustive_enums.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexhaustive_enums.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexhaustive_enums.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexhaustive_enums.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Warns on any exported `enum`s that are not tagged `#[non_exhaustive]`\n+\n+### Why is this bad?\n+Exhaustive enums are typically fine, but a project which does\n+not wish to make a stability commitment around exported enums may wish to\n+disable them by default.\n+\n+### Example\n+```\n+enum Foo {\n+    Bar,\n+    Baz\n+}\n+```\n+Use instead:\n+```\n+#[non_exhaustive]\n+enum Foo {\n+    Bar,\n+    Baz\n+}\n+```\n\\ No newline at end of file"}, {"sha": "fd6e4f5caf1f257b04d4f0712b064fe44eb40ff6", "filename": "src/docs/exhaustive_structs.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexhaustive_structs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexhaustive_structs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexhaustive_structs.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Warns on any exported `structs`s that are not tagged `#[non_exhaustive]`\n+\n+### Why is this bad?\n+Exhaustive structs are typically fine, but a project which does\n+not wish to make a stability commitment around exported structs may wish to\n+disable them by default.\n+\n+### Example\n+```\n+struct Foo {\n+    bar: u8,\n+    baz: String,\n+}\n+```\n+Use instead:\n+```\n+#[non_exhaustive]\n+struct Foo {\n+    bar: u8,\n+    baz: String,\n+}\n+```\n\\ No newline at end of file"}, {"sha": "1e6154d43e0538550a3c6b40f984d79d4bb259ea", "filename": "src/docs/exit.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexit.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexit.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexit.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+`exit()`  terminates the program and doesn't provide a\n+stack trace.\n+\n+### Why is this bad?\n+Ideally a program is terminated by finishing\n+the main function.\n+\n+### Example\n+```\n+std::process::exit(0)\n+```\n\\ No newline at end of file"}, {"sha": "d82d9aa9baff240c08aa50ceb41107973ffb44a9", "filename": "src/docs/expect_fun_call.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexpect_fun_call.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexpect_fun_call.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexpect_fun_call.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\n+etc., and suggests to use `unwrap_or_else` instead\n+\n+### Why is this bad?\n+The function will always be called.\n+\n+### Known problems\n+If the function has side-effects, not calling it will\n+change the semantics of the program, but you shouldn't rely on that anyway.\n+\n+### Example\n+```\n+foo.expect(&format!(\"Err {}: {}\", err_code, err_msg));\n+\n+// or\n+\n+foo.expect(format!(\"Err {}: {}\", err_code, err_msg).as_str());\n+```\n+\n+Use instead:\n+```\n+foo.unwrap_or_else(|| panic!(\"Err {}: {}\", err_code, err_msg));\n+```\n\\ No newline at end of file"}, {"sha": "4a6981e334fd368b1b2d521d395506c8d7fdb494", "filename": "src/docs/expect_used.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexpect_used.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexpect_used.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexpect_used.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for `.expect()` or `.expect_err()` calls on `Result`s and `.expect()` call on `Option`s.\n+\n+### Why is this bad?\n+Usually it is better to handle the `None` or `Err` case.\n+Still, for a lot of quick-and-dirty code, `expect` is a good choice, which is why\n+this lint is `Allow` by default.\n+\n+`result.expect()` will let the thread panic on `Err`\n+values. Normally, you want to implement more sophisticated error handling,\n+and propagate errors upwards with `?` operator.\n+\n+### Examples\n+```\n+option.expect(\"one\");\n+result.expect(\"one\");\n+```\n+\n+Use instead:\n+```\n+option?;\n+\n+// or\n+\n+result?;\n+```\n\\ No newline at end of file"}, {"sha": "391d93b6713cca2005d7d14b2b97fd24c48e8098", "filename": "src/docs/expl_impl_clone_on_copy.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexpl_impl_clone_on_copy.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexpl_impl_clone_on_copy.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexpl_impl_clone_on_copy.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for explicit `Clone` implementations for `Copy`\n+types.\n+\n+### Why is this bad?\n+To avoid surprising behavior, these traits should\n+agree and the behavior of `Copy` cannot be overridden. In almost all\n+situations a `Copy` type should have a `Clone` implementation that does\n+nothing more than copy the object, which is what `#[derive(Copy, Clone)]`\n+gets you.\n+\n+### Example\n+```\n+#[derive(Copy)]\n+struct Foo;\n+\n+impl Clone for Foo {\n+    // ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "65b256317725288a2f95142e309ca0effd3db921", "filename": "src/docs/explicit_auto_deref.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexplicit_auto_deref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexplicit_auto_deref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexplicit_auto_deref.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for dereferencing expressions which would be covered by auto-deref.\n+\n+### Why is this bad?\n+This unnecessarily complicates the code.\n+\n+### Example\n+```\n+let x = String::new();\n+let y: &str = &*x;\n+```\n+Use instead:\n+```\n+let x = String::new();\n+let y: &str = &x;\n+```\n\\ No newline at end of file"}, {"sha": "2661a43e10341f95851551e53b0b7695bc308cf4", "filename": "src/docs/explicit_counter_loop.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexplicit_counter_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexplicit_counter_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexplicit_counter_loop.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks `for` loops over slices with an explicit counter\n+and suggests the use of `.enumerate()`.\n+\n+### Why is this bad?\n+Using `.enumerate()` makes the intent more clear,\n+declutters the code and may be faster in some instances.\n+\n+### Example\n+```\n+let mut i = 0;\n+for item in &v {\n+    bar(i, *item);\n+    i += 1;\n+}\n+```\n+\n+Use instead:\n+```\n+for (i, item) in v.iter().enumerate() { bar(i, *item); }\n+```\n\\ No newline at end of file"}, {"sha": "e14e981c7073bee00239c22eb5420c6ca87669a3", "filename": "src/docs/explicit_deref_methods.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexplicit_deref_methods.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexplicit_deref_methods.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexplicit_deref_methods.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for explicit `deref()` or `deref_mut()` method calls.\n+\n+### Why is this bad?\n+Dereferencing by `&*x` or `&mut *x` is clearer and more concise,\n+when not part of a method chain.\n+\n+### Example\n+```\n+use std::ops::Deref;\n+let a: &mut String = &mut String::from(\"foo\");\n+let b: &str = a.deref();\n+```\n+\n+Use instead:\n+```\n+let a: &mut String = &mut String::from(\"foo\");\n+let b = &*a;\n+```\n+\n+This lint excludes:\n+```\n+let _ = d.unwrap().deref();\n+```\n\\ No newline at end of file"}, {"sha": "3931dfd69a318d74f9112bd2ea4b7baff6757b7a", "filename": "src/docs/explicit_into_iter_loop.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexplicit_into_iter_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexplicit_into_iter_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexplicit_into_iter_loop.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for loops on `y.into_iter()` where `y` will do, and\n+suggests the latter.\n+\n+### Why is this bad?\n+Readability.\n+\n+### Example\n+```\n+// with `y` a `Vec` or slice:\n+for x in y.into_iter() {\n+    // ..\n+}\n+```\n+can be rewritten to\n+```\n+for x in y {\n+    // ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "cabe72e91d04f6395df2a64f5180c9ec0ebe15e9", "filename": "src/docs/explicit_iter_loop.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexplicit_iter_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexplicit_iter_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexplicit_iter_loop.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for loops on `x.iter()` where `&x` will do, and\n+suggests the latter.\n+\n+### Why is this bad?\n+Readability.\n+\n+### Known problems\n+False negatives. We currently only warn on some known\n+types.\n+\n+### Example\n+```\n+// with `y` a `Vec` or slice:\n+for x in y.iter() {\n+    // ..\n+}\n+```\n+\n+Use instead:\n+```\n+for x in &y {\n+    // ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "eafed5d39e5c63e48783ae846b87de9c1c901ffe", "filename": "src/docs/explicit_write.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexplicit_write.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fexplicit_write.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexplicit_write.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for usage of `write!()` / `writeln()!` which can be\n+replaced with `(e)print!()` / `(e)println!()`\n+\n+### Why is this bad?\n+Using `(e)println! is clearer and more concise\n+\n+### Example\n+```\n+writeln!(&mut std::io::stderr(), \"foo: {:?}\", bar).unwrap();\n+writeln!(&mut std::io::stdout(), \"foo: {:?}\", bar).unwrap();\n+```\n+\n+Use instead:\n+```\n+eprintln!(\"foo: {:?}\", bar);\n+println!(\"foo: {:?}\", bar);\n+```\n\\ No newline at end of file"}, {"sha": "2f31dcf5f74013c933a071068115a2de1a20945e", "filename": "src/docs/extend_with_drain.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fextend_with_drain.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fextend_with_drain.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fextend_with_drain.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for occurrences where one vector gets extended instead of append\n+\n+### Why is this bad?\n+Using `append` instead of `extend` is more concise and faster\n+\n+### Example\n+```\n+let mut a = vec![1, 2, 3];\n+let mut b = vec![4, 5, 6];\n+\n+a.extend(b.drain(..));\n+```\n+\n+Use instead:\n+```\n+let mut a = vec![1, 2, 3];\n+let mut b = vec![4, 5, 6];\n+\n+a.append(&mut b);\n+```\n\\ No newline at end of file"}, {"sha": "bc1814aa4752dae2cf7574f3fa00b98553edd2ad", "filename": "src/docs/extra_unused_lifetimes.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fextra_unused_lifetimes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fextra_unused_lifetimes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fextra_unused_lifetimes.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for lifetimes in generics that are never used\n+anywhere else.\n+\n+### Why is this bad?\n+The additional lifetimes make the code look more\n+complicated, while there is nothing out of the ordinary going on. Removing\n+them leads to more readable code.\n+\n+### Example\n+```\n+// unnecessary lifetimes\n+fn unused_lifetime<'a>(x: u8) {\n+    // ..\n+}\n+```\n+\n+Use instead:\n+```\n+fn no_lifetime(x: u8) {\n+    // ...\n+}\n+```\n\\ No newline at end of file"}, {"sha": "588a5bb103d46e8cccd30f84c1982069c9c1d5e7", "filename": "src/docs/fallible_impl_from.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffallible_impl_from.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffallible_impl_from.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffallible_impl_from.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n+\n+### Why is this bad?\n+`TryFrom` should be used if there's a possibility of failure.\n+\n+### Example\n+```\n+struct Foo(i32);\n+\n+impl From<String> for Foo {\n+    fn from(s: String) -> Self {\n+        Foo(s.parse().unwrap())\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+struct Foo(i32);\n+\n+impl TryFrom<String> for Foo {\n+    type Error = ();\n+    fn try_from(s: String) -> Result<Self, Self::Error> {\n+        if let Ok(parsed) = s.parse() {\n+            Ok(Foo(parsed))\n+        } else {\n+            Err(())\n+        }\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "e58b7239fde9e039676d3208a95a8ebbcf991cce", "filename": "src/docs/field_reassign_with_default.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffield_reassign_with_default.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffield_reassign_with_default.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffield_reassign_with_default.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for immediate reassignment of fields initialized\n+with Default::default().\n+\n+### Why is this bad?\n+It's more idiomatic to use the [functional update syntax](https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax).\n+\n+### Known problems\n+Assignments to patterns that are of tuple type are not linted.\n+\n+### Example\n+```\n+let mut a: A = Default::default();\n+a.i = 42;\n+```\n+\n+Use instead:\n+```\n+let a = A {\n+    i: 42,\n+    .. Default::default()\n+};\n+```\n\\ No newline at end of file"}, {"sha": "ad14bd62c4de483b76e3d6d04f85a6120614996d", "filename": "src/docs/filetype_is_file.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffiletype_is_file.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffiletype_is_file.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffiletype_is_file.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Checks for `FileType::is_file()`.\n+\n+### Why is this bad?\n+When people testing a file type with `FileType::is_file`\n+they are testing whether a path is something they can get bytes from. But\n+`is_file` doesn't cover special file types in unix-like systems, and doesn't cover\n+symlink in windows. Using `!FileType::is_dir()` is a better way to that intention.\n+\n+### Example\n+```\n+let metadata = std::fs::metadata(\"foo.txt\")?;\n+let filetype = metadata.file_type();\n+\n+if filetype.is_file() {\n+    // read file\n+}\n+```\n+\n+should be written as:\n+\n+```\n+let metadata = std::fs::metadata(\"foo.txt\")?;\n+let filetype = metadata.file_type();\n+\n+if !filetype.is_dir() {\n+    // read file\n+}\n+```\n\\ No newline at end of file"}, {"sha": "83b666f2e27820a7493ace384d6e5676dc81ed6d", "filename": "src/docs/filter_map_identity.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffilter_map_identity.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffilter_map_identity.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffilter_map_identity.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks for usage of `filter_map(|x| x)`.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely by using `flatten`.\n+\n+### Example\n+```\n+iter.filter_map(|x| x);\n+```\n+Use instead:\n+```\n+iter.flatten();\n+```\n\\ No newline at end of file"}, {"sha": "b38620b56a50fecc0abeb311a07f30a84c2a6bae", "filename": "src/docs/filter_map_next.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffilter_map_next.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffilter_map_next.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffilter_map_next.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of `_.filter_map(_).next()`.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely as\n+`_.find_map(_)`.\n+\n+### Example\n+```\n+ (0..3).filter_map(|x| if x == 2 { Some(x) } else { None }).next();\n+```\n+Can be written as\n+\n+```\n+ (0..3).find_map(|x| if x == 2 { Some(x) } else { None });\n+```\n\\ No newline at end of file"}, {"sha": "898a74166dc14649f0faa4fb561968049f14bc9a", "filename": "src/docs/filter_next.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffilter_next.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffilter_next.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffilter_next.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of `_.filter(_).next()`.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely as\n+`_.find(_)`.\n+\n+### Example\n+```\n+vec.iter().filter(|x| **x == 0).next();\n+```\n+\n+Use instead:\n+```\n+vec.iter().find(|x| **x == 0);\n+```\n\\ No newline at end of file"}, {"sha": "a5ee79b4982fb753d1d99c77b40491d9b26c0013", "filename": "src/docs/flat_map_identity.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fflat_map_identity.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fflat_map_identity.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fflat_map_identity.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks for usage of `flat_map(|x| x)`.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely by using `flatten`.\n+\n+### Example\n+```\n+iter.flat_map(|x| x);\n+```\n+Can be written as\n+```\n+iter.flatten();\n+```\n\\ No newline at end of file"}, {"sha": "d50b9156d3654c19262e8460e2ddf1f3d22a5483", "filename": "src/docs/flat_map_option.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fflat_map_option.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fflat_map_option.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fflat_map_option.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usages of `Iterator::flat_map()` where `filter_map()` could be\n+used instead.\n+\n+### Why is this bad?\n+When applicable, `filter_map()` is more clear since it shows that\n+`Option` is used to produce 0 or 1 items.\n+\n+### Example\n+```\n+let nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().flat_map(|x| x.parse().ok()).collect();\n+```\n+Use instead:\n+```\n+let nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().filter_map(|x| x.parse().ok()).collect();\n+```\n\\ No newline at end of file"}, {"sha": "1f9bce5abd59fdd52e2210a73ea648687a55c1ce", "filename": "src/docs/float_arithmetic.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffloat_arithmetic.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffloat_arithmetic.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffloat_arithmetic.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,11 @@\n+### What it does\n+Checks for float arithmetic.\n+\n+### Why is this bad?\n+For some embedded systems or kernel development, it\n+can be useful to rule out floating-point numbers.\n+\n+### Example\n+```\n+a + 1.0;\n+```\n\\ No newline at end of file"}, {"sha": "c19907c903e9df1d6592666ddc5f07bf58977841", "filename": "src/docs/float_cmp.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffloat_cmp.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffloat_cmp.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffloat_cmp.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for (in-)equality comparisons on floating-point\n+values (apart from zero), except in functions called `*eq*` (which probably\n+implement equality for a type involving floats).\n+\n+### Why is this bad?\n+Floating point calculations are usually imprecise, so\n+asking if two values are *exactly* equal is asking for trouble. For a good\n+guide on what to do, see [the floating point\n+guide](http://www.floating-point-gui.de/errors/comparison).\n+\n+### Example\n+```\n+let x = 1.2331f64;\n+let y = 1.2332f64;\n+\n+if y == 1.23f64 { }\n+if y != x {} // where both are floats\n+```\n+\n+Use instead:\n+```\n+let error_margin = f64::EPSILON; // Use an epsilon for comparison\n+// Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n+// let error_margin = std::f64::EPSILON;\n+if (y - 1.23f64).abs() < error_margin { }\n+if (y - x).abs() > error_margin { }\n+```\n\\ No newline at end of file"}, {"sha": "9208feaacd81011198713479d3f80d72b33a2c41", "filename": "src/docs/float_cmp_const.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffloat_cmp_const.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffloat_cmp_const.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffloat_cmp_const.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for (in-)equality comparisons on floating-point\n+value and constant, except in functions called `*eq*` (which probably\n+implement equality for a type involving floats).\n+\n+### Why is this bad?\n+Floating point calculations are usually imprecise, so\n+asking if two values are *exactly* equal is asking for trouble. For a good\n+guide on what to do, see [the floating point\n+guide](http://www.floating-point-gui.de/errors/comparison).\n+\n+### Example\n+```\n+let x: f64 = 1.0;\n+const ONE: f64 = 1.00;\n+\n+if x == ONE { } // where both are floats\n+```\n+\n+Use instead:\n+```\n+let error_margin = f64::EPSILON; // Use an epsilon for comparison\n+// Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n+// let error_margin = std::f64::EPSILON;\n+if (x - ONE).abs() < error_margin { }\n+```\n\\ No newline at end of file"}, {"sha": "556b574e15d303a4b8c6774b1f9e94ec6b3c89dd", "filename": "src/docs/float_equality_without_abs.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffloat_equality_without_abs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffloat_equality_without_abs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffloat_equality_without_abs.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for statements of the form `(a - b) < f32::EPSILON` or\n+`(a - b) < f64::EPSILON`. Notes the missing `.abs()`.\n+\n+### Why is this bad?\n+The code without `.abs()` is more likely to have a bug.\n+\n+### Known problems\n+If the user can ensure that b is larger than a, the `.abs()` is\n+technically unnecessary. However, it will make the code more robust and doesn't have any\n+large performance implications. If the abs call was deliberately left out for performance\n+reasons, it is probably better to state this explicitly in the code, which then can be done\n+with an allow.\n+\n+### Example\n+```\n+pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+    (a - b) < f32::EPSILON\n+}\n+```\n+Use instead:\n+```\n+pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+    (a - b).abs() < f32::EPSILON\n+}\n+```\n\\ No newline at end of file"}, {"sha": "7d2b7b681deb15ff2edf37bf9b60d9b3cd60a3b7", "filename": "src/docs/fn_address_comparisons.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffn_address_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffn_address_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffn_address_comparisons.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for comparisons with an address of a function item.\n+\n+### Why is this bad?\n+Function item address is not guaranteed to be unique and could vary\n+between different code generation units. Furthermore different function items could have\n+the same address after being merged together.\n+\n+### Example\n+```\n+type F = fn();\n+fn a() {}\n+let f: F = a;\n+if f == a {\n+    // ...\n+}\n+```\n\\ No newline at end of file"}, {"sha": "2eae0563368c1adb6e91dc7080d1c839e5c07141", "filename": "src/docs/fn_params_excessive_bools.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffn_params_excessive_bools.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffn_params_excessive_bools.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffn_params_excessive_bools.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,31 @@\n+### What it does\n+Checks for excessive use of\n+bools in function definitions.\n+\n+### Why is this bad?\n+Calls to such functions\n+are confusing and error prone, because it's\n+hard to remember argument order and you have\n+no type system support to back you up. Using\n+two-variant enums instead of bools often makes\n+API easier to use.\n+\n+### Example\n+```\n+fn f(is_round: bool, is_hot: bool) { ... }\n+```\n+\n+Use instead:\n+```\n+enum Shape {\n+    Round,\n+    Spiky,\n+}\n+\n+enum Temperature {\n+    Hot,\n+    IceCold,\n+}\n+\n+fn f(shape: Shape, temperature: Temperature) { ... }\n+```\n\\ No newline at end of file"}, {"sha": "1f587f6d7176891c2999504b86bc80923eddf3ae", "filename": "src/docs/fn_to_numeric_cast.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffn_to_numeric_cast.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffn_to_numeric_cast.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffn_to_numeric_cast.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for casts of function pointers to something other than usize\n+\n+### Why is this bad?\n+Casting a function pointer to anything other than usize/isize is not portable across\n+architectures, because you end up losing bits if the target type is too small or end up with a\n+bunch of extra bits that waste space and add more instructions to the final binary than\n+strictly necessary for the problem\n+\n+Casting to isize also doesn't make sense since there are no signed addresses.\n+\n+### Example\n+```\n+fn fun() -> i32 { 1 }\n+let _ = fun as i64;\n+```\n+\n+Use instead:\n+```\n+let _ = fun as usize;\n+```\n\\ No newline at end of file"}, {"sha": "ee3c33d237255999c8332a1722c1a2e2248527d8", "filename": "src/docs/fn_to_numeric_cast_any.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffn_to_numeric_cast_any.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffn_to_numeric_cast_any.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffn_to_numeric_cast_any.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,35 @@\n+### What it does\n+Checks for casts of a function pointer to any integer type.\n+\n+### Why is this bad?\n+Casting a function pointer to an integer can have surprising results and can occur\n+accidentally if parentheses are omitted from a function call. If you aren't doing anything\n+low-level with function pointers then you can opt-out of casting functions to integers in\n+order to avoid mistakes. Alternatively, you can use this lint to audit all uses of function\n+pointer casts in your code.\n+\n+### Example\n+```\n+// fn1 is cast as `usize`\n+fn fn1() -> u16 {\n+    1\n+};\n+let _ = fn1 as usize;\n+```\n+\n+Use instead:\n+```\n+// maybe you intended to call the function?\n+fn fn2() -> u16 {\n+    1\n+};\n+let _ = fn2() as usize;\n+\n+// or\n+\n+// maybe you intended to cast it to a function type?\n+fn fn3() -> u16 {\n+    1\n+}\n+let _ = fn3 as fn() -> u16;\n+```\n\\ No newline at end of file"}, {"sha": "69f12fa319f184c12807d8f7037ba971a0c441b0", "filename": "src/docs/fn_to_numeric_cast_with_truncation.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffn_to_numeric_cast_with_truncation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffn_to_numeric_cast_with_truncation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffn_to_numeric_cast_with_truncation.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for casts of a function pointer to a numeric type not wide enough to\n+store address.\n+\n+### Why is this bad?\n+Such a cast discards some bits of the function's address. If this is intended, it would be more\n+clearly expressed by casting to usize first, then casting the usize to the intended type (with\n+a comment) to perform the truncation.\n+\n+### Example\n+```\n+fn fn1() -> i16 {\n+    1\n+};\n+let _ = fn1 as i32;\n+```\n+\n+Use instead:\n+```\n+// Cast to usize first, then comment with the reason for the truncation\n+fn fn1() -> i16 {\n+    1\n+};\n+let fn_ptr = fn1 as usize;\n+let fn_ptr_truncated = fn_ptr as i32;\n+```\n\\ No newline at end of file"}, {"sha": "a9a2ffee9c743dc99302ab5af63bdb465d1d6f37", "filename": "src/docs/for_kv_map.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffor_kv_map.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffor_kv_map.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffor_kv_map.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for iterating a map (`HashMap` or `BTreeMap`) and\n+ignoring either the keys or values.\n+\n+### Why is this bad?\n+Readability. There are `keys` and `values` methods that\n+can be used to express that don't need the values or keys.\n+\n+### Example\n+```\n+for (k, _) in &map {\n+    ..\n+}\n+```\n+\n+could be replaced by\n+\n+```\n+for k in map.keys() {\n+    ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "c5a7508e45d40e58cef17a27e3f92a855dd0b398", "filename": "src/docs/for_loops_over_fallibles.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffor_loops_over_fallibles.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffor_loops_over_fallibles.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffor_loops_over_fallibles.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks for `for` loops over `Option` or `Result` values.\n+\n+### Why is this bad?\n+Readability. This is more clearly expressed as an `if\n+let`.\n+\n+### Example\n+```\n+for x in opt {\n+    // ..\n+}\n+\n+for x in &res {\n+    // ..\n+}\n+\n+for x in res.iter() {\n+    // ..\n+}\n+```\n+\n+Use instead:\n+```\n+if let Some(x) = opt {\n+    // ..\n+}\n+\n+if let Ok(x) = res {\n+    // ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "1d100912e9a4858152077e45ecee4223f5ef154e", "filename": "src/docs/forget_copy.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fforget_copy.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fforget_copy.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fforget_copy.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for calls to `std::mem::forget` with a value that\n+derives the Copy trait\n+\n+### Why is this bad?\n+Calling `std::mem::forget` [does nothing for types that\n+implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html) since the\n+value will be copied and moved into the function on invocation.\n+\n+An alternative, but also valid, explanation is that Copy types do not\n+implement\n+the Drop trait, which means they have no destructors. Without a destructor,\n+there\n+is nothing for `std::mem::forget` to ignore.\n+\n+### Example\n+```\n+let x: i32 = 42; // i32 implements Copy\n+std::mem::forget(x) // A copy of x is passed to the function, leaving the\n+                    // original unaffected\n+```\n\\ No newline at end of file"}, {"sha": "3307d654c17f2bd860f740606bf29b5aa91b4085", "filename": "src/docs/forget_non_drop.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fforget_non_drop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fforget_non_drop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fforget_non_drop.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for calls to `std::mem::forget` with a value that does not implement `Drop`.\n+\n+### Why is this bad?\n+Calling `std::mem::forget` is no different than dropping such a type. A different value may\n+have been intended.\n+\n+### Example\n+```\n+struct Foo;\n+let x = Foo;\n+std::mem::forget(x);\n+```\n\\ No newline at end of file"}, {"sha": "874fb8786068d635fa10e65e5bce43bf27d6947b", "filename": "src/docs/forget_ref.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fforget_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fforget_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fforget_ref.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for calls to `std::mem::forget` with a reference\n+instead of an owned value.\n+\n+### Why is this bad?\n+Calling `forget` on a reference will only forget the\n+reference itself, which is a no-op. It will not forget the underlying\n+referenced\n+value, which is likely what was intended.\n+\n+### Example\n+```\n+let x = Box::new(1);\n+std::mem::forget(&x) // Should have been forget(x), x will still be dropped\n+```\n\\ No newline at end of file"}, {"sha": "ac498472f017f04a35c2a7017e599dc40f3034d9", "filename": "src/docs/format_in_format_args.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fformat_in_format_args.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fformat_in_format_args.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fformat_in_format_args.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Detects `format!` within the arguments of another macro that does\n+formatting such as `format!` itself, `write!` or `println!`. Suggests\n+inlining the `format!` call.\n+\n+### Why is this bad?\n+The recommended code is both shorter and avoids a temporary allocation.\n+\n+### Example\n+```\n+println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+```\n+Use instead:\n+```\n+println!(\"error: something failed at {}\", Location::caller());\n+```\n\\ No newline at end of file"}, {"sha": "ca409ebc7ec2634e5befc04cdda49e710dd6c8dd", "filename": "src/docs/format_push_string.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fformat_push_string.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fformat_push_string.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fformat_push_string.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Detects cases where the result of a `format!` call is\n+appended to an existing `String`.\n+\n+### Why is this bad?\n+Introduces an extra, avoidable heap allocation.\n+\n+### Known problems\n+`format!` returns a `String` but `write!` returns a `Result`.\n+Thus you are forced to ignore the `Err` variant to achieve the same API.\n+\n+While using `write!` in the suggested way should never fail, this isn't necessarily clear to the programmer.\n+\n+### Example\n+```\n+let mut s = String::new();\n+s += &format!(\"0x{:X}\", 1024);\n+s.push_str(&format!(\"0x{:X}\", 1024));\n+```\n+Use instead:\n+```\n+use std::fmt::Write as _; // import without risk of name clashing\n+\n+let mut s = String::new();\n+let _ = write!(s, \"0x{:X}\", 1024);\n+```\n\\ No newline at end of file"}, {"sha": "f3fd275972645c87168c6c141eb4eb95616e8fc9", "filename": "src/docs/from_iter_instead_of_collect.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffrom_iter_instead_of_collect.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffrom_iter_instead_of_collect.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffrom_iter_instead_of_collect.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for `from_iter()` function calls on types that implement the `FromIterator`\n+trait.\n+\n+### Why is this bad?\n+It is recommended style to use collect. See\n+[FromIterator documentation](https://doc.rust-lang.org/std/iter/trait.FromIterator.html)\n+\n+### Example\n+```\n+let five_fives = std::iter::repeat(5).take(5);\n+\n+let v = Vec::from_iter(five_fives);\n+\n+assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+```\n+Use instead:\n+```\n+let five_fives = std::iter::repeat(5).take(5);\n+\n+let v: Vec<i32> = five_fives.collect();\n+\n+assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+```\n\\ No newline at end of file"}, {"sha": "0770bcc42c2704e2a6e0335fd71dd4f5330dd798", "filename": "src/docs/from_over_into.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffrom_over_into.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffrom_over_into.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffrom_over_into.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Searches for implementations of the `Into<..>` trait and suggests to implement `From<..>` instead.\n+\n+### Why is this bad?\n+According the std docs implementing `From<..>` is preferred since it gives you `Into<..>` for free where the reverse isn't true.\n+\n+### Example\n+```\n+struct StringWrapper(String);\n+\n+impl Into<StringWrapper> for String {\n+    fn into(self) -> StringWrapper {\n+        StringWrapper(self)\n+    }\n+}\n+```\n+Use instead:\n+```\n+struct StringWrapper(String);\n+\n+impl From<String> for StringWrapper {\n+    fn from(s: String) -> StringWrapper {\n+        StringWrapper(s)\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "f6f319d3eaa1811b7ef308a538757da595320b1f", "filename": "src/docs/from_str_radix_10.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffrom_str_radix_10.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffrom_str_radix_10.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffrom_str_radix_10.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+\n+Checks for function invocations of the form `primitive::from_str_radix(s, 10)`\n+\n+### Why is this bad?\n+\n+This specific common use case can be rewritten as `s.parse::<primitive>()`\n+(and in most cases, the turbofish can be removed), which reduces code length\n+and complexity.\n+\n+### Known problems\n+\n+This lint may suggest using (&<expression>).parse() instead of <expression>.parse() directly\n+in some cases, which is correct but adds unnecessary complexity to the code.\n+\n+### Example\n+```\n+let input: &str = get_input();\n+let num = u16::from_str_radix(input, 10)?;\n+```\n+Use instead:\n+```\n+let input: &str = get_input();\n+let num: u16 = input.parse()?;\n+```\n\\ No newline at end of file"}, {"sha": "0aa048d273551a3af129d5246c8a8a15a0f087c4", "filename": "src/docs/future_not_send.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffuture_not_send.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Ffuture_not_send.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffuture_not_send.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+This lint requires Future implementations returned from\n+functions and methods to implement the `Send` marker trait. It is mostly\n+used by library authors (public and internal) that target an audience where\n+multithreaded executors are likely to be used for running these Futures.\n+\n+### Why is this bad?\n+A Future implementation captures some state that it\n+needs to eventually produce its final value. When targeting a multithreaded\n+executor (which is the norm on non-embedded devices) this means that this\n+state may need to be transported to other threads, in other words the\n+whole Future needs to implement the `Send` marker trait. If it does not,\n+then the resulting Future cannot be submitted to a thread pool in the\n+end user\u2019s code.\n+\n+Especially for generic functions it can be confusing to leave the\n+discovery of this problem to the end user: the reported error location\n+will be far from its cause and can in many cases not even be fixed without\n+modifying the library where the offending Future implementation is\n+produced.\n+\n+### Example\n+```\n+async fn not_send(bytes: std::rc::Rc<[u8]>) {}\n+```\n+Use instead:\n+```\n+async fn is_send(bytes: std::sync::Arc<[u8]>) {}\n+```\n\\ No newline at end of file"}, {"sha": "c905a737ddf3ff4ff2e27faf5f502b9e69a93c50", "filename": "src/docs/get_first.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fget_first.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fget_first.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fget_first.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for using `x.get(0)` instead of\n+`x.first()`.\n+\n+### Why is this bad?\n+Using `x.first()` is easier to read and has the same\n+result.\n+\n+### Example\n+```\n+let x = vec![2, 3, 5];\n+let first_element = x.get(0);\n+```\n+\n+Use instead:\n+```\n+let x = vec![2, 3, 5];\n+let first_element = x.first();\n+```\n\\ No newline at end of file"}, {"sha": "31c7f269586ab148b329ab5cd6146139d686d2cf", "filename": "src/docs/get_last_with_len.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fget_last_with_len.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fget_last_with_len.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fget_last_with_len.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for using `x.get(x.len() - 1)` instead of\n+`x.last()`.\n+\n+### Why is this bad?\n+Using `x.last()` is easier to read and has the same\n+result.\n+\n+Note that using `x[x.len() - 1]` is semantically different from\n+`x.last()`.  Indexing into the array will panic on out-of-bounds\n+accesses, while `x.get()` and `x.last()` will return `None`.\n+\n+There is another lint (get_unwrap) that covers the case of using\n+`x.get(index).unwrap()` instead of `x[index]`.\n+\n+### Example\n+```\n+let x = vec![2, 3, 5];\n+let last_element = x.get(x.len() - 1);\n+```\n+\n+Use instead:\n+```\n+let x = vec![2, 3, 5];\n+let last_element = x.last();\n+```\n\\ No newline at end of file"}, {"sha": "8defc2224416957864a017e09222554cdf5d1fcc", "filename": "src/docs/get_unwrap.txt", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fget_unwrap.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fget_unwrap.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fget_unwrap.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,30 @@\n+### What it does\n+Checks for use of `.get().unwrap()` (or\n+`.get_mut().unwrap`) on a standard library type which implements `Index`\n+\n+### Why is this bad?\n+Using the Index trait (`[]`) is more clear and more\n+concise.\n+\n+### Known problems\n+Not a replacement for error handling: Using either\n+`.unwrap()` or the Index trait (`[]`) carries the risk of causing a `panic`\n+if the value being accessed is `None`. If the use of `.get().unwrap()` is a\n+temporary placeholder for dealing with the `Option` type, then this does\n+not mitigate the need for error handling. If there is a chance that `.get()`\n+will be `None` in your program, then it is advisable that the `None` case\n+is handled in a future refactor instead of using `.unwrap()` or the Index\n+trait.\n+\n+### Example\n+```\n+let mut some_vec = vec![0, 1, 2, 3];\n+let last = some_vec.get(3).unwrap();\n+*some_vec.get_mut(0).unwrap() = 1;\n+```\n+The correct use would be:\n+```\n+let mut some_vec = vec![0, 1, 2, 3];\n+let last = some_vec[3];\n+some_vec[0] = 1;\n+```\n\\ No newline at end of file"}, {"sha": "a8e40bb43e9d51b2d528bde622560da8a60175c4", "filename": "src/docs/identity_op.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fidentity_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fidentity_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fidentity_op.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,11 @@\n+### What it does\n+Checks for identity operations, e.g., `x + 0`.\n+\n+### Why is this bad?\n+This code can be removed without changing the\n+meaning. So it just obscures what's going on. Delete it mercilessly.\n+\n+### Example\n+```\n+x / 1 + 0 * 1 - 0 | 0;\n+```\n\\ No newline at end of file"}, {"sha": "4d873ade9ace346cfe7303717e3a4e1fe0d4810d", "filename": "src/docs/if_let_mutex.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fif_let_mutex.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fif_let_mutex.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fif_let_mutex.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for `Mutex::lock` calls in `if let` expression\n+with lock calls in any of the else blocks.\n+\n+### Why is this bad?\n+The Mutex lock remains held for the whole\n+`if let ... else` block and deadlocks.\n+\n+### Example\n+```\n+if let Ok(thing) = mutex.lock() {\n+    do_thing();\n+} else {\n+    mutex.lock();\n+}\n+```\n+Should be written\n+```\n+let locked = mutex.lock();\n+if let Ok(thing) = locked {\n+    do_thing(thing);\n+} else {\n+    use_locked(locked);\n+}\n+```\n\\ No newline at end of file"}, {"sha": "0e5ac4ce6bb8047f8174bf2a1107f16646b347ef", "filename": "src/docs/if_not_else.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fif_not_else.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fif_not_else.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fif_not_else.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for usage of `!` or `!=` in an if condition with an\n+else branch.\n+\n+### Why is this bad?\n+Negations reduce the readability of statements.\n+\n+### Example\n+```\n+if !v.is_empty() {\n+    a()\n+} else {\n+    b()\n+}\n+```\n+\n+Could be written:\n+\n+```\n+if v.is_empty() {\n+    b()\n+} else {\n+    a()\n+}\n+```\n\\ No newline at end of file"}, {"sha": "75127016bb8c18d0e8992b000e7436725a8e1ffa", "filename": "src/docs/if_same_then_else.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fif_same_then_else.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fif_same_then_else.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fif_same_then_else.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for `if/else` with the same body as the *then* part\n+and the *else* part.\n+\n+### Why is this bad?\n+This is probably a copy & paste error.\n+\n+### Example\n+```\n+let foo = if \u2026 {\n+    42\n+} else {\n+    42\n+};\n+```\n\\ No newline at end of file"}, {"sha": "13744f920e36237bc28e7fbf5daba8da93b8563e", "filename": "src/docs/if_then_some_else_none.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fif_then_some_else_none.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fif_then_some_else_none.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fif_then_some_else_none.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for if-else that could be written using either `bool::then` or `bool::then_some`.\n+\n+### Why is this bad?\n+Looks a little redundant. Using `bool::then` is more concise and incurs no loss of clarity.\n+For simple calculations and known values, use `bool::then_some`, which is eagerly evaluated\n+in comparison to `bool::then`.\n+\n+### Example\n+```\n+let a = if v.is_empty() {\n+    println!(\"true!\");\n+    Some(42)\n+} else {\n+    None\n+};\n+```\n+\n+Could be written:\n+\n+```\n+let a = v.is_empty().then(|| {\n+    println!(\"true!\");\n+    42\n+});\n+```\n\\ No newline at end of file"}, {"sha": "024ba5df93a63a7a1651bb6075f95ab275493c54", "filename": "src/docs/ifs_same_cond.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fifs_same_cond.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fifs_same_cond.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fifs_same_cond.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for consecutive `if`s with the same condition.\n+\n+### Why is this bad?\n+This is probably a copy & paste error.\n+\n+### Example\n+```\n+if a == b {\n+    \u2026\n+} else if a == b {\n+    \u2026\n+}\n+```\n+\n+Note that this lint ignores all conditions with a function call as it could\n+have side effects:\n+\n+```\n+if foo() {\n+    \u2026\n+} else if foo() { // not linted\n+    \u2026\n+}\n+```\n\\ No newline at end of file"}, {"sha": "f5aa112c52c36b98c8e1f92022001cddb04b8047", "filename": "src/docs/implicit_clone.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fimplicit_clone.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fimplicit_clone.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fimplicit_clone.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for the usage of `_.to_owned()`, `vec.to_vec()`, or similar when calling `_.clone()` would be clearer.\n+\n+### Why is this bad?\n+These methods do the same thing as `_.clone()` but may be confusing as\n+to why we are calling `to_vec` on something that is already a `Vec` or calling `to_owned` on something that is already owned.\n+\n+### Example\n+```\n+let a = vec![1, 2, 3];\n+let b = a.to_vec();\n+let c = a.to_owned();\n+```\n+Use instead:\n+```\n+let a = vec![1, 2, 3];\n+let b = a.clone();\n+let c = a.clone();\n+```\n\\ No newline at end of file"}, {"sha": "0c1f76620f51d5ff79516b1b274b6ae62a6e7ab5", "filename": "src/docs/implicit_hasher.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fimplicit_hasher.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fimplicit_hasher.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fimplicit_hasher.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for public `impl` or `fn` missing generalization\n+over different hashers and implicitly defaulting to the default hashing\n+algorithm (`SipHash`).\n+\n+### Why is this bad?\n+`HashMap` or `HashSet` with custom hashers cannot be\n+used with them.\n+\n+### Known problems\n+Suggestions for replacing constructors can contain\n+false-positives. Also applying suggestions can require modification of other\n+pieces of code, possibly including external crates.\n+\n+### Example\n+```\n+impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { }\n+\n+pub fn foo(map: &mut HashMap<i32, i32>) { }\n+```\n+could be rewritten as\n+```\n+impl<K: Hash + Eq, V, S: BuildHasher> Serialize for HashMap<K, V, S> { }\n+\n+pub fn foo<S: BuildHasher>(map: &mut HashMap<i32, i32, S>) { }\n+```\n\\ No newline at end of file"}, {"sha": "ee65a636b38c5aa4d2640074d7887bc82ee7b4f5", "filename": "src/docs/implicit_return.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fimplicit_return.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fimplicit_return.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fimplicit_return.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for missing return statements at the end of a block.\n+\n+### Why is this bad?\n+Actually omitting the return keyword is idiomatic Rust code. Programmers\n+coming from other languages might prefer the expressiveness of `return`. It's possible to miss\n+the last returning statement because the only difference is a missing `;`. Especially in bigger\n+code with multiple return paths having a `return` keyword makes it easier to find the\n+corresponding statements.\n+\n+### Example\n+```\n+fn foo(x: usize) -> usize {\n+    x\n+}\n+```\n+add return\n+```\n+fn foo(x: usize) -> usize {\n+    return x;\n+}\n+```\n\\ No newline at end of file"}, {"sha": "03b47905a2118dc9e267293da15fed814ddabc42", "filename": "src/docs/implicit_saturating_sub.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fimplicit_saturating_sub.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fimplicit_saturating_sub.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fimplicit_saturating_sub.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for implicit saturating subtraction.\n+\n+### Why is this bad?\n+Simplicity and readability. Instead we can easily use an builtin function.\n+\n+### Example\n+```\n+let mut i: u32 = end - start;\n+\n+if i != 0 {\n+    i -= 1;\n+}\n+```\n+\n+Use instead:\n+```\n+let mut i: u32 = end - start;\n+\n+i = i.saturating_sub(1);\n+```\n\\ No newline at end of file"}, {"sha": "e84d81cea98e0b70abb9cfb7e93e7c95d526bf28", "filename": "src/docs/imprecise_flops.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fimprecise_flops.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fimprecise_flops.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fimprecise_flops.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Looks for floating-point expressions that\n+can be expressed using built-in methods to improve accuracy\n+at the cost of performance.\n+\n+### Why is this bad?\n+Negatively impacts accuracy.\n+\n+### Example\n+```\n+let a = 3f32;\n+let _ = a.powf(1.0 / 3.0);\n+let _ = (1.0 + a).ln();\n+let _ = a.exp() - 1.0;\n+```\n+\n+Use instead:\n+```\n+let a = 3f32;\n+let _ = a.cbrt();\n+let _ = a.ln_1p();\n+let _ = a.exp_m1();\n+```\n\\ No newline at end of file"}, {"sha": "aa0b072de1c4080303ccfe7f86ae3e07e3cde095", "filename": "src/docs/inconsistent_digit_grouping.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finconsistent_digit_grouping.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finconsistent_digit_grouping.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finconsistent_digit_grouping.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Warns if an integral or floating-point constant is\n+grouped inconsistently with underscores.\n+\n+### Why is this bad?\n+Readers may incorrectly interpret inconsistently\n+grouped digits.\n+\n+### Example\n+```\n+618_64_9189_73_511\n+```\n+\n+Use instead:\n+```\n+61_864_918_973_511\n+```\n\\ No newline at end of file"}, {"sha": "eb682109a54ee74cec3f50cf35b13600f8c534a2", "filename": "src/docs/inconsistent_struct_constructor.txt", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finconsistent_struct_constructor.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finconsistent_struct_constructor.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finconsistent_struct_constructor.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,40 @@\n+### What it does\n+Checks for struct constructors where all fields are shorthand and\n+the order of the field init shorthand in the constructor is inconsistent\n+with the order in the struct definition.\n+\n+### Why is this bad?\n+Since the order of fields in a constructor doesn't affect the\n+resulted instance as the below example indicates,\n+\n+```\n+#[derive(Debug, PartialEq, Eq)]\n+struct Foo {\n+    x: i32,\n+    y: i32,\n+}\n+let x = 1;\n+let y = 2;\n+\n+// This assertion never fails:\n+assert_eq!(Foo { x, y }, Foo { y, x });\n+```\n+\n+inconsistent order can be confusing and decreases readability and consistency.\n+\n+### Example\n+```\n+struct Foo {\n+    x: i32,\n+    y: i32,\n+}\n+let x = 1;\n+let y = 2;\n+\n+Foo { y, x };\n+```\n+\n+Use instead:\n+```\n+Foo { x, y };\n+```\n\\ No newline at end of file"}, {"sha": "8a7d52761af816657c32bee2884c333b81b153e1", "filename": "src/docs/index_refutable_slice.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Findex_refutable_slice.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Findex_refutable_slice.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Findex_refutable_slice.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+The lint checks for slice bindings in patterns that are only used to\n+access individual slice values.\n+\n+### Why is this bad?\n+Accessing slice values using indices can lead to panics. Using refutable\n+patterns can avoid these. Binding to individual values also improves the\n+readability as they can be named.\n+\n+### Limitations\n+This lint currently only checks for immutable access inside `if let`\n+patterns.\n+\n+### Example\n+```\n+let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+\n+if let Some(slice) = slice {\n+    println!(\"{}\", slice[0]);\n+}\n+```\n+Use instead:\n+```\n+let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+\n+if let Some(&[first, ..]) = slice {\n+    println!(\"{}\", first);\n+}\n+```\n\\ No newline at end of file"}, {"sha": "76ca6ed318b38b88ecbe7320e2c9c5d7eff761c3", "filename": "src/docs/indexing_slicing.txt", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Findexing_slicing.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Findexing_slicing.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Findexing_slicing.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,33 @@\n+### What it does\n+Checks for usage of indexing or slicing. Arrays are special cases, this lint\n+does report on arrays if we can tell that slicing operations are in bounds and does not\n+lint on constant `usize` indexing on arrays because that is handled by rustc's `const_err` lint.\n+\n+### Why is this bad?\n+Indexing and slicing can panic at runtime and there are\n+safe alternatives.\n+\n+### Example\n+```\n+// Vector\n+let x = vec![0; 5];\n+\n+x[2];\n+&x[2..100];\n+\n+// Array\n+let y = [0, 1, 2, 3];\n+\n+&y[10..100];\n+&y[10..];\n+```\n+\n+Use instead:\n+```\n+\n+x.get(2);\n+x.get(2..100);\n+\n+y.get(10);\n+y.get(10..100);\n+```\n\\ No newline at end of file"}, {"sha": "f6e7ef556215b891e29665cb7f080ed4cdab315c", "filename": "src/docs/ineffective_bit_mask.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fineffective_bit_mask.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fineffective_bit_mask.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fineffective_bit_mask.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for bit masks in comparisons which can be removed\n+without changing the outcome. The basic structure can be seen in the\n+following table:\n+\n+|Comparison| Bit Op   |Example     |equals |\n+|----------|----------|------------|-------|\n+|`>` / `<=`|`\\|` / `^`|`x \\| 2 > 3`|`x > 3`|\n+|`<` / `>=`|`\\|` / `^`|`x ^ 1 < 4` |`x < 4`|\n+\n+### Why is this bad?\n+Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\n+but still a bit misleading, because the bit mask is ineffective.\n+\n+### Known problems\n+False negatives: This lint will only match instances\n+where we have figured out the math (which is for a power-of-two compared\n+value). This means things like `x | 1 >= 7` (which would be better written\n+as `x >= 6`) will not be reported (but bit masks like this are fairly\n+uncommon).\n+\n+### Example\n+```\n+if (x | 1 > 3) {  }\n+```\n\\ No newline at end of file"}, {"sha": "f7061d1ce7b082c10f14302b673f5b5d783c1669", "filename": "src/docs/inefficient_to_string.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finefficient_to_string.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finefficient_to_string.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finefficient_to_string.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for usage of `.to_string()` on an `&&T` where\n+`T` implements `ToString` directly (like `&&str` or `&&String`).\n+\n+### Why is this bad?\n+This bypasses the specialized implementation of\n+`ToString` and instead goes through the more expensive string formatting\n+facilities.\n+\n+### Example\n+```\n+// Generic implementation for `T: Display` is used (slow)\n+[\"foo\", \"bar\"].iter().map(|s| s.to_string());\n+\n+// OK, the specialized impl is used\n+[\"foo\", \"bar\"].iter().map(|&s| s.to_string());\n+```\n\\ No newline at end of file"}, {"sha": "4b5d3c4ba6c40c1b0657fa0195b977bacdb09453", "filename": "src/docs/infallible_destructuring_match.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finfallible_destructuring_match.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finfallible_destructuring_match.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finfallible_destructuring_match.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Checks for matches being used to destructure a single-variant enum\n+or tuple struct where a `let` will suffice.\n+\n+### Why is this bad?\n+Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n+\n+### Example\n+```\n+enum Wrapper {\n+    Data(i32),\n+}\n+\n+let wrapper = Wrapper::Data(42);\n+\n+let data = match wrapper {\n+    Wrapper::Data(i) => i,\n+};\n+```\n+\n+The correct use would be:\n+```\n+enum Wrapper {\n+    Data(i32),\n+}\n+\n+let wrapper = Wrapper::Data(42);\n+let Wrapper::Data(data) = wrapper;\n+```\n\\ No newline at end of file"}, {"sha": "8a22fabc5492c4f87689a75dbe149dafba04951a", "filename": "src/docs/infinite_iter.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finfinite_iter.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finfinite_iter.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finfinite_iter.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for iteration that is guaranteed to be infinite.\n+\n+### Why is this bad?\n+While there may be places where this is acceptable\n+(e.g., in event streams), in most cases this is simply an error.\n+\n+### Example\n+```\n+use std::iter;\n+\n+iter::repeat(1_u8).collect::<Vec<_>>();\n+```\n\\ No newline at end of file"}, {"sha": "b18e600e9e67b056254eb92a07fec2dd9bd34faa", "filename": "src/docs/inherent_to_string.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finherent_to_string.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finherent_to_string.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finherent_to_string.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Checks for the definition of inherent methods with a signature of `to_string(&self) -> String`.\n+\n+### Why is this bad?\n+This method is also implicitly defined if a type implements the `Display` trait. As the functionality of `Display` is much more versatile, it should be preferred.\n+\n+### Example\n+```\n+pub struct A;\n+\n+impl A {\n+    pub fn to_string(&self) -> String {\n+        \"I am A\".to_string()\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+use std::fmt;\n+\n+pub struct A;\n+\n+impl fmt::Display for A {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"I am A\")\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "a4bd0b622c4f5833f59494a7999cd2d44d64a301", "filename": "src/docs/inherent_to_string_shadow_display.txt", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finherent_to_string_shadow_display.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finherent_to_string_shadow_display.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finherent_to_string_shadow_display.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,37 @@\n+### What it does\n+Checks for the definition of inherent methods with a signature of `to_string(&self) -> String` and if the type implementing this method also implements the `Display` trait.\n+\n+### Why is this bad?\n+This method is also implicitly defined if a type implements the `Display` trait. The less versatile inherent method will then shadow the implementation introduced by `Display`.\n+\n+### Example\n+```\n+use std::fmt;\n+\n+pub struct A;\n+\n+impl A {\n+    pub fn to_string(&self) -> String {\n+        \"I am A\".to_string()\n+    }\n+}\n+\n+impl fmt::Display for A {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"I am A, too\")\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+use std::fmt;\n+\n+pub struct A;\n+\n+impl fmt::Display for A {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"I am A\")\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "ba40af6a5fa555df8eb9843ed1bc9202711ad1e0", "filename": "src/docs/init_numbered_fields.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finit_numbered_fields.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finit_numbered_fields.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finit_numbered_fields.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for tuple structs initialized with field syntax.\n+It will however not lint if a base initializer is present.\n+The lint will also ignore code in macros.\n+\n+### Why is this bad?\n+This may be confusing to the uninitiated and adds no\n+benefit as opposed to tuple initializers\n+\n+### Example\n+```\n+struct TupleStruct(u8, u16);\n+\n+let _ = TupleStruct {\n+    0: 1,\n+    1: 23,\n+};\n+\n+// should be written as\n+let base = TupleStruct(1, 23);\n+\n+// This is OK however\n+let _ = TupleStruct { 0: 42, ..base };\n+```\n\\ No newline at end of file"}, {"sha": "7721da4c4cc71a26c26b6db49ef11516610c416c", "filename": "src/docs/inline_always.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finline_always.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finline_always.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finline_always.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for items annotated with `#[inline(always)]`,\n+unless the annotated function is empty or simply panics.\n+\n+### Why is this bad?\n+While there are valid uses of this annotation (and once\n+you know when to use it, by all means `allow` this lint), it's a common\n+newbie-mistake to pepper one's code with it.\n+\n+As a rule of thumb, before slapping `#[inline(always)]` on a function,\n+measure if that additional function call really affects your runtime profile\n+sufficiently to make up for the increase in compile time.\n+\n+### Known problems\n+False positives, big time. This lint is meant to be\n+deactivated by everyone doing serious performance work. This means having\n+done the measurement.\n+\n+### Example\n+```\n+#[inline(always)]\n+fn not_quite_hot_code(..) { ... }\n+```\n\\ No newline at end of file"}, {"sha": "8eb49d122d89962e0e09afa804554b4eb94e7552", "filename": "src/docs/inline_asm_x86_att_syntax.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finline_asm_x86_att_syntax.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finline_asm_x86_att_syntax.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finline_asm_x86_att_syntax.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of AT&T x86 assembly syntax.\n+\n+### Why is this bad?\n+The lint has been enabled to indicate a preference\n+for Intel x86 assembly syntax.\n+\n+### Example\n+\n+```\n+asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n+```\n+Use instead:\n+```\n+asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n+```\n\\ No newline at end of file"}, {"sha": "5aa22c8ed235780c05515903fa8119d0e5e2465d", "filename": "src/docs/inline_asm_x86_intel_syntax.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finline_asm_x86_intel_syntax.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finline_asm_x86_intel_syntax.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finline_asm_x86_intel_syntax.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of Intel x86 assembly syntax.\n+\n+### Why is this bad?\n+The lint has been enabled to indicate a preference\n+for AT&T x86 assembly syntax.\n+\n+### Example\n+\n+```\n+asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n+```\n+Use instead:\n+```\n+asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n+```\n\\ No newline at end of file"}, {"sha": "127c161aaa25063e2f3f7fc89a602a2cb743c810", "filename": "src/docs/inline_fn_without_body.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finline_fn_without_body.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finline_fn_without_body.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finline_fn_without_body.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks for `#[inline]` on trait methods without bodies\n+\n+### Why is this bad?\n+Only implementations of trait methods may be inlined.\n+The inline attribute is ignored for trait methods without bodies.\n+\n+### Example\n+```\n+trait Animal {\n+    #[inline]\n+    fn name(&self) -> &'static str;\n+}\n+```\n\\ No newline at end of file"}, {"sha": "01a46d6c451f4536989dd60becd9d42536cbfa96", "filename": "src/docs/inspect_for_each.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finspect_for_each.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finspect_for_each.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finspect_for_each.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for usage of `inspect().for_each()`.\n+\n+### Why is this bad?\n+It is the same as performing the computation\n+inside `inspect` at the beginning of the closure in `for_each`.\n+\n+### Example\n+```\n+[1,2,3,4,5].iter()\n+.inspect(|&x| println!(\"inspect the number: {}\", x))\n+.for_each(|&x| {\n+    assert!(x >= 0);\n+});\n+```\n+Can be written as\n+```\n+[1,2,3,4,5].iter()\n+.for_each(|&x| {\n+    println!(\"inspect the number: {}\", x);\n+    assert!(x >= 0);\n+});\n+```\n\\ No newline at end of file"}, {"sha": "1b68f3eeb64b44f709db8fdb51c607ebf4552ca1", "filename": "src/docs/int_plus_one.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fint_plus_one.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fint_plus_one.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fint_plus_one.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block\n+\n+### Why is this bad?\n+Readability -- better to use `> y` instead of `>= y + 1`.\n+\n+### Example\n+```\n+if x >= y + 1 {}\n+```\n+\n+Use instead:\n+```\n+if x > y {}\n+```\n\\ No newline at end of file"}, {"sha": "ea57a2ef97bf5e0ca5c61aae77d878c22d41ed28", "filename": "src/docs/integer_arithmetic.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finteger_arithmetic.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finteger_arithmetic.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finteger_arithmetic.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for integer arithmetic operations which could overflow or panic.\n+\n+Specifically, checks for any operators (`+`, `-`, `*`, `<<`, etc) which are capable\n+of overflowing according to the [Rust\n+Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n+or which can panic (`/`, `%`). No bounds analysis or sophisticated reasoning is\n+attempted.\n+\n+### Why is this bad?\n+Integer overflow will trigger a panic in debug builds or will wrap in\n+release mode. Division by zero will cause a panic in either mode. In some applications one\n+wants explicitly checked, wrapping or saturating arithmetic.\n+\n+### Example\n+```\n+a + 1;\n+```\n\\ No newline at end of file"}, {"sha": "f6d3349810ed86f7e0b7b07fa2a0d61e6b450250", "filename": "src/docs/integer_division.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finteger_division.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finteger_division.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finteger_division.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for division of integers\n+\n+### Why is this bad?\n+When outside of some very specific algorithms,\n+integer division is very often a mistake because it discards the\n+remainder.\n+\n+### Example\n+```\n+let x = 3 / 2;\n+println!(\"{}\", x);\n+```\n+\n+Use instead:\n+```\n+let x = 3f32 / 2f32;\n+println!(\"{}\", x);\n+```\n\\ No newline at end of file"}, {"sha": "acb6bd474ebf31bbc3d1954d9f293d261d43b7ad", "filename": "src/docs/into_iter_on_ref.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finto_iter_on_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finto_iter_on_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finto_iter_on_ref.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for `into_iter` calls on references which should be replaced by `iter`\n+or `iter_mut`.\n+\n+### Why is this bad?\n+Readability. Calling `into_iter` on a reference will not move out its\n+content into the resulting iterator, which is confusing. It is better just call `iter` or\n+`iter_mut` directly.\n+\n+### Example\n+```\n+(&vec).into_iter();\n+```\n+\n+Use instead:\n+```\n+(&vec).iter();\n+```\n\\ No newline at end of file"}, {"sha": "6fb3fa3f83d6672fa5cc8f84b418b2a0a484b42f", "filename": "src/docs/invalid_null_ptr_usage.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finvalid_null_ptr_usage.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finvalid_null_ptr_usage.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finvalid_null_ptr_usage.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+This lint checks for invalid usages of `ptr::null`.\n+\n+### Why is this bad?\n+This causes undefined behavior.\n+\n+### Example\n+```\n+// Undefined behavior\n+unsafe { std::slice::from_raw_parts(ptr::null(), 0); }\n+```\n+\n+Use instead:\n+```\n+unsafe { std::slice::from_raw_parts(NonNull::dangling().as_ptr(), 0); }\n+```\n\\ No newline at end of file"}, {"sha": "6c9969b6e1a335a8672de9d225ccf60d497d3308", "filename": "src/docs/invalid_regex.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finvalid_regex.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finvalid_regex.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finvalid_regex.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks [regex](https://crates.io/crates/regex) creation\n+(with `Regex::new`, `RegexBuilder::new`, or `RegexSet::new`) for correct\n+regex syntax.\n+\n+### Why is this bad?\n+This will lead to a runtime panic.\n+\n+### Example\n+```\n+Regex::new(\"(\")\n+```\n\\ No newline at end of file"}, {"sha": "77cb033080372924a3e379db7da01212cc265c6e", "filename": "src/docs/invalid_upcast_comparisons.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finvalid_upcast_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finvalid_upcast_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finvalid_upcast_comparisons.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for comparisons where the relation is always either\n+true or false, but where one side has been upcast so that the comparison is\n+necessary. Only integer types are checked.\n+\n+### Why is this bad?\n+An expression like `let x : u8 = ...; (x as u32) > 300`\n+will mistakenly imply that it is possible for `x` to be outside the range of\n+`u8`.\n+\n+### Known problems\n+https://github.com/rust-lang/rust-clippy/issues/886\n+\n+### Example\n+```\n+let x: u8 = 1;\n+(x as u32) > 300;\n+```\n\\ No newline at end of file"}, {"sha": "afb5acbe9c51cf079e6498acd2bba609712a239b", "filename": "src/docs/invalid_utf8_in_unchecked.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finvalid_utf8_in_unchecked.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finvalid_utf8_in_unchecked.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finvalid_utf8_in_unchecked.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks for `std::str::from_utf8_unchecked` with an invalid UTF-8 literal\n+\n+### Why is this bad?\n+Creating such a `str` would result in undefined behavior\n+\n+### Example\n+```\n+unsafe {\n+    std::str::from_utf8_unchecked(b\"cl\\x82ippy\");\n+}\n+```\n\\ No newline at end of file"}, {"sha": "3dda380911f91589d5b496967bb64b21badf592d", "filename": "src/docs/invisible_characters.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finvisible_characters.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Finvisible_characters.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finvisible_characters.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,10 @@\n+### What it does\n+Checks for invisible Unicode characters in the code.\n+\n+### Why is this bad?\n+Having an invisible character in the code makes for all\n+sorts of April fools, but otherwise is very much frowned upon.\n+\n+### Example\n+You don't see it, but there may be a zero-width space or soft hyphen\n+some\u00adwhere in this text.\n\\ No newline at end of file"}, {"sha": "9f11cf43054feddbe543d066c02597c7f392d233", "filename": "src/docs/is_digit_ascii_radix.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fis_digit_ascii_radix.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fis_digit_ascii_radix.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fis_digit_ascii_radix.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Finds usages of [`char::is_digit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_digit) that\n+can be replaced with [`is_ascii_digit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_digit) or\n+[`is_ascii_hexdigit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_hexdigit).\n+\n+### Why is this bad?\n+`is_digit(..)` is slower and requires specifying the radix.\n+\n+### Example\n+```\n+let c: char = '6';\n+c.is_digit(10);\n+c.is_digit(16);\n+```\n+Use instead:\n+```\n+let c: char = '6';\n+c.is_ascii_digit();\n+c.is_ascii_hexdigit();\n+```\n\\ No newline at end of file"}, {"sha": "6fdfff50d20e40844dfd35f78c55b945b9af6661", "filename": "src/docs/items_after_statements.txt", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fitems_after_statements.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fitems_after_statements.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fitems_after_statements.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,37 @@\n+### What it does\n+Checks for items declared after some statement in a block.\n+\n+### Why is this bad?\n+Items live for the entire scope they are declared\n+in. But statements are processed in order. This might cause confusion as\n+it's hard to figure out which item is meant in a statement.\n+\n+### Example\n+```\n+fn foo() {\n+    println!(\"cake\");\n+}\n+\n+fn main() {\n+    foo(); // prints \"foo\"\n+    fn foo() {\n+        println!(\"foo\");\n+    }\n+    foo(); // prints \"foo\"\n+}\n+```\n+\n+Use instead:\n+```\n+fn foo() {\n+    println!(\"cake\");\n+}\n+\n+fn main() {\n+    fn foo() {\n+        println!(\"foo\");\n+    }\n+    foo(); // prints \"foo\"\n+    foo(); // prints \"foo\"\n+}\n+```\n\\ No newline at end of file"}, {"sha": "90dc9ebb40f0b595825eb718cd380c1603613f69", "filename": "src/docs/iter_cloned_collect.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_cloned_collect.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_cloned_collect.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_cloned_collect.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for the use of `.cloned().collect()` on slice to\n+create a `Vec`.\n+\n+### Why is this bad?\n+`.to_vec()` is clearer\n+\n+### Example\n+```\n+let s = [1, 2, 3, 4, 5];\n+let s2: Vec<isize> = s[..].iter().cloned().collect();\n+```\n+The better use would be:\n+```\n+let s = [1, 2, 3, 4, 5];\n+let s2: Vec<isize> = s.to_vec();\n+```\n\\ No newline at end of file"}, {"sha": "f3db4a26c2997f42ab673bf3112c6e1a448031f6", "filename": "src/docs/iter_count.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_count.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_count.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_count.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for the use of `.iter().count()`.\n+\n+### Why is this bad?\n+`.len()` is more efficient and more\n+readable.\n+\n+### Example\n+```\n+let some_vec = vec![0, 1, 2, 3];\n+\n+some_vec.iter().count();\n+&some_vec[..].iter().count();\n+```\n+\n+Use instead:\n+```\n+let some_vec = vec![0, 1, 2, 3];\n+\n+some_vec.len();\n+&some_vec[..].len();\n+```\n\\ No newline at end of file"}, {"sha": "b33eb39d6e1d37529ed4969f94d4cf2c107d5042", "filename": "src/docs/iter_next_loop.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_next_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_next_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_next_loop.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for loops on `x.next()`.\n+\n+### Why is this bad?\n+`next()` returns either `Some(value)` if there was a\n+value, or `None` otherwise. The insidious thing is that `Option<_>`\n+implements `IntoIterator`, so that possibly one value will be iterated,\n+leading to some hard to find bugs. No one will want to write such code\n+[except to win an Underhanded Rust\n+Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n+\n+### Example\n+```\n+for x in y.next() {\n+    ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "1cea25eaf3017a7d5f6b8024ac886cad194182e2", "filename": "src/docs/iter_next_slice.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_next_slice.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_next_slice.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_next_slice.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of `iter().next()` on a Slice or an Array\n+\n+### Why is this bad?\n+These can be shortened into `.get()`\n+\n+### Example\n+```\n+a[2..].iter().next();\n+b.iter().next();\n+```\n+should be written as:\n+```\n+a.get(2);\n+b.get(0);\n+```\n\\ No newline at end of file"}, {"sha": "0ca862910a6f072a8199956be2a29db0ecfdc13d", "filename": "src/docs/iter_not_returning_iterator.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_not_returning_iterator.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_not_returning_iterator.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_not_returning_iterator.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Detects methods named `iter` or `iter_mut` that do not have a return type that implements `Iterator`.\n+\n+### Why is this bad?\n+Methods named `iter` or `iter_mut` conventionally return an `Iterator`.\n+\n+### Example\n+```\n+// `String` does not implement `Iterator`\n+struct Data {}\n+impl Data {\n+    fn iter(&self) -> String {\n+        todo!()\n+    }\n+}\n+```\n+Use instead:\n+```\n+use std::str::Chars;\n+struct Data {}\n+impl Data {\n+   fn iter(&self) -> Chars<'static> {\n+       todo!()\n+   }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "3d67d583ffde387ca67137aec43d074eeccdfb92", "filename": "src/docs/iter_nth.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_nth.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_nth.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_nth.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for use of `.iter().nth()` (and the related\n+`.iter_mut().nth()`) on standard library types with *O*(1) element access.\n+\n+### Why is this bad?\n+`.get()` and `.get_mut()` are more efficient and more\n+readable.\n+\n+### Example\n+```\n+let some_vec = vec![0, 1, 2, 3];\n+let bad_vec = some_vec.iter().nth(3);\n+let bad_slice = &some_vec[..].iter().nth(3);\n+```\n+The correct use would be:\n+```\n+let some_vec = vec![0, 1, 2, 3];\n+let bad_vec = some_vec.get(3);\n+let bad_slice = &some_vec[..].get(3);\n+```\n\\ No newline at end of file"}, {"sha": "8efe47a16a100ab2b193b58f1a7d52747b3a2e57", "filename": "src/docs/iter_nth_zero.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_nth_zero.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_nth_zero.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_nth_zero.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for the use of `iter.nth(0)`.\n+\n+### Why is this bad?\n+`iter.next()` is equivalent to\n+`iter.nth(0)`, as they both consume the next element,\n+ but is more readable.\n+\n+### Example\n+```\n+let x = s.iter().nth(0);\n+```\n+\n+Use instead:\n+```\n+let x = s.iter().next();\n+```\n\\ No newline at end of file"}, {"sha": "87c4ec12afae71b4592015e135452701cf64f0c1", "filename": "src/docs/iter_on_empty_collections.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_on_empty_collections.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_on_empty_collections.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_on_empty_collections.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+\n+Checks for calls to `iter`, `iter_mut` or `into_iter` on empty collections\n+\n+### Why is this bad?\n+\n+It is simpler to use the empty function from the standard library:\n+\n+### Example\n+\n+```\n+use std::{slice, option};\n+let a: slice::Iter<i32> = [].iter();\n+let f: option::IntoIter<i32> = None.into_iter();\n+```\n+Use instead:\n+```\n+use std::iter;\n+let a: iter::Empty<i32> = iter::empty();\n+let b: iter::Empty<i32> = iter::empty();\n+```\n+\n+### Known problems\n+\n+The type of the resulting iterator might become incompatible with its usage\n\\ No newline at end of file"}, {"sha": "d0388f25d045e709a953550443b5fe6feac8a119", "filename": "src/docs/iter_on_single_items.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_on_single_items.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_on_single_items.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_on_single_items.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+\n+Checks for calls to `iter`, `iter_mut` or `into_iter` on collections containing a single item\n+\n+### Why is this bad?\n+\n+It is simpler to use the once function from the standard library:\n+\n+### Example\n+\n+```\n+let a = [123].iter();\n+let b = Some(123).into_iter();\n+```\n+Use instead:\n+```\n+use std::iter;\n+let a = iter::once(&123);\n+let b = iter::once(123);\n+```\n+\n+### Known problems\n+\n+The type of the resulting iterator might become incompatible with its usage\n\\ No newline at end of file"}, {"sha": "2f902a0c2db4d1c6295ef59e3a05f977eb07377e", "filename": "src/docs/iter_overeager_cloned.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_overeager_cloned.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_overeager_cloned.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_overeager_cloned.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for usage of `_.cloned().<func>()` where call to `.cloned()` can be postponed.\n+\n+### Why is this bad?\n+It's often inefficient to clone all elements of an iterator, when eventually, only some\n+of them will be consumed.\n+\n+### Known Problems\n+This `lint` removes the side of effect of cloning items in the iterator.\n+A code that relies on that side-effect could fail.\n+\n+### Examples\n+```\n+vec.iter().cloned().take(10);\n+vec.iter().cloned().last();\n+```\n+\n+Use instead:\n+```\n+vec.iter().take(10).cloned();\n+vec.iter().last().cloned();\n+```\n\\ No newline at end of file"}, {"sha": "da226b041cf23aaa89e417a05505015fc472a1e8", "filename": "src/docs/iter_skip_next.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_skip_next.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_skip_next.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_skip_next.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for use of `.skip(x).next()` on iterators.\n+\n+### Why is this bad?\n+`.nth(x)` is cleaner\n+\n+### Example\n+```\n+let some_vec = vec![0, 1, 2, 3];\n+let bad_vec = some_vec.iter().skip(3).next();\n+let bad_slice = &some_vec[..].iter().skip(3).next();\n+```\n+The correct use would be:\n+```\n+let some_vec = vec![0, 1, 2, 3];\n+let bad_vec = some_vec.iter().nth(3);\n+let bad_slice = &some_vec[..].iter().nth(3);\n+```\n\\ No newline at end of file"}, {"sha": "2c52b99f7a5c5aceb533a8c43ba3594054767a20", "filename": "src/docs/iter_with_drain.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_with_drain.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiter_with_drain.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_with_drain.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for use of `.drain(..)` on `Vec` and `VecDeque` for iteration.\n+\n+### Why is this bad?\n+`.into_iter()` is simpler with better performance.\n+\n+### Example\n+```\n+let mut foo = vec![0, 1, 2, 3];\n+let bar: HashSet<usize> = foo.drain(..).collect();\n+```\n+Use instead:\n+```\n+let foo = vec![0, 1, 2, 3];\n+let bar: HashSet<usize> = foo.into_iter().collect();\n+```\n\\ No newline at end of file"}, {"sha": "73ecc99acfcbcb53b8328d4f8f4ce551313dc9d1", "filename": "src/docs/iterator_step_by_zero.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiterator_step_by_zero.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fiterator_step_by_zero.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiterator_step_by_zero.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for calling `.step_by(0)` on iterators which panics.\n+\n+### Why is this bad?\n+This very much looks like an oversight. Use `panic!()` instead if you\n+actually intend to panic.\n+\n+### Example\n+```\n+for x in (0..100).step_by(0) {\n+    //..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "a8790bcf25be6175547827c0908cd0bce21616ad", "filename": "src/docs/just_underscores_and_digits.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fjust_underscores_and_digits.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fjust_underscores_and_digits.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fjust_underscores_and_digits.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks if you have variables whose name consists of just\n+underscores and digits.\n+\n+### Why is this bad?\n+It's hard to memorize what a variable means without a\n+descriptive name.\n+\n+### Example\n+```\n+let _1 = 1;\n+let ___1 = 1;\n+let __1___2 = 11;\n+```\n\\ No newline at end of file"}, {"sha": "71f67854f2a1afcd3dc1bb0e961000ca3059e8f3", "filename": "src/docs/large_const_arrays.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flarge_const_arrays.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flarge_const_arrays.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_const_arrays.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for large `const` arrays that should\n+be defined as `static` instead.\n+\n+### Why is this bad?\n+Performance: const variables are inlined upon use.\n+Static items result in only one instance and has a fixed location in memory.\n+\n+### Example\n+```\n+pub const a = [0u32; 1_000_000];\n+```\n+\n+Use instead:\n+```\n+pub static a = [0u32; 1_000_000];\n+```\n\\ No newline at end of file"}, {"sha": "f60b19345af44e86e6f74564c80d17d654f9311b", "filename": "src/docs/large_digit_groups.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flarge_digit_groups.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flarge_digit_groups.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_digit_groups.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Warns if the digits of an integral or floating-point\n+constant are grouped into groups that\n+are too large.\n+\n+### Why is this bad?\n+Negatively impacts readability.\n+\n+### Example\n+```\n+let x: u64 = 6186491_8973511;\n+```\n\\ No newline at end of file"}, {"sha": "787e8e027e12baa4fa01818527e79a77b59cdd9c", "filename": "src/docs/large_enum_variant.txt", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flarge_enum_variant.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flarge_enum_variant.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_enum_variant.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,40 @@\n+### What it does\n+Checks for large size differences between variants on\n+`enum`s.\n+\n+### Why is this bad?\n+Enum size is bounded by the largest variant. Having a\n+large variant can penalize the memory layout of that enum.\n+\n+### Known problems\n+This lint obviously cannot take the distribution of\n+variants in your running program into account. It is possible that the\n+smaller variants make up less than 1% of all instances, in which case\n+the overhead is negligible and the boxing is counter-productive. Always\n+measure the change this lint suggests.\n+\n+For types that implement `Copy`, the suggestion to `Box` a variant's\n+data would require removing the trait impl. The types can of course\n+still be `Clone`, but that is worse ergonomically. Depending on the\n+use case it may be possible to store the large data in an auxiliary\n+structure (e.g. Arena or ECS).\n+\n+The lint will ignore generic types if the layout depends on the\n+generics, even if the size difference will be large anyway.\n+\n+### Example\n+```\n+enum Test {\n+    A(i32),\n+    B([i32; 8000]),\n+}\n+```\n+\n+Use instead:\n+```\n+// Possibly better\n+enum Test2 {\n+    A(i32),\n+    B(Box<[i32; 8000]>),\n+}\n+```\n\\ No newline at end of file"}, {"sha": "b2a54bd2eb5ca0f8f5ab0ffdc43e25e89ea58acb", "filename": "src/docs/large_include_file.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flarge_include_file.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flarge_include_file.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_include_file.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for the inclusion of large files via `include_bytes!()`\n+and `include_str!()`\n+\n+### Why is this bad?\n+Including large files can increase the size of the binary\n+\n+### Example\n+```\n+let included_str = include_str!(\"very_large_file.txt\");\n+let included_bytes = include_bytes!(\"very_large_file.txt\");\n+```\n+\n+Use instead:\n+```\n+use std::fs;\n+\n+// You can load the file at runtime\n+let string = fs::read_to_string(\"very_large_file.txt\")?;\n+let bytes = fs::read(\"very_large_file.txt\")?;\n+```\n\\ No newline at end of file"}, {"sha": "4a6f34785b0ef802748ff039f44578ff4dda2ea4", "filename": "src/docs/large_stack_arrays.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flarge_stack_arrays.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flarge_stack_arrays.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_stack_arrays.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,10 @@\n+### What it does\n+Checks for local arrays that may be too large.\n+\n+### Why is this bad?\n+Large local arrays may cause stack overflow.\n+\n+### Example\n+```\n+let a = [0u32; 1_000_000];\n+```\n\\ No newline at end of file"}, {"sha": "bca07f3ac61bbe56b2916ba79e839cad046d9b4a", "filename": "src/docs/large_types_passed_by_value.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flarge_types_passed_by_value.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flarge_types_passed_by_value.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_types_passed_by_value.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for functions taking arguments by value, where\n+the argument type is `Copy` and large enough to be worth considering\n+passing by reference. Does not trigger if the function is being exported,\n+because that might induce API breakage, if the parameter is declared as mutable,\n+or if the argument is a `self`.\n+\n+### Why is this bad?\n+Arguments passed by value might result in an unnecessary\n+shallow copy, taking up more space in the stack and requiring a call to\n+`memcpy`, which can be expensive.\n+\n+### Example\n+```\n+#[derive(Clone, Copy)]\n+struct TooLarge([u8; 2048]);\n+\n+fn foo(v: TooLarge) {}\n+```\n+\n+Use instead:\n+```\n+fn foo(v: &TooLarge) {}\n+```\n\\ No newline at end of file"}, {"sha": "47a2e8575228542722423914d378f5d4cdbe436f", "filename": "src/docs/len_without_is_empty.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flen_without_is_empty.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flen_without_is_empty.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flen_without_is_empty.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for items that implement `.len()` but not\n+`.is_empty()`.\n+\n+### Why is this bad?\n+It is good custom to have both methods, because for\n+some data structures, asking about the length will be a costly operation,\n+whereas `.is_empty()` can usually answer in constant time. Also it used to\n+lead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that\n+lint will ignore such entities.\n+\n+### Example\n+```\n+impl X {\n+    pub fn len(&self) -> usize {\n+        ..\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "664124bd391dfc719ed24e3220e7ee9407e8414d", "filename": "src/docs/len_zero.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flen_zero.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flen_zero.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flen_zero.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for getting the length of something via `.len()`\n+just to compare to zero, and suggests using `.is_empty()` where applicable.\n+\n+### Why is this bad?\n+Some structures can answer `.is_empty()` much faster\n+than calculating their length. So it is good to get into the habit of using\n+`.is_empty()`, and having it is cheap.\n+Besides, it makes the intent clearer than a manual comparison in some contexts.\n+\n+### Example\n+```\n+if x.len() == 0 {\n+    ..\n+}\n+if y.len() != 0 {\n+    ..\n+}\n+```\n+instead use\n+```\n+if x.is_empty() {\n+    ..\n+}\n+if !y.is_empty() {\n+    ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "eba5a90ddd66c57846806913fd0a81cb024df7ea", "filename": "src/docs/let_and_return.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flet_and_return.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flet_and_return.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flet_and_return.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for `let`-bindings, which are subsequently\n+returned.\n+\n+### Why is this bad?\n+It is just extraneous code. Remove it to make your code\n+more rusty.\n+\n+### Example\n+```\n+fn foo() -> String {\n+    let x = String::new();\n+    x\n+}\n+```\n+instead, use\n+```\n+fn foo() -> String {\n+    String::new()\n+}\n+```\n\\ No newline at end of file"}, {"sha": "29ce9bf50ce6a61254591e93ee7dadb8a0bfdd9d", "filename": "src/docs/let_underscore_drop.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flet_underscore_drop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flet_underscore_drop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flet_underscore_drop.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Checks for `let _ = <expr>`\n+where expr has a type that implements `Drop`\n+\n+### Why is this bad?\n+This statement immediately drops the initializer\n+expression instead of extending its lifetime to the end of the scope, which\n+is often not intended. To extend the expression's lifetime to the end of the\n+scope, use an underscore-prefixed name instead (i.e. _var). If you want to\n+explicitly drop the expression, `std::mem::drop` conveys your intention\n+better and is less error-prone.\n+\n+### Example\n+```\n+{\n+    let _ = DroppableItem;\n+    //                   ^ dropped here\n+    /* more code */\n+}\n+```\n+\n+Use instead:\n+```\n+{\n+    let _droppable = DroppableItem;\n+    /* more code */\n+    // dropped at end of scope\n+}\n+```\n\\ No newline at end of file"}, {"sha": "bd8217fb58b3c19dce8e06a2cbd8ddf2f5639f00", "filename": "src/docs/let_underscore_lock.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flet_underscore_lock.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flet_underscore_lock.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flet_underscore_lock.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for `let _ = sync_lock`.\n+This supports `mutex` and `rwlock` in `std::sync` and `parking_lot`.\n+\n+### Why is this bad?\n+This statement immediately drops the lock instead of\n+extending its lifetime to the end of the scope, which is often not intended.\n+To extend lock lifetime to the end of the scope, use an underscore-prefixed\n+name instead (i.e. _lock). If you want to explicitly drop the lock,\n+`std::mem::drop` conveys your intention better and is less error-prone.\n+\n+### Example\n+```\n+let _ = mutex.lock();\n+```\n+\n+Use instead:\n+```\n+let _lock = mutex.lock();\n+```\n\\ No newline at end of file"}, {"sha": "270b81d9a4c414ec482301e1593042f89c922b43", "filename": "src/docs/let_underscore_must_use.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flet_underscore_must_use.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flet_underscore_must_use.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flet_underscore_must_use.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for `let _ = <expr>` where expr is `#[must_use]`\n+\n+### Why is this bad?\n+It's better to explicitly handle the value of a `#[must_use]`\n+expr\n+\n+### Example\n+```\n+fn f() -> Result<u32, u32> {\n+    Ok(0)\n+}\n+\n+let _ = f();\n+// is_ok() is marked #[must_use]\n+let _ = f().is_ok();\n+```\n\\ No newline at end of file"}, {"sha": "bc16d5b3d81beeb6880a1f44bf36c49d5b9bb867", "filename": "src/docs/let_unit_value.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flet_unit_value.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flet_unit_value.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flet_unit_value.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for binding a unit value.\n+\n+### Why is this bad?\n+A unit value cannot usefully be used anywhere. So\n+binding one is kind of pointless.\n+\n+### Example\n+```\n+let x = {\n+    1;\n+};\n+```\n\\ No newline at end of file"}, {"sha": "986ff1369e3c150f5a7d838a4f81922d920af44d", "filename": "src/docs/linkedlist.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flinkedlist.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flinkedlist.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flinkedlist.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks for usage of any `LinkedList`, suggesting to use a\n+`Vec` or a `VecDeque` (formerly called `RingBuf`).\n+\n+### Why is this bad?\n+Gankro says:\n+\n+> The TL;DR of `LinkedList` is that it's built on a massive amount of\n+pointers and indirection.\n+> It wastes memory, it has terrible cache locality, and is all-around slow.\n+`RingBuf`, while\n+> \"only\" amortized for push/pop, should be faster in the general case for\n+almost every possible\n+> workload, and isn't even amortized at all if you can predict the capacity\n+you need.\n+>\n+> `LinkedList`s are only really good if you're doing a lot of merging or\n+splitting of lists.\n+> This is because they can just mangle some pointers instead of actually\n+copying the data. Even\n+> if you're doing a lot of insertion in the middle of the list, `RingBuf`\n+can still be better\n+> because of how expensive it is to seek to the middle of a `LinkedList`.\n+\n+### Known problems\n+False positives \u2013 the instances where using a\n+`LinkedList` makes sense are few and far between, but they can still happen.\n+\n+### Example\n+```\n+let x: LinkedList<usize> = LinkedList::new();\n+```\n\\ No newline at end of file"}, {"sha": "bbcb9115ea62a2f7ab2b608d1b56c48edc86cb48", "filename": "src/docs/lossy_float_literal.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flossy_float_literal.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Flossy_float_literal.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flossy_float_literal.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for whole number float literals that\n+cannot be represented as the underlying type without loss.\n+\n+### Why is this bad?\n+Rust will silently lose precision during\n+conversion to a float.\n+\n+### Example\n+```\n+let _: f32 = 16_777_217.0; // 16_777_216.0\n+```\n+\n+Use instead:\n+```\n+let _: f32 = 16_777_216.0;\n+let _: f64 = 16_777_217.0;\n+```\n\\ No newline at end of file"}, {"sha": "6a8180a60bc6fec1bc63542b035d7fbab02897b7", "filename": "src/docs/macro_use_imports.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmacro_use_imports.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmacro_use_imports.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmacro_use_imports.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks for `#[macro_use] use...`.\n+\n+### Why is this bad?\n+Since the Rust 2018 edition you can import\n+macro's directly, this is considered idiomatic.\n+\n+### Example\n+```\n+#[macro_use]\n+use some_macro;\n+```\n\\ No newline at end of file"}, {"sha": "e49becd15bbdb333909e3e2a2147cda2803367c5", "filename": "src/docs/main_recursion.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmain_recursion.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmain_recursion.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmain_recursion.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for recursion using the entrypoint.\n+\n+### Why is this bad?\n+Apart from special setups (which we could detect following attributes like #![no_std]),\n+recursing into main() seems like an unintuitive anti-pattern we should be able to detect.\n+\n+### Example\n+```\n+fn main() {\n+    main();\n+}\n+```\n\\ No newline at end of file"}, {"sha": "93653081a2ce08833423201991d8ee71b2bf1484", "filename": "src/docs/manual_assert.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_assert.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_assert.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_assert.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Detects `if`-then-`panic!` that can be replaced with `assert!`.\n+\n+### Why is this bad?\n+`assert!` is simpler than `if`-then-`panic!`.\n+\n+### Example\n+```\n+let sad_people: Vec<&str> = vec![];\n+if !sad_people.is_empty() {\n+    panic!(\"there are sad people: {:?}\", sad_people);\n+}\n+```\n+Use instead:\n+```\n+let sad_people: Vec<&str> = vec![];\n+assert!(sad_people.is_empty(), \"there are sad people: {:?}\", sad_people);\n+```\n\\ No newline at end of file"}, {"sha": "d01ac402e0d21f99b370c33d681d5d53680ef015", "filename": "src/docs/manual_async_fn.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_async_fn.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_async_fn.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_async_fn.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+It checks for manual implementations of `async` functions.\n+\n+### Why is this bad?\n+It's more idiomatic to use the dedicated syntax.\n+\n+### Example\n+```\n+use std::future::Future;\n+\n+fn foo() -> impl Future<Output = i32> { async { 42 } }\n+```\n+Use instead:\n+```\n+async fn foo() -> i32 { 42 }\n+```\n\\ No newline at end of file"}, {"sha": "b96c2eb151d4161b67aa4bd2a093f95caa8b657a", "filename": "src/docs/manual_bits.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_bits.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_bits.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_bits.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for uses of `std::mem::size_of::<T>() * 8` when\n+`T::BITS` is available.\n+\n+### Why is this bad?\n+Can be written as the shorter `T::BITS`.\n+\n+### Example\n+```\n+std::mem::size_of::<usize>() * 8;\n+```\n+Use instead:\n+```\n+usize::BITS as usize;\n+```\n\\ No newline at end of file"}, {"sha": "3b6860798ff58a54a569a0da8179a20219c7ad2c", "filename": "src/docs/manual_filter_map.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_filter_map.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_filter_map.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_filter_map.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for usage of `_.filter(_).map(_)` that can be written more simply\n+as `filter_map(_)`.\n+\n+### Why is this bad?\n+Redundant code in the `filter` and `map` operations is poor style and\n+less performant.\n+\n+### Example\n+```\n+(0_i32..10)\n+    .filter(|n| n.checked_add(1).is_some())\n+    .map(|n| n.checked_add(1).unwrap());\n+```\n+\n+Use instead:\n+```\n+(0_i32..10).filter_map(|n| n.checked_add(1));\n+```\n\\ No newline at end of file"}, {"sha": "e3e07a2771f95ccc49ca7275e60c47c6edae29f2", "filename": "src/docs/manual_find.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_find.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_find.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_find.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Check for manual implementations of Iterator::find\n+\n+### Why is this bad?\n+It doesn't affect performance, but using `find` is shorter and easier to read.\n+\n+### Example\n+\n+```\n+fn example(arr: Vec<i32>) -> Option<i32> {\n+    for el in arr {\n+        if el == 1 {\n+            return Some(el);\n+        }\n+    }\n+    None\n+}\n+```\n+Use instead:\n+```\n+fn example(arr: Vec<i32>) -> Option<i32> {\n+    arr.into_iter().find(|&el| el == 1)\n+}\n+```\n\\ No newline at end of file"}, {"sha": "83b22060c0e193a5510d103afdb7eb78f400b687", "filename": "src/docs/manual_find_map.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_find_map.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_find_map.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_find_map.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for usage of `_.find(_).map(_)` that can be written more simply\n+as `find_map(_)`.\n+\n+### Why is this bad?\n+Redundant code in the `find` and `map` operations is poor style and\n+less performant.\n+\n+### Example\n+```\n+(0_i32..10)\n+    .find(|n| n.checked_add(1).is_some())\n+    .map(|n| n.checked_add(1).unwrap());\n+```\n+\n+Use instead:\n+```\n+(0_i32..10).find_map(|n| n.checked_add(1));\n+```\n\\ No newline at end of file"}, {"sha": "62d5f3ec9357659152c99389be9f436c791a6a8c", "filename": "src/docs/manual_flatten.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_flatten.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_flatten.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_flatten.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Check for unnecessary `if let` usage in a for loop\n+where only the `Some` or `Ok` variant of the iterator element is used.\n+\n+### Why is this bad?\n+It is verbose and can be simplified\n+by first calling the `flatten` method on the `Iterator`.\n+\n+### Example\n+\n+```\n+let x = vec![Some(1), Some(2), Some(3)];\n+for n in x {\n+    if let Some(n) = n {\n+        println!(\"{}\", n);\n+    }\n+}\n+```\n+Use instead:\n+```\n+let x = vec![Some(1), Some(2), Some(3)];\n+for n in x.into_iter().flatten() {\n+    println!(\"{}\", n);\n+}\n+```\n\\ No newline at end of file"}, {"sha": "dde3d493c70d3806891006be2eb83c653ec046f9", "filename": "src/docs/manual_instant_elapsed.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_instant_elapsed.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_instant_elapsed.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_instant_elapsed.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Lints subtraction between `Instant::now()` and another `Instant`.\n+\n+### Why is this bad?\n+It is easy to accidentally write `prev_instant - Instant::now()`, which will always be 0ns\n+as `Instant` subtraction saturates.\n+\n+`prev_instant.elapsed()` also more clearly signals intention.\n+\n+### Example\n+```\n+use std::time::Instant;\n+let prev_instant = Instant::now();\n+let duration = Instant::now() - prev_instant;\n+```\n+Use instead:\n+```\n+use std::time::Instant;\n+let prev_instant = Instant::now();\n+let duration = prev_instant.elapsed();\n+```\n\\ No newline at end of file"}, {"sha": "7f68ccd1037e3fb4f89927bdb1d7f7d7ba7e5544", "filename": "src/docs/manual_map.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_map.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_map.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_map.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for usages of `match` which could be implemented using `map`\n+\n+### Why is this bad?\n+Using the `map` method is clearer and more concise.\n+\n+### Example\n+```\n+match Some(0) {\n+    Some(x) => Some(x + 1),\n+    None => None,\n+};\n+```\n+Use instead:\n+```\n+Some(0).map(|x| x + 1);\n+```\n\\ No newline at end of file"}, {"sha": "d7690bf25866934959af7781dbae6cf525972e50", "filename": "src/docs/manual_memcpy.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_memcpy.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_memcpy.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_memcpy.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for for-loops that manually copy items between\n+slices that could be optimized by having a memcpy.\n+\n+### Why is this bad?\n+It is not as fast as a memcpy.\n+\n+### Example\n+```\n+for i in 0..src.len() {\n+    dst[i + 64] = src[i];\n+}\n+```\n+\n+Use instead:\n+```\n+dst[64..(src.len() + 64)].clone_from_slice(&src[..]);\n+```\n\\ No newline at end of file"}, {"sha": "fb021393bd7c935beea0436d35fd047cf4e5f7ff", "filename": "src/docs/manual_non_exhaustive.txt", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_non_exhaustive.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_non_exhaustive.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_non_exhaustive.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,41 @@\n+### What it does\n+Checks for manual implementations of the non-exhaustive pattern.\n+\n+### Why is this bad?\n+Using the #[non_exhaustive] attribute expresses better the intent\n+and allows possible optimizations when applied to enums.\n+\n+### Example\n+```\n+struct S {\n+    pub a: i32,\n+    pub b: i32,\n+    _c: (),\n+}\n+\n+enum E {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    _C,\n+}\n+\n+struct T(pub i32, pub i32, ());\n+```\n+Use instead:\n+```\n+#[non_exhaustive]\n+struct S {\n+    pub a: i32,\n+    pub b: i32,\n+}\n+\n+#[non_exhaustive]\n+enum E {\n+    A,\n+    B,\n+}\n+\n+#[non_exhaustive]\n+struct T(pub i32, pub i32);\n+```\n\\ No newline at end of file"}, {"sha": "5accdf25965ab35f6d02cbf3d81d33483bef287a", "filename": "src/docs/manual_ok_or.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_ok_or.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_ok_or.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_ok_or.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+\n+Finds patterns that reimplement `Option::ok_or`.\n+\n+### Why is this bad?\n+\n+Concise code helps focusing on behavior instead of boilerplate.\n+\n+### Examples\n+```\n+let foo: Option<i32> = None;\n+foo.map_or(Err(\"error\"), |v| Ok(v));\n+```\n+\n+Use instead:\n+```\n+let foo: Option<i32> = None;\n+foo.ok_or(\"error\");\n+```\n\\ No newline at end of file"}, {"sha": "0ade26951d38523180ef49c247037c993a07653c", "filename": "src/docs/manual_range_contains.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_range_contains.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_range_contains.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_range_contains.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for expressions like `x >= 3 && x < 8` that could\n+be more readably expressed as `(3..8).contains(x)`.\n+\n+### Why is this bad?\n+`contains` expresses the intent better and has less\n+failure modes (such as fencepost errors or using `||` instead of `&&`).\n+\n+### Example\n+```\n+// given\n+let x = 6;\n+\n+assert!(x >= 3 && x < 8);\n+```\n+Use instead:\n+```\n+assert!((3..8).contains(&x));\n+```\n\\ No newline at end of file"}, {"sha": "d3bb8c61304e1cf513a41942d221d4e079f26171", "filename": "src/docs/manual_rem_euclid.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_rem_euclid.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_rem_euclid.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_rem_euclid.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for an expression like `((x % 4) + 4) % 4` which is a common manual reimplementation\n+of `x.rem_euclid(4)`.\n+\n+### Why is this bad?\n+It's simpler and more readable.\n+\n+### Example\n+```\n+let x: i32 = 24;\n+let rem = ((x % 4) + 4) % 4;\n+```\n+Use instead:\n+```\n+let x: i32 = 24;\n+let rem = x.rem_euclid(4);\n+```\n\\ No newline at end of file"}, {"sha": "cd4f65a93fc33ea4bc8d5a7521dd8c581b9e544d", "filename": "src/docs/manual_retain.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_retain.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_retain.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_retain.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for code to be replaced by `.retain()`.\n+### Why is this bad?\n+`.retain()` is simpler and avoids needless allocation.\n+### Example\n+```\n+let mut vec = vec![0, 1, 2];\n+vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+vec = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+```\n+Use instead:\n+```\n+let mut vec = vec![0, 1, 2];\n+vec.retain(|x| x % 2 == 0);\n+```\n\\ No newline at end of file"}, {"sha": "d9f5d3d1187129a7fe8cc6fc8c598d8d8930962e", "filename": "src/docs/manual_saturating_arithmetic.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_saturating_arithmetic.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_saturating_arithmetic.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_saturating_arithmetic.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for `.checked_add/sub(x).unwrap_or(MAX/MIN)`.\n+\n+### Why is this bad?\n+These can be written simply with `saturating_add/sub` methods.\n+\n+### Example\n+```\n+let add = x.checked_add(y).unwrap_or(u32::MAX);\n+let sub = x.checked_sub(y).unwrap_or(u32::MIN);\n+```\n+\n+can be written using dedicated methods for saturating addition/subtraction as:\n+\n+```\n+let add = x.saturating_add(y);\n+let sub = x.saturating_sub(y);\n+```\n\\ No newline at end of file"}, {"sha": "291ae447de08a6b80afb6c4960050e27abd7dae3", "filename": "src/docs/manual_split_once.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_split_once.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_split_once.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_split_once.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Checks for usages of `str::splitn(2, _)`\n+\n+### Why is this bad?\n+`split_once` is both clearer in intent and slightly more efficient.\n+\n+### Example\n+```\n+let s = \"key=value=add\";\n+let (key, value) = s.splitn(2, '=').next_tuple()?;\n+let value = s.splitn(2, '=').nth(1)?;\n+\n+let mut parts = s.splitn(2, '=');\n+let key = parts.next()?;\n+let value = parts.next()?;\n+```\n+\n+Use instead:\n+```\n+let s = \"key=value=add\";\n+let (key, value) = s.split_once('=')?;\n+let value = s.split_once('=')?.1;\n+\n+let (key, value) = s.split_once('=')?;\n+```\n+\n+### Limitations\n+The multiple statement variant currently only detects `iter.next()?`/`iter.next().unwrap()`\n+in two separate `let` statements that immediately follow the `splitn()`\n\\ No newline at end of file"}, {"sha": "1d4a7a48e203345b96f0ae4db4e243542693f327", "filename": "src/docs/manual_str_repeat.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_str_repeat.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_str_repeat.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_str_repeat.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for manual implementations of `str::repeat`\n+\n+### Why is this bad?\n+These are both harder to read, as well as less performant.\n+\n+### Example\n+```\n+let x: String = std::iter::repeat('x').take(10).collect();\n+```\n+\n+Use instead:\n+```\n+let x: String = \"x\".repeat(10);\n+```\n\\ No newline at end of file"}, {"sha": "4cbc43f8f8439b681a45c17adeb7f937d9fefb0d", "filename": "src/docs/manual_string_new.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_string_new.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_string_new.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_string_new.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+\n+Checks for usage of `\"\"` to create a `String`, such as `\"\".to_string()`, `\"\".to_owned()`,\n+`String::from(\"\")` and others.\n+\n+### Why is this bad?\n+\n+Different ways of creating an empty string makes your code less standardized, which can\n+be confusing.\n+\n+### Example\n+```\n+let a = \"\".to_string();\n+let b: String = \"\".into();\n+```\n+Use instead:\n+```\n+let a = String::new();\n+let b = String::new();\n+```\n\\ No newline at end of file"}, {"sha": "f32d8e7a09bb327fb711f76df7222b1c2d18fdd7", "filename": "src/docs/manual_strip.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_strip.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_strip.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_strip.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing using\n+the pattern's length.\n+\n+### Why is this bad?\n+Using `str:strip_{prefix,suffix}` is safer and may have better performance as there is no\n+slicing which may panic and the compiler does not need to insert this panic code. It is\n+also sometimes more readable as it removes the need for duplicating or storing the pattern\n+used by `str::{starts,ends}_with` and in the slicing.\n+\n+### Example\n+```\n+let s = \"hello, world!\";\n+if s.starts_with(\"hello, \") {\n+    assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n+}\n+```\n+Use instead:\n+```\n+let s = \"hello, world!\";\n+if let Some(end) = s.strip_prefix(\"hello, \") {\n+    assert_eq!(end.to_uppercase(), \"WORLD!\");\n+}\n+```\n\\ No newline at end of file"}, {"sha": "bd9526288e35b14bb806238a1a2163f6d672efe9", "filename": "src/docs/manual_swap.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_swap.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_swap.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_swap.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for manual swapping.\n+\n+### Why is this bad?\n+The `std::mem::swap` function exposes the intent better\n+without deinitializing or copying either variable.\n+\n+### Example\n+```\n+let mut a = 42;\n+let mut b = 1337;\n+\n+let t = b;\n+b = a;\n+a = t;\n+```\n+Use std::mem::swap():\n+```\n+let mut a = 1;\n+let mut b = 2;\n+std::mem::swap(&mut a, &mut b);\n+```\n\\ No newline at end of file"}, {"sha": "1fd7d831bfca2a44771e5321e0679d7013698cdf", "filename": "src/docs/manual_unwrap_or.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_unwrap_or.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmanual_unwrap_or.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_unwrap_or.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Finds patterns that reimplement `Option::unwrap_or` or `Result::unwrap_or`.\n+\n+### Why is this bad?\n+Concise code helps focusing on behavior instead of boilerplate.\n+\n+### Example\n+```\n+let foo: Option<i32> = None;\n+match foo {\n+    Some(v) => v,\n+    None => 1,\n+};\n+```\n+\n+Use instead:\n+```\n+let foo: Option<i32> = None;\n+foo.unwrap_or(1);\n+```\n\\ No newline at end of file"}, {"sha": "55ee5da5557443219b0f2a48a85f71d01af4c5f1", "filename": "src/docs/many_single_char_names.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmany_single_char_names.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmany_single_char_names.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmany_single_char_names.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks for too many variables whose name consists of a\n+single character.\n+\n+### Why is this bad?\n+It's hard to memorize what a variable means without a\n+descriptive name.\n+\n+### Example\n+```\n+let (a, b, c, d, e, f, g) = (...);\n+```\n\\ No newline at end of file"}, {"sha": "3ee27f072ef3da18b536306083f16808618fa47b", "filename": "src/docs/map_clone.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_clone.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_clone.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmap_clone.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for usage of `map(|x| x.clone())` or\n+dereferencing closures for `Copy` types, on `Iterator` or `Option`,\n+and suggests `cloned()` or `copied()` instead\n+\n+### Why is this bad?\n+Readability, this can be written more concisely\n+\n+### Example\n+```\n+let x = vec![42, 43];\n+let y = x.iter();\n+let z = y.map(|i| *i);\n+```\n+\n+The correct use would be:\n+\n+```\n+let x = vec![42, 43];\n+let y = x.iter();\n+let z = y.cloned();\n+```\n\\ No newline at end of file"}, {"sha": "9b720612495ce1607d7bd8c7d529bee8f5abb496", "filename": "src/docs/map_collect_result_unit.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_collect_result_unit.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_collect_result_unit.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmap_collect_result_unit.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks for usage of `_.map(_).collect::<Result<(), _>()`.\n+\n+### Why is this bad?\n+Using `try_for_each` instead is more readable and idiomatic.\n+\n+### Example\n+```\n+(0..3).map(|t| Err(t)).collect::<Result<(), _>>();\n+```\n+Use instead:\n+```\n+(0..3).try_for_each(|t| Err(t));\n+```\n\\ No newline at end of file"}, {"sha": "20dba1798d0d5d17887fc745fe7b44537ec8059e", "filename": "src/docs/map_entry.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_entry.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_entry.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmap_entry.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for uses of `contains_key` + `insert` on `HashMap`\n+or `BTreeMap`.\n+\n+### Why is this bad?\n+Using `entry` is more efficient.\n+\n+### Known problems\n+The suggestion may have type inference errors in some cases. e.g.\n+```\n+let mut map = std::collections::HashMap::new();\n+let _ = if !map.contains_key(&0) {\n+    map.insert(0, 0)\n+} else {\n+    None\n+};\n+```\n+\n+### Example\n+```\n+if !map.contains_key(&k) {\n+    map.insert(k, v);\n+}\n+```\n+Use instead:\n+```\n+map.entry(k).or_insert(v);\n+```\n\\ No newline at end of file"}, {"sha": "2606c13a7afd9e1081559f167d501d98c986a69a", "filename": "src/docs/map_err_ignore.txt", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_err_ignore.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_err_ignore.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmap_err_ignore.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,93 @@\n+### What it does\n+Checks for instances of `map_err(|_| Some::Enum)`\n+\n+### Why is this bad?\n+This `map_err` throws away the original error rather than allowing the enum to contain and report the cause of the error\n+\n+### Example\n+Before:\n+```\n+use std::fmt;\n+\n+#[derive(Debug)]\n+enum Error {\n+    Indivisible,\n+    Remainder(u8),\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Error::Indivisible => write!(f, \"could not divide input by three\"),\n+            Error::Remainder(remainder) => write!(\n+                f,\n+                \"input is not divisible by three, remainder = {}\",\n+                remainder\n+            ),\n+        }\n+    }\n+}\n+\n+impl std::error::Error for Error {}\n+\n+fn divisible_by_3(input: &str) -> Result<(), Error> {\n+    input\n+        .parse::<i32>()\n+        .map_err(|_| Error::Indivisible)\n+        .map(|v| v % 3)\n+        .and_then(|remainder| {\n+            if remainder == 0 {\n+                Ok(())\n+            } else {\n+                Err(Error::Remainder(remainder as u8))\n+            }\n+        })\n+}\n+ ```\n+\n+ After:\n+ ```rust\n+use std::{fmt, num::ParseIntError};\n+\n+#[derive(Debug)]\n+enum Error {\n+    Indivisible(ParseIntError),\n+    Remainder(u8),\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Error::Indivisible(_) => write!(f, \"could not divide input by three\"),\n+            Error::Remainder(remainder) => write!(\n+                f,\n+                \"input is not divisible by three, remainder = {}\",\n+                remainder\n+            ),\n+        }\n+    }\n+}\n+\n+impl std::error::Error for Error {\n+    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n+        match self {\n+            Error::Indivisible(source) => Some(source),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+fn divisible_by_3(input: &str) -> Result<(), Error> {\n+    input\n+        .parse::<i32>()\n+        .map_err(Error::Indivisible)\n+        .map(|v| v % 3)\n+        .and_then(|remainder| {\n+            if remainder == 0 {\n+                Ok(())\n+            } else {\n+                Err(Error::Remainder(remainder as u8))\n+            }\n+        })\n+}\n+```\n\\ No newline at end of file"}, {"sha": "73c0e51407f28e73e0914c7bae9ad8672f2f259b", "filename": "src/docs/map_flatten.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_flatten.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_flatten.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmap_flatten.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for usage of `_.map(_).flatten(_)` on `Iterator` and `Option`\n+\n+### Why is this bad?\n+Readability, this can be written more concisely as\n+`_.flat_map(_)` for `Iterator` or `_.and_then(_)` for `Option`\n+\n+### Example\n+```\n+let vec = vec![vec![1]];\n+let opt = Some(5);\n+\n+vec.iter().map(|x| x.iter()).flatten();\n+opt.map(|x| Some(x * 2)).flatten();\n+```\n+\n+Use instead:\n+```\n+vec.iter().flat_map(|x| x.iter());\n+opt.and_then(|x| Some(x * 2));\n+```\n\\ No newline at end of file"}, {"sha": "e2e7af0bed9b148d36e262f2c1cb913b65dc6b1c", "filename": "src/docs/map_identity.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_identity.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_identity.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmap_identity.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for instances of `map(f)` where `f` is the identity function.\n+\n+### Why is this bad?\n+It can be written more concisely without the call to `map`.\n+\n+### Example\n+```\n+let x = [1, 2, 3];\n+let y: Vec<_> = x.iter().map(|x| x).map(|x| 2*x).collect();\n+```\n+Use instead:\n+```\n+let x = [1, 2, 3];\n+let y: Vec<_> = x.iter().map(|x| 2*x).collect();\n+```\n\\ No newline at end of file"}, {"sha": "485b29f01b103e6cac338a0f0d7a2d03b62c5210", "filename": "src/docs/map_unwrap_or.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_unwrap_or.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmap_unwrap_or.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmap_unwrap_or.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for usage of `option.map(_).unwrap_or(_)` or `option.map(_).unwrap_or_else(_)` or\n+`result.map(_).unwrap_or_else(_)`.\n+\n+### Why is this bad?\n+Readability, these can be written more concisely (resp.) as\n+`option.map_or(_, _)`, `option.map_or_else(_, _)` and `result.map_or_else(_, _)`.\n+\n+### Known problems\n+The order of the arguments is not in execution order\n+\n+### Examples\n+```\n+option.map(|a| a + 1).unwrap_or(0);\n+result.map(|a| a + 1).unwrap_or_else(some_function);\n+```\n+\n+Use instead:\n+```\n+option.map_or(0, |a| a + 1);\n+result.map_or_else(some_function, |a| a + 1);\n+```\n\\ No newline at end of file"}, {"sha": "5e5f3d645a4e4f1da645bc5f2c868df6c6d77ee2", "filename": "src/docs/match_as_ref.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_as_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_as_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmatch_as_ref.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for match which is used to add a reference to an\n+`Option` value.\n+\n+### Why is this bad?\n+Using `as_ref()` or `as_mut()` instead is shorter.\n+\n+### Example\n+```\n+let x: Option<()> = None;\n+\n+let r: Option<&()> = match x {\n+    None => None,\n+    Some(ref v) => Some(v),\n+};\n+```\n+\n+Use instead:\n+```\n+let x: Option<()> = None;\n+\n+let r: Option<&()> = x.as_ref();\n+```\n\\ No newline at end of file"}, {"sha": "96f9e1f8b7d1bfb503d685bb7861da665d8616f2", "filename": "src/docs/match_bool.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_bool.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_bool.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmatch_bool.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for matches where match expression is a `bool`. It\n+suggests to replace the expression with an `if...else` block.\n+\n+### Why is this bad?\n+It makes the code less readable.\n+\n+### Example\n+```\n+let condition: bool = true;\n+match condition {\n+    true => foo(),\n+    false => bar(),\n+}\n+```\n+Use if/else instead:\n+```\n+let condition: bool = true;\n+if condition {\n+    foo();\n+} else {\n+    bar();\n+}\n+```\n\\ No newline at end of file"}, {"sha": "643e2ddc97ba0bfe03114790fe1af7e3bdf6527f", "filename": "src/docs/match_like_matches_macro.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_like_matches_macro.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_like_matches_macro.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmatch_like_matches_macro.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks for `match`  or `if let` expressions producing a\n+`bool` that could be written using `matches!`\n+\n+### Why is this bad?\n+Readability and needless complexity.\n+\n+### Known problems\n+This lint falsely triggers, if there are arms with\n+`cfg` attributes that remove an arm evaluating to `false`.\n+\n+### Example\n+```\n+let x = Some(5);\n+\n+let a = match x {\n+    Some(0) => true,\n+    _ => false,\n+};\n+\n+let a = if let Some(0) = x {\n+    true\n+} else {\n+    false\n+};\n+```\n+\n+Use instead:\n+```\n+let x = Some(5);\n+let a = matches!(x, Some(0));\n+```\n\\ No newline at end of file"}, {"sha": "981d18d0f9ed560919e29c4913a44773612f3adf", "filename": "src/docs/match_on_vec_items.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_on_vec_items.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_on_vec_items.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmatch_on_vec_items.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Checks for `match vec[idx]` or `match vec[n..m]`.\n+\n+### Why is this bad?\n+This can panic at runtime.\n+\n+### Example\n+```\n+let arr = vec![0, 1, 2, 3];\n+let idx = 1;\n+\n+match arr[idx] {\n+    0 => println!(\"{}\", 0),\n+    1 => println!(\"{}\", 3),\n+    _ => {},\n+}\n+```\n+\n+Use instead:\n+```\n+let arr = vec![0, 1, 2, 3];\n+let idx = 1;\n+\n+match arr.get(idx) {\n+    Some(0) => println!(\"{}\", 0),\n+    Some(1) => println!(\"{}\", 3),\n+    _ => {},\n+}\n+```\n\\ No newline at end of file"}, {"sha": "841c091bd5cad43216bef6f4c07c4d3f93facafe", "filename": "src/docs/match_overlapping_arm.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_overlapping_arm.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_overlapping_arm.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmatch_overlapping_arm.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for overlapping match arms.\n+\n+### Why is this bad?\n+It is likely to be an error and if not, makes the code\n+less obvious.\n+\n+### Example\n+```\n+let x = 5;\n+match x {\n+    1..=10 => println!(\"1 ... 10\"),\n+    5..=15 => println!(\"5 ... 15\"),\n+    _ => (),\n+}\n+```\n\\ No newline at end of file"}, {"sha": "b1d9029950972cfb76a01aa79b408a8e57f2c767", "filename": "src/docs/match_ref_pats.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_ref_pats.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_ref_pats.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmatch_ref_pats.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for matches where all arms match a reference,\n+suggesting to remove the reference and deref the matched expression\n+instead. It also checks for `if let &foo = bar` blocks.\n+\n+### Why is this bad?\n+It just makes the code less readable. That reference\n+destructuring adds nothing to the code.\n+\n+### Example\n+```\n+match x {\n+    &A(ref y) => foo(y),\n+    &B => bar(),\n+    _ => frob(&x),\n+}\n+```\n+\n+Use instead:\n+```\n+match *x {\n+    A(ref y) => foo(y),\n+    B => bar(),\n+    _ => frob(x),\n+}\n+```\n\\ No newline at end of file"}, {"sha": "eea7c8e00f1bb6b7bd0f3d7ccfe8bce8f0228914", "filename": "src/docs/match_result_ok.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_result_ok.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_result_ok.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmatch_result_ok.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,27 @@\n+### What it does\n+Checks for unnecessary `ok()` in `while let`.\n+\n+### Why is this bad?\n+Calling `ok()` in `while let` is unnecessary, instead match\n+on `Ok(pat)`\n+\n+### Example\n+```\n+while let Some(value) = iter.next().ok() {\n+    vec.push(value)\n+}\n+\n+if let Some(value) = iter.next().ok() {\n+    vec.push(value)\n+}\n+```\n+Use instead:\n+```\n+while let Ok(value) = iter.next() {\n+    vec.push(value)\n+}\n+\n+if let Ok(value) = iter.next() {\n+       vec.push(value)\n+}\n+```\n\\ No newline at end of file"}, {"sha": "14edf12032e0d31082449e2672ac8840f7c8fff8", "filename": "src/docs/match_same_arms.txt", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_same_arms.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_same_arms.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmatch_same_arms.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,38 @@\n+### What it does\n+Checks for `match` with identical arm bodies.\n+\n+### Why is this bad?\n+This is probably a copy & paste error. If arm bodies\n+are the same on purpose, you can factor them\n+[using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n+\n+### Known problems\n+False positive possible with order dependent `match`\n+(see issue\n+[#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n+\n+### Example\n+```\n+match foo {\n+    Bar => bar(),\n+    Quz => quz(),\n+    Baz => bar(), // <= oops\n+}\n+```\n+\n+This should probably be\n+```\n+match foo {\n+    Bar => bar(),\n+    Quz => quz(),\n+    Baz => baz(), // <= fixed\n+}\n+```\n+\n+or if the original code was not a typo:\n+```\n+match foo {\n+    Bar | Baz => bar(), // <= shows the intent better\n+    Quz => quz(),\n+}\n+```\n\\ No newline at end of file"}, {"sha": "67ded0bbd5534601fc2158b1eee91284bf00dd14", "filename": "src/docs/match_single_binding.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_single_binding.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_single_binding.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmatch_single_binding.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for useless match that binds to only one value.\n+\n+### Why is this bad?\n+Readability and needless complexity.\n+\n+### Known problems\n+ Suggested replacements may be incorrect when `match`\n+is actually binding temporary value, bringing a 'dropped while borrowed' error.\n+\n+### Example\n+```\n+match (a, b) {\n+    (c, d) => {\n+        // useless match\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+let (c, d) = (a, b);\n+```\n\\ No newline at end of file"}, {"sha": "19e74c2084eae933025b46ed4bf441880b318b6f", "filename": "src/docs/match_str_case_mismatch.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_str_case_mismatch.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_str_case_mismatch.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmatch_str_case_mismatch.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for `match` expressions modifying the case of a string with non-compliant arms\n+\n+### Why is this bad?\n+The arm is unreachable, which is likely a mistake\n+\n+### Example\n+```\n+match &*text.to_ascii_lowercase() {\n+    \"foo\" => {},\n+    \"Bar\" => {},\n+    _ => {},\n+}\n+```\n+Use instead:\n+```\n+match &*text.to_ascii_lowercase() {\n+    \"foo\" => {},\n+    \"bar\" => {},\n+    _ => {},\n+}\n+```\n\\ No newline at end of file"}, {"sha": "f89b3a23a1ca2052dc39371427aa3f7634f563f3", "filename": "src/docs/match_wild_err_arm.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_wild_err_arm.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_wild_err_arm.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmatch_wild_err_arm.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for arm which matches all errors with `Err(_)`\n+and take drastic actions like `panic!`.\n+\n+### Why is this bad?\n+It is generally a bad practice, similar to\n+catching all exceptions in java with `catch(Exception)`\n+\n+### Example\n+```\n+let x: Result<i32, &str> = Ok(3);\n+match x {\n+    Ok(_) => println!(\"ok\"),\n+    Err(_) => panic!(\"err\"),\n+}\n+```\n\\ No newline at end of file"}, {"sha": "25559b9ecdcff813cbc33e8c5fd28652d37bd327", "filename": "src/docs/match_wildcard_for_single_variants.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_wildcard_for_single_variants.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmatch_wildcard_for_single_variants.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmatch_wildcard_for_single_variants.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,27 @@\n+### What it does\n+Checks for wildcard enum matches for a single variant.\n+\n+### Why is this bad?\n+New enum variants added by library updates can be missed.\n+\n+### Known problems\n+Suggested replacements may not use correct path to enum\n+if it's not present in the current scope.\n+\n+### Example\n+```\n+match x {\n+    Foo::A => {},\n+    Foo::B => {},\n+    _ => {},\n+}\n+```\n+\n+Use instead:\n+```\n+match x {\n+    Foo::A => {},\n+    Foo::B => {},\n+    Foo::C => {},\n+}\n+```\n\\ No newline at end of file"}, {"sha": "1204a49b4668171c1df51234458547b3f439fe66", "filename": "src/docs/maybe_infinite_iter.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmaybe_infinite_iter.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmaybe_infinite_iter.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmaybe_infinite_iter.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for iteration that may be infinite.\n+\n+### Why is this bad?\n+While there may be places where this is acceptable\n+(e.g., in event streams), in most cases this is simply an error.\n+\n+### Known problems\n+The code may have a condition to stop iteration, but\n+this lint is not clever enough to analyze it.\n+\n+### Example\n+```\n+let infinite_iter = 0..;\n+[0..].iter().zip(infinite_iter.take_while(|x| *x > 5));\n+```\n\\ No newline at end of file"}, {"sha": "a6888c48fc33b1aa69c3aa63d812e530d1193b6e", "filename": "src/docs/mem_forget.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmem_forget.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmem_forget.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmem_forget.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks for usage of `std::mem::forget(t)` where `t` is\n+`Drop`.\n+\n+### Why is this bad?\n+`std::mem::forget(t)` prevents `t` from running its\n+destructor, possibly causing leaks.\n+\n+### Example\n+```\n+mem::forget(Rc::new(55))\n+```\n\\ No newline at end of file"}, {"sha": "7f243d1c165658739add51f38587759f1287955e", "filename": "src/docs/mem_replace_option_with_none.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmem_replace_option_with_none.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmem_replace_option_with_none.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmem_replace_option_with_none.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for `mem::replace()` on an `Option` with\n+`None`.\n+\n+### Why is this bad?\n+`Option` already has the method `take()` for\n+taking its current value (Some(..) or None) and replacing it with\n+`None`.\n+\n+### Example\n+```\n+use std::mem;\n+\n+let mut an_option = Some(0);\n+let replaced = mem::replace(&mut an_option, None);\n+```\n+Is better expressed with:\n+```\n+let mut an_option = Some(0);\n+let taken = an_option.take();\n+```\n\\ No newline at end of file"}, {"sha": "24e0913a30c920319bdfbc33b64c3beaf7f551f3", "filename": "src/docs/mem_replace_with_default.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmem_replace_with_default.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmem_replace_with_default.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmem_replace_with_default.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for `std::mem::replace` on a value of type\n+`T` with `T::default()`.\n+\n+### Why is this bad?\n+`std::mem` module already has the method `take` to\n+take the current value and replace it with the default value of that type.\n+\n+### Example\n+```\n+let mut text = String::from(\"foo\");\n+let replaced = std::mem::replace(&mut text, String::default());\n+```\n+Is better expressed with:\n+```\n+let mut text = String::from(\"foo\");\n+let taken = std::mem::take(&mut text);\n+```\n\\ No newline at end of file"}, {"sha": "0bb483668abc10f2c4e2094a2758754b5675f5d9", "filename": "src/docs/mem_replace_with_uninit.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmem_replace_with_uninit.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmem_replace_with_uninit.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmem_replace_with_uninit.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for `mem::replace(&mut _, mem::uninitialized())`\n+and `mem::replace(&mut _, mem::zeroed())`.\n+\n+### Why is this bad?\n+This will lead to undefined behavior even if the\n+value is overwritten later, because the uninitialized value may be\n+observed in the case of a panic.\n+\n+### Example\n+```\n+use std::mem;\n+\n+#[allow(deprecated, invalid_value)]\n+fn myfunc (v: &mut Vec<i32>) {\n+    let taken_v = unsafe { mem::replace(v, mem::uninitialized()) };\n+    let new_v = may_panic(taken_v); // undefined behavior on panic\n+    mem::forget(mem::replace(v, new_v));\n+}\n+```\n+\n+The [take_mut](https://docs.rs/take_mut) crate offers a sound solution,\n+at the cost of either lazily creating a replacement value or aborting\n+on panic, to ensure that the uninitialized value cannot be observed.\n\\ No newline at end of file"}, {"sha": "6acf0f932e986afb3e902030979226ae42f5f6db", "filename": "src/docs/min_max.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmin_max.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmin_max.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmin_max.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for expressions where `std::cmp::min` and `max` are\n+used to clamp values, but switched so that the result is constant.\n+\n+### Why is this bad?\n+This is in all probability not the intended outcome. At\n+the least it hurts readability of the code.\n+\n+### Example\n+```\n+min(0, max(100, x))\n+\n+// or\n+\n+x.max(100).min(0)\n+```\n+It will always be equal to `0`. Probably the author meant to clamp the value\n+between 0 and 100, but has erroneously swapped `min` and `max`.\n\\ No newline at end of file"}, {"sha": "51e5ec6e7c5c4c7ad8ccc3016e6064bf07d4dcdf", "filename": "src/docs/mismatched_target_os.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmismatched_target_os.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmismatched_target_os.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmismatched_target_os.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for cfg attributes having operating systems used in target family position.\n+\n+### Why is this bad?\n+The configuration option will not be recognised and the related item will not be included\n+by the conditional compilation engine.\n+\n+### Example\n+```\n+#[cfg(linux)]\n+fn conditional() { }\n+```\n+\n+Use instead:\n+```\n+#[cfg(target_os = \"linux\")]\n+fn conditional() { }\n+\n+// or\n+\n+#[cfg(unix)]\n+fn conditional() { }\n+```\n+Check the [Rust Reference](https://doc.rust-lang.org/reference/conditional-compilation.html#target_os) for more details.\n\\ No newline at end of file"}, {"sha": "ffc7f32d0aad8ea2320dfba9b2058c8de82a6903", "filename": "src/docs/mismatching_type_param_order.txt", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmismatching_type_param_order.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmismatching_type_param_order.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmismatching_type_param_order.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,33 @@\n+### What it does\n+Checks for type parameters which are positioned inconsistently between\n+a type definition and impl block. Specifically, a parameter in an impl\n+block which has the same name as a parameter in the type def, but is in\n+a different place.\n+\n+### Why is this bad?\n+Type parameters are determined by their position rather than name.\n+Naming type parameters inconsistently may cause you to refer to the\n+wrong type parameter.\n+\n+### Limitations\n+This lint only applies to impl blocks with simple generic params, e.g.\n+`A`. If there is anything more complicated, such as a tuple, it will be\n+ignored.\n+\n+### Example\n+```\n+struct Foo<A, B> {\n+    x: A,\n+    y: B,\n+}\n+// inside the impl, B refers to Foo::A\n+impl<B, A> Foo<B, A> {}\n+```\n+Use instead:\n+```\n+struct Foo<A, B> {\n+    x: A,\n+    y: B,\n+}\n+impl<A, B> Foo<A, B> {}\n+```\n\\ No newline at end of file"}, {"sha": "3d691fe4178b50d187691ee896402e2a271a83fc", "filename": "src/docs/misrefactored_assign_op.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmisrefactored_assign_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmisrefactored_assign_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmisrefactored_assign_op.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for `a op= a op b` or `a op= b op a` patterns.\n+\n+### Why is this bad?\n+Most likely these are bugs where one meant to write `a\n+op= b`.\n+\n+### Known problems\n+Clippy cannot know for sure if `a op= a op b` should have\n+been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\n+If `a op= a op b` is really the correct behavior it should be\n+written as `a = a op a op b` as it's less confusing.\n+\n+### Example\n+```\n+let mut a = 5;\n+let b = 2;\n+// ...\n+a += a + b;\n+```\n\\ No newline at end of file"}, {"sha": "067614d4c46bffe086a8fcb1055ed0566244c276", "filename": "src/docs/missing_const_for_fn.txt", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_const_for_fn.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_const_for_fn.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmissing_const_for_fn.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,40 @@\n+### What it does\n+Suggests the use of `const` in functions and methods where possible.\n+\n+### Why is this bad?\n+Not having the function const prevents callers of the function from being const as well.\n+\n+### Known problems\n+Const functions are currently still being worked on, with some features only being available\n+on nightly. This lint does not consider all edge cases currently and the suggestions may be\n+incorrect if you are using this lint on stable.\n+\n+Also, the lint only runs one pass over the code. Consider these two non-const functions:\n+\n+```\n+fn a() -> i32 {\n+    0\n+}\n+fn b() -> i32 {\n+    a()\n+}\n+```\n+\n+When running Clippy, the lint will only suggest to make `a` const, because `b` at this time\n+can't be const as it calls a non-const function. Making `a` const and running Clippy again,\n+will suggest to make `b` const, too.\n+\n+### Example\n+```\n+fn new() -> Self {\n+    Self { random_number: 42 }\n+}\n+```\n+\n+Could be a const fn:\n+\n+```\n+const fn new() -> Self {\n+    Self { random_number: 42 }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "5d37505bb1716288b6e16ac32c00bb008a85840c", "filename": "src/docs/missing_docs_in_private_items.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_docs_in_private_items.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_docs_in_private_items.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmissing_docs_in_private_items.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,9 @@\n+### What it does\n+Warns if there is missing doc for any documentable item\n+(public or private).\n+\n+### Why is this bad?\n+Doc is good. *rustc* has a `MISSING_DOCS`\n+allowed-by-default lint for\n+public members, but has no way to enforce documentation of private items.\n+This lint fixes that.\n\\ No newline at end of file"}, {"sha": "8f4649bd5923d40cb36b189fae53a67a5acb9f36", "filename": "src/docs/missing_enforced_import_renames.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_enforced_import_renames.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_enforced_import_renames.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmissing_enforced_import_renames.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for imports that do not rename the item as specified\n+in the `enforce-import-renames` config option.\n+\n+### Why is this bad?\n+Consistency is important, if a project has defined import\n+renames they should be followed. More practically, some item names are too\n+vague outside of their defining scope this can enforce a more meaningful naming.\n+\n+### Example\n+An example clippy.toml configuration:\n+```\n+enforced-import-renames = [ { path = \"serde_json::Value\", rename = \"JsonValue\" }]\n+```\n+\n+```\n+use serde_json::Value;\n+```\n+Use instead:\n+```\n+use serde_json::Value as JsonValue;\n+```\n\\ No newline at end of file"}, {"sha": "028778d85aeba6b8affa132c56b0db574d9cfaf0", "filename": "src/docs/missing_errors_doc.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_errors_doc.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_errors_doc.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmissing_errors_doc.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks the doc comments of publicly visible functions that\n+return a `Result` type and warns if there is no `# Errors` section.\n+\n+### Why is this bad?\n+Documenting the type of errors that can be returned from a\n+function can help callers write code to handle the errors appropriately.\n+\n+### Examples\n+Since the following function returns a `Result` it has an `# Errors` section in\n+its doc comment:\n+\n+```\n+/// # Errors\n+///\n+/// Will return `Err` if `filename` does not exist or the user does not have\n+/// permission to read it.\n+pub fn read(filename: String) -> io::Result<String> {\n+    unimplemented!();\n+}\n+```\n\\ No newline at end of file"}, {"sha": "d90c50fe7f9e822898d034c60d377d2e04da4c02", "filename": "src/docs/missing_inline_in_public_items.txt", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_inline_in_public_items.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_inline_in_public_items.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmissing_inline_in_public_items.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,45 @@\n+### What it does\n+It lints if an exported function, method, trait method with default impl,\n+or trait method impl is not `#[inline]`.\n+\n+### Why is this bad?\n+In general, it is not. Functions can be inlined across\n+crates when that's profitable as long as any form of LTO is used. When LTO is disabled,\n+functions that are not `#[inline]` cannot be inlined across crates. Certain types of crates\n+might intend for most of the methods in their public API to be able to be inlined across\n+crates even when LTO is disabled. For these types of crates, enabling this lint might make\n+sense. It allows the crate to require all exported methods to be `#[inline]` by default, and\n+then opt out for specific methods where this might not make sense.\n+\n+### Example\n+```\n+pub fn foo() {} // missing #[inline]\n+fn ok() {} // ok\n+#[inline] pub fn bar() {} // ok\n+#[inline(always)] pub fn baz() {} // ok\n+\n+pub trait Bar {\n+  fn bar(); // ok\n+  fn def_bar() {} // missing #[inline]\n+}\n+\n+struct Baz;\n+impl Baz {\n+   fn private() {} // ok\n+}\n+\n+impl Bar for Baz {\n+  fn bar() {} // ok - Baz is not exported\n+}\n+\n+pub struct PubBaz;\n+impl PubBaz {\n+   fn private() {} // ok\n+   pub fn not_private() {} // missing #[inline]\n+}\n+\n+impl Bar for PubBaz {\n+   fn bar() {} // missing #[inline]\n+   fn def_bar() {} // missing #[inline]\n+}\n+```\n\\ No newline at end of file"}, {"sha": "e5e39a824519b9f16755fe07560ae583db9fcd14", "filename": "src/docs/missing_panics_doc.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_panics_doc.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_panics_doc.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmissing_panics_doc.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks the doc comments of publicly visible functions that\n+may panic and warns if there is no `# Panics` section.\n+\n+### Why is this bad?\n+Documenting the scenarios in which panicking occurs\n+can help callers who do not want to panic to avoid those situations.\n+\n+### Examples\n+Since the following function may panic it has a `# Panics` section in\n+its doc comment:\n+\n+```\n+/// # Panics\n+///\n+/// Will panic if y is 0\n+pub fn divide_by(x: i32, y: i32) -> i32 {\n+    if y == 0 {\n+        panic!(\"Cannot divide by 0\")\n+    } else {\n+        x / y\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "6492eb84f63bf7328cd13496e0fcd5c98fca86e2", "filename": "src/docs/missing_safety_doc.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_safety_doc.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_safety_doc.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmissing_safety_doc.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for the doc comments of publicly visible\n+unsafe functions and warns if there is no `# Safety` section.\n+\n+### Why is this bad?\n+Unsafe functions should document their safety\n+preconditions, so that users can be sure they are using them safely.\n+\n+### Examples\n+```\n+/// This function should really be documented\n+pub unsafe fn start_apocalypse(u: &mut Universe) {\n+    unimplemented!();\n+}\n+```\n+\n+At least write a line about safety:\n+\n+```\n+/// # Safety\n+///\n+/// This function should not be called before the horsemen are ready.\n+pub unsafe fn start_apocalypse(u: &mut Universe) {\n+    unimplemented!();\n+}\n+```\n\\ No newline at end of file"}, {"sha": "3a06a91d718355bc7bfe2c3084a87dedc51df29b", "filename": "src/docs/missing_spin_loop.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_spin_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmissing_spin_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmissing_spin_loop.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,27 @@\n+### What it does\n+Check for empty spin loops\n+\n+### Why is this bad?\n+The loop body should have something like `thread::park()` or at least\n+`std::hint::spin_loop()` to avoid needlessly burning cycles and conserve\n+energy. Perhaps even better use an actual lock, if possible.\n+\n+### Known problems\n+This lint doesn't currently trigger on `while let` or\n+`loop { match .. { .. } }` loops, which would be considered idiomatic in\n+combination with e.g. `AtomicBool::compare_exchange_weak`.\n+\n+### Example\n+\n+```\n+use core::sync::atomic::{AtomicBool, Ordering};\n+let b = AtomicBool::new(true);\n+// give a ref to `b` to another thread,wait for it to become false\n+while b.load(Ordering::Acquire) {};\n+```\n+Use instead:\n+```\n+while b.load(Ordering::Acquire) {\n+    std::hint::spin_loop()\n+}\n+```\n\\ No newline at end of file"}, {"sha": "1760fcbfeacc420ad2215ff7139aa8016439828a", "filename": "src/docs/mistyped_literal_suffixes.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmistyped_literal_suffixes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmistyped_literal_suffixes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmistyped_literal_suffixes.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Warns for mistyped suffix in literals\n+\n+### Why is this bad?\n+This is most probably a typo\n+\n+### Known problems\n+- Does not match on integers too large to fit in the corresponding unsigned type\n+- Does not match on `_127` since that is a valid grouping for decimal and octal numbers\n+\n+### Example\n+```\n+`2_32` => `2_i32`\n+`250_8 => `250_u8`\n+```\n\\ No newline at end of file"}, {"sha": "d2d01e0c98eb49f8983ad0f5c0b908c69fc3b077", "filename": "src/docs/mixed_case_hex_literals.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmixed_case_hex_literals.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmixed_case_hex_literals.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmixed_case_hex_literals.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Warns on hexadecimal literals with mixed-case letter\n+digits.\n+\n+### Why is this bad?\n+It looks confusing.\n+\n+### Example\n+```\n+0x1a9BAcD\n+```\n+\n+Use instead:\n+```\n+0x1A9BACD\n+```\n\\ No newline at end of file"}, {"sha": "02d1c5d0525247843ca35f9ac5b6480eca74036e", "filename": "src/docs/mixed_read_write_in_expression.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmixed_read_write_in_expression.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmixed_read_write_in_expression.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmixed_read_write_in_expression.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks for a read and a write to the same variable where\n+whether the read occurs before or after the write depends on the evaluation\n+order of sub-expressions.\n+\n+### Why is this bad?\n+It is often confusing to read. As described [here](https://doc.rust-lang.org/reference/expressions.html?highlight=subexpression#evaluation-order-of-operands),\n+the operands of these expressions are evaluated before applying the effects of the expression.\n+\n+### Known problems\n+Code which intentionally depends on the evaluation\n+order, or which is correct for any evaluation order.\n+\n+### Example\n+```\n+let mut x = 0;\n+\n+let a = {\n+    x = 1;\n+    1\n+} + x;\n+// Unclear whether a is 1 or 2.\n+```\n+\n+Use instead:\n+```\n+let tmp = {\n+    x = 1;\n+    1\n+};\n+let a = tmp + x;\n+```\n\\ No newline at end of file"}, {"sha": "95bca583afd3cedc315c9dd931acc81937ed7585", "filename": "src/docs/mod_module_files.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmod_module_files.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmod_module_files.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmod_module_files.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks that module layout uses only self named module files, bans `mod.rs` files.\n+\n+### Why is this bad?\n+Having multiple module layout styles in a project can be confusing.\n+\n+### Example\n+```\n+src/\n+  stuff/\n+    stuff_files.rs\n+    mod.rs\n+  lib.rs\n+```\n+Use instead:\n+```\n+src/\n+  stuff/\n+    stuff_files.rs\n+  stuff.rs\n+  lib.rs\n+```\n\\ No newline at end of file"}, {"sha": "d80a1b8d8fe577e711bc488c8907d731845964e4", "filename": "src/docs/module_inception.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmodule_inception.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmodule_inception.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmodule_inception.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for modules that have the same name as their\n+parent module\n+\n+### Why is this bad?\n+A typical beginner mistake is to have `mod foo;` and\n+again `mod foo { ..\n+}` in `foo.rs`.\n+The expectation is that items inside the inner `mod foo { .. }` are then\n+available\n+through `foo::x`, but they are only available through\n+`foo::foo::x`.\n+If this is done on purpose, it would be better to choose a more\n+representative module name.\n+\n+### Example\n+```\n+// lib.rs\n+mod foo;\n+// foo.rs\n+mod foo {\n+    ...\n+}\n+```\n\\ No newline at end of file"}, {"sha": "3bc05d02780cac386936f874084a313e4b965fcc", "filename": "src/docs/module_name_repetitions.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmodule_name_repetitions.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmodule_name_repetitions.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmodule_name_repetitions.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Detects type names that are prefixed or suffixed by the\n+containing module's name.\n+\n+### Why is this bad?\n+It requires the user to type the module name twice.\n+\n+### Example\n+```\n+mod cake {\n+    struct BlackForestCake;\n+}\n+```\n+\n+Use instead:\n+```\n+mod cake {\n+    struct BlackForest;\n+}\n+```\n\\ No newline at end of file"}, {"sha": "ff7296f3c5b8d52e0716bf1d96898a474ff3dce7", "filename": "src/docs/modulo_arithmetic.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmodulo_arithmetic.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmodulo_arithmetic.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmodulo_arithmetic.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for modulo arithmetic.\n+\n+### Why is this bad?\n+The results of modulo (%) operation might differ\n+depending on the language, when negative numbers are involved.\n+If you interop with different languages it might be beneficial\n+to double check all places that use modulo arithmetic.\n+\n+For example, in Rust `17 % -3 = 2`, but in Python `17 % -3 = -1`.\n+\n+### Example\n+```\n+let x = -17 % 3;\n+```\n\\ No newline at end of file"}, {"sha": "bc8f95b0be693ab26dd7e62a1a2e0480ddb6d2bb", "filename": "src/docs/modulo_one.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmodulo_one.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmodulo_one.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmodulo_one.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for getting the remainder of a division by one or minus\n+one.\n+\n+### Why is this bad?\n+The result for a divisor of one can only ever be zero; for\n+minus one it can cause panic/overflow (if the left operand is the minimal value of\n+the respective integer type) or results in zero. No one will write such code\n+deliberately, unless trying to win an Underhanded Rust Contest. Even for that\n+contest, it's probably a bad idea. Use something more underhanded.\n+\n+### Example\n+```\n+let a = x % 1;\n+let a = x % -1;\n+```\n\\ No newline at end of file"}, {"sha": "ed1f1b420cbd3363ef19d48ba1f76c862c0a5d0e", "filename": "src/docs/multi_assignments.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmulti_assignments.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ad72aee93c80cf2e207e1f728ff0c87336ead695/src%2Fdocs%2Fmulti_assignments.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmulti_assignments.txt?ref=ad72aee93c80cf2e207e1f728ff0c87336ead695", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for nested assignments.\n+\n+### Why is this bad?\n+While this is in most cases already a type mismatch,\n+the result of an assignment being `()` can throw off people coming from languages like python or C,\n+where such assignments return a copy of the assigned value.\n+\n+### Example\n+```\n+a = b = 42;\n+```\n+Use instead:\n+```\n+b = 42;\n+a = b;\n+```\n\\ No newline at end of file"}]}