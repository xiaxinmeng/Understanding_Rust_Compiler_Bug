{"sha": "900191891fc5462d4ef33756a7d4d40e78e1c1cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMDE5MTg5MWZjNTQ2MmQ0ZWYzMzc1NmE3ZDRkNDBlNzhlMWMxY2M=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-29T06:15:16Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-30T02:48:56Z"}, "message": "rustdoc: link to cross-crate sources directly.", "tree": {"sha": "edcaf8c71810e1bd3943ccb0061f8cd6cdbd9e44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edcaf8c71810e1bd3943ccb0061f8cd6cdbd9e44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/900191891fc5462d4ef33756a7d4d40e78e1c1cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/900191891fc5462d4ef33756a7d4d40e78e1c1cc", "html_url": "https://github.com/rust-lang/rust/commit/900191891fc5462d4ef33756a7d4d40e78e1c1cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/900191891fc5462d4ef33756a7d4d40e78e1c1cc/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "177913b49c1f5df106c64599e649323882644dc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/177913b49c1f5df106c64599e649323882644dc1", "html_url": "https://github.com/rust-lang/rust/commit/177913b49c1f5df106c64599e649323882644dc1"}], "stats": {"total": 391, "additions": 173, "deletions": 218}, "files": [{"sha": "bf739abe3da0dc65134672eb5d6b3ad1b324e0db", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=900191891fc5462d4ef33756a7d4d40e78e1c1cc", "patch": "@@ -115,7 +115,7 @@ fn try_inline_def(cx: &DocContext, def: Def) -> Option<Vec<clean::Item>> {\n     let did = def.def_id();\n     cx.renderinfo.borrow_mut().inlined.insert(did);\n     ret.push(clean::Item {\n-        source: clean::Span::empty(),\n+        source: tcx.def_span(did).clean(cx),\n         name: Some(tcx.item_name(did).to_string()),\n         attrs: load_attrs(cx, did),\n         inner: inner,\n@@ -321,7 +321,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n                     clean::RegionBound(..) => unreachable!(),\n                 },\n             }),\n-            source: clean::Span::empty(),\n+            source: tcx.def_span(did).clean(cx),\n             name: None,\n             attrs: attrs,\n             visibility: Some(clean::Inherited),\n@@ -357,7 +357,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n                         tcx.item_type(item.def_id).clean(cx),\n                         default,\n                     ),\n-                    source: clean::Span::empty(),\n+                    source: tcx.def_span(item.def_id).clean(cx),\n                     attrs: clean::Attributes::default(),\n                     visibility: None,\n                     stability: tcx.lookup_stability(item.def_id).clean(cx),\n@@ -404,7 +404,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n                 Some(clean::Item {\n                     name: Some(item.name.clean(cx)),\n                     inner: clean::TypedefItem(typedef, true),\n-                    source: clean::Span::empty(),\n+                    source: tcx.def_span(item.def_id).clean(cx),\n                     attrs: clean::Attributes::default(),\n                     visibility: None,\n                     stability: tcx.lookup_stability(item.def_id).clean(cx),\n@@ -442,7 +442,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n             items: trait_items,\n             polarity: Some(polarity.clean(cx)),\n         }),\n-        source: clean::Span::empty(),\n+        source: tcx.def_span(did).clean(cx),\n         name: None,\n         attrs: attrs,\n         visibility: Some(clean::Inherited),"}, {"sha": "dba613ed1b6b37ea1673f71afe772ca5cc8bcb7b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 82, "deletions": 93, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=900191891fc5462d4ef33756a7d4d40e78e1c1cc", "patch": "@@ -27,11 +27,10 @@ use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n-use rustc_trans::back::link;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime::DefRegion::*;\n use rustc::hir::def::{Def, CtorKind};\n-use rustc::hir::def_id::{self, DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::print as pprust;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind};\n@@ -45,7 +44,6 @@ use std::rc::Rc;\n use std::slice;\n use std::sync::Arc;\n use std::u32;\n-use std::env::current_dir;\n use std::mem;\n \n use core::DocContext;\n@@ -110,19 +108,16 @@ pub struct Crate {\n     pub name: String,\n     pub src: PathBuf,\n     pub module: Option<Item>,\n-    pub externs: Vec<(def_id::CrateNum, ExternalCrate)>,\n-    pub primitives: Vec<PrimitiveType>,\n+    pub externs: Vec<(CrateNum, ExternalCrate)>,\n+    pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n     pub access_levels: Arc<AccessLevels<DefId>>,\n     // These are later on moved into `CACHEKEY`, leaving the map empty.\n     // Only here so that they can be filtered through the rustdoc passes.\n     pub external_traits: FxHashMap<DefId, Trait>,\n }\n \n-struct CrateNum(def_id::CrateNum);\n-\n impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     fn clean(&self, cx: &DocContext) -> Crate {\n-        use rustc::session::config::Input;\n         use ::visit_lib::LibEmbargoVisitor;\n \n         {\n@@ -133,83 +128,41 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         let mut externs = Vec::new();\n         for cnum in cx.sess().cstore.crates() {\n-            externs.push((cnum, CrateNum(cnum).clean(cx)));\n+            externs.push((cnum, cnum.clean(cx)));\n             // Analyze doc-reachability for extern items\n             LibEmbargoVisitor::new(cx).visit_lib(cnum);\n         }\n         externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n-        // Figure out the name of this crate\n-        let input = &cx.input;\n-        let name = link::find_crate_name(None, &self.attrs, input);\n-\n         // Clean the crate, translating the entire libsyntax AST to one that is\n         // understood by rustdoc.\n         let mut module = self.module.clean(cx);\n \n-        // Collect all inner modules which are tagged as implementations of\n-        // primitives.\n-        //\n-        // Note that this loop only searches the top-level items of the crate,\n-        // and this is intentional. If we were to search the entire crate for an\n-        // item tagged with `#[doc(primitive)]` then we would also have to\n-        // search the entirety of external modules for items tagged\n-        // `#[doc(primitive)]`, which is a pretty inefficient process (decoding\n-        // all that metadata unconditionally).\n-        //\n-        // In order to keep the metadata load under control, the\n-        // `#[doc(primitive)]` feature is explicitly designed to only allow the\n-        // primitive tags to show up as the top level items in a crate.\n-        //\n-        // Also note that this does not attempt to deal with modules tagged\n-        // duplicately for the same primitive. This is handled later on when\n-        // rendering by delegating everything to a hash map.\n-        let mut primitives = Vec::new();\n+        let ExternalCrate { name, src, primitives, .. } = LOCAL_CRATE.clean(cx);\n         {\n             let m = match module.inner {\n                 ModuleItem(ref mut m) => m,\n                 _ => unreachable!(),\n             };\n-            let mut tmp = Vec::new();\n-            for child in &mut m.items {\n-                if !child.is_mod() {\n-                    continue;\n-                }\n-                let prim = match PrimitiveType::find(&child.attrs) {\n-                    Some(prim) => prim,\n-                    None => continue,\n-                };\n-                primitives.push(prim);\n-                tmp.push(Item {\n+            m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| {\n+                Item {\n                     source: Span::empty(),\n                     name: Some(prim.to_url_str().to_string()),\n-                    attrs: child.attrs.clone(),\n+                    attrs: attrs.clone(),\n                     visibility: Some(Public),\n                     stability: None,\n                     deprecation: None,\n-                    def_id: DefId::local(prim.to_def_index()),\n+                    def_id: def_id,\n                     inner: PrimitiveItem(prim),\n-                });\n-            }\n-            m.items.extend(tmp);\n-        }\n-\n-        let src = match cx.input {\n-            Input::File(ref path) => {\n-                if path.is_absolute() {\n-                    path.clone()\n-                } else {\n-                    current_dir().unwrap().join(path)\n                 }\n-            },\n-            Input::Str { ref name, .. } => PathBuf::from(name.clone()),\n-        };\n+            }));\n+        }\n \n         let mut access_levels = cx.access_levels.borrow_mut();\n         let mut external_traits = cx.external_traits.borrow_mut();\n \n         Crate {\n-            name: name.to_string(),\n+            name: name,\n             src: src,\n             module: Some(module),\n             externs: externs,\n@@ -223,21 +176,78 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ExternalCrate {\n     pub name: String,\n+    pub src: PathBuf,\n     pub attrs: Attributes,\n-    pub primitives: Vec<PrimitiveType>,\n+    pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n }\n \n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext) -> ExternalCrate {\n-        let mut primitives = Vec::new();\n-        let root = DefId { krate: self.0, index: CRATE_DEF_INDEX };\n-        for item in cx.tcx.sess.cstore.item_children(root) {\n-            let attrs = inline::load_attrs(cx, item.def.def_id());\n-            PrimitiveType::find(&attrs).map(|prim| primitives.push(prim));\n-        }\n+        let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n+        let krate_span = cx.tcx.def_span(root);\n+        let krate_src = cx.sess().codemap().span_to_filename(krate_span);\n+\n+        // Collect all inner modules which are tagged as implementations of\n+        // primitives.\n+        //\n+        // Note that this loop only searches the top-level items of the crate,\n+        // and this is intentional. If we were to search the entire crate for an\n+        // item tagged with `#[doc(primitive)]` then we would also have to\n+        // search the entirety of external modules for items tagged\n+        // `#[doc(primitive)]`, which is a pretty inefficient process (decoding\n+        // all that metadata unconditionally).\n+        //\n+        // In order to keep the metadata load under control, the\n+        // `#[doc(primitive)]` feature is explicitly designed to only allow the\n+        // primitive tags to show up as the top level items in a crate.\n+        //\n+        // Also note that this does not attempt to deal with modules tagged\n+        // duplicately for the same primitive. This is handled later on when\n+        // rendering by delegating everything to a hash map.\n+        let as_primitive = |def: Def| {\n+            if let Def::Mod(def_id) = def {\n+                let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n+                let mut prim = None;\n+                for attr in attrs.lists(\"doc\") {\n+                    if let Some(v) = attr.value_str() {\n+                        if attr.check_name(\"primitive\") {\n+                            prim = PrimitiveType::from_str(&v.as_str());\n+                            if prim.is_some() {\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+                return prim.map(|p| (def_id, p, attrs));\n+            }\n+            None\n+        };\n+        let primitives = if root.is_local() {\n+            cx.tcx.map.krate().module.item_ids.iter().filter_map(|&id| {\n+                let item = cx.tcx.map.expect_item(id.id);\n+                match item.node {\n+                    hir::ItemMod(_) => {\n+                        as_primitive(Def::Mod(cx.tcx.map.local_def_id(id.id)))\n+                    }\n+                    hir::ItemUse(ref path, hir::UseKind::Single)\n+                    if item.vis == hir::Visibility::Public => {\n+                        as_primitive(path.def).map(|(_, prim, attrs)| {\n+                            // Pretend the primitive is local.\n+                            (cx.tcx.map.local_def_id(id.id), prim, attrs)\n+                        })\n+                    }\n+                    _ => None\n+                }\n+            }).collect()\n+        } else {\n+            cx.tcx.sess.cstore.item_children(root).iter().map(|item| item.def)\n+              .filter_map(as_primitive).collect()\n+        };\n+\n         ExternalCrate {\n-            name: cx.sess().cstore.crate_name(self.0).to_string(),\n-            attrs: cx.sess().cstore.item_attrs(root).clean(cx),\n+            name: cx.tcx.crate_name(*self).to_string(),\n+            src: PathBuf::from(krate_src),\n+            attrs: cx.tcx.get_attrs(root).clean(cx),\n             primitives: primitives,\n         }\n     }\n@@ -1460,7 +1470,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n             deprecation: get_deprecation(cx, self.def_id),\n             def_id: self.def_id,\n             attrs: inline::load_attrs(cx, self.def_id),\n-            source: Span::empty(),\n+            source: cx.tcx.def_span(self.def_id).clean(cx),\n             inner: inner,\n         }\n     }\n@@ -1618,19 +1628,6 @@ impl PrimitiveType {\n         }\n     }\n \n-    fn find(attrs: &Attributes) -> Option<PrimitiveType> {\n-        for attr in attrs.lists(\"doc\") {\n-            if let Some(v) = attr.value_str() {\n-                if attr.check_name(\"primitive\") {\n-                    if let ret@Some(..) = PrimitiveType::from_str(&v.as_str()) {\n-                        return ret;\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n     pub fn as_str(&self) -> &'static str {\n         match *self {\n             PrimitiveType::Isize => \"isize\",\n@@ -1658,14 +1655,6 @@ impl PrimitiveType {\n     pub fn to_url_str(&self) -> &'static str {\n         self.as_str()\n     }\n-\n-    /// Creates a rustdoc-specific node id for primitive types.\n-    ///\n-    /// These node ids are generally never used by the AST itself.\n-    pub fn to_def_index(&self) -> DefIndex {\n-        let x = u32::MAX - 1 - (*self as u32);\n-        DefIndex::new(x as usize)\n-    }\n }\n \n impl From<ast::IntTy> for PrimitiveType {\n@@ -1948,7 +1937,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n         Item {\n             name: Some(self.name).clean(cx),\n             attrs: cx.tcx.get_attrs(self.did).clean(cx),\n-            source: Span::empty(),\n+            source: cx.tcx.def_span(self.did).clean(cx),\n             visibility: self.vis.clean(cx),\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n@@ -2115,7 +2104,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                     fields_stripped: false,\n                     fields: self.fields.iter().map(|field| {\n                         Item {\n-                            source: Span::empty(),\n+                            source: cx.tcx.def_span(field.did).clean(cx),\n                             name: Some(field.name.clean(cx)),\n                             attrs: cx.tcx.get_attrs(field.did).clean(cx),\n                             visibility: field.vis.clean(cx),\n@@ -2131,7 +2120,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: inline::load_attrs(cx, self.did),\n-            source: Span::empty(),\n+            source: cx.tcx.def_span(self.did).clean(cx),\n             visibility: Some(Inherited),\n             def_id: self.did,\n             inner: VariantItem(Variant { kind: kind }),"}, {"sha": "df25473ddd91666640bcaabc9e22a14181b1c48f", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=900191891fc5462d4ef33756a7d4d40e78e1c1cc", "patch": "@@ -45,7 +45,6 @@ pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub input: Input,\n     pub populated_all_crate_impls: Cell<bool>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n@@ -187,7 +186,6 @@ pub fn run_core(search_paths: SearchPaths,\n \n         let ctxt = DocContext {\n             tcx: tcx,\n-            input: input,\n             populated_all_crate_impls: Cell::new(false),\n             access_levels: RefCell::new(access_levels),\n             external_traits: Default::default(),"}, {"sha": "6dc6e80dae0b81fb926e5238e145fedcb07704ce", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=900191891fc5462d4ef33756a7d4d40e78e1c1cc", "patch": "@@ -18,7 +18,7 @@\n use std::fmt;\n use std::iter::repeat;\n \n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::DefId;\n use syntax::abi::Abi;\n use rustc::hir;\n \n@@ -403,9 +403,9 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n         None => match cache.external_paths.get(&did) {\n             Some(&(ref fqp, shortty)) => {\n                 (fqp, shortty, match cache.extern_locations[&did.krate] {\n-                    (_, render::Remote(ref s)) => s.to_string(),\n-                    (_, render::Local) => repeat(\"../\").take(loc.len()).collect(),\n-                    (_, render::Unknown) => return None,\n+                    (.., render::Remote(ref s)) => s.to_string(),\n+                    (.., render::Local) => repeat(\"../\").take(loc.len()).collect(),\n+                    (.., render::Unknown) => return None,\n                 })\n             }\n             None => return None,\n@@ -479,22 +479,24 @@ fn primitive_link(f: &mut fmt::Formatter,\n     let mut needs_termination = false;\n     if !f.alternate() {\n         match m.primitive_locations.get(&prim) {\n-            Some(&LOCAL_CRATE) => {\n+            Some(&def_id) if def_id.is_local() => {\n                 let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n                 let len = if len == 0 {0} else {len - 1};\n                 write!(f, \"<a class='primitive' href='{}primitive.{}.html'>\",\n                        repeat(\"../\").take(len).collect::<String>(),\n                        prim.to_url_str())?;\n                 needs_termination = true;\n             }\n-            Some(&cnum) => {\n-                let loc = match m.extern_locations[&cnum] {\n-                    (ref cname, render::Remote(ref s)) => Some((cname, s.to_string())),\n-                    (ref cname, render::Local) => {\n+            Some(&def_id) => {\n+                let loc = match m.extern_locations[&def_id.krate] {\n+                    (ref cname, _, render::Remote(ref s)) => {\n+                        Some((cname, s.to_string()))\n+                    }\n+                    (ref cname, _, render::Local) => {\n                         let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n                         Some((cname, repeat(\"../\").take(len).collect::<String>()))\n                     }\n-                    (_, render::Unknown) => None,\n+                    (.., render::Unknown) => None,\n                 };\n                 if let Some((cname, root)) = loc {\n                     write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\","}, {"sha": "cbf93662811da6ee046cf69269cb93e0dbbc36fe", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 70, "deletions": 96, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=900191891fc5462d4ef33756a7d4d40e78e1c1cc", "patch": "@@ -55,7 +55,7 @@ use externalfiles::ExternalHtml;\n use serialize::json::{ToJson, Json, as_json};\n use syntax::{abi, ast};\n use syntax::feature_gate::UnstableFeatures;\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::hir;\n@@ -241,10 +241,10 @@ pub struct Cache {\n     pub implementors: FxHashMap<DefId, Vec<Implementor>>,\n \n     /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FxHashMap<CrateNum, (String, ExternalLocation)>,\n+    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n \n     /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FxHashMap<clean::PrimitiveType, CrateNum>,\n+    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n@@ -523,8 +523,13 @@ pub fn run(mut krate: clean::Crate,\n \n     // Cache where all our extern crates are located\n     for &(n, ref e) in &krate.externs {\n-        cache.extern_locations.insert(n, (e.name.clone(),\n+        let src_root = match Path::new(&e.src).parent() {\n+            Some(p) => p.to_path_buf(),\n+            None => PathBuf::new(),\n+        };\n+        cache.extern_locations.insert(n, (e.name.clone(), src_root,\n                                           extern_location(e, &cx.dst)));\n+\n         let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n         cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n     }\n@@ -533,13 +538,13 @@ pub fn run(mut krate: clean::Crate,\n     //\n     // Favor linking to as local extern as possible, so iterate all crates in\n     // reverse topological order.\n-    for &(n, ref e) in krate.externs.iter().rev() {\n-        for &prim in &e.primitives {\n-            cache.primitive_locations.insert(prim, n);\n+    for &(_, ref e) in krate.externs.iter().rev() {\n+        for &(def_id, prim, _) in &e.primitives {\n+            cache.primitive_locations.insert(prim, def_id);\n         }\n     }\n-    for &prim in &krate.primitives {\n-        cache.primitive_locations.insert(prim, LOCAL_CRATE);\n+    for &(def_id, prim, _) in &krate.primitives {\n+        cache.primitive_locations.insert(prim, def_id);\n     }\n \n     cache.stack.push(krate.name.clone());\n@@ -875,6 +880,8 @@ impl<'a> DocFolder for SourceCollector<'a> {\n         if self.scx.include_sources\n             // skip all invalid spans\n             && item.source.filename != \"\"\n+            // skip non-local items\n+            && item.def_id.is_local()\n             // Macros from other libraries get special filenames which we can\n             // safely ignore.\n             && !(item.source.filename.starts_with(\"<\")\n@@ -1127,13 +1134,15 @@ impl DocFolder for Cache {\n                         true\n                     }\n                     ref t => {\n-                        match t.primitive_type() {\n-                            Some(prim) => {\n-                                let did = DefId::local(prim.to_def_index());\n+                        let prim_did = t.primitive_type().and_then(|t| {\n+                            self.primitive_locations.get(&t).cloned()\n+                        });\n+                        match prim_did {\n+                            Some(did) => {\n                                 self.parent_stack.push(did);\n                                 true\n                             }\n-                            _ => false,\n+                            None => false,\n                         }\n                     }\n                 }\n@@ -1158,10 +1167,7 @@ impl DocFolder for Cache {\n                         }\n                         ref t => {\n                             t.primitive_type().and_then(|t| {\n-                                self.primitive_locations.get(&t).map(|n| {\n-                                    let id = t.to_def_index();\n-                                    DefId { krate: *n, index: id }\n-                                })\n+                                self.primitive_locations.get(&t).cloned()\n                             })\n                         }\n                     }\n@@ -1439,79 +1445,50 @@ impl<'a> Item<'a> {\n     /// If `None` is returned, then a source link couldn't be generated. This\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n-    fn href(&self) -> Option<String> {\n-        let href = if self.item.source.loline == self.item.source.hiline {\n-            format!(\"{}\", self.item.source.loline)\n-        } else {\n-            format!(\"{}-{}\", self.item.source.loline, self.item.source.hiline)\n-        };\n+    fn src_href(&self) -> Option<String> {\n+        let mut root = self.cx.root_path();\n \n-        // First check to see if this is an imported macro source. In this case\n-        // we need to handle it specially as cross-crate inlined macros have...\n-        // odd locations!\n-        let imported_macro_from = match self.item.inner {\n-            clean::MacroItem(ref m) => m.imported_from.as_ref(),\n-            _ => None,\n-        };\n-        if let Some(krate) = imported_macro_from {\n-            let cache = cache();\n-            let root = cache.extern_locations.values().find(|&&(ref n, _)| {\n-                *krate == *n\n-            }).map(|l| &l.1);\n-            let root = match root {\n-                Some(&Remote(ref s)) => s.to_string(),\n-                Some(&Local) => self.cx.root_path(),\n-                None | Some(&Unknown) => return None,\n-            };\n-            Some(format!(\"{root}/{krate}/macro.{name}.html?gotomacrosrc=1\",\n-                         root = root,\n-                         krate = krate,\n-                         name = self.item.name.as_ref().unwrap()))\n-\n-        // If this item is part of the local crate, then we're guaranteed to\n-        // know the span, so we plow forward and generate a proper url. The url\n-        // has anchors for the line numbers that we're linking to.\n-        } else if self.item.def_id.is_local() {\n+        let cache = cache();\n+        let mut path = String::new();\n+        let (krate, path) = if self.item.def_id.is_local() {\n             let path = PathBuf::from(&self.item.source.filename);\n-            self.cx.shared.local_sources.get(&path).map(|path| {\n-                format!(\"{root}src/{krate}/{path}#{href}\",\n-                        root = self.cx.root_path(),\n-                        krate = self.cx.shared.layout.krate,\n-                        path = path,\n-                        href = href)\n-            })\n-        // If this item is not part of the local crate, then things get a little\n-        // trickier. We don't actually know the span of the external item, but\n-        // we know that the documentation on the other end knows the span!\n-        //\n-        // In this case, we generate a link to the *documentation* for this type\n-        // in the original crate. There's an extra URL parameter which says that\n-        // we want to go somewhere else, and the JS on the destination page will\n-        // pick it up and instantly redirect the browser to the source code.\n-        //\n-        // If we don't know where the external documentation for this crate is\n-        // located, then we return `None`.\n+            if let Some(path) = self.cx.shared.local_sources.get(&path) {\n+                (&self.cx.shared.layout.krate, path)\n+            } else {\n+                return None;\n+            }\n         } else {\n-            let cache = cache();\n-            let external_path = match cache.external_paths.get(&self.item.def_id) {\n-                Some(&(ref path, _)) => path,\n-                None => return None,\n-            };\n-            let mut path = match cache.extern_locations.get(&self.item.def_id.krate) {\n-                Some(&(_, Remote(ref s))) => s.to_string(),\n-                Some(&(_, Local)) => self.cx.root_path(),\n-                Some(&(_, Unknown)) => return None,\n-                None => return None,\n+            let (krate, src_root) = match cache.extern_locations.get(&self.item.def_id.krate) {\n+                Some(&(ref name, ref src, Local)) => (name, src),\n+                Some(&(ref name, ref src, Remote(ref s))) => {\n+                    root = s.to_string();\n+                    (name, src)\n+                }\n+                Some(&(_, _, Unknown)) | None => return None,\n             };\n-            for item in &external_path[..external_path.len() - 1] {\n-                path.push_str(item);\n-                path.push_str(\"/\");\n-            }\n-            Some(format!(\"{path}{file}?gotosrc={goto}\",\n-                         path = path,\n-                         file = item_path(self.item.type_(), external_path.last().unwrap()),\n-                         goto = self.item.def_id.index.as_usize()))\n-        }\n+\n+            let file = Path::new(&self.item.source.filename);\n+            clean_srcpath(&src_root, file, false, |component| {\n+                path.push_str(component);\n+                path.push('/');\n+            });\n+            let mut fname = file.file_name().expect(\"source has no filename\")\n+                                .to_os_string();\n+            fname.push(\".html\");\n+            path.push_str(&fname.to_string_lossy());\n+            (krate, &path)\n+        };\n+\n+        let lines = if self.item.source.loline == self.item.source.hiline {\n+            format!(\"{}\", self.item.source.loline)\n+        } else {\n+            format!(\"{}-{}\", self.item.source.loline, self.item.source.hiline)\n+        };\n+        Some(format!(\"{root}src/{krate}/{path}#{lines}\",\n+                     root = root,\n+                     krate = krate,\n+                     path = path,\n+                     lines = lines))\n     }\n }\n \n@@ -1576,10 +1553,9 @@ impl<'a> fmt::Display for Item<'a> {\n         // this page, and this link will be auto-clicked. The `id` attribute is\n         // used to find the link to auto-click.\n         if self.cx.shared.include_sources && !self.item.is_primitive() {\n-            if let Some(l) = self.href() {\n-                write!(fmt, \"<a id='src-{}' class='srclink' \\\n-                              href='{}' title='{}'>[src]</a>\",\n-                       self.item.def_id.index.as_usize(), l, \"goto source code\")?;\n+            if let Some(l) = self.src_href() {\n+                write!(fmt, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n+                       l, \"goto source code\")?;\n             }\n         }\n \n@@ -2781,8 +2757,7 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n         render_assoc_items(w, cx, container_item, did, what)\n     } else {\n         if let Some(prim) = target.primitive_type() {\n-            if let Some(c) = cache().primitive_locations.get(&prim) {\n-                let did = DefId { krate: *c, index: prim.to_def_index() };\n+            if let Some(&did) = cache().primitive_locations.get(&prim) {\n                 render_assoc_items(w, cx, container_item, did, what)?;\n             }\n         }\n@@ -2796,12 +2771,11 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         write!(w, \"<h3 class='impl'><span class='in-band'><code>{}</code>\", i.inner_impl())?;\n         write!(w, \"</span><span class='out-of-band'>\")?;\n         let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n-        if let Some(l) = (Item { item: &i.impl_item, cx: cx }).href() {\n+        if let Some(l) = (Item { item: &i.impl_item, cx: cx }).src_href() {\n             write!(w, \"<div class='ghost'></div>\")?;\n             render_stability_since_raw(w, since, outer_version)?;\n-            write!(w, \"<a id='src-{}' class='srclink' \\\n-                       href='{}' title='{}'>[src]</a>\",\n-                   i.impl_item.def_id.index.as_usize(), l, \"goto source code\")?;\n+            write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n+                   l, \"goto source code\")?;\n         } else {\n             render_stability_since_raw(w, since, outer_version)?;\n         }"}, {"sha": "6ea25fa1241f8c447c9e845f87dab6a1de786672", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=900191891fc5462d4ef33756a7d4d40e78e1c1cc", "patch": "@@ -923,15 +923,6 @@\n         window.register_implementors(window.pending_implementors);\n     }\n \n-    // See documentation in html/render.rs for what this is doing.\n-    var query = getQueryStringParams();\n-    if (query['gotosrc']) {\n-        window.location = $('#src-' + query['gotosrc']).attr('href');\n-    }\n-    if (query['gotomacrosrc']) {\n-        window.location = $('.srclink').attr('href');\n-    }\n-\n     function labelForToggleButton(sectionIsCollapsed) {\n         if (sectionIsCollapsed) {\n             // button will expand the section"}, {"sha": "12f880421616f513810adc561fffd23cc84fe310", "filename": "src/test/rustdoc/issue-34274.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Ftest%2Frustdoc%2Fissue-34274.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Ftest%2Frustdoc%2Fissue-34274.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-34274.rs?ref=900191891fc5462d4ef33756a7d4d40e78e1c1cc", "patch": "@@ -16,5 +16,5 @@\n \n extern crate issue_34274;\n \n-// @has foo/fn.extern_c_fn.html '//a/@href' '../issue_34274/fn.extern_c_fn.html?gotosrc='\n+// @has foo/fn.extern_c_fn.html '//a/@href' '../src/issue_34274/issue-34274.rs.html#12'\n pub use issue_34274::extern_c_fn;"}, {"sha": "d3307bb4d42c1076f23e1df42d9f9c4392bafb38", "filename": "src/test/rustdoc/src-links-external.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Ftest%2Frustdoc%2Fsrc-links-external.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900191891fc5462d4ef33756a7d4d40e78e1c1cc/src%2Ftest%2Frustdoc%2Fsrc-links-external.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsrc-links-external.rs?ref=900191891fc5462d4ef33756a7d4d40e78e1c1cc", "patch": "@@ -11,12 +11,13 @@\n // aux-build:src-links-external.rs\n // build-aux-docs\n // ignore-cross-compile\n+// ignore-tidy-linelength\n \n #![crate_name = \"foo\"]\n \n extern crate src_links_external;\n \n-// @has foo/bar/index.html '//a/@href' '../src_links_external/index.html?gotosrc='\n+// @has foo/bar/index.html '//a/@href' '../../src/src_links_external/src-links-external.rs.html#11'\n pub use src_links_external as bar;\n \n-// @has foo/bar/struct.Foo.html '//a/@href' '../src_links_external/struct.Foo.html?gotosrc='\n+// @has foo/bar/struct.Foo.html '//a/@href' '../../src/src_links_external/src-links-external.rs.html#11'"}]}