{"sha": "e16243816251d66eb823ba7199259fcaac7d0deb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNjI0MzgxNjI1MWQ2NmViODIzYmE3MTk5MjU5ZmNhYWM3ZDBkZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-13T06:11:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-13T06:11:45Z"}, "message": "auto merge of #13919 : thomaslee/rust/thomaslee_proposed_tcpstream_open, r=alexcrichton\n\nBeen meaning to try my hand at something like this for a while, and noticed something similar mentioned as part of #13537. The suggestion on the original ticket is to use `TcpStream::open(&str)` to pass in a host + port string, but seems a little cleaner to pass in host and port separately -- so a signature like `TcpStream::open(&str, u16)`.\r\n\r\nAlso means we can use std::io::net::addrinfo directly instead of using e.g. liburl to parse the host+port pair from a string.\r\n\r\nOne outstanding issue in this PR that I'm not entirely sure how to address: in open_timeout, the timeout_ms will apply for every A record we find associated with a hostname -- probably not the intended behavior, but I didn't want to waste my time on elaborate alternatives until the general idea was a-OKed. :)\r\n\r\nAnyway, perhaps there are other reasons for us to prefer the original proposed syntax, but thought I'd get some thoughts on this. Maybe there are some solid reasons to prefer using liburl to do this stuff.", "tree": {"sha": "32dc563af8729e9937534e2716a035b33f903f31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32dc563af8729e9937534e2716a035b33f903f31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e16243816251d66eb823ba7199259fcaac7d0deb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e16243816251d66eb823ba7199259fcaac7d0deb", "html_url": "https://github.com/rust-lang/rust/commit/e16243816251d66eb823ba7199259fcaac7d0deb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e16243816251d66eb823ba7199259fcaac7d0deb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "967366e988a811ae0fb47d3ad5ce0499a1414a43", "url": "https://api.github.com/repos/rust-lang/rust/commits/967366e988a811ae0fb47d3ad5ce0499a1414a43", "html_url": "https://github.com/rust-lang/rust/commit/967366e988a811ae0fb47d3ad5ce0499a1414a43"}, {"sha": "218d01ef3321c40b091e3b77823f8bd857e87b93", "url": "https://api.github.com/repos/rust-lang/rust/commits/218d01ef3321c40b091e3b77823f8bd857e87b93", "html_url": "https://github.com/rust-lang/rust/commit/218d01ef3321c40b091e3b77823f8bd857e87b93"}], "stats": {"total": 393, "additions": 286, "deletions": 107}, "files": [{"sha": "e47e7dc33d8e4fd61a7b6f89d43c6434481118d8", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e16243816251d66eb823ba7199259fcaac7d0deb/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16243816251d66eb823ba7199259fcaac7d0deb/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=e16243816251d66eb823ba7199259fcaac7d0deb", "patch": "@@ -19,7 +19,6 @@ use util;\n \n use std::io::File;\n use std::io::fs;\n-use std::io::net::ip::{Ipv4Addr, SocketAddr};\n use std::io::net::tcp;\n use std::io::process::ProcessExit;\n use std::io::process;\n@@ -316,10 +315,7 @@ fn run_debuginfo_gdb_test(config: &config, props: &TestProps, testfile: &Path) {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(1000);\n                 let result = task::try(proc() {\n-                    tcp::TcpStream::connect(SocketAddr {\n-                        ip: Ipv4Addr(127, 0, 0, 1),\n-                        port: 5039,\n-                    }).unwrap();\n+                    tcp::TcpStream::connect(\"127.0.0.1\", 5039).unwrap();\n                 });\n                 if result.is_err() {\n                     continue;"}, {"sha": "731c46d6f4d50827a1f317a9c00630fa314dd8d9", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e16243816251d66eb823ba7199259fcaac7d0deb/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16243816251d66eb823ba7199259fcaac7d0deb/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=e16243816251d66eb823ba7199259fcaac7d0deb", "patch": "@@ -430,8 +430,19 @@ pub mod types {\n                     pub ai_socktype: c_int,\n                     pub ai_protocol: c_int,\n                     pub ai_addrlen: socklen_t,\n+\n+                    #[cfg(target_os = \"linux\")]\n                     pub ai_addr: *sockaddr,\n+\n+                    #[cfg(target_os = \"linux\")]\n+                    pub ai_canonname: *c_char,\n+\n+                    #[cfg(target_os = \"android\")]\n                     pub ai_canonname: *c_char,\n+\n+                    #[cfg(target_os = \"android\")]\n+                    pub ai_addr: *sockaddr,\n+\n                     pub ai_next: *addrinfo,\n                 }\n                 pub struct sockaddr_un {"}, {"sha": "0f8e37b4ee01139a43c1fc7106c44995e4bb0da1", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e16243816251d66eb823ba7199259fcaac7d0deb/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16243816251d66eb823ba7199259fcaac7d0deb/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e16243816251d66eb823ba7199259fcaac7d0deb", "patch": "@@ -83,11 +83,9 @@ Some examples of obvious things you might want to do\n \n     ```rust,should_fail\n     # #![allow(unused_must_use)]\n-    use std::io::net::ip::SocketAddr;\n     use std::io::net::tcp::TcpStream;\n \n-    let addr = from_str::<SocketAddr>(\"127.0.0.1:8080\").unwrap();\n-    let mut socket = TcpStream::connect(addr).unwrap();\n+    let mut socket = TcpStream::connect(\"127.0.0.1\", 8080).unwrap();\n     socket.write(bytes!(\"GET / HTTP/1.0\\n\\n\"));\n     let response = socket.read_to_end();\n     ```\n@@ -99,11 +97,9 @@ Some examples of obvious things you might want to do\n     # fn foo() {\n     # #![allow(dead_code)]\n     use std::io::{TcpListener, TcpStream};\n-    use std::io::net::ip::{Ipv4Addr, SocketAddr};\n     use std::io::{Acceptor, Listener};\n \n-    let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 80 };\n-    let listener = TcpListener::bind(addr);\n+    let listener = TcpListener::bind(\"127.0.0.1\", 80);\n \n     // bind the listener to the specified address\n     let mut acceptor = listener.listen();"}, {"sha": "0639611cc2466778d4189549c41146f2927de32e", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 262, "deletions": 90, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/e16243816251d66eb823ba7199259fcaac7d0deb/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16243816251d66eb823ba7199259fcaac7d0deb/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=e16243816251d66eb823ba7199259fcaac7d0deb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -19,8 +19,14 @@\n \n use clone::Clone;\n use io::IoResult;\n+use iter::Iterator;\n+use slice::ImmutableVector;\n+use result::{Ok,Err};\n+use io::net::addrinfo::get_host_addresses;\n use io::net::ip::SocketAddr;\n+use io::{IoError, ConnectionFailed, InvalidInput};\n use io::{Reader, Writer, Listener, Acceptor};\n+use from_str::FromStr;\n use kinds::Send;\n use option::{None, Some, Option};\n use owned::Box;\n@@ -35,10 +41,8 @@ use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n /// ```no_run\n /// # #![allow(unused_must_use)]\n /// use std::io::net::tcp::TcpStream;\n-/// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n ///\n-/// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n-/// let mut stream = TcpStream::connect(addr);\n+/// let mut stream = TcpStream::connect(\"127.0.0.1\", 34254);\n ///\n /// stream.write([1]);\n /// let mut buf = [0];\n@@ -54,13 +58,35 @@ impl TcpStream {\n         TcpStream { obj: s }\n     }\n \n-    /// Creates a TCP connection to a remote socket address.\n+    /// Open a TCP connection to a remote host by hostname or IP address.\n     ///\n-    /// If no error is encountered, then `Ok(stream)` is returned.\n-    pub fn connect(addr: SocketAddr) -> IoResult<TcpStream> {\n-        LocalIo::maybe_raise(|io| {\n-            io.tcp_connect(addr, None).map(TcpStream::new)\n-        })\n+    /// `host` can be a hostname or IP address string. If no error is\n+    /// encountered, then `Ok(stream)` is returned.\n+    pub fn connect(host: &str, port: u16) -> IoResult<TcpStream> {\n+        let addresses = match FromStr::from_str(host) {\n+            Some(addr) => vec!(addr),\n+            None => try!(get_host_addresses(host))\n+        };\n+        let mut err = IoError{\n+            kind: ConnectionFailed,\n+            desc: \"no addresses found for hostname\",\n+            detail: None\n+        };\n+        for address in addresses.iter() {\n+            let socket_addr = SocketAddr{ip: *address, port: port};\n+            let result = LocalIo::maybe_raise(|io| {\n+                io.tcp_connect(socket_addr, None).map(TcpStream::new)\n+            });\n+            match result {\n+                Ok(stream) => {\n+                    return Ok(stream)\n+                }\n+                Err(connect_err) => {\n+                    err = connect_err\n+                }\n+            }\n+        }\n+        Err(err)\n     }\n \n     /// Creates a TCP connection to a remote socket address, timing out after\n@@ -69,6 +95,9 @@ impl TcpStream {\n     /// This is the same as the `connect` method, except that if the timeout\n     /// specified (in milliseconds) elapses before a connection is made an error\n     /// will be returned. The error's kind will be `TimedOut`.\n+    ///\n+    /// Note that the `addr` argument may one day be split into a separate host\n+    /// and port, similar to the API seen in `connect`.\n     #[experimental = \"the timeout argument may eventually change types\"]\n     pub fn connect_timeout(addr: SocketAddr,\n                            timeout_ms: u64) -> IoResult<TcpStream> {\n@@ -121,10 +150,8 @@ impl TcpStream {\n     /// # #![allow(unused_must_use)]\n     /// use std::io::timer;\n     /// use std::io::net::tcp::TcpStream;\n-    /// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n     ///\n-    /// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n-    /// let mut stream = TcpStream::connect(addr).unwrap();\n+    /// let mut stream = TcpStream::connect(\"127.0.0.1\", 34254).unwrap();\n     /// let stream2 = stream.clone();\n     ///\n     /// spawn(proc() {\n@@ -251,11 +278,9 @@ impl Writer for TcpStream {\n /// # fn foo() {\n /// # #![allow(dead_code)]\n /// use std::io::{TcpListener, TcpStream};\n-/// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n /// use std::io::{Acceptor, Listener};\n ///\n-/// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 80 };\n-/// let listener = TcpListener::bind(addr);\n+/// let listener = TcpListener::bind(\"127.0.0.1\", 80);\n ///\n /// // bind the listener to the specified address\n /// let mut acceptor = listener.listen();\n@@ -284,17 +309,29 @@ pub struct TcpListener {\n }\n \n impl TcpListener {\n-    /// Creates a new `TcpListener` which will be bound to the specified local\n-    /// socket address. This listener is not ready for accepting connections,\n+    /// Creates a new `TcpListener` which will be bound to the specified IP\n+    /// and port. This listener is not ready for accepting connections,\n     /// `listen` must be called on it before that's possible.\n     ///\n     /// Binding with a port number of 0 will request that the OS assigns a port\n     /// to this listener. The port allocated can be queried via the\n     /// `socket_name` function.\n-    pub fn bind(addr: SocketAddr) -> IoResult<TcpListener> {\n-        LocalIo::maybe_raise(|io| {\n-            io.tcp_bind(addr).map(|l| TcpListener { obj: l })\n-        })\n+    pub fn bind(addr: &str, port: u16) -> IoResult<TcpListener> {\n+        match FromStr::from_str(addr) {\n+            Some(ip) => {\n+                let socket_addr = SocketAddr{ip: ip, port: port};\n+                LocalIo::maybe_raise(|io| {\n+                    io.tcp_bind(socket_addr).map(|l| TcpListener { obj: l })\n+                })\n+            }\n+            None => {\n+                Err(IoError{\n+                    kind: InvalidInput,\n+                    desc: \"invalid IP address specified\",\n+                    detail: None\n+                })\n+            }\n+        }\n     }\n \n     /// Returns the local socket address of this listener.\n@@ -338,11 +375,9 @@ impl TcpAcceptor {\n     /// ```no_run\n     /// # #![allow(experimental)]\n     /// use std::io::net::tcp::TcpListener;\n-    /// use std::io::net::ip::{SocketAddr, Ipv4Addr};\n     /// use std::io::{Listener, Acceptor, TimedOut};\n     ///\n-    /// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 8482 };\n-    /// let mut a = TcpListener::bind(addr).listen().unwrap();\n+    /// let mut a = TcpListener::bind(\"127.0.0.1\", 8482).listen().unwrap();\n     ///\n     /// // After 100ms have passed, all accepts will fail\n     /// a.set_timeout(Some(100));\n@@ -382,27 +417,96 @@ mod test {\n \n     // FIXME #11530 this fails on android because tests are run as root\n     iotest!(fn bind_error() {\n-        let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-        match TcpListener::bind(addr) {\n+        match TcpListener::bind(\"0.0.0.0\", 1) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, PermissionDenied),\n         }\n     } #[ignore(cfg(windows))] #[ignore(cfg(target_os = \"android\"))])\n \n     iotest!(fn connect_error() {\n-        let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-        match TcpStream::connect(addr) {\n+        match TcpStream::connect(\"0.0.0.0\", 1) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, ConnectionRefused),\n         }\n     })\n \n+    iotest!(fn listen_ip4_localhost() {\n+        let socket_addr = next_test_ip4();\n+        let ip_str = socket_addr.ip.to_str();\n+        let port = socket_addr.port;\n+        let listener = TcpListener::bind(ip_str, port);\n+        let mut acceptor = listener.listen();\n+\n+        spawn(proc() {\n+            let mut stream = TcpStream::connect(\"localhost\", port);\n+            stream.write([144]).unwrap();\n+        });\n+\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        stream.read(buf).unwrap();\n+        assert!(buf[0] == 144);\n+    })\n+\n+    iotest!(fn connect_localhost() {\n+        let addr = next_test_ip4();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+\n+        spawn(proc() {\n+            let mut stream = TcpStream::connect(\"localhost\", addr.port);\n+            stream.write([64]).unwrap();\n+        });\n+\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        stream.read(buf).unwrap();\n+        assert!(buf[0] == 64);\n+    })\n+\n+    iotest!(fn connect_ip4_loopback() {\n+        let addr = next_test_ip4();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+\n+        spawn(proc() {\n+            let mut stream = TcpStream::connect(\"127.0.0.1\", addr.port);\n+            stream.write([44]).unwrap();\n+        });\n+\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        stream.read(buf).unwrap();\n+        assert!(buf[0] == 44);\n+    })\n+\n+    iotest!(fn connect_ip6_loopback() {\n+        let addr = next_test_ip6();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+\n+        spawn(proc() {\n+            let mut stream = TcpStream::connect(\"::1\", addr.port);\n+            stream.write([66]).unwrap();\n+        });\n+\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        stream.read(buf).unwrap();\n+        assert!(buf[0] == 66);\n+    })\n+\n     iotest!(fn smoke_test_ip4() {\n         let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(addr);\n+            let mut stream = TcpStream::connect(ip_str, port);\n             stream.write([99]).unwrap();\n         });\n \n@@ -414,10 +518,12 @@ mod test {\n \n     iotest!(fn smoke_test_ip6() {\n         let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(addr);\n+            let mut stream = TcpStream::connect(ip_str, port);\n             stream.write([99]).unwrap();\n         });\n \n@@ -429,10 +535,12 @@ mod test {\n \n     iotest!(fn read_eof_ip4() {\n         let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(ip_str, port);\n             // Close\n         });\n \n@@ -444,10 +552,12 @@ mod test {\n \n     iotest!(fn read_eof_ip6() {\n         let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(ip_str, port);\n             // Close\n         });\n \n@@ -459,10 +569,12 @@ mod test {\n \n     iotest!(fn read_eof_twice_ip4() {\n         let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(ip_str, port);\n             // Close\n         });\n \n@@ -482,10 +594,12 @@ mod test {\n \n     iotest!(fn read_eof_twice_ip6() {\n         let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(ip_str, port);\n             // Close\n         });\n \n@@ -505,10 +619,12 @@ mod test {\n \n     iotest!(fn write_close_ip4() {\n         let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(ip_str, port);\n             // Close\n         });\n \n@@ -530,10 +646,12 @@ mod test {\n \n     iotest!(fn write_close_ip6() {\n         let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(ip_str, port);\n             // Close\n         });\n \n@@ -555,12 +673,14 @@ mod test {\n \n     iotest!(fn multiple_connect_serial_ip4() {\n         let addr = next_test_ip4();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n         let max = 10u;\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n             for _ in range(0, max) {\n-                let mut stream = TcpStream::connect(addr);\n+                let mut stream = TcpStream::connect(ip_str, port);\n                 stream.write([99]).unwrap();\n             }\n         });\n@@ -574,12 +694,14 @@ mod test {\n \n     iotest!(fn multiple_connect_serial_ip6() {\n         let addr = next_test_ip6();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n         let max = 10u;\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n             for _ in range(0, max) {\n-                let mut stream = TcpStream::connect(addr);\n+                let mut stream = TcpStream::connect(ip_str, port);\n                 stream.write([99]).unwrap();\n             }\n         });\n@@ -593,8 +715,10 @@ mod test {\n \n     iotest!(fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         let addr = next_test_ip4();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n         static MAX: int = 10;\n-        let acceptor = TcpListener::bind(addr).listen();\n+        let acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -613,11 +737,13 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n+            let ip_str = addr.ip.to_str();\n+            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n+                let mut stream = TcpStream::connect(ip_str, port);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -628,8 +754,10 @@ mod test {\n \n     iotest!(fn multiple_connect_interleaved_greedy_schedule_ip6() {\n         let addr = next_test_ip6();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n         static MAX: int = 10;\n-        let acceptor = TcpListener::bind(addr).listen();\n+        let acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -648,11 +776,13 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n+            let ip_str = addr.ip.to_str();\n+            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n+                let mut stream = TcpStream::connect(ip_str, port);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -664,7 +794,9 @@ mod test {\n     iotest!(fn multiple_connect_interleaved_lazy_schedule_ip4() {\n         static MAX: int = 10;\n         let addr = next_test_ip4();\n-        let acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -683,11 +815,13 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n+            let ip_str = addr.ip.to_str();\n+            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n+                let mut stream = TcpStream::connect(ip_str, port);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -699,7 +833,9 @@ mod test {\n     iotest!(fn multiple_connect_interleaved_lazy_schedule_ip6() {\n         static MAX: int = 10;\n         let addr = next_test_ip6();\n-        let acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -718,11 +854,13 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n+            let ip_str = addr.ip.to_str();\n+            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n+                let mut stream = TcpStream::connect(ip_str, port);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -732,7 +870,9 @@ mod test {\n     })\n \n     pub fn socket_name(addr: SocketAddr) {\n-        let mut listener = TcpListener::bind(addr).unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut listener = TcpListener::bind(ip_str, port).unwrap();\n \n         // Make sure socket_name gives\n         // us the socket we binded to.\n@@ -742,13 +882,15 @@ mod test {\n     }\n \n     pub fn peer_name(addr: SocketAddr) {\n-        let acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let acceptor = TcpListener::bind(ip_str, port).listen();\n         spawn(proc() {\n             let mut acceptor = acceptor;\n             acceptor.accept().unwrap();\n         });\n \n-        let stream = TcpStream::connect(addr);\n+        let stream = TcpStream::connect(ip_str, port);\n \n         assert!(stream.is_ok());\n         let mut stream = stream.unwrap();\n@@ -774,9 +916,11 @@ mod test {\n \n     iotest!(fn partial_read() {\n         let addr = next_test_ip4();\n+        let port = addr.port;\n         let (tx, rx) = channel();\n         spawn(proc() {\n-            let mut srv = TcpListener::bind(addr).listen().unwrap();\n+            let ip_str = addr.ip.to_str();\n+            let mut srv = TcpListener::bind(ip_str, port).listen().unwrap();\n             tx.send(());\n             let mut cl = srv.accept().unwrap();\n             cl.write([10]).unwrap();\n@@ -786,7 +930,8 @@ mod test {\n         });\n \n         rx.recv();\n-        let mut c = TcpStream::connect(addr).unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let mut c = TcpStream::connect(ip_str, port).unwrap();\n         let mut b = [0, ..10];\n         assert_eq!(c.read(b), Ok(1));\n         c.write([1]).unwrap();\n@@ -795,9 +940,11 @@ mod test {\n \n     iotest!(fn double_bind() {\n         let addr = next_test_ip4();\n-        let listener = TcpListener::bind(addr).unwrap().listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let listener = TcpListener::bind(ip_str, port).unwrap().listen();\n         assert!(listener.is_ok());\n-        match TcpListener::bind(addr).listen() {\n+        match TcpListener::bind(ip_str, port).listen() {\n             Ok(..) => fail!(),\n             Err(e) => {\n                 assert!(e.kind == ConnectionRefused || e.kind == OtherIoError);\n@@ -807,17 +954,20 @@ mod test {\n \n     iotest!(fn fast_rebind() {\n         let addr = next_test_ip4();\n+        let port = addr.port;\n         let (tx, rx) = channel();\n \n         spawn(proc() {\n+            let ip_str = addr.ip.to_str();\n             rx.recv();\n-            let _stream = TcpStream::connect(addr).unwrap();\n+            let _stream = TcpStream::connect(ip_str, port).unwrap();\n             // Close\n             rx.recv();\n         });\n \n         {\n-            let mut acceptor = TcpListener::bind(addr).listen();\n+            let ip_str = addr.ip.to_str();\n+            let mut acceptor = TcpListener::bind(ip_str, port).listen();\n             tx.send(());\n             {\n                 let _stream = acceptor.accept().unwrap();\n@@ -826,15 +976,17 @@ mod test {\n             }\n             // Close listener\n         }\n-        let _listener = TcpListener::bind(addr);\n+        let _listener = TcpListener::bind(addr.ip.to_str(), port);\n     })\n \n     iotest!(fn tcp_clone_smoke() {\n         let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr);\n+            let mut s = TcpStream::connect(ip_str, port);\n             let mut buf = [0, 0];\n             assert_eq!(s.read(buf), Ok(1));\n             assert_eq!(buf[0], 1);\n@@ -860,12 +1012,14 @@ mod test {\n \n     iotest!(fn tcp_clone_two_read() {\n         let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr);\n+            let mut s = TcpStream::connect(ip_str, port);\n             s.write([1]).unwrap();\n             rx.recv();\n             s.write([2]).unwrap();\n@@ -892,10 +1046,12 @@ mod test {\n \n     iotest!(fn tcp_clone_two_write() {\n         let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr);\n+            let mut s = TcpStream::connect(ip_str, port);\n             let mut buf = [0, 1];\n             s.read(buf).unwrap();\n             s.read(buf).unwrap();\n@@ -919,23 +1075,27 @@ mod test {\n         use rt::rtio::RtioTcpStream;\n \n         let addr = next_test_ip4();\n-        let a = TcpListener::bind(addr).unwrap().listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let a = TcpListener::bind(ip_str, port).unwrap().listen();\n         spawn(proc() {\n             let mut a = a;\n             let mut c = a.accept().unwrap();\n             assert_eq!(c.read_to_end(), Ok(vec!()));\n             c.write([1]).unwrap();\n         });\n \n-        let mut s = TcpStream::connect(addr).unwrap();\n+        let mut s = TcpStream::connect(ip_str, port).unwrap();\n         assert!(s.obj.close_write().is_ok());\n         assert!(s.write([1]).is_err());\n         assert_eq!(s.read_to_end(), Ok(vec!(1)));\n     })\n \n     iotest!(fn accept_timeout() {\n         let addr = next_test_ip4();\n-        let mut a = TcpListener::bind(addr).unwrap().listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut a = TcpListener::bind(ip_str, port).unwrap().listen().unwrap();\n \n         a.set_timeout(Some(10));\n \n@@ -954,7 +1114,7 @@ mod test {\n         if !cfg!(target_os = \"freebsd\") {\n             let (tx, rx) = channel();\n             spawn(proc() {\n-                tx.send(TcpStream::connect(addr).unwrap());\n+                tx.send(TcpStream::connect(addr.ip.to_str(), port).unwrap());\n             });\n             let l = rx.recv();\n             for i in range(0, 1001) {\n@@ -971,14 +1131,16 @@ mod test {\n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n         spawn(proc() {\n-            drop(TcpStream::connect(addr).unwrap());\n+            drop(TcpStream::connect(addr.ip.to_str(), port).unwrap());\n         });\n         a.accept().unwrap();\n     })\n \n     iotest!(fn close_readwrite_smoke() {\n         let addr = next_test_ip4();\n-        let a = TcpListener::bind(addr).listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let a = TcpListener::bind(ip_str, port).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n         spawn(proc() {\n             let mut a = a;\n@@ -987,7 +1149,7 @@ mod test {\n         });\n \n         let mut b = [0];\n-        let mut s = TcpStream::connect(addr).unwrap();\n+        let mut s = TcpStream::connect(ip_str, port).unwrap();\n         let mut s2 = s.clone();\n \n         // closing should prevent reads/writes\n@@ -1014,15 +1176,17 @@ mod test {\n \n     iotest!(fn close_read_wakes_up() {\n         let addr = next_test_ip4();\n-        let a = TcpListener::bind(addr).listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let a = TcpListener::bind(ip_str, port).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n         spawn(proc() {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv_opt();\n         });\n \n-        let mut s = TcpStream::connect(addr).unwrap();\n+        let mut s = TcpStream::connect(ip_str, port).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n         spawn(proc() {\n@@ -1039,10 +1203,12 @@ mod test {\n \n     iotest!(fn readwrite_timeouts() {\n         let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut a = TcpListener::bind(ip_str, port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr).unwrap();\n+            let mut s = TcpStream::connect(ip_str, port).unwrap();\n             rx.recv();\n             assert!(s.write([0]).is_ok());\n             let _ = rx.recv_opt();\n@@ -1071,10 +1237,12 @@ mod test {\n \n     iotest!(fn read_timeouts() {\n         let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut a = TcpListener::bind(ip_str, port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr).unwrap();\n+            let mut s = TcpStream::connect(ip_str, port).unwrap();\n             rx.recv();\n             let mut amt = 0;\n             while amt < 100 * 128 * 1024 {\n@@ -1099,10 +1267,12 @@ mod test {\n \n     iotest!(fn write_timeouts() {\n         let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut a = TcpListener::bind(ip_str, port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr).unwrap();\n+            let mut s = TcpStream::connect(ip_str, port).unwrap();\n             rx.recv();\n             assert!(s.write([0]).is_ok());\n             let _ = rx.recv_opt();\n@@ -1126,10 +1296,12 @@ mod test {\n \n     iotest!(fn timeout_concurrent_read() {\n         let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut a = TcpListener::bind(ip_str, port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr).unwrap();\n+            let mut s = TcpStream::connect(ip_str, port).unwrap();\n             rx.recv();\n             assert_eq!(s.write([0]), Ok(()));\n             let _ = rx.recv_opt();"}, {"sha": "5612c50142cafa045087fd00e075e8774b7ba0fe", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e16243816251d66eb823ba7199259fcaac7d0deb/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16243816251d66eb823ba7199259fcaac7d0deb/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=e16243816251d66eb823ba7199259fcaac7d0deb", "patch": "@@ -54,14 +54,16 @@ macro_rules! iotest (\n iotest!(fn eventual_timeout() {\n     use native;\n     let addr = next_test_ip4();\n+    let host = addr.ip.to_str();\n+    let port = addr.port;\n \n     // Use a native task to receive connections because it turns out libuv is\n     // really good at accepting connections and will likely run out of file\n     // descriptors before timing out.\n     let (tx1, rx1) = channel();\n     let (_tx2, rx2) = channel::<()>();\n     native::task::spawn(proc() {\n-        let _l = TcpListener::bind(addr).unwrap().listen();\n+        let _l = TcpListener::bind(host, port).unwrap().listen();\n         tx1.send(());\n         let _ = rx2.recv_opt();\n     });\n@@ -80,7 +82,9 @@ iotest!(fn eventual_timeout() {\n \n iotest!(fn timeout_success() {\n     let addr = next_test_ip4();\n-    let _l = TcpListener::bind(addr).unwrap().listen();\n+    let host = addr.ip.to_str();\n+    let port = addr.port;\n+    let _l = TcpListener::bind(host, port).unwrap().listen();\n \n     assert!(TcpStream::connect_timeout(addr, 1000).is_ok());\n })"}, {"sha": "f1a609b258498351fe1f7b3a8accbcb4121af889", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e16243816251d66eb823ba7199259fcaac7d0deb/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16243816251d66eb823ba7199259fcaac7d0deb/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=e16243816251d66eb823ba7199259fcaac7d0deb", "patch": "@@ -19,7 +19,6 @@ extern crate libc;\n extern crate green;\n extern crate rustuv;\n \n-use std::io::net::ip::{Ipv4Addr, SocketAddr};\n use std::io::net::tcp::{TcpListener, TcpStream};\n use std::io::{Acceptor, Listener};\n use std::task::TaskBuilder;\n@@ -38,10 +37,9 @@ fn main() {\n         unsafe { libc::exit(1) }\n     });\n \n-    let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 0 };\n     let (tx, rx) = channel();\n     spawn(proc() {\n-        let mut listener = TcpListener::bind(addr).unwrap();\n+        let mut listener = TcpListener::bind(\"127.0.0.1\", 0).unwrap();\n         tx.send(listener.socket_name().unwrap());\n         let mut acceptor = listener.listen();\n         loop {\n@@ -64,7 +62,9 @@ fn main() {\n         let mut builder = TaskBuilder::new();\n         builder.opts.stack_size = Some(32 * 1024);\n         builder.spawn(proc() {\n-            match TcpStream::connect(addr) {\n+            let host = addr.ip.to_str();\n+            let port = addr.port;\n+            match TcpStream::connect(host, port) {\n                 Ok(stream) => {\n                     let mut stream = stream;\n                     stream.write([1]);"}]}