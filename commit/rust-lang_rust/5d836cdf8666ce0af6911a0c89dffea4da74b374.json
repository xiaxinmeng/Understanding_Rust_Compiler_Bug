{"sha": "5d836cdf8666ce0af6911a0c89dffea4da74b374", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkODM2Y2RmODY2NmNlMGFmNjkxMWEwYzg5ZGZmZWE0ZGE3NGIzNzQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-23T18:46:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-27T00:01:58Z"}, "message": "std: Rename Writer::write to Writer::write_all\n\nIn preparation for upcoming changes to the `Writer` trait (soon to be called\n`Write`) this commit renames the current `write` method to `write_all` to match\nthe semantics of the upcoming `write_all` method. The `write` method will be\nrepurposed to return a `usize` indicating how much data was written which\ndiffers from the current `write` semantics. In order to head off as much\nunintended breakage as possible, the method is being deprecated now in favor of\na new name.\n\n[breaking-change]", "tree": {"sha": "a56491c0834f386aa44b9190d9ba493c60dce7b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a56491c0834f386aa44b9190d9ba493c60dce7b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d836cdf8666ce0af6911a0c89dffea4da74b374", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d836cdf8666ce0af6911a0c89dffea4da74b374", "html_url": "https://github.com/rust-lang/rust/commit/5d836cdf8666ce0af6911a0c89dffea4da74b374", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d836cdf8666ce0af6911a0c89dffea4da74b374/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a07f859b880bfe4dd6f095c959422d7c6b53831", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a07f859b880bfe4dd6f095c959422d7c6b53831", "html_url": "https://github.com/rust-lang/rust/commit/3a07f859b880bfe4dd6f095c959422d7c6b53831"}], "stats": {"total": 455, "additions": 229, "deletions": 226}, "files": [{"sha": "7f3865308da1ec158f73d854822b7db565fa893f", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -47,7 +47,7 @@ pub fn run(lib_path: &str,\n     match cmd.spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n-                process.stdin.as_mut().unwrap().write(input.as_bytes()).unwrap();\n+                process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n             }\n             let ProcessOutput { status, output, error } =\n                 process.wait_with_output().unwrap();\n@@ -79,7 +79,7 @@ pub fn run_background(lib_path: &str,\n     match cmd.spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n-                process.stdin.as_mut().unwrap().write(input.as_bytes()).unwrap();\n+                process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n             }\n \n             Some(process)"}, {"sha": "0ae32bd00a4a101876f08509049c508f33812998", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -1401,7 +1401,7 @@ fn dump_output(config: &Config, testfile: &Path, out: &str, err: &str) {\n fn dump_output_file(config: &Config, testfile: &Path,\n                     out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n-    File::create(&outfile).write(out.as_bytes()).unwrap();\n+    File::create(&outfile).write_all(out.as_bytes()).unwrap();\n }\n \n fn make_out_name(config: &Config, testfile: &Path, extension: &str) -> Path {"}, {"sha": "dba355373ce64256d5bdc6b9e1163137d7b3c430", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -170,7 +170,7 @@ mod u32 {\n     use test::Bencher;\n     use core::fmt::radix;\n     use std::rand::{weak_rng, Rng};\n-    use std::io::util::NullWriter;\n+    use std::old_io::util::NullWriter;\n \n     #[bench]\n     fn format_bin(b: &mut Bencher) {\n@@ -213,7 +213,7 @@ mod i32 {\n     use test::Bencher;\n     use core::fmt::radix;\n     use std::rand::{weak_rng, Rng};\n-    use std::io::util::NullWriter;\n+    use std::old_io::util::NullWriter;\n \n     #[bench]\n     fn format_bin(b: &mut Bencher) {"}, {"sha": "13ddad1fee256c8589949569bd3ae898fb85fc65", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -80,7 +80,7 @@ impl SeekableMemWriter {\n \n impl Writer for SeekableMemWriter {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         if self.pos == self.buf.len() {\n             self.buf.push_all(buf)\n         } else {"}, {"sha": "37a17a2736944ae4b83365a062df0d3432f4c1d4", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -708,11 +708,11 @@ pub mod writer {\n \n     fn write_sized_vuint<W: Writer>(w: &mut W, n: uint, size: uint) -> EncodeResult {\n         match size {\n-            1u => w.write(&[0x80u8 | (n as u8)]),\n-            2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n-            3u => w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n+            1u => w.write_all(&[0x80u8 | (n as u8)]),\n+            2u => w.write_all(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n+            3u => w.write_all(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n                             n as u8]),\n-            4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n+            4u => w.write_all(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n                             (n >> 8_u) as u8, n as u8]),\n             _ => Err(old_io::IoError {\n                 kind: old_io::OtherIoError,\n@@ -760,7 +760,7 @@ pub mod writer {\n             // Write a placeholder four-byte size.\n             self.size_positions.push(try!(self.writer.tell()) as uint);\n             let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n-            self.writer.write(zeroes)\n+            self.writer.write_all(zeroes)\n         }\n \n         pub fn end_tag(&mut self) -> EncodeResult {\n@@ -786,7 +786,7 @@ pub mod writer {\n         pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) -> EncodeResult {\n             try!(write_vuint(self.writer, tag_id));\n             try!(write_vuint(self.writer, b.len()));\n-            self.writer.write(b)\n+            self.writer.write_all(b)\n         }\n \n         pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) -> EncodeResult {\n@@ -839,12 +839,12 @@ pub mod writer {\n \n         pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n             debug!(\"Write {:?} bytes\", b.len());\n-            self.writer.write(b)\n+            self.writer.write_all(b)\n         }\n \n         pub fn wr_str(&mut self, s: &str) -> EncodeResult {\n             debug!(\"Write str: {:?}\", s);\n-            self.writer.write(s.as_bytes())\n+            self.writer.write_all(s.as_bytes())\n         }\n     }\n "}, {"sha": "f6c5ba4b52bc8c84da3bf399a8b8881d79472eae", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -122,7 +122,7 @@ fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n // Item info table encoding\n fn encode_family(rbml_w: &mut Encoder, c: char) {\n     rbml_w.start_tag(tag_items_data_item_family);\n-    rbml_w.writer.write(&[c as u8]);\n+    rbml_w.writer.write_all(&[c as u8]);\n     rbml_w.end_tag();\n }\n \n@@ -149,7 +149,7 @@ fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.start_tag(tag_items_data_item_variant);\n     let s = def_to_string(vid);\n-    rbml_w.writer.write(s.as_bytes());\n+    rbml_w.writer.write_all(s.as_bytes());\n     rbml_w.end_tag();\n \n     rbml_w.start_tag(tag_mod_child);\n@@ -259,7 +259,7 @@ fn encode_symbol(ecx: &EncodeContext,\n     match ecx.item_symbols.borrow().get(&id) {\n         Some(x) => {\n             debug!(\"encode_symbol(id={}, str={})\", id, *x);\n-            rbml_w.writer.write(x.as_bytes());\n+            rbml_w.writer.write_all(x.as_bytes());\n         }\n         None => {\n             ecx.diag.handler().bug(\n@@ -274,14 +274,14 @@ fn encode_disr_val(_: &EncodeContext,\n                    disr_val: ty::Disr) {\n     rbml_w.start_tag(tag_disr_val);\n     let s = disr_val.to_string();\n-    rbml_w.writer.write(s.as_bytes());\n+    rbml_w.writer.write_all(s.as_bytes());\n     rbml_w.end_tag();\n }\n \n fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n     rbml_w.start_tag(tag_items_data_parent_item);\n     let s = def_to_string(id);\n-    rbml_w.writer.write(s.as_bytes());\n+    rbml_w.writer.write_all(s.as_bytes());\n     rbml_w.end_tag();\n }\n \n@@ -299,7 +299,7 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n         encode_def_id(rbml_w, f.id);\n         rbml_w.start_tag(tag_item_field_origin);\n         let s = def_to_string(origin);\n-        rbml_w.writer.write(s.as_bytes());\n+        rbml_w.writer.write_all(s.as_bytes());\n         rbml_w.end_tag();\n         rbml_w.end_tag();\n     }\n@@ -636,17 +636,17 @@ fn encode_explicit_self(rbml_w: &mut Encoder,\n     // Encode the base self type.\n     match *explicit_self {\n         ty::StaticExplicitSelfCategory => {\n-            rbml_w.writer.write(&[ 's' as u8 ]);\n+            rbml_w.writer.write_all(&[ 's' as u8 ]);\n         }\n         ty::ByValueExplicitSelfCategory => {\n-            rbml_w.writer.write(&[ 'v' as u8 ]);\n+            rbml_w.writer.write_all(&[ 'v' as u8 ]);\n         }\n         ty::ByBoxExplicitSelfCategory => {\n-            rbml_w.writer.write(&[ '~' as u8 ]);\n+            rbml_w.writer.write_all(&[ '~' as u8 ]);\n         }\n         ty::ByReferenceExplicitSelfCategory(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n-            rbml_w.writer.write(&['&' as u8]);\n+            rbml_w.writer.write_all(&['&' as u8]);\n             encode_mutability(rbml_w, m);\n         }\n     }\n@@ -656,21 +656,21 @@ fn encode_explicit_self(rbml_w: &mut Encoder,\n     fn encode_mutability(rbml_w: &mut Encoder,\n                          m: ast::Mutability) {\n         match m {\n-            ast::MutImmutable => { rbml_w.writer.write(&[ 'i' as u8 ]); }\n-            ast::MutMutable => { rbml_w.writer.write(&[ 'm' as u8 ]); }\n+            ast::MutImmutable => { rbml_w.writer.write_all(&[ 'i' as u8 ]); }\n+            ast::MutMutable => { rbml_w.writer.write_all(&[ 'm' as u8 ]); }\n         }\n     }\n }\n \n fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n     rbml_w.start_tag(tag_item_trait_item_sort);\n-    rbml_w.writer.write(&[ sort as u8 ]);\n+    rbml_w.writer.write_all(&[ sort as u8 ]);\n     rbml_w.end_tag();\n }\n \n fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n     rbml_w.start_tag(tag_item_trait_parent_sort);\n-    rbml_w.writer.write(&[ sort as u8 ]);\n+    rbml_w.writer.write_all(&[ sort as u8 ]);\n     rbml_w.end_tag();\n }\n \n@@ -679,7 +679,7 @@ fn encode_provided_source(rbml_w: &mut Encoder,\n     for source in source_opt.iter() {\n         rbml_w.start_tag(tag_item_method_provided_source);\n         let s = def_to_string(*source);\n-        rbml_w.writer.write(s.as_bytes());\n+        rbml_w.writer.write_all(s.as_bytes());\n         rbml_w.end_tag();\n     }\n }\n@@ -926,7 +926,7 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n         rbml_w.start_tag(tag_method_argument_name);\n         if let ast::PatIdent(_, ref path1, _) = arg.pat.node {\n             let name = token::get_ident(path1.node);\n-            rbml_w.writer.write(name.get().as_bytes());\n+            rbml_w.writer.write_all(name.get().as_bytes());\n         }\n         rbml_w.end_tag();\n     }\n@@ -1646,7 +1646,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n       ast::MetaWord(ref name) => {\n         rbml_w.start_tag(tag_meta_item_word);\n         rbml_w.start_tag(tag_meta_item_name);\n-        rbml_w.writer.write(name.get().as_bytes());\n+        rbml_w.writer.write_all(name.get().as_bytes());\n         rbml_w.end_tag();\n         rbml_w.end_tag();\n       }\n@@ -1655,10 +1655,10 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n           ast::LitStr(ref value, _) => {\n             rbml_w.start_tag(tag_meta_item_name_value);\n             rbml_w.start_tag(tag_meta_item_name);\n-            rbml_w.writer.write(name.get().as_bytes());\n+            rbml_w.writer.write_all(name.get().as_bytes());\n             rbml_w.end_tag();\n             rbml_w.start_tag(tag_meta_item_value);\n-            rbml_w.writer.write(value.get().as_bytes());\n+            rbml_w.writer.write_all(value.get().as_bytes());\n             rbml_w.end_tag();\n             rbml_w.end_tag();\n           }\n@@ -1668,7 +1668,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n       ast::MetaList(ref name, ref items) => {\n         rbml_w.start_tag(tag_meta_item_list);\n         rbml_w.start_tag(tag_meta_item_name);\n-        rbml_w.writer.write(name.get().as_bytes());\n+        rbml_w.writer.write_all(name.get().as_bytes());\n         rbml_w.end_tag();\n         for inner_item in items.iter() {\n             encode_meta_item(rbml_w, &**inner_item);\n@@ -1800,7 +1800,7 @@ fn encode_native_libraries(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n                 rbml_w.end_tag();\n \n                 rbml_w.start_tag(tag_native_libraries_name);\n-                rbml_w.writer.write(lib.as_bytes());\n+                rbml_w.writer.write_all(lib.as_bytes());\n                 rbml_w.end_tag();\n \n                 rbml_w.end_tag();\n@@ -1975,29 +1975,29 @@ fn encode_crate_dep(rbml_w: &mut Encoder,\n                     dep: decoder::CrateDep) {\n     rbml_w.start_tag(tag_crate_dep);\n     rbml_w.start_tag(tag_crate_dep_crate_name);\n-    rbml_w.writer.write(dep.name.as_bytes());\n+    rbml_w.writer.write_all(dep.name.as_bytes());\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_crate_dep_hash);\n-    rbml_w.writer.write(dep.hash.as_str().as_bytes());\n+    rbml_w.writer.write_all(dep.hash.as_str().as_bytes());\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n \n fn encode_hash(rbml_w: &mut Encoder, hash: &Svh) {\n     rbml_w.start_tag(tag_crate_hash);\n-    rbml_w.writer.write(hash.as_str().as_bytes());\n+    rbml_w.writer.write_all(hash.as_str().as_bytes());\n     rbml_w.end_tag();\n }\n \n fn encode_crate_name(rbml_w: &mut Encoder, crate_name: &str) {\n     rbml_w.start_tag(tag_crate_crate_name);\n-    rbml_w.writer.write(crate_name.as_bytes());\n+    rbml_w.writer.write_all(crate_name.as_bytes());\n     rbml_w.end_tag();\n }\n \n fn encode_crate_triple(rbml_w: &mut Encoder, triple: &str) {\n     rbml_w.start_tag(tag_crate_triple);\n-    rbml_w.writer.write(triple.as_bytes());\n+    rbml_w.writer.write_all(triple.as_bytes());\n     rbml_w.end_tag();\n }\n \n@@ -2011,7 +2011,7 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n                     cstore::RequireStatic => \"s\",\n                 })).to_string())\n             }).collect::<Vec<String>>();\n-            rbml_w.writer.write(s.connect(\",\").as_bytes());\n+            rbml_w.writer.write_all(s.connect(\",\").as_bytes());\n         }\n         None => {}\n     }"}, {"sha": "658bacdb576c3c3ae6d628688d954117234e1647", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -51,7 +51,7 @@ pub type abbrev_map<'tcx> = RefCell<FnvHashMap<Ty<'tcx>, ty_abbrev>>;\n \n pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n     match cx.abbrevs.borrow_mut().get(&t) {\n-        Some(a) => { w.write(a.s.as_bytes()); return; }\n+        Some(a) => { w.write_all(a.s.as_bytes()); return; }\n         None => {}\n     }\n     let pos = w.tell().unwrap();"}, {"sha": "f5a6f3d95a2c466054e3b81e303c9578af380b54", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -586,8 +586,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // the same filename for metadata (stomping over one another)\n             let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n-            match fs::File::create(&metadata).write(&trans.metadata\n-                                                    []) {\n+            match fs::File::create(&metadata).write_all(&trans.metadata[]) {\n                 Ok(..) => {}\n                 Err(e) => {\n                     sess.err(&format!(\"failed to write {}: {}\",\n@@ -674,10 +673,10 @@ fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n                                          -> ::std::old_io::IoResult<()> {\n     let bc_data_deflated_size: u64 = bc_data_deflated.len() as u64;\n \n-    try! { writer.write(RLIB_BYTECODE_OBJECT_MAGIC) };\n+    try! { writer.write_all(RLIB_BYTECODE_OBJECT_MAGIC) };\n     try! { writer.write_le_u32(1) };\n     try! { writer.write_le_u64(bc_data_deflated_size) };\n-    try! { writer.write(&bc_data_deflated[]) };\n+    try! { writer.write_all(&bc_data_deflated[]) };\n \n     let number_of_bytes_written_so_far =\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id"}, {"sha": "956d50efd697b9890d6b1c584c8a21eedb0955c4", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -626,7 +626,7 @@ fn render_sources(cx: &mut Context,\n /// Writes the entire contents of a string to a destination, not attempting to\n /// catch any errors.\n fn write(dst: Path, contents: &[u8]) -> old_io::IoResult<()> {\n-    File::create(&dst).write(contents)\n+    File::create(&dst).write_all(contents)\n }\n \n /// Makes a directory on the filesystem, failing the task if an error occurs and"}, {"sha": "fdf522baf5c8dfe6117ec22f15317c235d7943af", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -27,7 +27,7 @@ thread_local! {\n }\n \n impl Writer for Stdio {\n-    fn write(&mut self, bytes: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, bytes: &[u8]) -> IoResult<()> {\n         let _ = self.write_bytes(bytes);\n         Ok(())\n     }"}, {"sha": "768cec129a9766456a2e73bbf80c643df26c6373", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -184,7 +184,7 @@ impl<W: Writer> BufferedWriter<W> {\n \n     fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            let ret = self.inner.as_mut().unwrap().write(&self.buf[..self.pos]);\n+            let ret = self.inner.as_mut().unwrap().write_all(&self.buf[..self.pos]);\n             self.pos = 0;\n             ret\n         } else {\n@@ -213,13 +213,13 @@ impl<W: Writer> BufferedWriter<W> {\n }\n \n impl<W: Writer> Writer for BufferedWriter<W> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         if self.pos + buf.len() > self.buf.len() {\n             try!(self.flush_buf());\n         }\n \n         if buf.len() > self.buf.len() {\n-            self.inner.as_mut().unwrap().write(buf)\n+            self.inner.as_mut().unwrap().write_all(buf)\n         } else {\n             let dst = &mut self.buf[self.pos..];\n             slice::bytes::copy_memory(dst, buf);\n@@ -281,15 +281,15 @@ impl<W: Writer> LineBufferedWriter<W> {\n }\n \n impl<W: Writer> Writer for LineBufferedWriter<W> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n-                try!(self.inner.write(&buf[..i + 1]));\n+                try!(self.inner.write_all(&buf[..i + 1]));\n                 try!(self.inner.flush());\n-                try!(self.inner.write(&buf[i + 1..]));\n+                try!(self.inner.write_all(&buf[i + 1..]));\n                 Ok(())\n             }\n-            None => self.inner.write(buf),\n+            None => self.inner.write_all(buf),\n         }\n     }\n \n@@ -329,7 +329,7 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n /// let file = File::open(&Path::new(\"message.txt\"));\n /// let mut stream = BufferedStream::new(file);\n ///\n-/// stream.write(\"hello, world\".as_bytes());\n+/// stream.write_all(\"hello, world\".as_bytes());\n /// stream.flush();\n ///\n /// let mut buf = [0; 100];\n@@ -412,8 +412,8 @@ impl<S: Stream> Reader for BufferedStream<S> {\n }\n \n impl<S: Stream> Writer for BufferedStream<S> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner.inner.get_mut().write(buf)\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.inner.inner.get_mut().write_all(buf)\n     }\n     fn flush(&mut self) -> IoResult<()> {\n         self.inner.inner.get_mut().flush()\n@@ -443,7 +443,7 @@ mod test {\n     }\n \n     impl Writer for NullStream {\n-        fn write(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n+        fn write_all(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n     }\n \n     /// A dummy reader intended at testing short-reads propagation.\n@@ -503,34 +503,34 @@ mod test {\n         let inner = Vec::new();\n         let mut writer = BufferedWriter::with_capacity(2, inner);\n \n-        writer.write(&[0, 1]).unwrap();\n+        writer.write_all(&[0, 1]).unwrap();\n         let b: &[_] = &[];\n         assert_eq!(&writer.get_ref()[], b);\n \n-        writer.write(&[2]).unwrap();\n+        writer.write_all(&[2]).unwrap();\n         let b: &[_] = &[0, 1];\n         assert_eq!(&writer.get_ref()[], b);\n \n-        writer.write(&[3]).unwrap();\n+        writer.write_all(&[3]).unwrap();\n         assert_eq!(&writer.get_ref()[], b);\n \n         writer.flush().unwrap();\n         let a: &[_] = &[0, 1, 2, 3];\n         assert_eq!(a, &writer.get_ref()[]);\n \n-        writer.write(&[4]).unwrap();\n-        writer.write(&[5]).unwrap();\n+        writer.write_all(&[4]).unwrap();\n+        writer.write_all(&[5]).unwrap();\n         assert_eq!(a, &writer.get_ref()[]);\n \n-        writer.write(&[6]).unwrap();\n+        writer.write_all(&[6]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5];\n         assert_eq!(a, &writer.get_ref()[]);\n \n-        writer.write(&[7, 8]).unwrap();\n+        writer.write_all(&[7, 8]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5, 6];\n         assert_eq!(a, &writer.get_ref()[]);\n \n-        writer.write(&[9, 10, 11]).unwrap();\n+        writer.write_all(&[9, 10, 11]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n         assert_eq!(a, &writer.get_ref()[]);\n \n@@ -541,7 +541,7 @@ mod test {\n     #[test]\n     fn test_buffered_writer_inner_flushes() {\n         let mut w = BufferedWriter::with_capacity(3, Vec::new());\n-        w.write(&[0, 1]).unwrap();\n+        w.write_all(&[0, 1]).unwrap();\n         let a: &[_] = &[];\n         assert_eq!(a, &w.get_ref()[]);\n         let w = w.into_inner();\n@@ -556,7 +556,7 @@ mod test {\n         struct S;\n \n         impl old_io::Writer for S {\n-            fn write(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n+            fn write_all(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n         }\n \n         impl old_io::Reader for S {\n@@ -568,7 +568,7 @@ mod test {\n         let mut stream = BufferedStream::new(S);\n         let mut buf = [];\n         assert!(stream.read(&mut buf).is_err());\n-        stream.write(&buf).unwrap();\n+        stream.write_all(&buf).unwrap();\n         stream.flush().unwrap();\n     }\n \n@@ -586,21 +586,21 @@ mod test {\n     #[test]\n     fn test_line_buffer() {\n         let mut writer = LineBufferedWriter::new(Vec::new());\n-        writer.write(&[0]).unwrap();\n+        writer.write_all(&[0]).unwrap();\n         let b: &[_] = &[];\n         assert_eq!(&writer.get_ref()[], b);\n-        writer.write(&[1]).unwrap();\n+        writer.write_all(&[1]).unwrap();\n         assert_eq!(&writer.get_ref()[], b);\n         writer.flush().unwrap();\n         let b: &[_] = &[0, 1];\n         assert_eq!(&writer.get_ref()[], b);\n-        writer.write(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n+        writer.write_all(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n'];\n         assert_eq!(&writer.get_ref()[], b);\n         writer.flush().unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2];\n         assert_eq!(&writer.get_ref()[], b);\n-        writer.write(&[3, b'\\n']).unwrap();\n+        writer.write_all(&[3, b'\\n']).unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n'];\n         assert_eq!(&writer.get_ref()[], b);\n     }\n@@ -663,7 +663,7 @@ mod test {\n         struct FailFlushWriter;\n \n         impl Writer for FailFlushWriter {\n-            fn write(&mut self, _buf: &[u8]) -> IoResult<()> { Ok(()) }\n+            fn write_all(&mut self, _buf: &[u8]) -> IoResult<()> { Ok(()) }\n             fn flush(&mut self) -> IoResult<()> { Err(old_io::standard_error(EndOfFile)) }\n         }\n "}, {"sha": "a1f2efdb28afe56c0e9d26408c305368a7a00bfc", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -142,7 +142,7 @@ impl Clone for ChanWriter {\n }\n \n impl Writer for ChanWriter {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.tx.send(buf.to_vec()).map_err(|_| {\n             old_io::IoError {\n                 kind: old_io::BrokenPipe,"}, {"sha": "a1ac5d2eab02b39d1387c4fe57b9237ed16c690d", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -719,7 +719,7 @@ impl Reader for File {\n }\n \n impl Writer for File {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.fd.write(buf)\n             .update_err(\"couldn't write to file\",\n                         |e| format!(\"{}; path={}\", e, self.path.display()))"}, {"sha": "be965d9cf2d6a844b070e73236171c07c654191d", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -43,7 +43,7 @@ fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64>\n \n impl Writer for Vec<u8> {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.push_all(buf);\n         Ok(())\n     }\n@@ -99,7 +99,7 @@ impl MemWriter {\n \n impl Writer for MemWriter {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.buf.push_all(buf);\n         Ok(())\n     }\n@@ -269,7 +269,7 @@ impl<'a> BufWriter<'a> {\n \n impl<'a> Writer for BufWriter<'a> {\n     #[inline]\n-    fn write(&mut self, src: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, src: &[u8]) -> IoResult<()> {\n         let dst = &mut self.buf[self.pos..];\n         let dst_len = dst.len();\n "}, {"sha": "3d1c8a0b86c6f2c84169a9df44d23a706bae072d", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -70,7 +70,7 @@\n //!     use std::old_io::File;\n //!\n //!     let mut file = File::create(&Path::new(\"message.txt\"));\n-//!     file.write(b\"hello, file!\\n\");\n+//!     file.write_all(b\"hello, file!\\n\");\n //!     # drop(file);\n //!     # ::std::old_io::fs::unlink(&Path::new(\"message.txt\"));\n //!     ```\n@@ -110,7 +110,7 @@\n //!     # // just stop it running (#11576)\n //!     # if false {\n //!     let mut socket = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n-//!     socket.write(b\"GET / HTTP/1.0\\n\\n\");\n+//!     socket.write_all(b\"GET / HTTP/1.0\\n\\n\");\n //!     let response = socket.read_to_end();\n //!     # }\n //!     ```\n@@ -174,7 +174,7 @@\n //!   to be 'unwrapped' before use.\n //!\n //! These features combine in the API to allow for expressions like\n-//! `File::create(&Path::new(\"diary.txt\")).write(b\"Met a girl.\\n\")`\n+//! `File::create(&Path::new(\"diary.txt\")).write_all(b\"Met a girl.\\n\")`\n //! without having to worry about whether \"diary.txt\" exists or whether\n //! the write succeeds. As written, if either `new` or `write_line`\n //! encounters an error then the result of the entire expression will\n@@ -186,7 +186,7 @@\n //! # #![allow(unused_must_use)]\n //! use std::old_io::File;\n //!\n-//! match File::create(&Path::new(\"diary.txt\")).write(b\"Met a girl.\\n\") {\n+//! match File::create(&Path::new(\"diary.txt\")).write_all(b\"Met a girl.\\n\") {\n //!     Ok(()) => (), // succeeded\n //!     Err(e) => println!(\"failed to write to my diary: {}\", e),\n //! }\n@@ -997,7 +997,11 @@ pub trait Writer {\n     /// `Err`. Note that it is considered an error if the entire buffer could\n     /// not be written, and if an error is returned then it is unknown how much\n     /// data (if any) was actually written.\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()>;\n+\n+    /// Deprecated, this method was renamed to `write_all`\n+    #[deprecated = \"renamed to `write_all`\"]\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write_all(buf) }\n \n     /// Flush this output stream, ensuring that all intermediately buffered\n     /// contents reach their destination.\n@@ -1026,7 +1030,7 @@ pub trait Writer {\n \n         impl<'a, T: ?Sized + Writer> fmt::Writer for Adaptor<'a, T> {\n             fn write_str(&mut self, s: &str) -> fmt::Result {\n-                match self.inner.write(s.as_bytes()) {\n+                match self.inner.write_all(s.as_bytes()) {\n                     Ok(()) => Ok(()),\n                     Err(e) => {\n                         self.error = Err(e);\n@@ -1052,7 +1056,7 @@ pub trait Writer {\n     /// converted byte-array instead.\n     #[inline]\n     fn write_str(&mut self, s: &str) -> IoResult<()> {\n-        self.write(s.as_bytes())\n+        self.write_all(s.as_bytes())\n     }\n \n     /// Writes a string into this sink, and then writes a literal newline (`\\n`)\n@@ -1064,15 +1068,15 @@ pub trait Writer {\n     /// that the `write` method is used specifically instead.\n     #[inline]\n     fn write_line(&mut self, s: &str) -> IoResult<()> {\n-        self.write_str(s).and_then(|()| self.write(&[b'\\n']))\n+        self.write_str(s).and_then(|()| self.write_all(&[b'\\n']))\n     }\n \n     /// Write a single char, encoded as UTF-8.\n     #[inline]\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8; 4];\n         let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        self.write(&buf[..n])\n+        self.write_all(&buf[..n])\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n@@ -1090,61 +1094,61 @@ pub trait Writer {\n     /// Write a little-endian uint (number of bytes depends on system).\n     #[inline]\n     fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, uint::BYTES, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, uint::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian int (number of bytes depends on system).\n     #[inline]\n     fn write_le_int(&mut self, n: int) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, int::BYTES, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, int::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian uint (number of bytes depends on system).\n     #[inline]\n     fn write_be_uint(&mut self, n: uint) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, uint::BYTES, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, uint::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian int (number of bytes depends on system).\n     #[inline]\n     fn write_be_int(&mut self, n: int) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, int::BYTES, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, int::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian u64 (8 bytes).\n     #[inline]\n     fn write_be_u64(&mut self, n: u64) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n, 8u, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n, 8u, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian u32 (4 bytes).\n     #[inline]\n     fn write_be_u32(&mut self, n: u32) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian u16 (2 bytes).\n     #[inline]\n     fn write_be_u16(&mut self, n: u16) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian i64 (8 bytes).\n     #[inline]\n     fn write_be_i64(&mut self, n: i64) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, 8u, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian i32 (4 bytes).\n     #[inline]\n     fn write_be_i32(&mut self, n: i32) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian i16 (2 bytes).\n     #[inline]\n     fn write_be_i16(&mut self, n: i16) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n@@ -1166,37 +1170,37 @@ pub trait Writer {\n     /// Write a little-endian u64 (8 bytes).\n     #[inline]\n     fn write_le_u64(&mut self, n: u64) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n, 8u, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n, 8u, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian u32 (4 bytes).\n     #[inline]\n     fn write_le_u32(&mut self, n: u32) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian u16 (2 bytes).\n     #[inline]\n     fn write_le_u16(&mut self, n: u16) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian i64 (8 bytes).\n     #[inline]\n     fn write_le_i64(&mut self, n: i64) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, 8u, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian i32 (4 bytes).\n     #[inline]\n     fn write_le_i32(&mut self, n: i32) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian i16 (2 bytes).\n     #[inline]\n     fn write_le_i16(&mut self, n: i16) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian IEEE754 double-precision floating-point\n@@ -1220,13 +1224,13 @@ pub trait Writer {\n     /// Write a u8 (1 byte).\n     #[inline]\n     fn write_u8(&mut self, n: u8) -> IoResult<()> {\n-        self.write(&[n])\n+        self.write_all(&[n])\n     }\n \n     /// Write an i8 (1 byte).\n     #[inline]\n     fn write_i8(&mut self, n: i8) -> IoResult<()> {\n-        self.write(&[n as u8])\n+        self.write_all(&[n as u8])\n     }\n }\n \n@@ -1248,8 +1252,8 @@ impl<T: Writer> ByRefWriter for T {\n \n impl<'a> Writer for Box<Writer+'a> {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        (&mut **self).write(buf)\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n+        (&mut **self).write_all(buf)\n     }\n \n     #[inline]\n@@ -1260,7 +1264,7 @@ impl<'a> Writer for Box<Writer+'a> {\n \n impl<'a> Writer for &'a mut (Writer+'a) {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { (**self).write(buf) }\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> { (**self).write_all(buf) }\n \n     #[inline]\n     fn flush(&mut self) -> IoResult<()> { (**self).flush() }\n@@ -1295,7 +1299,7 @@ pub struct RefWriter<'a, W:'a> {\n \n impl<'a, W: Writer> Writer for RefWriter<'a, W> {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write(buf) }\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write_all(buf) }\n \n     #[inline]\n     fn flush(&mut self) -> IoResult<()> { self.inner.flush() }"}, {"sha": "760e778fd7ccede4cd9934b0837a76f46140371b", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -142,7 +142,7 @@ impl Reader for UnixStream {\n }\n \n impl Writer for UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner.write(buf)\n     }\n }"}, {"sha": "f01f6e1a87c408ad80fcc7f9a32fd5762338c523", "filename": "src/libstd/old_io/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -258,7 +258,7 @@ impl Reader for TcpStream {\n }\n \n impl Writer for TcpStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner.write(buf)\n     }\n }"}, {"sha": "5843b1ba1b13f377c70264035099ea7db8e2d9e5", "filename": "src/libstd/old_io/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fpipe.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -105,7 +105,7 @@ impl Reader for PipeStream {\n }\n \n impl Writer for PipeStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner.write(buf)\n     }\n }"}, {"sha": "96b979860ae902fe571e226cb00fb3fdeb592a8e", "filename": "src/libstd/old_io/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fresult.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -19,9 +19,9 @@ use result::Result::{Ok, Err};\n use super::{Reader, Writer, Listener, Acceptor, Seek, SeekStyle, IoResult};\n \n impl<W: Writer> Writer for IoResult<W> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         match *self {\n-            Ok(ref mut writer) => writer.write(buf),\n+            Ok(ref mut writer) => writer.write_all(buf),\n             Err(ref e) => Err((*e).clone())\n         }\n     }\n@@ -85,7 +85,7 @@ mod test {\n     #[test]\n     fn test_option_writer() {\n         let mut writer: old_io::IoResult<Vec<u8>> = Ok(Vec::new());\n-        writer.write(&[0, 1, 2]).unwrap();\n+        writer.write_all(&[0, 1, 2]).unwrap();\n         writer.flush().unwrap();\n         assert_eq!(writer.unwrap(), vec!(0, 1, 2));\n     }\n@@ -95,7 +95,7 @@ mod test {\n         let mut writer: old_io::IoResult<Vec<u8>> =\n             Err(old_io::standard_error(old_io::EndOfFile));\n \n-        match writer.write(&[0, 0, 0]) {\n+        match writer.write_all(&[0, 0, 0]) {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n         }"}, {"sha": "70400619bea7315ffc2d7968600d05ed604a94c3", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -22,7 +22,7 @@\n //! use std::old_io;\n //!\n //! let mut out = old_io::stdout();\n-//! out.write(b\"Hello, world!\");\n+//! out.write_all(b\"Hello, world!\");\n //! ```\n \n use self::StdSource::*;\n@@ -370,14 +370,14 @@ pub fn flush() {\n /// Prints a string to the stdout of the current process. No newline is emitted\n /// after the string is printed.\n pub fn print(s: &str) {\n-    with_task_stdout(|io| io.write(s.as_bytes()))\n+    with_task_stdout(|io| io.write_all(s.as_bytes()))\n }\n \n /// Prints a string to the stdout of the current process. A literal\n /// `\\n` character is printed to the console after the string.\n pub fn println(s: &str) {\n     with_task_stdout(|io| {\n-        io.write(s.as_bytes()).and_then(|()| io.write(&[b'\\n']))\n+        io.write_all(s.as_bytes()).and_then(|()| io.write_all(&[b'\\n']))\n     })\n }\n \n@@ -498,7 +498,7 @@ impl StdWriter {\n }\n \n impl Writer for StdWriter {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         // As with stdin on windows, stdout often can't handle writes of large\n         // sizes. For an example, see #14940. For this reason, chunk the output\n         // buffer on windows, but on unix we can just write the whole buffer all"}, {"sha": "4b6d9b08141a3c829e73b34f011157cf8266d770", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -83,7 +83,7 @@ pub struct NullWriter;\n \n impl Writer for NullWriter {\n     #[inline]\n-    fn write(&mut self, _buf: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n+    fn write_all(&mut self, _buf: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n }\n \n /// A `Reader` which returns an infinite stream of 0 bytes, like /dev/zero.\n@@ -143,9 +143,9 @@ impl<W> MultiWriter<W> where W: Writer {\n \n impl<W> Writer for MultiWriter<W> where W: Writer {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> old_io::IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> old_io::IoResult<()> {\n         for writer in self.writers.iter_mut() {\n-            try!(writer.write(buf));\n+            try!(writer.write_all(buf));\n         }\n         Ok(())\n     }\n@@ -223,7 +223,7 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n     fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         self.reader.read(buf).and_then(|len| {\n-            self.writer.write(&mut buf[..len]).map(|()| len)\n+            self.writer.write_all(&mut buf[..len]).map(|()| len)\n         })\n     }\n }\n@@ -237,7 +237,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> old_io::IoResult<()>\n             Err(ref e) if e.kind == old_io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n         };\n-        try!(w.write(&buf[..len]));\n+        try!(w.write_all(&buf[..len]));\n     }\n }\n \n@@ -321,7 +321,7 @@ mod test {\n     fn test_null_writer() {\n         let mut s = NullWriter;\n         let buf = vec![0, 0, 0];\n-        s.write(buf.as_slice()).unwrap();\n+        s.write_all(buf.as_slice()).unwrap();\n         s.flush().unwrap();\n     }\n \n@@ -347,7 +347,7 @@ mod test {\n \n         struct TestWriter;\n         impl Writer for TestWriter {\n-            fn write(&mut self, _buf: &[u8]) -> old_io::IoResult<()> {\n+            fn write_all(&mut self, _buf: &[u8]) -> old_io::IoResult<()> {\n                 unsafe { writes += 1 }\n                 Ok(())\n             }\n@@ -360,7 +360,7 @@ mod test {\n \n         let mut multi = MultiWriter::new(vec!(box TestWriter as Box<Writer>,\n                                               box TestWriter as Box<Writer>));\n-        multi.write(&[1, 2, 3]).unwrap();\n+        multi.write_all(&[1, 2, 3]).unwrap();\n         assert_eq!(2, unsafe { writes });\n         assert_eq!(0, unsafe { flushes });\n         multi.flush().unwrap();"}, {"sha": "ca1a16d8e173060cc3d5e61f7c2d21456c603cce", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -375,7 +375,7 @@ fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n         Some(string) => try!(demangle(w, string)),\n         None => try!(write!(w, \"<unknown>\")),\n     }\n-    w.write(&['\\n' as u8])\n+    w.write_all(&['\\n' as u8])\n }\n \n /// Unwind library interface used for backtraces"}, {"sha": "d414f70152da44b44934f174ebdd966deeab8112", "filename": "src/libstd/sys/unix/tty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -67,7 +67,7 @@ impl TTY {\n             let mut size = winsize { ws_row: 0, ws_col: 0, ws_xpixel: 0, ws_ypixel: 0 };\n             if c::ioctl(self.fd.fd(), TIOCGWINSZ, &mut size) == -1 {\n                 Err(IoError {\n-                    kind: io::OtherIoError,\n+                    kind: old_io::OtherIoError,\n                     desc: \"Size of terminal could not be determined\",\n                     detail: None,\n                 })"}, {"sha": "a186465f234e3d6c4915f0044559c4da3e27fec9", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -25,7 +25,7 @@ use dynamic_lib::DynamicLibrary;\n use ffi;\n use core::ops::Index;\n use intrinsics;\n-use io::{IoResult, Writer};\n+use old_io::{IoResult, Writer};\n use libc;\n use mem;\n use ops::Drop;\n@@ -363,10 +363,10 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n             let bytes = unsafe { ffi::c_str_to_bytes(&ptr) };\n             match str::from_utf8(bytes) {\n                 Ok(s) => try!(demangle(w, s)),\n-                Err(..) => try!(w.write(&bytes[..bytes.len()-1])),\n+                Err(..) => try!(w.write_all(&bytes[..bytes.len()-1])),\n             }\n         }\n-        try!(w.write(&['\\n' as u8]));\n+        try!(w.write_all(&['\\n' as u8]));\n     }\n \n     Ok(())"}, {"sha": "8e87f8cba365598eeee5225e13ab9ec6f9c2183c", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -23,7 +23,7 @@ use sys_common::{AsInner, FromInner};\n use ffi::{OsStr, OsString};\n use libc;\n \n-use io;\n+use old_io;\n \n /// Raw HANDLEs.\n pub type Handle = libc::HANDLE;\n@@ -37,31 +37,31 @@ pub trait AsRawHandle {\n     fn as_raw_handle(&self) -> Handle;\n }\n \n-impl AsRawHandle for io::fs::File {\n+impl AsRawHandle for old_io::fs::File {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()\n     }\n }\n \n-impl AsRawHandle for io::pipe::PipeStream {\n+impl AsRawHandle for old_io::pipe::PipeStream {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()\n     }\n }\n \n-impl AsRawHandle for io::net::pipe::UnixStream {\n+impl AsRawHandle for old_io::net::pipe::UnixStream {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()\n     }\n }\n \n-impl AsRawHandle for io::net::pipe::UnixListener {\n+impl AsRawHandle for old_io::net::pipe::UnixListener {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()\n     }\n }\n \n-impl AsRawHandle for io::net::pipe::UnixAcceptor {\n+impl AsRawHandle for old_io::net::pipe::UnixAcceptor {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()\n     }\n@@ -72,25 +72,25 @@ pub trait AsRawSocket {\n     fn as_raw_socket(&self) -> Socket;\n }\n \n-impl AsRawSocket for io::net::tcp::TcpStream {\n+impl AsRawSocket for old_io::net::tcp::TcpStream {\n     fn as_raw_socket(&self) -> Socket {\n         self.as_inner().fd()\n     }\n }\n \n-impl AsRawSocket for io::net::tcp::TcpListener {\n+impl AsRawSocket for old_io::net::tcp::TcpListener {\n     fn as_raw_socket(&self) -> Socket {\n         self.as_inner().socket()\n     }\n }\n \n-impl AsRawSocket for io::net::tcp::TcpAcceptor {\n+impl AsRawSocket for old_io::net::tcp::TcpAcceptor {\n     fn as_raw_socket(&self) -> Socket {\n         self.as_inner().socket()\n     }\n }\n \n-impl AsRawSocket for io::net::udp::UdpSocket {\n+impl AsRawSocket for old_io::net::udp::UdpSocket {\n     fn as_raw_socket(&self) -> Socket {\n         self.as_inner().fd()\n     }"}, {"sha": "d9d1a37465140f05708f9ea1178e36c432468183", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -18,16 +18,16 @@ use sys::os::fill_utf16_buf_and_decode;\n use path;\n use ptr;\n use str;\n-use io;\n+use old_io;\n \n use prelude::v1::*;\n use sys;\n use sys::os;\n use sys_common::{keep_going, eof, mkerr_libc};\n \n-use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n-use io::{IoResult, IoError, FileStat, SeekStyle};\n-use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n+use old_io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n+use old_io::{IoResult, IoError, FileStat, SeekStyle};\n+use old_io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n \n pub type fd_t = libc::c_int;\n \n@@ -130,7 +130,7 @@ impl FileDesc {\n         return ret;\n     }\n \n-    pub fn fstat(&self) -> IoResult<io::FileStat> {\n+    pub fn fstat(&self) -> IoResult<old_io::FileStat> {\n         let mut stat: libc::stat = unsafe { mem::zeroed() };\n         match unsafe { libc::fstat(self.fd(), &mut stat) } {\n             0 => Ok(mkstat(&stat)),\n@@ -268,7 +268,7 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n                         Err(..) => {\n                             assert!(libc::FindClose(find_handle) != 0);\n                             return Err(IoError {\n-                                kind: io::InvalidInput,\n+                                kind: old_io::InvalidInput,\n                                 desc: \"path was not valid UTF-16\",\n                                 detail: Some(format!(\"path was not valid UTF-16: {:?}\", filename)),\n                             })\n@@ -303,14 +303,14 @@ pub fn unlink(p: &Path) -> IoResult<()> {\n             // however, it cannot. To keep the two platforms in line with\n             // respect to their behavior, catch this case on windows, attempt to\n             // change it to read-write, and then remove the file.\n-            if e.kind == io::PermissionDenied {\n+            if e.kind == old_io::PermissionDenied {\n                 let stat = match stat(p) {\n                     Ok(stat) => stat,\n                     Err(..) => return Err(e),\n                 };\n-                if stat.perm.intersects(io::USER_WRITE) { return Err(e) }\n+                if stat.perm.intersects(old_io::USER_WRITE) { return Err(e) }\n \n-                match chmod(p, (stat.perm | io::USER_WRITE).bits() as uint) {\n+                match chmod(p, (stat.perm | old_io::USER_WRITE).bits() as uint) {\n                     Ok(()) => do_unlink(&p_utf16),\n                     Err(..) => {\n                         // Try to put it back as we found it\n@@ -406,12 +406,12 @@ fn mkstat(stat: &libc::stat) -> FileStat {\n     FileStat {\n         size: stat.st_size as u64,\n         kind: match (stat.st_mode as libc::c_int) & libc::S_IFMT {\n-            libc::S_IFREG => io::FileType::RegularFile,\n-            libc::S_IFDIR => io::FileType::Directory,\n-            libc::S_IFIFO => io::FileType::NamedPipe,\n-            libc::S_IFBLK => io::FileType::BlockSpecial,\n-            libc::S_IFLNK => io::FileType::Symlink,\n-            _ => io::FileType::Unknown,\n+            libc::S_IFREG => old_io::FileType::RegularFile,\n+            libc::S_IFDIR => old_io::FileType::Directory,\n+            libc::S_IFIFO => old_io::FileType::NamedPipe,\n+            libc::S_IFBLK => old_io::FileType::BlockSpecial,\n+            libc::S_IFLNK => old_io::FileType::Symlink,\n+            _ => old_io::FileType::Unknown,\n         },\n         perm: FilePermission::from_bits_truncate(stat.st_mode as u32),\n         created: stat.st_ctime as u64,"}, {"sha": "e8b65c9b64ea36e189543d55c977ce942a3cf5d0", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -22,7 +22,7 @@ use prelude::v1::*;\n \n use num;\n use mem;\n-use io::{self, IoResult, IoError};\n+use old_io::{self, IoResult, IoError};\n use sync::{Once, ONCE_INIT};\n \n macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n@@ -99,43 +99,43 @@ pub fn last_gai_error(_errno: i32) -> IoError {\n /// Convert an `errno` value into a high-level error variant and description.\n pub fn decode_error(errno: i32) -> IoError {\n     let (kind, desc) = match errno {\n-        libc::EOF => (io::EndOfFile, \"end of file\"),\n-        libc::ERROR_NO_DATA => (io::BrokenPipe, \"the pipe is being closed\"),\n-        libc::ERROR_FILE_NOT_FOUND => (io::FileNotFound, \"file not found\"),\n-        libc::ERROR_INVALID_NAME => (io::InvalidInput, \"invalid file name\"),\n-        libc::WSAECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n-        libc::WSAECONNRESET => (io::ConnectionReset, \"connection reset\"),\n+        libc::EOF => (old_io::EndOfFile, \"end of file\"),\n+        libc::ERROR_NO_DATA => (old_io::BrokenPipe, \"the pipe is being closed\"),\n+        libc::ERROR_FILE_NOT_FOUND => (old_io::FileNotFound, \"file not found\"),\n+        libc::ERROR_INVALID_NAME => (old_io::InvalidInput, \"invalid file name\"),\n+        libc::WSAECONNREFUSED => (old_io::ConnectionRefused, \"connection refused\"),\n+        libc::WSAECONNRESET => (old_io::ConnectionReset, \"connection reset\"),\n         libc::ERROR_ACCESS_DENIED | libc::WSAEACCES =>\n-            (io::PermissionDenied, \"permission denied\"),\n+            (old_io::PermissionDenied, \"permission denied\"),\n         libc::WSAEWOULDBLOCK => {\n-            (io::ResourceUnavailable, \"resource temporarily unavailable\")\n+            (old_io::ResourceUnavailable, \"resource temporarily unavailable\")\n         }\n-        libc::WSAENOTCONN => (io::NotConnected, \"not connected\"),\n-        libc::WSAECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n-        libc::WSAEADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n-        libc::WSAEADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n-        libc::ERROR_BROKEN_PIPE => (io::EndOfFile, \"the pipe has ended\"),\n+        libc::WSAENOTCONN => (old_io::NotConnected, \"not connected\"),\n+        libc::WSAECONNABORTED => (old_io::ConnectionAborted, \"connection aborted\"),\n+        libc::WSAEADDRNOTAVAIL => (old_io::ConnectionRefused, \"address not available\"),\n+        libc::WSAEADDRINUSE => (old_io::ConnectionRefused, \"address in use\"),\n+        libc::ERROR_BROKEN_PIPE => (old_io::EndOfFile, \"the pipe has ended\"),\n         libc::ERROR_OPERATION_ABORTED =>\n-            (io::TimedOut, \"operation timed out\"),\n-        libc::WSAEINVAL => (io::InvalidInput, \"invalid argument\"),\n+            (old_io::TimedOut, \"operation timed out\"),\n+        libc::WSAEINVAL => (old_io::InvalidInput, \"invalid argument\"),\n         libc::ERROR_CALL_NOT_IMPLEMENTED =>\n-            (io::IoUnavailable, \"function not implemented\"),\n+            (old_io::IoUnavailable, \"function not implemented\"),\n         libc::ERROR_INVALID_HANDLE =>\n-            (io::MismatchedFileTypeForOperation,\n+            (old_io::MismatchedFileTypeForOperation,\n              \"invalid handle provided to function\"),\n         libc::ERROR_NOTHING_TO_TERMINATE =>\n-            (io::InvalidInput, \"no process to kill\"),\n+            (old_io::InvalidInput, \"no process to kill\"),\n         libc::ERROR_ALREADY_EXISTS =>\n-            (io::PathAlreadyExists, \"path already exists\"),\n+            (old_io::PathAlreadyExists, \"path already exists\"),\n \n         // libuv maps this error code to EISDIR. we do too. if it is found\n         // to be incorrect, we can add in some more machinery to only\n         // return this message when ERROR_INVALID_FUNCTION after certain\n         // Windows calls.\n-        libc::ERROR_INVALID_FUNCTION => (io::InvalidInput,\n+        libc::ERROR_INVALID_FUNCTION => (old_io::InvalidInput,\n                                          \"illegal operation on a directory\"),\n \n-        _ => (io::OtherIoError, \"unknown error\")\n+        _ => (old_io::OtherIoError, \"unknown error\")\n     };\n     IoError { kind: kind, desc: desc, detail: None }\n }\n@@ -185,7 +185,7 @@ pub fn init_net() {\n \n pub fn unimpl() -> IoError {\n     IoError {\n-        kind: io::IoUnavailable,\n+        kind: old_io::IoUnavailable,\n         desc: \"operation is not implemented\",\n         detail: None,\n     }\n@@ -199,7 +199,7 @@ pub fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> {\n             s\n         }),\n         None => Err(IoError {\n-            kind: io::InvalidInput,\n+            kind: old_io::InvalidInput,\n             desc: \"valid unicode input required\",\n             detail: None\n         })"}, {"sha": "a82259ad5ec57ee4af485cdf655df00b50885b31", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -16,7 +16,7 @@\n use prelude::v1::*;\n \n use fmt;\n-use io::{IoResult, IoError};\n+use old_io::{IoResult, IoError};\n use iter::repeat;\n use libc::{c_int, c_void};\n use libc;\n@@ -162,7 +162,7 @@ pub fn fill_utf16_buf_and_decode<F>(mut f: F) -> Option<String> where\n pub fn getcwd() -> IoResult<Path> {\n     use libc::DWORD;\n     use libc::GetCurrentDirectoryW;\n-    use io::OtherIoError;\n+    use old_io::OtherIoError;\n \n     let mut buf = [0 as u16; BUF_BYTES];\n     unsafe {"}, {"sha": "dc9fb3253ffb8e5f4684eef148ee09848ef77bd9", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -88,7 +88,7 @@ use prelude::v1::*;\n \n use libc;\n use ffi::CString;\n-use io::{self, IoError, IoResult};\n+use old_io::{self, IoError, IoResult};\n use mem;\n use ptr;\n use str;\n@@ -202,7 +202,7 @@ pub fn await(handle: libc::HANDLE, deadline: u64,\n \n fn epipe() -> IoError {\n     IoError {\n-        kind: io::EndOfFile,\n+        kind: old_io::EndOfFile,\n         desc: \"the pipe has ended\",\n         detail: None,\n     }\n@@ -485,7 +485,7 @@ impl UnixStream {\n                         let amt = offset + bytes_written as uint;\n                         return if amt > 0 {\n                             Err(IoError {\n-                                kind: io::ShortWrite(amt),\n+                                kind: old_io::ShortWrite(amt),\n                                 desc: \"short write during write\",\n                                 detail: None,\n                             })"}, {"sha": "43f9e805db10c304f7d225b4642afe04699024ae", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -14,10 +14,10 @@ use collections;\n use ffi::CString;\n use hash::Hash;\n use collections::hash_map::Hasher;\n-use io::fs::PathExtensions;\n-use io::process::{ProcessExit, ExitStatus, ExitSignal};\n-use io::{IoResult, IoError};\n-use io;\n+use old_io::fs::PathExtensions;\n+use old_io::process::{ProcessExit, ExitStatus, ExitSignal};\n+use old_io::{IoResult, IoError};\n+use old_io;\n use libc::{pid_t, c_void, c_int};\n use libc;\n use mem;\n@@ -84,7 +84,7 @@ impl Process {\n                     Err(super::last_error())\n                 } else if status != libc::STILL_ACTIVE {\n                     Err(IoError {\n-                        kind: io::InvalidInput,\n+                        kind: old_io::InvalidInput,\n                         desc: \"no process to kill\",\n                         detail: None,\n                     })\n@@ -97,7 +97,7 @@ impl Process {\n                 super::mkerr_winbool(ret)\n             }\n             _ => Err(IoError {\n-                kind: io::IoUnavailable,\n+                kind: old_io::IoUnavailable,\n                 desc: \"unsupported signal on windows\",\n                 detail: None,\n             })\n@@ -133,7 +133,7 @@ impl Process {\n \n         if cfg.gid().is_some() || cfg.uid().is_some() {\n             return Err(IoError {\n-                kind: io::IoUnavailable,\n+                kind: old_io::IoUnavailable,\n                 desc: \"unsupported gid/uid requested on windows\",\n                 detail: None,\n             })"}, {"sha": "b7e27fb37f0c1de35ec967e32872ad83a5f7d8cc", "filename": "src/libstd/sys/windows/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use io::net::ip;\n-use io::IoResult;\n+use old_io::net::ip;\n+use old_io::IoResult;\n use libc;\n use mem;\n use ptr;"}, {"sha": "34f3c418c558d5de67e0fe8be9299252ae8974fb", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -26,7 +26,7 @@ use prelude::v1::*;\n use libc;\n use ptr;\n \n-use io::IoResult;\n+use old_io::IoResult;\n use sync::mpsc::{channel, Sender, Receiver, TryRecvError};\n use sys::c;\n use sys::fs::FileDesc;"}, {"sha": "6ecabfa985304efabddfcf36b8ffd7ee2962f8a1", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -27,7 +27,7 @@\n \n use prelude::v1::*;\n \n-use io::{self, IoError, IoResult, MemReader};\n+use old_io::{self, IoError, IoResult, MemReader};\n use iter::repeat;\n use libc::types::os::arch::extra::LPCVOID;\n use libc::{c_int, HANDLE, LPDWORD, DWORD, LPVOID};\n@@ -44,7 +44,7 @@ use super::c::{GetConsoleScreenBufferInfo};\n \n fn invalid_encoding() -> IoError {\n     IoError {\n-        kind: io::InvalidInput,\n+        kind: old_io::InvalidInput,\n         desc: \"text was not valid unicode\",\n         detail: None,\n     }\n@@ -83,7 +83,7 @@ impl TTY {\n             })\n         } else {\n             Err(IoError {\n-                kind: io::MismatchedFileTypeForOperation,\n+                kind: old_io::MismatchedFileTypeForOperation,\n                 desc: \"invalid handle provided to function\",\n                 detail: None,\n             })"}, {"sha": "5b79cb7b5dd356dd3260cab773ac425e2ac99c35", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -362,10 +362,10 @@ impl EmitterWriter {\n }\n \n impl Writer for Destination {\n-    fn write(&mut self, bytes: &[u8]) -> old_io::IoResult<()> {\n+    fn write_all(&mut self, bytes: &[u8]) -> old_io::IoResult<()> {\n         match *self {\n-            Terminal(ref mut t) => t.write(bytes),\n-            Raw(ref mut w) => w.write(bytes),\n+            Terminal(ref mut t) => t.write_all(bytes),\n+            Raw(ref mut w) => w.write_all(bytes),\n         }\n     }\n }"}, {"sha": "94c810833fca66382f6f01b12f5ceb86ec23f5d6", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -76,8 +76,8 @@ pub struct WriterWrapper {\n \n impl Writer for WriterWrapper {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.wrapped.write(buf)\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.wrapped.write_all(buf)\n     }\n \n     #[inline]"}, {"sha": "a8df045e203ca9533ad20c614beae5b232be133b", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -83,7 +83,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n                                .as_slice(),\n                            &[Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                try!(self.out.write(s.unwrap().as_slice()));\n+                try!(self.out.write_all(s.unwrap().as_slice()));\n                 return Ok(true)\n             }\n         }\n@@ -100,7 +100,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n                                .as_slice(),\n                            &[Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                try!(self.out.write(s.unwrap().as_slice()));\n+                try!(self.out.write_all(s.unwrap().as_slice()));\n                 return Ok(true)\n             }\n         }\n@@ -119,7 +119,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n                                    &[],\n                                    &mut Variables::new());\n                     if s.is_ok() {\n-                        try!(self.out.write(s.unwrap().as_slice()));\n+                        try!(self.out.write_all(s.unwrap().as_slice()));\n                         return Ok(true)\n                     }\n                 }\n@@ -154,7 +154,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n             expand(op.as_slice(), &[], &mut Variables::new())\n         });\n         if s.is_ok() {\n-            return self.out.write(s.unwrap().as_slice())\n+            return self.out.write_all(s.unwrap().as_slice())\n         }\n         Ok(())\n     }\n@@ -221,8 +221,8 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n \n \n impl<T: Writer> Writer for TerminfoTerminal<T> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.out.write(buf)\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.out.write_all(buf)\n     }\n \n     fn flush(&mut self) -> IoResult<()> {"}, {"sha": "a56613681c8ca0e7b213601003bfac9a7158b344", "filename": "src/libterm/win.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -14,7 +14,7 @@\n \n extern crate libc;\n \n-use std::io::IoResult;\n+use std::old_io::IoResult;\n \n use attr;\n use color;\n@@ -130,8 +130,8 @@ impl<T: Writer+Send> WinConsole<T> {\n }\n \n impl<T: Writer> Writer for WinConsole<T> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.buf.write(buf)\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.buf.write_all(buf)\n     }\n \n     fn flush(&mut self) -> IoResult<()> {"}, {"sha": "2e59b15b6d9189d2111becce633b2f63549ee287", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -496,20 +496,20 @@ impl<T: Writer> ConsoleTestState<T> {\n                 if self.use_color {\n                     try!(term.fg(color));\n                 }\n-                try!(term.write(word.as_bytes()));\n+                try!(term.write_all(word.as_bytes()));\n                 if self.use_color {\n                     try!(term.reset());\n                 }\n                 Ok(())\n             }\n-            Raw(ref mut stdout) => stdout.write(word.as_bytes())\n+            Raw(ref mut stdout) => stdout.write_all(word.as_bytes())\n         }\n     }\n \n     pub fn write_plain(&mut self, s: &str) -> old_io::IoResult<()> {\n         match self.out {\n-            Pretty(ref mut term) => term.write(s.as_bytes()),\n-            Raw(ref mut stdout) => stdout.write(s.as_bytes())\n+            Pretty(ref mut term) => term.write_all(s.as_bytes()),\n+            Raw(ref mut stdout) => stdout.write_all(s.as_bytes())\n         }\n     }\n \n@@ -558,7 +558,7 @@ impl<T: Writer> ConsoleTestState<T> {\n                         TrMetrics(ref mm) => mm.fmt_metrics(),\n                         TrBench(ref bs) => fmt_bench_samples(bs)\n                     }, test.name.as_slice());\n-                o.write(s.as_bytes())\n+                o.write_all(s.as_bytes())\n             }\n         }\n     }"}, {"sha": "799352911f605e66f9f70a4a9c7685069df5413e", "filename": "src/test/debuginfo/function-prologue-stepping-regular.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -156,7 +156,7 @@ fn assignment(mut a: u64, b: u64, c: f64) {\n }\n \n fn function_call(x: u64, y: u64, z: f64) {\n-    std::io::stdio::print(\"Hi!\")\n+    std::old_io::stdio::print(\"Hi!\")\n }\n \n fn identifier(x: u64, y: u64, z: f64) -> u64 {"}, {"sha": "8178a0d5a6cb5a067ea313df73493b922fe09b78", "filename": "src/test/run-pass/out-of-stack-no-split.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -16,7 +16,7 @@\n \n #![feature(asm)]\n \n-use std::io::process::Command;\n+use std::old_io::process::Command;\n use std::os;\n \n // lifted from the test module"}, {"sha": "e23d1a6222530e96e9006787c464db2a8c1a29a4", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d836cdf8666ce0af6911a0c89dffea4da74b374/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=5d836cdf8666ce0af6911a0c89dffea4da74b374", "patch": "@@ -17,15 +17,15 @@ extern crate log;\n extern crate libc;\n \n use std::sync::mpsc::channel;\n-use std::io::net::tcp::{TcpListener, TcpStream};\n-use std::io::{Acceptor, Listener};\n+use std::old_io::net::tcp::{TcpListener, TcpStream};\n+use std::old_io::{Acceptor, Listener};\n use std::thread::{Builder, Thread};\n use std::time::Duration;\n \n fn main() {\n     // This test has a chance to time out, try to not let it time out\n     Thread::spawn(move|| -> () {\n-        use std::io::timer;\n+        use std::old_io::timer;\n         timer::sleep(Duration::milliseconds(30 * 1000));\n         println!(\"timed out!\");\n         unsafe { libc::exit(1) }"}]}