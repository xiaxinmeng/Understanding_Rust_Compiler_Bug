{"sha": "2a738bb8edc7c0ed77bb12657a55db666cffeda3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNzM4YmI4ZWRjN2MwZWQ3N2JiMTI2NTdhNTVkYjY2NmNmZmVkYTM=", "commit": {"author": {"name": "LooMaclin", "email": "loo.maclin@protonmail.com", "date": "2019-04-08T20:34:28Z"}, "committer": {"name": "LooMaclin", "email": "loo.maclin@protonmail.com", "date": "2019-04-08T20:34:28Z"}, "message": "Improve miri's error reporting in check_in_alloc", "tree": {"sha": "6c1b63ef3b5c6d2328f06f9ed0fdc5fa7b94a570", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c1b63ef3b5c6d2328f06f9ed0fdc5fa7b94a570"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a738bb8edc7c0ed77bb12657a55db666cffeda3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a738bb8edc7c0ed77bb12657a55db666cffeda3", "html_url": "https://github.com/rust-lang/rust/commit/2a738bb8edc7c0ed77bb12657a55db666cffeda3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a738bb8edc7c0ed77bb12657a55db666cffeda3/comments", "author": {"login": "LooMaclin", "id": 10957765, "node_id": "MDQ6VXNlcjEwOTU3NzY1", "avatar_url": "https://avatars.githubusercontent.com/u/10957765?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LooMaclin", "html_url": "https://github.com/LooMaclin", "followers_url": "https://api.github.com/users/LooMaclin/followers", "following_url": "https://api.github.com/users/LooMaclin/following{/other_user}", "gists_url": "https://api.github.com/users/LooMaclin/gists{/gist_id}", "starred_url": "https://api.github.com/users/LooMaclin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LooMaclin/subscriptions", "organizations_url": "https://api.github.com/users/LooMaclin/orgs", "repos_url": "https://api.github.com/users/LooMaclin/repos", "events_url": "https://api.github.com/users/LooMaclin/events{/privacy}", "received_events_url": "https://api.github.com/users/LooMaclin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LooMaclin", "id": 10957765, "node_id": "MDQ6VXNlcjEwOTU3NzY1", "avatar_url": "https://avatars.githubusercontent.com/u/10957765?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LooMaclin", "html_url": "https://github.com/LooMaclin", "followers_url": "https://api.github.com/users/LooMaclin/followers", "following_url": "https://api.github.com/users/LooMaclin/following{/other_user}", "gists_url": "https://api.github.com/users/LooMaclin/gists{/gist_id}", "starred_url": "https://api.github.com/users/LooMaclin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LooMaclin/subscriptions", "organizations_url": "https://api.github.com/users/LooMaclin/orgs", "repos_url": "https://api.github.com/users/LooMaclin/repos", "events_url": "https://api.github.com/users/LooMaclin/events{/privacy}", "received_events_url": "https://api.github.com/users/LooMaclin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3449fa90f8534a197a20db6d757d9095d5124ba8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3449fa90f8534a197a20db6d757d9095d5124ba8", "html_url": "https://github.com/rust-lang/rust/commit/3449fa90f8534a197a20db6d757d9095d5124ba8"}], "stats": {"total": 62, "additions": 23, "deletions": 39}, "files": [{"sha": "ca680187b37db13df69100474226cc379bb42cea", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2a738bb8edc7c0ed77bb12657a55db666cffeda3/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a738bb8edc7c0ed77bb12657a55db666cffeda3/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=2a738bb8edc7c0ed77bb12657a55db666cffeda3", "patch": "@@ -25,35 +25,19 @@ pub enum InboundsCheck {\n /// Used by `check_in_alloc` to indicate context of check\n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum CheckInAllocMsg {\n-    ReadCStr,\n-    CheckBytes,\n-    WriteBytes,\n-    WriteRepeat,\n-    ReadScalar,\n-    WriteScalar,\n-    SlicePatCoveredByConst,\n-    ReadDiscriminant,\n-    CheckAlign,\n-    ReadBytes,\n-    CopyRepeatedly,\n-    CheckBounds,\n+    MemoryAccess,\n+    NullPointer,\n+    PointerArithmetic,\n+    OutOfBounds,\n }\n \n impl Display for CheckInAllocMsg {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", match *self {\n-            CheckInAllocMsg::ReadCStr => \"read C str\",\n-            CheckInAllocMsg::CheckBytes => \"check bytes\",\n-            CheckInAllocMsg::WriteBytes => \"write bytes\",\n-            CheckInAllocMsg::WriteRepeat => \"write repeat\",\n-            CheckInAllocMsg::ReadScalar => \"read scalar\",\n-            CheckInAllocMsg::WriteScalar => \"write scalar\",\n-            CheckInAllocMsg::SlicePatCoveredByConst => \"slice pat covered by const\",\n-            CheckInAllocMsg::ReadDiscriminant => \"read discriminant\",\n-            CheckInAllocMsg::CheckAlign => \"check align\",\n-            CheckInAllocMsg::ReadBytes => \"read bytes\",\n-            CheckInAllocMsg::CopyRepeatedly => \"copy repeatedly\",\n-            CheckInAllocMsg::CheckBounds => \"check bounds\",\n+            CheckInAllocMsg::MemoryAccess => \"memory access\",\n+            CheckInAllocMsg::NullPointer => \"null pointer\",\n+            CheckInAllocMsg::PointerArithmetic => \"pointer arithmetic\",\n+            CheckInAllocMsg::OutOfBounds => \"out of bounds\",\n         })\n     }\n }\n@@ -311,7 +295,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n                 // Go through `get_bytes` for checks and AllocationExtra hooks.\n                 // We read the null, so we include it in the request, but we want it removed\n                 // from the result!\n-                Ok(&self.get_bytes(cx, ptr, size_with_null, CheckInAllocMsg::ReadCStr)?[..size])\n+                Ok(&self.get_bytes(cx, ptr, size_with_null, CheckInAllocMsg::NullPointer)?[..size])\n             }\n             None => err!(UnterminatedCString(ptr.erase_tag())),\n         }\n@@ -331,7 +315,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         // Check bounds and relocations on the edges\n-        self.get_bytes_with_undef_and_ptr(cx, ptr, size, CheckInAllocMsg::CheckBytes)?;\n+        self.get_bytes_with_undef_and_ptr(cx, ptr, size, CheckInAllocMsg::OutOfBounds)?;\n         // Check undef and ptr\n         if !allow_ptr_and_undef {\n             self.check_defined(ptr, size)?;\n@@ -353,7 +337,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64),\n-                                       CheckInAllocMsg::WriteBytes)?;\n+                                       CheckInAllocMsg::MemoryAccess)?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n@@ -369,7 +353,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n         where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n-        let bytes = self.get_bytes_mut(cx, ptr, count, CheckInAllocMsg::WriteRepeat)?;\n+        let bytes = self.get_bytes_mut(cx, ptr, count, CheckInAllocMsg::MemoryAccess)?;\n         for b in bytes {\n             *b = val;\n         }\n@@ -394,7 +378,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         // get_bytes_unchecked tests relocation edges\n-        let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size, CheckInAllocMsg::ReadScalar)?;\n+        let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size, CheckInAllocMsg::PointerArithmetic)?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n@@ -471,7 +455,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         };\n \n         let endian = cx.data_layout().endian;\n-        let dst = self.get_bytes_mut(cx, ptr, type_size, CheckInAllocMsg::WriteScalar)?;\n+        let dst = self.get_bytes_mut(cx, ptr, type_size, CheckInAllocMsg::PointerArithmetic)?;\n         write_target_uint(endian, dst, bytes).unwrap();\n \n         // See if we have to also write a relocation"}, {"sha": "1e2ffa5db440b41fa181df41baed7c3bac746bef", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a738bb8edc7c0ed77bb12657a55db666cffeda3/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a738bb8edc7c0ed77bb12657a55db666cffeda3/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=2a738bb8edc7c0ed77bb12657a55db666cffeda3", "patch": "@@ -1419,7 +1419,7 @@ fn slice_pat_covered_by_const<'tcx>(\n             }\n             let n = n.assert_usize(tcx).unwrap();\n             alloc.get_bytes(&tcx, ptr, Size::from_bytes(n),\n-                            CheckInAllocMsg::SlicePatCoveredByConst).unwrap()\n+                            CheckInAllocMsg::OutOfBounds).unwrap()\n         },\n         // a slice fat pointer to a zero length slice\n         (ConstValue::Slice(Scalar::Bits { .. }, 0), ty::Slice(t)) => {\n@@ -1444,7 +1444,7 @@ fn slice_pat_covered_by_const<'tcx>(\n             tcx.alloc_map\n                 .lock()\n                 .unwrap_memory(ptr.alloc_id)\n-                .get_bytes(&tcx, ptr, Size::from_bytes(n), CheckInAllocMsg::SlicePatCoveredByConst)\n+                .get_bytes(&tcx, ptr, Size::from_bytes(n), CheckInAllocMsg::OutOfBounds)\n                 .unwrap()\n         },\n         _ => bug!("}, {"sha": "a911479a15a23211d624de8696dc36e93d95e504", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a738bb8edc7c0ed77bb12657a55db666cffeda3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a738bb8edc7c0ed77bb12657a55db666cffeda3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=2a738bb8edc7c0ed77bb12657a55db666cffeda3", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             Scalar::Ptr(ptr) => {\n                 // check this is not NULL -- which we can ensure only if this is in-bounds\n                 // of some (potentially dead) allocation.\n-                let align = self.check_bounds_ptr(ptr, CheckInAllocMsg::CheckAlign)?;\n+                let align = self.check_bounds_ptr(ptr, CheckInAllocMsg::NullPointer)?;\n                 (ptr.offset.bytes(), align)\n             }\n             Scalar::Bits { bits, size } => {\n@@ -440,7 +440,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 Ok((layout.size, layout.align.abi))\n             }\n             _ => match msg {\n-                CheckInAllocMsg::CheckAlign | CheckInAllocMsg::ReadDiscriminant => {\n+                CheckInAllocMsg::NullPointer | CheckInAllocMsg::OutOfBounds => {\n                     // Must be a deallocated pointer\n                     Ok(*self.dead_alloc_map.get(&id).expect(\n                         \"allocation missing in dead_alloc_map\"\n@@ -604,7 +604,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             Ok(&[])\n         } else {\n             let ptr = ptr.to_ptr()?;\n-            self.get(ptr.alloc_id)?.get_bytes(self, ptr, size, CheckInAllocMsg::ReadBytes)\n+            self.get(ptr.alloc_id)?.get_bytes(self, ptr, size, CheckInAllocMsg::MemoryAccess)\n         }\n     }\n }\n@@ -729,10 +729,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         // This checks relocation edges on the src.\n         let src_bytes = self.get(src.alloc_id)?\n-            .get_bytes_with_undef_and_ptr(&tcx, src, size, CheckInAllocMsg::CopyRepeatedly)?\n+            .get_bytes_with_undef_and_ptr(&tcx, src, size, CheckInAllocMsg::MemoryAccess)?\n             .as_ptr();\n         let dest_bytes = self.get_mut(dest.alloc_id)?\n-            .get_bytes_mut(&tcx, dest, size * length, CheckInAllocMsg::CopyRepeatedly)?\n+            .get_bytes_mut(&tcx, dest, size * length, CheckInAllocMsg::MemoryAccess)?\n             .as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes"}, {"sha": "e7e22a12cd68f53657b26975c3e367228e96a7c7", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a738bb8edc7c0ed77bb12657a55db666cffeda3/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a738bb8edc7c0ed77bb12657a55db666cffeda3/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=2a738bb8edc7c0ed77bb12657a55db666cffeda3", "patch": "@@ -668,7 +668,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n                             self.memory.check_bounds_ptr(ptr,\n-                                                         CheckInAllocMsg::ReadDiscriminant).is_ok();\n+                                                         CheckInAllocMsg::OutOfBounds).is_ok();\n                         if !ptr_valid {\n                             return err!(InvalidDiscriminant(raw_discr.erase_tag()));\n                         }"}, {"sha": "965b2898cad53a92f2b0c42726a057bdb0555b5d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a738bb8edc7c0ed77bb12657a55db666cffeda3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a738bb8edc7c0ed77bb12657a55db666cffeda3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=2a738bb8edc7c0ed77bb12657a55db666cffeda3", "patch": "@@ -394,7 +394,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                         try_validation!(\n                             self.ecx.memory\n                                 .get(ptr.alloc_id)?\n-                                .check_bounds(self.ecx, ptr, size, CheckInAllocMsg::CheckBounds),\n+                                .check_bounds(self.ecx, ptr, size, CheckInAllocMsg::OutOfBounds),\n                             \"dangling (not entirely in bounds) reference\", self.path);\n                     }\n                     // Check if we have encountered this pointer+layout combination"}]}