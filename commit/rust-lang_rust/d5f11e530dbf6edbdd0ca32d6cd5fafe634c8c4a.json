{"sha": "d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZjExZTUzMGRiZjZlZGJkZDBjYTMyZDZjZDVmYWZlNjM0YzhjNGE=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-06-27T21:11:43Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-08-10T12:44:54Z"}, "message": "Unsafe borrow of packed fields: account for borrow through ref binding, auto ref function calls", "tree": {"sha": "b348ea6d5552be08913ac3a451836cad5ac75c1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b348ea6d5552be08913ac3a451836cad5ac75c1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "html_url": "https://github.com/rust-lang/rust/commit/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38440d53d8329ac9f3f2013c6e32b3f69b069c72", "url": "https://api.github.com/repos/rust-lang/rust/commits/38440d53d8329ac9f3f2013c6e32b3f69b069c72", "html_url": "https://github.com/rust-lang/rust/commit/38440d53d8329ac9f3f2013c6e32b3f69b069c72"}], "stats": {"total": 204, "additions": 156, "deletions": 48}, "files": [{"sha": "a880fa6713d817c2592959ff8f4a07d29bc1466e", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "patch": "@@ -11,6 +11,7 @@ use hir_def::{\n     docs::Documentation,\n     expr::{BindingAnnotation, Pat, PatId},\n     import_map,\n+    item_tree::SelfParam,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n@@ -670,8 +671,8 @@ impl Function {\n         db.function_data(self.id).name.clone()\n     }\n \n-    pub fn has_self_param(self, db: &dyn HirDatabase) -> bool {\n-        db.function_data(self.id).has_self_param\n+    pub fn self_param(self, db: &dyn HirDatabase) -> Option<SelfParam> {\n+        db.function_data(self.id).self_param\n     }\n \n     pub fn params(self, db: &dyn HirDatabase) -> Vec<TypeRef> {"}, {"sha": "2a26b0183e2a4c090d98190980d69c0266a33a0f", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "patch": "@@ -10,7 +10,7 @@ use crate::{\n     attr::Attrs,\n     body::Expander,\n     db::DefDatabase,\n-    item_tree::{AssocItem, ItemTreeId, ModItem},\n+    item_tree::{AssocItem, ItemTreeId, ModItem, SelfParam},\n     type_ref::{TypeBound, TypeRef},\n     visibility::RawVisibility,\n     AssocContainerId, AssocItemId, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n@@ -25,7 +25,7 @@ pub struct FunctionData {\n     pub attrs: Attrs,\n     /// True if the first param is `self`. This is relevant to decide whether this\n     /// can be called as a method.\n-    pub has_self_param: bool,\n+    pub self_param: Option<SelfParam>,\n     pub is_unsafe: bool,\n     pub is_varargs: bool,\n     pub visibility: RawVisibility,\n@@ -42,7 +42,7 @@ impl FunctionData {\n             params: func.params.to_vec(),\n             ret_type: func.ret_type.clone(),\n             attrs: item_tree.attrs(ModItem::from(loc.id.value).into()).clone(),\n-            has_self_param: func.has_self_param,\n+            self_param: func.self_param,\n             is_unsafe: func.is_unsafe,\n             is_varargs: func.is_varargs,\n             visibility: item_tree[func.visibility].clone(),"}, {"sha": "1eaea66e4a32bce26910e4e8c3791fea22098eff", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "patch": "@@ -500,14 +500,20 @@ pub struct Function {\n     pub name: Name,\n     pub visibility: RawVisibilityId,\n     pub generic_params: GenericParamsId,\n-    pub has_self_param: bool,\n+    pub self_param: Option<SelfParam>,\n     pub is_unsafe: bool,\n     pub params: Box<[TypeRef]>,\n     pub is_varargs: bool,\n     pub ret_type: TypeRef,\n     pub ast_id: FileAstId<ast::Fn>,\n }\n \n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+pub struct SelfParam {\n+    pub is_ref: bool,\n+    pub is_mut: bool,\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Struct {\n     pub name: Name,"}, {"sha": "89ad91d376fb471955e3614ef4509255573f0210", "filename": "crates/ra_hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "patch": "@@ -283,7 +283,7 @@ impl Ctx {\n         let name = func.name()?.as_name();\n \n         let mut params = Vec::new();\n-        let mut has_self_param = false;\n+        let mut func_self_param = None;\n         if let Some(param_list) = func.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n                 let self_type = match self_param.ty() {\n@@ -302,7 +302,10 @@ impl Ctx {\n                     }\n                 };\n                 params.push(self_type);\n-                has_self_param = true;\n+                func_self_param = Some(SelfParam {\n+                    is_ref: self_param.amp_token().is_some(),\n+                    is_mut: self_param.mut_token().is_some(),\n+                });\n             }\n             for param in param_list.params() {\n                 let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ty());\n@@ -335,7 +338,7 @@ impl Ctx {\n             name,\n             visibility,\n             generic_params: GenericParamsId::EMPTY,\n-            has_self_param,\n+            self_param: func_self_param,\n             is_unsafe: func.unsafe_token().is_some(),\n             params: params.into_boxed_slice(),\n             is_varargs,"}, {"sha": "79c5adf0f1bd4ca42a1ab61129f9e3b3a8e9799e", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "patch": "@@ -640,7 +640,7 @@ fn is_valid_candidate(\n                 }\n             }\n             if let Some(receiver_ty) = receiver_ty {\n-                if !data.has_self_param {\n+                if data.self_param.is_none() {\n                     return false;\n                 }\n                 let transformed_receiver_ty = match transform_receiver_ty(db, m, self_ty) {"}, {"sha": "5488db43f72086b244ec6d2188a6e18f649b48a2", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "patch": "@@ -48,7 +48,7 @@ fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &T\n         let mut seen_methods = FxHashSet::default();\n         let traits_in_scope = ctx.scope.traits_in_scope();\n         receiver.iterate_method_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, func| {\n-            if func.has_self_param(ctx.db)\n+            if func.self_param(ctx.db).is_some()\n                 && ctx.scope.module().map_or(true, |m| func.is_visible_from(ctx.db, m))\n                 && seen_methods.insert(func.name(ctx.db))\n             {"}, {"sha": "e3ba7ebc47f51049dafa5cd48531777a12b67ac5", "filename": "crates/ra_ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "patch": "@@ -136,7 +136,7 @@ fn add_function_impl(\n         .lookup_by(fn_name)\n         .set_documentation(func.docs(ctx.db));\n \n-    let completion_kind = if func.has_self_param(ctx.db) {\n+    let completion_kind = if func.self_param(ctx.db).is_some() {\n         CompletionItemKind::Method\n     } else {\n         CompletionItemKind::Function"}, {"sha": "fc3d1a4bda43eacf08d6390353ef718d3dbaa287", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "patch": "@@ -191,7 +191,7 @@ impl Completions {\n         func: hir::Function,\n         local_name: Option<String>,\n     ) {\n-        let has_self_param = func.has_self_param(ctx.db);\n+        let has_self_param = func.self_param(ctx.db).is_some();\n \n         let name = local_name.unwrap_or_else(|| func.name(ctx.db).to_string());\n         let ast_node = func.source(ctx.db).value;"}, {"sha": "454fef39c6611dd259176b5367b2a80b69caf562", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 117, "deletions": 20, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "patch": "@@ -497,9 +497,9 @@ fn highlight_element(\n             match name_kind {\n                 Some(NameClass::ExternCrate(_)) => HighlightTag::Module.into(),\n                 Some(NameClass::Definition(def)) => {\n-                    highlight_name(db, def, false) | HighlightModifier::Definition\n+                    highlight_name(sema, db, def, None, false) | HighlightModifier::Definition\n                 }\n-                Some(NameClass::ConstReference(def)) => highlight_name(db, def, false),\n+                Some(NameClass::ConstReference(def)) => highlight_name(sema, db, def, None, false),\n                 Some(NameClass::FieldShorthand { field, .. }) => {\n                     let mut h = HighlightTag::Field.into();\n                     if let Definition::Field(field) = field {\n@@ -532,7 +532,7 @@ fn highlight_element(\n                                 binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n                             }\n                         };\n-                        highlight_name(db, def, possibly_unsafe)\n+                        highlight_name(sema, db, def, Some(name_ref), possibly_unsafe)\n                     }\n                     NameRefClass::FieldShorthand { .. } => HighlightTag::Field.into(),\n                 },\n@@ -565,8 +565,8 @@ fn highlight_element(\n                 _ => h,\n             }\n         }\n-        REF_EXPR => {\n-            let ref_expr = element.into_node().and_then(ast::RefExpr::cast)?;\n+        T![&] => {\n+            let ref_expr = element.parent().and_then(ast::RefExpr::cast)?;\n             let expr = ref_expr.expr()?;\n             let field_expr = match expr {\n                 ast::Expr::FieldExpr(fe) => fe,\n@@ -668,6 +668,52 @@ fn highlight_element(\n                         HighlightTag::SelfKeyword.into()\n                     }\n                 }\n+                T![ref] => {\n+                    let modifier: Option<HighlightModifier> = (|| {\n+                        let bind_pat = element.parent().and_then(ast::BindPat::cast)?;\n+                        let parent = bind_pat.syntax().parent()?;\n+\n+                        let ty = if let Some(pat_list) =\n+                            ast::RecordFieldPatList::cast(parent.clone())\n+                        {\n+                            let record_pat =\n+                                pat_list.syntax().parent().and_then(ast::RecordPat::cast)?;\n+                            sema.type_of_pat(&ast::Pat::RecordPat(record_pat))\n+                        } else if let Some(let_stmt) = ast::LetStmt::cast(parent.clone()) {\n+                            let field_expr =\n+                                if let ast::Expr::FieldExpr(field_expr) = let_stmt.initializer()? {\n+                                    field_expr\n+                                } else {\n+                                    return None;\n+                                };\n+\n+                            sema.type_of_expr(&field_expr.expr()?)\n+                        } else if let Some(record_field_pat) = ast::RecordFieldPat::cast(parent) {\n+                            let record_pat = record_field_pat\n+                                .syntax()\n+                                .parent()\n+                                .and_then(ast::RecordFieldPatList::cast)?\n+                                .syntax()\n+                                .parent()\n+                                .and_then(ast::RecordPat::cast)?;\n+                            sema.type_of_pat(&ast::Pat::RecordPat(record_pat))\n+                        } else {\n+                            None\n+                        }?;\n+\n+                        if !ty.is_packed(db) {\n+                            return None;\n+                        }\n+\n+                        Some(HighlightModifier::Unsafe)\n+                    })();\n+\n+                    if let Some(modifier) = modifier {\n+                        h | modifier\n+                    } else {\n+                        h\n+                    }\n+                }\n                 _ => h,\n             }\n         }\n@@ -697,7 +743,13 @@ fn is_child_of_impl(element: &SyntaxElement) -> bool {\n     }\n }\n \n-fn highlight_name(db: &RootDatabase, def: Definition, possibly_unsafe: bool) -> Highlight {\n+fn highlight_name(\n+    sema: &Semantics<RootDatabase>,\n+    db: &RootDatabase,\n+    def: Definition,\n+    name_ref: Option<ast::NameRef>,\n+    possibly_unsafe: bool,\n+) -> Highlight {\n     match def {\n         Definition::Macro(_) => HighlightTag::Macro,\n         Definition::Field(field) => {\n@@ -716,6 +768,29 @@ fn highlight_name(db: &RootDatabase, def: Definition, possibly_unsafe: bool) ->\n                 let mut h = HighlightTag::Function.into();\n                 if func.is_unsafe(db) {\n                     h |= HighlightModifier::Unsafe;\n+                } else {\n+                    (|| {\n+                        let method_call_expr =\n+                            name_ref?.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n+                        let expr = method_call_expr.expr()?;\n+                        let field_expr = if let ast::Expr::FieldExpr(field_expr) = expr {\n+                            Some(field_expr)\n+                        } else {\n+                            None\n+                        }?;\n+                        let ty = sema.type_of_expr(&field_expr.expr()?)?;\n+                        if !ty.is_packed(db) {\n+                            return None;\n+                        }\n+\n+                        let func = sema.resolve_method_call(&method_call_expr)?;\n+                        if func.self_param(db)?.is_ref {\n+                            Some(HighlightModifier::Unsafe)\n+                        } else {\n+                            None\n+                        }\n+                    })()\n+                    .map(|modifier| h |= modifier);\n                 }\n                 return h;\n             }\n@@ -787,8 +862,33 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n         _ => return default.into(),\n     };\n \n-    let tag = match parent.kind() {\n-        METHOD_CALL_EXPR => HighlightTag::Function,\n+    match parent.kind() {\n+        METHOD_CALL_EXPR => {\n+            let mut h = Highlight::new(HighlightTag::Function);\n+            let modifier: Option<HighlightModifier> = (|| {\n+                let method_call_expr = ast::MethodCallExpr::cast(parent)?;\n+                let expr = method_call_expr.expr()?;\n+                let field_expr = if let ast::Expr::FieldExpr(field_expr) = expr {\n+                    field_expr\n+                } else {\n+                    return None;\n+                };\n+\n+                let expr = field_expr.expr()?;\n+                let ty = sema.type_of_expr(&expr)?;\n+                if ty.is_packed(sema.db) {\n+                    Some(HighlightModifier::Unsafe)\n+                } else {\n+                    None\n+                }\n+            })();\n+\n+            if let Some(modifier) = modifier {\n+                h |= modifier;\n+            }\n+\n+            h\n+        }\n         FIELD_EXPR => {\n             let h = HighlightTag::Field;\n             let is_union = ast::FieldExpr::cast(parent)\n@@ -801,7 +901,7 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n                     })\n                 })\n                 .unwrap_or(false);\n-            return if is_union { h | HighlightModifier::Unsafe } else { h.into() };\n+            if is_union { h | HighlightModifier::Unsafe } else { h.into() }\n         }\n         PATH_SEGMENT => {\n             let path = match parent.parent().and_then(ast::Path::cast) {\n@@ -826,18 +926,15 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n             };\n \n             match parent.kind() {\n-                CALL_EXPR => HighlightTag::Function,\n-                _ => {\n-                    if name.text().chars().next().unwrap_or_default().is_uppercase() {\n-                        HighlightTag::Struct\n-                    } else {\n-                        HighlightTag::Constant\n-                    }\n+                CALL_EXPR => HighlightTag::Function.into(),\n+                _ => if name.text().chars().next().unwrap_or_default().is_uppercase() {\n+                    HighlightTag::Struct.into()\n+                } else {\n+                    HighlightTag::Constant\n                 }\n+                .into(),\n             }\n         }\n-        _ => default,\n-    };\n-\n-    tag.into()\n+        _ => default.into(),\n+    }\n }"}, {"sha": "a8087635a878e3801ef95d0396eadc9d4040be2a", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=d5f11e530dbf6edbdd0ca32d6cd5fafe634c8c4a", "patch": "@@ -301,37 +301,38 @@ trait DoTheAutoref {\n     fn calls_autoref(&self);\n }\n \n-struct NeedsAlign {\n-    a: u16\n-}\n-\n-#[repr(packed)]\n-struct HasAligned {\n-    a: NeedsAlign\n-}\n-\n-impl DoTheAutoref for NeedsAlign {\n+impl DoTheAutoref for u16 {\n     fn calls_autoref(&self) {}\n }\n \n fn main() {\n     let x = &5 as *const _ as *const usize;\n     let u = Union { b: 0 };\n     unsafe {\n+        // unsafe fn and method calls\n         unsafe_fn();\n         let b = u.b;\n         match u {\n             Union { b: 0 } => (),\n             Union { a } => (),\n         }\n         HasUnsafeFn.unsafe_method();\n-        let _y = *(x);\n-        let z = -x;\n+\n+        // unsafe deref\n+        let y = *x;\n+\n+        // unsafe access to a static mut\n         let a = global_mut.a;\n+\n+        // unsafe ref of packed fields\n         let packed = Packed { a: 0 };\n-        let _a = &packed.a;\n-        let h = HasAligned{ a: NeedsAlign { a: 1 } };\n-        h.a.calls_autoref();\n+        let a = &packed.a;\n+        let ref a = packed.a;\n+        let Packed { ref a } = packed;\n+        let Packed { a: ref _a } = packed;\n+\n+        // unsafe auto ref of packed field\n+        packed.a.calls_autoref();\n     }\n }\n \"#"}]}