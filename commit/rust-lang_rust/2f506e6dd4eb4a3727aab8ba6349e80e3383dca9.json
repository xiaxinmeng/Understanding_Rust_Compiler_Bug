{"sha": "2f506e6dd4eb4a3727aab8ba6349e80e3383dca9", "node_id": "C_kwDOAAsO6NoAKDJmNTA2ZTZkZDRlYjRhMzcyN2FhYjhiYTYzNDllODBlMzM4M2RjYTk", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev+love@gmail.com", "date": "2022-11-22T21:40:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-22T21:40:21Z"}, "message": "Rollup merge of #101368 - thomcc:wintls-noinline, r=ChrisDenton\n\nForbid inlining `thread_local!`'s `__getit` function on Windows\n\nSadly, this will make things slower to avoid UB in an edge case, but it seems hard to avoid... and really whenever I look at this code I can't help but think we're asking for trouble.\n\nIt's pretty dodgy for us to leave this as a normal function rather than `#[inline(never)]`, given that if it *does* get inlined into a dynamically linked component, it's extremely unsafe (you get some other thread local, or if you're lucky, crash). Given that it's pretty rare for people to use dylibs on Windows, the fact that we haven't gotten bug reports about it isn't really that convincing. Ideally we'd come up with some kind of compiler solution (that avoids paying for this cost when static linking, or *at least* for use within the same crate...), but it's not clear what that looks like.\n\nOh, and because all this is only needed when we're implementing `thread_local!` with `#[thread_local]`, this patch adjusts the `cfg_attr` to be `all(windows, target_thread_local)` as well.\n\nr? ``@ChrisDenton``\n\nSee also #84933, which is about improving the situation.", "tree": {"sha": "c0ecc6c06b2125c002d8e2dab003a62b79c9d10c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0ecc6c06b2125c002d8e2dab003a62b79c9d10c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f506e6dd4eb4a3727aab8ba6349e80e3383dca9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjfUHFCRBK7hj4Ov3rIwAAAcEIABI9w0y4gFqeIo6YoiViCjCK\nf8TufXaZfYYKx78HQNZtTIbF+UK505EXYFTCT12c1ogAhETv8AMeH6TztICkCv+2\nSuj9Xe+xd62f6hXZDw5BMLzJDl6bmaU5gtMZ2VrtXcPnSE5HLuny6MazBDqVa40R\nH5rWXsoSAON/uxC9+Kc4ewT+/s8Q8jAwEKRI7bp5yoq8Vy89aL4mcp9hBAPAKBmL\n70Z9KZJb/Y1+iiFmPVBBXNqJ3OrknzQP08IgG5lL6HaeWr18ezzAyHoGqEKQ8YaX\npkEXMzwtTAFLmzYTW3sJUEyNEaghMyIHnV3+P9KTMI3mniT1y2RM53uTVAH1twI=\n=YVcW\n-----END PGP SIGNATURE-----\n", "payload": "tree c0ecc6c06b2125c002d8e2dab003a62b79c9d10c\nparent e221616639fb87de9dca21e252ee8a2565ec51d0\nparent 3099dfdd9fc1a331eb9c53200b310fa1a06e1573\nauthor Yuki Okushi <huyuumi.dev+love@gmail.com> 1669153221 +0900\ncommitter GitHub <noreply@github.com> 1669153221 +0900\n\nRollup merge of #101368 - thomcc:wintls-noinline, r=ChrisDenton\n\nForbid inlining `thread_local!`'s `__getit` function on Windows\n\nSadly, this will make things slower to avoid UB in an edge case, but it seems hard to avoid... and really whenever I look at this code I can't help but think we're asking for trouble.\n\nIt's pretty dodgy for us to leave this as a normal function rather than `#[inline(never)]`, given that if it *does* get inlined into a dynamically linked component, it's extremely unsafe (you get some other thread local, or if you're lucky, crash). Given that it's pretty rare for people to use dylibs on Windows, the fact that we haven't gotten bug reports about it isn't really that convincing. Ideally we'd come up with some kind of compiler solution (that avoids paying for this cost when static linking, or *at least* for use within the same crate...), but it's not clear what that looks like.\n\nOh, and because all this is only needed when we're implementing `thread_local!` with `#[thread_local]`, this patch adjusts the `cfg_attr` to be `all(windows, target_thread_local)` as well.\n\nr? ``@ChrisDenton``\n\nSee also #84933, which is about improving the situation.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f506e6dd4eb4a3727aab8ba6349e80e3383dca9", "html_url": "https://github.com/rust-lang/rust/commit/2f506e6dd4eb4a3727aab8ba6349e80e3383dca9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f506e6dd4eb4a3727aab8ba6349e80e3383dca9/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e221616639fb87de9dca21e252ee8a2565ec51d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e221616639fb87de9dca21e252ee8a2565ec51d0", "html_url": "https://github.com/rust-lang/rust/commit/e221616639fb87de9dca21e252ee8a2565ec51d0"}, {"sha": "3099dfdd9fc1a331eb9c53200b310fa1a06e1573", "url": "https://api.github.com/repos/rust-lang/rust/commits/3099dfdd9fc1a331eb9c53200b310fa1a06e1573", "html_url": "https://github.com/rust-lang/rust/commit/3099dfdd9fc1a331eb9c53200b310fa1a06e1573"}], "stats": {"total": 25, "additions": 16, "deletions": 9}, "files": [{"sha": "154b608c0dc5c30cbc183117ac1ed847391f5cd0", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2f506e6dd4eb4a3727aab8ba6349e80e3383dca9/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f506e6dd4eb4a3727aab8ba6349e80e3383dca9/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=2f506e6dd4eb4a3727aab8ba6349e80e3383dca9", "patch": "@@ -181,7 +181,8 @@ macro_rules! thread_local {\n macro_rules! __thread_local_inner {\n     // used to generate the `LocalKey` value for const-initialized thread locals\n     (@key $t:ty, const $init:expr) => {{\n-        #[cfg_attr(not(windows), inline)] // see comments below\n+        #[cfg_attr(not(all(windows, target_thread_local)), inline)] // see comments below\n+        #[cfg_attr(all(windows, target_thread_local), inline(never))]\n         #[deny(unsafe_op_in_unsafe_fn)]\n         unsafe fn __getit(\n             _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n@@ -294,12 +295,17 @@ macro_rules! __thread_local_inner {\n             fn __init() -> $t { $init }\n \n             // When reading this function you might ask \"why is this inlined\n-            // everywhere other than Windows?\", and that's a very reasonable\n-            // question to ask. The short story is that it segfaults rustc if\n-            // this function is inlined. The longer story is that Windows looks\n-            // to not support `extern` references to thread locals across DLL\n-            // boundaries. This appears to at least not be supported in the ABI\n-            // that LLVM implements.\n+            // everywhere other than Windows?\", and \"why must it not be inlined\n+            // on Windows?\" and these are very reasonable questions to ask.\n+            //\n+            // The short story is that Windows doesn't support referencing\n+            // `#[thread_local]` across DLL boundaries. The slightly longer\n+            // story is that each module (dll or exe) has its own separate set\n+            // of static thread locals, so if you try and reference a\n+            // `#[thread_local]` that comes from `crate1.dll` from within one of\n+            // `crate2.dll`'s functions, then it might give you a completely\n+            // different thread local than what you asked for (or it might just\n+            // crash).\n             //\n             // Because of this we never inline on Windows, but we do inline on\n             // other platforms (where external references to thread locals\n@@ -314,8 +320,9 @@ macro_rules! __thread_local_inner {\n             // Cargo question kinda). This means that, unfortunately, Windows\n             // gets the pessimistic path for now where it's never inlined.\n             //\n-            // The issue of \"should enable on Windows sometimes\" is #84933\n-            #[cfg_attr(not(windows), inline)]\n+            // The issue of \"should improve things on Windows\" is #84933\n+            #[cfg_attr(not(all(windows, target_thread_local)), inline)]\n+            #[cfg_attr(all(windows, target_thread_local), inline(never))]\n             unsafe fn __getit(\n                 init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n             ) -> $crate::option::Option<&'static $t> {"}]}