{"sha": "fad99542c8643984b7630d8e297007aef824b268", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZDk5NTQyYzg2NDM5ODRiNzYzMGQ4ZTI5NzAwN2FlZjgyNGIyNjg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-19T09:52:30Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:31Z"}, "message": "rustc: split layout::FieldPlacement::Linear back into Union and Array.", "tree": {"sha": "e062bb878e8201a788efcd1add9264b8f92432c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e062bb878e8201a788efcd1add9264b8f92432c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fad99542c8643984b7630d8e297007aef824b268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fad99542c8643984b7630d8e297007aef824b268", "html_url": "https://github.com/rust-lang/rust/commit/fad99542c8643984b7630d8e297007aef824b268", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fad99542c8643984b7630d8e297007aef824b268/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3", "html_url": "https://github.com/rust-lang/rust/commit/18d54aa7d52c271c8a352fe6ccdefa80b100d0d3"}], "stats": {"total": 71, "additions": 36, "deletions": 35}, "files": [{"sha": "4d74e5eed5919ee2a050fd64d43246c472c06d21", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fad99542c8643984b7630d8e297007aef824b268/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad99542c8643984b7630d8e297007aef824b268/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=fad99542c8643984b7630d8e297007aef824b268", "patch": "@@ -635,9 +635,11 @@ pub const FAT_PTR_EXTRA: usize = 1;\n /// Describes how the fields of a type are located in memory.\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub enum FieldPlacement {\n-    /// Array-like placement. Can also express\n-    /// unions, by using a stride of zero bytes.\n-    Linear {\n+    /// All fields start at no offset. The `usize` is the field count.\n+    Union(usize),\n+\n+    /// Array/vector-like placement, with all fields of identical types.\n+    Array {\n         stride: Size,\n         count: u64\n     },\n@@ -664,16 +666,10 @@ pub enum FieldPlacement {\n }\n \n impl FieldPlacement {\n-    pub fn union(count: usize) -> Self {\n-        FieldPlacement::Linear {\n-            stride: Size::from_bytes(0),\n-            count: count as u64\n-        }\n-    }\n-\n     pub fn count(&self) -> usize {\n         match *self {\n-            FieldPlacement::Linear { count, .. } => {\n+            FieldPlacement::Union(count) => count,\n+            FieldPlacement::Array { count, .. } => {\n                 let usize_count = count as usize;\n                 assert_eq!(usize_count as u64, count);\n                 usize_count\n@@ -684,7 +680,8 @@ impl FieldPlacement {\n \n     pub fn offset(&self, i: usize) -> Size {\n         match *self {\n-            FieldPlacement::Linear { stride, count } => {\n+            FieldPlacement::Union(_) => Size::from_bytes(0),\n+            FieldPlacement::Array { stride, count } => {\n                 let i = i as u64;\n                 assert!(i < count);\n                 stride * i\n@@ -695,7 +692,8 @@ impl FieldPlacement {\n \n     pub fn memory_index(&self, i: usize) -> usize {\n         match *self {\n-            FieldPlacement::Linear { .. } => i,\n+            FieldPlacement::Union(_) |\n+            FieldPlacement::Array { .. } => i,\n             FieldPlacement::Arbitrary { ref memory_index, .. } => {\n                 let r = memory_index[i];\n                 assert_eq!(r as usize as u32, r);\n@@ -727,7 +725,8 @@ impl FieldPlacement {\n \n         (0..self.count()).map(move |i| {\n             match *self {\n-                FieldPlacement::Linear { .. } => i,\n+                FieldPlacement::Union(_) |\n+                FieldPlacement::Array { .. } => i,\n                 FieldPlacement::Arbitrary { .. } => {\n                     if use_small { inverse_small[i] as usize }\n                     else { inverse_big[i] as usize }\n@@ -945,7 +944,7 @@ impl<'a, 'tcx> Layout {\n         let scalar = |value| {\n             tcx.intern_layout(CachedLayout {\n                 layout: Layout::Scalar,\n-                fields: FieldPlacement::union(0),\n+                fields: FieldPlacement::Union(0),\n                 abi: Abi::Scalar(value)\n             })\n         };\n@@ -1118,12 +1117,12 @@ impl<'a, 'tcx> Layout {\n \n             // Effectively a (ptr, meta) tuple.\n             let align = Pointer.align(dl).max(metadata.align(dl));\n-            let fields = FieldPlacement::Linear {\n-                stride: Pointer.size(dl),\n-                count: 2\n-            };\n-            let meta_offset = fields.offset(1);\n+            let meta_offset = Pointer.size(dl);\n             assert_eq!(meta_offset, meta_offset.abi_align(metadata.align(dl)));\n+            let fields = FieldPlacement::Arbitrary {\n+                offsets: vec![Size::from_bytes(0), meta_offset],\n+                memory_index: vec![0, 1]\n+            };\n             Ok(tcx.intern_layout(CachedLayout {\n                 layout: Layout::FatPointer,\n                 fields,\n@@ -1182,7 +1181,7 @@ impl<'a, 'tcx> Layout {\n \n                 tcx.intern_layout(CachedLayout {\n                     layout: Layout::Array,\n-                    fields: FieldPlacement::Linear {\n+                    fields: FieldPlacement::Array {\n                         stride: element_size,\n                         count\n                     },\n@@ -1199,7 +1198,7 @@ impl<'a, 'tcx> Layout {\n                 let element = cx.layout_of(element)?;\n                 tcx.intern_layout(CachedLayout {\n                     layout: Layout::Array,\n-                    fields: FieldPlacement::Linear {\n+                    fields: FieldPlacement::Array {\n                         stride: element.size(dl),\n                         count: 0\n                     },\n@@ -1215,7 +1214,7 @@ impl<'a, 'tcx> Layout {\n             ty::TyStr => {\n                 tcx.intern_layout(CachedLayout {\n                     layout: Layout::Array,\n-                    fields: FieldPlacement::Linear {\n+                    fields: FieldPlacement::Array {\n                         stride: Size::from_bytes(1),\n                         count: 0\n                     },\n@@ -1283,7 +1282,7 @@ impl<'a, 'tcx> Layout {\n                 };\n                 tcx.intern_layout(CachedLayout {\n                     layout: Layout::Vector,\n-                    fields: FieldPlacement::Linear {\n+                    fields: FieldPlacement::Array {\n                         stride: element.size(tcx),\n                         count\n                     },\n@@ -1340,7 +1339,7 @@ impl<'a, 'tcx> Layout {\n \n                     return Ok(tcx.intern_layout(CachedLayout {\n                         layout: Layout::UntaggedUnion,\n-                        fields: FieldPlacement::union(variants[0].len()),\n+                        fields: FieldPlacement::Union(variants[0].len()),\n                         abi: Abi::Aggregate {\n                             sized: true,\n                             packed,\n@@ -2282,7 +2281,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for FieldPlacement {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            Linear { count, stride } => {\n+            Union(count) => {\n+                count.hash_stable(hcx, hasher);\n+            }\n+            Array { count, stride } => {\n                 count.hash_stable(hcx, hasher);\n                 stride.hash_stable(hcx, hasher);\n             }"}, {"sha": "365570edd65efa609a4c3fbc30a1876ab3581200", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fad99542c8643984b7630d8e297007aef824b268/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad99542c8643984b7630d8e297007aef824b268/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=fad99542c8643984b7630d8e297007aef824b268", "patch": "@@ -35,7 +35,7 @@ use type_::Type;\n \n use rustc::hir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Align, Layout, Size, FullLayout};\n+use rustc::ty::layout::{self, Align, Size, FullLayout};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc_back::PanicStrategy;\n \n@@ -307,19 +307,18 @@ impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n             }\n \n             layout::Abi::Aggregate { .. } => {\n-                if let Layout::Array { .. } = *self.layout {\n-                    if self.fields.count() > 0 {\n-                        return self.field(ccx, 0).homogeneous_aggregate(ccx);\n-                    }\n-                }\n-\n                 let mut total = Size::from_bytes(0);\n                 let mut result = None;\n \n                 let is_union = match *self.fields {\n-                    layout::FieldPlacement::Linear { stride, .. } => {\n-                        stride.bytes() == 0\n+                    layout::FieldPlacement::Array { count, .. } => {\n+                        if count > 0 {\n+                            return self.field(ccx, 0).homogeneous_aggregate(ccx);\n+                        } else {\n+                            return None;\n+                        }\n                     }\n+                    layout::FieldPlacement::Union(_) => true,\n                     layout::FieldPlacement::Arbitrary { .. } => false\n                 };\n "}]}