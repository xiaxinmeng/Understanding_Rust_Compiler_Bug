{"sha": "a9430a359f36e8d19505398129223a60d3f3b972", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NDMwYTM1OWYzNmU4ZDE5NTA1Mzk4MTI5MjIzYTYwZDNmM2I5NzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-18T03:35:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-18T03:35:21Z"}, "message": "Auto merge of #31641 - petrochenkov:reach, r=alexcrichton\n\nFixes https://github.com/rust-lang/rust/issues/16734 and probably some other issues\n\nThis is a continuation of https://github.com/rust-lang/rust/pull/29822, but the algorithm is mostly a copy of https://github.com/rust-lang/rust/pull/29973, so\nr? @alexcrichton or @nikomatsakis", "tree": {"sha": "548ca210a87add7ea76984e11d63cee05e4c79f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/548ca210a87add7ea76984e11d63cee05e4c79f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9430a359f36e8d19505398129223a60d3f3b972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9430a359f36e8d19505398129223a60d3f3b972", "html_url": "https://github.com/rust-lang/rust/commit/a9430a359f36e8d19505398129223a60d3f3b972", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9430a359f36e8d19505398129223a60d3f3b972/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e18f7a1c5af91f8630f3c47f73f490c49b61acde", "url": "https://api.github.com/repos/rust-lang/rust/commits/e18f7a1c5af91f8630f3c47f73f490c49b61acde", "html_url": "https://github.com/rust-lang/rust/commit/e18f7a1c5af91f8630f3c47f73f490c49b61acde"}, {"sha": "fadc95e60a7d9eb4f886169b1abbfb9e96274927", "url": "https://api.github.com/repos/rust-lang/rust/commits/fadc95e60a7d9eb4f886169b1abbfb9e96274927", "html_url": "https://github.com/rust-lang/rust/commit/fadc95e60a7d9eb4f886169b1abbfb9e96274927"}], "stats": {"total": 327, "additions": 316, "deletions": 11}, "files": [{"sha": "366089645bf69e12166e7443de649dee11ae3566", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 134, "deletions": 11, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/a9430a359f36e8d19505398129223a60d3f3b972/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9430a359f36e8d19505398129223a60d3f3b972/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a9430a359f36e8d19505398129223a60d3f3b972", "patch": "@@ -169,6 +169,10 @@ struct EmbargoVisitor<'a, 'tcx: 'a> {\n     changed: bool,\n }\n \n+struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n+    ev: &'b mut EmbargoVisitor<'a, 'tcx>,\n+}\n+\n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn ty_level(&self, ty: &hir::Ty) -> Option<AccessLevel> {\n         if let hir::TyPath(..) = ty.node {\n@@ -214,6 +218,10 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n             old_level\n         }\n     }\n+\n+    fn reach<'b>(&'b mut self) -> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+        ReachEverythingInTheInterfaceVisitor { ev: self }\n+    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n@@ -245,10 +253,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             }\n         };\n \n-        // Update id of the item itself\n+        // Update level of the item itself\n         let item_level = self.update(item.id, inherited_item_level);\n \n-        // Update ids of nested things\n+        // Update levels of nested things\n         match item.node {\n             hir::ItemEnum(ref def, _) => {\n                 for variant in &def.variants {\n@@ -292,19 +300,72 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemTy(ref ty, _) if item_level.is_some() => {\n-                if let hir::TyPath(..) = ty.node {\n-                    match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n-                        Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {},\n-                        def => {\n-                            if let Some(node_id) = self.tcx.map.as_local_node_id(def.def_id()) {\n-                                self.update(node_id, Some(AccessLevel::Reachable));\n-                            }\n+            _ => {}\n+        }\n+\n+        // Mark all items in interfaces of reachable items as reachable\n+        match item.node {\n+            // The interface is empty\n+            hir::ItemExternCrate(..) => {}\n+            // All nested items are checked by visit_item\n+            hir::ItemMod(..) => {}\n+            // Reexports are handled in visit_mod\n+            hir::ItemUse(..) => {}\n+            // Visit everything\n+            hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n+            hir::ItemTrait(..) | hir::ItemTy(..) | hir::ItemImpl(_, _, _, Some(..), _, _) => {\n+                if item_level.is_some() {\n+                    self.reach().visit_item(item);\n+                }\n+            }\n+            // Visit everything, but enum variants have their own levels\n+            hir::ItemEnum(ref def, ref generics) => {\n+                if item_level.is_some() {\n+                    self.reach().visit_generics(generics);\n+                }\n+                for variant in &def.variants {\n+                    if self.get(variant.node.data.id()).is_some() {\n+                        for field in variant.node.data.fields() {\n+                            self.reach().visit_struct_field(field);\n+                        }\n+                        // Corner case: if the variant is reachable, but its\n+                        // enum is not, make the enum reachable as well.\n+                        self.update(item.id, Some(AccessLevel::Reachable));\n+                    }\n+                }\n+            }\n+            // Visit everything, but foreign items have their own levels\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    if self.get(foreign_item.id).is_some() {\n+                        self.reach().visit_foreign_item(foreign_item);\n+                    }\n+                }\n+            }\n+            // Visit everything except for private fields\n+            hir::ItemStruct(ref struct_def, ref generics) => {\n+                if item_level.is_some() {\n+                    self.reach().visit_generics(generics);\n+                    for field in struct_def.fields() {\n+                        if self.get(field.node.id).is_some() {\n+                            self.reach().visit_struct_field(field);\n+                        }\n+                    }\n+                }\n+            }\n+            // The interface is empty\n+            hir::ItemDefaultImpl(..) => {}\n+            // Visit everything except for private impl items\n+            hir::ItemImpl(_, _, ref generics, None, _, ref impl_items) => {\n+                if item_level.is_some() {\n+                    self.reach().visit_generics(generics);\n+                    for impl_item in impl_items {\n+                        if self.get(impl_item.id).is_some() {\n+                            self.reach().visit_impl_item(impl_item);\n                         }\n                     }\n                 }\n             }\n-            _ => {}\n         }\n \n         let orig_level = self.prev_level;\n@@ -347,6 +408,68 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n     }\n }\n \n+impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    // Make the type hidden under a type alias reachable\n+    fn reach_aliased_type(&mut self, item: &hir::Item, path: &hir::Path) {\n+        if let hir::ItemTy(ref ty, ref generics) = item.node {\n+            // See `fn is_public_type_alias` for details\n+            self.visit_ty(ty);\n+            let provided_params = path.segments.last().unwrap().parameters.types().len();\n+            for ty_param in &generics.ty_params[provided_params..] {\n+                if let Some(ref default_ty) = ty_param.default {\n+                    self.visit_ty(default_ty);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n+        if let hir::TyPath(_, ref path) = ty.node {\n+            let def = self.ev.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n+            match def {\n+                Def::Struct(def_id) | Def::Enum(def_id) | Def::TyAlias(def_id) |\n+                Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n+                    if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+                        let item = self.ev.tcx.map.expect_item(node_id);\n+                        if let Def::TyAlias(..) = def {\n+                            // Type aliases are substituted. Associated type aliases are not\n+                            // substituted yet, but ideally they should be.\n+                            if self.ev.get(item.id).is_none() {\n+                                self.reach_aliased_type(item, path);\n+                            }\n+                        } else {\n+                            self.ev.update(item.id, Some(AccessLevel::Reachable));\n+                        }\n+                    }\n+                }\n+\n+                _ => {}\n+            }\n+        }\n+\n+        intravisit::walk_ty(self, ty);\n+    }\n+\n+    fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n+        let def_id = self.ev.tcx.trait_ref_to_def_id(trait_ref);\n+        if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+            let item = self.ev.tcx.map.expect_item(node_id);\n+            self.ev.update(item.id, Some(AccessLevel::Reachable));\n+        }\n+\n+        intravisit::walk_trait_ref(self, trait_ref);\n+    }\n+\n+    // Don't recurse into function bodies\n+    fn visit_block(&mut self, _: &hir::Block) {}\n+    // Don't recurse into expressions in array sizes or const initializers\n+    fn visit_expr(&mut self, _: &hir::Expr) {}\n+    // Don't recurse into patterns in function arguments\n+    fn visit_pat(&mut self, _: &hir::Pat) {}\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n /// The privacy visitor, where privacy checks take place (violations reported)\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "7ec2bb9394cc3724c2eb17e3b1420dc8a52d8fb6", "filename": "src/test/auxiliary/reachable-unnameable-items.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a9430a359f36e8d19505398129223a60d3f3b972/src%2Ftest%2Fauxiliary%2Freachable-unnameable-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9430a359f36e8d19505398129223a60d3f3b972/src%2Ftest%2Fauxiliary%2Freachable-unnameable-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freachable-unnameable-items.rs?ref=a9430a359f36e8d19505398129223a60d3f3b972", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use inner_private_module::*;\n+\n+mod inner_private_module {\n+    pub struct Unnameable1;\n+    pub struct Unnameable2;\n+    #[derive(Clone, Copy)]\n+    pub struct Unnameable3;\n+    pub struct Unnameable4;\n+    pub struct Unnameable5;\n+    pub struct Unnameable6;\n+    pub struct Unnameable7;\n+    #[derive(Default)]\n+    pub struct Unnameable8;\n+    pub enum UnnameableEnum {\n+        NameableVariant\n+    }\n+    pub trait UnnameableTrait {\n+        type Alias: Default;\n+    }\n+\n+    impl Unnameable1 {\n+        pub fn method_of_unnameable_type1(&self) -> &'static str {\n+            \"Hello1\"\n+        }\n+    }\n+    impl Unnameable2 {\n+        pub fn method_of_unnameable_type2(&self) -> &'static str {\n+            \"Hello2\"\n+        }\n+    }\n+    impl Unnameable3 {\n+        pub fn method_of_unnameable_type3(&self) -> &'static str {\n+            \"Hello3\"\n+        }\n+    }\n+    impl Unnameable4 {\n+        pub fn method_of_unnameable_type4(&self) -> &'static str {\n+            \"Hello4\"\n+        }\n+    }\n+    impl Unnameable5 {\n+        pub fn method_of_unnameable_type5(&self) -> &'static str {\n+            \"Hello5\"\n+        }\n+    }\n+    impl Unnameable6 {\n+        pub fn method_of_unnameable_type6(&self) -> &'static str {\n+            \"Hello6\"\n+        }\n+    }\n+    impl Unnameable7 {\n+        pub fn method_of_unnameable_type7(&self) -> &'static str {\n+            \"Hello7\"\n+        }\n+    }\n+    impl Unnameable8 {\n+        pub fn method_of_unnameable_type8(&self) -> &'static str {\n+            \"Hello8\"\n+        }\n+    }\n+    impl UnnameableEnum {\n+        pub fn method_of_unnameable_enum(&self) -> &'static str {\n+            \"HelloEnum\"\n+        }\n+    }\n+}\n+\n+pub fn function_returning_unnameable_type() -> Unnameable1 {\n+    Unnameable1\n+}\n+\n+pub const CONSTANT_OF_UNNAMEABLE_TYPE: Unnameable2 =\n+                                            Unnameable2;\n+\n+pub fn function_accepting_unnameable_type(_: Option<Unnameable3>) {}\n+\n+pub type AliasOfUnnameableType = Unnameable4;\n+\n+impl Unnameable1 {\n+    pub fn inherent_method_returning_unnameable_type(&self) -> Unnameable5 {\n+        Unnameable5\n+    }\n+}\n+\n+pub trait Tr {\n+    fn trait_method_returning_unnameable_type(&self) -> Unnameable6 {\n+        Unnameable6\n+    }\n+}\n+impl Tr for Unnameable1 {}\n+\n+pub use inner_private_module::UnnameableEnum::NameableVariant;\n+\n+pub struct Struct {\n+    pub field_of_unnameable_type: Unnameable7\n+}\n+\n+pub static STATIC: Struct = Struct { field_of_unnameable_type: Unnameable7 } ;\n+\n+impl UnnameableTrait for AliasOfUnnameableType {\n+    type Alias = Unnameable8;\n+}\n+\n+pub fn generic_function<T: UnnameableTrait>() -> T::Alias {\n+    Default::default()\n+}"}, {"sha": "88d3f160c81ea38d65d55bdbdfb42f1cecf977f8", "filename": "src/test/run-pass/reachable-unnameable-items.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a9430a359f36e8d19505398129223a60d3f3b972/src%2Ftest%2Frun-pass%2Freachable-unnameable-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9430a359f36e8d19505398129223a60d3f3b972/src%2Ftest%2Frun-pass%2Freachable-unnameable-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freachable-unnameable-items.rs?ref=a9430a359f36e8d19505398129223a60d3f3b972", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:reachable-unnameable-items.rs\n+\n+#![feature(braced_empty_structs)]\n+#![feature(recover)]\n+\n+extern crate reachable_unnameable_items;\n+use reachable_unnameable_items::*;\n+\n+fn main() {\n+    let res1 = function_returning_unnameable_type().method_of_unnameable_type1();\n+    let res2 = CONSTANT_OF_UNNAMEABLE_TYPE.method_of_unnameable_type2();\n+    let res4 = AliasOfUnnameableType{}.method_of_unnameable_type4();\n+    let res5 = function_returning_unnameable_type().inherent_method_returning_unnameable_type().\n+                                                    method_of_unnameable_type5();\n+    let res6 = function_returning_unnameable_type().trait_method_returning_unnameable_type().\n+                                                    method_of_unnameable_type6();\n+    let res7 = STATIC.field_of_unnameable_type.method_of_unnameable_type7();\n+    let res8 = generic_function::<AliasOfUnnameableType>().method_of_unnameable_type8();\n+    let res_enum = NameableVariant.method_of_unnameable_enum();\n+    assert_eq!(res1, \"Hello1\");\n+    assert_eq!(res2, \"Hello2\");\n+    assert_eq!(res4, \"Hello4\");\n+    assert_eq!(res5, \"Hello5\");\n+    assert_eq!(res6, \"Hello6\");\n+    assert_eq!(res7, \"Hello7\");\n+    assert_eq!(res8, \"Hello8\");\n+    assert_eq!(res_enum, \"HelloEnum\");\n+\n+    let none = None;\n+    function_accepting_unnameable_type(none);\n+    let _guard = std::panic::recover(|| none.unwrap().method_of_unnameable_type3());\n+}"}, {"sha": "5d0c6df3d582f3dce77a493c835152a2f8044762", "filename": "src/test/run-pass/reachable-unnameable-type-alias.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9430a359f36e8d19505398129223a60d3f3b972/src%2Ftest%2Frun-pass%2Freachable-unnameable-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9430a359f36e8d19505398129223a60d3f3b972/src%2Ftest%2Frun-pass%2Freachable-unnameable-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freachable-unnameable-type-alias.rs?ref=a9430a359f36e8d19505398129223a60d3f3b972", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(staged_api)]\n+#![stable(feature = \"a\", since = \"b\")]\n+\n+mod inner_private_module {\n+    // UnnameableTypeAlias isn't marked as reachable, so no stability annotation is required here\n+    pub type UnnameableTypeAlias = u8;\n+}\n+\n+#[stable(feature = \"a\", since = \"b\")]\n+pub fn f() -> inner_private_module::UnnameableTypeAlias {\n+    0\n+}\n+\n+fn main() {}"}]}