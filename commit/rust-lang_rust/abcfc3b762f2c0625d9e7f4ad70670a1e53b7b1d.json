{"sha": "abcfc3b762f2c0625d9e7f4ad70670a1e53b7b1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiY2ZjM2I3NjJmMmMwNjI1ZDllN2Y0YWQ3MDY3MGExZTUzYjdiMWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-09T23:02:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-09T23:02:15Z"}, "message": "Auto merge of #58065 - alexreg:refactor-smart_resolve_path_fragment, r=petrochenkov\n\nFactor out error reporting from `smart_resolve_path_fragment` fn\n\nThis function was ridiculously monolithic before. We now have three rather-less-monolithic-and-horrifying functions.\n\nr? @centril", "tree": {"sha": "943ed4c18a78cc76384f27eb514daf748dfdd0dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/943ed4c18a78cc76384f27eb514daf748dfdd0dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abcfc3b762f2c0625d9e7f4ad70670a1e53b7b1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abcfc3b762f2c0625d9e7f4ad70670a1e53b7b1d", "html_url": "https://github.com/rust-lang/rust/commit/abcfc3b762f2c0625d9e7f4ad70670a1e53b7b1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abcfc3b762f2c0625d9e7f4ad70670a1e53b7b1d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3315728c060b73ccf986c63677c1fcd7d92e15c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3315728c060b73ccf986c63677c1fcd7d92e15c5", "html_url": "https://github.com/rust-lang/rust/commit/3315728c060b73ccf986c63677c1fcd7d92e15c5"}, {"sha": "fd70e8e8db6f0a43f9f5bc669e03ab9bbdce7fbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd70e8e8db6f0a43f9f5bc669e03ab9bbdce7fbc", "html_url": "https://github.com/rust-lang/rust/commit/fd70e8e8db6f0a43f9f5bc669e03ab9bbdce7fbc"}], "stats": {"total": 812, "additions": 423, "deletions": 389}, "files": [{"sha": "8300e691bbea4bce6fb53fb0e0871b67ff5bcc34", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 418, "deletions": 11, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/abcfc3b762f2c0625d9e7f4ad70670a1e53b7b1d/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abcfc3b762f2c0625d9e7f4ad70670a1e53b7b1d/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=abcfc3b762f2c0625d9e7f4ad70670a1e53b7b1d", "patch": "@@ -1,16 +1,423 @@\n-use crate::{CrateLint, PathResult, Segment};\n-use crate::macros::ParentScope;\n-use crate::resolve_imports::ImportResolver;\n+use std::cmp::Reverse;\n \n+use log::debug;\n+use rustc::hir::def::*;\n+use rustc::hir::def::Namespace::*;\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::session::config::nightly_options;\n+use syntax::ast::{ExprKind};\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n-use log::debug;\n+use crate::errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use crate::macros::ParentScope;\n+use crate::resolve_imports::ImportResolver;\n+use crate::{import_candidate_to_enum_paths, is_self_type, is_self_value, path_names_to_string};\n+use crate::{AssocSuggestion, CrateLint, ImportSuggestion, ModuleOrUniformRoot, PathResult,\n+            PathSource, Resolver, Segment};\n \n-use std::cmp::Reverse;\n+impl<'a> Resolver<'a> {\n+    /// Handles error reporting for `smart_resolve_path_fragment` function.\n+    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n+    pub(crate) fn smart_resolve_report_errors(\n+        &mut self,\n+        path: &[Segment],\n+        span: Span,\n+        source: PathSource<'_>,\n+        def: Option<Def>,\n+    ) -> (DiagnosticBuilder<'a>, Vec<ImportSuggestion>) {\n+        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n+        let ns = source.namespace();\n+        let is_expected = &|def| source.is_expected(def);\n+        let is_enum_variant = &|def| if let Def::Variant(..) = def { true } else { false };\n+\n+        // Make the base error.\n+        let expected = source.descr_expected();\n+        let path_str = Segment::names_to_string(path);\n+        let item_str = path.last().unwrap().ident;\n+        let code = source.error_code(def.is_some());\n+        let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n+            (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n+                format!(\"not a {}\", expected),\n+                span)\n+        } else {\n+            let item_span = path.last().unwrap().ident.span;\n+            let (mod_prefix, mod_str) = if path.len() == 1 {\n+                (String::new(), \"this scope\".to_string())\n+            } else if path.len() == 2 && path[0].ident.name == keywords::PathRoot.name() {\n+                (String::new(), \"the crate root\".to_string())\n+            } else {\n+                let mod_path = &path[..path.len() - 1];\n+                let mod_prefix = match self.resolve_path_without_parent_scope(\n+                    mod_path, Some(TypeNS), false, span, CrateLint::No\n+                ) {\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                        module.def(),\n+                    _ => None,\n+                }.map_or(String::new(), |def| format!(\"{} \", def.kind_name()));\n+                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n+            };\n+            (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n+                format!(\"not found in {}\", mod_str),\n+                item_span)\n+        };\n+\n+        let code = DiagnosticId::Error(code.into());\n+        let mut err = self.session.struct_span_err_with_code(base_span, &base_msg, code);\n+\n+        // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n+        if [\"this\", \"my\"].contains(&&*item_str.as_str())\n+            && self.self_value_is_available(path[0].ident.span, span) {\n+            err.span_suggestion(\n+                span,\n+                \"did you mean\",\n+                \"self\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+\n+        // Emit special messages for unresolved `Self` and `self`.\n+        if is_self_type(path, ns) {\n+            __diagnostic_used!(E0411);\n+            err.code(DiagnosticId::Error(\"E0411\".into()));\n+            err.span_label(span, format!(\"`Self` is only available in impls, traits, \\\n+                                          and type definitions\"));\n+            return (err, Vec::new());\n+        }\n+        if is_self_value(path, ns) {\n+            debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n+\n+            __diagnostic_used!(E0424);\n+            err.code(DiagnosticId::Error(\"E0424\".into()));\n+            err.span_label(span, match source {\n+                PathSource::Pat => {\n+                    format!(\"`self` value is a keyword \\\n+                             and may not be bound to \\\n+                             variables or shadowed\")\n+                }\n+                _ => {\n+                    format!(\"`self` value is a keyword \\\n+                             only available in methods \\\n+                             with `self` parameter\")\n+                }\n+            });\n+            return (err, Vec::new());\n+        }\n+\n+        // Try to lookup name in more relaxed fashion for better error reporting.\n+        let ident = path.last().unwrap().ident;\n+        let candidates = self.lookup_import_candidates(ident, ns, is_expected);\n+        if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n+            let enum_candidates =\n+                self.lookup_import_candidates(ident, ns, is_enum_variant);\n+            let mut enum_candidates = enum_candidates.iter()\n+                .map(|suggestion| {\n+                    import_candidate_to_enum_paths(&suggestion)\n+                }).collect::<Vec<_>>();\n+            enum_candidates.sort();\n+\n+            if !enum_candidates.is_empty() {\n+                // Contextualize for E0412 \"cannot find type\", but don't belabor the point\n+                // (that it's a variant) for E0573 \"expected type, found variant\".\n+                let preamble = if def.is_none() {\n+                    let others = match enum_candidates.len() {\n+                        1 => String::new(),\n+                        2 => \" and 1 other\".to_owned(),\n+                        n => format!(\" and {} others\", n)\n+                    };\n+                    format!(\"there is an enum variant `{}`{}; \",\n+                            enum_candidates[0].0, others)\n+                } else {\n+                    String::new()\n+                };\n+                let msg = format!(\"{}try using the variant's enum\", preamble);\n+\n+                err.span_suggestions(\n+                    span,\n+                    &msg,\n+                    enum_candidates.into_iter()\n+                        .map(|(_variant_path, enum_ty_path)| enum_ty_path)\n+                        // Variants re-exported in prelude doesn't mean `prelude::v1` is the\n+                        // type name!\n+                        // FIXME: is there a more principled way to do this that\n+                        // would work for other re-exports?\n+                        .filter(|enum_ty_path| enum_ty_path != \"std::prelude::v1\")\n+                        // Also write `Option` rather than `std::prelude::v1::Option`.\n+                        .map(|enum_ty_path| {\n+                            // FIXME #56861: DRY-er prelude filtering.\n+                            enum_ty_path.trim_start_matches(\"std::prelude::v1::\").to_owned()\n+                        }),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        if path.len() == 1 && self.self_type_is_available(span) {\n+            if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n+                let self_is_available = self.self_value_is_available(path[0].ident.span, span);\n+                match candidate {\n+                    AssocSuggestion::Field => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"try\",\n+                            format!(\"self.{}\", path_str),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        if !self_is_available {\n+                            err.span_label(span, format!(\"`self` value is a keyword \\\n+                                                         only available in \\\n+                                                         methods with `self` parameter\"));\n+                        }\n+                    }\n+                    AssocSuggestion::MethodWithSelf if self_is_available => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"try\",\n+                            format!(\"self.{}\", path_str),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                    AssocSuggestion::MethodWithSelf | AssocSuggestion::AssocItem => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"try\",\n+                            format!(\"Self::{}\", path_str),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+                return (err, candidates);\n+            }\n+        }\n+\n+        let mut levenshtein_worked = false;\n+\n+        // Try Levenshtein algorithm.\n+        let suggestion = self.lookup_typo_candidate(path, ns, is_expected, span);\n+        if let Some(suggestion) = suggestion {\n+            let msg = format!(\n+                \"{} {} with a similar name exists\",\n+                suggestion.article, suggestion.kind\n+            );\n+            err.span_suggestion(\n+                ident_span,\n+                &msg,\n+                suggestion.candidate.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+\n+            levenshtein_worked = true;\n+        }\n+\n+        // Try context-dependent help if relaxed lookup didn't work.\n+        if let Some(def) = def {\n+            if self.smart_resolve_context_dependent_help(&mut err,\n+                                                         span,\n+                                                         source,\n+                                                         def,\n+                                                         &path_str,\n+                                                         &fallback_label) {\n+                return (err, candidates);\n+            }\n+        }\n+\n+        // Fallback label.\n+        if !levenshtein_worked {\n+            err.span_label(base_span, fallback_label);\n+            self.type_ascription_suggestion(&mut err, base_span);\n+        }\n+        (err, candidates)\n+    }\n+\n+    /// Provides context-dependent help for errors reported by the `smart_resolve_path_fragment`\n+    /// function.\n+    /// Returns `true` if able to provide context-dependent help.\n+    fn smart_resolve_context_dependent_help(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        span: Span,\n+        source: PathSource<'_>,\n+        def: Def,\n+        path_str: &str,\n+        fallback_label: &str,\n+    ) -> bool {\n+        let ns = source.namespace();\n+        let is_expected = &|def| source.is_expected(def);\n+\n+        match (def, source) {\n+            (Def::Macro(..), _) => {\n+                err.span_suggestion(\n+                    span,\n+                    \"use `!` to invoke the macro\",\n+                    format!(\"{}!\", path_str),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            (Def::TyAlias(..), PathSource::Trait(_)) => {\n+                err.span_label(span, \"type aliases cannot be used as traits\");\n+                if nightly_options::is_nightly_build() {\n+                    err.note(\"did you mean to use a trait alias?\");\n+                }\n+            }\n+            (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n+                ExprKind::Field(_, ident) => {\n+                    err.span_suggestion(\n+                        parent.span,\n+                        \"use the path separator to refer to an item\",\n+                        format!(\"{}::{}\", path_str, ident),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ExprKind::MethodCall(ref segment, ..) => {\n+                    let span = parent.span.with_hi(segment.ident.span.hi());\n+                    err.span_suggestion(\n+                        span,\n+                        \"use the path separator to refer to an item\",\n+                        format!(\"{}::{}\", path_str, segment.ident),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                _ => return false,\n+            },\n+            (Def::Enum(..), PathSource::TupleStruct)\n+                | (Def::Enum(..), PathSource::Expr(..))  => {\n+                if let Some(variants) = self.collect_enum_variants(def) {\n+                    err.note(&format!(\"did you mean to use one \\\n+                                       of the following variants?\\n{}\",\n+                        variants.iter()\n+                            .map(|suggestion| path_names_to_string(suggestion))\n+                            .map(|suggestion| format!(\"- `{}`\", suggestion))\n+                            .collect::<Vec<_>>()\n+                            .join(\"\\n\")));\n+                } else {\n+                    err.note(\"did you mean to use one of the enum's variants?\");\n+                }\n+            },\n+            (Def::Struct(def_id), _) if ns == ValueNS => {\n+                if let Some((ctor_def, ctor_vis))\n+                        = self.struct_constructors.get(&def_id).cloned() {\n+                    let accessible_ctor = self.is_accessible(ctor_vis);\n+                    if is_expected(ctor_def) && !accessible_ctor {\n+                        err.span_label(span, format!(\"constructor is not visible \\\n+                                                      here due to private fields\"));\n+                    }\n+                } else {\n+                    // HACK(estebank): find a better way to figure out that this was a\n+                    // parser issue where a struct literal is being used on an expression\n+                    // where a brace being opened means a block is being started. Look\n+                    // ahead for the next text to see if `span` is followed by a `{`.\n+                    let sm = self.session.source_map();\n+                    let mut sp = span;\n+                    loop {\n+                        sp = sm.next_point(sp);\n+                        match sm.span_to_snippet(sp) {\n+                            Ok(ref snippet) => {\n+                                if snippet.chars().any(|c| { !c.is_whitespace() }) {\n+                                    break;\n+                                }\n+                            }\n+                            _ => break,\n+                        }\n+                    }\n+                    let followed_by_brace = match sm.span_to_snippet(sp) {\n+                        Ok(ref snippet) if snippet == \"{\" => true,\n+                        _ => false,\n+                    };\n+                    // In case this could be a struct literal that needs to be surrounded\n+                    // by parenthesis, find the appropriate span.\n+                    let mut i = 0;\n+                    let mut closing_brace = None;\n+                    loop {\n+                        sp = sm.next_point(sp);\n+                        match sm.span_to_snippet(sp) {\n+                            Ok(ref snippet) => {\n+                                if snippet == \"}\" {\n+                                    let sp = span.to(sp);\n+                                    if let Ok(snippet) = sm.span_to_snippet(sp) {\n+                                        closing_brace = Some((sp, snippet));\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                            _ => break,\n+                        }\n+                        i += 1;\n+                        // The bigger the span, the more likely we're incorrect --\n+                        // bound it to 100 chars long.\n+                        if i > 100 {\n+                            break;\n+                        }\n+                    }\n+                    match source {\n+                        PathSource::Expr(Some(parent)) => {\n+                            match parent.node {\n+                                ExprKind::MethodCall(ref path_assignment, _)  => {\n+                                    err.span_suggestion(\n+                                        sm.start_point(parent.span)\n+                                            .to(path_assignment.ident.span),\n+                                        \"use `::` to access an associated function\",\n+                                        format!(\"{}::{}\",\n+                                                path_str,\n+                                                path_assignment.ident),\n+                                        Applicability::MaybeIncorrect\n+                                    );\n+                                },\n+                                _ => {\n+                                    err.span_label(\n+                                        span,\n+                                        format!(\"did you mean `{} {{ /* fields */ }}`?\",\n+                                                path_str),\n+                                    );\n+                                },\n+                            }\n+                        },\n+                        PathSource::Expr(None) if followed_by_brace == true => {\n+                            if let Some((sp, snippet)) = closing_brace {\n+                                err.span_suggestion(\n+                                    sp,\n+                                    \"surround the struct literal with parenthesis\",\n+                                    format!(\"({})\", snippet),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            } else {\n+                                err.span_label(\n+                                    span,\n+                                    format!(\"did you mean `({} {{ /* fields */ }})`?\",\n+                                            path_str),\n+                                );\n+                            }\n+                        },\n+                        _ => {\n+                            err.span_label(\n+                                span,\n+                                format!(\"did you mean `{} {{ /* fields */ }}`?\",\n+                                        path_str),\n+                            );\n+                        },\n+                    }\n+                }\n+            }\n+            (Def::Union(..), _) |\n+            (Def::Variant(..), _) |\n+            (Def::VariantCtor(_, CtorKind::Fictive), _) if ns == ValueNS => {\n+                err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\",\n+                                             path_str));\n+            }\n+            (Def::SelfTy(..), _) if ns == ValueNS => {\n+                err.span_label(span, fallback_label);\n+                err.note(\"can't use `Self` as a constructor, you must use the \\\n+                          implemented struct\");\n+            }\n+            (Def::TyAlias(_), _) | (Def::AssociatedTy(..), _) if ns == ValueNS => {\n+                err.note(\"can't use a type alias as a constructor\");\n+            }\n+            _ => return false,\n+        }\n+        true\n+    }\n+}\n \n impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n-    /// Add suggestions for a path that cannot be resolved.\n+    /// Adds suggestions for a path that cannot be resolved.\n     pub(crate) fn make_path_suggestion(\n         &mut self,\n         span: Span,\n@@ -24,7 +431,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // On 2015 `{{root}}` is usually added implicitly.\n             (Some(fst), Some(snd)) if fst.ident.name == keywords::PathRoot.name() &&\n                                       !snd.ident.is_path_segment_keyword() => {}\n-            // `ident::...` on 2018\n+            // `ident::...` on 2018.\n             (Some(fst), _) if fst.ident.span.rust_2018() &&\n                               !fst.ident.is_path_segment_keyword() => {\n                 // Insert a placeholder that's later replaced by `self`/`super`/etc.\n@@ -63,7 +470,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    /// Suggest a missing `crate::` if that resolves to an correct module.\n+    /// Suggests a missing `crate::` if that resolves to an correct module.\n     ///\n     /// ```\n     ///    |\n@@ -94,7 +501,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    /// Suggest a missing `super::` if that resolves to an correct module.\n+    /// Suggests a missing `super::` if that resolves to an correct module.\n     ///\n     /// ```\n     ///    |\n@@ -118,7 +525,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    /// Suggest a missing external crate name if that resolves to an correct module.\n+    /// Suggests a missing external crate name if that resolves to an correct module.\n     ///\n     /// ```\n     ///    |\n@@ -139,7 +546,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n \n         // Sort extern crate names in reverse order to get\n-        // 1) some consistent ordering for emitted dignostics and\n+        // 1) some consistent ordering for emitted dignostics, and\n         // 2) `std` suggestions before `core` suggestions.\n         let mut extern_crate_names =\n             self.resolver.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();"}, {"sha": "ecbfcec3c5eb4acc4203254b834922fed61b70b3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 378, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/abcfc3b762f2c0625d9e7f4ad70670a1e53b7b1d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abcfc3b762f2c0625d9e7f4ad70670a1e53b7b1d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=abcfc3b762f2c0625d9e7f4ad70670a1e53b7b1d", "patch": "@@ -25,7 +25,6 @@ use rustc::hir::def::*;\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n-use rustc::session::config::nightly_options;\n use rustc::ty;\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::{bug, span_bug};\n@@ -1756,7 +1755,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// resolve_hir_path, but takes a callback in case there was an error\n+    /// Like `resolve_hir_path`, but takes a callback in case there was an error.\n     fn resolve_hir_path_cb<F>(\n         &mut self,\n         path: &ast::Path,\n@@ -1769,7 +1768,7 @@ impl<'a> Resolver<'a> {\n         let span = path.span;\n         let segments = &path.segments;\n         let path = Segment::from_path(&path);\n-        // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n+        // FIXME(Manishearth): intra-doc links won't get warned of epoch changes.\n         let def = match self.resolve_path_without_parent_scope(&path, Some(namespace), true,\n                                                                span, CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n@@ -3184,383 +3183,11 @@ impl<'a> Resolver<'a> {\n                                    source: PathSource<'_>,\n                                    crate_lint: CrateLint)\n                                    -> PathResolution {\n-        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n         let ns = source.namespace();\n         let is_expected = &|def| source.is_expected(def);\n-        let is_enum_variant = &|def| if let Def::Variant(..) = def { true } else { false };\n \n-        // Base error is amended with one short label and possibly some longer helps/notes.\n         let report_errors = |this: &mut Self, def: Option<Def>| {\n-            // Make the base error.\n-            let expected = source.descr_expected();\n-            let path_str = Segment::names_to_string(path);\n-            let item_str = path.last().unwrap().ident;\n-            let code = source.error_code(def.is_some());\n-            let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n-                (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n-                 format!(\"not a {}\", expected),\n-                 span)\n-            } else {\n-                let item_span = path.last().unwrap().ident.span;\n-                let (mod_prefix, mod_str) = if path.len() == 1 {\n-                    (String::new(), \"this scope\".to_string())\n-                } else if path.len() == 2 && path[0].ident.name == keywords::PathRoot.name() {\n-                    (String::new(), \"the crate root\".to_string())\n-                } else {\n-                    let mod_path = &path[..path.len() - 1];\n-                    let mod_prefix = match this.resolve_path_without_parent_scope(\n-                        mod_path, Some(TypeNS), false, span, CrateLint::No\n-                    ) {\n-                        PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                            module.def(),\n-                        _ => None,\n-                    }.map_or(String::new(), |def| format!(\"{} \", def.kind_name()));\n-                    (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n-                };\n-                (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n-                 format!(\"not found in {}\", mod_str),\n-                 item_span)\n-            };\n-\n-            let code = DiagnosticId::Error(code.into());\n-            let mut err = this.session.struct_span_err_with_code(base_span, &base_msg, code);\n-\n-            // Emit help message for fake-self from other languages like `this`(javascript)\n-            if [\"this\", \"my\"].contains(&&*item_str.as_str())\n-                && this.self_value_is_available(path[0].ident.span, span) {\n-                err.span_suggestion(\n-                    span,\n-                    \"did you mean\",\n-                    \"self\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-\n-            // Emit special messages for unresolved `Self` and `self`.\n-            if is_self_type(path, ns) {\n-                __diagnostic_used!(E0411);\n-                err.code(DiagnosticId::Error(\"E0411\".into()));\n-                err.span_label(span, format!(\"`Self` is only available in impls, traits, \\\n-                                              and type definitions\"));\n-                return (err, Vec::new());\n-            }\n-            if is_self_value(path, ns) {\n-                debug!(\"smart_resolve_path_fragment E0424 source:{:?}\", source);\n-\n-                __diagnostic_used!(E0424);\n-                err.code(DiagnosticId::Error(\"E0424\".into()));\n-                err.span_label(span, match source {\n-                    PathSource::Pat => {\n-                        format!(\"`self` value is a keyword \\\n-                                and may not be bound to \\\n-                                variables or shadowed\")\n-                    }\n-                    _ => {\n-                        format!(\"`self` value is a keyword \\\n-                                only available in methods \\\n-                                with `self` parameter\")\n-                    }\n-                });\n-                return (err, Vec::new());\n-            }\n-\n-            // Try to lookup the name in more relaxed fashion for better error reporting.\n-            let ident = path.last().unwrap().ident;\n-            let candidates = this.lookup_import_candidates(ident, ns, is_expected);\n-            if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n-                let enum_candidates =\n-                    this.lookup_import_candidates(ident, ns, is_enum_variant);\n-                let mut enum_candidates = enum_candidates.iter()\n-                    .map(|suggestion| {\n-                        import_candidate_to_enum_paths(&suggestion)\n-                    }).collect::<Vec<_>>();\n-                enum_candidates.sort();\n-\n-                if !enum_candidates.is_empty() {\n-                    // contextualize for E0412 \"cannot find type\", but don't belabor the point\n-                    // (that it's a variant) for E0573 \"expected type, found variant\"\n-                    let preamble = if def.is_none() {\n-                        let others = match enum_candidates.len() {\n-                            1 => String::new(),\n-                            2 => \" and 1 other\".to_owned(),\n-                            n => format!(\" and {} others\", n)\n-                        };\n-                        format!(\"there is an enum variant `{}`{}; \",\n-                                enum_candidates[0].0, others)\n-                    } else {\n-                        String::new()\n-                    };\n-                    let msg = format!(\"{}try using the variant's enum\", preamble);\n-\n-                    err.span_suggestions(\n-                        span,\n-                        &msg,\n-                        enum_candidates.into_iter()\n-                            .map(|(_variant_path, enum_ty_path)| enum_ty_path)\n-                            // variants re\u00ebxported in prelude doesn't mean `prelude::v1` is the\n-                            // type name! FIXME: is there a more principled way to do this that\n-                            // would work for other re\u00ebxports?\n-                            .filter(|enum_ty_path| enum_ty_path != \"std::prelude::v1\")\n-                            // also say `Option` rather than `std::prelude::v1::Option`\n-                            .map(|enum_ty_path| {\n-                                // FIXME #56861: DRYer prelude filtering\n-                                enum_ty_path.trim_start_matches(\"std::prelude::v1::\").to_owned()\n-                            }),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            if path.len() == 1 && this.self_type_is_available(span) {\n-                if let Some(candidate) = this.lookup_assoc_candidate(ident, ns, is_expected) {\n-                    let self_is_available = this.self_value_is_available(path[0].ident.span, span);\n-                    match candidate {\n-                        AssocSuggestion::Field => {\n-                            err.span_suggestion(\n-                                span,\n-                                \"try\",\n-                                format!(\"self.{}\", path_str),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            if !self_is_available {\n-                                err.span_label(span, format!(\"`self` value is a keyword \\\n-                                                               only available in \\\n-                                                               methods with `self` parameter\"));\n-                            }\n-                        }\n-                        AssocSuggestion::MethodWithSelf if self_is_available => {\n-                            err.span_suggestion(\n-                                span,\n-                                \"try\",\n-                                format!(\"self.{}\", path_str),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                        AssocSuggestion::MethodWithSelf | AssocSuggestion::AssocItem => {\n-                            err.span_suggestion(\n-                                span,\n-                                \"try\",\n-                                format!(\"Self::{}\", path_str),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    }\n-                    return (err, candidates);\n-                }\n-            }\n-\n-            let mut levenshtein_worked = false;\n-\n-            // Try Levenshtein algorithm.\n-            let suggestion = this.lookup_typo_candidate(path, ns, is_expected, span);\n-            if let Some(suggestion) = suggestion {\n-                let msg = format!(\n-                    \"{} {} with a similar name exists\",\n-                    suggestion.article, suggestion.kind\n-                );\n-                err.span_suggestion(\n-                    ident_span,\n-                    &msg,\n-                    suggestion.candidate.to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-\n-                levenshtein_worked = true;\n-            }\n-\n-            // Try context dependent help if relaxed lookup didn't work.\n-            if let Some(def) = def {\n-                match (def, source) {\n-                    (Def::Macro(..), _) => {\n-                        err.span_suggestion(\n-                            span,\n-                            \"use `!` to invoke the macro\",\n-                            format!(\"{}!\", path_str),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        return (err, candidates);\n-                    }\n-                    (Def::TyAlias(..), PathSource::Trait(_)) => {\n-                        err.span_label(span, \"type aliases cannot be used as traits\");\n-                        if nightly_options::is_nightly_build() {\n-                            err.note(\"did you mean to use a trait alias?\");\n-                        }\n-                        return (err, candidates);\n-                    }\n-                    (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n-                        ExprKind::Field(_, ident) => {\n-                            err.span_suggestion(\n-                                parent.span,\n-                                \"use the path separator to refer to an item\",\n-                                format!(\"{}::{}\", path_str, ident),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            return (err, candidates);\n-                        }\n-                        ExprKind::MethodCall(ref segment, ..) => {\n-                            let span = parent.span.with_hi(segment.ident.span.hi());\n-                            err.span_suggestion(\n-                                span,\n-                                \"use the path separator to refer to an item\",\n-                                format!(\"{}::{}\", path_str, segment.ident),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            return (err, candidates);\n-                        }\n-                        _ => {}\n-                    },\n-                    (Def::Enum(..), PathSource::TupleStruct)\n-                        | (Def::Enum(..), PathSource::Expr(..))  => {\n-                        if let Some(variants) = this.collect_enum_variants(def) {\n-                            err.note(&format!(\"did you mean to use one \\\n-                                               of the following variants?\\n{}\",\n-                                variants.iter()\n-                                    .map(|suggestion| path_names_to_string(suggestion))\n-                                    .map(|suggestion| format!(\"- `{}`\", suggestion))\n-                                    .collect::<Vec<_>>()\n-                                    .join(\"\\n\")));\n-\n-                        } else {\n-                            err.note(\"did you mean to use one of the enum's variants?\");\n-                        }\n-                        return (err, candidates);\n-                    },\n-                    (Def::Struct(def_id), _) if ns == ValueNS => {\n-                        if let Some((ctor_def, ctor_vis))\n-                                = this.struct_constructors.get(&def_id).cloned() {\n-                            let accessible_ctor = this.is_accessible(ctor_vis);\n-                            if is_expected(ctor_def) && !accessible_ctor {\n-                                err.span_label(span, format!(\"constructor is not visible \\\n-                                                              here due to private fields\"));\n-                            }\n-                        } else {\n-                            // HACK(estebank): find a better way to figure out that this was a\n-                            // parser issue where a struct literal is being used on an expression\n-                            // where a brace being opened means a block is being started. Look\n-                            // ahead for the next text to see if `span` is followed by a `{`.\n-                            let sm = this.session.source_map();\n-                            let mut sp = span;\n-                            loop {\n-                                sp = sm.next_point(sp);\n-                                match sm.span_to_snippet(sp) {\n-                                    Ok(ref snippet) => {\n-                                        if snippet.chars().any(|c| { !c.is_whitespace() }) {\n-                                            break;\n-                                        }\n-                                    }\n-                                    _ => break,\n-                                }\n-                            }\n-                            let followed_by_brace = match sm.span_to_snippet(sp) {\n-                                Ok(ref snippet) if snippet == \"{\" => true,\n-                                _ => false,\n-                            };\n-                            // In case this could be a struct literal that needs to be surrounded\n-                            // by parenthesis, find the appropriate span.\n-                            let mut i = 0;\n-                            let mut closing_brace = None;\n-                            loop {\n-                                sp = sm.next_point(sp);\n-                                match sm.span_to_snippet(sp) {\n-                                    Ok(ref snippet) => {\n-                                        if snippet == \"}\" {\n-                                            let sp = span.to(sp);\n-                                            if let Ok(snippet) = sm.span_to_snippet(sp) {\n-                                                closing_brace = Some((sp, snippet));\n-                                            }\n-                                            break;\n-                                        }\n-                                    }\n-                                    _ => break,\n-                                }\n-                                i += 1;\n-                                if i > 100 { // The bigger the span the more likely we're\n-                                    break;   // incorrect. Bound it to 100 chars long.\n-                                }\n-                            }\n-                            match source {\n-                                PathSource::Expr(Some(parent)) => {\n-                                    match parent.node {\n-                                        ExprKind::MethodCall(ref path_assignment, _)  => {\n-                                            err.span_suggestion(\n-                                                sm.start_point(parent.span)\n-                                                  .to(path_assignment.ident.span),\n-                                                \"use `::` to access an associated function\",\n-                                                format!(\"{}::{}\",\n-                                                        path_str,\n-                                                        path_assignment.ident),\n-                                                Applicability::MaybeIncorrect\n-                                            );\n-                                            return (err, candidates);\n-                                        },\n-                                        _ => {\n-                                            err.span_label(\n-                                                span,\n-                                                format!(\"did you mean `{} {{ /* fields */ }}`?\",\n-                                                        path_str),\n-                                            );\n-                                            return (err, candidates);\n-                                        },\n-                                    }\n-                                },\n-                                PathSource::Expr(None) if followed_by_brace == true => {\n-                                    if let Some((sp, snippet)) = closing_brace {\n-                                        err.span_suggestion(\n-                                            sp,\n-                                            \"surround the struct literal with parenthesis\",\n-                                            format!(\"({})\", snippet),\n-                                            Applicability::MaybeIncorrect,\n-                                        );\n-                                    } else {\n-                                        err.span_label(\n-                                            span,\n-                                            format!(\"did you mean `({} {{ /* fields */ }})`?\",\n-                                                    path_str),\n-                                        );\n-                                    }\n-                                    return (err, candidates);\n-                                },\n-                                _ => {\n-                                    err.span_label(\n-                                        span,\n-                                        format!(\"did you mean `{} {{ /* fields */ }}`?\",\n-                                                path_str),\n-                                    );\n-                                    return (err, candidates);\n-                                },\n-                            }\n-                        }\n-                        return (err, candidates);\n-                    }\n-                    (Def::Union(..), _) |\n-                    (Def::Variant(..), _) |\n-                    (Def::VariantCtor(_, CtorKind::Fictive), _) if ns == ValueNS => {\n-                        err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\",\n-                                                     path_str));\n-                        return (err, candidates);\n-                    }\n-                    (Def::SelfTy(..), _) if ns == ValueNS => {\n-                        err.span_label(span, fallback_label);\n-                        err.note(\"can't use `Self` as a constructor, you must use the \\\n-                                  implemented struct\");\n-                        return (err, candidates);\n-                    }\n-                    (Def::TyAlias(_), _) | (Def::AssociatedTy(..), _) if ns == ValueNS => {\n-                        err.note(\"can't use a type alias as a constructor\");\n-                        return (err, candidates);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            // Fallback label.\n-            if !levenshtein_worked {\n-                err.span_label(base_span, fallback_label);\n-                this.type_ascription_suggestion(&mut err, base_span);\n-            }\n-            (err, candidates)\n-        };\n-        let report_errors = |this: &mut Self, def: Option<Def>| {\n-            let (err, candidates) = report_errors(this, def);\n+            let (err, candidates) = this.smart_resolve_report_errors(path, span, source, def);\n             let def_id = this.current_module.normal_ancestor_id;\n             let node_id = this.definitions.as_local_node_id(def_id).unwrap();\n             let better = def.is_some();\n@@ -3631,7 +3258,8 @@ impl<'a> Resolver<'a> {\n         debug!(\"self.current_type_ascription {:?}\", self.current_type_ascription);\n         if let Some(sp) = self.current_type_ascription.last() {\n             let mut sp = *sp;\n-            loop {  // try to find the `:`, bail on first non-':'/non-whitespace\n+            loop {\n+                // Try to find the `:`; bail on first non-':' / non-whitespace.\n                 sp = cm.next_point(sp);\n                 if let Ok(snippet) = cm.span_to_snippet(sp.to(cm.next_point(sp))) {\n                     debug!(\"snippet {:?}\", snippet);\n@@ -5520,7 +5148,6 @@ fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, Str\n     (variant_path_string, enum_path_string)\n }\n \n-\n /// When an entity with a given name is not available in scope, we search for\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way"}]}