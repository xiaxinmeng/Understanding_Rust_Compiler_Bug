{"sha": "fe639057086fa7bef1e964bf3a211517b04bc328", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNjM5MDU3MDg2ZmE3YmVmMWU5NjRiZjNhMjExNTE3YjA0YmMzMjg=", "commit": {"author": {"name": "Ashley Mannix", "email": "ashleymannix@live.com.au", "date": "2020-07-18T00:09:47Z"}, "committer": {"name": "Ashley Mannix", "email": "ashleymannix@live.com.au", "date": "2020-07-18T00:12:02Z"}, "message": "link once_cell feature to #74465", "tree": {"sha": "d9bc7611cd9c20903b258588d755b2057a2a8a5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9bc7611cd9c20903b258588d755b2057a2a8a5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe639057086fa7bef1e964bf3a211517b04bc328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe639057086fa7bef1e964bf3a211517b04bc328", "html_url": "https://github.com/rust-lang/rust/commit/fe639057086fa7bef1e964bf3a211517b04bc328", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe639057086fa7bef1e964bf3a211517b04bc328/comments", "author": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48844fed2bdc7c40d213131d5e13ab28e47df083", "url": "https://api.github.com/repos/rust-lang/rust/commits/48844fed2bdc7c40d213131d5e13ab28e47df083", "html_url": "https://github.com/rust-lang/rust/commit/48844fed2bdc7c40d213131d5e13ab28e47df083"}], "stats": {"total": 102, "additions": 51, "deletions": 51}, "files": [{"sha": "5cf7217ef11e81724f0c34482f1f9b18a780a063", "filename": "src/libcore/lazy.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fe639057086fa7bef1e964bf3a211517b04bc328/src%2Flibcore%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe639057086fa7bef1e964bf3a211517b04bc328/src%2Flibcore%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flazy.rs?ref=fe639057086fa7bef1e964bf3a211517b04bc328", "patch": "@@ -26,20 +26,20 @@ use crate::ops::Deref;\n /// assert_eq!(value, \"Hello, World!\");\n /// assert!(cell.get().is_some());\n /// ```\n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n pub struct OnceCell<T> {\n     // Invariant: written to at most once.\n     inner: UnsafeCell<Option<T>>,\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T> Default for OnceCell<T> {\n     fn default() -> Self {\n         Self::new()\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.get() {\n@@ -49,7 +49,7 @@ impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: Clone> Clone for OnceCell<T> {\n     fn clone(&self) -> OnceCell<T> {\n         let res = OnceCell::new();\n@@ -63,17 +63,17 @@ impl<T: Clone> Clone for OnceCell<T> {\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: PartialEq> PartialEq for OnceCell<T> {\n     fn eq(&self, other: &Self) -> bool {\n         self.get() == other.get()\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: Eq> Eq for OnceCell<T> {}\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T> From<T> for OnceCell<T> {\n     fn from(value: T) -> Self {\n         OnceCell { inner: UnsafeCell::new(Some(value)) }\n@@ -82,15 +82,15 @@ impl<T> From<T> for OnceCell<T> {\n \n impl<T> OnceCell<T> {\n     /// Creates a new empty cell.\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub const fn new() -> OnceCell<T> {\n         OnceCell { inner: UnsafeCell::new(None) }\n     }\n \n     /// Gets the reference to the underlying value.\n     ///\n     /// Returns `None` if the cell is empty.\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get(&self) -> Option<&T> {\n         // Safety: Safe due to `inner`'s invariant\n         unsafe { &*self.inner.get() }.as_ref()\n@@ -99,7 +99,7 @@ impl<T> OnceCell<T> {\n     /// Gets the mutable reference to the underlying value.\n     ///\n     /// Returns `None` if the cell is empty.\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get_mut(&mut self) -> Option<&mut T> {\n         // Safety: Safe because we have unique access\n         unsafe { &mut *self.inner.get() }.as_mut()\n@@ -127,7 +127,7 @@ impl<T> OnceCell<T> {\n     ///\n     /// assert!(cell.get().is_some());\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn set(&self, value: T) -> Result<(), T> {\n         // Safety: Safe because we cannot have overlapping mutable borrows\n         let slot = unsafe { &*self.inner.get() };\n@@ -168,7 +168,7 @@ impl<T> OnceCell<T> {\n     /// let value = cell.get_or_init(|| unreachable!());\n     /// assert_eq!(value, &92);\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get_or_init<F>(&self, f: F) -> &T\n     where\n         F: FnOnce() -> T,\n@@ -206,7 +206,7 @@ impl<T> OnceCell<T> {\n     /// assert_eq!(value, Ok(&92));\n     /// assert_eq!(cell.get(), Some(&92))\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n     where\n         F: FnOnce() -> Result<T, E>,\n@@ -241,7 +241,7 @@ impl<T> OnceCell<T> {\n     /// cell.set(\"hello\".to_string()).unwrap();\n     /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn into_inner(self) -> Option<T> {\n         // Because `into_inner` takes `self` by value, the compiler statically verifies\n         // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n@@ -269,7 +269,7 @@ impl<T> OnceCell<T> {\n     /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n     /// assert_eq!(cell.get(), None);\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn take(&mut self) -> Option<T> {\n         mem::take(self).into_inner()\n     }\n@@ -298,13 +298,13 @@ impl<T> OnceCell<T> {\n /// //   92\n /// //   92\n /// ```\n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n pub struct Lazy<T, F = fn() -> T> {\n     cell: OnceCell<T>,\n     init: Cell<Option<F>>,\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: fmt::Debug, F> fmt::Debug for Lazy<T, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n@@ -329,7 +329,7 @@ impl<T, F> Lazy<T, F> {\n     /// assert_eq!(&*lazy, \"HELLO, WORLD!\");\n     /// # }\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub const fn new(init: F) -> Lazy<T, F> {\n         Lazy { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n     }\n@@ -353,7 +353,7 @@ impl<T, F: FnOnce() -> T> Lazy<T, F> {\n     /// assert_eq!(Lazy::force(&lazy), &92);\n     /// assert_eq!(&*lazy, &92);\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn force(this: &Lazy<T, F>) -> &T {\n         this.cell.get_or_init(|| match this.init.take() {\n             Some(f) => f(),\n@@ -362,15 +362,15 @@ impl<T, F: FnOnce() -> T> Lazy<T, F> {\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n     type Target = T;\n     fn deref(&self) -> &T {\n         Lazy::force(self)\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: Default> Default for Lazy<T> {\n     /// Creates a new lazy value using `Default` as the initializing function.\n     fn default() -> Lazy<T> {"}, {"sha": "7bd530c5fb10a8d7c5b5f2968d26f9b14c1c7faa", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe639057086fa7bef1e964bf3a211517b04bc328/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe639057086fa7bef1e964bf3a211517b04bc328/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=fe639057086fa7bef1e964bf3a211517b04bc328", "patch": "@@ -239,7 +239,7 @@ pub mod char;\n pub mod ffi;\n #[cfg(not(test))] // See #65860\n pub mod iter;\n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n pub mod lazy;\n pub mod option;\n pub mod panic;"}, {"sha": "86e1cfae582e87bcc14e2e1ac69f19a4652438e3", "filename": "src/libstd/lazy.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fe639057086fa7bef1e964bf3a211517b04bc328/src%2Flibstd%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe639057086fa7bef1e964bf3a211517b04bc328/src%2Flibstd%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flazy.rs?ref=fe639057086fa7bef1e964bf3a211517b04bc328", "patch": "@@ -10,7 +10,7 @@ use crate::{\n };\n \n #[doc(inline)]\n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n pub use core::lazy::*;\n \n /// A synchronization primitive which can be written to only once.\n@@ -38,7 +38,7 @@ pub use core::lazy::*;\n /// assert!(value.is_some());\n /// assert_eq!(value.unwrap().as_str(), \"Hello, World!\");\n /// ```\n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n pub struct SyncOnceCell<T> {\n     once: Once,\n     // Whether or not the value is initialized is tracked by `state_and_queue`.\n@@ -50,24 +50,24 @@ pub struct SyncOnceCell<T> {\n // scoped thread B, which fills the cell, which is\n // then destroyed by A. That is, destructor observes\n // a sent value.\n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n unsafe impl<T: Sync + Send> Sync for SyncOnceCell<T> {}\n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n unsafe impl<T: Send> Send for SyncOnceCell<T> {}\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: RefUnwindSafe + UnwindSafe> RefUnwindSafe for SyncOnceCell<T> {}\n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: UnwindSafe> UnwindSafe for SyncOnceCell<T> {}\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T> Default for SyncOnceCell<T> {\n     fn default() -> SyncOnceCell<T> {\n         SyncOnceCell::new()\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: fmt::Debug> fmt::Debug for SyncOnceCell<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.get() {\n@@ -77,7 +77,7 @@ impl<T: fmt::Debug> fmt::Debug for SyncOnceCell<T> {\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: Clone> Clone for SyncOnceCell<T> {\n     fn clone(&self) -> SyncOnceCell<T> {\n         let cell = Self::new();\n@@ -91,7 +91,7 @@ impl<T: Clone> Clone for SyncOnceCell<T> {\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T> From<T> for SyncOnceCell<T> {\n     fn from(value: T) -> Self {\n         let cell = Self::new();\n@@ -102,19 +102,19 @@ impl<T> From<T> for SyncOnceCell<T> {\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: PartialEq> PartialEq for SyncOnceCell<T> {\n     fn eq(&self, other: &SyncOnceCell<T>) -> bool {\n         self.get() == other.get()\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: Eq> Eq for SyncOnceCell<T> {}\n \n impl<T> SyncOnceCell<T> {\n     /// Creates a new empty cell.\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub const fn new() -> SyncOnceCell<T> {\n         SyncOnceCell { once: Once::new(), value: UnsafeCell::new(MaybeUninit::uninit()) }\n     }\n@@ -123,7 +123,7 @@ impl<T> SyncOnceCell<T> {\n     ///\n     /// Returns `None` if the cell is empty, or being initialized. This\n     /// method never blocks.\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get(&self) -> Option<&T> {\n         if self.is_initialized() {\n             // Safe b/c checked is_initialized\n@@ -136,7 +136,7 @@ impl<T> SyncOnceCell<T> {\n     /// Gets the mutable reference to the underlying value.\n     ///\n     /// Returns `None` if the cell is empty. This method never blocks.\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get_mut(&mut self) -> Option<&mut T> {\n         if self.is_initialized() {\n             // Safe b/c checked is_initialized and we have a unique access\n@@ -170,7 +170,7 @@ impl<T> SyncOnceCell<T> {\n     ///     assert_eq!(CELL.get(), Some(&92));\n     /// }\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn set(&self, value: T) -> Result<(), T> {\n         let mut value = Some(value);\n         self.get_or_init(|| value.take().unwrap());\n@@ -209,7 +209,7 @@ impl<T> SyncOnceCell<T> {\n     /// let value = cell.get_or_init(|| unreachable!());\n     /// assert_eq!(value, &92);\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get_or_init<F>(&self, f: F) -> &T\n     where\n         F: FnOnce() -> T,\n@@ -248,7 +248,7 @@ impl<T> SyncOnceCell<T> {\n     /// assert_eq!(value, Ok(&92));\n     /// assert_eq!(cell.get(), Some(&92))\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n     where\n         F: FnOnce() -> Result<T, E>,\n@@ -286,7 +286,7 @@ impl<T> SyncOnceCell<T> {\n     /// cell.set(\"hello\".to_string()).unwrap();\n     /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn into_inner(mut self) -> Option<T> {\n         // Safety: Safe because we immediately free `self` without dropping\n         let inner = unsafe { self.take_inner() };\n@@ -318,7 +318,7 @@ impl<T> SyncOnceCell<T> {\n     /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n     /// assert_eq!(cell.get(), None);\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn take(&mut self) -> Option<T> {\n         mem::take(self).into_inner()\n     }\n@@ -428,13 +428,13 @@ impl<T> Drop for SyncOnceCell<T> {\n ///     //   Some(\"Hoyten\")\n /// }\n /// ```\n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n pub struct SyncLazy<T, F = fn() -> T> {\n     cell: SyncOnceCell<T>,\n     init: Cell<Option<F>>,\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: fmt::Debug, F> fmt::Debug for SyncLazy<T, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n@@ -446,17 +446,17 @@ impl<T: fmt::Debug, F> fmt::Debug for SyncLazy<T, F> {\n // we do create a `&mut Option<F>` in `force`, but this is\n // properly synchronized, so it only happens once\n // so it also does not contribute to this impl.\n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n unsafe impl<T, F: Send> Sync for SyncLazy<T, F> where SyncOnceCell<T>: Sync {}\n // auto-derived `Send` impl is OK.\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T, F: RefUnwindSafe> RefUnwindSafe for SyncLazy<T, F> where SyncOnceCell<T>: RefUnwindSafe {}\n \n impl<T, F> SyncLazy<T, F> {\n     /// Creates a new lazy value with the given initializing\n     /// function.\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub const fn new(f: F) -> SyncLazy<T, F> {\n         SyncLazy { cell: SyncOnceCell::new(), init: Cell::new(Some(f)) }\n     }\n@@ -479,7 +479,7 @@ impl<T, F: FnOnce() -> T> SyncLazy<T, F> {\n     /// assert_eq!(SyncLazy::force(&lazy), &92);\n     /// assert_eq!(&*lazy, &92);\n     /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn force(this: &SyncLazy<T, F>) -> &T {\n         this.cell.get_or_init(|| match this.init.take() {\n             Some(f) => f(),\n@@ -488,15 +488,15 @@ impl<T, F: FnOnce() -> T> SyncLazy<T, F> {\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T, F: FnOnce() -> T> Deref for SyncLazy<T, F> {\n     type Target = T;\n     fn deref(&self) -> &T {\n         SyncLazy::force(self)\n     }\n }\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: Default> Default for SyncLazy<T> {\n     /// Creates a new lazy value using `Default` as the initializing function.\n     fn default() -> SyncLazy<T> {"}, {"sha": "cf9cc4ebc7bd264e03732e2c9d13209b35427fbf", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe639057086fa7bef1e964bf3a211517b04bc328/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe639057086fa7bef1e964bf3a211517b04bc328/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=fe639057086fa7bef1e964bf3a211517b04bc328", "patch": "@@ -478,7 +478,7 @@ pub mod process;\n pub mod sync;\n pub mod time;\n \n-#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n pub mod lazy;\n \n #[stable(feature = \"futures_api\", since = \"1.36.0\")]"}]}