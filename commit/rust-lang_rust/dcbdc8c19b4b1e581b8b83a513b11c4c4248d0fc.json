{"sha": "dcbdc8c19b4b1e581b8b83a513b11c4c4248d0fc", "node_id": "C_kwDOAAsO6NoAKGRjYmRjOGMxOWI0YjFlNTgxYjhiODNhNTEzYjExYzRjNDI0OGQwZmM", "commit": {"author": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2022-02-17T05:58:13Z"}, "committer": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2022-02-18T19:36:12Z"}, "message": "At opt-level=0, apply only ABI-affecting attributes to functions\n\nThis should provide a small perf improvement for debug builds,\nand should more than cancel out the regression from adding noundef,\nwhich was only significant in debug builds.", "tree": {"sha": "be9fb4a21141869d43e66686586e6d22d36dd19f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be9fb4a21141869d43e66686586e6d22d36dd19f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcbdc8c19b4b1e581b8b83a513b11c4c4248d0fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcbdc8c19b4b1e581b8b83a513b11c4c4248d0fc", "html_url": "https://github.com/rust-lang/rust/commit/dcbdc8c19b4b1e581b8b83a513b11c4c4248d0fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcbdc8c19b4b1e581b8b83a513b11c4c4248d0fc/comments", "author": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73a7423e77b49a99e270531fbadda5b8899df3f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/73a7423e77b49a99e270531fbadda5b8899df3f6", "html_url": "https://github.com/rust-lang/rust/commit/73a7423e77b49a99e270531fbadda5b8899df3f6"}], "stats": {"total": 156, "additions": 115, "deletions": 41}, "files": [{"sha": "a20801914adfa423e91cda269433e87a6a125df7", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 52, "deletions": 41, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/dcbdc8c19b4b1e581b8b83a513b11c4c4248d0fc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbdc8c19b4b1e581b8b83a513b11c4c4248d0fc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=dcbdc8c19b4b1e581b8b83a513b11c4c4248d0fc", "patch": "@@ -13,34 +13,14 @@ use rustc_middle::bug;\n use rustc_middle::ty::layout::LayoutOf;\n pub use rustc_middle::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n use rustc_middle::ty::Ty;\n+use rustc_session::config;\n use rustc_target::abi::call::ArgAbi;\n pub use rustc_target::abi::call::*;\n use rustc_target::abi::{self, HasDataLayout, Int};\n pub use rustc_target::spec::abi::Abi;\n \n use libc::c_uint;\n \n-macro_rules! for_each_kind {\n-    ($flags: ident, $f: ident, $($kind: ident),+) => ({\n-        $(if $flags.contains(ArgAttribute::$kind) { $f(llvm::Attribute::$kind) })+\n-    })\n-}\n-\n-trait ArgAttributeExt {\n-    fn for_each_kind<F>(&self, f: F)\n-    where\n-        F: FnMut(llvm::Attribute);\n-}\n-\n-impl ArgAttributeExt for ArgAttribute {\n-    fn for_each_kind<F>(&self, mut f: F)\n-    where\n-        F: FnMut(llvm::Attribute),\n-    {\n-        for_each_kind!(self, f, NoAlias, NoCapture, NonNull, ReadOnly, InReg, NoUndef)\n-    }\n-}\n-\n pub trait ArgAttributesExt {\n     fn apply_attrs_to_llfn(&self, idx: AttributePlace, cx: &CodegenCx<'_, '_>, llfn: &Value);\n     fn apply_attrs_to_callsite(\n@@ -58,10 +38,36 @@ fn should_use_mutable_noalias(cx: &CodegenCx<'_, '_>) -> bool {\n     cx.tcx.sess.opts.debugging_opts.mutable_noalias.unwrap_or(true)\n }\n \n+const ABI_AFFECTING_ATTRIBUTES: [(ArgAttribute, llvm::Attribute); 1] =\n+    [(ArgAttribute::InReg, llvm::Attribute::InReg)];\n+\n+const OPTIMIZATION_ATTRIBUTES: [(ArgAttribute, llvm::Attribute); 5] = [\n+    (ArgAttribute::NoAlias, llvm::Attribute::NoAlias),\n+    (ArgAttribute::NoCapture, llvm::Attribute::NoCapture),\n+    (ArgAttribute::NonNull, llvm::Attribute::NonNull),\n+    (ArgAttribute::ReadOnly, llvm::Attribute::ReadOnly),\n+    (ArgAttribute::NoUndef, llvm::Attribute::NoUndef),\n+];\n+\n impl ArgAttributesExt for ArgAttributes {\n     fn apply_attrs_to_llfn(&self, idx: AttributePlace, cx: &CodegenCx<'_, '_>, llfn: &Value) {\n         let mut regular = self.regular;\n         unsafe {\n+            // ABI-affecting attributes must always be applied\n+            for (attr, llattr) in ABI_AFFECTING_ATTRIBUTES {\n+                if regular.contains(attr) {\n+                    llattr.apply_llfn(idx, llfn);\n+                }\n+            }\n+            match self.arg_ext {\n+                ArgExtension::None => {}\n+                ArgExtension::Zext => llvm::Attribute::ZExt.apply_llfn(idx, llfn),\n+                ArgExtension::Sext => llvm::Attribute::SExt.apply_llfn(idx, llfn),\n+            }\n+            // Only apply remaining attributes when optimizing\n+            if cx.sess().opts.optimize == config::OptLevel::No {\n+                return;\n+            }\n             let deref = self.pointee_size.bytes();\n             if deref != 0 {\n                 if regular.contains(ArgAttribute::NonNull) {\n@@ -74,19 +80,14 @@ impl ArgAttributesExt for ArgAttributes {\n             if let Some(align) = self.pointee_align {\n                 llvm::LLVMRustAddAlignmentAttr(llfn, idx.as_uint(), align.bytes() as u32);\n             }\n-            regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n+            for (attr, llattr) in OPTIMIZATION_ATTRIBUTES {\n+                if regular.contains(attr) {\n+                    llattr.apply_llfn(idx, llfn);\n+                }\n+            }\n             if regular.contains(ArgAttribute::NoAliasMutRef) && should_use_mutable_noalias(cx) {\n                 llvm::Attribute::NoAlias.apply_llfn(idx, llfn);\n             }\n-            match self.arg_ext {\n-                ArgExtension::None => {}\n-                ArgExtension::Zext => {\n-                    llvm::Attribute::ZExt.apply_llfn(idx, llfn);\n-                }\n-                ArgExtension::Sext => {\n-                    llvm::Attribute::SExt.apply_llfn(idx, llfn);\n-                }\n-            }\n         }\n     }\n \n@@ -98,6 +99,21 @@ impl ArgAttributesExt for ArgAttributes {\n     ) {\n         let mut regular = self.regular;\n         unsafe {\n+            // ABI-affecting attributes must always be applied\n+            for (attr, llattr) in ABI_AFFECTING_ATTRIBUTES {\n+                if regular.contains(attr) {\n+                    llattr.apply_callsite(idx, callsite);\n+                }\n+            }\n+            match self.arg_ext {\n+                ArgExtension::None => {}\n+                ArgExtension::Zext => llvm::Attribute::ZExt.apply_callsite(idx, callsite),\n+                ArgExtension::Sext => llvm::Attribute::SExt.apply_callsite(idx, callsite),\n+            }\n+            // Only apply remaining attributes when optimizing\n+            if cx.sess().opts.optimize == config::OptLevel::No {\n+                return;\n+            }\n             let deref = self.pointee_size.bytes();\n             if deref != 0 {\n                 if regular.contains(ArgAttribute::NonNull) {\n@@ -118,19 +134,14 @@ impl ArgAttributesExt for ArgAttributes {\n                     align.bytes() as u32,\n                 );\n             }\n-            regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));\n+            for (attr, llattr) in OPTIMIZATION_ATTRIBUTES {\n+                if regular.contains(attr) {\n+                    llattr.apply_callsite(idx, callsite);\n+                }\n+            }\n             if regular.contains(ArgAttribute::NoAliasMutRef) && should_use_mutable_noalias(cx) {\n                 llvm::Attribute::NoAlias.apply_callsite(idx, callsite);\n             }\n-            match self.arg_ext {\n-                ArgExtension::None => {}\n-                ArgExtension::Zext => {\n-                    llvm::Attribute::ZExt.apply_callsite(idx, callsite);\n-                }\n-                ArgExtension::Sext => {\n-                    llvm::Attribute::SExt.apply_callsite(idx, callsite);\n-                }\n-            }\n         }\n     }\n }"}, {"sha": "c8c88888978848c2b718dc363d985c9a44fe5d5b", "filename": "src/test/codegen/function-arguments-noopt.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dcbdc8c19b4b1e581b8b83a513b11c4c4248d0fc/src%2Ftest%2Fcodegen%2Ffunction-arguments-noopt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbdc8c19b4b1e581b8b83a513b11c4c4248d0fc/src%2Ftest%2Fcodegen%2Ffunction-arguments-noopt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments-noopt.rs?ref=dcbdc8c19b4b1e581b8b83a513b11c4c4248d0fc", "patch": "@@ -0,0 +1,63 @@\n+// compile-flags: -C opt-level=0 -C no-prepopulate-passes\n+\n+// This test checks that arguments/returns in opt-level=0 builds,\n+// while lacking attributes used for optimization, still have ABI-affecting attributes.\n+\n+#![crate_type = \"lib\"]\n+#![feature(rustc_attrs)]\n+\n+pub struct S {\n+  _field: [i32; 8],\n+}\n+\n+// CHECK: define zeroext i1 @boolean(i1 zeroext %x)\n+#[no_mangle]\n+pub fn boolean(x: bool) -> bool {\n+  x\n+}\n+\n+// CHECK-LABEL: @boolean_call\n+#[no_mangle]\n+pub fn boolean_call(x: bool, f: fn(bool) -> bool) -> bool {\n+// CHECK: call zeroext i1 %f(i1 zeroext %x)\n+  f(x)\n+}\n+\n+// CHECK: define i32* @borrow(i32* %x)\n+#[no_mangle]\n+pub fn borrow(x: &i32) -> &i32 {\n+  x\n+}\n+\n+// CHECK-LABEL: @borrow_call\n+#[no_mangle]\n+pub fn borrow_call(x: &i32, f: fn(&i32) -> &i32) -> &i32 {\n+  // CHECK: call i32* %f(i32* %x)\n+  f(x)\n+}\n+\n+// CHECK: define void @struct_(%S* sret(%S){{( %0)?}}, %S* %x)\n+#[no_mangle]\n+pub fn struct_(x: S) -> S {\n+  x\n+}\n+\n+// CHECK-LABEL: @struct_call\n+#[no_mangle]\n+pub fn struct_call(x: S, f: fn(S) -> S) -> S {\n+  // CHECK: call void %f(%S* sret(%S){{( %0)?}}, %S* %{{.+}})\n+  f(x)\n+}\n+\n+// CHECK: define { i8, i8 } @enum_(i1 zeroext %x.0, i8 %x.1)\n+#[no_mangle]\n+pub fn enum_(x: Option<u8>) -> Option<u8> {\n+  x\n+}\n+\n+// CHECK-LABEL: @enum_call\n+#[no_mangle]\n+pub fn enum_call(x: Option<u8>, f: fn(Option<u8>) -> Option<u8>) -> Option<u8> {\n+  // CHECK: call { i8, i8 } %f(i1 zeroext %x.0, i8 %x.1)\n+  f(x)\n+}"}]}