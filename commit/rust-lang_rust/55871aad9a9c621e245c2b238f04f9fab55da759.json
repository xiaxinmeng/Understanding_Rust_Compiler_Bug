{"sha": "55871aad9a9c621e245c2b238f04f9fab55da759", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ODcxYWFkOWE5YzYyMWUyNDVjMmIyMzhmMDRmOWZhYjU1ZGE3NTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-18T19:33:31Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: split out the pretty-printing parts of ty::print into a separate module.", "tree": {"sha": "c7f47024ec822f762fd74afa7723be32a2a565e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7f47024ec822f762fd74afa7723be32a2a565e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55871aad9a9c621e245c2b238f04f9fab55da759", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55871aad9a9c621e245c2b238f04f9fab55da759", "html_url": "https://github.com/rust-lang/rust/commit/55871aad9a9c621e245c2b238f04f9fab55da759", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55871aad9a9c621e245c2b238f04f9fab55da759/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26f180705a993816dd6e16dd7f19775e4325c709", "url": "https://api.github.com/repos/rust-lang/rust/commits/26f180705a993816dd6e16dd7f19775e4325c709", "html_url": "https://github.com/rust-lang/rust/commit/26f180705a993816dd6e16dd7f19775e4325c709"}], "stats": {"total": 2599, "additions": 1324, "deletions": 1275}, "files": [{"sha": "0165bba5ed7e36609f3907c7954709835c31dfbb", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55871aad9a9c621e245c2b238f04f9fab55da759/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55871aad9a9c621e245c2b238f04f9fab55da759/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=55871aad9a9c621e245c2b238f04f9fab55da759", "patch": "@@ -2370,7 +2370,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                 // When printing regions, add trailing space if necessary.\n                 let ns = Namespace::ValueNS;\n-                ty::print::PrintCx::with_tls_tcx(ty::print::FmtPrinter::new(fmt, ns), |cx| {\n+                ty::print::PrintCx::with_tls_tcx(ty::print::FmtPrinter::new(fmt, ns), |mut cx| {\n                     let region = if cx.config.is_verbose || cx.config.identify_regions {\n                         let mut region = region.to_string();\n                         if region.len() > 0 {\n@@ -2381,7 +2381,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         // Do not even print 'static\n                         String::new()\n                     };\n-                    write!(cx.printer.fmt, \"&{}{}{:?}\", region, kind_str, place)\n+                    write!(cx.printer, \"&{}{}{:?}\", region, kind_str, place)\n                 })\n             }\n "}, {"sha": "9d93d1a34a13a7222dfb5a7fc35af64a1662d02c", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 10, "deletions": 894, "changes": 904, "blob_url": "https://github.com/rust-lang/rust/blob/55871aad9a9c621e245c2b238f04f9fab55da759/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55871aad9a9c621e245c2b238f04f9fab55da759/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=55871aad9a9c621e245c2b238f04f9fab55da759", "patch": "@@ -1,144 +1,21 @@\n-use crate::hir::def::Namespace;\n use crate::hir::map::DefPathData;\n-use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use crate::middle::region;\n+use crate::hir::def_id::{CrateNum, DefId};\n use crate::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n-use crate::ty::subst::{Kind, Subst, SubstsRef, UnpackedKind};\n-use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n-use syntax::symbol::{keywords, Symbol};\n+use crate::ty::subst::{Subst, SubstsRef};\n \n use rustc_data_structures::fx::FxHashSet;\n use syntax::symbol::InternedString;\n \n-use std::cell::Cell;\n-use std::fmt::{self, Write as _};\n use std::iter;\n use std::ops::Deref;\n \n-thread_local! {\n-    static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n-    static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = Cell::new(false);\n-}\n-\n-/// Force us to name impls with just the filename/line number. We\n-/// normally try to use types. But at some points, notably while printing\n-/// cycle errors, this can result in extra or suboptimal error output,\n-/// so this variable disables that check.\n-pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n-    FORCE_IMPL_FILENAME_LINE.with(|force| {\n-        let old = force.get();\n-        force.set(true);\n-        let result = f();\n-        force.set(old);\n-        result\n-    })\n-}\n-\n-/// Adds the `crate::` prefix to paths where appropriate.\n-pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n-    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n-        let old = flag.get();\n-        flag.set(true);\n-        let result = f();\n-        flag.set(old);\n-        result\n-    })\n-}\n+// `pretty` is a separate module only for organization.\n+mod pretty;\n+pub use self::pretty::*;\n \n // FIXME(eddyb) this module uses `pub(crate)` for things used only\n // from `ppaux` - when that is removed, they can be re-privatized.\n \n-/// The \"region highlights\" are used to control region printing during\n-/// specific error messages. When a \"region highlight\" is enabled, it\n-/// gives an alternate way to print specific regions. For now, we\n-/// always print those regions using a number, so something like \"`'0`\".\n-///\n-/// Regions not selected by the region highlight mode are presently\n-/// unaffected.\n-#[derive(Copy, Clone, Default)]\n-pub struct RegionHighlightMode {\n-    /// If enabled, when we see the selected region, use \"`'N`\"\n-    /// instead of the ordinary behavior.\n-    highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n-\n-    /// If enabled, when printing a \"free region\" that originated from\n-    /// the given `ty::BoundRegion`, print it as \"`'1`\". Free regions that would ordinarily\n-    /// have names print as normal.\n-    ///\n-    /// This is used when you have a signature like `fn foo(x: &u32,\n-    /// y: &'a u32)` and we want to give a name to the region of the\n-    /// reference `x`.\n-    highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n-}\n-\n-impl RegionHighlightMode {\n-    /// If `region` and `number` are both `Some`, invokes\n-    /// `highlighting_region`.\n-    pub fn maybe_highlighting_region(\n-        &mut self,\n-        region: Option<ty::Region<'_>>,\n-        number: Option<usize>,\n-    ) {\n-        if let Some(k) = region {\n-            if let Some(n) = number {\n-                self.highlighting_region(k, n);\n-            }\n-        }\n-    }\n-\n-    /// Highlights the region inference variable `vid` as `'N`.\n-    pub fn highlighting_region(\n-        &mut self,\n-        region: ty::Region<'_>,\n-        number: usize,\n-    ) {\n-        let num_slots = self.highlight_regions.len();\n-        let first_avail_slot = self.highlight_regions.iter_mut()\n-            .filter(|s| s.is_none())\n-            .next()\n-            .unwrap_or_else(|| {\n-                bug!(\n-                    \"can only highlight {} placeholders at a time\",\n-                    num_slots,\n-                )\n-            });\n-        *first_avail_slot = Some((*region, number));\n-    }\n-\n-    /// Convenience wrapper for `highlighting_region`.\n-    pub fn highlighting_region_vid(\n-        &mut self,\n-        vid: ty::RegionVid,\n-        number: usize,\n-    ) {\n-        self.highlighting_region(&ty::ReVar(vid), number)\n-    }\n-\n-    /// Returns `Some(n)` with the number to use for the given region, if any.\n-    fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n-        self\n-            .highlight_regions\n-            .iter()\n-            .filter_map(|h| match h {\n-                Some((r, n)) if r == region => Some(*n),\n-                _ => None,\n-            })\n-            .next()\n-    }\n-\n-    /// Highlight the given bound region.\n-    /// We can only highlight one bound region at a time. See\n-    /// the field `highlight_bound_region` for more detailed notes.\n-    pub fn highlighting_bound_region(\n-        &mut self,\n-        br: ty::BoundRegion,\n-        number: usize,\n-    ) {\n-        assert!(self.highlight_bound_region.is_none());\n-        self.highlight_bound_region = Some((br, number));\n-    }\n-}\n-\n struct LateBoundRegionNameCollector(FxHashSet<InternedString>);\n impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n@@ -156,13 +33,13 @@ pub(crate) struct PrintConfig {\n     pub(crate) is_debug: bool,\n     pub(crate) is_verbose: bool,\n     pub(crate) identify_regions: bool,\n-    pub(crate) used_region_names: Option<FxHashSet<InternedString>>,\n-    pub(crate) region_index: usize,\n-    pub(crate) binder_depth: usize,\n+    used_region_names: Option<FxHashSet<InternedString>>,\n+    region_index: usize,\n+    binder_depth: usize,\n }\n \n impl PrintConfig {\n-    pub(crate) fn new(tcx: TyCtxt<'_, '_, '_>) -> Self {\n+    fn new(tcx: TyCtxt<'_, '_, '_>) -> Self {\n         PrintConfig {\n             is_debug: false,\n             is_verbose: tcx.sess.verbose(),\n@@ -205,7 +82,7 @@ impl<'a, 'gcx, 'tcx, P> PrintCx<'a, 'gcx, 'tcx, P> {\n     pub(crate) fn with_tls_tcx<R>(printer: P, f: impl FnOnce(PrintCx<'_, '_, '_, P>) -> R) -> R {\n         ty::tls::with(|tcx| PrintCx::with(tcx, printer, f))\n     }\n-    pub(crate) fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n+    fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n     where T: TypeFoldable<'tcx>\n     {\n         let mut collector = LateBoundRegionNameCollector(Default::default());\n@@ -318,109 +195,6 @@ pub trait Printer: Sized {\n     ) -> Result<Self::Path, Self::Error>;\n }\n \n-/// Trait for printers that pretty-print using `fmt::Write` to the printer.\n-pub trait PrettyPrinter:\n-    Printer<\n-        Error = fmt::Error,\n-        Path = Self,\n-        Region = Self,\n-        Type = Self,\n-    > +\n-    fmt::Write\n-{\n-    /// Enter a nested print context, for pretty-printing\n-    /// nested components in some larger context.\n-    fn nest<'a, 'gcx, 'tcx, E>(\n-        self: PrintCx<'a, 'gcx, 'tcx, Self>,\n-        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n-    ) -> Result<PrintCx<'a, 'gcx, 'tcx, Self>, E> {\n-        let printer = f(PrintCx {\n-            tcx: self.tcx,\n-            printer: self.printer,\n-            config: self.config,\n-        })?;\n-        Ok(PrintCx {\n-            tcx: self.tcx,\n-            printer,\n-            config: self.config,\n-        })\n-    }\n-\n-    /// Like `print_def_path` but for value paths.\n-    fn print_value_path(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n-        def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self.print_def_path(def_id, substs, iter::empty())\n-    }\n-\n-    /// Print `<...>` around what `f` prints.\n-    fn generic_delimiters<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n-    ) -> Result<Self, Self::Error>;\n-\n-    /// Return `true` if the region should be printed in path generic args\n-    /// even when it's `'_`, such as in e.g. `Foo<'_, '_, '_>`.\n-    fn always_print_region_in_paths(\n-        self: &PrintCx<'_, '_, '_, Self>,\n-        _region: ty::Region<'_>,\n-    ) -> bool {\n-        false\n-    }\n-\n-    // HACK(eddyb) Trying to print a lifetime might not print anything, which\n-    // may need special handling in the caller (of `ty::RegionKind::print`).\n-    // To avoid printing to a temporary string (which isn't even supported),\n-    // the `print_region_outputs_anything` method can instead be used to\n-    // determine this, ahead of time.\n-    //\n-    // NB: this must be kept in sync with the implementation of `print_region`.\n-    fn print_region_outputs_anything(\n-        self: &PrintCx<'_, '_, '_, Self>,\n-        region: ty::Region<'_>,\n-    ) -> bool;\n-}\n-\n-macro_rules! nest {\n-    ($cx:ident, $closure:expr) => {\n-        $cx = $cx.nest($closure)?\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n-    // (but also some things just print a `DefId` generally so maybe we need this?)\n-    fn guess_def_namespace(self, def_id: DefId) -> Namespace {\n-        match self.def_key(def_id).disambiguated_data.data {\n-            DefPathData::ValueNs(..) |\n-            DefPathData::EnumVariant(..) |\n-            DefPathData::Field(..) |\n-            DefPathData::AnonConst |\n-            DefPathData::ConstParam(..) |\n-            DefPathData::ClosureExpr |\n-            DefPathData::StructCtor => Namespace::ValueNS,\n-\n-            DefPathData::MacroDef(..) => Namespace::MacroNS,\n-\n-            _ => Namespace::TypeNS,\n-        }\n-    }\n-\n-    /// Returns a string identifying this `DefId`. This string is\n-    /// suitable for user output.\n-    pub fn def_path_str(self, def_id: DefId) -> String {\n-        let ns = self.guess_def_namespace(def_id);\n-        debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n-        let mut s = String::new();\n-        let _ = PrintCx::with(self, FmtPrinter::new(&mut s, ns), |cx| {\n-            cx.print_def_path(def_id, None, iter::empty())\n-        });\n-        s\n-    }\n-}\n-\n impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n     pub fn default_print_def_path(\n         self,\n@@ -588,661 +362,3 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n         ty::Float(_) => None,\n     }\n }\n-\n-pub struct FmtPrinter<F: fmt::Write> {\n-    pub(crate) fmt: F,\n-    empty: bool,\n-    in_value: bool,\n-    pub region_highlight_mode: RegionHighlightMode,\n-}\n-\n-impl<F: fmt::Write> FmtPrinter<F> {\n-    pub fn new(fmt: F, ns: Namespace) -> Self {\n-        FmtPrinter {\n-            fmt,\n-            empty: true,\n-            in_value: ns == Namespace::ValueNS,\n-            region_highlight_mode: RegionHighlightMode::default(),\n-        }\n-    }\n-}\n-\n-impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n-    /// If possible, this returns a global path resolving to `def_id` that is visible\n-    /// from at least one local module and returns true. If the crate defining `def_id` is\n-    /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n-    fn try_print_visible_def_path(\n-        mut self,\n-        def_id: DefId,\n-    ) -> Result<(P, bool), P::Error> {\n-        debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n-\n-        // If `def_id` is a direct or injected extern crate, return the\n-        // path to the crate followed by the path to the item within the crate.\n-        if def_id.index == CRATE_DEF_INDEX {\n-            let cnum = def_id.krate;\n-\n-            if cnum == LOCAL_CRATE {\n-                return Ok((self.path_crate(cnum)?, true));\n-            }\n-\n-            // In local mode, when we encounter a crate other than\n-            // LOCAL_CRATE, execution proceeds in one of two ways:\n-            //\n-            // 1. for a direct dependency, where user added an\n-            //    `extern crate` manually, we put the `extern\n-            //    crate` as the parent. So you wind up with\n-            //    something relative to the current crate.\n-            // 2. for an extern inferred from a path or an indirect crate,\n-            //    where there is no explicit `extern crate`, we just prepend\n-            //    the crate name.\n-            match *self.tcx.extern_crate(def_id) {\n-                Some(ExternCrate {\n-                    src: ExternCrateSource::Extern(def_id),\n-                    direct: true,\n-                    span,\n-                    ..\n-                }) => {\n-                    debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n-                    return Ok((if !span.is_dummy() {\n-                        self.print_def_path(def_id, None, iter::empty())?\n-                    } else {\n-                        self.path_crate(cnum)?\n-                    }, true));\n-                }\n-                None => {\n-                    return Ok((self.path_crate(cnum)?, true));\n-                }\n-                _ => {},\n-            }\n-        }\n-\n-        if def_id.is_local() {\n-            return Ok((self.printer, false));\n-        }\n-\n-        let visible_parent_map = self.tcx.visible_parent_map(LOCAL_CRATE);\n-\n-        let mut cur_def_key = self.tcx.def_key(def_id);\n-        debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n-\n-        // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n-        if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n-            let parent = DefId {\n-                krate: def_id.krate,\n-                index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n-            };\n-\n-            cur_def_key = self.tcx.def_key(parent);\n-        }\n-\n-        let visible_parent = match visible_parent_map.get(&def_id).cloned() {\n-            Some(parent) => parent,\n-            None => return Ok((self.printer, false)),\n-        };\n-        // HACK(eddyb) this uses `nest` to avoid knowing ahead of time whether\n-        // the entire path will succeed or not. To support printers that do not\n-        // implement `PrettyPrinter`, a `Vec` or linked list on the stack would\n-        // need to be built, before starting to print anything.\n-        let mut prefix_success = false;\n-        nest!(self, |cx| {\n-            let (printer, success) = cx.try_print_visible_def_path(visible_parent)?;\n-            prefix_success = success;\n-            Ok(printer)\n-        });\n-        if !prefix_success {\n-            return Ok((self.printer, false));\n-        };\n-        let actual_parent = self.tcx.parent(def_id);\n-\n-        let data = cur_def_key.disambiguated_data.data;\n-        debug!(\n-            \"try_print_visible_def_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n-            data, visible_parent, actual_parent,\n-        );\n-\n-        let symbol = match data {\n-            // In order to output a path that could actually be imported (valid and visible),\n-            // we need to handle re-exports correctly.\n-            //\n-            // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n-            // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n-            //\n-            // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n-            // private so the \"true\" path to `CommandExt` isn't accessible.\n-            //\n-            // In this case, the `visible_parent_map` will look something like this:\n-            //\n-            // (child) -> (parent)\n-            // `std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n-            // `std::sys::unix::ext::process` -> `std::sys::unix::ext`\n-            // `std::sys::unix::ext` -> `std::os`\n-            //\n-            // This is correct, as the visible parent of `std::sys::unix::ext` is in fact\n-            // `std::os`.\n-            //\n-            // When printing the path to `CommandExt` and looking at the `cur_def_key` that\n-            // corresponds to `std::sys::unix::ext`, we would normally print `ext` and then go\n-            // to the parent - resulting in a mangled path like\n-            // `std::os::ext::process::CommandExt`.\n-            //\n-            // Instead, we must detect that there was a re-export and instead print `unix`\n-            // (which is the name `std::sys::unix::ext` was re-exported as in `std::os`). To\n-            // do this, we compare the parent of `std::sys::unix::ext` (`std::sys::unix`) with\n-            // the visible parent (`std::os`). If these do not match, then we iterate over\n-            // the children of the visible parent (as was done when computing\n-            // `visible_parent_map`), looking for the specific child we currently have and then\n-            // have access to the re-exported name.\n-            DefPathData::Module(actual_name) |\n-            DefPathData::TypeNs(actual_name) if Some(visible_parent) != actual_parent => {\n-                self.tcx.item_children(visible_parent)\n-                    .iter()\n-                    .find(|child| child.def.def_id() == def_id)\n-                    .map(|child| child.ident.as_str())\n-                    .unwrap_or_else(|| actual_name.as_str())\n-            }\n-            _ => {\n-                data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n-                    // Re-exported `extern crate` (#43189).\n-                    if let DefPathData::CrateRoot = data {\n-                        self.tcx.original_crate_name(def_id.krate).as_str()\n-                    } else {\n-                        Symbol::intern(\"<unnamed>\").as_str()\n-                    }\n-                })\n-            },\n-        };\n-        debug!(\"try_print_visible_def_path: symbol={:?}\", symbol);\n-        Ok((self.path_append(|cx| Ok(cx.printer), &symbol)?, true))\n-    }\n-\n-    pub fn pretty_path_qualified(\n-        self,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<P::Path, P::Error> {\n-        if trait_ref.is_none() {\n-            // Inherent impls. Try to print `Foo::bar` for an inherent\n-            // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n-            // anything other than a simple path.\n-            match self_ty.sty {\n-                ty::Adt(..) | ty::Foreign(_) |\n-                ty::Bool | ty::Char | ty::Str |\n-                ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n-                    return self_ty.print_display(self);\n-                }\n-\n-                _ => {}\n-            }\n-        }\n-\n-        self.generic_delimiters(|mut cx| {\n-            nest!(cx, |cx| self_ty.print_display(cx));\n-            if let Some(trait_ref) = trait_ref {\n-                write!(cx.printer, \" as \")?;\n-                nest!(cx, |cx| trait_ref.print_display(cx));\n-            }\n-            Ok(cx.printer)\n-        })\n-    }\n-\n-    pub fn pretty_path_append_impl(\n-        mut self,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, P>,\n-        ) -> Result<P::Path, P::Error>,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<P::Path, P::Error> {\n-        nest!(self, print_prefix);\n-\n-        self.generic_delimiters(|mut cx| {\n-            write!(cx.printer, \"impl \")?;\n-            if let Some(trait_ref) = trait_ref {\n-                nest!(cx, |cx| trait_ref.print_display(cx));\n-                write!(cx.printer, \" for \")?;\n-            }\n-            nest!(cx, |cx| self_ty.print_display(cx));\n-\n-            Ok(cx.printer)\n-        })\n-    }\n-\n-    pub fn pretty_path_generic_args(\n-        mut self,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, P>,\n-        ) -> Result<P::Path, P::Error>,\n-        params: &[ty::GenericParamDef],\n-        substs: SubstsRef<'tcx>,\n-        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-    ) -> Result<P::Path, P::Error> {\n-        nest!(self, |cx| print_prefix(cx));\n-\n-        // Don't print `'_` if there's no printed region.\n-        let print_regions = params.iter().any(|param| {\n-            match substs[param.index as usize].unpack() {\n-                UnpackedKind::Lifetime(r) => {\n-                    self.always_print_region_in_paths(r) ||\n-                    self.print_region_outputs_anything(r)\n-                }\n-                _ => false,\n-            }\n-        });\n-\n-        // Don't print args that are the defaults of their respective parameters.\n-        let num_supplied_defaults = if self.config.is_verbose {\n-            0\n-        } else {\n-            params.iter().rev().take_while(|param| {\n-                match param.kind {\n-                    ty::GenericParamDefKind::Lifetime => false,\n-                    ty::GenericParamDefKind::Type { has_default, .. } => {\n-                        has_default && substs[param.index as usize] == Kind::from(\n-                            self.tcx.type_of(param.def_id).subst(self.tcx, substs)\n-                        )\n-                    }\n-                    ty::GenericParamDefKind::Const => false, // FIXME(const_generics:defaults)\n-                }\n-            }).count()\n-        };\n-\n-        let params = &params[..params.len() - num_supplied_defaults];\n-        let mut args = params.iter().map(|param| {\n-            substs[param.index as usize].unpack()\n-        }).filter(|arg| {\n-            match arg {\n-                UnpackedKind::Lifetime(_) => print_regions,\n-                _ => true,\n-            }\n-        });\n-        let arg0 = args.next();\n-\n-        let mut projections = projections;\n-        let projection0 = projections.next();\n-\n-        if arg0.is_none() && projection0.is_none() {\n-            return Ok(self.printer);\n-        }\n-\n-        self.generic_delimiters(|mut cx| {\n-            let mut empty = true;\n-            let mut maybe_comma = |cx: &mut Self| {\n-                if empty {\n-                    empty = false;\n-                    Ok(())\n-                } else {\n-                    write!(cx.printer, \", \")\n-                }\n-            };\n-\n-            for arg in arg0.into_iter().chain(args) {\n-                maybe_comma(&mut cx)?;\n-\n-                match arg {\n-                    UnpackedKind::Lifetime(region) => {\n-                        if !cx.print_region_outputs_anything(region) {\n-                            // This happens when the value of the region\n-                            // parameter is not easily serialized. This may be\n-                            // because the user omitted it in the first place,\n-                            // or because it refers to some block in the code,\n-                            // etc. I'm not sure how best to serialize this.\n-                            write!(cx.printer, \"'_\")?;\n-                        } else {\n-                            nest!(cx, |cx| region.print_display(cx));\n-                        }\n-                    }\n-                    UnpackedKind::Type(ty) => {\n-                        nest!(cx, |cx| ty.print_display(cx));\n-                    }\n-                    UnpackedKind::Const(ct) => {\n-                        nest!(cx, |cx| ct.print_display(cx));\n-                    }\n-                }\n-            }\n-\n-            for projection in projection0.into_iter().chain(projections) {\n-                maybe_comma(&mut cx)?;\n-\n-                write!(cx.printer, \"{}=\",\n-                    cx.tcx.associated_item(projection.item_def_id).ident)?;\n-                nest!(cx, |cx| projection.ty.print_display(cx));\n-            }\n-\n-            Ok(cx.printer)\n-        })\n-    }\n-}\n-\n-impl<F: fmt::Write> fmt::Write for FmtPrinter<F> {\n-    fn write_str(&mut self, s: &str) -> fmt::Result {\n-        self.empty &= s.is_empty();\n-        self.fmt.write_str(s)\n-    }\n-}\n-\n-impl<F: fmt::Write> Printer for FmtPrinter<F> {\n-    type Error = fmt::Error;\n-\n-    type Path = Self;\n-    type Region = Self;\n-    type Type = Self;\n-\n-    fn print_def_path(\n-        mut self: PrintCx<'_, '_, 'tcx, Self>,\n-        def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        // FIXME(eddyb) avoid querying `tcx.generics_of` and `tcx.def_key`\n-        // both here and in `default_print_def_path`.\n-        let generics = substs.map(|_| self.tcx.generics_of(def_id));\n-        if generics.as_ref().and_then(|g| g.parent).is_none() {\n-            let mut visible_path_success = false;\n-            nest!(self, |cx| {\n-                let (printer, success) = cx.try_print_visible_def_path(def_id)?;\n-                visible_path_success = success;\n-                Ok(printer)\n-            });\n-            if visible_path_success {\n-                return if let (Some(generics), Some(substs)) = (generics, substs) {\n-                    let has_own_self = generics.has_self && generics.parent_count == 0;\n-                    let params = &generics.params[has_own_self as usize..];\n-                    self.path_generic_args(|cx| Ok(cx.printer), params, substs, projections)\n-                } else {\n-                    Ok(self.printer)\n-                };\n-            }\n-        }\n-\n-        let key = self.tcx.def_key(def_id);\n-        if let DefPathData::Impl = key.disambiguated_data.data {\n-            // Always use types for non-local impls, where types are always\n-            // available, and filename/line-number is mostly uninteresting.\n-            let use_types =\n-                !def_id.is_local() || {\n-                    // Otherwise, use filename/line-number if forced.\n-                    let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n-                    !force_no_types\n-                };\n-\n-            if !use_types {\n-                // If no type info is available, fall back to\n-                // pretty printing some span information. This should\n-                // only occur very early in the compiler pipeline.\n-                let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n-                let span = self.tcx.def_span(def_id);\n-                return self.path_append(\n-                    |cx| cx.print_def_path(parent_def_id, None, iter::empty()),\n-                    &format!(\"<impl at {:?}>\", span),\n-                );\n-            }\n-        }\n-\n-        self.default_print_def_path(def_id, substs, projections)\n-    }\n-\n-    fn print_region(\n-        mut self: PrintCx<'_, '_, '_, Self>,\n-        region: ty::Region<'_>,\n-    ) -> Result<Self::Region, Self::Error> {\n-        // Watch out for region highlights.\n-        let highlight = self.printer.region_highlight_mode;\n-        if let Some(n) = highlight.region_highlighted(region) {\n-            write!(self.printer, \"'{}\", n)?;\n-            return Ok(self.printer);\n-        }\n-\n-        if self.config.is_verbose {\n-            return region.print_debug(self);\n-        }\n-\n-        // These printouts are concise.  They do not contain all the information\n-        // the user might want to diagnose an error, but there is basically no way\n-        // to fit that into a short string.  Hence the recommendation to use\n-        // `explain_region()` or `note_and_explain_region()`.\n-        match *region {\n-            ty::ReEarlyBound(ref data) => {\n-                if data.name != \"'_\" {\n-                    write!(self.printer, \"{}\", data.name)?;\n-                }\n-            }\n-            ty::ReLateBound(_, br) |\n-            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n-                if let ty::BrNamed(_, name) = br {\n-                    if name != \"\" && name != \"'_\" {\n-                        write!(self.printer, \"{}\", name)?;\n-                        return Ok(self.printer);\n-                    }\n-                }\n-\n-                if let Some((region, counter)) = highlight.highlight_bound_region {\n-                    if br == region {\n-                        write!(self.printer, \"'{}\", counter)?;\n-                    }\n-                }\n-            }\n-            ty::ReScope(scope) if self.config.identify_regions => {\n-                match scope.data {\n-                    region::ScopeData::Node =>\n-                        write!(self.printer, \"'{}s\", scope.item_local_id().as_usize())?,\n-                    region::ScopeData::CallSite =>\n-                        write!(self.printer, \"'{}cs\", scope.item_local_id().as_usize())?,\n-                    region::ScopeData::Arguments =>\n-                        write!(self.printer, \"'{}as\", scope.item_local_id().as_usize())?,\n-                    region::ScopeData::Destruction =>\n-                        write!(self.printer, \"'{}ds\", scope.item_local_id().as_usize())?,\n-                    region::ScopeData::Remainder(first_statement_index) => write!(self.printer,\n-                        \"'{}_{}rs\",\n-                        scope.item_local_id().as_usize(),\n-                        first_statement_index.index()\n-                    )?,\n-                }\n-            }\n-            ty::ReVar(region_vid) if self.config.identify_regions => {\n-                write!(self.printer, \"{:?}\", region_vid)?;\n-            }\n-            ty::ReVar(_) => {}\n-            ty::ReScope(_) |\n-            ty::ReErased => {}\n-            ty::ReStatic => write!(self.printer, \"'static\")?,\n-            ty::ReEmpty => write!(self.printer, \"'<empty>\")?,\n-\n-            // The user should never encounter these in unsubstituted form.\n-            ty::ReClosureBound(vid) => write!(self.printer, \"{:?}\", vid)?,\n-        }\n-\n-        Ok(self.printer)\n-    }\n-\n-    fn print_type(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n-        ty: Ty<'tcx>,\n-    ) -> Result<Self::Type, Self::Error> {\n-        self.pretty_print_type(ty)\n-    }\n-\n-    fn path_crate(\n-        mut self: PrintCx<'_, '_, '_, Self>,\n-        cnum: CrateNum,\n-    ) -> Result<Self::Path, Self::Error> {\n-        if cnum == LOCAL_CRATE {\n-            if self.tcx.sess.rust_2018() {\n-                // We add the `crate::` keyword on Rust 2018, only when desired.\n-                if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n-                    write!(self.printer, \"{}\", keywords::Crate.name())?;\n-                }\n-            }\n-            Ok(self.printer)\n-        } else {\n-            write!(self.printer, \"{}\", self.tcx.crate_name(cnum))?;\n-            Ok(self.printer)\n-        }\n-    }\n-    fn path_qualified(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_qualified(self_ty, trait_ref)\n-    }\n-\n-    fn path_append_impl<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, Self>,\n-        ) -> Result<Self::Path, Self::Error>,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_append_impl(|cx| {\n-            let mut printer = print_prefix(cx)?;\n-\n-            // HACK(eddyb) this accounts for `generic_delimiters`\n-            // printing `::<` instead of `<` if `in_value` is set.\n-            if !printer.empty && !printer.in_value {\n-                write!(printer, \"::\")?;\n-            }\n-\n-            Ok(printer)\n-        }, self_ty, trait_ref)\n-    }\n-    fn path_append<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, Self>,\n-        ) -> Result<Self::Path, Self::Error>,\n-        text: &str,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let mut printer = print_prefix(self)?;\n-\n-        // FIXME(eddyb) `text` should never be empty, but it\n-        // currently is for `extern { ... }` \"foreign modules\".\n-        if !text.is_empty() {\n-            if !printer.empty {\n-                write!(printer, \"::\")?;\n-            }\n-            write!(printer, \"{}\", text)?;\n-        }\n-\n-        Ok(printer)\n-    }\n-    fn path_generic_args<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, Self>,\n-        ) -> Result<Self::Path, Self::Error>,\n-        params: &[ty::GenericParamDef],\n-        substs: SubstsRef<'tcx>,\n-        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_generic_args(print_prefix, params, substs, projections)\n-    }\n-}\n-\n-impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n-    fn nest<'a, 'gcx, 'tcx, E>(\n-        mut self: PrintCx<'a, 'gcx, 'tcx, Self>,\n-        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n-    ) -> Result<PrintCx<'a, 'gcx, 'tcx, Self>, E> {\n-        let was_empty = std::mem::replace(&mut self.printer.empty, true);\n-        let mut printer = f(PrintCx {\n-            tcx: self.tcx,\n-            printer: self.printer,\n-            config: self.config,\n-        })?;\n-        printer.empty &= was_empty;\n-        Ok(PrintCx {\n-            tcx: self.tcx,\n-            printer,\n-            config: self.config,\n-        })\n-    }\n-\n-    fn print_value_path(\n-        mut self: PrintCx<'_, '_, 'tcx, Self>,\n-        def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let was_in_value = std::mem::replace(&mut self.printer.in_value, true);\n-        let mut printer = self.print_def_path(def_id, substs, iter::empty())?;\n-        printer.in_value = was_in_value;\n-\n-        Ok(printer)\n-    }\n-\n-    fn generic_delimiters<'gcx, 'tcx>(\n-        mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n-    ) -> Result<Self, Self::Error> {\n-        if !self.printer.empty && self.printer.in_value {\n-            write!(self.printer, \"::<\")?;\n-        } else {\n-            write!(self.printer, \"<\")?;\n-        }\n-\n-        let was_in_value = std::mem::replace(&mut self.printer.in_value, false);\n-        let mut printer = f(self)?;\n-        printer.in_value = was_in_value;\n-\n-        write!(printer, \">\")?;\n-        Ok(printer)\n-    }\n-\n-    fn always_print_region_in_paths(\n-        self: &PrintCx<'_, '_, '_, Self>,\n-        region: ty::Region<'_>,\n-    ) -> bool {\n-        *region != ty::ReErased\n-    }\n-\n-    fn print_region_outputs_anything(\n-        self: &PrintCx<'_, '_, '_, Self>,\n-        region: ty::Region<'_>,\n-    ) -> bool {\n-        let highlight = self.printer.region_highlight_mode;\n-        if highlight.region_highlighted(region).is_some() {\n-            return true;\n-        }\n-\n-        if self.config.is_verbose {\n-            return true;\n-        }\n-\n-        match *region {\n-            ty::ReEarlyBound(ref data) => {\n-                data.name != \"\" && data.name != \"'_\"\n-            }\n-\n-            ty::ReLateBound(_, br) |\n-            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n-                if let ty::BrNamed(_, name) = br {\n-                    if name != \"\" && name != \"'_\" {\n-                        return true;\n-                    }\n-                }\n-\n-                if let Some((region, _)) = highlight.highlight_bound_region {\n-                    if br == region {\n-                        return true;\n-                    }\n-                }\n-\n-                false\n-            }\n-\n-            ty::ReScope(_) |\n-            ty::ReVar(_) if self.config.identify_regions => true,\n-\n-            ty::ReVar(_) |\n-            ty::ReScope(_) |\n-            ty::ReErased => false,\n-\n-            ty::ReStatic |\n-            ty::ReEmpty |\n-            ty::ReClosureBound(_) => true,\n-        }\n-    }\n-}"}, {"sha": "caa4090625d911b21cc03f577d3653c7f7e98201", "filename": "src/librustc/ty/print/pretty.rs", "status": "added", "additions": 1305, "deletions": 0, "changes": 1305, "blob_url": "https://github.com/rust-lang/rust/blob/55871aad9a9c621e245c2b238f04f9fab55da759/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55871aad9a9c621e245c2b238f04f9fab55da759/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=55871aad9a9c621e245c2b238f04f9fab55da759", "patch": "@@ -0,0 +1,1305 @@\n+use crate::hir;\n+use crate::hir::def::Namespace;\n+use crate::hir::map::DefPathData;\n+use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n+use crate::middle::region;\n+use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::subst::{Kind, Subst, SubstsRef, UnpackedKind};\n+use crate::mir::interpret::ConstValue;\n+use syntax::symbol::{keywords, Symbol};\n+\n+use syntax::symbol::InternedString;\n+\n+use std::cell::Cell;\n+use std::fmt::{self, Write as _};\n+use std::iter;\n+\n+// `pretty` is a separate module only for organization.\n+use super::*;\n+\n+macro_rules! nest {\n+    ($closure:expr) => {\n+        scoped_cx!() = scoped_cx!().nest($closure)?\n+    }\n+}\n+macro_rules! print_inner {\n+    (write ($($data:expr),+)) => {\n+        write!(scoped_cx!().printer, $($data),+)?\n+    };\n+    ($kind:ident ($data:expr)) => {\n+        nest!(|cx| $data.$kind(cx))\n+    };\n+}\n+macro_rules! p {\n+    ($($kind:ident $data:tt),+) => {\n+        {\n+            $(print_inner!($kind $data));+\n+        }\n+    };\n+}\n+macro_rules! define_scoped_cx {\n+    ($cx:ident) => {\n+        #[allow(unused_macros)]\n+        macro_rules! scoped_cx {\n+            () => ($cx)\n+        }\n+    };\n+}\n+\n+thread_local! {\n+    static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n+    static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = Cell::new(false);\n+}\n+\n+/// Force us to name impls with just the filename/line number. We\n+/// normally try to use types. But at some points, notably while printing\n+/// cycle errors, this can result in extra or suboptimal error output,\n+/// so this variable disables that check.\n+pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n+    FORCE_IMPL_FILENAME_LINE.with(|force| {\n+        let old = force.get();\n+        force.set(true);\n+        let result = f();\n+        force.set(old);\n+        result\n+    })\n+}\n+\n+/// Adds the `crate::` prefix to paths where appropriate.\n+pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n+    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n+        let old = flag.get();\n+        flag.set(true);\n+        let result = f();\n+        flag.set(old);\n+        result\n+    })\n+}\n+\n+/// The \"region highlights\" are used to control region printing during\n+/// specific error messages. When a \"region highlight\" is enabled, it\n+/// gives an alternate way to print specific regions. For now, we\n+/// always print those regions using a number, so something like \"`'0`\".\n+///\n+/// Regions not selected by the region highlight mode are presently\n+/// unaffected.\n+#[derive(Copy, Clone, Default)]\n+pub struct RegionHighlightMode {\n+    /// If enabled, when we see the selected region, use \"`'N`\"\n+    /// instead of the ordinary behavior.\n+    highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n+\n+    /// If enabled, when printing a \"free region\" that originated from\n+    /// the given `ty::BoundRegion`, print it as \"`'1`\". Free regions that would ordinarily\n+    /// have names print as normal.\n+    ///\n+    /// This is used when you have a signature like `fn foo(x: &u32,\n+    /// y: &'a u32)` and we want to give a name to the region of the\n+    /// reference `x`.\n+    highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n+}\n+\n+impl RegionHighlightMode {\n+    /// If `region` and `number` are both `Some`, invokes\n+    /// `highlighting_region`.\n+    pub fn maybe_highlighting_region(\n+        &mut self,\n+        region: Option<ty::Region<'_>>,\n+        number: Option<usize>,\n+    ) {\n+        if let Some(k) = region {\n+            if let Some(n) = number {\n+                self.highlighting_region(k, n);\n+            }\n+        }\n+    }\n+\n+    /// Highlights the region inference variable `vid` as `'N`.\n+    pub fn highlighting_region(\n+        &mut self,\n+        region: ty::Region<'_>,\n+        number: usize,\n+    ) {\n+        let num_slots = self.highlight_regions.len();\n+        let first_avail_slot = self.highlight_regions.iter_mut()\n+            .filter(|s| s.is_none())\n+            .next()\n+            .unwrap_or_else(|| {\n+                bug!(\n+                    \"can only highlight {} placeholders at a time\",\n+                    num_slots,\n+                )\n+            });\n+        *first_avail_slot = Some((*region, number));\n+    }\n+\n+    /// Convenience wrapper for `highlighting_region`.\n+    pub fn highlighting_region_vid(\n+        &mut self,\n+        vid: ty::RegionVid,\n+        number: usize,\n+    ) {\n+        self.highlighting_region(&ty::ReVar(vid), number)\n+    }\n+\n+    /// Returns `Some(n)` with the number to use for the given region, if any.\n+    fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n+        self\n+            .highlight_regions\n+            .iter()\n+            .filter_map(|h| match h {\n+                Some((r, n)) if r == region => Some(*n),\n+                _ => None,\n+            })\n+            .next()\n+    }\n+\n+    /// Highlight the given bound region.\n+    /// We can only highlight one bound region at a time. See\n+    /// the field `highlight_bound_region` for more detailed notes.\n+    pub fn highlighting_bound_region(\n+        &mut self,\n+        br: ty::BoundRegion,\n+        number: usize,\n+    ) {\n+        assert!(self.highlight_bound_region.is_none());\n+        self.highlight_bound_region = Some((br, number));\n+    }\n+}\n+\n+/// Trait for printers that pretty-print using `fmt::Write` to the printer.\n+pub trait PrettyPrinter:\n+    Printer<\n+        Error = fmt::Error,\n+        Path = Self,\n+        Region = Self,\n+        Type = Self,\n+    > +\n+    fmt::Write\n+{\n+    /// Enter a nested print context, for pretty-printing\n+    /// nested components in some larger context.\n+    fn nest<'a, 'gcx, 'tcx, E>(\n+        self: PrintCx<'a, 'gcx, 'tcx, Self>,\n+        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n+    ) -> Result<PrintCx<'a, 'gcx, 'tcx, Self>, E> {\n+        let printer = f(PrintCx {\n+            tcx: self.tcx,\n+            printer: self.printer,\n+            config: self.config,\n+        })?;\n+        Ok(PrintCx {\n+            tcx: self.tcx,\n+            printer,\n+            config: self.config,\n+        })\n+    }\n+\n+    /// Like `print_def_path` but for value paths.\n+    fn print_value_path(\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n+        def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.print_def_path(def_id, substs, iter::empty())\n+    }\n+\n+    /// Print `<...>` around what `f` prints.\n+    fn generic_delimiters<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error>;\n+\n+    /// Return `true` if the region should be printed in path generic args\n+    /// even when it's `'_`, such as in e.g. `Foo<'_, '_, '_>`.\n+    fn always_print_region_in_paths(\n+        self: &PrintCx<'_, '_, '_, Self>,\n+        _region: ty::Region<'_>,\n+    ) -> bool {\n+        false\n+    }\n+\n+    // HACK(eddyb) Trying to print a lifetime might not print anything, which\n+    // may need special handling in the caller (of `ty::RegionKind::print`).\n+    // To avoid printing to a temporary string (which isn't even supported),\n+    // the `print_region_outputs_anything` method can instead be used to\n+    // determine this, ahead of time.\n+    //\n+    // NB: this must be kept in sync with the implementation of `print_region`.\n+    fn print_region_outputs_anything(\n+        self: &PrintCx<'_, '_, '_, Self>,\n+        region: ty::Region<'_>,\n+    ) -> bool;\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n+    // (but also some things just print a `DefId` generally so maybe we need this?)\n+    fn guess_def_namespace(self, def_id: DefId) -> Namespace {\n+        match self.def_key(def_id).disambiguated_data.data {\n+            DefPathData::ValueNs(..) |\n+            DefPathData::EnumVariant(..) |\n+            DefPathData::Field(..) |\n+            DefPathData::AnonConst |\n+            DefPathData::ConstParam(..) |\n+            DefPathData::ClosureExpr |\n+            DefPathData::StructCtor => Namespace::ValueNS,\n+\n+            DefPathData::MacroDef(..) => Namespace::MacroNS,\n+\n+            _ => Namespace::TypeNS,\n+        }\n+    }\n+\n+    /// Returns a string identifying this `DefId. This string is\n+    /// suitable for user output.\n+    pub fn def_path_str(self, def_id: DefId) -> String {\n+        let ns = self.guess_def_namespace(def_id);\n+        debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n+        let mut s = String::new();\n+        let _ = PrintCx::with(self, FmtPrinter::new(&mut s, ns), |cx| {\n+            cx.print_def_path(def_id, None, iter::empty())\n+        });\n+        s\n+    }\n+}\n+\n+pub struct FmtPrinter<F: fmt::Write> {\n+    fmt: F,\n+    empty: bool,\n+    in_value: bool,\n+    pub region_highlight_mode: RegionHighlightMode,\n+}\n+\n+impl<F: fmt::Write> FmtPrinter<F> {\n+    pub fn new(fmt: F, ns: Namespace) -> Self {\n+        FmtPrinter {\n+            fmt,\n+            empty: true,\n+            in_value: ns == Namespace::ValueNS,\n+            region_highlight_mode: RegionHighlightMode::default(),\n+        }\n+    }\n+}\n+\n+impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n+    /// If possible, this returns a global path resolving to `def_id` that is visible\n+    /// from at least one local module and returns true. If the crate defining `def_id` is\n+    /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n+    fn try_print_visible_def_path(\n+        mut self,\n+        def_id: DefId,\n+    ) -> Result<(P, bool), P::Error> {\n+        define_scoped_cx!(self);\n+\n+        debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n+\n+        // If `def_id` is a direct or injected extern crate, return the\n+        // path to the crate followed by the path to the item within the crate.\n+        if def_id.index == CRATE_DEF_INDEX {\n+            let cnum = def_id.krate;\n+\n+            if cnum == LOCAL_CRATE {\n+                return Ok((self.path_crate(cnum)?, true));\n+            }\n+\n+            // In local mode, when we encounter a crate other than\n+            // LOCAL_CRATE, execution proceeds in one of two ways:\n+            //\n+            // 1. for a direct dependency, where user added an\n+            //    `extern crate` manually, we put the `extern\n+            //    crate` as the parent. So you wind up with\n+            //    something relative to the current crate.\n+            // 2. for an extern inferred from a path or an indirect crate,\n+            //    where there is no explicit `extern crate`, we just prepend\n+            //    the crate name.\n+            match *self.tcx.extern_crate(def_id) {\n+                Some(ExternCrate {\n+                    src: ExternCrateSource::Extern(def_id),\n+                    direct: true,\n+                    span,\n+                    ..\n+                }) => {\n+                    debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n+                    return Ok((if !span.is_dummy() {\n+                        self.print_def_path(def_id, None, iter::empty())?\n+                    } else {\n+                        self.path_crate(cnum)?\n+                    }, true));\n+                }\n+                None => {\n+                    return Ok((self.path_crate(cnum)?, true));\n+                }\n+                _ => {},\n+            }\n+        }\n+\n+        if def_id.is_local() {\n+            return Ok((self.printer, false));\n+        }\n+\n+        let visible_parent_map = self.tcx.visible_parent_map(LOCAL_CRATE);\n+\n+        let mut cur_def_key = self.tcx.def_key(def_id);\n+        debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n+\n+        // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n+        if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n+            let parent = DefId {\n+                krate: def_id.krate,\n+                index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n+            };\n+\n+            cur_def_key = self.tcx.def_key(parent);\n+        }\n+\n+        let visible_parent = match visible_parent_map.get(&def_id).cloned() {\n+            Some(parent) => parent,\n+            None => return Ok((self.printer, false)),\n+        };\n+        // HACK(eddyb) this uses `nest` to avoid knowing ahead of time whether\n+        // the entire path will succeed or not. To support printers that do not\n+        // implement `PrettyPrinter`, a `Vec` or linked list on the stack would\n+        // need to be built, before starting to print anything.\n+        let mut prefix_success = false;\n+        nest!(|cx| {\n+            let (printer, success) = cx.try_print_visible_def_path(visible_parent)?;\n+            prefix_success = success;\n+            Ok(printer)\n+        });\n+        if !prefix_success {\n+            return Ok((self.printer, false));\n+        };\n+        let actual_parent = self.tcx.parent(def_id);\n+        debug!(\n+            \"try_print_visible_def_path: visible_parent={:?} actual_parent={:?}\",\n+            visible_parent, actual_parent,\n+        );\n+\n+        let data = cur_def_key.disambiguated_data.data;\n+        debug!(\n+            \"try_print_visible_def_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n+            data, visible_parent, actual_parent,\n+        );\n+\n+        let symbol = match data {\n+            // In order to output a path that could actually be imported (valid and visible),\n+            // we need to handle re-exports correctly.\n+            //\n+            // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n+            // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n+            //\n+            // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n+            // private so the \"true\" path to `CommandExt` isn't accessible.\n+            //\n+            // In this case, the `visible_parent_map` will look something like this:\n+            //\n+            // (child) -> (parent)\n+            // `std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n+            // `std::sys::unix::ext::process` -> `std::sys::unix::ext`\n+            // `std::sys::unix::ext` -> `std::os`\n+            //\n+            // This is correct, as the visible parent of `std::sys::unix::ext` is in fact\n+            // `std::os`.\n+            //\n+            // When printing the path to `CommandExt` and looking at the `cur_def_key` that\n+            // corresponds to `std::sys::unix::ext`, we would normally print `ext` and then go\n+            // to the parent - resulting in a mangled path like\n+            // `std::os::ext::process::CommandExt`.\n+            //\n+            // Instead, we must detect that there was a re-export and instead print `unix`\n+            // (which is the name `std::sys::unix::ext` was re-exported as in `std::os`). To\n+            // do this, we compare the parent of `std::sys::unix::ext` (`std::sys::unix`) with\n+            // the visible parent (`std::os`). If these do not match, then we iterate over\n+            // the children of the visible parent (as was done when computing\n+            // `visible_parent_map`), looking for the specific child we currently have and then\n+            // have access to the re-exported name.\n+            DefPathData::Module(actual_name) |\n+            DefPathData::TypeNs(actual_name) if Some(visible_parent) != actual_parent => {\n+                self.tcx.item_children(visible_parent)\n+                    .iter()\n+                    .find(|child| child.def.def_id() == def_id)\n+                    .map(|child| child.ident.as_str())\n+                    .unwrap_or_else(|| actual_name.as_str())\n+            }\n+            _ => {\n+                data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n+                    // Re-exported `extern crate` (#43189).\n+                    if let DefPathData::CrateRoot = data {\n+                        self.tcx.original_crate_name(def_id.krate).as_str()\n+                    } else {\n+                        Symbol::intern(\"<unnamed>\").as_str()\n+                    }\n+                })\n+            },\n+        };\n+        debug!(\"try_print_visible_def_path: symbol={:?}\", symbol);\n+        Ok((self.path_append(|cx| Ok(cx.printer), &symbol)?, true))\n+    }\n+\n+    pub fn pretty_path_qualified(\n+        self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<P::Path, P::Error> {\n+        if trait_ref.is_none() {\n+            // Inherent impls. Try to print `Foo::bar` for an inherent\n+            // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n+            // anything other than a simple path.\n+            match self_ty.sty {\n+                ty::Adt(..) | ty::Foreign(_) |\n+                ty::Bool | ty::Char | ty::Str |\n+                ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n+                    return self_ty.print_display(self);\n+                }\n+\n+                _ => {}\n+            }\n+        }\n+\n+        self.generic_delimiters(|mut cx| {\n+            define_scoped_cx!(cx);\n+\n+            p!(print_display(self_ty));\n+            if let Some(trait_ref) = trait_ref {\n+                p!(write(\" as \"), print_display(trait_ref));\n+            }\n+            Ok(cx.printer)\n+        })\n+    }\n+\n+    pub fn pretty_path_append_impl(\n+        mut self,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, P>,\n+        ) -> Result<P::Path, P::Error>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<P::Path, P::Error> {\n+        self = self.nest(print_prefix)?;\n+\n+        self.generic_delimiters(|mut cx| {\n+            define_scoped_cx!(cx);\n+\n+            p!(write(\"impl \"));\n+            if let Some(trait_ref) = trait_ref {\n+                p!(print_display(trait_ref), write(\" for \"));\n+            }\n+            p!(print_display(self_ty));\n+\n+            Ok(cx.printer)\n+        })\n+    }\n+\n+    pub fn pretty_path_generic_args(\n+        mut self,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, P>,\n+        ) -> Result<P::Path, P::Error>,\n+        params: &[ty::GenericParamDef],\n+        substs: SubstsRef<'tcx>,\n+        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+    ) -> Result<P::Path, P::Error> {\n+        self = self.nest(print_prefix)?;\n+\n+        // Don't print `'_` if there's no printed region.\n+        let print_regions = params.iter().any(|param| {\n+            match substs[param.index as usize].unpack() {\n+                UnpackedKind::Lifetime(r) => {\n+                    self.always_print_region_in_paths(r) ||\n+                    self.print_region_outputs_anything(r)\n+                }\n+                _ => false,\n+            }\n+        });\n+\n+        // Don't print args that are the defaults of their respective parameters.\n+        let num_supplied_defaults = if self.config.is_verbose {\n+            0\n+        } else {\n+            params.iter().rev().take_while(|param| {\n+                match param.kind {\n+                    ty::GenericParamDefKind::Lifetime => false,\n+                    ty::GenericParamDefKind::Type { has_default, .. } => {\n+                        has_default && substs[param.index as usize] == Kind::from(\n+                            self.tcx.type_of(param.def_id).subst(self.tcx, substs)\n+                        )\n+                    }\n+                    ty::GenericParamDefKind::Const => false, // FIXME(const_generics:defaults)\n+                }\n+            }).count()\n+        };\n+\n+        let params = &params[..params.len() - num_supplied_defaults];\n+        let mut args = params.iter().map(|param| {\n+            substs[param.index as usize]\n+        }).filter(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(_) => print_regions,\n+                _ => true,\n+            }\n+        });\n+        let arg0 = args.next();\n+\n+        let mut projections = projections;\n+        let projection0 = projections.next();\n+\n+        if arg0.is_none() && projection0.is_none() {\n+            return Ok(self.printer);\n+        }\n+\n+        self.generic_delimiters(|mut cx| {\n+            define_scoped_cx!(cx);\n+\n+            let mut empty = true;\n+            let mut maybe_comma = |cx: &mut Self| {\n+                if empty {\n+                    empty = false;\n+                    Ok(())\n+                } else {\n+                    write!(cx.printer, \", \")\n+                }\n+            };\n+\n+            for arg in arg0.into_iter().chain(args) {\n+                maybe_comma(&mut cx)?;\n+\n+                if let UnpackedKind::Lifetime(region) = arg.unpack() {\n+                    if !cx.print_region_outputs_anything(region) {\n+                        // This happens when the value of the region\n+                        // parameter is not easily serialized. This may be\n+                        // because the user omitted it in the first place,\n+                        // or because it refers to some block in the code,\n+                        // etc. I'm not sure how best to serialize this.\n+                        p!(write(\"'_\"));\n+\n+                        continue;\n+                    }\n+                }\n+\n+                p!(print_display(arg));\n+            }\n+\n+            for projection in projection0.into_iter().chain(projections) {\n+                maybe_comma(&mut cx)?;\n+\n+                p!(write(\"{}=\", cx.tcx.associated_item(projection.item_def_id).ident),\n+                   print_display(projection.ty));\n+            }\n+\n+            Ok(cx.printer)\n+        })\n+    }\n+}\n+\n+impl<F: fmt::Write> fmt::Write for FmtPrinter<F> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.empty &= s.is_empty();\n+        self.fmt.write_str(s)\n+    }\n+}\n+\n+impl<F: fmt::Write> Printer for FmtPrinter<F> {\n+    type Error = fmt::Error;\n+\n+    type Path = Self;\n+    type Region = Self;\n+    type Type = Self;\n+\n+    fn print_def_path(\n+        mut self: PrintCx<'_, '_, 'tcx, Self>,\n+        def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        // FIXME(eddyb) avoid querying `tcx.generics_of` and `tcx.def_key`\n+        // both here and in `default_print_def_path`.\n+        let generics = substs.map(|_| self.tcx.generics_of(def_id));\n+        if generics.as_ref().and_then(|g| g.parent).is_none() {\n+            let mut visible_path_success = false;\n+            self = self.nest(|cx| {\n+                let (printer, success) = cx.try_print_visible_def_path(def_id)?;\n+                visible_path_success = success;\n+                Ok(printer)\n+            })?;\n+            if visible_path_success {\n+                return if let (Some(generics), Some(substs)) = (generics, substs) {\n+                    let has_own_self = generics.has_self && generics.parent_count == 0;\n+                    let params = &generics.params[has_own_self as usize..];\n+                    self.path_generic_args(|cx| Ok(cx.printer), params, substs, projections)\n+                } else {\n+                    Ok(self.printer)\n+                };\n+            }\n+        }\n+\n+        let key = self.tcx.def_key(def_id);\n+        if let DefPathData::Impl = key.disambiguated_data.data {\n+            // Always use types for non-local impls, where types are always\n+            // available, and filename/line-number is mostly uninteresting.\n+            let use_types =\n+                !def_id.is_local() || {\n+                    // Otherwise, use filename/line-number if forced.\n+                    let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n+                    !force_no_types\n+                };\n+\n+            if !use_types {\n+                // If no type info is available, fall back to\n+                // pretty printing some span information. This should\n+                // only occur very early in the compiler pipeline.\n+                let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n+                let span = self.tcx.def_span(def_id);\n+                return self.path_append(\n+                    |cx| cx.print_def_path(parent_def_id, None, iter::empty()),\n+                    &format!(\"<impl at {:?}>\", span),\n+                );\n+            }\n+        }\n+\n+        self.default_print_def_path(def_id, substs, projections)\n+    }\n+\n+    fn print_region(\n+        self: PrintCx<'_, '_, '_, Self>,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error> {\n+        self.pretty_print_region(region)\n+    }\n+\n+    fn print_type(\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        self.pretty_print_type(ty)\n+    }\n+\n+    fn path_crate(\n+        mut self: PrintCx<'_, '_, '_, Self>,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error> {\n+        if cnum == LOCAL_CRATE {\n+            if self.tcx.sess.rust_2018() {\n+                // We add the `crate::` keyword on Rust 2018, only when desired.\n+                if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n+                    write!(self.printer, \"{}\", keywords::Crate.name())?;\n+                }\n+            }\n+            Ok(self.printer)\n+        } else {\n+            write!(self.printer, \"{}\", self.tcx.crate_name(cnum))?;\n+            Ok(self.printer)\n+        }\n+    }\n+    fn path_qualified(\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.pretty_path_qualified(self_ty, trait_ref)\n+    }\n+\n+    fn path_append_impl<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, Self>,\n+        ) -> Result<Self::Path, Self::Error>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.pretty_path_append_impl(|cx| {\n+            let mut printer = print_prefix(cx)?;\n+\n+            // HACK(eddyb) this accounts for `generic_delimiters`\n+            // printing `::<` instead of `<` if `in_value` is set.\n+            if !printer.empty && !printer.in_value {\n+                write!(printer, \"::\")?;\n+            }\n+\n+            Ok(printer)\n+        }, self_ty, trait_ref)\n+    }\n+    fn path_append<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, Self>,\n+        ) -> Result<Self::Path, Self::Error>,\n+        text: &str,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let mut printer = print_prefix(self)?;\n+\n+        // FIXME(eddyb) `text` should never be empty, but it\n+        // currently is for `extern { ... }` \"foreign modules\".\n+        if !text.is_empty() {\n+            if !printer.empty {\n+                write!(printer, \"::\")?;\n+            }\n+            write!(printer, \"{}\", text)?;\n+        }\n+\n+        Ok(printer)\n+    }\n+    fn path_generic_args<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, Self>,\n+        ) -> Result<Self::Path, Self::Error>,\n+        params: &[ty::GenericParamDef],\n+        substs: SubstsRef<'tcx>,\n+        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.pretty_path_generic_args(print_prefix, params, substs, projections)\n+    }\n+}\n+\n+impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n+    fn nest<'a, 'gcx, 'tcx, E>(\n+        mut self: PrintCx<'a, 'gcx, 'tcx, Self>,\n+        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n+    ) -> Result<PrintCx<'a, 'gcx, 'tcx, Self>, E> {\n+        let was_empty = std::mem::replace(&mut self.printer.empty, true);\n+        let mut printer = f(PrintCx {\n+            tcx: self.tcx,\n+            printer: self.printer,\n+            config: self.config,\n+        })?;\n+        printer.empty &= was_empty;\n+        Ok(PrintCx {\n+            tcx: self.tcx,\n+            printer,\n+            config: self.config,\n+        })\n+    }\n+\n+    fn print_value_path(\n+        mut self: PrintCx<'_, '_, 'tcx, Self>,\n+        def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let was_in_value = std::mem::replace(&mut self.printer.in_value, true);\n+        let mut printer = self.print_def_path(def_id, substs, iter::empty())?;\n+        printer.in_value = was_in_value;\n+\n+        Ok(printer)\n+    }\n+\n+    fn generic_delimiters<'gcx, 'tcx>(\n+        mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error> {\n+        if !self.printer.empty && self.printer.in_value {\n+            write!(self.printer, \"::<\")?;\n+        } else {\n+            write!(self.printer, \"<\")?;\n+        }\n+\n+        let was_in_value = std::mem::replace(&mut self.printer.in_value, false);\n+        let mut printer = f(self)?;\n+        printer.in_value = was_in_value;\n+\n+        write!(printer, \">\")?;\n+        Ok(printer)\n+    }\n+\n+    fn always_print_region_in_paths(\n+        self: &PrintCx<'_, '_, '_, Self>,\n+        region: ty::Region<'_>,\n+    ) -> bool {\n+        *region != ty::ReErased\n+    }\n+\n+    fn print_region_outputs_anything(\n+        self: &PrintCx<'_, '_, '_, Self>,\n+        region: ty::Region<'_>,\n+    ) -> bool {\n+        let highlight = self.printer.region_highlight_mode;\n+        if highlight.region_highlighted(region).is_some() {\n+            return true;\n+        }\n+\n+        if self.config.is_verbose {\n+            return true;\n+        }\n+\n+        match *region {\n+            ty::ReEarlyBound(ref data) => {\n+                data.name != \"\" && data.name != \"'_\"\n+            }\n+\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n+                if let ty::BrNamed(_, name) = br {\n+                    if name != \"\" && name != \"'_\" {\n+                        return true;\n+                    }\n+                }\n+\n+                if let Some((region, _)) = highlight.highlight_bound_region {\n+                    if br == region {\n+                        return true;\n+                    }\n+                }\n+\n+                false\n+            }\n+\n+            ty::ReScope(_) |\n+            ty::ReVar(_) if self.config.identify_regions => true,\n+\n+            ty::ReVar(_) |\n+            ty::ReScope(_) |\n+            ty::ReErased => false,\n+\n+            ty::ReStatic |\n+            ty::ReEmpty |\n+            ty::ReClosureBound(_) => true,\n+        }\n+    }\n+}\n+\n+// HACK(eddyb) limited to `FmtPrinter` because of `region_highlight_mode`.\n+impl<F: fmt::Write> FmtPrinter<F> {\n+    pub fn pretty_print_region(\n+        mut self: PrintCx<'_, '_, '_, Self>,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self, fmt::Error> {\n+        define_scoped_cx!(self);\n+\n+        // Watch out for region highlights.\n+        let highlight = self.printer.region_highlight_mode;\n+        if let Some(n) = highlight.region_highlighted(region) {\n+            p!(write(\"'{}\", n));\n+            return Ok(self.printer);\n+        }\n+\n+        if self.config.is_verbose {\n+            return region.print_debug(self);\n+        }\n+\n+        // These printouts are concise.  They do not contain all the information\n+        // the user might want to diagnose an error, but there is basically no way\n+        // to fit that into a short string.  Hence the recommendation to use\n+        // `explain_region()` or `note_and_explain_region()`.\n+        match *region {\n+            ty::ReEarlyBound(ref data) => {\n+                if data.name != \"'_\" {\n+                    p!(write(\"{}\", data.name));\n+                }\n+            }\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n+                if let ty::BrNamed(_, name) = br {\n+                    if name != \"\" && name != \"'_\" {\n+                        p!(write(\"{}\", name));\n+                        return Ok(self.printer);\n+                    }\n+                }\n+\n+                if let Some((region, counter)) = highlight.highlight_bound_region {\n+                    if br == region {\n+                        p!(write(\"'{}\", counter));\n+                    }\n+                }\n+            }\n+            ty::ReScope(scope) if self.config.identify_regions => {\n+                match scope.data {\n+                    region::ScopeData::Node =>\n+                        p!(write(\"'{}s\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::CallSite =>\n+                        p!(write(\"'{}cs\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::Arguments =>\n+                        p!(write(\"'{}as\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::Destruction =>\n+                        p!(write(\"'{}ds\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::Remainder(first_statement_index) => p!(write(\n+                        \"'{}_{}rs\",\n+                        scope.item_local_id().as_usize(),\n+                        first_statement_index.index()\n+                    )),\n+                }\n+            }\n+            ty::ReVar(region_vid) if self.config.identify_regions => {\n+                p!(write(\"{:?}\", region_vid));\n+            }\n+            ty::ReVar(_) => {}\n+            ty::ReScope(_) |\n+            ty::ReErased => {}\n+            ty::ReStatic => p!(write(\"'static\")),\n+            ty::ReEmpty => p!(write(\"'<empty>\")),\n+\n+            // The user should never encounter these in unsubstituted form.\n+            ty::ReClosureBound(vid) => p!(write(\"{:?}\", vid)),\n+        }\n+\n+        Ok(self.printer)\n+    }\n+}\n+\n+impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n+    pub fn pretty_print_type(\n+        mut self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<P::Type, P::Error> {\n+        define_scoped_cx!(self);\n+\n+        match ty.sty {\n+            ty::Bool => p!(write(\"bool\")),\n+            ty::Char => p!(write(\"char\")),\n+            ty::Int(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::Uint(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::Float(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::RawPtr(ref tm) => {\n+                p!(write(\"*{} \", match tm.mutbl {\n+                    hir::MutMutable => \"mut\",\n+                    hir::MutImmutable => \"const\",\n+                }));\n+                p!(print(tm.ty))\n+            }\n+            ty::Ref(r, ty, mutbl) => {\n+                p!(write(\"&\"));\n+                if self.print_region_outputs_anything(r) {\n+                    p!(print_display(r), write(\" \"));\n+                }\n+                p!(print(ty::TypeAndMut { ty, mutbl }))\n+            }\n+            ty::Never => p!(write(\"!\")),\n+            ty::Tuple(ref tys) => {\n+                p!(write(\"(\"));\n+                let mut tys = tys.iter();\n+                if let Some(&ty) = tys.next() {\n+                    p!(print(ty), write(\",\"));\n+                    if let Some(&ty) = tys.next() {\n+                        p!(write(\" \"), print(ty));\n+                        for &ty in tys {\n+                            p!(write(\", \"), print(ty));\n+                        }\n+                    }\n+                }\n+                p!(write(\")\"))\n+            }\n+            ty::FnDef(def_id, substs) => {\n+                let sig = self.tcx.fn_sig(def_id).subst(self.tcx, substs);\n+                p!(print(sig), write(\" {{\"));\n+                nest!(|cx| cx.print_value_path(def_id, Some(substs)));\n+                p!(write(\"}}\"))\n+            }\n+            ty::FnPtr(ref bare_fn) => {\n+                p!(print(bare_fn))\n+            }\n+            ty::Infer(infer_ty) => p!(write(\"{}\", infer_ty)),\n+            ty::Error => p!(write(\"[type error]\")),\n+            ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n+            ty::Bound(debruijn, bound_ty) => {\n+                match bound_ty.kind {\n+                    ty::BoundTyKind::Anon => {\n+                        if debruijn == ty::INNERMOST {\n+                            p!(write(\"^{}\", bound_ty.var.index()))\n+                        } else {\n+                            p!(write(\"^{}_{}\", debruijn.index(), bound_ty.var.index()))\n+                        }\n+                    }\n+\n+                    ty::BoundTyKind::Param(p) => p!(write(\"{}\", p)),\n+                }\n+            }\n+            ty::Adt(def, substs) => {\n+                nest!(|cx| cx.print_def_path(def.did, Some(substs), iter::empty()));\n+            }\n+            ty::Dynamic(data, r) => {\n+                let print_r = self.print_region_outputs_anything(r);\n+                if print_r {\n+                    p!(write(\"(\"));\n+                }\n+                p!(write(\"dyn \"), print(data));\n+                if print_r {\n+                    p!(write(\" + \"), print_display(r), write(\")\"));\n+                }\n+            }\n+            ty::Foreign(def_id) => {\n+                nest!(|cx| cx.print_def_path(def_id, None, iter::empty()));\n+            }\n+            ty::Projection(ref data) => p!(print(data)),\n+            ty::UnnormalizedProjection(ref data) => {\n+                p!(write(\"Unnormalized(\"), print(data), write(\")\"))\n+            }\n+            ty::Placeholder(placeholder) => {\n+                p!(write(\"Placeholder({:?})\", placeholder))\n+            }\n+            ty::Opaque(def_id, substs) => {\n+                if self.config.is_verbose {\n+                    p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n+                    return Ok(self.printer);\n+                }\n+\n+                let def_key = self.tcx.def_key(def_id);\n+                if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n+                    p!(write(\"{}\", name));\n+                    let mut substs = substs.iter();\n+                    // FIXME(eddyb) print this with `print_def_path`.\n+                    if let Some(first) = substs.next() {\n+                        p!(write(\"::<\"));\n+                        p!(print_display(first));\n+                        for subst in substs {\n+                            p!(write(\", \"), print_display(subst));\n+                        }\n+                        p!(write(\">\"));\n+                    }\n+                    return Ok(self.printer);\n+                }\n+                // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                // by looking up the projections associated with the def_id.\n+                let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n+\n+                let mut first = true;\n+                let mut is_sized = false;\n+                p!(write(\"impl\"));\n+                for predicate in bounds.predicates {\n+                    if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                        // Don't print +Sized, but rather +?Sized if absent.\n+                        if Some(trait_ref.def_id()) == self.tcx.lang_items().sized_trait() {\n+                            is_sized = true;\n+                            continue;\n+                        }\n+\n+                        p!(\n+                                write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                print(trait_ref));\n+                        first = false;\n+                    }\n+                }\n+                if !is_sized {\n+                    p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n+                } else if first {\n+                    p!(write(\" Sized\"));\n+                }\n+            }\n+            ty::Str => p!(write(\"str\")),\n+            ty::Generator(did, substs, movability) => {\n+                let upvar_tys = substs.upvar_tys(did, self.tcx);\n+                let witness = substs.witness(did, self.tcx);\n+                if movability == hir::GeneratorMovability::Movable {\n+                    p!(write(\"[generator\"));\n+                } else {\n+                    p!(write(\"[static generator\"));\n+                }\n+\n+                // FIXME(eddyb) should use `def_span`.\n+                if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n+                    p!(write(\"@{:?}\", self.tcx.hir().span_by_hir_id(hir_id)));\n+                    let mut sep = \" \";\n+                    for (freevar, upvar_ty) in self.tcx.freevars(did)\n+                        .as_ref()\n+                        .map_or(&[][..], |fv| &fv[..])\n+                        .iter()\n+                        .zip(upvar_tys)\n+                    {\n+                        p!(\n+                            write(\"{}{}:\",\n+                                    sep,\n+                                    self.tcx.hir().name(freevar.var_id())),\n+                            print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                } else {\n+                    // cross-crate closure types should only be\n+                    // visible in codegen bug reports, I imagine.\n+                    p!(write(\"@{:?}\", did));\n+                    let mut sep = \" \";\n+                    for (index, upvar_ty) in upvar_tys.enumerate() {\n+                        p!(\n+                                write(\"{}{}:\", sep, index),\n+                                print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                }\n+\n+                p!(write(\" \"), print(witness), write(\"]\"))\n+            },\n+            ty::GeneratorWitness(types) => {\n+                nest!(|cx| cx.pretty_in_binder(&types))\n+            }\n+            ty::Closure(did, substs) => {\n+                let upvar_tys = substs.upvar_tys(did, self.tcx);\n+                p!(write(\"[closure\"));\n+\n+                // FIXME(eddyb) should use `def_span`.\n+                if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n+                    if self.tcx.sess.opts.debugging_opts.span_free_formats {\n+                        p!(write(\"@{:?}\", hir_id));\n+                    } else {\n+                        p!(write(\"@{:?}\", self.tcx.hir().span_by_hir_id(hir_id)));\n+                    }\n+                    let mut sep = \" \";\n+                    for (freevar, upvar_ty) in self.tcx.freevars(did)\n+                        .as_ref()\n+                        .map_or(&[][..], |fv| &fv[..])\n+                        .iter()\n+                        .zip(upvar_tys)\n+                    {\n+                        p!(\n+                            write(\"{}{}:\",\n+                                    sep,\n+                                    self.tcx.hir().name(freevar.var_id())),\n+                            print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                } else {\n+                    // cross-crate closure types should only be\n+                    // visible in codegen bug reports, I imagine.\n+                    p!(write(\"@{:?}\", did));\n+                    let mut sep = \" \";\n+                    for (index, upvar_ty) in upvar_tys.enumerate() {\n+                        p!(\n+                                write(\"{}{}:\", sep, index),\n+                                print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                }\n+\n+                if self.config.is_verbose {\n+                    p!(write(\n+                        \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n+                        substs.closure_kind_ty(did, self.tcx),\n+                        substs.closure_sig_ty(did, self.tcx)\n+                    ));\n+                }\n+\n+                p!(write(\"]\"))\n+            },\n+            ty::Array(ty, sz) => {\n+                p!(write(\"[\"), print(ty), write(\"; \"));\n+                match sz {\n+                    ty::LazyConst::Unevaluated(_def_id, _substs) => {\n+                        p!(write(\"_\"));\n+                    }\n+                    ty::LazyConst::Evaluated(c) => {\n+                        match c.val {\n+                            ConstValue::Infer(..) => p!(write(\"_\")),\n+                            ConstValue::Param(ParamConst { name, .. }) =>\n+                                p!(write(\"{}\", name)),\n+                            _ => p!(write(\"{}\", c.unwrap_usize(self.tcx))),\n+                        }\n+                    }\n+                }\n+                p!(write(\"]\"))\n+            }\n+            ty::Slice(ty) => {\n+                p!(write(\"[\"), print(ty), write(\"]\"))\n+            }\n+        }\n+\n+        Ok(self.printer)\n+    }\n+\n+    pub fn pretty_fn_sig(\n+        mut self,\n+        inputs: &[Ty<'tcx>],\n+        c_variadic: bool,\n+        output: Ty<'tcx>,\n+    ) -> Result<P, fmt::Error> {\n+        define_scoped_cx!(self);\n+\n+        p!(write(\"(\"));\n+        let mut inputs = inputs.iter();\n+        if let Some(&ty) = inputs.next() {\n+            p!(print_display(ty));\n+            for &ty in inputs {\n+                p!(write(\", \"), print_display(ty));\n+            }\n+            if c_variadic {\n+                p!(write(\", ...\"));\n+            }\n+        }\n+        p!(write(\")\"));\n+        if !output.is_unit() {\n+            p!(write(\" -> \"), print_display(output));\n+        }\n+\n+        Ok(self.printer)\n+    }\n+\n+    pub fn pretty_in_binder<T>(mut self, value: &ty::Binder<T>) -> Result<P, fmt::Error>\n+        where T: Print<'tcx, P, Output = P, Error = fmt::Error> + TypeFoldable<'tcx>\n+    {\n+        fn name_by_region_index(index: usize) -> InternedString {\n+            match index {\n+                0 => Symbol::intern(\"'r\"),\n+                1 => Symbol::intern(\"'s\"),\n+                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n+            }.as_interned_str()\n+        }\n+\n+        // Replace any anonymous late-bound regions with named\n+        // variants, using gensym'd identifiers, so that we can\n+        // clearly differentiate between named and unnamed regions in\n+        // the output. We'll probably want to tweak this over time to\n+        // decide just how much information to give.\n+        if self.config.binder_depth == 0 {\n+            self.prepare_late_bound_region_info(value);\n+        }\n+\n+        let mut empty = true;\n+        let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n+            write!(cx.printer, \"{}\", if empty {\n+                empty = false;\n+                start\n+            } else {\n+                cont\n+            })\n+        };\n+\n+        // NOTE(eddyb) this must be below `start_or_continue`'s definition\n+        // as that also has a `define_scoped_cx` and that kind of shadowing\n+        // is disallowed (name resolution thinks `scoped_cx!` is ambiguous).\n+        define_scoped_cx!(self);\n+\n+        let old_region_index = self.config.region_index;\n+        let mut region_index = old_region_index;\n+        let new_value = self.tcx.replace_late_bound_regions(value, |br| {\n+            let _ = start_or_continue(&mut self, \"for<\", \", \");\n+            let br = match br {\n+                ty::BrNamed(_, name) => {\n+                    let _ = write!(self.printer, \"{}\", name);\n+                    br\n+                }\n+                ty::BrAnon(_) |\n+                ty::BrFresh(_) |\n+                ty::BrEnv => {\n+                    let name = loop {\n+                        let name = name_by_region_index(region_index);\n+                        region_index += 1;\n+                        if !self.is_name_used(&name) {\n+                            break name;\n+                        }\n+                    };\n+                    let _ = write!(self.printer, \"{}\", name);\n+                    ty::BrNamed(DefId::local(CRATE_DEF_INDEX), name)\n+                }\n+            };\n+            self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n+        }).0;\n+        start_or_continue(&mut self, \"\", \"> \")?;\n+\n+        // Push current state to gcx, and restore after writing new_value.\n+        self.config.binder_depth += 1;\n+        self.config.region_index = region_index;\n+        let result = new_value.print_display(PrintCx {\n+            tcx: self.tcx,\n+            printer: self.printer,\n+            config: self.config,\n+        });\n+        self.config.region_index = old_region_index;\n+        self.config.binder_depth -= 1;\n+        result\n+    }\n+\n+    fn is_name_used(&self, name: &InternedString) -> bool {\n+        match self.config.used_region_names {\n+            Some(ref names) => names.contains(name),\n+            None => false,\n+        }\n+    }\n+}"}, {"sha": "059a3614704bbbdbac6175f3c2e42686385f1001", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 379, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/55871aad9a9c621e245c2b238f04f9fab55da759/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55871aad9a9c621e245c2b238f04f9fab55da759/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=55871aad9a9c621e245c2b238f04f9fab55da759", "patch": "@@ -1,18 +1,15 @@\n+use crate::hir;\n use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n-use crate::ty::subst::{Kind, Subst, SubstsRef, UnpackedKind};\n-use crate::ty::{self, ParamConst, Ty, TypeFoldable};\n+use crate::ty::subst::{Kind, SubstsRef, UnpackedKind};\n+use crate::ty::{self, ParamConst, Ty};\n use crate::ty::print::{FmtPrinter, PrettyPrinter, PrintCx, Print, Printer};\n use crate::mir::interpret::ConstValue;\n \n use std::fmt::{self, Write as _};\n use std::iter;\n-use std::usize;\n \n use rustc_target::spec::abi::Abi;\n-use syntax::ast::CRATE_NODE_ID;\n-use syntax::symbol::{Symbol, InternedString};\n-use crate::hir;\n \n macro_rules! gen_display_debug_body {\n     ( $with:path ) => {\n@@ -145,117 +142,6 @@ macro_rules! define_scoped_cx {\n     };\n }\n \n-impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n-    fn fn_sig(\n-        mut self,\n-        inputs: &[Ty<'tcx>],\n-        c_variadic: bool,\n-        output: Ty<'tcx>,\n-    ) -> Result<P, fmt::Error> {\n-        define_scoped_cx!(self);\n-\n-        p!(write(\"(\"));\n-        let mut inputs = inputs.iter();\n-        if let Some(&ty) = inputs.next() {\n-            p!(print_display(ty));\n-            for &ty in inputs {\n-                p!(write(\", \"), print_display(ty));\n-            }\n-            if c_variadic {\n-                p!(write(\", ...\"));\n-            }\n-        }\n-        p!(write(\")\"));\n-        if !output.is_unit() {\n-            p!(write(\" -> \"), print_display(output));\n-        }\n-\n-        Ok(self.printer)\n-    }\n-\n-    fn in_binder<T>(mut self, value: &ty::Binder<T>) -> Result<P, fmt::Error>\n-        where T: Print<'tcx, P, Output = P, Error = fmt::Error> + TypeFoldable<'tcx>\n-    {\n-        fn name_by_region_index(index: usize) -> InternedString {\n-            match index {\n-                0 => Symbol::intern(\"'r\"),\n-                1 => Symbol::intern(\"'s\"),\n-                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n-            }.as_interned_str()\n-        }\n-\n-        // Replace any anonymous late-bound regions with named\n-        // variants, using gensym'd identifiers, so that we can\n-        // clearly differentiate between named and unnamed regions in\n-        // the output. We'll probably want to tweak this over time to\n-        // decide just how much information to give.\n-        if self.config.binder_depth == 0 {\n-            self.prepare_late_bound_region_info(value);\n-        }\n-\n-        let mut empty = true;\n-        let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n-            write!(cx.printer, \"{}\", if empty {\n-                empty = false;\n-                start\n-            } else {\n-                cont\n-            })\n-        };\n-\n-        // NOTE(eddyb) this must be below `start_or_continue`'s definition\n-        // as that also has a `define_scoped_cx` and that kind of shadowing\n-        // is disallowed (name resolution thinks `scoped_cx!` is ambiguous).\n-        define_scoped_cx!(self);\n-\n-        let old_region_index = self.config.region_index;\n-        let mut region_index = old_region_index;\n-        let new_value = self.tcx.replace_late_bound_regions(value, |br| {\n-            let _ = start_or_continue(&mut self, \"for<\", \", \");\n-            let br = match br {\n-                ty::BrNamed(_, name) => {\n-                    let _ = write!(self.printer, \"{}\", name);\n-                    br\n-                }\n-                ty::BrAnon(_) |\n-                ty::BrFresh(_) |\n-                ty::BrEnv => {\n-                    let name = loop {\n-                        let name = name_by_region_index(region_index);\n-                        region_index += 1;\n-                        if !self.is_name_used(&name) {\n-                            break name;\n-                        }\n-                    };\n-                    let _ = write!(self.printer, \"{}\", name);\n-                    ty::BrNamed(self.tcx.hir().local_def_id(CRATE_NODE_ID), name)\n-                }\n-            };\n-            self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n-        }).0;\n-        start_or_continue(&mut self, \"\", \"> \")?;\n-\n-        // Push current state to gcx, and restore after writing new_value.\n-        self.config.binder_depth += 1;\n-        self.config.region_index = region_index;\n-        let result = new_value.print_display(PrintCx {\n-            tcx: self.tcx,\n-            printer: self.printer,\n-            config: self.config,\n-        });\n-        self.config.region_index = old_region_index;\n-        self.config.binder_depth -= 1;\n-        result\n-    }\n-\n-    fn is_name_used(&self, name: &InternedString) -> bool {\n-        match self.config.used_region_names {\n-            Some(ref names) => names.contains(name),\n-            None => false,\n-        }\n-    }\n-}\n-\n pub fn parameterized<F: fmt::Write>(\n     f: &mut F,\n     did: DefId,\n@@ -285,7 +171,7 @@ define_print! {\n                         let mut projections = self.projection_bounds();\n                         if let (Some(proj), None) = (projections.next(), projections.next()) {\n                             nest!(|cx| cx.print_def_path(principal.def_id, None, iter::empty()));\n-                            nest!(|cx| cx.fn_sig(args, false, proj.ty));\n+                            nest!(|cx| cx.pretty_fn_sig(args, false, proj.ty));\n                             resugared_principal = true;\n                         }\n                     }\n@@ -535,7 +421,7 @@ define_print! {\n             }\n \n             p!(write(\"fn\"));\n-            nest!(|cx| cx.fn_sig(self.inputs(), self.c_variadic, self.output()));\n+            nest!(|cx| cx.pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n         }\n         debug {\n             p!(write(\"({:?}; c_variadic: {})->{:?}\",\n@@ -624,7 +510,7 @@ impl fmt::Debug for ty::FloatVarValue {\n           for<'a> <T as ty::Lift<'a>>::Lifted: fmt::Display + TypeFoldable<'a>\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(|cx| cx.in_binder(cx.tcx.lift(self)\n+        PrintCx::with_tls_tcx(|cx| cx.pretty_in_binder(cx.tcx.lift(self)\n             .expect(\"could not lift for printing\")))\n     }\n }*/\n@@ -642,7 +528,7 @@ define_print_multi! {\n     ]\n     (self, cx) {\n         display {\n-            nest!(|cx| cx.in_binder(self))\n+            nest!(|cx| cx.pretty_in_binder(self))\n         }\n     }\n }\n@@ -658,264 +544,6 @@ define_print! {\n     }\n }\n \n-// FIXME(eddyb) move this to `ty::print`.\n-impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n-    pub fn pretty_print_type(\n-        mut self,\n-        ty: Ty<'tcx>,\n-    ) -> Result<P::Type, P::Error> {\n-        define_scoped_cx!(self);\n-\n-        match ty.sty {\n-            ty::Bool => p!(write(\"bool\")),\n-            ty::Char => p!(write(\"char\")),\n-            ty::Int(t) => p!(write(\"{}\", t.ty_to_string())),\n-            ty::Uint(t) => p!(write(\"{}\", t.ty_to_string())),\n-            ty::Float(t) => p!(write(\"{}\", t.ty_to_string())),\n-            ty::RawPtr(ref tm) => {\n-                p!(write(\"*{} \", match tm.mutbl {\n-                    hir::MutMutable => \"mut\",\n-                    hir::MutImmutable => \"const\",\n-                }));\n-                p!(print(tm.ty))\n-            }\n-            ty::Ref(r, ty, mutbl) => {\n-                p!(write(\"&\"));\n-                if self.print_region_outputs_anything(r) {\n-                    p!(print_display(r), write(\" \"));\n-                }\n-                p!(print(ty::TypeAndMut { ty, mutbl }))\n-            }\n-            ty::Never => p!(write(\"!\")),\n-            ty::Tuple(ref tys) => {\n-                p!(write(\"(\"));\n-                let mut tys = tys.iter();\n-                if let Some(&ty) = tys.next() {\n-                    p!(print(ty), write(\",\"));\n-                    if let Some(&ty) = tys.next() {\n-                        p!(write(\" \"), print(ty));\n-                        for &ty in tys {\n-                            p!(write(\", \"), print(ty));\n-                        }\n-                    }\n-                }\n-                p!(write(\")\"))\n-            }\n-            ty::FnDef(def_id, substs) => {\n-                let sig = self.tcx.fn_sig(def_id).subst(self.tcx, substs);\n-                p!(print(sig), write(\" {{\"));\n-                nest!(|cx| cx.print_value_path(def_id, Some(substs)));\n-                p!(write(\"}}\"))\n-            }\n-            ty::FnPtr(ref bare_fn) => {\n-                p!(print(bare_fn))\n-            }\n-            ty::Infer(infer_ty) => p!(write(\"{}\", infer_ty)),\n-            ty::Error => p!(write(\"[type error]\")),\n-            ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n-            ty::Bound(debruijn, bound_ty) => {\n-                match bound_ty.kind {\n-                    ty::BoundTyKind::Anon => {\n-                        if debruijn == ty::INNERMOST {\n-                            p!(write(\"^{}\", bound_ty.var.index()))\n-                        } else {\n-                            p!(write(\"^{}_{}\", debruijn.index(), bound_ty.var.index()))\n-                        }\n-                    }\n-\n-                    ty::BoundTyKind::Param(p) => p!(write(\"{}\", p)),\n-                }\n-            }\n-            ty::Adt(def, substs) => {\n-                nest!(|cx| cx.print_def_path(def.did, Some(substs), iter::empty()));\n-            }\n-            ty::Dynamic(data, r) => {\n-                let print_r = self.print_region_outputs_anything(r);\n-                if print_r {\n-                    p!(write(\"(\"));\n-                }\n-                p!(write(\"dyn \"), print(data));\n-                if print_r {\n-                    p!(write(\" + \"), print_display(r), write(\")\"));\n-                }\n-            }\n-            ty::Foreign(def_id) => {\n-                nest!(|cx| cx.print_def_path(def_id, None, iter::empty()));\n-            }\n-            ty::Projection(ref data) => p!(print(data)),\n-            ty::UnnormalizedProjection(ref data) => {\n-                p!(write(\"Unnormalized(\"), print(data), write(\")\"))\n-            }\n-            ty::Placeholder(placeholder) => {\n-                p!(write(\"Placeholder({:?})\", placeholder))\n-            }\n-            ty::Opaque(def_id, substs) => {\n-                if self.config.is_verbose {\n-                    p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n-                    return Ok(self.printer);\n-                }\n-\n-                let def_key = self.tcx.def_key(def_id);\n-                if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                    p!(write(\"{}\", name));\n-                    let mut substs = substs.iter();\n-                    // FIXME(eddyb) print this with `print_def_path`.\n-                    if let Some(first) = substs.next() {\n-                        p!(write(\"::<\"));\n-                        p!(print_display(first));\n-                        for subst in substs {\n-                            p!(write(\", \"), print_display(subst));\n-                        }\n-                        p!(write(\">\"));\n-                    }\n-                    return Ok(self.printer);\n-                }\n-                // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                // by looking up the projections associated with the def_id.\n-                let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n-\n-                let mut first = true;\n-                let mut is_sized = false;\n-                p!(write(\"impl\"));\n-                for predicate in bounds.predicates {\n-                    if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n-                        // Don't print +Sized, but rather +?Sized if absent.\n-                        if Some(trait_ref.def_id()) == self.tcx.lang_items().sized_trait() {\n-                            is_sized = true;\n-                            continue;\n-                        }\n-\n-                        p!(\n-                                write(\"{}\", if first { \" \" } else { \"+\" }),\n-                                print(trait_ref));\n-                        first = false;\n-                    }\n-                }\n-                if !is_sized {\n-                    p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n-                } else if first {\n-                    p!(write(\" Sized\"));\n-                }\n-            }\n-            ty::Str => p!(write(\"str\")),\n-            ty::Generator(did, substs, movability) => {\n-                let upvar_tys = substs.upvar_tys(did, self.tcx);\n-                let witness = substs.witness(did, self.tcx);\n-                if movability == hir::GeneratorMovability::Movable {\n-                    p!(write(\"[generator\"));\n-                } else {\n-                    p!(write(\"[static generator\"));\n-                }\n-\n-                // FIXME(eddyb) should use `def_span`.\n-                if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n-                    p!(write(\"@{:?}\", self.tcx.hir().span_by_hir_id(hir_id)));\n-                    let mut sep = \" \";\n-                    for (freevar, upvar_ty) in self.tcx.freevars(did)\n-                        .as_ref()\n-                        .map_or(&[][..], |fv| &fv[..])\n-                        .iter()\n-                        .zip(upvar_tys)\n-                    {\n-                        p!(\n-                            write(\"{}{}:\",\n-                                    sep,\n-                                    self.tcx.hir().name(freevar.var_id())),\n-                            print(upvar_ty));\n-                        sep = \", \";\n-                    }\n-                } else {\n-                    // cross-crate closure types should only be\n-                    // visible in codegen bug reports, I imagine.\n-                    p!(write(\"@{:?}\", did));\n-                    let mut sep = \" \";\n-                    for (index, upvar_ty) in upvar_tys.enumerate() {\n-                        p!(\n-                                write(\"{}{}:\", sep, index),\n-                                print(upvar_ty));\n-                        sep = \", \";\n-                    }\n-                }\n-\n-                p!(write(\" \"), print(witness), write(\"]\"))\n-            },\n-            ty::GeneratorWitness(types) => {\n-                nest!(|cx| cx.in_binder(&types))\n-            }\n-            ty::Closure(did, substs) => {\n-                let upvar_tys = substs.upvar_tys(did, self.tcx);\n-                p!(write(\"[closure\"));\n-\n-                // FIXME(eddyb) should use `def_span`.\n-                if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n-                    if self.tcx.sess.opts.debugging_opts.span_free_formats {\n-                        p!(write(\"@{:?}\", hir_id));\n-                    } else {\n-                        p!(write(\"@{:?}\", self.tcx.hir().span_by_hir_id(hir_id)));\n-                    }\n-                    let mut sep = \" \";\n-                    for (freevar, upvar_ty) in self.tcx.freevars(did)\n-                        .as_ref()\n-                        .map_or(&[][..], |fv| &fv[..])\n-                        .iter()\n-                        .zip(upvar_tys)\n-                    {\n-                        p!(\n-                            write(\"{}{}:\",\n-                                    sep,\n-                                    self.tcx.hir().name(freevar.var_id())),\n-                            print(upvar_ty));\n-                        sep = \", \";\n-                    }\n-                } else {\n-                    // cross-crate closure types should only be\n-                    // visible in codegen bug reports, I imagine.\n-                    p!(write(\"@{:?}\", did));\n-                    let mut sep = \" \";\n-                    for (index, upvar_ty) in upvar_tys.enumerate() {\n-                        p!(\n-                                write(\"{}{}:\", sep, index),\n-                                print(upvar_ty));\n-                        sep = \", \";\n-                    }\n-                }\n-\n-                if self.config.is_verbose {\n-                    p!(write(\n-                        \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n-                        substs.closure_kind_ty(did, self.tcx),\n-                        substs.closure_sig_ty(did, self.tcx)\n-                    ));\n-                }\n-\n-                p!(write(\"]\"))\n-            },\n-            ty::Array(ty, sz) => {\n-                p!(write(\"[\"), print(ty), write(\"; \"));\n-                match sz {\n-                    ty::LazyConst::Unevaluated(_def_id, _substs) => {\n-                        p!(write(\"_\"));\n-                    }\n-                    ty::LazyConst::Evaluated(c) => {\n-                        match c.val {\n-                            ConstValue::Infer(..) => p!(write(\"_\")),\n-                            ConstValue::Param(ParamConst { name, .. }) =>\n-                                p!(write(\"{}\", name)),\n-                            _ => p!(write(\"{}\", c.unwrap_usize(self.tcx))),\n-                        }\n-                    }\n-                }\n-                p!(write(\"]\"))\n-            }\n-            ty::Slice(ty) => {\n-                p!(write(\"[\"), print(ty), write(\"]\"))\n-            }\n-        }\n-\n-        Ok(self.printer)\n-    }\n-}\n-\n define_print! {\n     ('tcx) Ty<'tcx>, (self, cx) {\n         display {"}]}