{"sha": "a91f6f745e18bd9f32dbcb29286f81efec41eff2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MWY2Zjc0NWUxOGJkOWYzMmRiY2IyOTI4NmY4MWVmZWM0MWVmZjI=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-11T06:11:14Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-11T06:26:12Z"}, "message": "Tweak `nearest_common_ancestor()`.\n\n- Remove the \"no nearest common ancestor found\" case, because it's never\n  hit in practise. (This means `closure_is_enclosed_by` can also be\n  removed.)\n\n- Add a comment about why `SmallVec` is used for the \"seen\" structures.\n\n- Use `&Scope` instead of `Scope` to avoid some `map()` calls.\n\n- Use `any(p)` instead of `position(p).is_some()`.", "tree": {"sha": "52344d73efda15a2d65b8a2f5b19e0e7e670c705", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52344d73efda15a2d65b8a2f5b19e0e7e670c705"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a91f6f745e18bd9f32dbcb29286f81efec41eff2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a91f6f745e18bd9f32dbcb29286f81efec41eff2", "html_url": "https://github.com/rust-lang/rust/commit/a91f6f745e18bd9f32dbcb29286f81efec41eff2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a91f6f745e18bd9f32dbcb29286f81efec41eff2/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9bfe840f41d00e9712f13fbc635ec3fbe95e8c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9bfe840f41d00e9712f13fbc635ec3fbe95e8c4", "html_url": "https://github.com/rust-lang/rust/commit/f9bfe840f41d00e9712f13fbc635ec3fbe95e8c4"}], "stats": {"total": 78, "additions": 19, "deletions": 59}, "files": [{"sha": "3838e09bda32e483df570a682bfd81d80e2895aa", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 19, "deletions": 59, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a91f6f745e18bd9f32dbcb29286f81efec41eff2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a91f6f745e18bd9f32dbcb29286f81efec41eff2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a91f6f745e18bd9f32dbcb29286f81efec41eff2", "patch": "@@ -542,18 +542,6 @@ impl<'tcx> ScopeTree {\n         assert!(previous.is_none());\n     }\n \n-    fn closure_is_enclosed_by(&self,\n-                              mut sub_closure: hir::ItemLocalId,\n-                              sup_closure: hir::ItemLocalId) -> bool {\n-        loop {\n-            if sub_closure == sup_closure { return true; }\n-            match self.closure_tree.get(&sub_closure) {\n-                Some(&s) => { sub_closure = s; }\n-                None => { return false; }\n-            }\n-        }\n-    }\n-\n     fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: Scope) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.item_local_id());\n@@ -688,65 +676,37 @@ impl<'tcx> ScopeTree {\n         // requires a hash table lookup, and we often have very long scope\n         // chains (10s or 100s of scopes) that only differ by a few elements at\n         // the start. So this algorithm is faster.\n-        let mut ma = Some(scope_a);\n-        let mut mb = Some(scope_b);\n-        let mut seen_a: SmallVec<[Scope; 32]> = SmallVec::new();\n-        let mut seen_b: SmallVec<[Scope; 32]> = SmallVec::new();\n+\n+        let mut ma = Some(&scope_a);\n+        let mut mb = Some(&scope_b);\n+\n+        // A HashSet<Scope> is a more obvious choice for these, but SmallVec is\n+        // faster because the set size is normally small so linear search is\n+        // as good or better than a hash table lookup, plus the size is usually\n+        // small enough to avoid a heap allocation.\n+        let mut seen_a: SmallVec<[&Scope; 32]> = SmallVec::new();\n+        let mut seen_b: SmallVec<[&Scope; 32]> = SmallVec::new();\n+\n         loop {\n             if let Some(a) = ma {\n-                if seen_b.iter().position(|s| *s == a).is_some() {\n-                    return a;\n+                if seen_b.iter().any(|s| *s == a) {\n+                    return *a;\n                 }\n                 seen_a.push(a);\n-                ma = self.parent_map.get(&a).map(|s| *s);\n+                ma = self.parent_map.get(&a);\n             }\n \n             if let Some(b) = mb {\n-                if seen_a.iter().position(|s| *s == b).is_some() {\n-                    return b;\n+                if seen_a.iter().any(|s| *s == b) {\n+                    return *b;\n                 }\n                 seen_b.push(b);\n-                mb = self.parent_map.get(&b).map(|s| *s);\n+                mb = self.parent_map.get(&b);\n             }\n \n             if ma.is_none() && mb.is_none() {\n-                break;\n-            }\n-        };\n-\n-        fn outermost_scope(parent_map: &FxHashMap<Scope, Scope>, scope: Scope) -> Scope {\n-            let mut scope = scope;\n-            loop {\n-               match parent_map.get(&scope) {\n-                   Some(&superscope) => scope = superscope,\n-                   None => break scope,\n-               }\n-            }\n-        }\n-\n-        // In this (rare) case, the two regions belong to completely different\n-        // functions. Compare those fn for lexical nesting. The reasoning\n-        // behind this is subtle. See the \"Modeling closures\" section of the\n-        // README in infer::region_constraints for more details.\n-        let a_root_scope = outermost_scope(&self.parent_map, scope_a);\n-        let b_root_scope = outermost_scope(&self.parent_map, scope_b);\n-        match (a_root_scope.data(), b_root_scope.data()) {\n-            (ScopeData::Destruction(a_root_id),\n-             ScopeData::Destruction(b_root_id)) => {\n-                if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n-                    // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n-                    scope_b\n-                } else if self.closure_is_enclosed_by(b_root_id, a_root_id) {\n-                    // `b` is enclosed by `a`, hence `a` is the ancestor of everything in `b`\n-                    scope_a\n-                } else {\n-                    // neither fn encloses the other\n-                    bug!()\n-                }\n-            }\n-            _ => {\n-                // root ids are always Node right now\n-                bug!()\n+                // No nearest common ancestor found.\n+                bug!();\n             }\n         }\n     }"}]}