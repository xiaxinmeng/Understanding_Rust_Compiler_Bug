{"sha": "dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhYjJhZTA0MDQwMTRiNGZiYzVhMzJhOGM5NTRmZTYwNjhiMjVmNzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-05T05:08:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-05T05:08:19Z"}, "message": "Auto merge of #75037 - richkadel:llvm-coverage-map-gen-5.2, r=wesleywiser\n\nCompletes support for coverage in external crates\n\nFollow-up to #74959 :\n\nThe prior PR corrected for errors encountered when trying to generate\nthe coverage map on source code inlined from external crates (including\nmacros and generics) by avoiding adding external DefIds to the coverage\nmap.\n\nThis made it possible to generate a coverage report including external\ncrates, but the external crate coverage was incomplete (did not include\ncoverage for the DefIds that were eliminated.\n\nThe root issue was that the coverage map was converting Span locations\nto source file and locations, using the SourceMap for the current crate,\nand this would not work for spans from external crates (compliled with a\ndifferent SourceMap).\n\nThe solution was to convert the Spans to filename and location during\nMIR generation instead, so precompiled external crates would already\nhave the correct source code locations embedded in their MIR, when\nimported into another crate.\n\n@wesleywiser FYI\nr? @tmandry", "tree": {"sha": "18150cd32fd769b4700cfcc034b2696aabe1a913", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18150cd32fd769b4700cfcc034b2696aabe1a913"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "html_url": "https://github.com/rust-lang/rust/commit/dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "119d2a1a98fe87d4ae6cabf12134a0ef2fb95851", "url": "https://api.github.com/repos/rust-lang/rust/commits/119d2a1a98fe87d4ae6cabf12134a0ef2fb95851", "html_url": "https://github.com/rust-lang/rust/commit/119d2a1a98fe87d4ae6cabf12134a0ef2fb95851"}, {"sha": "e0dc8dec273b4cba44a91c1b4433e3dcd117919f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0dc8dec273b4cba44a91c1b4433e3dcd117919f", "html_url": "https://github.com/rust-lang/rust/commit/e0dc8dec273b4cba44a91c1b4433e3dcd117919f"}], "stats": {"total": 779, "additions": 411, "deletions": 368}, "files": [{"sha": "3a28bc79effafd6fc25b0bf4036ab5ad89d15543", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -1950,15 +1950,20 @@ extern \"rust-intrinsic\" {\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// Internal placeholder for injecting code coverage counters when the \"instrument-coverage\"\n-    /// option is enabled. The placeholder is replaced with `llvm.instrprof.increment` during code\n-    /// generation.\n+    /// option is enabled. The source code region information is extracted prior to code generation,\n+    /// and added to the \"coverage map\", which is injected into the generated code as additional\n+    /// data. This intrinsic then triggers the generation of LLVM intrinsic call\n+    /// `instrprof.increment`, using the remaining args (`function_source_hash` and `index`).\n     #[cfg(not(bootstrap))]\n     #[lang = \"count_code_region\"]\n     pub fn count_code_region(\n         function_source_hash: u64,\n         index: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        file_name: &'static str,\n+        start_line: u32,\n+        start_col: u32,\n+        end_line: u32,\n+        end_col: u32,\n     );\n \n     /// Internal marker for code coverage expressions, injected into the MIR when the\n@@ -1973,8 +1978,11 @@ extern \"rust-intrinsic\" {\n         index: u32,\n         left_index: u32,\n         right_index: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        file_name: &'static str,\n+        start_line: u32,\n+        start_col: u32,\n+        end_line: u32,\n+        end_col: u32,\n     );\n \n     /// This marker identifies a code region and two other counters or counter expressions\n@@ -1986,14 +1994,24 @@ extern \"rust-intrinsic\" {\n         index: u32,\n         left_index: u32,\n         right_index: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        file_name: &'static str,\n+        start_line: u32,\n+        start_col: u32,\n+        end_line: u32,\n+        end_col: u32,\n     );\n \n     /// This marker identifies a code region to be added to the \"coverage map\" to indicate source\n     /// code that can never be reached.\n     /// (See `coverage_counter_add` for more information.)\n-    pub fn coverage_unreachable(start_byte_pos: u32, end_byte_pos: u32);\n+    #[cfg(not(bootstrap))]\n+    pub fn coverage_unreachable(\n+        file_name: &'static str,\n+        start_line: u32,\n+        start_col: u32,\n+        end_line: u32,\n+        end_col: u32,\n+    );\n \n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]"}, {"sha": "9d2383abeed223264490f9680b079a6b579da855", "filename": "src/librustc_codegen_llvm/coverageinfo/mapgen.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -92,7 +92,7 @@ impl CoverageMapGenerator {\n     fn write_coverage_mappings(\n         &mut self,\n         expressions: Vec<CounterExpression>,\n-        counter_regions: impl Iterator<Item = (Counter, &'a Region)>,\n+        counter_regions: impl Iterator<Item = (Counter, &'tcx Region<'tcx>)>,\n         coverage_mappings_buffer: &RustString,\n     ) {\n         let mut counter_regions = counter_regions.collect::<Vec<_>>();\n@@ -102,7 +102,7 @@ impl CoverageMapGenerator {\n \n         let mut virtual_file_mapping = Vec::new();\n         let mut mapping_regions = Vec::new();\n-        let mut current_file_path = None;\n+        let mut current_file_name = None;\n         let mut current_file_id = 0;\n \n         // Convert the list of (Counter, Region) pairs to an array of `CounterMappingRegion`, sorted\n@@ -112,22 +112,22 @@ impl CoverageMapGenerator {\n         // `filenames` array.\n         counter_regions.sort_unstable_by_key(|(_counter, region)| *region);\n         for (counter, region) in counter_regions {\n-            let (file_path, start_line, start_col, end_line, end_col) = region.file_start_and_end();\n-            let same_file = current_file_path.as_ref().map_or(false, |p| p == file_path);\n+            let Region { file_name, start_line, start_col, end_line, end_col } = *region;\n+            let same_file = current_file_name.as_ref().map_or(false, |p| p == file_name);\n             if !same_file {\n-                if current_file_path.is_some() {\n+                if current_file_name.is_some() {\n                     current_file_id += 1;\n                 }\n-                current_file_path = Some(file_path.clone());\n-                let filename = CString::new(file_path.to_string_lossy().to_string())\n-                    .expect(\"null error converting filename to C string\");\n-                debug!(\"  file_id: {} = '{:?}'\", current_file_id, filename);\n-                let filenames_index = match self.filename_to_index.get(&filename) {\n+                current_file_name = Some(file_name.to_string());\n+                let c_filename =\n+                    CString::new(file_name).expect(\"null error converting filename to C string\");\n+                debug!(\"  file_id: {} = '{:?}'\", current_file_id, c_filename);\n+                let filenames_index = match self.filename_to_index.get(&c_filename) {\n                     Some(index) => *index,\n                     None => {\n                         let index = self.filenames.len() as u32;\n-                        self.filenames.push(filename.clone());\n-                        self.filename_to_index.insert(filename.clone(), index);\n+                        self.filenames.push(c_filename.clone());\n+                        self.filename_to_index.insert(c_filename.clone(), index);\n                         index\n                     }\n                 };"}, {"sha": "7b864e499d1de03391757bf7001c4e6193e2e824", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -6,7 +6,7 @@ use crate::common::CodegenCx;\n use libc::c_uint;\n use llvm::coverageinfo::CounterMappingRegion;\n use log::debug;\n-use rustc_codegen_ssa::coverageinfo::map::{CounterExpression, ExprKind, FunctionCoverage};\n+use rustc_codegen_ssa::coverageinfo::map::{CounterExpression, ExprKind, FunctionCoverage, Region};\n use rustc_codegen_ssa::traits::{\n     BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, StaticMethods,\n };\n@@ -49,19 +49,18 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         instance: Instance<'tcx>,\n         function_source_hash: u64,\n         id: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        region: Region<'tcx>,\n     ) {\n         debug!(\n             \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={}, \\\n-             byte range {}..{}\",\n-            instance, function_source_hash, id, start_byte_pos, end_byte_pos,\n+             at {:?}\",\n+            instance, function_source_hash, id, region,\n         );\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n             .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter(function_source_hash, id, start_byte_pos, end_byte_pos);\n+            .add_counter(function_source_hash, id, region);\n     }\n \n     fn add_counter_expression_region(\n@@ -71,43 +70,30 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         lhs: u32,\n         op: ExprKind,\n         rhs: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        region: Region<'tcx>,\n     ) {\n         debug!(\n             \"adding counter expression to coverage_regions: instance={:?}, id={}, {} {:?} {}, \\\n-             byte range {}..{}\",\n-            instance, id_descending_from_max, lhs, op, rhs, start_byte_pos, end_byte_pos,\n+             at {:?}\",\n+            instance, id_descending_from_max, lhs, op, rhs, region,\n         );\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n             .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter_expression(\n-                id_descending_from_max,\n-                lhs,\n-                op,\n-                rhs,\n-                start_byte_pos,\n-                end_byte_pos,\n-            );\n+            .add_counter_expression(id_descending_from_max, lhs, op, rhs, region);\n     }\n \n-    fn add_unreachable_region(\n-        &mut self,\n-        instance: Instance<'tcx>,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n-    ) {\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: Region<'tcx>) {\n         debug!(\n-            \"adding unreachable code to coverage_regions: instance={:?}, byte range {}..{}\",\n-            instance, start_byte_pos, end_byte_pos,\n+            \"adding unreachable code to coverage_regions: instance={:?}, at {:?}\",\n+            instance, region,\n         );\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n             .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_unreachable_region(start_byte_pos, end_byte_pos);\n+            .add_unreachable_region(region);\n     }\n }\n "}, {"sha": "dfd5104a31f6d0ae735aba57aa8c84b476f0b85b", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 61, "deletions": 60, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n-use rustc_codegen_ssa::coverageinfo::ExprKind;\n+use rustc_codegen_ssa::coverageinfo;\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n@@ -93,64 +93,64 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let mut is_codegen_intrinsic = true;\n         // Set `is_codegen_intrinsic` to `false` to bypass `codegen_intrinsic_call()`.\n \n-        if self.tcx.sess.opts.debugging_opts.instrument_coverage {\n-            // If the intrinsic is from the local MIR, add the coverage information to the Codegen\n-            // context, to be encoded into the local crate's coverage map.\n-            if caller_instance.def_id().is_local() {\n-                // FIXME(richkadel): Make sure to add coverage analysis tests on a crate with\n-                // external crate dependencies, where:\n-                //   1. Both binary and dependent crates are compiled with `-Zinstrument-coverage`\n-                //   2. Only binary is compiled with `-Zinstrument-coverage`\n-                //   3. Only dependent crates are compiled with `-Zinstrument-coverage`\n-                match intrinsic {\n-                    sym::count_code_region => {\n-                        use coverage::count_code_region_args::*;\n-                        self.add_counter_region(\n-                            caller_instance,\n-                            op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n-                            op_to_u32(&args[COUNTER_ID]),\n-                            op_to_u32(&args[START_BYTE_POS]),\n-                            op_to_u32(&args[END_BYTE_POS]),\n-                        );\n-                    }\n-                    sym::coverage_counter_add | sym::coverage_counter_subtract => {\n-                        use coverage::coverage_counter_expression_args::*;\n-                        self.add_counter_expression_region(\n-                            caller_instance,\n-                            op_to_u32(&args[EXPRESSION_ID]),\n-                            op_to_u32(&args[LEFT_ID]),\n-                            if intrinsic == sym::coverage_counter_add {\n-                                ExprKind::Add\n-                            } else {\n-                                ExprKind::Subtract\n-                            },\n-                            op_to_u32(&args[RIGHT_ID]),\n-                            op_to_u32(&args[START_BYTE_POS]),\n-                            op_to_u32(&args[END_BYTE_POS]),\n-                        );\n-                    }\n-                    sym::coverage_unreachable => {\n-                        use coverage::coverage_unreachable_args::*;\n-                        self.add_unreachable_region(\n-                            caller_instance,\n-                            op_to_u32(&args[START_BYTE_POS]),\n-                            op_to_u32(&args[END_BYTE_POS]),\n-                        );\n-                    }\n-                    _ => {}\n-                }\n+        // FIXME(richkadel): Make sure to add coverage analysis tests on a crate with\n+        // external crate dependencies, where:\n+        //   1. Both binary and dependent crates are compiled with `-Zinstrument-coverage`\n+        //   2. Only binary is compiled with `-Zinstrument-coverage`\n+        //   3. Only dependent crates are compiled with `-Zinstrument-coverage`\n+        match intrinsic {\n+            sym::count_code_region => {\n+                use coverage::count_code_region_args::*;\n+                self.add_counter_region(\n+                    caller_instance,\n+                    op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n+                    op_to_u32(&args[COUNTER_ID]),\n+                    coverageinfo::Region::new(\n+                        op_to_str_slice(&args[FILE_NAME]),\n+                        op_to_u32(&args[START_LINE]),\n+                        op_to_u32(&args[START_COL]),\n+                        op_to_u32(&args[END_LINE]),\n+                        op_to_u32(&args[END_COL]),\n+                    ),\n+                );\n             }\n-\n-            // Only the `count_code_region` coverage intrinsic is translated into an actual LLVM\n-            // intrinsic call (local or not); otherwise, set `is_codegen_intrinsic` to `false`.\n-            match intrinsic {\n-                sym::coverage_counter_add\n-                | sym::coverage_counter_subtract\n-                | sym::coverage_unreachable => {\n-                    is_codegen_intrinsic = false;\n-                }\n-                _ => {}\n+            sym::coverage_counter_add | sym::coverage_counter_subtract => {\n+                is_codegen_intrinsic = false;\n+                use coverage::coverage_counter_expression_args::*;\n+                self.add_counter_expression_region(\n+                    caller_instance,\n+                    op_to_u32(&args[EXPRESSION_ID]),\n+                    op_to_u32(&args[LEFT_ID]),\n+                    if intrinsic == sym::coverage_counter_add {\n+                        coverageinfo::ExprKind::Add\n+                    } else {\n+                        coverageinfo::ExprKind::Subtract\n+                    },\n+                    op_to_u32(&args[RIGHT_ID]),\n+                    coverageinfo::Region::new(\n+                        op_to_str_slice(&args[FILE_NAME]),\n+                        op_to_u32(&args[START_LINE]),\n+                        op_to_u32(&args[START_COL]),\n+                        op_to_u32(&args[END_LINE]),\n+                        op_to_u32(&args[END_COL]),\n+                    ),\n+                );\n             }\n+            sym::coverage_unreachable => {\n+                is_codegen_intrinsic = false;\n+                use coverage::coverage_unreachable_args::*;\n+                self.add_unreachable_region(\n+                    caller_instance,\n+                    coverageinfo::Region::new(\n+                        op_to_str_slice(&args[FILE_NAME]),\n+                        op_to_u32(&args[START_LINE]),\n+                        op_to_u32(&args[START_COL]),\n+                        op_to_u32(&args[END_LINE]),\n+                        op_to_u32(&args[END_COL]),\n+                    ),\n+                );\n+            }\n+            _ => {}\n         }\n         is_codegen_intrinsic\n     }\n@@ -215,9 +215,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.call(llfn, &[], None)\n             }\n             sym::count_code_region => {\n-                // FIXME(richkadel): The current implementation assumes the MIR for the given\n-                // caller_instance represents a single function. Validate and/or correct if inlining\n-                // and/or monomorphization invalidates these assumptions.\n                 let coverageinfo = tcx.coverageinfo(caller_instance.def_id());\n                 let mangled_fn = tcx.symbol_name(caller_instance);\n                 let (mangled_fn_name, _len_val) = self.const_str(Symbol::intern(mangled_fn.name));\n@@ -2243,6 +2240,10 @@ fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n     }\n }\n \n+fn op_to_str_slice<'tcx>(op: &Operand<'tcx>) -> &'tcx str {\n+    Operand::value_from_const(op).try_to_str_slice().expect(\"Value is &str\")\n+}\n+\n fn op_to_u32<'tcx>(op: &Operand<'tcx>) -> u32 {\n     Operand::scalar_from_const(op).to_u32().expect(\"Scalar is u32\")\n }"}, {"sha": "7f6841f9daa603f2b70c4f8ef8a1ef5210ce88a4", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "modified", "additions": 37, "deletions": 147, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -3,12 +3,8 @@ pub use super::ffi::*;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::source_map::{Pos, SourceMap};\n-use rustc_span::{BytePos, FileName, Loc, RealFileName};\n \n-use std::cmp::{Ord, Ordering};\n-use std::fmt;\n-use std::path::PathBuf;\n+use std::cmp::Ord;\n \n rustc_index::newtype_index! {\n     pub struct ExpressionOperandId {\n@@ -38,127 +34,35 @@ rustc_index::newtype_index! {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Region {\n-    start: Loc,\n-    end: Loc,\n-}\n-\n-impl Ord for Region {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        (&self.start.file.name, &self.start.line, &self.start.col, &self.end.line, &self.end.col)\n-            .cmp(&(\n-                &other.start.file.name,\n-                &other.start.line,\n-                &other.start.col,\n-                &other.end.line,\n-                &other.end.col,\n-            ))\n-    }\n-}\n-\n-impl PartialOrd for Region {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl PartialEq for Region {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.start.file.name == other.start.file.name\n-            && self.start.line == other.start.line\n-            && self.start.col == other.start.col\n-            && self.end.line == other.end.line\n-            && self.end.col == other.end.col\n-    }\n-}\n-\n-impl Eq for Region {}\n-\n-impl fmt::Display for Region {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (file_path, start_line, start_col, end_line, end_col) = self.file_start_and_end();\n-        write!(f, \"{:?}:{}:{} - {}:{}\", file_path, start_line, start_col, end_line, end_col)\n-    }\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct Region<'tcx> {\n+    pub file_name: &'tcx str,\n+    pub start_line: u32,\n+    pub start_col: u32,\n+    pub end_line: u32,\n+    pub end_col: u32,\n }\n \n-impl Region {\n-    pub fn new(source_map: &SourceMap, start_byte_pos: u32, end_byte_pos: u32) -> Self {\n-        let start = source_map.lookup_char_pos(BytePos::from_u32(start_byte_pos));\n-        let end = source_map.lookup_char_pos(BytePos::from_u32(end_byte_pos));\n-        assert_eq!(\n-            start.file.name, end.file.name,\n-            \"Region start ({} -> {:?}) and end ({} -> {:?}) don't come from the same source file!\",\n-            start_byte_pos, start, end_byte_pos, end\n-        );\n-        Self { start, end }\n-    }\n-\n-    pub fn file_start_and_end<'a>(&'a self) -> (&'a PathBuf, u32, u32, u32, u32) {\n-        let start = &self.start;\n-        let end = &self.end;\n-        match &start.file.name {\n-            FileName::Real(RealFileName::Named(path)) => (\n-                path,\n-                start.line as u32,\n-                start.col.to_u32() + 1,\n-                end.line as u32,\n-                end.col.to_u32() + 1,\n-            ),\n-            _ => {\n-                bug!(\"start.file.name should be a RealFileName, but it was: {:?}\", start.file.name)\n-            }\n-        }\n+impl<'tcx> Region<'tcx> {\n+    pub fn new(\n+        file_name: &'tcx str,\n+        start_line: u32,\n+        start_col: u32,\n+        end_line: u32,\n+        end_col: u32,\n+    ) -> Self {\n+        Self { file_name, start_line, start_col, end_line, end_col }\n     }\n }\n \n #[derive(Clone, Debug)]\n-pub struct ExpressionRegion {\n+pub struct ExpressionRegion<'tcx> {\n     lhs: ExpressionOperandId,\n     op: ExprKind,\n     rhs: ExpressionOperandId,\n-    region: Region,\n+    region: Region<'tcx>,\n }\n \n-// FIXME(richkadel): There seems to be a problem computing the file location in\n-// some cases. I need to investigate this more. When I generate and show coverage\n-// for the example binary in the crates.io crate `json5format`, I had a couple of\n-// notable problems:\n-//\n-//   1. I saw a lot of coverage spans in `llvm-cov show` highlighting regions in\n-//      various comments (not corresponding to rustdoc code), indicating a possible\n-//      problem with the byte_pos-to-source-map implementation.\n-//\n-//   2. And (perhaps not related) when I build the aforementioned example binary with:\n-//      `RUST_FLAGS=\"-Zinstrument-coverage\" cargo build --example formatjson5`\n-//      and then run that binary with\n-//      `LLVM_PROFILE_FILE=\"formatjson5.profraw\" ./target/debug/examples/formatjson5 \\\n-//      some.json5` for some reason the binary generates *TWO* `.profraw` files. One\n-//      named `default.profraw` and the other named `formatjson5.profraw` (the expected\n-//      name, in this case).\n-//\n-//   3. I think that if I eliminate regions within a function, their region_ids,\n-//      referenced in expressions, will be wrong? I think the ids are implied by their\n-//      array position in the final coverage map output (IIRC).\n-//\n-//   4. I suspect a problem (if not the only problem) is the SourceMap is wrong for some\n-//      region start/end byte positions. Just like I couldn't get the function hash at\n-//      intrinsic codegen time for external crate functions, I think the SourceMap I\n-//      have here only applies to the local crate, and I know I have coverages that\n-//      reference external crates.\n-//\n-//          I still don't know if I fixed the hash problem correctly. If external crates\n-//          implement the function, can't I use the coverage counters already compiled\n-//          into those external crates? (Maybe not for generics and/or maybe not for\n-//          macros... not sure. But I need to understand this better.)\n-//\n-// If the byte range conversion is wrong, fix it. But if it\n-// is right, then it is possible for the start and end to be in different files.\n-// Can I do something other than ignore coverages that span multiple files?\n-//\n-// If I can resolve this, remove the \"Option<>\" result type wrapper\n-// `regions_in_file_order()` accordingly.\n-\n /// Collects all of the coverage regions associated with (a) injected counters, (b) counter\n /// expressions (additions or subtraction), and (c) unreachable regions (always counted as zero),\n /// for a given Function. Counters and counter expressions have non-overlapping `id`s because they\n@@ -171,19 +75,17 @@ pub struct ExpressionRegion {\n /// only whitespace or comments). According to LLVM Code Coverage Mapping documentation, \"A count\n /// for a gap area is only used as the line execution count if there are no other regions on a\n /// line.\"\n-pub struct FunctionCoverage<'a> {\n-    source_map: &'a SourceMap,\n+pub struct FunctionCoverage<'tcx> {\n     source_hash: u64,\n-    counters: IndexVec<CounterValueReference, Option<Region>>,\n-    expressions: IndexVec<InjectedExpressionIndex, Option<ExpressionRegion>>,\n-    unreachable_regions: Vec<Region>,\n+    counters: IndexVec<CounterValueReference, Option<Region<'tcx>>>,\n+    expressions: IndexVec<InjectedExpressionIndex, Option<ExpressionRegion<'tcx>>>,\n+    unreachable_regions: Vec<Region<'tcx>>,\n }\n \n-impl<'a> FunctionCoverage<'a> {\n-    pub fn new<'tcx: 'a>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n+impl<'tcx> FunctionCoverage<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n         let coverageinfo = tcx.coverageinfo(instance.def_id());\n         Self {\n-            source_map: tcx.sess.source_map(),\n             source_hash: 0, // will be set with the first `add_counter()`\n             counters: IndexVec::from_elem_n(None, coverageinfo.num_counters as usize),\n             expressions: IndexVec::from_elem_n(None, coverageinfo.num_expressions as usize),\n@@ -194,20 +96,14 @@ impl<'a> FunctionCoverage<'a> {\n     /// Adds a code region to be counted by an injected counter intrinsic.\n     /// The source_hash (computed during coverage instrumentation) should also be provided, and\n     /// should be the same for all counters in a given function.\n-    pub fn add_counter(\n-        &mut self,\n-        source_hash: u64,\n-        id: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n-    ) {\n+    pub fn add_counter(&mut self, source_hash: u64, id: u32, region: Region<'tcx>) {\n         if self.source_hash == 0 {\n             self.source_hash = source_hash;\n         } else {\n             debug_assert_eq!(source_hash, self.source_hash);\n         }\n         self.counters[CounterValueReference::from(id)]\n-            .replace(Region::new(self.source_map, start_byte_pos, end_byte_pos))\n+            .replace(region)\n             .expect_none(\"add_counter called with duplicate `id`\");\n     }\n \n@@ -231,27 +127,21 @@ impl<'a> FunctionCoverage<'a> {\n         lhs: u32,\n         op: ExprKind,\n         rhs: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        region: Region<'tcx>,\n     ) {\n         let expression_id = ExpressionOperandId::from(id_descending_from_max);\n         let lhs = ExpressionOperandId::from(lhs);\n         let rhs = ExpressionOperandId::from(rhs);\n \n         let expression_index = self.expression_index(expression_id);\n         self.expressions[expression_index]\n-            .replace(ExpressionRegion {\n-                lhs,\n-                op,\n-                rhs,\n-                region: Region::new(self.source_map, start_byte_pos, end_byte_pos),\n-            })\n+            .replace(ExpressionRegion { lhs, op, rhs, region })\n             .expect_none(\"add_counter_expression called with duplicate `id_descending_from_max`\");\n     }\n \n     /// Add a region that will be marked as \"unreachable\", with a constant \"zero counter\".\n-    pub fn add_unreachable_region(&mut self, start_byte_pos: u32, end_byte_pos: u32) {\n-        self.unreachable_regions.push(Region::new(self.source_map, start_byte_pos, end_byte_pos));\n+    pub fn add_unreachable_region(&mut self, region: Region<'tcx>) {\n+        self.unreachable_regions.push(region)\n     }\n \n     /// Return the source hash, generated from the HIR node structure, and used to indicate whether\n@@ -264,8 +154,8 @@ impl<'a> FunctionCoverage<'a> {\n     /// associated `Regions` (from which the LLVM-specific `CoverageMapGenerator` will create\n     /// `CounterMappingRegion`s.\n     pub fn get_expressions_and_counter_regions(\n-        &'a self,\n-    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'a Region)>) {\n+        &'tcx self,\n+    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'tcx Region<'tcx>)>) {\n         assert!(self.source_hash != 0);\n \n         let counter_regions = self.counter_regions();\n@@ -277,7 +167,7 @@ impl<'a> FunctionCoverage<'a> {\n         (counter_expressions, counter_regions)\n     }\n \n-    fn counter_regions(&'a self) -> impl Iterator<Item = (Counter, &'a Region)> {\n+    fn counter_regions(&'tcx self) -> impl Iterator<Item = (Counter, &'tcx Region<'tcx>)> {\n         self.counters.iter_enumerated().filter_map(|(index, entry)| {\n             // Option::map() will return None to filter out missing counters. This may happen\n             // if, for example, a MIR-instrumented counter is removed during an optimization.\n@@ -288,8 +178,8 @@ impl<'a> FunctionCoverage<'a> {\n     }\n \n     fn expressions_with_regions(\n-        &'a self,\n-    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'a Region)>) {\n+        &'tcx self,\n+    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'tcx Region<'tcx>)>) {\n         let mut counter_expressions = Vec::with_capacity(self.expressions.len());\n         let mut expression_regions = Vec::with_capacity(self.expressions.len());\n         let mut new_indexes =\n@@ -350,7 +240,7 @@ impl<'a> FunctionCoverage<'a> {\n         (counter_expressions, expression_regions.into_iter())\n     }\n \n-    fn unreachable_regions(&'a self) -> impl Iterator<Item = (Counter, &'a Region)> {\n+    fn unreachable_regions(&'tcx self) -> impl Iterator<Item = (Counter, &'tcx Region<'tcx>)> {\n         self.unreachable_regions.iter().map(|region| (Counter::zero(), region))\n     }\n "}, {"sha": "ff794a75c360d97756530437ce29823313ab8a55", "filename": "src/librustc_codegen_ssa/coverageinfo/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -2,3 +2,4 @@ pub mod ffi;\n pub mod map;\n \n pub use map::ExprKind;\n+pub use map::Region;"}, {"sha": "2b5878f46bc43bfc7540b45468f6657e5c7e07ee", "filename": "src/librustc_codegen_ssa/traits/coverageinfo.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -1,5 +1,5 @@\n use super::BackendTypes;\n-use crate::coverageinfo::ExprKind;\n+use crate::coverageinfo::{ExprKind, Region};\n use rustc_middle::ty::Instance;\n \n pub trait CoverageInfoMethods: BackendTypes {\n@@ -12,8 +12,7 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n         instance: Instance<'tcx>,\n         function_source_hash: u64,\n         index: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        region: Region<'tcx>,\n     );\n \n     fn add_counter_expression_region(\n@@ -23,14 +22,8 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n         lhs: u32,\n         op: ExprKind,\n         rhs: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        region: Region<'tcx>,\n     );\n \n-    fn add_unreachable_region(\n-        &mut self,\n-        instance: Instance<'tcx>,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n-    );\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: Region<'tcx>);\n }"}, {"sha": "6b1514da6441de474a19c738e3a9b92a7865105f", "filename": "src/librustc_middle/mir/coverage/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -4,8 +4,11 @@\n pub mod count_code_region_args {\n     pub const FUNCTION_SOURCE_HASH: usize = 0;\n     pub const COUNTER_ID: usize = 1;\n-    pub const START_BYTE_POS: usize = 2;\n-    pub const END_BYTE_POS: usize = 3;\n+    pub const FILE_NAME: usize = 2;\n+    pub const START_LINE: usize = 3;\n+    pub const START_COL: usize = 4;\n+    pub const END_LINE: usize = 5;\n+    pub const END_COL: usize = 6;\n }\n \n /// Positional arguments to `libcore::coverage_counter_add()` and\n@@ -14,12 +17,18 @@ pub mod coverage_counter_expression_args {\n     pub const EXPRESSION_ID: usize = 0;\n     pub const LEFT_ID: usize = 1;\n     pub const RIGHT_ID: usize = 2;\n-    pub const START_BYTE_POS: usize = 3;\n-    pub const END_BYTE_POS: usize = 4;\n+    pub const FILE_NAME: usize = 3;\n+    pub const START_LINE: usize = 4;\n+    pub const START_COL: usize = 5;\n+    pub const END_LINE: usize = 6;\n+    pub const END_COL: usize = 7;\n }\n \n /// Positional arguments to `libcore::coverage_unreachable()`\n pub mod coverage_unreachable_args {\n-    pub const START_BYTE_POS: usize = 0;\n-    pub const END_BYTE_POS: usize = 1;\n+    pub const FILE_NAME: usize = 0;\n+    pub const START_LINE: usize = 1;\n+    pub const START_COL: usize = 2;\n+    pub const END_LINE: usize = 3;\n+    pub const END_COL: usize = 4;\n }"}, {"sha": "b4e7a5b98e33ba6296a957f4973a0ed8d53159f5", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -56,6 +56,15 @@ impl<'tcx> ConstValue<'tcx> {\n         }\n     }\n \n+    pub fn try_to_str_slice(&self) -> Option<&'tcx str> {\n+        if let ConstValue::Slice { data, start, end } = *self {\n+            ::std::str::from_utf8(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n+                .ok()\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n         self.try_to_scalar()?.to_bits(size).ok()\n     }"}, {"sha": "3b0c480f6d400458cb0f40b906fc9ceea216ab82", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -2,7 +2,7 @@\n //!\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n-use crate::mir::interpret::{GlobalAlloc, Scalar};\n+use crate::mir::interpret::{Allocation, ConstValue, GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -1842,6 +1842,33 @@ impl<'tcx> Operand<'tcx> {\n         }\n     }\n \n+    /// Convenience helper to make a literal-like constant from a given `&str` slice.\n+    /// Since this is used to synthesize MIR, assumes `user_ty` is None.\n+    pub fn const_from_str(tcx: TyCtxt<'tcx>, val: &str, span: Span) -> Operand<'tcx> {\n+        let tcx = tcx;\n+        let allocation = Allocation::from_byte_aligned_bytes(val.as_bytes());\n+        let allocation = tcx.intern_const_alloc(allocation);\n+        let const_val = ConstValue::Slice { data: allocation, start: 0, end: val.len() };\n+        let ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, tcx.types.str_);\n+        Operand::Constant(box Constant {\n+            span,\n+            user_ty: None,\n+            literal: ty::Const::from_value(tcx, const_val, ty),\n+        })\n+    }\n+\n+    /// Convenience helper to make a `ConstValue` from the given `Operand`, assuming that `Operand`\n+    /// wraps a constant value (such as a `&str` slice). Panics if this is not the case.\n+    pub fn value_from_const(operand: &Operand<'tcx>) -> ConstValue<'tcx> {\n+        match operand {\n+            Operand::Constant(constant) => match constant.literal.val.try_to_value() {\n+                Some(const_value) => const_value,\n+                _ => panic!(\"{:?}: ConstValue expected\", constant.literal.val),\n+            },\n+            _ => panic!(\"{:?}: Constant expected\", operand),\n+        }\n+    }\n+\n     pub fn to_copy(&self) -> Self {\n         match *self {\n             Operand::Copy(_) | Operand::Constant(_) => self.clone(),"}, {"sha": "5b2954dd5b0a3e08ebf228722ed6d056f35d9631", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 61, "deletions": 33, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -5,18 +5,19 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::lang_items;\n use rustc_middle::hir;\n use rustc_middle::ich::StableHashingContext;\n+use rustc_middle::mir;\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::interpret::Scalar;\n+use rustc_middle::mir::traversal;\n use rustc_middle::mir::{\n-    self, traversal, BasicBlock, BasicBlockData, CoverageInfo, Operand, Place, SourceInfo,\n-    SourceScope, StatementKind, Terminator, TerminatorKind,\n+    BasicBlock, BasicBlockData, CoverageInfo, Operand, Place, SourceInfo, SourceScope,\n+    StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::FnDef;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{FnDef, TyCtxt};\n use rustc_span::def_id::DefId;\n-use rustc_span::{Pos, Span};\n+use rustc_span::{FileName, Pos, RealFileName, Span};\n \n /// Inserts call to count_code_region() as a placeholder to be replaced during code generation with\n /// the intrinsic llvm.instrprof.increment.\n@@ -112,6 +113,7 @@ enum Op {\n struct InjectedCall<'tcx> {\n     func: Operand<'tcx>,\n     args: Vec<Operand<'tcx>>,\n+    span: Span,\n     inject_at: Span,\n }\n \n@@ -179,12 +181,11 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let _ignore = mir_body;\n         let id = self.next_counter();\n         let function_source_hash = self.function_source_hash();\n-        let code_region = body_span;\n         let scope = rustc_middle::mir::OUTERMOST_SOURCE_SCOPE;\n         let is_cleanup = false;\n         let next_block = rustc_middle::mir::START_BLOCK;\n         self.inject_call(\n-            self.make_counter(id, function_source_hash, code_region),\n+            self.make_counter(id, function_source_hash, body_span),\n             scope,\n             is_cleanup,\n             next_block,\n@@ -201,28 +202,22 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n             let op = if add { Op::Add } else { Op::Subtract };\n             let rhs = 2;\n \n-            let code_region = body_span;\n             let scope = rustc_middle::mir::OUTERMOST_SOURCE_SCOPE;\n             let is_cleanup = false;\n             let next_block = rustc_middle::mir::START_BLOCK;\n \n             let id = self.next_expression();\n             self.inject_call(\n-                self.make_expression(id, code_region, lhs, op, rhs),\n+                self.make_expression(id, body_span, lhs, op, rhs),\n                 scope,\n                 is_cleanup,\n                 next_block,\n             );\n         }\n     }\n \n-    fn make_counter(\n-        &self,\n-        id: u32,\n-        function_source_hash: u64,\n-        code_region: Span,\n-    ) -> InjectedCall<'tcx> {\n-        let inject_at = code_region.shrink_to_lo();\n+    fn make_counter(&self, id: u32, function_source_hash: u64, span: Span) -> InjectedCall<'tcx> {\n+        let inject_at = span.shrink_to_lo();\n \n         let func = function_handle(\n             self.tcx,\n@@ -239,24 +234,18 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         debug_assert_eq!(COUNTER_ID, args.len());\n         args.push(self.const_u32(id, inject_at));\n \n-        debug_assert_eq!(START_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.lo().to_u32(), inject_at));\n-\n-        debug_assert_eq!(END_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.hi().to_u32(), inject_at));\n-\n-        InjectedCall { func, args, inject_at }\n+        InjectedCall { func, args, span, inject_at }\n     }\n \n     fn make_expression(\n         &self,\n         id: u32,\n-        code_region: Span,\n+        span: Span,\n         lhs: u32,\n         op: Op,\n         rhs: u32,\n     ) -> InjectedCall<'tcx> {\n-        let inject_at = code_region.shrink_to_lo();\n+        let inject_at = span.shrink_to_lo();\n \n         let func = function_handle(\n             self.tcx,\n@@ -282,13 +271,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         debug_assert_eq!(RIGHT_ID, args.len());\n         args.push(self.const_u32(rhs, inject_at));\n \n-        debug_assert_eq!(START_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.lo().to_u32(), inject_at));\n-\n-        debug_assert_eq!(END_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.hi().to_u32(), inject_at));\n-\n-        InjectedCall { func, args, inject_at }\n+        InjectedCall { func, args, span, inject_at }\n     }\n \n     fn inject_call(\n@@ -298,7 +281,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         is_cleanup: bool,\n         next_block: BasicBlock,\n     ) {\n-        let InjectedCall { func, args, inject_at } = call;\n+        let InjectedCall { func, mut args, span, inject_at } = call;\n         debug!(\n             \"  injecting {}call to {:?}({:?}) at: {:?}, scope: {:?}\",\n             if is_cleanup { \"cleanup \" } else { \"\" },\n@@ -310,6 +293,14 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n \n         let mut patch = MirPatch::new(self.mir_body);\n \n+        let (file_name, start_line, start_col, end_line, end_col) = self.code_region(&span);\n+\n+        args.push(self.const_str(&file_name, inject_at));\n+        args.push(self.const_u32(start_line, inject_at));\n+        args.push(self.const_u32(start_col, inject_at));\n+        args.push(self.const_u32(end_line, inject_at));\n+        args.push(self.const_u32(end_col, inject_at));\n+\n         let temp = patch.new_temp(self.tcx.mk_unit(), inject_at);\n         let new_block = patch.new_block(placeholder_block(inject_at, scope, is_cleanup));\n         patch.patch_terminator(\n@@ -335,6 +326,43 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         self.mir_body.basic_blocks_mut().swap(next_block, new_block);\n     }\n \n+    /// Convert the Span into its file name, start line and column, and end line and column\n+    fn code_region(&self, span: &Span) -> (String, u32, u32, u32, u32) {\n+        let source_map = self.tcx.sess.source_map();\n+        let start = source_map.lookup_char_pos(span.lo());\n+        let end = if span.hi() == span.lo() {\n+            start.clone()\n+        } else {\n+            let end = source_map.lookup_char_pos(span.hi());\n+            debug_assert_eq!(\n+                start.file.name,\n+                end.file.name,\n+                \"Region start ({:?} -> {:?}) and end ({:?} -> {:?}) don't come from the same source file!\",\n+                span.lo(),\n+                start,\n+                span.hi(),\n+                end\n+            );\n+            end\n+        };\n+        match &start.file.name {\n+            FileName::Real(RealFileName::Named(path)) => (\n+                path.to_string_lossy().to_string(),\n+                start.line as u32,\n+                start.col.to_u32() + 1,\n+                end.line as u32,\n+                end.col.to_u32() + 1,\n+            ),\n+            _ => {\n+                bug!(\"start.file.name should be a RealFileName, but it was: {:?}\", start.file.name)\n+            }\n+        }\n+    }\n+\n+    fn const_str(&self, value: &str, span: Span) -> Operand<'tcx> {\n+        Operand::const_from_str(self.tcx, value, span)\n+    }\n+\n     fn const_u32(&self, value: u32, span: Span) -> Operand<'tcx> {\n         Operand::const_from_scalar(self.tcx, self.tcx.types.u32, Scalar::from_u32(value), span)\n     }"}, {"sha": "b3287caa0bfc879ed32249a4be2db575a34dc71f", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -379,17 +379,46 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             sym::nontemporal_store => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n-            sym::count_code_region => {\n-                (0, vec![tcx.types.u64, tcx.types.u32, tcx.types.u32, tcx.types.u32], tcx.mk_unit())\n-            }\n+            sym::count_code_region => (\n+                0,\n+                vec![\n+                    tcx.types.u64,\n+                    tcx.types.u32,\n+                    tcx.mk_static_str(),\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                ],\n+                tcx.mk_unit(),\n+            ),\n \n             sym::coverage_counter_add | sym::coverage_counter_subtract => (\n                 0,\n-                vec![tcx.types.u32, tcx.types.u32, tcx.types.u32, tcx.types.u32, tcx.types.u32],\n+                vec![\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.mk_static_str(),\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                ],\n                 tcx.mk_unit(),\n             ),\n \n-            sym::coverage_unreachable => (0, vec![tcx.types.u32, tcx.types.u32], tcx.mk_unit()),\n+            sym::coverage_unreachable => (\n+                0,\n+                vec![\n+                    tcx.mk_static_str(),\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                ],\n+                tcx.mk_unit(),\n+            ),\n \n             other => {\n                 struct_span_err!("}, {"sha": "9ca6f93c9bc08d21aeb506fe6e8fd795a346f67b", "filename": "src/test/mir-opt/instrument_coverage.bar.InstrumentCoverage.diff", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Ftest%2Fmir-opt%2Finstrument_coverage.bar.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Ftest%2Fmir-opt%2Finstrument_coverage.bar.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.bar.InstrumentCoverage.diff?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -2,58 +2,76 @@\n + // MIR for `bar` after InstrumentCoverage\n   \n   fn bar() -> bool {\n-      let mut _0: bool;                    // return place in scope 0 at $DIR/instrument_coverage.rs:18:13: 18:17\n-+     let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:18:18: 18:18\n+      let mut _0: bool;                    // return place in scope 0 at /the/src/instrument_coverage.rs:19:13: 19:17\n++     let mut _1: ();                      // in scope 0 at /the/src/instrument_coverage.rs:19:18: 19:18\n   \n       bb0: {\n-+         StorageLive(_1);                 // scope 0 at $DIR/instrument_coverage.rs:18:18: 18:18\n-+         _1 = const std::intrinsics::count_code_region(const 10208505205182607101_u64, const 0_u32, const 529_u32, const 541_u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:18: 18:18\n++         StorageLive(_1);                 // scope 0 at /the/src/instrument_coverage.rs:19:18: 19:18\n++         _1 = const std::intrinsics::count_code_region(const 10208505205182607101_u64, const 0_u32, const \"/the/src/instrument_coverage.rs\", const 19_u32, const 18_u32, const 21_u32, const 2_u32) -> bb2; // scope 0 at /the/src/instrument_coverage.rs:19:18: 19:18\n +                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, &'static str, u32, u32, u32, u32) {std::intrinsics::count_code_region}\n +                                          // + val: Value(Scalar(<ZST>))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, &'static str, u32, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n +                                          // ty::Const\n +                                          // + ty: u64\n +                                          // + val: Value(Scalar(0x8dabe565aaa2aefd))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n +                                          // + literal: Const { ty: u64, val: Value(Scalar(0x8dabe565aaa2aefd)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n +                                          // ty::Const\n++                                          // + ty: &str\n++                                          // + val: Value(Slice { data: Allocation { bytes: [47, 116, 104, 101, 47, 115, 114, 99, 47, 105, 110, 115, 116, 114, 117, 109, 101, 110, 116, 95, 99, 111, 118, 101, 114, 97, 103, 101, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, size: Size { raw: 31 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 })\n++                                          // mir::Constant\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n++                                          // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [47, 116, 104, 101, 47, 115, 114, 99, 47, 105, 110, 115, 116, 114, 117, 109, 101, 110, 116, 95, 99, 111, 118, 101, 114, 97, 103, 101, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, size: Size { raw: 31 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 }) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000013))\n++                                          // mir::Constant\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000013)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000012))\n++                                          // mir::Constant\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000012)) }\n++                                          // ty::Const\n +                                          // + ty: u32\n-+                                          // + val: Value(Scalar(0x00000211))\n++                                          // + val: Value(Scalar(0x00000015))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n-+                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000211)) }\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000015)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n-+                                          // + val: Value(Scalar(0x0000021d))\n++                                          // + val: Value(Scalar(0x00000002))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n-+                                          // + literal: Const { ty: u32, val: Value(Scalar(0x0000021d)) }\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000002)) }\n +     }\n + \n +     bb1 (cleanup): {\n-+         resume;                          // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++         resume;                          // scope 0 at /the/src/instrument_coverage.rs:19:1: 21:2\n +     }\n + \n +     bb2: {\n-+         StorageDead(_1);                 // scope 0 at $DIR/instrument_coverage.rs:19:5: 19:9\n-          _0 = const true;                 // scope 0 at $DIR/instrument_coverage.rs:19:5: 19:9\n++         StorageDead(_1);                 // scope 0 at /the/src/instrument_coverage.rs:20:5: 20:9\n+          _0 = const true;                 // scope 0 at /the/src/instrument_coverage.rs:20:5: 20:9\n                                            // ty::Const\n                                            // + ty: bool\n                                            // + val: Value(Scalar(0x01))\n                                            // mir::Constant\n-                                           // + span: $DIR/instrument_coverage.rs:19:5: 19:9\n+                                           // + span: /the/src/instrument_coverage.rs:20:5: 20:9\n                                            // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n-          return;                          // scope 0 at $DIR/instrument_coverage.rs:20:2: 20:2\n+          return;                          // scope 0 at /the/src/instrument_coverage.rs:21:2: 21:2\n       }\n   }\n   "}, {"sha": "3f47aa13bf91fdc225b64ce624fe8a961e8dba22", "filename": "src/test/mir-opt/instrument_coverage.main.InstrumentCoverage.diff", "status": "modified", "additions": 54, "deletions": 36, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Ftest%2Fmir-opt%2Finstrument_coverage.main.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Ftest%2Fmir-opt%2Finstrument_coverage.main.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.main.InstrumentCoverage.diff?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -2,99 +2,117 @@\n + // MIR for `main` after InstrumentCoverage\n   \n   fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n-      let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n-      let mut _2: bool;                    // in scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n-      let mut _3: !;                       // in scope 0 at $DIR/instrument_coverage.rs:11:18: 13:10\n-+     let mut _4: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n+      let mut _0: ();                      // return place in scope 0 at /the/src/instrument_coverage.rs:10:11: 10:11\n+      let mut _1: ();                      // in scope 0 at /the/src/instrument_coverage.rs:10:1: 16:2\n+      let mut _2: bool;                    // in scope 0 at /the/src/instrument_coverage.rs:12:12: 12:17\n+      let mut _3: !;                       // in scope 0 at /the/src/instrument_coverage.rs:12:18: 14:10\n++     let mut _4: ();                      // in scope 0 at /the/src/instrument_coverage.rs:10:11: 10:11\n   \n       bb0: {\n--         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n-+         StorageLive(_4);                 // scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n-+         _4 = const std::intrinsics::count_code_region(const 16004455475339839479_u64, const 0_u32, const 425_u32, const 493_u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n+-         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n++         StorageLive(_4);                 // scope 0 at /the/src/instrument_coverage.rs:10:11: 10:11\n++         _4 = const std::intrinsics::count_code_region(const 16004455475339839479_u64, const 0_u32, const \"/the/src/instrument_coverage.rs\", const 10_u32, const 11_u32, const 16_u32, const 2_u32) -> bb7; // scope 0 at /the/src/instrument_coverage.rs:10:11: 10:11\n +                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, &'static str, u32, u32, u32, u32) {std::intrinsics::count_code_region}\n +                                          // + val: Value(Scalar(<ZST>))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, &'static str, u32, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n +                                          // ty::Const\n +                                          // + ty: u64\n +                                          // + val: Value(Scalar(0xde1b3f75a72fc7f7))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n +                                          // + literal: Const { ty: u64, val: Value(Scalar(0xde1b3f75a72fc7f7)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n +                                          // ty::Const\n++                                          // + ty: &str\n++                                          // + val: Value(Slice { data: Allocation { bytes: [47, 116, 104, 101, 47, 115, 114, 99, 47, 105, 110, 115, 116, 114, 117, 109, 101, 110, 116, 95, 99, 111, 118, 101, 114, 97, 103, 101, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, size: Size { raw: 31 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 })\n++                                          // mir::Constant\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n++                                          // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [47, 116, 104, 101, 47, 115, 114, 99, 47, 105, 110, 115, 116, 114, 117, 109, 101, 110, 116, 95, 99, 111, 118, 101, 114, 97, 103, 101, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, size: Size { raw: 31 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 }) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x0000000a))\n++                                          // mir::Constant\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x0000000a)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x0000000b))\n++                                          // mir::Constant\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x0000000b)) }\n++                                          // ty::Const\n +                                          // + ty: u32\n-+                                          // + val: Value(Scalar(0x000001a9))\n++                                          // + val: Value(Scalar(0x00000010))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n-+                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001a9)) }\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000010)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n-+                                          // + val: Value(Scalar(0x000001ed))\n++                                          // + val: Value(Scalar(0x00000002))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n-+                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001ed)) }\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000002)) }\n       }\n   \n       bb1: {\n-          StorageLive(_2);                 // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n-          _2 = const bar() -> [return: bb3, unwind: bb2]; // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+          StorageLive(_2);                 // scope 0 at /the/src/instrument_coverage.rs:12:12: 12:17\n+          _2 = const bar() -> [return: bb3, unwind: bb2]; // scope 0 at /the/src/instrument_coverage.rs:12:12: 12:17\n                                            // ty::Const\n                                            // + ty: fn() -> bool {bar}\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n-                                           // + span: $DIR/instrument_coverage.rs:11:12: 11:15\n+                                           // + span: /the/src/instrument_coverage.rs:12:12: 12:15\n                                            // + literal: Const { ty: fn() -> bool {bar}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb2 (cleanup): {\n-          resume;                          // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n+          resume;                          // scope 0 at /the/src/instrument_coverage.rs:10:1: 16:2\n       }\n   \n       bb3: {\n-          FakeRead(ForMatchedPlace, _2);   // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n-          switchInt(_2) -> [false: bb5, otherwise: bb4]; // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+          FakeRead(ForMatchedPlace, _2);   // scope 0 at /the/src/instrument_coverage.rs:12:12: 12:17\n+          switchInt(_2) -> [false: bb5, otherwise: bb4]; // scope 0 at /the/src/instrument_coverage.rs:12:9: 14:10\n       }\n   \n       bb4: {\n-          falseEdge -> [real: bb6, imaginary: bb5]; // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+          falseEdge -> [real: bb6, imaginary: bb5]; // scope 0 at /the/src/instrument_coverage.rs:12:9: 14:10\n       }\n   \n       bb5: {\n-          _1 = const ();                   // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+          _1 = const ();                   // scope 0 at /the/src/instrument_coverage.rs:12:9: 14:10\n                                            // ty::Const\n                                            // + ty: ()\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n-                                           // + span: $DIR/instrument_coverage.rs:11:9: 13:10\n+                                           // + span: /the/src/instrument_coverage.rs:12:9: 14:10\n                                            // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-          StorageDead(_2);                 // scope 0 at $DIR/instrument_coverage.rs:14:5: 14:6\n-          goto -> bb0;                     // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n+          StorageDead(_2);                 // scope 0 at /the/src/instrument_coverage.rs:15:5: 15:6\n+          goto -> bb0;                     // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n       }\n   \n       bb6: {\n-          _0 = const ();                   // scope 0 at $DIR/instrument_coverage.rs:12:13: 12:18\n+          _0 = const ();                   // scope 0 at /the/src/instrument_coverage.rs:13:13: 13:18\n                                            // ty::Const\n                                            // + ty: ()\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n-                                           // + span: $DIR/instrument_coverage.rs:12:13: 12:18\n+                                           // + span: /the/src/instrument_coverage.rs:13:13: 13:18\n                                            // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-          StorageDead(_2);                 // scope 0 at $DIR/instrument_coverage.rs:14:5: 14:6\n-          return;                          // scope 0 at $DIR/instrument_coverage.rs:15:2: 15:2\n+          StorageDead(_2);                 // scope 0 at /the/src/instrument_coverage.rs:15:5: 15:6\n+          return;                          // scope 0 at /the/src/instrument_coverage.rs:16:2: 16:2\n +     }\n + \n +     bb7: {\n-+         StorageDead(_4);                 // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n-+         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n++         StorageDead(_4);                 // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n++         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n       }\n   }\n   "}, {"sha": "430573c7c05f474ee8692292a0e66ce2da5b966b", "filename": "src/test/mir-opt/instrument_coverage.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab2ae0404014b4fbc5a32a8c954fe6068b25f71/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs?ref=dab2ae0404014b4fbc5a32a8c954fe6068b25f71", "patch": "@@ -3,7 +3,8 @@\n // intrinsics, during codegen.\n \n // needs-profiler-support\n-// compile-flags: -Zinstrument-coverage\n+// ignore-windows\n+// compile-flags: -Zinstrument-coverage --remap-path-prefix={{src-base}}=/the/src\n // EMIT_MIR instrument_coverage.main.InstrumentCoverage.diff\n // EMIT_MIR instrument_coverage.bar.InstrumentCoverage.diff\n fn main() {\n@@ -18,3 +19,18 @@ fn main() {\n fn bar() -> bool {\n     true\n }\n+\n+// Note that the MIR with injected coverage intrinsics includes references to source locations,\n+// including the source file absolute path. Typically, MIR pretty print output with file\n+// references are safe because the file prefixes are substituted with `$DIR`, but in this case\n+// the file references are encoded as function arguments, with an `Operand` type representation\n+// (`Slice` `Allocation` interned byte array) that cannot be normalized by simple substitution.\n+//\n+// The first workaround is to use the `SourceMap`-supported `--remap-path-prefix` option; however,\n+// the implementation of the `--remap-path-prefix` option currently joins the new prefix and the\n+// remaining source path with an OS-specific path separator (`\\` on Windows). This difference still\n+// shows up in the byte array representation of the path, causing Windows tests to fail to match\n+// blessed results baselined with a `/` path separator.\n+//\n+// Since this `mir-opt` test does not have any significant platform dependencies, other than the\n+// path separator differences, the final workaround is to disable testing on Windows."}]}