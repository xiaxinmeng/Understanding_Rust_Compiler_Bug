{"sha": "1e2291c90ce753ab200c5d3902fc1c63aebada76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMjI5MWM5MGNlNzUzYWIyMDBjNWQzOTAyZmMxYzYzYWViYWRhNzY=", "commit": {"author": {"name": "Oliver S\u0336c\u0336h\u0336n\u0336e\u0336i\u0336d\u0336e\u0336r Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-26T12:37:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-26T12:37:46Z"}, "message": "Merge pull request #3365 from gnieto/lint/slow-initialization\n\nAdd slow vector initializations lint", "tree": {"sha": "bc0cc29dff38cc53a68cb624813b0b24c5378084", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc0cc29dff38cc53a68cb624813b0b24c5378084"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e2291c90ce753ab200c5d3902fc1c63aebada76", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb++kaCRBK7hj4Ov3rIwAAdHIIAHFX7rUZ2RHOI6300TeDQ25d\nNztPLVe0lAoT1I/LrB5GTAJxYZ7zdFgH7ukmWNXUJBWYEeU7W3hvNlh9sBN8yjZ7\n8NeKnLzL6uQoQ8NKV7rUfWA0acrxL9GsOpdrUgaCVCc72SI1mfS3n/LRFfOHWWhj\nFAgSV8MJ0zrWaBEFEf5IC4//rEDkYFrrFn96ErmryuG/+r/P6n2sgrhs7zLev63R\nyM0hgufk0grl+MuGRDL72rNQlg3U9RahDAh280wOm+XqMQdxGvpIt6QAYilfdJvC\nnOwJ30yqG9nGDGmUFJWRGIlOTro82PdGSQO01CnIqaieXUItBCxWk0KvsnYp6fs=\n=9KX1\n-----END PGP SIGNATURE-----\n", "payload": "tree bc0cc29dff38cc53a68cb624813b0b24c5378084\nparent 03498fd502c1746e968d91244f8d48a8a061e245\nparent dc35841be4dd7efad4205e6d2d9f183b5866f6f6\nauthor Oliver S\u0336c\u0336h\u0336n\u0336e\u0336i\u0336d\u0336e\u0336r Scherer <github35764891676564198441@oli-obk.de> 1543235866 +0100\ncommitter GitHub <noreply@github.com> 1543235866 +0100\n\nMerge pull request #3365 from gnieto/lint/slow-initialization\n\nAdd slow vector initializations lint"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e2291c90ce753ab200c5d3902fc1c63aebada76", "html_url": "https://github.com/rust-lang/rust/commit/1e2291c90ce753ab200c5d3902fc1c63aebada76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e2291c90ce753ab200c5d3902fc1c63aebada76/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03498fd502c1746e968d91244f8d48a8a061e245", "url": "https://api.github.com/repos/rust-lang/rust/commits/03498fd502c1746e968d91244f8d48a8a061e245", "html_url": "https://github.com/rust-lang/rust/commit/03498fd502c1746e968d91244f8d48a8a061e245"}, {"sha": "dc35841be4dd7efad4205e6d2d9f183b5866f6f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc35841be4dd7efad4205e6d2d9f183b5866f6f6", "html_url": "https://github.com/rust-lang/rust/commit/dc35841be4dd7efad4205e6d2d9f183b5866f6f6"}], "stats": {"total": 562, "additions": 561, "deletions": 1}, "files": [{"sha": "320a3511e5c53a3155e0da8533b6498e12183f2f", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2291c90ce753ab200c5d3902fc1c63aebada76/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/1e2291c90ce753ab200c5d3902fc1c63aebada76/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=1e2291c90ce753ab200c5d3902fc1c63aebada76", "patch": "@@ -842,6 +842,7 @@ All notable changes to this project will be documented in this file.\n [`single_char_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_pattern\n [`single_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match\n [`single_match_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match_else\n+[`slow_vector_initialization`]: https://rust-lang.github.io/rust-clippy/master/index.html#slow_vector_initialization\n [`str_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#str_to_string\n [`string_add`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_add\n [`string_add_assign`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_add_assign\n@@ -880,6 +881,7 @@ All notable changes to this project will be documented in this file.\n [`unneeded_field_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_field_pattern\n [`unreadable_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#unreadable_literal\n [`unsafe_removed_from_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#unsafe_removed_from_name\n+[`unsafe_vector_initialization`]: https://rust-lang.github.io/rust-clippy/master/index.html#unsafe_vector_initialization\n [`unseparated_literal_suffix`]: https://rust-lang.github.io/rust-clippy/master/index.html#unseparated_literal_suffix\n [`unstable_as_mut_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#unstable_as_mut_slice\n [`unstable_as_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#unstable_as_slice"}, {"sha": "9d142a2deee8ec01f966e008a210d9ae2971b609", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2291c90ce753ab200c5d3902fc1c63aebada76/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/1e2291c90ce753ab200c5d3902fc1c63aebada76/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=1e2291c90ce753ab200c5d3902fc1c63aebada76", "patch": "@@ -9,7 +9,7 @@ We are currently in the process of discussing Clippy 1.0 via the RFC process in\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 288 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are 290 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "35f47c1cde4341eec0ffce14d342a0ba534fb9c8", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e2291c90ce753ab200c5d3902fc1c63aebada76/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2291c90ce753ab200c5d3902fc1c63aebada76/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=1e2291c90ce753ab200c5d3902fc1c63aebada76", "patch": "@@ -190,6 +190,7 @@ pub mod replace_consts;\n pub mod returns;\n pub mod serde_api;\n pub mod shadow;\n+pub mod slow_vector_initialization;\n pub mod strings;\n pub mod suspicious_trait_impl;\n pub mod swap;\n@@ -459,6 +460,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box non_copy_const::NonCopyConst);\n     reg.register_late_lint_pass(box ptr_offset_with_cast::Pass);\n     reg.register_late_lint_pass(box redundant_clone::RedundantClone);\n+    reg.register_late_lint_pass(box slow_vector_initialization::Pass);\n \n     reg.register_lint_group(\"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -709,6 +711,8 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         returns::NEEDLESS_RETURN,\n         returns::UNUSED_UNIT,\n         serde_api::SERDE_API_MISUSE,\n+        slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n+        slow_vector_initialization::UNSAFE_VECTOR_INITIALIZATION,\n         strings::STRING_LIT_AS_BYTES,\n         suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL,\n         suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL,\n@@ -955,6 +959,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         ranges::ITERATOR_STEP_BY_ZERO,\n         regex::INVALID_REGEX,\n         serde_api::SERDE_API_MISUSE,\n+        slow_vector_initialization::UNSAFE_VECTOR_INITIALIZATION,\n         suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL,\n         suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL,\n         swap::ALMOST_SWAPPED,\n@@ -980,6 +985,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         methods::SINGLE_CHAR_PATTERN,\n         misc::CMP_OWNED,\n         mutex_atomic::MUTEX_ATOMIC,\n+        slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n         trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF,\n         types::BOX_VEC,\n         vec::USELESS_VEC,"}, {"sha": "272047bc7cb0f9591474672cee3d29d144267761", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/1e2291c90ce753ab200c5d3902fc1c63aebada76/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2291c90ce753ab200c5d3902fc1c63aebada76/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=1e2291c90ce753ab200c5d3902fc1c63aebada76", "patch": "@@ -0,0 +1,398 @@\n+// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use crate::rustc::hir::intravisit::{walk_expr, walk_stmt, walk_block, NestedVisitorMap, Visitor};\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, Lint};\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc::hir::*;\n+use if_chain::if_chain;\n+use crate::syntax_pos::symbol::Symbol;\n+use crate::syntax::ast::{LitKind, NodeId};\n+use crate::utils::{match_qpath, span_lint_and_then, SpanlessEq, get_enclosing_block};\n+use crate::utils::sugg::Sugg;\n+use crate::rustc_errors::{Applicability};\n+\n+/// **What it does:** Checks slow zero-filled vector initialization\n+///\n+/// **Why is this bad?** This structures are non-idiomatic and less efficient than simply using\n+/// `vec![len; 0]`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let mut vec1 = Vec::with_capacity(len);\n+/// vec1.resize(len, 0);\n+///\n+/// let mut vec2 = Vec::with_capacity(len);\n+/// vec2.extend(repeat(0).take(len))\n+/// ```\n+declare_clippy_lint! {\n+    pub SLOW_VECTOR_INITIALIZATION,\n+    perf,\n+    \"slow vector initialization\"\n+}\n+\n+/// **What it does:** Checks unsafe vector initialization\n+///\n+/// **Why is this bad?** Changing the length of a vector may expose uninitialized memory, which\n+/// can lead to memory safety issues\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let mut vec1 = Vec::with_capacity(len);\n+/// unsafe { vec1.set_len(len); }\n+/// ```\n+declare_clippy_lint! {\n+    pub UNSAFE_VECTOR_INITIALIZATION,\n+    correctness,\n+    \"unsafe vector initialization\"\n+}\n+\n+#[derive(Copy, Clone, Default)]\n+pub struct Pass;\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(\n+            SLOW_VECTOR_INITIALIZATION,\n+            UNSAFE_VECTOR_INITIALIZATION,\n+        )\n+    }\n+}\n+\n+/// `VecAllocation` contains data regarding a vector allocated with `with_capacity` and then\n+/// assigned to a variable. For example, `let mut vec = Vec::with_capacity(0)` or\n+/// `vec = Vec::with_capacity(0)`\n+struct VecAllocation<'tcx> {\n+    /// Symbol of the local variable name\n+    variable_name: Symbol,\n+\n+    /// Reference to the expression which allocates the vector\n+    allocation_expr: &'tcx Expr,\n+\n+    /// Reference to the expression used as argument on `with_capacity` call. This is used\n+    /// to only match slow zero-filling idioms of the same length than vector initialization.\n+    len_expr: &'tcx Expr,\n+}\n+\n+/// Type of slow initialization\n+enum InitializationType<'tcx> {\n+    /// Extend is a slow initialization with the form `vec.extend(repeat(0).take(..))`\n+    Extend(&'tcx Expr),\n+\n+    /// Resize is a slow initialization with the form `vec.resize(.., 0)`\n+    Resize(&'tcx Expr),\n+\n+    /// UnsafeSetLen is a slow initialization with the form `vec.set_len(..)`\n+    UnsafeSetLen(&'tcx Expr),\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        // Matches initialization on reassignements. For example: `vec = Vec::with_capacity(100)`\n+        if_chain! {\n+            if let ExprKind::Assign(ref left, ref right) = expr.node;\n+\n+            // Extract variable name\n+            if let ExprKind::Path(QPath::Resolved(_, ref path)) = left.node;\n+            if let Some(variable_name) = path.segments.get(0);\n+\n+            // Extract len argument\n+            if let Some(ref len_arg) = Self::is_vec_with_capacity(right);\n+\n+            then {\n+                let vi = VecAllocation {\n+                    variable_name: variable_name.ident.name,\n+                    allocation_expr: right,\n+                    len_expr: len_arg,\n+                };\n+\n+                Self::search_initialization(cx, vi, expr.id);\n+            }\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n+        // Matches statements which initializes vectors. For example: `let mut vec = Vec::with_capacity(10)`\n+        if_chain! {\n+            if let StmtKind::Decl(ref decl, _) = stmt.node;\n+            if let DeclKind::Local(ref local) = decl.node;\n+            if let PatKind::Binding(BindingAnnotation::Mutable, _, variable_name, None) = local.pat.node;\n+            if let Some(ref init) = local.init;\n+            if let Some(ref len_arg) = Self::is_vec_with_capacity(init);\n+\n+            then {\n+                let vi = VecAllocation {\n+                    variable_name: variable_name.name,\n+                    allocation_expr: init,\n+                    len_expr: len_arg,\n+                };\n+\n+                Self::search_initialization(cx, vi, stmt.node.id());\n+            }\n+        }\n+    }\n+}\n+\n+impl Pass {\n+    /// Checks if the given expression is `Vec::with_capacity(..)`. It will return the expression\n+    /// of the first argument of `with_capacity` call if it matches or `None` if it does not.\n+    fn is_vec_with_capacity(expr: &Expr) -> Option<&Expr> {\n+        if_chain! {\n+            if let ExprKind::Call(ref func, ref args) = expr.node;\n+            if let ExprKind::Path(ref path) = func.node;\n+            if match_qpath(path, &[\"Vec\", \"with_capacity\"]);\n+            if args.len() == 1;\n+\n+            then {\n+                return Some(&args[0]);\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Search initialization for the given vector\n+    fn search_initialization<'tcx>(\n+        cx: &LateContext<'_, 'tcx>,\n+        vec_alloc: VecAllocation<'tcx>,\n+        parent_node: NodeId\n+    ) {\n+        let enclosing_body = get_enclosing_block(cx, parent_node);\n+\n+        if enclosing_body.is_none() {\n+            return;\n+        }\n+\n+        let mut v = VectorInitializationVisitor {\n+            cx,\n+            vec_alloc,\n+            slow_expression: None,\n+            initialization_found: false,\n+        };\n+\n+        v.visit_block(enclosing_body.unwrap());\n+\n+        if let Some(ref allocation_expr) = v.slow_expression {\n+            Self::lint_initialization(cx, allocation_expr, &v.vec_alloc);\n+        }\n+    }\n+\n+    fn lint_initialization<'tcx>(cx: &LateContext<'_, 'tcx>, initialization: &InitializationType<'tcx>, vec_alloc: &VecAllocation<'_>) {\n+        match initialization {\n+            InitializationType::UnsafeSetLen(e) =>\n+                Self::emit_lint(\n+                    cx,\n+                    e,\n+                    vec_alloc,\n+                    \"unsafe vector initialization\",\n+                    UNSAFE_VECTOR_INITIALIZATION\n+                ),\n+\n+            InitializationType::Extend(e) |\n+            InitializationType::Resize(e) =>\n+                Self::emit_lint(\n+                    cx,\n+                    e,\n+                    vec_alloc,\n+                    \"slow zero-filling initialization\",\n+                    SLOW_VECTOR_INITIALIZATION\n+                )\n+        };\n+    }\n+\n+    fn emit_lint<'tcx>(\n+        cx: &LateContext<'_, 'tcx>,\n+        slow_fill: &Expr,\n+        vec_alloc: &VecAllocation<'_>,\n+        msg: &str,\n+        lint: &'static Lint\n+    ) {\n+        let len_expr = Sugg::hir(cx, vec_alloc.len_expr, \"len\");\n+\n+        span_lint_and_then(\n+            cx,\n+            lint,\n+            slow_fill.span,\n+            msg,\n+            |db| {\n+                db.span_suggestion_with_applicability(\n+                    vec_alloc.allocation_expr.span,\n+                    \"consider replace allocation with\",\n+                    format!(\"vec![0; {}]\", len_expr),\n+                    Applicability::Unspecified\n+                );\n+            }\n+        );\n+    }\n+}\n+\n+/// `VectorInitializationVisitor` searches for unsafe or slow vector initializations for the given\n+/// vector.\n+struct VectorInitializationVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+\n+    /// Contains the information\n+    vec_alloc: VecAllocation<'tcx>,\n+\n+    /// Contains, if found, the slow initialization expression\n+    slow_expression: Option<InitializationType<'tcx>>,\n+\n+    /// true if the initialization of the vector has been found on the visited block\n+    initialization_found: bool,\n+}\n+\n+impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n+    /// Checks if the given expression is extending a vector with `repeat(0).take(..)`\n+    fn search_slow_extend_filling(&mut self, expr: &'tcx Expr) {\n+        if_chain! {\n+            if self.initialization_found;\n+            if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath_subj) = args[0].node;\n+            if match_qpath(&qpath_subj, &[&self.vec_alloc.variable_name.to_string()]);\n+            if path.ident.name == \"extend\";\n+            if let Some(ref extend_arg) = args.get(1);\n+            if self.is_repeat_take(extend_arg);\n+\n+            then {\n+                self.slow_expression = Some(InitializationType::Extend(expr));\n+            }\n+        }\n+    }\n+\n+    /// Checks if the given expression is resizing a vector with 0\n+    fn search_slow_resize_filling(&mut self, expr: &'tcx Expr) {\n+        if_chain! {\n+            if self.initialization_found;\n+            if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath_subj) = args[0].node;\n+            if match_qpath(&qpath_subj, &[&self.vec_alloc.variable_name.to_string()]);\n+            if path.ident.name == \"resize\";\n+            if let (Some(ref len_arg), Some(fill_arg)) = (args.get(1), args.get(2));\n+\n+            // Check that is filled with 0\n+            if let ExprKind::Lit(ref lit) = fill_arg.node;\n+            if let LitKind::Int(0, _) = lit.node;\n+\n+            // Check that len expression is equals to `with_capacity` expression\n+            if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr);\n+\n+            then {\n+                self.slow_expression = Some(InitializationType::Resize(expr));\n+            }\n+        }\n+    }\n+\n+    /// Checks if the given expression is using `set_len` to initialize the vector\n+    fn search_unsafe_set_len(&mut self, expr: &'tcx Expr) {\n+        if_chain! {\n+            if self.initialization_found;\n+            if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath_subj) = args[0].node;\n+            if match_qpath(&qpath_subj, &[&self.vec_alloc.variable_name.to_string()]);\n+            if path.ident.name == \"set_len\";\n+            if let Some(ref len_arg) = args.get(1);\n+\n+            // Check that len expression is equals to `with_capacity` expression\n+            if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr);\n+\n+            then {\n+                self.slow_expression = Some(InitializationType::UnsafeSetLen(expr));\n+            }\n+        }\n+    }\n+\n+    /// Returns `true` if give expression is `repeat(0).take(...)`\n+    fn is_repeat_take(&self, expr: &Expr) -> bool {\n+        if_chain! {\n+            if let ExprKind::MethodCall(ref take_path, _, ref take_args) = expr.node;\n+            if take_path.ident.name == \"take\";\n+\n+            // Check that take is applied to `repeat(0)`\n+            if let Some(ref repeat_expr) = take_args.get(0);\n+            if self.is_repeat_zero(repeat_expr);\n+\n+            // Check that len expression is equals to `with_capacity` expression\n+            if let Some(ref len_arg) = take_args.get(1);\n+            if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr);\n+\n+            then {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    /// Returns `true` if given expression is `repeat(0)`\n+    fn is_repeat_zero(&self, expr: &Expr) -> bool {\n+        if_chain! {\n+            if let ExprKind::Call(ref fn_expr, ref repeat_args) = expr.node;\n+            if let ExprKind::Path(ref qpath_repeat) = fn_expr.node;\n+            if match_qpath(&qpath_repeat, &[\"repeat\"]);\n+            if let Some(ref repeat_arg) = repeat_args.get(0);\n+            if let ExprKind::Lit(ref lit) = repeat_arg.node;\n+            if let LitKind::Int(0, _) = lit.node;\n+\n+            then {\n+                return true\n+            }\n+        }\n+\n+        false\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n+        if self.initialization_found {\n+            match stmt.node {\n+                StmtKind::Expr(ref expr, _) |\n+                StmtKind::Semi(ref expr, _) => {\n+                    self.search_slow_extend_filling(expr);\n+                    self.search_slow_resize_filling(expr);\n+                    self.search_unsafe_set_len(expr);\n+                },\n+                _ => (),\n+            }\n+\n+            self.initialization_found = false;\n+        } else {\n+            walk_stmt(self, stmt);\n+        }\n+    }\n+\n+    fn visit_block(&mut self, block: &'tcx Block) {\n+        if self.initialization_found {\n+            if let Some(ref s) = block.stmts.get(0) {\n+                self.visit_stmt( s)\n+            }\n+\n+            self.initialization_found = false;\n+        } else {\n+            walk_block(self, block);\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        // Skip all the expressions previous to the vector initialization\n+        if self.vec_alloc.allocation_expr.id == expr.id {\n+            self.initialization_found = true;\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "daa6b9c13769d97a14f9802a966f50d8888fb3e7", "filename": "tests/ui/slow_vector_initialization.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1e2291c90ce753ab200c5d3902fc1c63aebada76/tests%2Fui%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2291c90ce753ab200c5d3902fc1c63aebada76/tests%2Fui%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fslow_vector_initialization.rs?ref=1e2291c90ce753ab200c5d3902fc1c63aebada76", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter::repeat;\n+\n+fn main() {\n+    resize_vector();\n+    extend_vector();\n+    mixed_extend_resize_vector();\n+    unsafe_vector();\n+}\n+\n+fn extend_vector() {\n+    // Extend with constant expression\n+    let len = 300;\n+    let mut vec1 = Vec::with_capacity(len);\n+    vec1.extend(repeat(0).take(len));\n+\n+    // Extend with len expression\n+    let mut vec2 = Vec::with_capacity(len - 10);\n+    vec2.extend(repeat(0).take(len - 10));\n+\n+    // Extend with mismatching expression should not be warned\n+    let mut vec3 = Vec::with_capacity(24322);\n+    vec3.extend(repeat(0).take(2));\n+}\n+\n+fn mixed_extend_resize_vector() {\n+    // Mismatching len\n+    let mut mismatching_len = Vec::with_capacity(30);\n+    mismatching_len.extend(repeat(0).take(40));\n+\n+    // Slow initialization\n+    let mut resized_vec = Vec::with_capacity(30);\n+    resized_vec.resize(30, 0);\n+\n+    let mut extend_vec = Vec::with_capacity(30);\n+    extend_vec.extend(repeat(0).take(30));\n+}\n+\n+fn resize_vector() {\n+    // Resize with constant expression\n+    let len = 300;\n+    let mut vec1 = Vec::with_capacity(len);\n+    vec1.resize(len, 0);\n+\n+    // Resize mismatch len\n+    let mut vec2 = Vec::with_capacity(200);\n+    vec2.resize(10, 0);\n+\n+    // Resize with len expression\n+    let mut vec3 = Vec::with_capacity(len - 10);\n+    vec3.resize(len - 10, 0);\n+\n+    // Reinitialization should be warned\n+    vec1 = Vec::with_capacity(10);\n+    vec1.resize(10, 0);\n+}\n+\n+fn unsafe_vector() {\n+    let mut unsafe_vec: Vec<u8> = Vec::with_capacity(200);\n+\n+    unsafe {\n+        unsafe_vec.set_len(200);\n+    }\n+}\n+\n+fn do_stuff(vec: &mut Vec<u8>) {\n+\n+}\n+\n+fn extend_vector_with_manipulations_between() {\n+    let len = 300;\n+    let mut vec1:Vec<u8> = Vec::with_capacity(len);\n+    do_stuff(&mut vec1);\n+    vec1.extend(repeat(0).take(len));\n+}"}, {"sha": "577cc82c6d52f82a8cf8202d6f86cb3137c55730", "filename": "tests/ui/slow_vector_initialization.stderr", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1e2291c90ce753ab200c5d3902fc1c63aebada76/tests%2Fui%2Fslow_vector_initialization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e2291c90ce753ab200c5d3902fc1c63aebada76/tests%2Fui%2Fslow_vector_initialization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fslow_vector_initialization.stderr?ref=1e2291c90ce753ab200c5d3902fc1c63aebada76", "patch": "@@ -0,0 +1,71 @@\n+error: slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:23:5\n+   |\n+22 |     let mut vec1 = Vec::with_capacity(len);\n+   |                    ----------------------- help: consider replace allocation with: `vec![0; len]`\n+23 |     vec1.extend(repeat(0).take(len));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::slow-vector-initialization` implied by `-D warnings`\n+\n+error: slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:27:5\n+   |\n+26 |     let mut vec2 = Vec::with_capacity(len - 10);\n+   |                    ---------------------------- help: consider replace allocation with: `vec![0; len - 10]`\n+27 |     vec2.extend(repeat(0).take(len - 10));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:41:5\n+   |\n+40 |     let mut resized_vec = Vec::with_capacity(30);\n+   |                           ---------------------- help: consider replace allocation with: `vec![0; 30]`\n+41 |     resized_vec.resize(30, 0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:44:5\n+   |\n+43 |     let mut extend_vec = Vec::with_capacity(30);\n+   |                          ---------------------- help: consider replace allocation with: `vec![0; 30]`\n+44 |     extend_vec.extend(repeat(0).take(30));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:51:5\n+   |\n+50 |     let mut vec1 = Vec::with_capacity(len);\n+   |                    ----------------------- help: consider replace allocation with: `vec![0; len]`\n+51 |     vec1.resize(len, 0);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:59:5\n+   |\n+58 |     let mut vec3 = Vec::with_capacity(len - 10);\n+   |                    ---------------------------- help: consider replace allocation with: `vec![0; len - 10]`\n+59 |     vec3.resize(len - 10, 0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:63:5\n+   |\n+62 |     vec1 = Vec::with_capacity(10);\n+   |            ---------------------- help: consider replace allocation with: `vec![0; 10]`\n+63 |     vec1.resize(10, 0);\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: unsafe vector initialization\n+  --> $DIR/slow_vector_initialization.rs:70:9\n+   |\n+67 |     let mut unsafe_vec: Vec<u8> = Vec::with_capacity(200);\n+   |                                   ----------------------- help: consider replace allocation with: `vec![0; 200]`\n+...\n+70 |         unsafe_vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[deny(clippy::unsafe_vector_initialization)] on by default\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/slow_vector_initialization.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1e2291c90ce753ab200c5d3902fc1c63aebada76/tests%2Fui%2Fslow_vector_initialization.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1e2291c90ce753ab200c5d3902fc1c63aebada76/tests%2Fui%2Fslow_vector_initialization.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fslow_vector_initialization.stdout?ref=1e2291c90ce753ab200c5d3902fc1c63aebada76"}]}