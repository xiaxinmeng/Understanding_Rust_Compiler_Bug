{"sha": "8b7c3f20e83de20518abb879f7a0e41b6e93414f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiN2MzZjIwZTgzZGUyMDUxOGFiYjg3OWY3YTBlNDFiNmU5MzQxNGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-08T04:06:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-08T04:06:17Z"}, "message": "Auto merge of #29734 - Ryman:whitespace_consistency, r=Aatch\n\nlibsyntax: be more accepting of whitespace in lexer\n\nFixes #29590.\n\nPerhaps this may need more thorough testing?\n\nr? @Aatch", "tree": {"sha": "d04a59bc3bfb143972d35059a2da9b8052e13f86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d04a59bc3bfb143972d35059a2da9b8052e13f86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b7c3f20e83de20518abb879f7a0e41b6e93414f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b7c3f20e83de20518abb879f7a0e41b6e93414f", "html_url": "https://github.com/rust-lang/rust/commit/8b7c3f20e83de20518abb879f7a0e41b6e93414f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b7c3f20e83de20518abb879f7a0e41b6e93414f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4352a8554f3765b98d27c1a0b1a170414f82b199", "url": "https://api.github.com/repos/rust-lang/rust/commits/4352a8554f3765b98d27c1a0b1a170414f82b199", "html_url": "https://github.com/rust-lang/rust/commit/4352a8554f3765b98d27c1a0b1a170414f82b199"}, {"sha": "24578e0fe555f267bef40528b8ac79bc7e898007", "url": "https://api.github.com/repos/rust-lang/rust/commits/24578e0fe555f267bef40528b8ac79bc7e898007", "html_url": "https://github.com/rust-lang/rust/commit/24578e0fe555f267bef40528b8ac79bc7e898007"}], "stats": {"total": 175, "additions": 111, "deletions": 64}, "files": [{"sha": "ffdfec41c8f87ec86f481512e0e099d1b9403e6a", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b7c3f20e83de20518abb879f7a0e41b6e93414f/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/8b7c3f20e83de20518abb879f7a0e41b6e93414f/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=8b7c3f20e83de20518abb879f7a0e41b6e93414f", "patch": "@@ -87,7 +87,7 @@ DEPS_serialize := std log\n DEPS_term := std log\n DEPS_test := std getopts serialize rbml term native:rust_test_helpers\n \n-DEPS_syntax := std term serialize log arena libc rustc_bitflags\n+DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode\n DEPS_syntax_ext := syntax fmt_macros\n \n DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml rustc_front\\"}, {"sha": "5a7632868e467202379324d00f36931ed15e583a", "filename": "src/etc/unicode.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=8b7c3f20e83de20518abb879f7a0e41b6e93414f", "patch": "@@ -398,7 +398,7 @@ def emit_norm_module(f, canon, compat, combine, norm_props):\n         derived = load_properties(\"DerivedCoreProperties.txt\", want_derived)\n         scripts = load_properties(\"Scripts.txt\", [])\n         props = load_properties(\"PropList.txt\",\n-                [\"White_Space\", \"Join_Control\", \"Noncharacter_Code_Point\"])\n+                [\"White_Space\", \"Join_Control\", \"Noncharacter_Code_Point\", \"Pattern_White_Space\"])\n         norm_props = load_properties(\"DerivedNormalizationProps.txt\",\n                      [\"Full_Composition_Exclusion\"])\n \n@@ -408,7 +408,7 @@ def emit_norm_module(f, canon, compat, combine, norm_props):\n         # category tables\n         for (name, cat, pfuns) in (\"general_category\", gencats, [\"N\", \"Cc\"]), \\\n                                   (\"derived_property\", derived, want_derived), \\\n-                                  (\"property\", props, [\"White_Space\"]):\n+                                  (\"property\", props, [\"White_Space\", \"Pattern_White_Space\"]):\n             emit_property_module(rf, name, cat, pfuns)\n \n         # normalizations and conversions module"}, {"sha": "fb85176340e9267c4e8a5041bc327da7c2ea0e95", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=8b7c3f20e83de20518abb879f7a0e41b6e93414f", "patch": "@@ -51,3 +51,8 @@ pub mod str {\n pub mod derived_property {\n     pub use tables::derived_property::{Cased, Case_Ignorable};\n }\n+\n+// For use in libsyntax\n+pub mod property {\n+    pub use tables::property::Pattern_White_Space;\n+}"}, {"sha": "ad17016eae8cbb8b4b6ce47c2b19e129b3cd1c7d", "filename": "src/librustc_unicode/tables.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Flibrustc_unicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Flibrustc_unicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Ftables.rs?ref=8b7c3f20e83de20518abb879f7a0e41b6e93414f", "patch": "@@ -1180,6 +1180,15 @@ pub mod derived_property {\n }\n \n pub mod property {\n+    pub const Pattern_White_Space_table: &'static [(char, char)] = &[\n+        ('\\u{9}', '\\u{d}'), ('\\u{20}', '\\u{20}'), ('\\u{85}', '\\u{85}'), ('\\u{200e}', '\\u{200f}'),\n+        ('\\u{2028}', '\\u{2029}')\n+    ];\n+\n+    pub fn Pattern_White_Space(c: char) -> bool {\n+        super::bsearch_range_table(c, Pattern_White_Space_table)\n+    }\n+\n     pub const White_Space_table: &'static [(char, char)] = &[\n         ('\\u{9}', '\\u{d}'), ('\\u{20}', '\\u{20}'), ('\\u{85}', '\\u{85}'), ('\\u{a0}', '\\u{a0}'),\n         ('\\u{1680}', '\\u{1680}'), ('\\u{2000}', '\\u{200a}'), ('\\u{2028}', '\\u{2029}'), ('\\u{202f}',"}, {"sha": "04a3cf096baf024994aec9da4e05336132926d34", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=8b7c3f20e83de20518abb879f7a0e41b6e93414f", "patch": "@@ -38,6 +38,7 @@ extern crate term;\n extern crate libc;\n #[macro_use] extern crate log;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n+extern crate rustc_unicode;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "629edced804f51f015f88e89989caa5fc294a485", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=8b7c3f20e83de20518abb879f7a0e41b6e93414f", "patch": "@@ -15,7 +15,7 @@ use codemap::{BytePos, CharPos, CodeMap, Pos};\n use errors;\n use parse::lexer::is_block_doc_comment;\n use parse::lexer::{StringReader, TokenAndSpan};\n-use parse::lexer::{is_whitespace, Reader};\n+use parse::lexer::{is_pattern_whitespace, Reader};\n use parse::lexer;\n use print::pprust;\n use str::char_at;\n@@ -153,7 +153,7 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment>) {\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: &mut StringReader, comments: &mut Vec<Comment>) {\n-    while is_whitespace(rdr.curr) && !rdr.is_eof() {\n+    while is_pattern_whitespace(rdr.curr) && !rdr.is_eof() {\n         if rdr.col == CharPos(0) && rdr.curr_is('\\n') {\n             push_blank_line_comment(rdr, &mut *comments);\n         }"}, {"sha": "a5cb5c7117e212d64bd82e32fc9a2d426161de74", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=8b7c3f20e83de20518abb879f7a0e41b6e93414f", "patch": "@@ -16,6 +16,7 @@ use ext::tt::transcribe::tt_next_token;\n use parse::token::str_to_ident;\n use parse::token;\n use str::char_at;\n+use rustc_unicode::property::Pattern_White_Space;\n \n use std::borrow::Cow;\n use std::char;\n@@ -546,10 +547,10 @@ impl<'a> StringReader<'a> {\n                 let c = self.scan_comment();\n                 debug!(\"scanning a comment {:?}\", c);\n                 c\n-            }\n-            c if is_whitespace(Some(c)) => {\n+            },\n+            c if is_pattern_whitespace(Some(c)) => {\n                 let start_bpos = self.last_pos;\n-                while is_whitespace(self.curr) {\n+                while is_pattern_whitespace(self.curr) {\n                     self.bump();\n                 }\n                 let c = Some(TokenAndSpan {\n@@ -1440,7 +1441,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     fn consume_whitespace(&mut self) {\n-        while is_whitespace(self.curr) && !self.is_eof() {\n+        while is_pattern_whitespace(self.curr) && !self.is_eof() {\n             self.bump();\n         }\n     }\n@@ -1465,7 +1466,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     fn consume_non_eol_whitespace(&mut self) {\n-        while is_whitespace(self.curr) && !self.curr_is('\\n') && !self.is_eof() {\n+        while is_pattern_whitespace(self.curr) && !self.curr_is('\\n') && !self.is_eof() {\n             self.bump();\n         }\n     }\n@@ -1596,11 +1597,10 @@ impl<'a> StringReader<'a> {\n     }\n }\n \n-pub fn is_whitespace(c: Option<char>) -> bool {\n-    match c.unwrap_or('\\x00') { // None can be null for now... it's not whitespace\n-        ' ' | '\\n' | '\\t' | '\\r' => true,\n-        _ => false,\n-    }\n+// This tests the character for the unicode property 'PATTERN_WHITE_SPACE' which\n+// is guaranteed to be forward compatible. http://unicode.org/reports/tr31/#R3\n+pub fn is_pattern_whitespace(c: Option<char>) -> bool {\n+    c.map_or(false, Pattern_White_Space)\n }\n \n fn in_range(c: Option<char>, lo: char, hi: char) -> bool {"}, {"sha": "8358af69b6666dc0a5b7f2c85ba1863c12b6113a", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=8b7c3f20e83de20518abb879f7a0e41b6e93414f", "patch": "@@ -10,11 +10,11 @@\n \n use ast;\n use parse::{ParseSess,PResult,filemap_to_tts};\n-use parse::new_parser_from_source_str;\n+use parse::{lexer, new_parser_from_source_str};\n use parse::parser::Parser;\n use parse::token;\n use ptr::P;\n-use str::char_at;\n+use std::iter::Peekable;\n \n /// Map a string to tts, using a made-up filename:\n pub fn string_to_tts(source_str: String) -> Vec<ast::TokenTree> {\n@@ -87,69 +87,62 @@ pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<ast::Ident> {\n \n /// Does the given string match the pattern? whitespace in the first string\n /// may be deleted or replaced with other whitespace to match the pattern.\n-/// this function is Unicode-ignorant; fortunately, the careful design of\n-/// UTF-8 mitigates this ignorance.  In particular, this function only collapses\n-/// sequences of \\n, \\r, ' ', and \\t, but it should otherwise tolerate Unicode\n-/// chars. Unsurprisingly, it doesn't do NKF-normalization(?).\n+/// This function is relatively Unicode-ignorant; fortunately, the careful design\n+/// of UTF-8 mitigates this ignorance. It doesn't do NKF-normalization(?).\n pub fn matches_codepattern(a : &str, b : &str) -> bool {\n-    let mut idx_a = 0;\n-    let mut idx_b = 0;\n+    let mut a_iter = a.chars().peekable();\n+    let mut b_iter = b.chars().peekable();\n+\n     loop {\n-        if idx_a == a.len() && idx_b == b.len() {\n-            return true;\n-        }\n-        else if idx_a == a.len() {return false;}\n-        else if idx_b == b.len() {\n-            // maybe the stuff left in a is all ws?\n-            if is_whitespace(char_at(a, idx_a)) {\n-                return scan_for_non_ws_or_end(a,idx_a) == a.len();\n-            } else {\n-                return false;\n+        let (a, b) = match (a_iter.peek(), b_iter.peek()) {\n+            (None, None) => return true,\n+            (None, _) => return false,\n+            (Some(&a), None) => {\n+                if is_pattern_whitespace(a) {\n+                    break // trailing whitespace check is out of loop for borrowck\n+                } else {\n+                    return false\n+                }\n             }\n-        }\n-        // ws in both given and pattern:\n-        else if is_whitespace(char_at(a, idx_a))\n-           && is_whitespace(char_at(b, idx_b)) {\n-            idx_a = scan_for_non_ws_or_end(a,idx_a);\n-            idx_b = scan_for_non_ws_or_end(b,idx_b);\n-        }\n-        // ws in given only:\n-        else if is_whitespace(char_at(a, idx_a)) {\n-            idx_a = scan_for_non_ws_or_end(a,idx_a);\n-        }\n-        // *don't* silently eat ws in expected only.\n-        else if char_at(a, idx_a) == char_at(b, idx_b) {\n-            idx_a += 1;\n-            idx_b += 1;\n-        }\n-        else {\n-            return false;\n+            (Some(&a), Some(&b)) => (a, b)\n+        };\n+\n+        if is_pattern_whitespace(a) && is_pattern_whitespace(b) {\n+            // skip whitespace for a and b\n+            scan_for_non_ws_or_end(&mut a_iter);\n+            scan_for_non_ws_or_end(&mut b_iter);\n+        } else if is_pattern_whitespace(a) {\n+            // skip whitespace for a\n+            scan_for_non_ws_or_end(&mut a_iter);\n+        } else if a == b {\n+            a_iter.next();\n+            b_iter.next();\n+        } else {\n+            return false\n         }\n     }\n+\n+    // check if a has *only* trailing whitespace\n+    a_iter.all(is_pattern_whitespace)\n }\n \n-/// Given a string and an index, return the first usize >= idx\n-/// that is a non-ws-char or is outside of the legal range of\n-/// the string.\n-fn scan_for_non_ws_or_end(a : &str, idx: usize) -> usize {\n-    let mut i = idx;\n-    let len = a.len();\n-    while (i < len) && (is_whitespace(char_at(a, i))) {\n-        i += 1;\n+/// Advances the given peekable `Iterator` until it reaches a non-whitespace character\n+fn scan_for_non_ws_or_end<I: Iterator<Item= char>>(iter: &mut Peekable<I>) {\n+    while lexer::is_pattern_whitespace(iter.peek().cloned()) {\n+        iter.next();\n     }\n-    i\n }\n \n-/// Copied from lexer.\n-pub fn is_whitespace(c: char) -> bool {\n-    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n+pub fn is_pattern_whitespace(c: char) -> bool {\n+    lexer::is_pattern_whitespace(Some(c))\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n \n-    #[test] fn eqmodws() {\n+    #[test]\n+    fn eqmodws() {\n         assert_eq!(matches_codepattern(\"\",\"\"),true);\n         assert_eq!(matches_codepattern(\"\",\"a\"),false);\n         assert_eq!(matches_codepattern(\"a\",\"\"),false);\n@@ -160,5 +153,22 @@ mod tests {\n         assert_eq!(matches_codepattern(\"a   b\",\"a b\"),true);\n         assert_eq!(matches_codepattern(\"ab\",\"a b\"),false);\n         assert_eq!(matches_codepattern(\"a   b\",\"ab\"),true);\n+        assert_eq!(matches_codepattern(\" a   b\",\"ab\"),true);\n+    }\n+\n+    #[test]\n+    fn pattern_whitespace() {\n+        assert_eq!(matches_codepattern(\"\",\"\\x0C\"), false);\n+        assert_eq!(matches_codepattern(\"a b \",\"a   \\u{0085}\\n\\t\\r  b\"),true);\n+        assert_eq!(matches_codepattern(\"a b\",\"a   \\u{0085}\\n\\t\\r  b \"),false);\n+    }\n+\n+    #[test]\n+    fn non_pattern_whitespace() {\n+        // These have the property 'White_Space' but not 'Pattern_White_Space'\n+        assert_eq!(matches_codepattern(\"a b\",\"a\\u{2002}b\"), false);\n+        assert_eq!(matches_codepattern(\"a   b\",\"a\\u{2002}b\"), false);\n+        assert_eq!(matches_codepattern(\"\\u{205F}a   b\",\"ab\"), false);\n+        assert_eq!(matches_codepattern(\"a  \\u{3000}b\",\"ab\"), false);\n     }\n }"}, {"sha": "837bb8339e1d14de183022feda8b90d0360eb44d", "filename": "src/test/run-pass/parser-unicode-whitespace.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Ftest%2Frun-pass%2Fparser-unicode-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b7c3f20e83de20518abb879f7a0e41b6e93414f/src%2Ftest%2Frun-pass%2Fparser-unicode-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fparser-unicode-whitespace.rs?ref=8b7c3f20e83de20518abb879f7a0e41b6e93414f", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// Beware editing: it has numerous whitespace characters which are important.\n+// It contains one ranges from the 'PATTERN_WHITE_SPACE' property outlined in\n+// http://unicode.org/Public/UNIDATA/PropList.txt\n+//\n+// The characters in the first expression of the assertion can be generated\n+// from: \"4\\u{0C}+\\n\\t\\r7\\t*\\u{20}2\\u{85}/\\u{200E}3\\u{200F}*\\u{2028}2\\u{2029}\"\n+pub fn main() {\n+assert_eq!(4\f+\n+\n+7   * 2\u0085/\u200e3\u200f*\u20282\u2029, 4 + 7 * 2 / 3 * 2);\n+}"}]}