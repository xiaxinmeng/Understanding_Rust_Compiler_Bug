{"sha": "b00147a99b289b11a210d9fc841b8aca3e59ce0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMDE0N2E5OWIyODliMTFhMjEwZDlmYzg0MWI4YWNhM2U1OWNlMGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-15T23:32:44Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T20:04:30Z"}, "message": "Add an AtomicU64 type to std::sync::atomics\n\nThis also generalizes all atomic intrinsics over T so we'll be able to add u8\natomics if we really feel the need to (do we really want to?)", "tree": {"sha": "e9ecbac3936c7f778d3d7e2ef278ba35ef07551f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9ecbac3936c7f778d3d7e2ef278ba35ef07551f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b00147a99b289b11a210d9fc841b8aca3e59ce0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b00147a99b289b11a210d9fc841b8aca3e59ce0e", "html_url": "https://github.com/rust-lang/rust/commit/b00147a99b289b11a210d9fc841b8aca3e59ce0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b00147a99b289b11a210d9fc841b8aca3e59ce0e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb40eba4b1ce12914612914b94bdccd251a9f554", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb40eba4b1ce12914612914b94bdccd251a9f554", "html_url": "https://github.com/rust-lang/rust/commit/cb40eba4b1ce12914612914b94bdccd251a9f554"}], "stats": {"total": 495, "additions": 398, "deletions": 97}, "files": [{"sha": "cedd98e261cc7a1c207b7ebf855ce9e74d297af0", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b00147a99b289b11a210d9fc841b8aca3e59ce0e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00147a99b289b11a210d9fc841b8aca3e59ce0e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=b00147a99b289b11a210d9fc841b8aca3e59ce0e", "patch": "@@ -15,7 +15,7 @@ use lib::llvm::{Opcode, IntPredicate, RealPredicate, False};\n use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use middle::trans::base;\n use middle::trans::common::*;\n-use middle::trans::machine::llalign_of_min;\n+use middle::trans::machine::llalign_of_pref;\n use middle::trans::type_::Type;\n use std::cast;\n use std::hashmap::HashMap;\n@@ -461,8 +461,10 @@ impl Builder {\n     pub fn atomic_load(&self, ptr: ValueRef, order: AtomicOrdering) -> ValueRef {\n         self.count_insn(\"load.atomic\");\n         unsafe {\n-            let align = llalign_of_min(self.ccx, self.ccx.int_type);\n-            llvm::LLVMBuildAtomicLoad(self.llbuilder, ptr, noname(), order, align as c_uint)\n+            let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n+            let align = llalign_of_pref(self.ccx, ty.element_type());\n+            llvm::LLVMBuildAtomicLoad(self.llbuilder, ptr, noname(), order,\n+                                      align as c_uint)\n         }\n     }\n \n@@ -514,8 +516,9 @@ impl Builder {\n                self.ccx.tn.val_to_str(val),\n                self.ccx.tn.val_to_str(ptr));\n         self.count_insn(\"store.atomic\");\n-        let align = llalign_of_min(self.ccx, self.ccx.int_type);\n         unsafe {\n+            let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n+            let align = llalign_of_pref(self.ccx, ty.element_type());\n             llvm::LLVMBuildAtomicStore(self.llbuilder, val, ptr, order, align as c_uint);\n         }\n     }"}, {"sha": "e1679c81a0e2db6c682337587d2b9927c53e864b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b00147a99b289b11a210d9fc841b8aca3e59ce0e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00147a99b289b11a210d9fc841b8aca3e59ce0e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b00147a99b289b11a210d9fc841b8aca3e59ce0e", "patch": "@@ -4030,29 +4030,32 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n \n         //We only care about the operation here\n         match split[1] {\n-            \"cxchg\" => (0, ~[ty::mk_mut_rptr(tcx,\n+            \"cxchg\" => (1, ~[ty::mk_mut_rptr(tcx,\n                                              ty::ReLateBound(it.id, ty::BrAnon(0)),\n-                                             ty::mk_int()),\n-                        ty::mk_int(),\n-                        ty::mk_int()\n-                        ], ty::mk_int()),\n-            \"load\" => (0,\n+                                             param(ccx, 0)),\n+                        param(ccx, 0),\n+                        param(ccx, 0),\n+                        ], param(ccx, 0)),\n+            \"load\" => (1,\n                ~[\n-                  ty::mk_imm_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), ty::mk_int())\n+                  ty::mk_imm_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)),\n+                                  param(ccx, 0))\n                ],\n-              ty::mk_int()),\n-            \"store\" => (0,\n+              param(ccx, 0)),\n+            \"store\" => (1,\n                ~[\n-                  ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), ty::mk_int()),\n-                  ty::mk_int()\n+                  ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)),\n+                                  param(ccx, 0)),\n+                  param(ccx, 0)\n                ],\n                ty::mk_nil()),\n \n-            \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\"   | \"xor\"  | \"max\"  |\n+            \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n             \"min\"  | \"umax\" | \"umin\" => {\n-                (0, ~[ty::mk_mut_rptr(tcx,\n+                (1, ~[ty::mk_mut_rptr(tcx,\n                                       ty::ReLateBound(it.id, ty::BrAnon(0)),\n-                                      ty::mk_int()), ty::mk_int() ], ty::mk_int())\n+                                      param(ccx, 0)), param(ccx, 0) ],\n+                 param(ccx, 0))\n             }\n             \"fence\" => {\n                 (0, ~[], ty::mk_nil())\n@@ -4085,16 +4088,6 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n             }\n             \"needs_drop\" => (1u, ~[], ty::mk_bool()),\n             \"owns_managed\" => (1u, ~[], ty::mk_bool()),\n-            \"atomic_xchg\"     | \"atomic_xadd\"     | \"atomic_xsub\"     |\n-            \"atomic_xchg_acq\" | \"atomic_xadd_acq\" | \"atomic_xsub_acq\" |\n-            \"atomic_xchg_rel\" | \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => {\n-              (0,\n-               ~[\n-                  ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), ty::mk_int()),\n-                  ty::mk_int()\n-               ],\n-               ty::mk_int())\n-            }\n \n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {"}, {"sha": "6ce285152dea8ad60f2db8ee1eeda32552d8443b", "filename": "src/libstd/sync/atomics.rs", "status": "modified", "additions": 245, "deletions": 32, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/b00147a99b289b11a210d9fc841b8aca3e59ce0e/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00147a99b289b11a210d9fc841b8aca3e59ce0e/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=b00147a99b289b11a210d9fc841b8aca3e59ce0e", "patch": "@@ -59,9 +59,25 @@ pub struct AtomicUint {\n     priv nocopy: NonCopyable\n }\n \n+/**\n+ * An unsigned atomic integer type that is forced to be 64-bits. This does not\n+ * support all operations.\n+ */\n+#[cfg(not(stage0))]\n+pub struct AtomicU64 {\n+    priv v: u64,\n+    priv nocopy: NonCopyable\n+}\n+\n /**\n  * An unsafe atomic pointer. Only supports basic atomic operations\n  */\n+#[cfg(not(stage0))]\n+pub struct AtomicPtr<T> {\n+    priv p: uint,\n+    priv nocopy: NonCopyable\n+}\n+#[cfg(stage0)]\n pub struct AtomicPtr<T> {\n     priv p: *mut T,\n     priv nocopy: NonCopyable\n@@ -71,6 +87,12 @@ pub struct AtomicPtr<T> {\n  * An owned atomic pointer. Ensures that only a single reference to the data is held at any time.\n  */\n #[unsafe_no_drop_flag]\n+#[cfg(not(stage0))]\n+pub struct AtomicOption<T> {\n+    priv p: uint,\n+}\n+#[unsafe_no_drop_flag]\n+#[cfg(stage0)]\n pub struct AtomicOption<T> {\n     priv p: *mut u8\n }\n@@ -87,6 +109,8 @@ pub static INIT_ATOMIC_FLAG : AtomicFlag = AtomicFlag { v: 0, nocopy: NonCopyabl\n pub static INIT_ATOMIC_BOOL : AtomicBool = AtomicBool { v: 0, nocopy: NonCopyable };\n pub static INIT_ATOMIC_INT  : AtomicInt  = AtomicInt  { v: 0, nocopy: NonCopyable };\n pub static INIT_ATOMIC_UINT : AtomicUint = AtomicUint { v: 0, nocopy: NonCopyable };\n+#[cfg(not(stage0))]\n+pub static INIT_ATOMIC_U64 : AtomicU64 = AtomicU64 { v: 0, nocopy: NonCopyable };\n \n impl AtomicFlag {\n \n@@ -215,6 +239,43 @@ impl AtomicInt {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl AtomicU64 {\n+    pub fn new(v: u64) -> AtomicU64 {\n+        AtomicU64 { v:v, nocopy: NonCopyable }\n+    }\n+\n+    #[inline]\n+    pub fn load(&self, order: Ordering) -> u64 {\n+        unsafe { atomic_load(&self.v, order) }\n+    }\n+\n+    #[inline]\n+    pub fn store(&mut self, val: u64, order: Ordering) {\n+        unsafe { atomic_store(&mut self.v, val, order); }\n+    }\n+\n+    #[inline]\n+    pub fn swap(&mut self, val: u64, order: Ordering) -> u64 {\n+        unsafe { atomic_swap(&mut self.v, val, order) }\n+    }\n+\n+    #[inline]\n+    pub fn compare_and_swap(&mut self, old: u64, new: u64, order: Ordering) -> u64 {\n+        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n+    }\n+\n+    #[inline]\n+    pub fn fetch_add(&mut self, val: u64, order: Ordering) -> u64 {\n+        unsafe { atomic_add(&mut self.v, val, order) }\n+    }\n+\n+    #[inline]\n+    pub fn fetch_sub(&mut self, val: u64, order: Ordering) -> u64 {\n+        unsafe { atomic_sub(&mut self.v, val, order) }\n+    }\n+}\n+\n impl AtomicUint {\n     pub fn new(v: uint) -> AtomicUint {\n         AtomicUint { v:v, nocopy: NonCopyable }\n@@ -254,57 +315,86 @@ impl AtomicUint {\n }\n \n impl<T> AtomicPtr<T> {\n+    #[cfg(stage0)]\n+    pub fn new(p: *mut T) -> AtomicPtr<T> {\n+        AtomicPtr { p: p, nocopy: NonCopyable }\n+    }\n+    #[cfg(not(stage0))]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p:p, nocopy: NonCopyable }\n+        AtomicPtr { p: p as uint, nocopy: NonCopyable }\n     }\n \n     #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn load(&self, order: Ordering) -> *mut T {\n+        unsafe {\n+            atomic_load(&self.p, order) as *mut T\n+        }\n+    }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn store(&mut self, ptr: *mut T, order: Ordering) {\n+        unsafe { atomic_store(&mut self.p, ptr as uint, order); }\n+    }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn swap(&mut self, ptr: *mut T, order: Ordering) -> *mut T {\n+        unsafe { atomic_swap(&mut self.p, ptr as uint, order) as *mut T }\n+    }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn compare_and_swap(&mut self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n+        unsafe {\n+            atomic_compare_and_swap(&mut self.p, old as uint,\n+                                    new as uint, order) as *mut T\n+        }\n+    }\n+\n+    #[inline]\n+    #[cfg(stage0)]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe { atomic_load(&self.p, order) }\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     pub fn store(&mut self, ptr: *mut T, order: Ordering) {\n         unsafe { atomic_store(&mut self.p, ptr, order); }\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     pub fn swap(&mut self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(&mut self.p, ptr, order) }\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     pub fn compare_and_swap(&mut self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_compare_and_swap(&mut self.p, old, new, order) }\n     }\n }\n \n impl<T> AtomicOption<T> {\n     pub fn new(p: ~T) -> AtomicOption<T> {\n-        unsafe {\n-            AtomicOption {\n-                p: cast::transmute(p)\n-            }\n-        }\n+        unsafe { AtomicOption { p: cast::transmute(p) } }\n     }\n \n-    pub fn empty() -> AtomicOption<T> {\n-        unsafe {\n-            AtomicOption {\n-                p: cast::transmute(0)\n-            }\n-        }\n-    }\n+    #[cfg(stage0)]\n+    pub fn empty() -> AtomicOption<T> { AtomicOption { p: 0 as *mut c_void } }\n+    #[cfg(not(stage0))]\n+    pub fn empty() -> AtomicOption<T> { AtomicOption { p: 0 } }\n \n     #[inline]\n     pub fn swap(&mut self, val: ~T, order: Ordering) -> Option<~T> {\n         unsafe {\n             let val = cast::transmute(val);\n \n             let p = atomic_swap(&mut self.p, val, order);\n-            let pv : &uint = cast::transmute(&p);\n-\n-            if *pv == 0 {\n+            if p as uint == 0 {\n                 None\n             } else {\n                 Some(cast::transmute(p))\n@@ -314,9 +404,7 @@ impl<T> AtomicOption<T> {\n \n     #[inline]\n     pub fn take(&mut self, order: Ordering) -> Option<~T> {\n-        unsafe {\n-            self.swap(cast::transmute(0), order)\n-        }\n+        unsafe { self.swap(cast::transmute(0), order) }\n     }\n \n     /// A compare-and-swap. Succeeds if the option is 'None' and returns 'None'\n@@ -340,7 +428,7 @@ impl<T> AtomicOption<T> {\n     /// result does not get invalidated by another task after this returns.\n     #[inline]\n     pub fn is_empty(&mut self, order: Ordering) -> bool {\n-        unsafe { atomic_load(&self.p, order) == cast::transmute(0) }\n+        unsafe { atomic_load(&self.p, order) as uint == 0 }\n     }\n }\n \n@@ -351,34 +439,52 @@ impl<T> Drop for AtomicOption<T> {\n     }\n }\n \n+#[cfg(stage0)]\n #[inline]\n pub unsafe fn atomic_store<T>(dst: &mut T, val: T, order:Ordering) {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n-\n+    cast::transmute(match order {\n+        Release => intrinsics::atomic_store_rel(dst, val),\n+        Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n+        _       => intrinsics::atomic_store(dst, val)\n+    })\n+}\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn atomic_store<T>(dst: &mut T, val: T, order:Ordering) {\n     match order {\n         Release => intrinsics::atomic_store_rel(dst, val),\n         Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n         _       => intrinsics::atomic_store(dst, val)\n     }\n }\n \n+#[cfg(stage0)]\n #[inline]\n pub unsafe fn atomic_load<T>(dst: &T, order:Ordering) -> T {\n     let dst = cast::transmute(dst);\n-\n     cast::transmute(match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n         Relaxed => intrinsics::atomic_load_relaxed(dst),\n         _       => intrinsics::atomic_load(dst)\n     })\n }\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn atomic_load<T>(dst: &T, order:Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_load_acq(dst),\n+        Relaxed => intrinsics::atomic_load_relaxed(dst),\n+        _       => intrinsics::atomic_load(dst)\n+    }\n+}\n \n+#[cfg(stage0)]\n #[inline]\n pub unsafe fn atomic_swap<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n-\n     cast::transmute(match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n         Release => intrinsics::atomic_xchg_rel(dst, val),\n@@ -387,13 +493,24 @@ pub unsafe fn atomic_swap<T>(dst: &mut T, val: T, order: Ordering) -> T {\n         _       => intrinsics::atomic_xchg(dst, val)\n     })\n }\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn atomic_swap<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_xchg_acq(dst, val),\n+        Release => intrinsics::atomic_xchg_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xchg_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n+        _       => intrinsics::atomic_xchg(dst, val)\n+    }\n+}\n \n /// Returns the old value (like __sync_fetch_and_add).\n+#[cfg(stage0)]\n #[inline]\n pub unsafe fn atomic_add<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n-\n     cast::transmute(match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n         Release => intrinsics::atomic_xadd_rel(dst, val),\n@@ -402,13 +519,25 @@ pub unsafe fn atomic_add<T>(dst: &mut T, val: T, order: Ordering) -> T {\n         _       => intrinsics::atomic_xadd(dst, val)\n     })\n }\n+/// Returns the old value (like __sync_fetch_and_add).\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn atomic_add<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_xadd_acq(dst, val),\n+        Release => intrinsics::atomic_xadd_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xadd_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n+        _       => intrinsics::atomic_xadd(dst, val)\n+    }\n+}\n \n /// Returns the old value (like __sync_fetch_and_sub).\n+#[cfg(stage0)]\n #[inline]\n pub unsafe fn atomic_sub<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n-\n     cast::transmute(match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n         Release => intrinsics::atomic_xsub_rel(dst, val),\n@@ -417,13 +546,25 @@ pub unsafe fn atomic_sub<T>(dst: &mut T, val: T, order: Ordering) -> T {\n         _       => intrinsics::atomic_xsub(dst, val)\n     })\n }\n+/// Returns the old value (like __sync_fetch_and_sub).\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn atomic_sub<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_xsub_acq(dst, val),\n+        Release => intrinsics::atomic_xsub_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xsub_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n+        _       => intrinsics::atomic_xsub(dst, val)\n+    }\n+}\n \n+#[cfg(stage0)]\n #[inline]\n pub unsafe fn atomic_compare_and_swap<T>(dst:&mut T, old:T, new:T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n-    let old = cast::transmute(old);\n     let new = cast::transmute(new);\n-\n+    let old = cast::transmute(old);\n     cast::transmute(match order {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n         Release => intrinsics::atomic_cxchg_rel(dst, old, new),\n@@ -432,12 +573,23 @@ pub unsafe fn atomic_compare_and_swap<T>(dst:&mut T, old:T, new:T, order: Orderi\n         _       => intrinsics::atomic_cxchg(dst, old, new),\n     })\n }\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn atomic_compare_and_swap<T>(dst:&mut T, old:T, new:T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n+        Release => intrinsics::atomic_cxchg_rel(dst, old, new),\n+        AcqRel  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n+        Relaxed => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n+        _       => intrinsics::atomic_cxchg(dst, old, new),\n+    }\n+}\n \n+#[cfg(stage0)]\n #[inline]\n pub unsafe fn atomic_and<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n-\n     cast::transmute(match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n         Release => intrinsics::atomic_and_rel(dst, val),\n@@ -446,13 +598,23 @@ pub unsafe fn atomic_and<T>(dst: &mut T, val: T, order: Ordering) -> T {\n         _       => intrinsics::atomic_and(dst, val)\n     })\n }\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn atomic_and<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_and_acq(dst, val),\n+        Release => intrinsics::atomic_and_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_and_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n+        _       => intrinsics::atomic_and(dst, val)\n+    }\n+}\n \n-\n+#[cfg(stage0)]\n #[inline]\n pub unsafe fn atomic_nand<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n-\n     cast::transmute(match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n         Release => intrinsics::atomic_nand_rel(dst, val),\n@@ -461,13 +623,24 @@ pub unsafe fn atomic_nand<T>(dst: &mut T, val: T, order: Ordering) -> T {\n         _       => intrinsics::atomic_nand(dst, val)\n     })\n }\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn atomic_nand<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_nand_acq(dst, val),\n+        Release => intrinsics::atomic_nand_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_nand_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n+        _       => intrinsics::atomic_nand(dst, val)\n+    }\n+}\n \n \n+#[cfg(stage0)]\n #[inline]\n pub unsafe fn atomic_or<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n-\n     cast::transmute(match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n         Release => intrinsics::atomic_or_rel(dst, val),\n@@ -476,13 +649,24 @@ pub unsafe fn atomic_or<T>(dst: &mut T, val: T, order: Ordering) -> T {\n         _       => intrinsics::atomic_or(dst, val)\n     })\n }\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn atomic_or<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_or_acq(dst, val),\n+        Release => intrinsics::atomic_or_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_or_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n+        _       => intrinsics::atomic_or(dst, val)\n+    }\n+}\n \n \n+#[cfg(stage0)]\n #[inline]\n pub unsafe fn atomic_xor<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n-\n     cast::transmute(match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n         Release => intrinsics::atomic_xor_rel(dst, val),\n@@ -491,6 +675,17 @@ pub unsafe fn atomic_xor<T>(dst: &mut T, val: T, order: Ordering) -> T {\n         _       => intrinsics::atomic_xor(dst, val)\n     })\n }\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn atomic_xor<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_xor_acq(dst, val),\n+        Release => intrinsics::atomic_xor_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xor_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n+        _       => intrinsics::atomic_xor(dst, val)\n+    }\n+}\n \n \n /**\n@@ -599,4 +794,22 @@ mod test {\n             assert!(S_UINT.load(SeqCst) == 0);\n         }\n     }\n+\n+    #[test]\n+    #[cfg(not(stage0))]\n+    fn different_sizes() {\n+        unsafe {\n+            let mut slot = 0u16;\n+            assert_eq!(super::atomic_swap(&mut slot, 1, SeqCst), 0);\n+\n+            let mut slot = 0u8;\n+            assert_eq!(super::atomic_compare_and_swap(&mut slot, 1, 2, SeqCst), 0);\n+\n+            let mut slot = 0u32;\n+            assert_eq!(super::atomic_load(&mut slot, SeqCst), 0);\n+\n+            let mut slot = 0u64;\n+            super::atomic_store(&mut slot, 2, SeqCst);\n+        }\n+    }\n }"}, {"sha": "9b3826b42a59abfb0b6ef2fee26cb54b2e3f42af", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 101, "deletions": 9, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b00147a99b289b11a210d9fc841b8aca3e59ce0e/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00147a99b289b11a210d9fc841b8aca3e59ce0e/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=b00147a99b289b11a210d9fc841b8aca3e59ce0e", "patch": "@@ -172,16 +172,8 @@ pub trait TyVisitor {\n     fn visit_closure_ptr(&mut self, ck: uint) -> bool;\n }\n \n+#[cfg(stage0)]\n extern \"rust-intrinsic\" {\n-    /// Abort the execution of the process.\n-    pub fn abort() -> !;\n-\n-    /// Execute a breakpoint trap, for inspection by a debugger.\n-    pub fn breakpoint();\n-\n-    pub fn volatile_load<T>(src: *T) -> T;\n-    pub fn volatile_store<T>(dst: *mut T, val: T);\n-\n     /// Atomic compare and exchange, sequentially consistent.\n     pub fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n     /// Atomic compare and exchange, acquire ordering.\n@@ -286,6 +278,106 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_fence_acq();\n     pub fn atomic_fence_rel();\n     pub fn atomic_fence_acqrel();\n+}\n+\n+#[cfg(not(stage0))]\n+extern \"rust-intrinsic\" {\n+    pub fn atomic_cxchg<T>(dst: &mut T, old: T, src: T) -> T;\n+    pub fn atomic_cxchg_acq<T>(dst: &mut T, old: T, src: T) -> T;\n+    pub fn atomic_cxchg_rel<T>(dst: &mut T, old: T, src: T) -> T;\n+    pub fn atomic_cxchg_acqrel<T>(dst: &mut T, old: T, src: T) -> T;\n+    pub fn atomic_cxchg_relaxed<T>(dst: &mut T, old: T, src: T) -> T;\n+\n+    pub fn atomic_load<T>(src: &T) -> T;\n+    pub fn atomic_load_acq<T>(src: &T) -> T;\n+    pub fn atomic_load_relaxed<T>(src: &T) -> T;\n+\n+    pub fn atomic_store<T>(dst: &mut T, val: T);\n+    pub fn atomic_store_rel<T>(dst: &mut T, val: T);\n+    pub fn atomic_store_relaxed<T>(dst: &mut T, val: T);\n+\n+    pub fn atomic_xchg<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xchg_acq<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xchg_rel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xchg_acqrel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xchg_relaxed<T>(dst: &mut T, src: T) -> T;\n+\n+    pub fn atomic_xadd<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xadd_acq<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xadd_rel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xadd_acqrel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xadd_relaxed<T>(dst: &mut T, src: T) -> T;\n+\n+    pub fn atomic_xsub<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xsub_acq<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xsub_rel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xsub_acqrel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xsub_relaxed<T>(dst: &mut T, src: T) -> T;\n+\n+    pub fn atomic_and<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_and_acq<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_and_rel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_and_acqrel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_and_relaxed<T>(dst: &mut T, src: T) -> T;\n+\n+    pub fn atomic_nand<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_nand_acq<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_nand_rel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_nand_acqrel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_nand_relaxed<T>(dst: &mut T, src: T) -> T;\n+\n+    pub fn atomic_or<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_or_acq<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_or_rel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_or_acqrel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_or_relaxed<T>(dst: &mut T, src: T) -> T;\n+\n+    pub fn atomic_xor<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xor_acq<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xor_rel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xor_acqrel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_xor_relaxed<T>(dst: &mut T, src: T) -> T;\n+\n+    pub fn atomic_max<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_max_acq<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_max_rel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_max_acqrel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_max_relaxed<T>(dst: &mut T, src: T) -> T;\n+\n+    pub fn atomic_min<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_min_acq<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_min_rel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_min_acqrel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_min_relaxed<T>(dst: &mut T, src: T) -> T;\n+\n+    pub fn atomic_umin<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_umin_acq<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_umin_rel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_umin_acqrel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_umin_relaxed<T>(dst: &mut T, src: T) -> T;\n+\n+    pub fn atomic_umax<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_umax_acq<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_umax_rel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_umax_acqrel<T>(dst: &mut T, src: T) -> T;\n+    pub fn atomic_umax_relaxed<T>(dst: &mut T, src: T) -> T;\n+\n+    pub fn atomic_fence();\n+    pub fn atomic_fence_acq();\n+    pub fn atomic_fence_rel();\n+    pub fn atomic_fence_acqrel();\n+}\n+\n+extern \"rust-intrinsic\" {\n+    /// Abort the execution of the process.\n+    pub fn abort() -> !;\n+\n+    /// Execute a breakpoint trap, for inspection by a debugger.\n+    pub fn breakpoint();\n+\n+    pub fn volatile_load<T>(src: *T) -> T;\n+    pub fn volatile_store<T>(dst: *mut T, val: T);\n+\n \n     /// The size of a type in bytes.\n     ///"}, {"sha": "07d6df89d220c29e317bebbde85f71f00714c7f9", "filename": "src/test/auxiliary/cci_intrinsic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b00147a99b289b11a210d9fc841b8aca3e59ce0e/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00147a99b289b11a210d9fc841b8aca3e59ce0e/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs?ref=b00147a99b289b11a210d9fc841b8aca3e59ce0e", "patch": "@@ -10,21 +10,21 @@\n \n pub mod rusti {\n     extern \"rust-intrinsic\" {\n-        pub fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n-        pub fn atomic_cxchg_acq(dst: &mut int, old: int, src: int) -> int;\n-        pub fn atomic_cxchg_rel(dst: &mut int, old: int, src: int) -> int;\n+        pub fn atomic_cxchg<T>(dst: &mut T, old: T, src: T) -> T;\n+        pub fn atomic_cxchg_acq<T>(dst: &mut T, old: T, src: T) -> T;\n+        pub fn atomic_cxchg_rel<T>(dst: &mut T, old: T, src: T) -> T;\n \n-        pub fn atomic_xchg(dst: &mut int, src: int) -> int;\n-        pub fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n-        pub fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n+        pub fn atomic_xchg<T>(dst: &mut T, src: T) -> T;\n+        pub fn atomic_xchg_acq<T>(dst: &mut T, src: T) -> T;\n+        pub fn atomic_xchg_rel<T>(dst: &mut T, src: T) -> T;\n \n-        pub fn atomic_xadd(dst: &mut int, src: int) -> int;\n-        pub fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n-        pub fn atomic_xadd_rel(dst: &mut int, src: int) -> int;\n+        pub fn atomic_xadd<T>(dst: &mut T, src: T) -> T;\n+        pub fn atomic_xadd_acq<T>(dst: &mut T, src: T) -> T;\n+        pub fn atomic_xadd_rel<T>(dst: &mut T, src: T) -> T;\n \n-        pub fn atomic_xsub(dst: &mut int, src: int) -> int;\n-        pub fn atomic_xsub_acq(dst: &mut int, src: int) -> int;\n-        pub fn atomic_xsub_rel(dst: &mut int, src: int) -> int;\n+        pub fn atomic_xsub<T>(dst: &mut T, src: T) -> T;\n+        pub fn atomic_xsub_acq<T>(dst: &mut T, src: T) -> T;\n+        pub fn atomic_xsub_rel<T>(dst: &mut T, src: T) -> T;\n     }\n }\n "}, {"sha": "d6e394a345e228bee26d849175457acfaee0f081", "filename": "src/test/run-pass/intrinsic-atomics.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b00147a99b289b11a210d9fc841b8aca3e59ce0e/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00147a99b289b11a210d9fc841b8aca3e59ce0e/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs?ref=b00147a99b289b11a210d9fc841b8aca3e59ce0e", "patch": "@@ -10,27 +10,27 @@\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n-        pub fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n-        pub fn atomic_cxchg_acq(dst: &mut int, old: int, src: int) -> int;\n-        pub fn atomic_cxchg_rel(dst: &mut int, old: int, src: int) -> int;\n+        pub fn atomic_cxchg<T>(dst: &mut T, old: T, src: T) -> T;\n+        pub fn atomic_cxchg_acq<T>(dst: &mut T, old: T, src: T) -> T;\n+        pub fn atomic_cxchg_rel<T>(dst: &mut T, old: T, src: T) -> T;\n \n-        pub fn atomic_load(src: &int) -> int;\n-        pub fn atomic_load_acq(src: &int) -> int;\n+        pub fn atomic_load<T>(src: &T) -> T;\n+        pub fn atomic_load_acq<T>(src: &T) -> T;\n \n-        pub fn atomic_store(dst: &mut int, val: int);\n-        pub fn atomic_store_rel(dst: &mut int, val: int);\n+        pub fn atomic_store<T>(dst: &mut T, val: T);\n+        pub fn atomic_store_rel<T>(dst: &mut T, val: T);\n \n-        pub fn atomic_xchg(dst: &mut int, src: int) -> int;\n-        pub fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n-        pub fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n+        pub fn atomic_xchg<T>(dst: &mut T, src: T) -> T;\n+        pub fn atomic_xchg_acq<T>(dst: &mut T, src: T) -> T;\n+        pub fn atomic_xchg_rel<T>(dst: &mut T, src: T) -> T;\n \n-        pub fn atomic_xadd(dst: &mut int, src: int) -> int;\n-        pub fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n-        pub fn atomic_xadd_rel(dst: &mut int, src: int) -> int;\n+        pub fn atomic_xadd<T>(dst: &mut T, src: T) -> T;\n+        pub fn atomic_xadd_acq<T>(dst: &mut T, src: T) -> T;\n+        pub fn atomic_xadd_rel<T>(dst: &mut T, src: T) -> T;\n \n-        pub fn atomic_xsub(dst: &mut int, src: int) -> int;\n-        pub fn atomic_xsub_acq(dst: &mut int, src: int) -> int;\n-        pub fn atomic_xsub_rel(dst: &mut int, src: int) -> int;\n+        pub fn atomic_xsub<T>(dst: &mut T, src: T) -> T;\n+        pub fn atomic_xsub_acq<T>(dst: &mut T, src: T) -> T;\n+        pub fn atomic_xsub_rel<T>(dst: &mut T, src: T) -> T;\n     }\n }\n "}]}