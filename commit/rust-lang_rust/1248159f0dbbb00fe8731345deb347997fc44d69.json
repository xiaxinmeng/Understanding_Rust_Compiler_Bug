{"sha": "1248159f0dbbb00fe8731345deb347997fc44d69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNDgxNTlmMGRiYmIwMGZlODczMTM0NWRlYjM0Nzk5N2ZjNDRkNjk=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-10-24T12:28:58Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-10-24T12:28:58Z"}, "message": "add expression and pattern dump", "tree": {"sha": "3e5e37d1160ef5a72ffc17f8676307ddaa7bf8f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e5e37d1160ef5a72ffc17f8676307ddaa7bf8f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1248159f0dbbb00fe8731345deb347997fc44d69", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYDf6KAAoJEFbW7qD8Z6xGo9EP/29PmACXNNDiWAP05923gQD0\n0HtjXoFDe1F3tI+wmnM9pFespUWql7iusdJTODL0NP94/FAFvK6Bhe4bGcXTtUc3\nbjOiq11hT0pXO/Cn8mkU5eW2q2oWxqVBiRn/pe3Xq41cxGaPv8qHPpNYKVm7c/q+\nf4DdBqwJVcGVrCVC605q2XtuHMMfTMmU9sz2Z8Y0Kkq9ObTZinQN3jn298ruH2TF\nhqx8cSX8TMl9OsAposIUr82LnEuSS9UEgLg0Md4LnzhSaGUgw6MCjKYwqbaWyhTq\naqPO+FxMet96bW7YoJJnJy9Z9eWepJgGQ4s9bQwBGPUkCP2PeFDUQoSaISc5YnSD\n3+Qo2qfhG0OqMBaj/akcy6hWKcv6yQhTCIIuze1/opo7CcfkRPZ75nXmdgHvaz62\nBp+dzYnAci0Rt5/nBu8XKtfyPRzSMfxONYI/E1hWMHrDZgocDcD32LwBl3DAa/MU\ngNfpxMKhmYEsjsZPkUuPUNgultbWdJ/exzuhWST6iq6oI3ifAvkesnMnqs/5IrHi\nQ7uJNtoNdIWpMX5WeBc2y2PCtNxopJ+HkNW0kEBeSvsZ0n98cgP2y4SasU77S8M1\nwSaiHo4lN4I2Eo+N9fvHRzYIbxdcf7v+ATEItk9zN8Hzim9tpW+h5AEbBss0rrwh\n1xtR0OmpiE/VS2kXwTAU\n=DnKE\n-----END PGP SIGNATURE-----", "payload": "tree 3e5e37d1160ef5a72ffc17f8676307ddaa7bf8f1\nparent f29ab8c2451e59153f956d01cb1f228663ef9054\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1477312138 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1477312138 +0200\n\nadd expression and pattern dump"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1248159f0dbbb00fe8731345deb347997fc44d69", "html_url": "https://github.com/rust-lang/rust/commit/1248159f0dbbb00fe8731345deb347997fc44d69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1248159f0dbbb00fe8731345deb347997fc44d69/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f29ab8c2451e59153f956d01cb1f228663ef9054", "url": "https://api.github.com/repos/rust-lang/rust/commits/f29ab8c2451e59153f956d01cb1f228663ef9054", "html_url": "https://github.com/rust-lang/rust/commit/f29ab8c2451e59153f956d01cb1f228663ef9054"}], "stats": {"total": 292, "additions": 291, "deletions": 1}, "files": [{"sha": "4c97c5d465f0f7b303ac3d1067d64c7157bec211", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1248159f0dbbb00fe8731345deb347997fc44d69/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1248159f0dbbb00fe8731345deb347997fc44d69/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=1248159f0dbbb00fe8731345deb347997fc44d69", "patch": "@@ -7,6 +7,7 @@\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n+#![feature(repeat_str)]\n \n #![allow(indexing_slicing, shadow_reuse, unknown_lints, missing_docs_in_private_items)]\n "}, {"sha": "fc9f398f16c2719185c818124357fd8d0cf4f112", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 290, "deletions": 1, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/1248159f0dbbb00fe8731345deb347997fc44d69/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1248159f0dbbb00fe8731345deb347997fc44d69/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=1248159f0dbbb00fe8731345deb347997fc44d69", "patch": "@@ -130,7 +130,7 @@ impl LateLintPass for Pass {\n         if !has_attr(&expr.attrs) {\n             return;\n         }\n-        println!(\"expression type: {}\", cx.tcx.node_id_to_type(expr.id));\n+        print_expr(cx, expr, 0);\n     }\n \n     fn check_decl(&mut self, cx: &LateContext, decl: &hir::Decl) {\n@@ -149,6 +149,15 @@ impl LateLintPass for Pass {\n         if !has_attr(&arm.attrs) {\n             return;\n         }\n+        for pat in &arm.pats {\n+            print_pat(cx, pat, 1);\n+        }\n+        if let Some(ref guard) = arm.guard {\n+            println!(\"guard:\");\n+            print_expr(cx, guard, 1);\n+        }\n+        println!(\"body:\");\n+        print_expr(cx, &arm.body, 1);\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext, stmt: &hir::Stmt) {\n@@ -177,3 +186,283 @@ fn has_attr(attrs: &[Attribute]) -> bool {\n         _ => false,\n     })\n }\n+\n+fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n+    match decl.node {\n+        hir::DeclLocal(ref local) => {\n+            println!(\"local variable of type {}\", cx.tcx.node_id_to_type(local.id));\n+            println!(\"pattern:\");\n+            print_pat(cx, &local.pat, 0);\n+            if let Some(ref e) = local.init {\n+                println!(\"init expression:\");\n+                print_expr(cx, e, 0);\n+            }\n+        },\n+        hir::DeclItem(_) => println!(\"item decl\"),\n+    }\n+}\n+\n+fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n+    let ind = \"  \".repeat(indent);\n+    let ty = cx.tcx.node_id_to_type(expr.id);\n+    println!(\"{}+\", ind);\n+    match expr.node {\n+        hir::ExprBox(ref e) => {\n+            println!(\"{}Box, {}\", ind, ty);\n+            print_expr(cx, e, indent + 1);\n+        },\n+        hir::ExprArray(ref v) => {\n+            println!(\"{}Array, {}\", ind, ty);\n+            for e in v {\n+                print_expr(cx, e, indent + 1);\n+            }\n+        },\n+        hir::ExprCall(ref func, ref args) => {\n+            println!(\"{}Call, {}\", ind, ty);\n+            println!(\"{}function:\", ind);\n+            print_expr(cx, func, indent + 1);\n+            println!(\"{}arguments:\", ind);\n+            for arg in args {\n+                print_expr(cx, arg, indent + 1);\n+            }\n+        },\n+        hir::ExprMethodCall(ref name, _, ref args) => {\n+            println!(\"{}MethodCall, {}\", ind, ty);\n+            println!(\"{}method name: {}\", ind, name.node);\n+            for arg in args {\n+                print_expr(cx, arg, indent + 1);\n+            }\n+        },\n+        hir::ExprTup(ref v) => {\n+            println!(\"{}Tup, {}\", ind, ty);\n+            for e in v {\n+                print_expr(cx, e, indent + 1);\n+            }\n+        },\n+        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+            println!(\"{}Binary, {}\", ind, ty);\n+            println!(\"{}op: {:?}\", ind, op.node);\n+            println!(\"{}lhs:\", ind);\n+            print_expr(cx, lhs, indent + 1);\n+            println!(\"{}rhs:\", ind);\n+            print_expr(cx, rhs, indent + 1);\n+        },\n+        hir::ExprUnary(op, ref inner) => {\n+            println!(\"{}Unary, {}\", ind, ty);\n+            println!(\"{}op: {:?}\", ind, op);\n+            print_expr(cx, inner, indent + 1);\n+        },\n+        hir::ExprLit(ref lit) => {\n+            println!(\"{}Lit, {}\", ind, ty);\n+            println!(\"{}{:?}\", ind, lit);\n+        },\n+        hir::ExprCast(ref e, ref target) => {\n+            println!(\"{}Cast, {}\", ind, ty);\n+            print_expr(cx, e, indent + 1);\n+            println!(\"{}target type: {:?}\", ind, target);\n+        },\n+        hir::ExprType(ref e, ref target) => {\n+            println!(\"{}Type, {}\", ind, ty);\n+            print_expr(cx, e, indent + 1);\n+            println!(\"{}target type: {:?}\", ind, target);\n+        },\n+        hir::ExprIf(ref e, _, ref els) => {\n+            println!(\"{}If, {}\", ind, ty);\n+            println!(\"{}condition:\", ind);\n+            print_expr(cx, e, indent + 1);\n+            if let Some(ref els) = *els {\n+                println!(\"{}else:\", ind);\n+                print_expr(cx, els, indent + 1);\n+            }\n+        },\n+        hir::ExprWhile(ref cond, _, _) => {\n+            println!(\"{}While, {}\", ind, ty);\n+            println!(\"{}condition:\", ind);\n+            print_expr(cx, cond, indent + 1);\n+        },\n+        hir::ExprLoop(..) => {\n+            println!(\"{}Loop, {}\", ind, ty);\n+        },\n+        hir::ExprMatch(ref cond, _, ref source) => {\n+            println!(\"{}Match, {}\", ind, ty);\n+            println!(\"{}condition:\", ind);\n+            print_expr(cx, cond, indent + 1);\n+            println!(\"{}source: {:?}\", ind, source);\n+        },\n+        hir::ExprClosure(ref clause, _, _, _) => {\n+            println!(\"{}Closure, {}\", ind, ty);\n+            println!(\"{}clause: {:?}\", ind, clause);\n+        },\n+        hir::ExprBlock(_) => {\n+            println!(\"{}Block, {}\", ind, ty);\n+        },\n+        hir::ExprAssign(ref lhs, ref rhs) => {\n+            println!(\"{}Assign, {}\", ind, ty);\n+            println!(\"{}lhs:\", ind);\n+            print_expr(cx, lhs, indent + 1);\n+            println!(\"{}rhs:\", ind);\n+            print_expr(cx, rhs, indent + 1);\n+        },\n+        hir::ExprAssignOp(ref binop, ref lhs, ref rhs) => {\n+            println!(\"{}AssignOp, {}\", ind, ty);\n+            println!(\"{}op: {:?}\", ind, binop.node);\n+            println!(\"{}lhs:\", ind);\n+            print_expr(cx, lhs, indent + 1);\n+            println!(\"{}rhs:\", ind);\n+            print_expr(cx, rhs, indent + 1);\n+        },\n+        hir::ExprField(ref e, ref name) => {\n+            println!(\"{}Field, {}\", ind, ty);\n+            println!(\"{}field name: {}\", ind, name.node);\n+            println!(\"{}struct expr:\", ind);\n+            print_expr(cx, e, indent + 1);\n+        },\n+        hir::ExprTupField(ref e, ref idx) => {\n+            println!(\"{}TupField, {}\", ind, ty);\n+            println!(\"{}field index: {}\", ind, idx.node);\n+            println!(\"{}tuple expr:\", ind);\n+            print_expr(cx, e, indent + 1);\n+        },\n+        hir::ExprIndex(ref arr, ref idx) => {\n+            println!(\"{}Index, {}\", ind, ty);\n+            println!(\"{}array expr:\", ind);\n+            print_expr(cx, arr, indent + 1);\n+            println!(\"{}index expr:\", ind);\n+            print_expr(cx, idx, indent + 1);\n+        },\n+        hir::ExprPath(ref sel, ref path) => {\n+            println!(\"{}Path, {}\", ind, ty);\n+            println!(\"{}self: {:?}\", ind, sel);\n+            println!(\"{}path: {:?}\", ind, path);\n+        },\n+        hir::ExprAddrOf(ref muta, ref e) => {\n+            println!(\"{}AddrOf, {}\", ind, ty);\n+            println!(\"mutability: {:?}\", muta);\n+            print_expr(cx, e, indent + 1);\n+        },\n+        hir::ExprBreak(_) => println!(\"{}Break, {}\", ind, ty),\n+        hir::ExprAgain(_) => println!(\"{}Again, {}\", ind, ty),\n+        hir::ExprRet(ref e) => {\n+            println!(\"{}Ret, {}\", ind, ty);\n+            if let Some(ref e) = *e {\n+                print_expr(cx, e, indent + 1);\n+            }\n+        },\n+        hir::ExprInlineAsm(_, ref input, ref output) => {\n+            println!(\"{}InlineAsm, {}\", ind, ty);\n+            println!(\"{}inputs:\", ind);\n+            for e in input {\n+                print_expr(cx, e, indent + 1);\n+            }\n+            println!(\"{}outputs:\", ind);\n+            for e in output {\n+                print_expr(cx, e, indent + 1);\n+            }\n+        },\n+        hir::ExprStruct(ref path, ref fields, ref base) => {\n+            println!(\"{}Struct, {}\", ind, ty);\n+            println!(\"{}path: {:?}\", ind, path);\n+            for field in fields {\n+                println!(\"{}field \\\"{}\\\":\", ind, field.name.node);\n+                print_expr(cx, &field.expr, indent + 1);\n+            }\n+            if let Some(ref base) = *base {\n+                println!(\"{}base:\", ind);\n+                print_expr(cx, base, indent + 1);\n+            }\n+        },\n+        hir::ExprRepeat(ref val, ref n) => {\n+            println!(\"{}Repeat, {}\", ind, ty);\n+            println!(\"{}value:\", ind);\n+            print_expr(cx, val, indent + 1);\n+            println!(\"{}repeat count:\", ind);\n+            print_expr(cx, n, indent + 1);\n+        },\n+    }\n+}\n+fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n+    let ind = \"  \".repeat(indent);\n+    println!(\"{}+\", ind);\n+    match pat.node {\n+        hir::PatKind::Wild => println!(\"{}Wild\", ind),\n+        hir::PatKind::Binding(ref mode, ref name, ref inner) => {\n+            println!(\"{}Binding\", ind);\n+            println!(\"{}mode: {:?}\", ind, mode);\n+            println!(\"{}name: {}\", ind, name.node);\n+            if let Some(ref inner) = *inner {\n+                println!(\"{}inner:\", ind);\n+                print_pat(cx, inner, indent + 1);\n+            }\n+        },\n+        hir::PatKind::Struct(ref path, ref fields, ignore) => {\n+            println!(\"{}Struct\", ind);\n+            println!(\"{}name: {}\", ind, path);\n+            println!(\"{}ignore leftover fields: {}\", ind, ignore);\n+            println!(\"{}fields:\", ind);\n+            for field in fields {\n+                println!(\"{}  field name: {}\", ind, field.node.name);\n+                if field.node.is_shorthand {\n+                    println!(\"{}  in shorthand notation\", ind);\n+                }\n+                print_pat(cx, &field.node.pat, indent + 1);\n+            }\n+        },\n+        hir::PatKind::TupleStruct(ref path, ref pats, opt_dots_position) => {\n+            println!(\"{}TupleStruct\", ind);\n+            println!(\"{}path: {}\", ind, path);\n+            if let Some(dot_position) = opt_dots_position {\n+                println!(\"{}dot position: {}\", ind, dot_position);\n+            }\n+            for field in pats {\n+                print_pat(cx, &field, indent + 1);\n+            }\n+        },\n+        hir::PatKind::Path(ref sel, ref path) => {\n+            println!(\"{}Path\", ind);\n+            println!(\"{}self: {:?}\", ind, sel);\n+            println!(\"{}path: {:?}\", ind, path);\n+        },\n+        hir::PatKind::Tuple(ref pats, opt_dots_position) => {\n+            println!(\"{}Tuple\", ind);\n+            if let Some(dot_position) = opt_dots_position {\n+                println!(\"{}dot position: {}\", ind, dot_position);\n+            }\n+            for field in pats {\n+                print_pat(cx, &field, indent + 1);\n+            }\n+        },\n+        hir::PatKind::Box(ref inner) => {\n+            println!(\"{}Box\", ind);\n+            print_pat(cx, inner, indent + 1);\n+        },\n+        hir::PatKind::Ref(ref inner, ref muta) => {\n+            println!(\"{}Ref\", ind);\n+            println!(\"{}mutability: {:?}\", ind, muta);\n+            print_pat(cx, inner, indent + 1);\n+        },\n+        hir::PatKind::Lit(ref e) => {\n+            println!(\"{}Lit\", ind);\n+            print_expr(cx, e, indent + 1);\n+        },\n+        hir::PatKind::Range(ref l, ref r) => {\n+            println!(\"{}Range\", ind);\n+            print_expr(cx, l, indent + 1);\n+            print_expr(cx, r, indent + 1);\n+        },\n+        hir::PatKind::Slice(ref start, ref range, ref end) => {\n+            println!(\"{}Slice [a, b, ..i, y, z]\", ind);\n+            println!(\"[a, b]:\");\n+            for pat in start {\n+                print_pat(cx, pat, indent + 1);\n+            }\n+            println!(\"i:\");\n+            if let Some(ref pat) = *range {\n+                print_pat(cx, pat, indent + 1);\n+            }\n+            println!(\"[y, z]:\");\n+            for pat in end {\n+                print_pat(cx, pat, indent + 1);\n+            }\n+        },\n+    }\n+}"}]}