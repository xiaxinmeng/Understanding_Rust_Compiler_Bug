{"sha": "fa0d568522de0f806fa078be8e7f09addae97835", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMGQ1Njg1MjJkZTBmODA2ZmEwNzhiZThlN2YwOWFkZGFlOTc4MzU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-22T12:32:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-22T12:32:02Z"}, "message": "Merge #9369\n\n9369: internal: document source_to_def and it's connection to Kotlin&Roslyn r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "c791c501c38fa7f01e9ddb9f789a6bb1ca0eda2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c791c501c38fa7f01e9ddb9f789a6bb1ca0eda2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa0d568522de0f806fa078be8e7f09addae97835", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg0dhCCRBK7hj4Ov3rIwAA03QIAKCn1uyGJlfVxWVxy22sr7aV\nuTAf7uWqSGoPWbpUU81sdcHM/NDCBCm+PGKkETrFs6Iy0olbnd3QCgvY1umFyHa3\nXNQBctRqjWVSXFadDyeKlFo6IZ0OpJ3EpYeP+QmQZZ8W+ZjWlztw84KAG1C4hzro\nynYKrOBwnIg4OpFblAV9vIgi0iaSQVq88VjmnDtD6MOC6xMd/6Mm5QZtZnbKRc3i\npWi+1bpCFke89LTXJQrFvxk9iM5GjEKKbvOkNxnxx53GxR04seGB8PhvlPVpO5nY\n/7uCo69t8M3BxO0yi6lBZ2KawWVmF0MJHNx+pCbEVltSBzt2El48ngMJ2fstPPY=\n=aBKm\n-----END PGP SIGNATURE-----\n", "payload": "tree c791c501c38fa7f01e9ddb9f789a6bb1ca0eda2f\nparent ff92afb4c1934b611ab67d35dc6c6b113e97e525\nparent bf9ce9e65cea5a79bfba3917c4b8c5ee80f67481\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1624365122 +0000\ncommitter GitHub <noreply@github.com> 1624365122 +0000\n\nMerge #9369\n\n9369: internal: document source_to_def and it's connection to Kotlin&Roslyn r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa0d568522de0f806fa078be8e7f09addae97835", "html_url": "https://github.com/rust-lang/rust/commit/fa0d568522de0f806fa078be8e7f09addae97835", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa0d568522de0f806fa078be8e7f09addae97835/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff92afb4c1934b611ab67d35dc6c6b113e97e525", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff92afb4c1934b611ab67d35dc6c6b113e97e525", "html_url": "https://github.com/rust-lang/rust/commit/ff92afb4c1934b611ab67d35dc6c6b113e97e525"}, {"sha": "bf9ce9e65cea5a79bfba3917c4b8c5ee80f67481", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf9ce9e65cea5a79bfba3917c4b8c5ee80f67481", "html_url": "https://github.com/rust-lang/rust/commit/bf9ce9e65cea5a79bfba3917c4b8c5ee80f67481"}], "stats": {"total": 69, "additions": 69, "deletions": 0}, "files": [{"sha": "24afcfba007effe24ac4464a5870826597f5382b", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fa0d568522de0f806fa078be8e7f09addae97835/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0d568522de0f806fa078be8e7f09addae97835/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=fa0d568522de0f806fa078be8e7f09addae97835", "patch": "@@ -1,4 +1,73 @@\n //! Maps *syntax* of various definitions to their semantic ids.\n+//!\n+//! This is a very interesting module, and, in some sense, can be considered a\n+//! heart of the IDE parts of rust-analyzer.\n+//!\n+//! This module solves the following problem:\n+//!\n+//!     Given a piece of syntax, find the corresponding semantic definition (def).\n+//!\n+//! This problem is a part of more-or-less every IDE feature implemented. Every\n+//! IDE functionality (like goto to definition), conceptually starts with a\n+//! specific cursor position in a file. Starting with this text offset, we first\n+//! figure out what syntactic construct are we at: is this a pattern, an\n+//! expression, an item definition.\n+//!\n+//! Knowing only the syntax gives us relatively little info. For example,\n+//! looking at the syntax of the function we can realise that it is a part of an\n+//! `impl` block, but we won't be able to tell what trait function the current\n+//! function overrides, and whether it does that correctly. For that, we need to\n+//! go from [`ast::Fn`] to [`crate::Function], and that's exactly what this\n+//! module does.\n+//!\n+//! As syntax trees are values and don't know their place of origin/identity,\n+//! this module also requires [`InFile`] wrappers to understand which specific\n+//! real or macro-expanded file the tree comes from.\n+//!\n+//! The actual algorithm to resolve syntax to def is curious in two aspects:\n+//!\n+//!     * It is recursive\n+//!     * It uses the inverse algorithm (what is the syntax for this def?)\n+//!\n+//! Specifically, the algorithm goes like this:\n+//!\n+//!     1. Find the syntactic container for the syntax. For example, field's\n+//!        container is the struct, and structs container is a module.\n+//!     2. Recursively get the def corresponding to container.\n+//!     3. Ask the container def for all child defs. These child defs contain\n+//!        the answer and answer's siblings.\n+//!     4. For each child def, ask for it's source.\n+//!     5. The child def whose source is the syntax node we've started with\n+//!        is the answer.\n+//!\n+//! It's interesting that both Roslyn and Kotlin contain very similar code\n+//! shape.\n+//!\n+//! Let's take a look at Roslyn:\n+//!\n+//!   <https://github.com/dotnet/roslyn/blob/36a0c338d6621cc5fe34b79d414074a95a6a489c/src/Compilers/CSharp/Portable/Compilation/SyntaxTreeSemanticModel.cs#L1403-L1429>\n+//!   <https://sourceroslyn.io/#Microsoft.CodeAnalysis.CSharp/Compilation/SyntaxTreeSemanticModel.cs,1403>\n+//!\n+//! The `GetDeclaredType` takes `Syntax` as input, and returns `Symbol` as\n+//! output. First, it retrieves a `Symbol` for parent `Syntax`:\n+//!\n+//! * https://sourceroslyn.io/#Microsoft.CodeAnalysis.CSharp/Compilation/SyntaxTreeSemanticModel.cs,1423\n+//!\n+//! Then, it iterates parent symbol's children, looking for one which has the\n+//! same text span as the original node:\n+//!\n+//!   <https://sourceroslyn.io/#Microsoft.CodeAnalysis.CSharp/Compilation/SyntaxTreeSemanticModel.cs,1786>\n+//!\n+//! Now, let's look at Kotlin:\n+//!\n+//!   <https://github.com/JetBrains/kotlin/blob/a288b8b00e4754a1872b164999c6d3f3b8c8994a/idea/idea-frontend-fir/idea-fir-low-level-api/src/org/jetbrains/kotlin/idea/fir/low/level/api/FirModuleResolveStateImpl.kt#L93-L125>\n+//!\n+//! This function starts with a syntax node (`KtExpression` is syntax, like all\n+//! `Kt` nodes), and returns a def. It uses\n+//! `getNonLocalContainingOrThisDeclaration` to get syntactic container for a\n+//! current node. Then, `findSourceNonLocalFirDeclaration` gets `Fir` for this\n+//! parent. Finally, `findElementIn` function traverses `Fir` children to find\n+//! one with the same source we originally started with.\n \n use base_db::FileId;\n use hir_def::{"}]}