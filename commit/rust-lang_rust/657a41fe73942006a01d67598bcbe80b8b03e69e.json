{"sha": "657a41fe73942006a01d67598bcbe80b8b03e69e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1N2E0MWZlNzM5NDIwMDZhMDFkNjc1OThiY2JlODBiOGIwM2U2OWU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-12T10:28:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-12T10:28:25Z"}, "message": "Rollup merge of #73178 - petrochenkov:explint, r=varkor\n\nexpand: More precise locations for expansion-time lints\n\nFirst commit: a macro expansion doesn't have a `NodeId` associated with it, but it has a parent `DefId` which we can use for linting.\nThe observable effect is that lints associated with macro expansions can now be `allow`ed at finer-grained level than whole crate.\n\nSecond commit: each macro definition has a `NodeId` which we can use for linting, unless that macro definition was decoded from other crate.", "tree": {"sha": "f6f5c255dc50760f8f95ad85f8288acf9ee1b562", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6f5c255dc50760f8f95ad85f8288acf9ee1b562"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/657a41fe73942006a01d67598bcbe80b8b03e69e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe41jJCRBK7hj4Ov3rIwAAdHIIABGGQTZ8KuEJjkRX5SnJlTgc\nQ+FP2/94Zxfk3tJ29ddql5nTR+7iGwXkV4gkiKfrAQnXBsok4+1f48VL78kObTEV\nLOOept6AqAucw6xYPh4oz/w5rqhUUCoOQaPIJnG6LIX1gOg2enI+VDMbBqtK2Mci\nBTkfPNNbPN8yst7czn/cMQQ3HsefhLT1S0zsS33qgvydjLwcOKxR4lxC8OOAJNAj\n76oBttSJdw5nr3OUYZgHgtuRJUqGeLlF6IQchj1jNx3VaySkoRUz1VaXauGpB3Ij\nzFkWK5J7Vi4kMc0ezhtRiJCE2h2eA+zlQwuVss245UnDbm7EwnVupuOkzTiuHqU=\n=LkaJ\n-----END PGP SIGNATURE-----\n", "payload": "tree f6f5c255dc50760f8f95ad85f8288acf9ee1b562\nparent c06799e4c4103330c972eb04f08aa72b7c1d5ace\nparent d60df536d5d6a4ad2d6b2cdf4c443e022fe35d30\nauthor Dylan DPC <dylan.dpc@gmail.com> 1591957705 +0200\ncommitter GitHub <noreply@github.com> 1591957705 +0200\n\nRollup merge of #73178 - petrochenkov:explint, r=varkor\n\nexpand: More precise locations for expansion-time lints\n\nFirst commit: a macro expansion doesn't have a `NodeId` associated with it, but it has a parent `DefId` which we can use for linting.\nThe observable effect is that lints associated with macro expansions can now be `allow`ed at finer-grained level than whole crate.\n\nSecond commit: each macro definition has a `NodeId` which we can use for linting, unless that macro definition was decoded from other crate.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/657a41fe73942006a01d67598bcbe80b8b03e69e", "html_url": "https://github.com/rust-lang/rust/commit/657a41fe73942006a01d67598bcbe80b8b03e69e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/657a41fe73942006a01d67598bcbe80b8b03e69e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c06799e4c4103330c972eb04f08aa72b7c1d5ace", "url": "https://api.github.com/repos/rust-lang/rust/commits/c06799e4c4103330c972eb04f08aa72b7c1d5ace", "html_url": "https://github.com/rust-lang/rust/commit/c06799e4c4103330c972eb04f08aa72b7c1d5ace"}, {"sha": "d60df536d5d6a4ad2d6b2cdf4c443e022fe35d30", "url": "https://api.github.com/repos/rust-lang/rust/commits/d60df536d5d6a4ad2d6b2cdf4c443e022fe35d30", "html_url": "https://github.com/rust-lang/rust/commit/d60df536d5d6a4ad2d6b2cdf4c443e022fe35d30"}], "stats": {"total": 172, "additions": 146, "deletions": 26}, "files": [{"sha": "1b164eae5a34594eb10a36d7d3c313cb348020d9", "filename": "src/librustc_builtin_macros/source_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fsource_util.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -122,6 +122,7 @@ pub fn expand_include<'cx>(\n \n     struct ExpandResult<'a> {\n         p: Parser<'a>,\n+        node_id: ast::NodeId,\n     }\n     impl<'a> base::MacResult for ExpandResult<'a> {\n         fn make_expr(mut self: Box<ExpandResult<'a>>) -> Option<P<ast::Expr>> {\n@@ -130,7 +131,7 @@ pub fn expand_include<'cx>(\n                 self.p.sess.buffer_lint(\n                     &INCOMPLETE_INCLUDE,\n                     self.p.token.span,\n-                    ast::CRATE_NODE_ID,\n+                    self.node_id,\n                     \"include macro expected single expression in source\",\n                 );\n             }\n@@ -158,7 +159,7 @@ pub fn expand_include<'cx>(\n         }\n     }\n \n-    Box::new(ExpandResult { p })\n+    Box::new(ExpandResult { p, node_id: cx.resolver.lint_node_id(cx.current_expansion.id) })\n }\n \n // include_str! : read the given file, insert it as a literal string expr"}, {"sha": "a57ae798ffcebf34fe6d8bd87ac776c05f195105", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -915,6 +915,9 @@ pub trait Resolver {\n \n     fn check_unused_macros(&mut self);\n \n+    /// Some parent node that is close enough to the given macro call.\n+    fn lint_node_id(&mut self, expn_id: ExpnId) -> NodeId;\n+\n     fn has_derive_copy(&self, expn_id: ExpnId) -> bool;\n     fn add_derive_copy(&mut self, expn_id: ExpnId);\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;"}, {"sha": "ca3e68fa6706e25972862965cb03b148d9b942c2", "filename": "src/librustc_expand/mbe/macro_check.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -106,7 +106,7 @@\n //! bound.\n use crate::mbe::{KleeneToken, TokenTree};\n \n-use rustc_ast::ast::NodeId;\n+use rustc_ast::ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast::token::{DelimToken, Token, TokenKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_session::lint::builtin::META_VARIABLE_MISUSE;\n@@ -626,5 +626,8 @@ fn ops_is_prefix(\n }\n \n fn buffer_lint(sess: &ParseSess, span: MultiSpan, node_id: NodeId, message: &str) {\n-    sess.buffer_lint(&META_VARIABLE_MISUSE, span, node_id, message);\n+    // Macros loaded from other crates have dummy node ids.\n+    if node_id != DUMMY_NODE_ID {\n+        sess.buffer_lint(&META_VARIABLE_MISUSE, span, node_id, message);\n+    }\n }"}, {"sha": "db8258a77863b8c3d3043fa656dd8267f2decdfe", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -383,7 +383,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                 }\n             }\n             TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n-                if sess.missing_fragment_specifiers.borrow_mut().remove(&span) {\n+                if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                     return Err((span, \"missing fragment specifier\".to_string()));\n                 }\n             }\n@@ -566,7 +566,7 @@ fn inner_parse_loop<'root, 'tt>(\n \n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n                 TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n-                    if sess.missing_fragment_specifiers.borrow_mut().remove(&span) {\n+                    if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                         return Error(span, \"missing fragment specifier\".to_string());\n                     }\n                 }"}, {"sha": "8cdb5b09c9e8b3dade6fdab096cc3391df435631", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -474,7 +474,9 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt = mbe::quoted::parse(tt.clone().into(), true, sess).pop().unwrap();\n+                        let tt = mbe::quoted::parse(tt.clone().into(), true, sess, def.id)\n+                            .pop()\n+                            .unwrap();\n                         valid &= check_lhs_nt_follows(sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n@@ -491,7 +493,9 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        return mbe::quoted::parse(tt.clone().into(), false, sess).pop().unwrap();\n+                        return mbe::quoted::parse(tt.clone().into(), false, sess, def.id)\n+                            .pop()\n+                            .unwrap();\n                     }\n                 }\n                 sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n@@ -509,9 +513,7 @@ pub fn compile_declarative_macro(\n         valid &= check_lhs_no_empty_seq(sess, slice::from_ref(lhs));\n     }\n \n-    // We use CRATE_NODE_ID instead of `def.id` otherwise we may emit buffered lints for a node id\n-    // that is not lint-checked and trigger the \"failed to process buffered lint here\" bug.\n-    valid &= macro_check::check_meta_variables(sess, ast::CRATE_NODE_ID, def.span, &lhses, &rhses);\n+    valid &= macro_check::check_meta_variables(sess, def.id, def.span, &lhses, &rhses);\n \n     let (transparency, transparency_error) = attr::find_transparency(&def.attrs, macro_rules);\n     match transparency_error {"}, {"sha": "de66c2ada40e62ff32c72272c4f3bce76518b80c", "filename": "src/librustc_expand/mbe/quoted.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -1,6 +1,7 @@\n use crate::mbe::macro_parser;\n use crate::mbe::{Delimited, KleeneOp, KleeneToken, SequenceRepetition, TokenTree};\n \n+use rustc_ast::ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream;\n use rustc_ast_pretty::pprust;\n@@ -36,6 +37,7 @@ pub(super) fn parse(\n     input: tokenstream::TokenStream,\n     expect_matchers: bool,\n     sess: &ParseSess,\n+    node_id: NodeId,\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n     let mut result = Vec::new();\n@@ -46,7 +48,7 @@ pub(super) fn parse(\n     while let Some(tree) = trees.next() {\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e., in `$id:ident` this would parse the `:` and `ident`).\n-        let tree = parse_tree(tree, &mut trees, expect_matchers, sess);\n+        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, node_id);\n         match tree {\n             TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n                 let span = match trees.next() {\n@@ -65,7 +67,10 @@ pub(super) fn parse(\n                     }\n                     tree => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(start_sp),\n                 };\n-                sess.missing_fragment_specifiers.borrow_mut().insert(span);\n+                if node_id != DUMMY_NODE_ID {\n+                    // Macros loaded from other crates have dummy node ids.\n+                    sess.missing_fragment_specifiers.borrow_mut().insert(span, node_id);\n+                }\n                 result.push(TokenTree::MetaVarDecl(span, ident, Ident::invalid()));\n             }\n \n@@ -96,6 +101,7 @@ fn parse_tree(\n     trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n+    node_id: NodeId,\n ) -> TokenTree {\n     // Depending on what `tree` is, we could be parsing different parts of a macro\n     match tree {\n@@ -111,7 +117,7 @@ fn parse_tree(\n                     sess.span_diagnostic.span_err(span.entire(), &msg);\n                 }\n                 // Parse the contents of the sequence itself\n-                let sequence = parse(tts, expect_matchers, sess);\n+                let sequence = parse(tts, expect_matchers, sess, node_id);\n                 // Get the Kleene operator and optional separator\n                 let (separator, kleene) = parse_sep_and_kleene_op(trees, span.entire(), sess);\n                 // Count the number of captured \"names\" (i.e., named metavars)\n@@ -158,7 +164,7 @@ fn parse_tree(\n         // descend into the delimited set and further parse it.\n         tokenstream::TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n             span,\n-            Lrc::new(Delimited { delim, tts: parse(tts, expect_matchers, sess) }),\n+            Lrc::new(Delimited { delim, tts: parse(tts, expect_matchers, sess, node_id) }),\n         ),\n     }\n }"}, {"sha": "b63dd653c4dd8a5209447745508ffc1421c8aab2", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -519,6 +519,12 @@ impl Definitions {\n         let old_index = self.placeholder_field_indices.insert(node_id, index);\n         assert!(old_index.is_none(), \"placeholder field index is reset for a node ID\");\n     }\n+\n+    pub fn lint_node_id(&mut self, expn_id: ExpnId) -> ast::NodeId {\n+        self.invocation_parents\n+            .get(&expn_id)\n+            .map_or(ast::CRATE_NODE_ID, |id| self.def_id_to_node_id[*id])\n+    }\n }\n \n impl DefPathData {"}, {"sha": "1a9bf4e1e8f3d0268f877df2cd00ffcb99f7d8ac", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -307,16 +307,21 @@ fn configure_and_expand_inner<'a>(\n             ecx.check_unused_macros();\n         });\n \n-        let mut missing_fragment_specifiers: Vec<_> =\n-            ecx.parse_sess.missing_fragment_specifiers.borrow().iter().cloned().collect();\n-        missing_fragment_specifiers.sort();\n+        let mut missing_fragment_specifiers: Vec<_> = ecx\n+            .parse_sess\n+            .missing_fragment_specifiers\n+            .borrow()\n+            .iter()\n+            .map(|(span, node_id)| (*span, *node_id))\n+            .collect();\n+        missing_fragment_specifiers.sort_unstable_by_key(|(span, _)| *span);\n \n         let recursion_limit_hit = ecx.reduced_recursion_limit.is_some();\n \n-        for span in missing_fragment_specifiers {\n+        for (span, node_id) in missing_fragment_specifiers {\n             let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n             let msg = \"missing fragment specifier\";\n-            resolver.lint_buffer().buffer_lint(lint, ast::CRATE_NODE_ID, span, msg);\n+            resolver.lint_buffer().buffer_lint(lint, node_id, span, msg);\n         }\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);"}, {"sha": "1b49722355e54133bf79c9a2cfc0fc732753a883", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -288,7 +288,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         // Derives are not included when `invocations` are collected, so we have to add them here.\n         let parent_scope = &ParentScope { derives, ..parent_scope };\n-        let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n+        let node_id = self.lint_node_id(eager_expansion_root);\n+        let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, node_id, force)?;\n \n         let span = invoc.span();\n         invoc_id.set_expn_data(ext.expn_data(\n@@ -338,6 +339,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n         }\n     }\n \n+    fn lint_node_id(&mut self, expn_id: ExpnId) -> NodeId {\n+        self.definitions.lint_node_id(expn_id)\n+    }\n+\n     fn has_derive_copy(&self, expn_id: ExpnId) -> bool {\n         self.containers_deriving_copy.contains(&expn_id)\n     }\n@@ -390,6 +395,7 @@ impl<'a> Resolver<'a> {\n         path: &ast::Path,\n         kind: MacroKind,\n         parent_scope: &ParentScope<'a>,\n+        node_id: NodeId,\n         force: bool,\n     ) -> Result<(Lrc<SyntaxExtension>, Res), Indeterminate> {\n         let (ext, res) = match self.resolve_macro_path(path, Some(kind), parent_scope, true, force)\n@@ -430,7 +436,7 @@ impl<'a> Resolver<'a> {\n             _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n         };\n \n-        self.check_stability_and_deprecation(&ext, path);\n+        self.check_stability_and_deprecation(&ext, path, node_id);\n \n         Ok(if ext.macro_kind() != kind {\n             let expected = kind.descr_expected();\n@@ -984,13 +990,17 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn check_stability_and_deprecation(&mut self, ext: &SyntaxExtension, path: &ast::Path) {\n+    fn check_stability_and_deprecation(\n+        &mut self,\n+        ext: &SyntaxExtension,\n+        path: &ast::Path,\n+        node_id: NodeId,\n+    ) {\n         let span = path.span;\n         if let Some(stability) = &ext.stability {\n             if let StabilityLevel::Unstable { reason, issue, is_soft } = stability.level {\n                 let feature = stability.feature;\n                 if !self.active_features.contains(&feature) && !span.allows_unstable(feature) {\n-                    let node_id = ast::CRATE_NODE_ID;\n                     let lint_buffer = &mut self.lint_buffer;\n                     let soft_handler =\n                         |lint, span, msg: &_| lint_buffer.buffer_lint(lint, node_id, span, msg);"}, {"sha": "58388bafbeddf27bbafbc3d21e0336c00603adcd", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -606,6 +606,7 @@ declare_lint_pass! {\n         INLINE_NO_SANITIZE,\n         ASM_SUB_REGISTER,\n         UNSAFE_OP_IN_UNSAFE_FN,\n+        INCOMPLETE_INCLUDE,\n     ]\n }\n "}, {"sha": "ddbc95fb1b0b8ed61888b9b91a4829924aec1913", "filename": "src/librustc_session/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_session%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Flibrustc_session%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fparse.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -119,7 +119,7 @@ pub struct ParseSess {\n     pub unstable_features: UnstableFeatures,\n     pub config: CrateConfig,\n     pub edition: Edition,\n-    pub missing_fragment_specifiers: Lock<FxHashSet<Span>>,\n+    pub missing_fragment_specifiers: Lock<FxHashMap<Span, NodeId>>,\n     /// Places where raw identifiers were used. This is used for feature-gating raw identifiers.\n     pub raw_identifier_spans: Lock<Vec<Span>>,\n     /// Used to determine and report recursive module inclusions.\n@@ -150,7 +150,7 @@ impl ParseSess {\n             unstable_features: UnstableFeatures::from_environment(),\n             config: FxHashSet::default(),\n             edition: ExpnId::root().expn_data().edition,\n-            missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n+            missing_fragment_specifiers: Default::default(),\n             raw_identifier_spans: Lock::new(Vec::new()),\n             included_mod_stack: Lock::new(vec![]),\n             source_map,"}, {"sha": "4ea89d5adff94a3693949409c987439ad2c48240", "filename": "src/test/ui/lint/expansion-time-include.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Ftest%2Fui%2Flint%2Fexpansion-time-include.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Ftest%2Fui%2Flint%2Fexpansion-time-include.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fexpansion-time-include.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -0,0 +1,4 @@\n+// ignore-test auxiliary file for expansion-time.rs\n+\n+1\n+2"}, {"sha": "6e420c51f0a7ffa9d405279e1294ad47fc5af0ad", "filename": "src/test/ui/lint/expansion-time.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Ftest%2Fui%2Flint%2Fexpansion-time.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Ftest%2Fui%2Flint%2Fexpansion-time.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fexpansion-time.rs?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+#[warn(meta_variable_misuse)]\n+macro_rules! foo {\n+    ( $($i:ident)* ) => { $($i)+ }; //~ WARN meta-variable repeats with different Kleene operator\n+}\n+\n+#[warn(missing_fragment_specifier)]\n+macro_rules! m { ($i) => {} } //~ WARN missing fragment specifier\n+                              //~| WARN this was previously accepted\n+\n+#[warn(soft_unstable)]\n+mod benches {\n+    #[bench] //~ WARN use of unstable library feature 'test'\n+             //~| WARN this was previously accepted\n+    fn foo() {}\n+}\n+\n+#[warn(incomplete_include)]\n+fn main() {\n+    // WARN see in the stderr file, the warning points to the included file.\n+    include!(\"expansion-time-include.rs\");\n+}"}, {"sha": "e6b5cf67e390461673f12563096f2b4ff5629e91", "filename": "src/test/ui/lint/expansion-time.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Ftest%2Fui%2Flint%2Fexpansion-time.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/657a41fe73942006a01d67598bcbe80b8b03e69e/src%2Ftest%2Fui%2Flint%2Fexpansion-time.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fexpansion-time.stderr?ref=657a41fe73942006a01d67598bcbe80b8b03e69e", "patch": "@@ -0,0 +1,56 @@\n+warning: meta-variable repeats with different Kleene operator\n+  --> $DIR/expansion-time.rs:5:29\n+   |\n+LL |     ( $($i:ident)* ) => { $($i)+ };\n+   |                  -          ^^ - conflicting repetition\n+   |                  |\n+   |                  expected repetition\n+   |\n+note: the lint level is defined here\n+  --> $DIR/expansion-time.rs:3:8\n+   |\n+LL | #[warn(meta_variable_misuse)]\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+\n+warning: missing fragment specifier\n+  --> $DIR/expansion-time.rs:9:19\n+   |\n+LL | macro_rules! m { ($i) => {} }\n+   |                   ^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/expansion-time.rs:8:8\n+   |\n+LL | #[warn(missing_fragment_specifier)]\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #40107 <https://github.com/rust-lang/rust/issues/40107>\n+\n+warning: use of unstable library feature 'test': `bench` is a part of custom test frameworks which are unstable\n+  --> $DIR/expansion-time.rs:14:7\n+   |\n+LL |     #[bench]\n+   |       ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/expansion-time.rs:12:8\n+   |\n+LL | #[warn(soft_unstable)]\n+   |        ^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #64266 <https://github.com/rust-lang/rust/issues/64266>\n+\n+warning: include macro expected single expression in source\n+  --> $DIR/expansion-time-include.rs:4:1\n+   |\n+LL | 2\n+   | ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/expansion-time.rs:19:8\n+   |\n+LL | #[warn(incomplete_include)]\n+   |        ^^^^^^^^^^^^^^^^^^\n+\n+warning: 4 warnings emitted\n+"}]}