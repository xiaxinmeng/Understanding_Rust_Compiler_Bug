{"sha": "1999a2288123173b2e487865c9a04386173025f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5OTlhMjI4ODEyMzE3M2IyZTQ4Nzg2NWM5YTA0Mzg2MTczMDI1Zjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-28T15:00:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-28T15:00:25Z"}, "message": "Auto merge of #57760 - dlrobertson:varargs1, r=alexreg\n\nSupport defining C compatible variadic functions\n\n## Summary\n\nAdd support for defining C compatible variadic functions in unsafe rust with\n`extern \"C\"` according to [RFC 2137].\n\n## Details\n\n### Parsing\nWhen parsing a user defined function that is `unsafe` and `extern \"C\"` allow\nvariadic signatures and inject a \"spoofed\" `VaList` in the new functions\nsignature. This allows the user to interact with the variadic arguments via a\n`VaList` instead of manually using `va_start` and `va_end` (See [RFC 2137] for\ndetails).\n\n### Codegen\n\nWhen running codegen for a variadic function, remove the \"spoofed\" `VaList`\nfrom the function signature and inject `va_start` when the arg local\nreferences are created for the function and `va_end` on return.\n\n## TODO\n\n - [x] Get feedback on injecting `va_start/va_end` in MIR vs codegen\n - [x] Properly inject `va_end` - It seems like it should be possible to inject\n       `va_end` on the `TerminatorKind::Return`. I just need to figure out how\n       to get the `LocalRef` here.\n - [x] Properly call Rust defined C variadic functions in Rust - The spoofed\n       `VaList` causes problems here.\n\nRelated to: #44930\n\nr? @ghost\n\n[RFC 2137]: https://github.com/rust-lang/rfcs/blob/master/text/2137-variadic.md", "tree": {"sha": "3fccdd2d553dbd4f0c44a8c4ef280e14a0f9ceee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fccdd2d553dbd4f0c44a8c4ef280e14a0f9ceee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1999a2288123173b2e487865c9a04386173025f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1999a2288123173b2e487865c9a04386173025f7", "html_url": "https://github.com/rust-lang/rust/commit/1999a2288123173b2e487865c9a04386173025f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1999a2288123173b2e487865c9a04386173025f7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "190feb65290d39d7ab6d44e994bd99188d339f16", "url": "https://api.github.com/repos/rust-lang/rust/commits/190feb65290d39d7ab6d44e994bd99188d339f16", "html_url": "https://github.com/rust-lang/rust/commit/190feb65290d39d7ab6d44e994bd99188d339f16"}, {"sha": "f7dd4389f8145fe0f29c5b29784b244fa38d2bfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7dd4389f8145fe0f29c5b29784b244fa38d2bfb", "html_url": "https://github.com/rust-lang/rust/commit/f7dd4389f8145fe0f29c5b29784b244fa38d2bfb"}], "stats": {"total": 2680, "additions": 1778, "deletions": 902}, "files": [{"sha": "9e7968d906fbf5ff62a3824b764c43a690bd1644", "filename": "src/doc/unstable-book/src/language-features/c-variadic.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fc-variadic.md", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fc-variadic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fc-variadic.md?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -0,0 +1,24 @@\n+# `c_variadic`\n+\n+The tracking issue for this feature is: [#44930]\n+\n+[#44930]: https://github.com/rust-lang/rust/issues/44930\n+\n+------------------------\n+\n+The `c_variadic` language feature enables C-variadic functions to be\n+defined in Rust. The may be called both from within Rust and via FFI.\n+\n+## Examples\n+\n+```rust\n+#![feature(c_variadic)]\n+\n+pub unsafe extern \"C\" fn add(n: usize, mut args: ...) -> usize {\n+    let mut sum = 0;\n+    for _ in 0..n {\n+        sum += args.arg::<usize>();\n+    }\n+    sum\n+}\n+```"}, {"sha": "77762116e6b1c072c650ff19939447044a21343a", "filename": "src/doc/unstable-book/src/library-features/c-variadic.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fc-variadic.md", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fc-variadic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fc-variadic.md?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -0,0 +1,26 @@\n+# `c_variadic`\n+\n+The tracking issue for this feature is: [#44930]\n+\n+[#44930]: https://github.com/rust-lang/rust/issues/44930\n+\n+------------------------\n+\n+The `c_variadic` library feature exposes the `VaList` structure,\n+Rust's analogue of C's `va_list` type.\n+\n+## Examples\n+\n+```rust\n+#![feature(c_variadic)]\n+\n+use std::ffi::VaList;\n+\n+pub unsafe extern \"C\" fn vadd(n: usize, mut args: VaList) -> usize {\n+    let mut sum = 0;\n+    for _ in 0..n {\n+        sum += args.arg::<usize>();\n+    }\n+    sum\n+}\n+```"}, {"sha": "8e4b9a5e8e641db7e529351fe4682b87cfc76d9b", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -617,6 +617,9 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyKind::Typeof(ref expression) => {\n             visitor.visit_anon_const(expression)\n         }\n+        TyKind::CVarArgs(ref lt) => {\n+            visitor.visit_lifetime(lt)\n+        }\n         TyKind::Infer | TyKind::Err => {}\n     }\n }"}, {"sha": "19bb7f41e1b0211eac3140ca54875adcfdfd7d01", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -74,7 +74,7 @@ const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n \n-    // Used to assign ids to HIR nodes that do not directly correspond to an AST node.\n+    /// Used to assign ids to HIR nodes that do not directly correspond to an AST node.\n     sess: &'a Session,\n \n     cstore: &'a dyn CrateStore,\n@@ -107,25 +107,25 @@ pub struct LoweringContext<'a> {\n     /// written at all (e.g., `&T` or `std::cell::Ref<T>`).\n     anonymous_lifetime_mode: AnonymousLifetimeMode,\n \n-    // Used to create lifetime definitions from in-band lifetime usages.\n-    // e.g., `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n-    // When a named lifetime is encountered in a function or impl header and\n-    // has not been defined\n-    // (i.e., it doesn't appear in the in_scope_lifetimes list), it is added\n-    // to this list. The results of this list are then added to the list of\n-    // lifetime definitions in the corresponding impl or function generics.\n+    /// Used to create lifetime definitions from in-band lifetime usages.\n+    /// e.g., `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n+    /// When a named lifetime is encountered in a function or impl header and\n+    /// has not been defined\n+    /// (i.e., it doesn't appear in the in_scope_lifetimes list), it is added\n+    /// to this list. The results of this list are then added to the list of\n+    /// lifetime definitions in the corresponding impl or function generics.\n     lifetimes_to_define: Vec<(Span, ParamName)>,\n \n-    // Whether or not in-band lifetimes are being collected. This is used to\n-    // indicate whether or not we're in a place where new lifetimes will result\n-    // in in-band lifetime definitions, such a function or an impl header,\n-    // including implicit lifetimes from `impl_header_lifetime_elision`.\n+    /// Whether or not in-band lifetimes are being collected. This is used to\n+    /// indicate whether or not we're in a place where new lifetimes will result\n+    /// in in-band lifetime definitions, such a function or an impl header,\n+    /// including implicit lifetimes from `impl_header_lifetime_elision`.\n     is_collecting_in_band_lifetimes: bool,\n \n-    // Currently in-scope lifetimes defined in impl headers, fn headers, or HRTB.\n-    // When `is_collectin_in_band_lifetimes` is true, each lifetime is checked\n-    // against this list to see if it is already in-scope, or if a definition\n-    // needs to be created for it.\n+    /// Currently in-scope lifetimes defined in impl headers, fn headers, or HRTB.\n+    /// When `is_collectin_in_band_lifetimes` is true, each lifetime is checked\n+    /// against this list to see if it is already in-scope, or if a definition\n+    /// needs to be created for it.\n     in_scope_lifetimes: Vec<Ident>,\n \n     current_module: NodeId,\n@@ -954,7 +954,7 @@ impl<'a> LoweringContext<'a> {\n         let decl = FnDecl {\n             inputs: vec![],\n             output,\n-            variadic: false\n+            c_variadic: false\n         };\n         let body_id = self.record_body(body_expr, Some(&decl));\n         self.is_generator = prev_is_generator;\n@@ -1345,6 +1345,12 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n             TyKind::Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n+            TyKind::CVarArgs => {\n+                // Create the implicit lifetime of the \"spoofed\" `VaList`.\n+                let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n+                let lt = self.new_implicit_lifetime(span);\n+                hir::TyKind::CVarArgs(lt)\n+            },\n         };\n \n         let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(t.id);\n@@ -2112,7 +2118,7 @@ impl<'a> LoweringContext<'a> {\n         P(hir::FnDecl {\n             inputs,\n             output,\n-            variadic: decl.variadic,\n+            c_variadic: decl.c_variadic,\n             implicit_self: decl.inputs.get(0).map_or(\n                 hir::ImplicitSelfKind::None,\n                 |arg| {\n@@ -3967,7 +3973,7 @@ impl<'a> LoweringContext<'a> {\n                     let outer_decl = FnDecl {\n                         inputs: decl.inputs.clone(),\n                         output: FunctionRetTy::Default(fn_decl_span),\n-                        variadic: false,\n+                        c_variadic: false,\n                     };\n                     // We need to lower the declaration outside the new scope, because we\n                     // have to conserve the state of being inside a loop condition for the"}, {"sha": "d8169d05dd4d0df0ac64ca3291567b7d11eb1193", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1829,6 +1829,9 @@ pub enum TyKind {\n     Infer,\n     /// Placeholder for a type that has failed to be defined.\n     Err,\n+    /// Placeholder for C-variadic arguments. We \"spoof\" the `VaList` created\n+    /// from the variadic arguments. This type is only valid up to typeck.\n+    CVarArgs(Lifetime),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -1865,7 +1868,7 @@ pub struct Arg {\n pub struct FnDecl {\n     pub inputs: HirVec<Ty>,\n     pub output: FunctionRetTy,\n-    pub variadic: bool,\n+    pub c_variadic: bool,\n     /// Does the function have an implicit self?\n     pub implicit_self: ImplicitSelfKind,\n }"}, {"sha": "dab4b9c824d9a9389ea8fec78ccaaca87f6a50f1", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -434,6 +434,9 @@ impl<'a> State<'a> {\n                 self.s.word(\"/*ERROR*/\")?;\n                 self.pclose()?;\n             }\n+            hir::TyKind::CVarArgs(_) => {\n+                self.s.word(\"...\")?;\n+            }\n         }\n         self.end()\n     }\n@@ -2004,7 +2007,7 @@ impl<'a> State<'a> {\n             s.print_type(ty)?;\n             s.end()\n         })?;\n-        if decl.variadic {\n+        if decl.c_variadic {\n             self.s.word(\", ...\")?;\n         }\n         self.pclose()?;"}, {"sha": "775822786900a9d39d0bdaff718544fe37d2c86e", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -361,13 +361,14 @@ impl_stable_hash_for!(enum hir::TyKind {\n     TraitObject(trait_refs, lifetime),\n     Typeof(body_id),\n     Err,\n-    Infer\n+    Infer,\n+    CVarArgs(lt),\n });\n \n impl_stable_hash_for!(struct hir::FnDecl {\n     inputs,\n     output,\n-    variadic,\n+    c_variadic,\n     implicit_self\n });\n "}, {"sha": "f77a88128f252ef36deb2a9665d78a087547da56", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -232,7 +232,7 @@ impl_stable_hash_for!(struct ty::GenSig<'tcx> {\n \n impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n     inputs_and_output,\n-    variadic,\n+    c_variadic,\n     unsafety,\n     abi\n });"}, {"sha": "832391d44162bba2ca5610f3d7d88c11e0938207", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -764,6 +764,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     });\n                 }\n             }\n+            hir::TyKind::CVarArgs(ref lt) => {\n+                // Resolve the generated lifetime for the C-variadic arguments.\n+                // The lifetime is generated in AST -> HIR lowering.\n+                if lt.name.is_elided() {\n+                    self.resolve_elided_lifetimes(vec![lt])\n+                }\n+            }\n             _ => intravisit::walk_ty(self, ty),\n         }\n     }\n@@ -2225,18 +2232,22 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 if let hir::TyKind::BareFn(_) = ty.node {\n                     self.outer_index.shift_in(1);\n                 }\n-                if let hir::TyKind::TraitObject(ref bounds, ref lifetime) = ty.node {\n-                    for bound in bounds {\n-                        self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n-                    }\n+                match ty.node {\n+                    hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n+                        for bound in bounds {\n+                            self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                        }\n \n-                    // Stay on the safe side and don't include the object\n-                    // lifetime default (which may not end up being used).\n-                    if !lifetime.is_elided() {\n-                        self.visit_lifetime(lifetime);\n+                        // Stay on the safe side and don't include the object\n+                        // lifetime default (which may not end up being used).\n+                        if !lifetime.is_elided() {\n+                            self.visit_lifetime(lifetime);\n+                        }\n+                    }\n+                    hir::TyKind::CVarArgs(_) => {}\n+                    _ => {\n+                        intravisit::walk_ty(self, ty);\n                     }\n-                } else {\n-                    intravisit::walk_ty(self, ty);\n                 }\n                 if let hir::TyKind::BareFn(_) = ty.node {\n                     self.outer_index.shift_out(1);"}, {"sha": "e7cc9618080c2689f0196b84364dfcc4126612ec", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1944,7 +1944,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 if let ty::FnSig {\n                     unsafety: hir::Unsafety::Normal,\n                     abi: Abi::Rust,\n-                    variadic: false,\n+                    c_variadic: false,\n                     ..\n                 } = self_ty.fn_sig(self.tcx()).skip_binder()\n                 {"}, {"sha": "9767396147cf911c098185dfbbf12f3409fc5285", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -2453,7 +2453,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.mk_fn_sig(\n                 params_iter,\n                 s.output(),\n-                s.variadic,\n+                s.c_variadic,\n                 hir::Unsafety::Normal,\n                 abi::Abi::Rust,\n             )\n@@ -2779,7 +2779,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn mk_fn_sig<I>(self,\n                         inputs: I,\n                         output: I::Item,\n-                        variadic: bool,\n+                        c_variadic: bool,\n                         unsafety: hir::Unsafety,\n                         abi: abi::Abi)\n         -> <I::Item as InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>>::Output\n@@ -2788,7 +2788,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         inputs.chain(iter::once(output)).intern_with(|xs| ty::FnSig {\n             inputs_and_output: self.intern_type_list(xs),\n-            variadic, unsafety, abi\n+            c_variadic, unsafety, abi\n         })\n     }\n "}, {"sha": "49ebd202813f636b7518493d91a746b15eae453c", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n                 sig.map_bound(|sig| tcx.mk_fn_sig(\n                     iter::once(*env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n                     sig.output(),\n-                    sig.variadic,\n+                    sig.c_variadic,\n                     sig.unsafety,\n                     sig.abi\n                 ))"}, {"sha": "2940757fa905be45e68db9baa12418123ca595c8", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -147,9 +147,9 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n     {\n         let tcx = relation.tcx();\n \n-        if a.variadic != b.variadic {\n+        if a.c_variadic != b.c_variadic {\n             return Err(TypeError::VariadicMismatch(\n-                expected_found(relation, &a.variadic, &b.variadic)));\n+                expected_found(relation, &a.c_variadic, &b.c_variadic)));\n         }\n         let unsafety = relation.relate(&a.unsafety, &b.unsafety)?;\n         let abi = relation.relate(&a.abi, &b.abi)?;\n@@ -171,7 +171,7 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n             });\n         Ok(ty::FnSig {\n             inputs_and_output: tcx.mk_type_list(inputs_and_output)?,\n-            variadic: a.variadic,\n+            c_variadic: a.c_variadic,\n             unsafety,\n             abi,\n         })"}, {"sha": "f1a465e1f1724b384b1c7df0dbe0671a73965f9b", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -396,7 +396,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n         tcx.lift(&self.inputs_and_output).map(|x| {\n             ty::FnSig {\n                 inputs_and_output: x,\n-                variadic: self.variadic,\n+                c_variadic: self.c_variadic,\n                 unsafety: self.unsafety,\n                 abi: self.abi,\n             }\n@@ -832,7 +832,7 @@ BraceStructTypeFoldableImpl! {\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n-        inputs_and_output, variadic, unsafety, abi\n+        inputs_and_output, c_variadic, unsafety, abi\n     }\n }\n "}, {"sha": "3fd2e38a3d3e51cd10baca00a68b8bd20bbf766c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -977,13 +977,13 @@ impl<'tcx> PolyGenSig<'tcx> {\n /// Signature of a function type, which I have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n-/// - `inputs` is the list of arguments and their modes.\n-/// - `output` is the return type.\n-/// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n+/// - `inputs`: is the list of arguments and their modes.\n+/// - `output`: is the return type.\n+/// - `c_variadic`: indicates whether this is a C-variadic function.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct FnSig<'tcx> {\n     pub inputs_and_output: &'tcx List<Ty<'tcx>>,\n-    pub variadic: bool,\n+    pub c_variadic: bool,\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n }\n@@ -1016,8 +1016,8 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.output())\n     }\n-    pub fn variadic(&self) -> bool {\n-        self.skip_binder().variadic\n+    pub fn c_variadic(&self) -> bool {\n+        self.skip_binder().c_variadic\n     }\n     pub fn unsafety(&self) -> hir::Unsafety {\n         self.skip_binder().unsafety"}, {"sha": "aecef3c5ec71e4d5439efd1718065508b0e1c1d2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -360,7 +360,7 @@ impl PrintContext {\n     fn fn_sig<F: fmt::Write>(&mut self,\n                              f: &mut F,\n                              inputs: &[Ty<'_>],\n-                             variadic: bool,\n+                             c_variadic: bool,\n                              output: Ty<'_>)\n                              -> fmt::Result {\n         write!(f, \"(\")?;\n@@ -370,7 +370,7 @@ impl PrintContext {\n             for &ty in inputs {\n                 print!(f, self, write(\", \"), print_display(ty))?;\n             }\n-            if variadic {\n+            if c_variadic {\n                 write!(f, \", ...\")?;\n             }\n         }\n@@ -1074,10 +1074,10 @@ define_print! {\n             }\n \n             write!(f, \"fn\")?;\n-            cx.fn_sig(f, self.inputs(), self.variadic, self.output())\n+            cx.fn_sig(f, self.inputs(), self.c_variadic, self.output())\n         }\n         debug {\n-            write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs(), self.variadic, self.output())\n+            write!(f, \"({:?}; c_variadic: {})->{:?}\", self.inputs(), self.c_variadic, self.output())\n         }\n     }\n }"}, {"sha": "49c9555a2c682d74f642016699c9e4116940b953", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -258,7 +258,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             val\n         };\n         match self.mode {\n-            PassMode::Ignore => {},\n+            PassMode::Ignore(_) => {}\n             PassMode::Pair(..) => {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n@@ -422,7 +422,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n \n         let mut inputs = sig.inputs();\n         let extra_args = if sig.abi == RustCall {\n-            assert!(!sig.variadic && extra_args.is_empty());\n+            assert!(!sig.c_variadic && extra_args.is_empty());\n \n             match sig.inputs().last().unwrap().sty {\n                 ty::Tuple(ref tupled_arguments) => {\n@@ -435,7 +435,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 }\n             }\n         } else {\n-            assert!(sig.variadic || extra_args.is_empty());\n+            assert!(sig.c_variadic || extra_args.is_empty());\n             extra_args\n         };\n \n@@ -507,6 +507,14 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             }\n         };\n \n+        // Store the index of the last argument. This is useful for working with\n+        // C-compatible variadic arguments.\n+        let last_arg_idx = if sig.inputs().is_empty() {\n+            None\n+        } else {\n+            Some(sig.inputs().len() - 1)\n+        };\n+\n         let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n             let is_return = arg_idx.is_none();\n             let mut arg = mk_arg_type(ty, arg_idx);\n@@ -516,7 +524,30 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 // The same is true for s390x-unknown-linux-gnu\n                 // and sparc64-unknown-linux-gnu.\n                 if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n-                    arg.mode = PassMode::Ignore;\n+                    arg.mode = PassMode::Ignore(IgnoreMode::Zst);\n+                }\n+            }\n+\n+            // If this is a C-variadic function, this is not the return value,\n+            // and there is one or more fixed arguments; ensure that the `VaList`\n+            // is ignored as an argument.\n+            if sig.c_variadic {\n+                match (last_arg_idx, arg_idx) {\n+                    (Some(last_idx), Some(cur_idx)) if last_idx == cur_idx => {\n+                        let va_list_did = match cx.tcx.lang_items().va_list() {\n+                            Some(did) => did,\n+                            None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n+                        };\n+                        match ty.sty {\n+                            ty::Adt(def, _) if def.did == va_list_did => {\n+                                // This is the \"spoofed\" `VaList`. Set the arguments mode\n+                                // so that it will be ignored.\n+                                arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n+                            },\n+                            _ => (),\n+                        }\n+                    }\n+                    _ => {}\n                 }\n             }\n \n@@ -558,7 +589,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             args: inputs.iter().chain(extra_args).enumerate().map(|(i, ty)| {\n                 arg_of(ty, Some(i))\n             }).collect(),\n-            variadic: sig.variadic,\n+            c_variadic: sig.c_variadic,\n             conv,\n         };\n         fn_ty.adjust_for_abi(cx, sig.abi);\n@@ -646,7 +677,9 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         );\n \n         let llreturn_ty = match self.ret.mode {\n-            PassMode::Ignore => cx.type_void(),\n+            PassMode::Ignore(IgnoreMode::Zst) => cx.type_void(),\n+            PassMode::Ignore(IgnoreMode::CVarArgs) =>\n+                bug!(\"`va_list` should never be a return type\"),\n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 self.ret.layout.immediate_llvm_type(cx)\n             }\n@@ -664,7 +697,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             }\n \n             let llarg_ty = match arg.mode {\n-                PassMode::Ignore => continue,\n+                PassMode::Ignore(_) => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_llvm_type(cx),\n                 PassMode::Pair(..) => {\n                     llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 0, true));\n@@ -684,7 +717,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             llargument_tys.push(llarg_ty);\n         }\n \n-        if self.variadic {\n+        if self.c_variadic {\n             cx.type_variadic_func(&llargument_tys, llreturn_ty)\n         } else {\n             cx.type_func(&llargument_tys, llreturn_ty)\n@@ -733,7 +766,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 apply(&ArgAttributes::new());\n             }\n             match arg.mode {\n-                PassMode::Ignore => {}\n+                PassMode::Ignore(_) => {}\n                 PassMode::Direct(ref attrs) |\n                 PassMode::Indirect(ref attrs, None) => apply(attrs),\n                 PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n@@ -780,7 +813,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 apply(&ArgAttributes::new());\n             }\n             match arg.mode {\n-                PassMode::Ignore => {}\n+                PassMode::Ignore(_) => {}\n                 PassMode::Direct(ref attrs) |\n                 PassMode::Indirect(ref attrs, None) => apply(attrs),\n                 PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {"}, {"sha": "8b218ab39d99b520d60a3faa078b6d05d736d6ff", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -143,7 +143,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.pop();\n             }\n \n-            if sig.variadic {\n+            if sig.c_variadic {\n                 if !sig.inputs().is_empty() {\n                     output.push_str(\", ...\");\n                 } else {"}, {"sha": "3268af396a2f4f475c2353b3ed76ea66083c8ec9", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -136,22 +136,18 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let tp_ty = substs.type_at(0);\n                 self.const_usize(self.size_of(tp_ty).bytes())\n             }\n-            func @ \"va_start\" | func @ \"va_end\" => {\n-                let va_list = match (tcx.lang_items().va_list(), &result.layout.ty.sty) {\n-                    (Some(did), ty::Adt(def, _)) if def.did == did => args[0].immediate(),\n-                    (Some(_), _) => self.load(args[0].immediate(),\n-                                              tcx.data_layout.pointer_align.abi),\n-                    (None, _) => bug!(\"va_list language item must be defined\")\n-                };\n-                let intrinsic = self.cx().get_intrinsic(&format!(\"llvm.{}\", func));\n-                self.call(intrinsic, &[va_list], None)\n+            \"va_start\" => {\n+                self.va_start(args[0].immediate())\n+            }\n+            \"va_end\" => {\n+                self.va_end(args[0].immediate())\n             }\n             \"va_copy\" => {\n                 let va_list = match (tcx.lang_items().va_list(), &result.layout.ty.sty) {\n                     (Some(did), ty::Adt(def, _)) if def.did == did => args[0].immediate(),\n                     (Some(_), _)  => self.load(args[0].immediate(),\n                                                tcx.data_layout.pointer_align.abi),\n-                    (None, _) => bug!(\"va_list language item must be defined\")\n+                    (None, _) => bug!(\"`va_list` language item must be defined\")\n                 };\n                 let intrinsic = self.cx().get_intrinsic(&(\"llvm.va_copy\"));\n                 self.call(intrinsic, &[llresult, va_list], None);\n@@ -722,6 +718,41 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let expect = self.get_intrinsic(&\"llvm.expect.i1\");\n         self.call(expect, &[cond, self.const_bool(expected)], None)\n     }\n+\n+    fn va_start(&mut self, list: &'ll Value) -> &'ll Value {\n+        let target = &self.cx.tcx.sess.target.target;\n+        let arch = &target.arch;\n+        // A pointer to the architecture specific structure is passed to this\n+        // function. For pointer variants (i686, RISC-V, Windows, etc), we\n+        // should do do nothing, as the address to the pointer is needed. For\n+        // architectures with a architecture specific structure (`Aarch64`,\n+        // `X86_64`, etc), this function should load the structure from the\n+        // address provided.\n+        let va_list = match &**arch {\n+            _ if target.options.is_like_windows => list,\n+            \"aarch64\" if target.target_os == \"ios\" => list,\n+            \"aarch64\" | \"x86_64\" | \"powerpc\" =>\n+                self.load(list, self.tcx().data_layout.pointer_align.abi),\n+            _ => list,\n+        };\n+        let intrinsic = self.cx().get_intrinsic(\"llvm.va_start\");\n+        self.call(intrinsic, &[va_list], None)\n+    }\n+\n+    fn va_end(&mut self, list: &'ll Value) -> &'ll Value {\n+        let target = &self.cx.tcx.sess.target.target;\n+        let arch = &target.arch;\n+        // See the comment in `va_start` for the purpose of the following.\n+        let va_list = match &**arch {\n+            _ if target.options.is_like_windows => list,\n+            \"aarch64\" if target.target_os == \"ios\" => list,\n+            \"aarch64\" | \"x86_64\" | \"powerpc\" =>\n+                self.load(list, self.tcx().data_layout.pointer_align.abi),\n+            _ => list,\n+        };\n+        let intrinsic = self.cx().get_intrinsic(\"llvm.va_end\");\n+        self.call(intrinsic, &[va_list], None)\n+    }\n }\n \n fn copy_intrinsic("}, {"sha": "7f0cdb9f580088b1b49f0e0ee1d08596f42afcb7", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -36,10 +36,10 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn predefine_fn(&self,\n-                              instance: Instance<'tcx>,\n-                              linkage: Linkage,\n-                              visibility: Visibility,\n-                              symbol_name: &str) {\n+                    instance: Instance<'tcx>,\n+                    linkage: Linkage,\n+                    visibility: Visibility,\n+                    symbol_name: &str) {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n "}, {"sha": "7aceaea4510ceb156246f1cea7cafcb110b548fc", "filename": "src/librustc_codegen_llvm/va_arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fva_arg.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -109,12 +109,12 @@ pub(super) fn emit_va_arg(\n                             Align::from_bytes(4).unwrap(), true)\n         }\n         // Windows Aarch64\n-        (\"aarch4\", true) => {\n+        (\"aarch64\", true) => {\n             emit_ptr_va_arg(bx, addr, target_ty, false,\n                             Align::from_bytes(8).unwrap(), false)\n         }\n         // iOS Aarch64\n-        (\"aarch4\", _) if target.target_os == \"ios\" => {\n+        (\"aarch64\", _) if target.target_os == \"ios\" => {\n             emit_ptr_va_arg(bx, addr, target_ty, false,\n                             Align::from_bytes(8).unwrap(), true)\n         }"}, {"sha": "627380ee38ff14d6bd16b99ab41bd79635c13c71", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 773, "deletions": 631, "changes": 1404, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::interpret::EvalErrorKind;\n-use rustc_target::abi::call::{ArgType, FnType, PassMode};\n+use rustc_target::abi::call::{ArgType, FnType, PassMode, IgnoreMode};\n use rustc_target::spec::abi::Abi;\n use rustc_mir::monomorphize;\n use crate::base;\n@@ -13,730 +13,872 @@ use crate::meth;\n \n use crate::traits::*;\n \n+use std::borrow::Cow;\n+\n use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n \n use super::{FunctionCx, LocalRef};\n use super::place::PlaceRef;\n-use super::operand::OperandRef;\n+use super::operand::{OperandValue, OperandRef};\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n-impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n-    pub fn codegen_block(\n-        &mut self,\n-        bb: mir::BasicBlock,\n-    ) {\n-        let mut bx = self.build_block(bb);\n-        let data = &self.mir[bb];\n+/// Used by `FunctionCx::codegen_terminator` for emitting common patterns\n+/// e.g., creating a basic block, calling a function, etc.\n+struct TerminatorCodegenHelper<'a, 'tcx> {\n+    bb: &'a mir::BasicBlock,\n+    terminator: &'a mir::Terminator<'tcx>,\n+    funclet_bb: Option<mir::BasicBlock>,\n+}\n \n-        debug!(\"codegen_block({:?}={:?})\", bb, data);\n+impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n+    /// Returns the associated funclet from `FunctionCx::funclets` for the\n+    /// `funclet_bb` member if it is not `None`.\n+    fn funclet<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n+        &self,\n+        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n+    ) -> Option<&'c Bx::Funclet> {\n+        match self.funclet_bb {\n+            Some(funcl) => fx.funclets[funcl].as_ref(),\n+            None => None,\n+        }\n+    }\n \n-        for statement in &data.statements {\n-            bx = self.codegen_statement(bx, statement);\n+    fn lltarget<'b, 'c, Bx: BuilderMethods<'b, 'tcx>>(\n+        &self,\n+        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n+        target: mir::BasicBlock,\n+    ) -> (Bx::BasicBlock, bool) {\n+        let span = self.terminator.source_info.span;\n+        let lltarget = fx.blocks[target];\n+        let target_funclet = fx.cleanup_kinds[target].funclet_bb(target);\n+        match (self.funclet_bb, target_funclet) {\n+            (None, None) => (lltarget, false),\n+            (Some(f), Some(t_f)) if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) =>\n+                (lltarget, false),\n+            // jump *into* cleanup - need a landing pad if GNU\n+            (None, Some(_)) => (fx.landing_pad_to(target), false),\n+            (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator),\n+            (Some(_), Some(_)) => (fx.landing_pad_to(target), true),\n         }\n+    }\n \n-        self.codegen_terminator(bx, bb, data.terminator());\n+    /// Create a basic block.\n+    fn llblock<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n+        &self,\n+        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n+        target: mir::BasicBlock,\n+    ) -> Bx::BasicBlock {\n+        let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n+        if is_cleanupret {\n+            // MSVC cross-funclet jump - need a trampoline\n+\n+            debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n+            let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", self.bb, target);\n+            let mut trampoline = fx.new_block(name);\n+            trampoline.cleanup_ret(self.funclet(fx).unwrap(),\n+                                   Some(lltarget));\n+            trampoline.llbb()\n+        } else {\n+            lltarget\n+        }\n     }\n \n-    fn codegen_terminator(\n-        &mut self,\n-        mut bx: Bx,\n-        bb: mir::BasicBlock,\n-        terminator: &mir::Terminator<'tcx>\n+    fn funclet_br<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n+        &self,\n+        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n+        bx: &mut Bx,\n+        target: mir::BasicBlock,\n     ) {\n-        debug!(\"codegen_terminator: {:?}\", terminator);\n-\n-        // Create the cleanup bundle, if needed.\n-        let tcx = self.cx.tcx();\n-        let span = terminator.source_info.span;\n-        let funclet_bb = self.cleanup_kinds[bb].funclet_bb(bb);\n+        let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n+        if is_cleanupret {\n+            // micro-optimization: generate a `ret` rather than a jump\n+            // to a trampoline.\n+            bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n+        } else {\n+            bx.br(lltarget);\n+        }\n+    }\n \n-        // HACK(eddyb) force the right lifetimes, NLL can't figure them out.\n-        fn funclet_closure_factory<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-            funclet_bb: Option<mir::BasicBlock>\n-        ) -> impl for<'b> Fn(\n-            &'b FunctionCx<'a, 'tcx, Bx>,\n-        ) -> Option<&'b Bx::Funclet> {\n-            move |this| {\n-                match funclet_bb {\n-                    Some(funclet_bb) => this.funclets[funclet_bb].as_ref(),\n-                    None => None,\n-                }\n+    /// Call `fn_ptr` of `fn_ty` with the arguments `llargs`, the optional\n+    /// return destination `destination` and the cleanup function `cleanup`.\n+    fn do_call<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n+        &self,\n+        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n+        bx: &mut Bx,\n+        fn_ty: FnType<'tcx, Ty<'tcx>>,\n+        fn_ptr: Bx::Value,\n+        llargs: &[Bx::Value],\n+        destination: Option<(ReturnDest<'tcx, Bx::Value>, mir::BasicBlock)>,\n+        cleanup: Option<mir::BasicBlock>,\n+    ) {\n+        if let Some(cleanup) = cleanup {\n+            let ret_bx = if let Some((_, target)) = destination {\n+                fx.blocks[target]\n+            } else {\n+                fx.unreachable_block()\n+            };\n+            let invokeret = bx.invoke(fn_ptr,\n+                                      &llargs,\n+                                      ret_bx,\n+                                      self.llblock(fx, cleanup),\n+                                      self.funclet(fx));\n+            bx.apply_attrs_callsite(&fn_ty, invokeret);\n+\n+            if let Some((ret_dest, target)) = destination {\n+                let mut ret_bx = fx.build_block(target);\n+                fx.set_debug_loc(&mut ret_bx, self.terminator.source_info);\n+                fx.store_return(&mut ret_bx, ret_dest, &fn_ty.ret, invokeret);\n             }\n-        }\n-        let funclet = funclet_closure_factory(funclet_bb);\n-\n-        let lltarget = |this: &mut Self, target: mir::BasicBlock| {\n-            let lltarget = this.blocks[target];\n-            let target_funclet = this.cleanup_kinds[target].funclet_bb(target);\n-            match (funclet_bb, target_funclet) {\n-                (None, None) => (lltarget, false),\n-                (Some(f), Some(t_f))\n-                    if f == t_f || !base::wants_msvc_seh(tcx.sess)\n-                    => (lltarget, false),\n-                (None, Some(_)) => {\n-                    // jump *into* cleanup - need a landing pad if GNU\n-                    (this.landing_pad_to(target), false)\n-                }\n-                (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", terminator),\n-                (Some(_), Some(_)) => {\n-                    (this.landing_pad_to(target), true)\n-                }\n+        } else {\n+            let llret = bx.call(fn_ptr, &llargs, self.funclet(fx));\n+            bx.apply_attrs_callsite(&fn_ty, llret);\n+            if fx.mir[*self.bb].is_cleanup {\n+                // Cleanup is always the cold path. Don't inline\n+                // drop glue. Also, when there is a deeply-nested\n+                // struct, there are \"symmetry\" issues that cause\n+                // exponential inlining - see issue #41696.\n+                bx.do_not_inline(llret);\n             }\n-        };\n-\n-        let llblock = |this: &mut Self, target: mir::BasicBlock| {\n-            let (lltarget, is_cleanupret) = lltarget(this, target);\n-            if is_cleanupret {\n-                // MSVC cross-funclet jump - need a trampoline\n \n-                debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n-                let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n-                let mut trampoline = this.new_block(name);\n-                trampoline.cleanup_ret(funclet(this).unwrap(), Some(lltarget));\n-                trampoline.llbb()\n+            if let Some((ret_dest, target)) = destination {\n+                fx.store_return(bx, ret_dest, &fn_ty.ret, llret);\n+                self.funclet_br(fx, bx, target);\n             } else {\n-                lltarget\n+                bx.unreachable();\n             }\n-        };\n-\n-        let funclet_br =\n-            |this: &mut Self, bx: &mut Bx, target: mir::BasicBlock| {\n-                let (lltarget, is_cleanupret) = lltarget(this, target);\n-                if is_cleanupret {\n-                    // micro-optimization: generate a `ret` rather than a jump\n-                    // to a trampoline.\n-                    bx.cleanup_ret(funclet(this).unwrap(), Some(lltarget));\n-                } else {\n-                    bx.br(lltarget);\n-                }\n-            };\n+        }\n+    }\n+}\n \n-        let do_call = |\n-            this: &mut Self,\n-            bx: &mut Bx,\n-            fn_ty: FnType<'tcx, Ty<'tcx>>,\n-            fn_ptr: Bx::Value,\n-            llargs: &[Bx::Value],\n-            destination: Option<(ReturnDest<'tcx, Bx::Value>, mir::BasicBlock)>,\n-            cleanup: Option<mir::BasicBlock>\n-        | {\n-            if let Some(cleanup) = cleanup {\n-                let ret_bx = if let Some((_, target)) = destination {\n-                    this.blocks[target]\n-                } else {\n-                    this.unreachable_block()\n-                };\n-                let invokeret = bx.invoke(fn_ptr,\n-                                          &llargs,\n-                                          ret_bx,\n-                                          llblock(this, cleanup),\n-                                          funclet(this));\n-                bx.apply_attrs_callsite(&fn_ty, invokeret);\n-\n-                if let Some((ret_dest, target)) = destination {\n-                    let mut ret_bx = this.build_block(target);\n-                    this.set_debug_loc(&mut ret_bx, terminator.source_info);\n-                    this.store_return(&mut ret_bx, ret_dest, &fn_ty.ret, invokeret);\n-                }\n+/// Codegen implementations for some terminator variants.\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    /// Generates code for a `Resume` terminator.\n+    fn codegen_resume_terminator<'b>(\n+        &mut self,\n+        helper: TerminatorCodegenHelper<'b, 'tcx>,\n+        mut bx: Bx,\n+    ) {\n+        if let Some(funclet) = helper.funclet(self) {\n+            bx.cleanup_ret(funclet, None);\n+        } else {\n+            let slot = self.get_personality_slot(&mut bx);\n+            let lp0 = slot.project_field(&mut bx, 0);\n+            let lp0 = bx.load_operand(lp0).immediate();\n+            let lp1 = slot.project_field(&mut bx, 1);\n+            let lp1 = bx.load_operand(lp1).immediate();\n+            slot.storage_dead(&mut bx);\n+\n+            if !bx.sess().target.target.options.custom_unwind_resume {\n+                let mut lp = bx.const_undef(self.landing_pad_type());\n+                lp = bx.insert_value(lp, lp0, 0);\n+                lp = bx.insert_value(lp, lp1, 1);\n+                bx.resume(lp);\n             } else {\n-                let llret = bx.call(fn_ptr, &llargs, funclet(this));\n-                bx.apply_attrs_callsite(&fn_ty, llret);\n-                if this.mir[bb].is_cleanup {\n-                    // Cleanup is always the cold path. Don't inline\n-                    // drop glue. Also, when there is a deeply-nested\n-                    // struct, there are \"symmetry\" issues that cause\n-                    // exponential inlining - see issue #41696.\n-                    bx.do_not_inline(llret);\n-                }\n-\n-                if let Some((ret_dest, target)) = destination {\n-                    this.store_return(bx, ret_dest, &fn_ty.ret, llret);\n-                    funclet_br(this, bx, target);\n-                } else {\n-                    bx.unreachable();\n-                }\n+                bx.call(bx.eh_unwind_resume(), &[lp0],\n+                        helper.funclet(self));\n+                bx.unreachable();\n             }\n-        };\n+        }\n+    }\n \n-        self.set_debug_loc(&mut bx, terminator.source_info);\n-        match terminator.kind {\n-            mir::TerminatorKind::Resume => {\n-                if let Some(funclet) = funclet(self) {\n-                    bx.cleanup_ret(funclet, None);\n+    fn codegen_switchint_terminator<'b>(\n+        &mut self,\n+        helper: TerminatorCodegenHelper<'b, 'tcx>,\n+        mut bx: Bx,\n+        discr: &mir::Operand<'tcx>,\n+        switch_ty: Ty<'tcx>,\n+        values: &Cow<'tcx, [u128]>,\n+        targets: &Vec<mir::BasicBlock>,\n+    ) {\n+        let discr = self.codegen_operand(&mut bx, &discr);\n+        if targets.len() == 2 {\n+            // If there are two targets, emit br instead of switch\n+            let lltrue = helper.llblock(self, targets[0]);\n+            let llfalse = helper.llblock(self, targets[1]);\n+            if switch_ty == bx.tcx().types.bool {\n+                // Don't generate trivial icmps when switching on bool\n+                if let [0] = values[..] {\n+                    bx.cond_br(discr.immediate(), llfalse, lltrue);\n                 } else {\n-                    let slot = self.get_personality_slot(&mut bx);\n-                    let lp0 = slot.project_field(&mut bx, 0);\n-                    let lp0 = bx.load_operand(lp0).immediate();\n-                    let lp1 = slot.project_field(&mut bx, 1);\n-                    let lp1 = bx.load_operand(lp1).immediate();\n-                    slot.storage_dead(&mut bx);\n-\n-                    if !bx.sess().target.target.options.custom_unwind_resume {\n-                        let mut lp = bx.const_undef(self.landing_pad_type());\n-                        lp = bx.insert_value(lp, lp0, 0);\n-                        lp = bx.insert_value(lp, lp1, 1);\n-                        bx.resume(lp);\n-                    } else {\n-                        bx.call(bx.eh_unwind_resume(), &[lp0], funclet(self));\n-                        bx.unreachable();\n-                    }\n+                    assert_eq!(&values[..], &[1]);\n+                    bx.cond_br(discr.immediate(), lltrue, llfalse);\n                 }\n+            } else {\n+                let switch_llty = bx.immediate_backend_type(\n+                    bx.layout_of(switch_ty)\n+                );\n+                let llval = bx.const_uint_big(switch_llty, values[0]);\n+                let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n+                bx.cond_br(cmp, lltrue, llfalse);\n+            }\n+        } else {\n+            let (otherwise, targets) = targets.split_last().unwrap();\n+            let switch = bx.switch(discr.immediate(),\n+                                   helper.llblock(self, *otherwise),\n+                                   values.len());\n+            let switch_llty = bx.immediate_backend_type(\n+                bx.layout_of(switch_ty)\n+            );\n+            for (&value, target) in values.iter().zip(targets) {\n+                let llval = bx.const_uint_big(switch_llty, value);\n+                let llbb = helper.llblock(self, *target);\n+                bx.add_case(switch, llval, llbb)\n             }\n+        }\n+    }\n \n-            mir::TerminatorKind::Abort => {\n-                bx.abort();\n-                bx.unreachable();\n+    fn codegen_return_terminator<'b>(\n+        &mut self,\n+        mut bx: Bx,\n+    ) {\n+        if self.fn_ty.c_variadic {\n+            if let Some(va_list) = self.va_list_ref {\n+                bx.va_end(va_list.llval);\n+            }\n+        }\n+        let llval = match self.fn_ty.ret.mode {\n+            PassMode::Ignore(IgnoreMode::Zst) | PassMode::Indirect(..) => {\n+                bx.ret_void();\n+                return;\n             }\n \n-            mir::TerminatorKind::Goto { target } => {\n-                funclet_br(self, &mut bx, target);\n+            PassMode::Ignore(IgnoreMode::CVarArgs) => {\n+                bug!(\"C-variadic arguments should never be the return type\");\n             }\n \n-            mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n-                let discr = self.codegen_operand(&mut bx, discr);\n-                if targets.len() == 2 {\n-                    // If there are two targets, emit br instead of switch\n-                    let lltrue = llblock(self, targets[0]);\n-                    let llfalse = llblock(self, targets[1]);\n-                    if switch_ty == bx.tcx().types.bool {\n-                        // Don't generate trivial icmps when switching on bool\n-                        if let [0] = values[..] {\n-                            bx.cond_br(discr.immediate(), llfalse, lltrue);\n-                        } else {\n-                            assert_eq!(&values[..], &[1]);\n-                            bx.cond_br(discr.immediate(), lltrue, llfalse);\n-                        }\n-                    } else {\n-                        let switch_llty = bx.immediate_backend_type(\n-                            bx.layout_of(switch_ty)\n-                        );\n-                        let llval = bx.const_uint_big(switch_llty, values[0]);\n-                        let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n-                        bx.cond_br(cmp, lltrue, llfalse);\n-                    }\n+            PassMode::Direct(_) | PassMode::Pair(..) => {\n+                let op =\n+                    self.codegen_consume(&mut bx, &mir::Place::Local(mir::RETURN_PLACE));\n+                if let Ref(llval, _, align) = op.val {\n+                    bx.load(llval, align)\n                 } else {\n-                    let (otherwise, targets) = targets.split_last().unwrap();\n-                    let switch = bx.switch(discr.immediate(),\n-                                           llblock(self, *otherwise),\n-                                           values.len());\n-                    let switch_llty = bx.immediate_backend_type(\n-                        bx.layout_of(switch_ty)\n-                    );\n-                    for (&value, target) in values.iter().zip(targets) {\n-                        let llval = bx.const_uint_big(switch_llty, value);\n-                        let llbb = llblock(self, *target);\n-                        bx.add_case(switch, llval, llbb)\n-                    }\n+                    op.immediate_or_packed_pair(&mut bx)\n                 }\n             }\n \n-            mir::TerminatorKind::Return => {\n-                let llval = match self.fn_ty.ret.mode {\n-                    PassMode::Ignore | PassMode::Indirect(..) => {\n-                        bx.ret_void();\n-                        return;\n-                    }\n-\n-                    PassMode::Direct(_) | PassMode::Pair(..) => {\n-                        let op =\n-                            self.codegen_consume(&mut bx, &mir::Place::Local(mir::RETURN_PLACE));\n-                        if let Ref(llval, _, align) = op.val {\n-                            bx.load(llval, align)\n-                        } else {\n-                            op.immediate_or_packed_pair(&mut bx)\n+            PassMode::Cast(cast_ty) => {\n+                let op = match self.locals[mir::RETURN_PLACE] {\n+                    LocalRef::Operand(Some(op)) => op,\n+                    LocalRef::Operand(None) => bug!(\"use of return before def\"),\n+                    LocalRef::Place(cg_place) => {\n+                        OperandRef {\n+                            val: Ref(cg_place.llval, None, cg_place.align),\n+                            layout: cg_place.layout\n                         }\n                     }\n-\n-                    PassMode::Cast(cast_ty) => {\n-                        let op = match self.locals[mir::RETURN_PLACE] {\n-                            LocalRef::Operand(Some(op)) => op,\n-                            LocalRef::Operand(None) => bug!(\"use of return before def\"),\n-                            LocalRef::Place(cg_place) => {\n-                                OperandRef {\n-                                    val: Ref(cg_place.llval, None, cg_place.align),\n-                                    layout: cg_place.layout\n-                                }\n-                            }\n-                            LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n-                        };\n-                        let llslot = match op.val {\n-                            Immediate(_) | Pair(..) => {\n-                                let scratch =\n-                                    PlaceRef::alloca(&mut bx, self.fn_ty.ret.layout, \"ret\");\n-                                op.val.store(&mut bx, scratch);\n-                                scratch.llval\n-                            }\n-                            Ref(llval, _, align) => {\n-                                assert_eq!(align, op.layout.align.abi,\n-                                           \"return place is unaligned!\");\n-                                llval\n-                            }\n-                        };\n-                        let addr = bx.pointercast(llslot, bx.type_ptr_to(\n-                            bx.cast_backend_type(&cast_ty)\n-                        ));\n-                        bx.load(addr, self.fn_ty.ret.layout.align.abi)\n+                    LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n+                };\n+                let llslot = match op.val {\n+                    Immediate(_) | Pair(..) => {\n+                        let scratch =\n+                            PlaceRef::alloca(&mut bx, self.fn_ty.ret.layout, \"ret\");\n+                        op.val.store(&mut bx, scratch);\n+                        scratch.llval\n+                    }\n+                    Ref(llval, _, align) => {\n+                        assert_eq!(align, op.layout.align.abi,\n+                                   \"return place is unaligned!\");\n+                        llval\n                     }\n                 };\n-                bx.ret(llval);\n+                let addr = bx.pointercast(llslot, bx.type_ptr_to(\n+                    bx.cast_backend_type(&cast_ty)\n+                ));\n+                bx.load(addr, self.fn_ty.ret.layout.align.abi)\n             }\n+        };\n+        bx.ret(llval);\n+    }\n \n-            mir::TerminatorKind::Unreachable => {\n-                bx.unreachable();\n+\n+    fn codegen_drop_terminator<'b>(\n+        &mut self,\n+        helper: TerminatorCodegenHelper<'b, 'tcx>,\n+        mut bx: Bx,\n+        location: &mir::Place<'tcx>,\n+        target: mir::BasicBlock,\n+        unwind: Option<mir::BasicBlock>,\n+    ) {\n+        let ty = location.ty(self.mir, bx.tcx()).to_ty(bx.tcx());\n+        let ty = self.monomorphize(&ty);\n+        let drop_fn = monomorphize::resolve_drop_in_place(bx.tcx(), ty);\n+\n+        if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n+            // we don't actually need to drop anything.\n+            helper.funclet_br(self, &mut bx, target);\n+            return\n+        }\n+\n+        let place = self.codegen_place(&mut bx, location);\n+        let (args1, args2);\n+        let mut args = if let Some(llextra) = place.llextra {\n+            args2 = [place.llval, llextra];\n+            &args2[..]\n+        } else {\n+            args1 = [place.llval];\n+            &args1[..]\n+        };\n+        let (drop_fn, fn_ty) = match ty.sty {\n+            ty::Dynamic(..) => {\n+                let sig = drop_fn.fn_sig(self.cx.tcx());\n+                let sig = self.cx.tcx().normalize_erasing_late_bound_regions(\n+                    ty::ParamEnv::reveal_all(),\n+                    &sig,\n+                );\n+                let fn_ty = bx.new_vtable(sig, &[]);\n+                let vtable = args[1];\n+                args = &args[..1];\n+                (meth::DESTRUCTOR.get_fn(&mut bx, vtable, &fn_ty), fn_ty)\n+            }\n+            _ => {\n+                (bx.get_fn(drop_fn),\n+                 bx.fn_type_of_instance(&drop_fn))\n             }\n+        };\n+        helper.do_call(self, &mut bx, fn_ty, drop_fn, args,\n+                       Some((ReturnDest::Nothing, target)),\n+                       unwind);\n+    }\n \n-            mir::TerminatorKind::Drop { ref location, target, unwind } => {\n-                let ty = location.ty(self.mir, bx.tcx()).to_ty(bx.tcx());\n-                let ty = self.monomorphize(&ty);\n-                let drop_fn = monomorphize::resolve_drop_in_place(bx.tcx(), ty);\n-\n-                if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n-                    // we don't actually need to drop anything.\n-                    funclet_br(self, &mut bx, target);\n-                    return\n-                }\n+    fn codegen_assert_terminator<'b>(\n+        &mut self,\n+        helper: TerminatorCodegenHelper<'b, 'tcx>,\n+        mut bx: Bx,\n+        terminator: &mir::Terminator<'tcx>,\n+        cond: &mir::Operand<'tcx>,\n+        expected: bool,\n+        msg: &mir::AssertMessage<'tcx>,\n+        target: mir::BasicBlock,\n+        cleanup: Option<mir::BasicBlock>,\n+    ) {\n+        let span = terminator.source_info.span;\n+        let cond = self.codegen_operand(&mut bx, cond).immediate();\n+        let mut const_cond = bx.const_to_opt_u128(cond, false).map(|c| c == 1);\n+\n+        // This case can currently arise only from functions marked\n+        // with #[rustc_inherit_overflow_checks] and inlined from\n+        // another crate (mostly core::num generic/#[inline] fns),\n+        // while the current crate doesn't use overflow checks.\n+        // NOTE: Unlike binops, negation doesn't have its own\n+        // checked operation, just a comparison with the minimum\n+        // value, so we have to check for the assert message.\n+        if !bx.check_overflow() {\n+            if let mir::interpret::EvalErrorKind::OverflowNeg = *msg {\n+                const_cond = Some(expected);\n+            }\n+        }\n \n-                let place = self.codegen_place(&mut bx, location);\n-                let (args1, args2);\n-                let mut args = if let Some(llextra) = place.llextra {\n-                    args2 = [place.llval, llextra];\n-                    &args2[..]\n-                } else {\n-                    args1 = [place.llval];\n-                    &args1[..]\n-                };\n-                let (drop_fn, fn_ty) = match ty.sty {\n-                    ty::Dynamic(..) => {\n-                        let sig = drop_fn.fn_sig(tcx);\n-                        let sig = tcx.normalize_erasing_late_bound_regions(\n-                            ty::ParamEnv::reveal_all(),\n-                            &sig,\n-                        );\n-                        let fn_ty = bx.new_vtable(sig, &[]);\n-                        let vtable = args[1];\n-                        args = &args[..1];\n-                        (meth::DESTRUCTOR.get_fn(&mut bx, vtable, &fn_ty), fn_ty)\n-                    }\n-                    _ => {\n-                        (bx.get_fn(drop_fn),\n-                         bx.fn_type_of_instance(&drop_fn))\n-                    }\n-                };\n-                do_call(self, &mut bx, fn_ty, drop_fn, args,\n-                        Some((ReturnDest::Nothing, target)),\n-                        unwind);\n+        // Don't codegen the panic block if success if known.\n+        if const_cond == Some(expected) {\n+            helper.funclet_br(self, &mut bx, target);\n+            return;\n+        }\n+\n+        // Pass the condition through llvm.expect for branch hinting.\n+        let cond = bx.expect(cond, expected);\n+\n+        // Create the failure block and the conditional branch to it.\n+        let lltarget = helper.llblock(self, target);\n+        let panic_block = self.new_block(\"panic\");\n+        if expected {\n+            bx.cond_br(cond, lltarget, panic_block.llbb());\n+        } else {\n+            bx.cond_br(cond, panic_block.llbb(), lltarget);\n+        }\n+\n+        // After this point, bx is the block for the call to panic.\n+        bx = panic_block;\n+        self.set_debug_loc(&mut bx, terminator.source_info);\n+\n+        // Get the location information.\n+        let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n+        let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n+        let filename = bx.const_str_slice(filename);\n+        let line = bx.const_u32(loc.line as u32);\n+        let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n+        let align = self.cx.tcx().data_layout.aggregate_align.abi\n+            .max(self.cx.tcx().data_layout.i32_align.abi)\n+            .max(self.cx.tcx().data_layout.pointer_align.abi);\n+\n+        // Put together the arguments to the panic entry point.\n+        let (lang_item, args) = match *msg {\n+            EvalErrorKind::BoundsCheck { ref len, ref index } => {\n+                let len = self.codegen_operand(&mut bx, len).immediate();\n+                let index = self.codegen_operand(&mut bx, index).immediate();\n+\n+                let file_line_col = bx.const_struct(&[filename, line, col], false);\n+                let file_line_col = bx.static_addr_of(\n+                    file_line_col,\n+                    align,\n+                    Some(\"panic_bounds_check_loc\")\n+                );\n+                (lang_items::PanicBoundsCheckFnLangItem,\n+                 vec![file_line_col, index, len])\n+            }\n+            _ => {\n+                let str = msg.description();\n+                let msg_str = Symbol::intern(str).as_str();\n+                let msg_str = bx.const_str_slice(msg_str);\n+                let msg_file_line_col = bx.const_struct(\n+                    &[msg_str, filename, line, col],\n+                    false\n+                );\n+                let msg_file_line_col = bx.static_addr_of(\n+                    msg_file_line_col,\n+                    align,\n+                    Some(\"panic_loc\")\n+                );\n+                (lang_items::PanicFnLangItem,\n+                 vec![msg_file_line_col])\n             }\n+        };\n \n-            mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                let cond = self.codegen_operand(&mut bx, cond).immediate();\n-                let mut const_cond = bx.const_to_opt_u128(cond, false).map(|c| c == 1);\n-\n-                // This case can currently arise only from functions marked\n-                // with #[rustc_inherit_overflow_checks] and inlined from\n-                // another crate (mostly core::num generic/#[inline] fns),\n-                // while the current crate doesn't use overflow checks.\n-                // NOTE: Unlike binops, negation doesn't have its own\n-                // checked operation, just a comparison with the minimum\n-                // value, so we have to check for the assert message.\n-                if !bx.check_overflow() {\n-                    if let mir::interpret::EvalErrorKind::OverflowNeg = *msg {\n-                        const_cond = Some(expected);\n-                    }\n-                }\n+        // Obtain the panic entry point.\n+        let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n+        let instance = ty::Instance::mono(bx.tcx(), def_id);\n+        let fn_ty = bx.fn_type_of_instance(&instance);\n+        let llfn = bx.get_fn(instance);\n \n-                // Don't codegen the panic block if success if known.\n-                if const_cond == Some(expected) {\n-                    funclet_br(self, &mut bx, target);\n-                    return;\n-                }\n+        // Codegen the actual panic invoke/call.\n+        helper.do_call(self, &mut bx, fn_ty, llfn, &args, None, cleanup);\n+    }\n \n-                // Pass the condition through llvm.expect for branch hinting.\n-                let cond = bx.expect(cond, expected);\n+    fn codegen_call_terminator<'b>(\n+        &mut self,\n+        helper: TerminatorCodegenHelper<'b, 'tcx>,\n+        mut bx: Bx,\n+        terminator: &mir::Terminator<'tcx>,\n+        func: &mir::Operand<'tcx>,\n+        args: &Vec<mir::Operand<'tcx>>,\n+        destination: &Option<(mir::Place<'tcx>, mir::BasicBlock)>,\n+        cleanup: Option<mir::BasicBlock>,\n+    ) {\n+        let span = terminator.source_info.span;\n+        // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n+        let callee = self.codegen_operand(&mut bx, func);\n+\n+        let (instance, mut llfn) = match callee.layout.ty.sty {\n+            ty::FnDef(def_id, substs) => {\n+                (Some(ty::Instance::resolve(bx.tcx(),\n+                                            ty::ParamEnv::reveal_all(),\n+                                            def_id,\n+                                            substs).unwrap()),\n+                 None)\n+            }\n+            ty::FnPtr(_) => {\n+                (None, Some(callee.immediate()))\n+            }\n+            _ => bug!(\"{} is not callable\", callee.layout.ty),\n+        };\n+        let def = instance.map(|i| i.def);\n+        let sig = callee.layout.ty.fn_sig(bx.tcx());\n+        let sig = bx.tcx().normalize_erasing_late_bound_regions(\n+            ty::ParamEnv::reveal_all(),\n+            &sig,\n+        );\n+        let abi = sig.abi;\n+\n+        // Handle intrinsics old codegen wants Expr's for, ourselves.\n+        let intrinsic = match def {\n+            Some(ty::InstanceDef::Intrinsic(def_id)) =>\n+                Some(bx.tcx().item_name(def_id).as_str()),\n+            _ => None\n+        };\n+        let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n \n-                // Create the failure block and the conditional branch to it.\n-                let lltarget = llblock(self, target);\n-                let panic_block = self.new_block(\"panic\");\n-                if expected {\n-                    bx.cond_br(cond, lltarget, panic_block.llbb());\n-                } else {\n-                    bx.cond_br(cond, panic_block.llbb(), lltarget);\n-                }\n+        if intrinsic == Some(\"transmute\") {\n+            if let Some(destination_ref) = destination.as_ref() {\n+                let &(ref dest, target) = destination_ref;\n+                self.codegen_transmute(&mut bx, &args[0], dest);\n+                helper.funclet_br(self, &mut bx, target);\n+            } else {\n+                // If we are trying to transmute to an uninhabited type,\n+                // it is likely there is no allotted destination. In fact,\n+                // transmuting to an uninhabited type is UB, which means\n+                // we can do what we like. Here, we declare that transmuting\n+                // into an uninhabited type is impossible, so anything following\n+                // it must be unreachable.\n+                assert_eq!(bx.layout_of(sig.output()).abi, layout::Abi::Uninhabited);\n+                bx.unreachable();\n+            }\n+            return;\n+        }\n \n-                // After this point, bx is the block for the call to panic.\n-                bx = panic_block;\n-                self.set_debug_loc(&mut bx, terminator.source_info);\n+        // The \"spoofed\" `VaList` added to a C-variadic functions signature\n+        // should not be included in the `extra_args` calculation.\n+        let extra_args_start_idx = sig.inputs().len() - if sig.c_variadic { 1 } else { 0 };\n+        let extra_args = &args[extra_args_start_idx..];\n+        let extra_args = extra_args.iter().map(|op_arg| {\n+            let op_ty = op_arg.ty(self.mir, bx.tcx());\n+            self.monomorphize(&op_ty)\n+        }).collect::<Vec<_>>();\n+\n+        let fn_ty = match def {\n+            Some(ty::InstanceDef::Virtual(..)) => {\n+                bx.new_vtable(sig, &extra_args)\n+            }\n+            Some(ty::InstanceDef::DropGlue(_, None)) => {\n+                // Empty drop glue; a no-op.\n+                let &(_, target) = destination.as_ref().unwrap();\n+                helper.funclet_br(self, &mut bx, target);\n+                return;\n+            }\n+            _ => bx.new_fn_type(sig, &extra_args)\n+        };\n \n-                // Get the location information.\n+        // Emit a panic or a no-op for `panic_if_uninhabited`.\n+        if intrinsic == Some(\"panic_if_uninhabited\") {\n+            let ty = instance.unwrap().substs.type_at(0);\n+            let layout = bx.layout_of(ty);\n+            if layout.abi.is_uninhabited() {\n                 let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n                 let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n                 let filename = bx.const_str_slice(filename);\n                 let line = bx.const_u32(loc.line as u32);\n                 let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n-                let align = tcx.data_layout.aggregate_align.abi\n-                    .max(tcx.data_layout.i32_align.abi)\n-                    .max(tcx.data_layout.pointer_align.abi);\n-\n-                // Put together the arguments to the panic entry point.\n-                let (lang_item, args) = match *msg {\n-                    EvalErrorKind::BoundsCheck { ref len, ref index } => {\n-                        let len = self.codegen_operand(&mut bx, len).immediate();\n-                        let index = self.codegen_operand(&mut bx, index).immediate();\n-\n-                        let file_line_col = bx.const_struct(&[filename, line, col], false);\n-                        let file_line_col = bx.static_addr_of(\n-                            file_line_col,\n-                            align,\n-                            Some(\"panic_bounds_check_loc\")\n-                        );\n-                        (lang_items::PanicBoundsCheckFnLangItem,\n-                         vec![file_line_col, index, len])\n-                    }\n-                    _ => {\n-                        let str = msg.description();\n-                        let msg_str = Symbol::intern(str).as_str();\n-                        let msg_str = bx.const_str_slice(msg_str);\n-                        let msg_file_line_col = bx.const_struct(\n-                            &[msg_str, filename, line, col],\n-                            false\n-                        );\n-                        let msg_file_line_col = bx.static_addr_of(\n-                            msg_file_line_col,\n-                            align,\n-                            Some(\"panic_loc\")\n-                        );\n-                        (lang_items::PanicFnLangItem,\n-                         vec![msg_file_line_col])\n-                    }\n-                };\n+                let align = self.cx.tcx().data_layout.aggregate_align.abi\n+                    .max(self.cx.tcx().data_layout.i32_align.abi)\n+                    .max(self.cx.tcx().data_layout.pointer_align.abi);\n+\n+                let str = format!(\n+                    \"Attempted to instantiate uninhabited type {}\",\n+                    ty\n+                );\n+                let msg_str = Symbol::intern(&str).as_str();\n+                let msg_str = bx.const_str_slice(msg_str);\n+                let msg_file_line_col = bx.const_struct(\n+                    &[msg_str, filename, line, col],\n+                    false,\n+                );\n+                let msg_file_line_col = bx.static_addr_of(\n+                    msg_file_line_col,\n+                    align,\n+                    Some(\"panic_loc\"),\n+                );\n \n                 // Obtain the panic entry point.\n-                let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n+                let def_id =\n+                    common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n                 let fn_ty = bx.fn_type_of_instance(&instance);\n                 let llfn = bx.get_fn(instance);\n \n                 // Codegen the actual panic invoke/call.\n-                do_call(self, &mut bx, fn_ty, llfn, &args, None, cleanup);\n+                helper.do_call(\n+                    self,\n+                    &mut bx,\n+                    fn_ty,\n+                    llfn,\n+                    &[msg_file_line_col],\n+                    destination.as_ref().map(|(_, bb)| (ReturnDest::Nothing, *bb)),\n+                    cleanup,\n+                );\n+            } else {\n+                // a NOP\n+                helper.funclet_br(self, &mut bx, destination.as_ref().unwrap().1)\n             }\n+            return;\n+        }\n \n-            mir::TerminatorKind::DropAndReplace { .. } => {\n-                bug!(\"undesugared DropAndReplace in codegen: {:?}\", terminator);\n-            }\n+        // The arguments we'll be passing. Plus one to account for outptr, if used.\n+        let arg_count = fn_ty.args.len() + fn_ty.ret.is_indirect() as usize;\n+        let mut llargs = Vec::with_capacity(arg_count);\n \n-            mir::TerminatorKind::Call {\n-                ref func,\n-                ref args,\n-                ref destination,\n-                cleanup,\n-                from_hir_call: _\n-            } => {\n-                // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n-                let callee = self.codegen_operand(&mut bx, func);\n-\n-                let (instance, mut llfn) = match callee.layout.ty.sty {\n-                    ty::FnDef(def_id, substs) => {\n-                        (Some(ty::Instance::resolve(bx.tcx(),\n-                                                    ty::ParamEnv::reveal_all(),\n-                                                    def_id,\n-                                                    substs).unwrap()),\n-                         None)\n-                    }\n-                    ty::FnPtr(_) => {\n-                        (None, Some(callee.immediate()))\n-                    }\n-                    _ => bug!(\"{} is not callable\", callee.layout.ty)\n-                };\n-                let def = instance.map(|i| i.def);\n-                let sig = callee.layout.ty.fn_sig(bx.tcx());\n-                let sig = bx.tcx().normalize_erasing_late_bound_regions(\n-                    ty::ParamEnv::reveal_all(),\n-                    &sig,\n-                );\n-                let abi = sig.abi;\n+        // Prepare the return value destination\n+        let ret_dest = if let Some((ref dest, _)) = *destination {\n+            let is_intrinsic = intrinsic.is_some();\n+            self.make_return_dest(&mut bx, dest, &fn_ty.ret, &mut llargs,\n+                                  is_intrinsic)\n+        } else {\n+            ReturnDest::Nothing\n+        };\n \n-                // Handle intrinsics old codegen wants Expr's for, ourselves.\n-                let intrinsic = match def {\n-                    Some(ty::InstanceDef::Intrinsic(def_id))\n-                        => Some(bx.tcx().item_name(def_id).as_str()),\n-                    _ => None\n-                };\n-                let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n+        if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n+            let dest = match ret_dest {\n+                _ if fn_ty.ret.is_indirect() => llargs[0],\n+                ReturnDest::Nothing =>\n+                    bx.const_undef(bx.type_ptr_to(bx.memory_ty(&fn_ty.ret))),\n+                ReturnDest::IndirectOperand(dst, _) | ReturnDest::Store(dst) =>\n+                    dst.llval,\n+                ReturnDest::DirectOperand(_) =>\n+                    bug!(\"Cannot use direct operand with an intrinsic call\"),\n+            };\n \n-                if intrinsic == Some(\"transmute\") {\n-                    if let Some(destination_ref) = destination.as_ref() {\n-                        let &(ref dest, target) = destination_ref;\n-                        self.codegen_transmute(&mut bx, &args[0], dest);\n-                        funclet_br(self, &mut bx, target);\n-                    } else {\n-                        // If we are trying to transmute to an uninhabited type,\n-                        // it is likely there is no allotted destination. In fact,\n-                        // transmuting to an uninhabited type is UB, which means\n-                        // we can do what we like. Here, we declare that transmuting\n-                        // into an uninhabited type is impossible, so anything following\n-                        // it must be unreachable.\n-                        assert_eq!(bx.layout_of(sig.output()).abi, layout::Abi::Uninhabited);\n-                        bx.unreachable();\n+            let args: Vec<_> = args.iter().enumerate().map(|(i, arg)| {\n+                // The indices passed to simd_shuffle* in the\n+                // third argument must be constant. This is\n+                // checked by const-qualification, which also\n+                // promotes any complex rvalues to constants.\n+                if i == 2 && intrinsic.unwrap().starts_with(\"simd_shuffle\") {\n+                    match *arg {\n+                        // The shuffle array argument is usually not an explicit constant,\n+                        // but specified directly in the code. This means it gets promoted\n+                        // and we can then extract the value by evaluating the promoted.\n+                        mir::Operand::Copy(mir::Place::Promoted(box(index, ty))) |\n+                        mir::Operand::Move(mir::Place::Promoted(box(index, ty))) => {\n+                            let param_env = ty::ParamEnv::reveal_all();\n+                            let cid = mir::interpret::GlobalId {\n+                                instance: self.instance,\n+                                promoted: Some(index),\n+                            };\n+                            let c = bx.tcx().const_eval(param_env.and(cid));\n+                            let (llval, ty) = self.simd_shuffle_indices(\n+                                &bx,\n+                                terminator.source_info.span,\n+                                ty,\n+                                c,\n+                            );\n+                            return OperandRef {\n+                                val: Immediate(llval),\n+                                layout: bx.layout_of(ty),\n+                            };\n+\n+                        }\n+                        mir::Operand::Copy(_) |\n+                        mir::Operand::Move(_) => {\n+                            span_bug!(span, \"shuffle indices must be constant\");\n+                        }\n+                        mir::Operand::Constant(ref constant) => {\n+                            let c = self.eval_mir_constant(&bx, constant);\n+                            let (llval, ty) = self.simd_shuffle_indices(\n+                                &bx,\n+                                constant.span,\n+                                constant.ty,\n+                                c,\n+                            );\n+                            return OperandRef {\n+                                val: Immediate(llval),\n+                                layout: bx.layout_of(ty)\n+                            };\n+                        }\n                     }\n-                    return;\n                 }\n \n-                let extra_args = &args[sig.inputs().len()..];\n-                let extra_args = extra_args.iter().map(|op_arg| {\n-                    let op_ty = op_arg.ty(self.mir, bx.tcx());\n-                    self.monomorphize(&op_ty)\n-                }).collect::<Vec<_>>();\n+                self.codegen_operand(&mut bx, arg)\n+            }).collect();\n \n-                let fn_ty = match def {\n-                    Some(ty::InstanceDef::Virtual(..)) => {\n-                        bx.new_vtable(sig, &extra_args)\n-                    }\n-                    Some(ty::InstanceDef::DropGlue(_, None)) => {\n-                        // empty drop glue - a nop.\n-                        let &(_, target) = destination.as_ref().unwrap();\n-                        funclet_br(self, &mut bx, target);\n-                        return;\n-                    }\n-                    _ => bx.new_fn_type(sig, &extra_args)\n+\n+            let callee_ty = instance.as_ref().unwrap().ty(bx.tcx());\n+            bx.codegen_intrinsic_call(callee_ty, &fn_ty, &args, dest,\n+                                      terminator.source_info.span);\n+\n+            if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n+                self.store_return(&mut bx, ret_dest, &fn_ty.ret, dst.llval);\n+            }\n+\n+            if let Some((_, target)) = *destination {\n+                helper.funclet_br(self, &mut bx, target);\n+            } else {\n+                bx.unreachable();\n+            }\n+\n+            return;\n+        }\n+\n+        // Split the rust-call tupled arguments off.\n+        let (first_args, untuple) = if abi == Abi::RustCall && !args.is_empty() {\n+            let (tup, args) = args.split_last().unwrap();\n+            (args, Some(tup))\n+        } else {\n+            (&args[..], None)\n+        };\n+\n+        // Useful determining if the current argument is the \"spoofed\" `VaList`\n+        let last_arg_idx = if sig.inputs().is_empty() {\n+            None\n+        } else {\n+            Some(sig.inputs().len() - 1)\n+        };\n+        'make_args: for (i, arg) in first_args.iter().enumerate() {\n+            // If this is a C-variadic function the function signature contains\n+            // an \"spoofed\" `VaList`. This argument is ignored, but we need to\n+            // populate it with a dummy operand so that the users real arguments\n+            // are not overwritten.\n+            let i = if sig.c_variadic && last_arg_idx.map(|x| x == i).unwrap_or(false) {\n+                let layout = match self.cx.tcx().lang_items().va_list() {\n+                    Some(did) => bx.cx().layout_of(bx.tcx().type_of(did)),\n+                    None => bug!(\"`va_list` language item required for C-variadics\"),\n                 };\n+                let op = OperandRef {\n+                    val: OperandValue::Immediate(\n+                        bx.cx().const_undef(bx.cx().immediate_backend_type(layout)\n+                    )),\n+                    layout: layout,\n+                };\n+                self.codegen_argument(&mut bx, op, &mut llargs, &fn_ty.args[i]);\n+                if i + 1 < fn_ty.args.len() {\n+                    i + 1\n+                } else {\n+                    break 'make_args\n+                }\n+            } else {\n+                i\n+            };\n+            let mut op = self.codegen_operand(&mut bx, arg);\n+\n+            if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n+                if let Pair(..) = op.val {\n+                    // In the case of Rc<Self>, we need to explicitly pass a\n+                    // *mut RcBox<Self> with a Scalar (not ScalarPair) ABI. This is a hack\n+                    // that is understood elsewhere in the compiler as a method on\n+                    // `dyn Trait`.\n+                    // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n+                    // we get a value of a built-in pointer type\n+                    'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n+                                    && !op.layout.ty.is_region_ptr()\n+                    {\n+                        'iter_fields: for i in 0..op.layout.fields.count() {\n+                            let field = op.extract_field(&mut bx, i);\n+                            if !field.layout.is_zst() {\n+                                // we found the one non-zero-sized field that is allowed\n+                                // now find *its* non-zero-sized field, or stop if it's a\n+                                // pointer\n+                                op = field;\n+                                continue 'descend_newtypes\n+                            }\n+                        }\n \n-                // emit a panic or a NOP for `panic_if_uninhabited`\n-                if intrinsic == Some(\"panic_if_uninhabited\") {\n-                    let ty = instance.unwrap().substs.type_at(0);\n-                    let layout = bx.layout_of(ty);\n-                    if layout.abi.is_uninhabited() {\n-                        let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n-                        let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                        let filename = bx.const_str_slice(filename);\n-                        let line = bx.const_u32(loc.line as u32);\n-                        let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n-                        let align = tcx.data_layout.aggregate_align.abi\n-                            .max(tcx.data_layout.i32_align.abi)\n-                            .max(tcx.data_layout.pointer_align.abi);\n-\n-                        let str = format!(\n-                            \"Attempted to instantiate uninhabited type {}\",\n-                            ty\n-                        );\n-                        let msg_str = Symbol::intern(&str).as_str();\n-                        let msg_str = bx.const_str_slice(msg_str);\n-                        let msg_file_line_col = bx.const_struct(\n-                            &[msg_str, filename, line, col],\n-                            false,\n-                        );\n-                        let msg_file_line_col = bx.static_addr_of(\n-                            msg_file_line_col,\n-                            align,\n-                            Some(\"panic_loc\"),\n-                        );\n-\n-                        // Obtain the panic entry point.\n-                        let def_id =\n-                            common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n-                        let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                        let fn_ty = bx.fn_type_of_instance(&instance);\n-                        let llfn = bx.get_fn(instance);\n-\n-                        // Codegen the actual panic invoke/call.\n-                        do_call(\n-                            self,\n-                            &mut bx,\n-                            fn_ty,\n-                            llfn,\n-                            &[msg_file_line_col],\n-                            destination.as_ref().map(|(_, bb)| (ReturnDest::Nothing, *bb)),\n-                            cleanup,\n-                        );\n-                    } else {\n-                        // a NOP\n-                        funclet_br(self, &mut bx, destination.as_ref().unwrap().1);\n+                        span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n                     }\n-                    return;\n+\n+                    // now that we have `*dyn Trait` or `&dyn Trait`, split it up into its\n+                    // data pointer and vtable. Look up the method in the vtable, and pass\n+                    // the data pointer as the first argument\n+                    match op.val {\n+                        Pair(data_ptr, meta) => {\n+                            llfn = Some(meth::VirtualIndex::from_index(idx)\n+                                .get_fn(&mut bx, meta, &fn_ty));\n+                            llargs.push(data_ptr);\n+                            continue 'make_args\n+                        }\n+                        other => bug!(\"expected a Pair, got {:?}\", other),\n+                    }\n+                } else if let Ref(data_ptr, Some(meta), _) = op.val {\n+                    // by-value dynamic dispatch\n+                    llfn = Some(meth::VirtualIndex::from_index(idx)\n+                        .get_fn(&mut bx, meta, &fn_ty));\n+                    llargs.push(data_ptr);\n+                    continue;\n+                } else {\n+                    span_bug!(span, \"can't codegen a virtual call on {:?}\", op);\n                 }\n+            }\n \n-                // The arguments we'll be passing. Plus one to account for outptr, if used.\n-                let arg_count = fn_ty.args.len() + fn_ty.ret.is_indirect() as usize;\n-                let mut llargs = Vec::with_capacity(arg_count);\n+            // The callee needs to own the argument memory if we pass it\n+            // by-ref, so make a local copy of non-immediate constants.\n+            match (arg, op.val) {\n+                (&mir::Operand::Copy(_), Ref(_, None, _)) |\n+                (&mir::Operand::Constant(_), Ref(_, None, _)) => {\n+                    let tmp = PlaceRef::alloca(&mut bx, op.layout, \"const\");\n+                    op.val.store(&mut bx, tmp);\n+                    op.val = Ref(tmp.llval, None, tmp.align);\n+                }\n+                _ => {}\n+            }\n \n-                // Prepare the return value destination\n-                let ret_dest = if let Some((ref dest, _)) = *destination {\n-                    let is_intrinsic = intrinsic.is_some();\n-                    self.make_return_dest(&mut bx, dest, &fn_ty.ret, &mut llargs,\n-                                          is_intrinsic)\n-                } else {\n-                    ReturnDest::Nothing\n-                };\n+            self.codegen_argument(&mut bx, op, &mut llargs, &fn_ty.args[i]);\n+        }\n+        if let Some(tup) = untuple {\n+            self.codegen_arguments_untupled(&mut bx, tup, &mut llargs,\n+                &fn_ty.args[first_args.len()..])\n+        }\n \n-                if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n-                    let dest = match ret_dest {\n-                        _ if fn_ty.ret.is_indirect() => llargs[0],\n-                        ReturnDest::Nothing => {\n-                            bx.const_undef(bx.type_ptr_to(bx.memory_ty(&fn_ty.ret)))\n-                        }\n-                        ReturnDest::IndirectOperand(dst, _) |\n-                        ReturnDest::Store(dst) => dst.llval,\n-                        ReturnDest::DirectOperand(_) =>\n-                            bug!(\"Cannot use direct operand with an intrinsic call\")\n-                    };\n+        let fn_ptr = match (llfn, instance) {\n+            (Some(llfn), _) => llfn,\n+            (None, Some(instance)) => bx.get_fn(instance),\n+            _ => span_bug!(span, \"no llfn for call\"),\n+        };\n \n-                    let args: Vec<_> = args.iter().enumerate().map(|(i, arg)| {\n-                        // The indices passed to simd_shuffle* in the\n-                        // third argument must be constant. This is\n-                        // checked by const-qualification, which also\n-                        // promotes any complex rvalues to constants.\n-                        if i == 2 && intrinsic.unwrap().starts_with(\"simd_shuffle\") {\n-                            match *arg {\n-                                // The shuffle array argument is usually not an explicit constant,\n-                                // but specified directly in the code. This means it gets promoted\n-                                // and we can then extract the value by evaluating the promoted.\n-                                mir::Operand::Copy(mir::Place::Promoted(box(index, ty))) |\n-                                mir::Operand::Move(mir::Place::Promoted(box(index, ty))) => {\n-                                    let param_env = ty::ParamEnv::reveal_all();\n-                                    let cid = mir::interpret::GlobalId {\n-                                        instance: self.instance,\n-                                        promoted: Some(index),\n-                                    };\n-                                    let c = bx.tcx().const_eval(param_env.and(cid));\n-                                    let (llval, ty) = self.simd_shuffle_indices(\n-                                        &bx,\n-                                        terminator.source_info.span,\n-                                        ty,\n-                                        c,\n-                                    );\n-                                    return OperandRef {\n-                                        val: Immediate(llval),\n-                                        layout: bx.layout_of(ty),\n-                                    };\n-\n-                                },\n-                                mir::Operand::Copy(_) |\n-                                mir::Operand::Move(_) => {\n-                                    span_bug!(span, \"shuffle indices must be constant\");\n-                                }\n-                                mir::Operand::Constant(ref constant) => {\n-                                    let c = self.eval_mir_constant(&bx, constant);\n-                                    let (llval, ty) = self.simd_shuffle_indices(\n-                                        &bx,\n-                                        constant.span,\n-                                        constant.ty,\n-                                        c,\n-                                    );\n-                                    return OperandRef {\n-                                        val: Immediate(llval),\n-                                        layout: bx.layout_of(ty)\n-                                    };\n-                                }\n-                            }\n-                        }\n+        helper.do_call(self, &mut bx, fn_ty, fn_ptr, &llargs,\n+                       destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n+                       cleanup);\n+    }\n+}\n \n-                        self.codegen_operand(&mut bx, arg)\n-                    }).collect();\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn codegen_block(\n+        &mut self,\n+        bb: mir::BasicBlock,\n+    ) {\n+        let mut bx = self.build_block(bb);\n+        let data = &self.mir[bb];\n \n+        debug!(\"codegen_block({:?}={:?})\", bb, data);\n \n-                    let callee_ty = instance.as_ref().unwrap().ty(bx.tcx());\n-                    bx.codegen_intrinsic_call(callee_ty, &fn_ty, &args, dest,\n-                                               terminator.source_info.span);\n+        for statement in &data.statements {\n+            bx = self.codegen_statement(bx, statement);\n+        }\n \n-                    if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                        self.store_return(&mut bx, ret_dest, &fn_ty.ret, dst.llval);\n-                    }\n+        self.codegen_terminator(bx, bb, data.terminator());\n+    }\n \n-                    if let Some((_, target)) = *destination {\n-                        funclet_br(self, &mut bx, target);\n-                    } else {\n-                        bx.unreachable();\n-                    }\n+    fn codegen_terminator(\n+        &mut self,\n+        mut bx: Bx,\n+        bb: mir::BasicBlock,\n+        terminator: &mir::Terminator<'tcx>\n+    ) {\n+        debug!(\"codegen_terminator: {:?}\", terminator);\n \n-                    return;\n-                }\n+        // Create the cleanup bundle, if needed.\n+        let funclet_bb = self.cleanup_kinds[bb].funclet_bb(bb);\n+        let helper = TerminatorCodegenHelper {\n+            bb: &bb, terminator, funclet_bb\n+        };\n \n-                // Split the rust-call tupled arguments off.\n-                let (first_args, untuple) = if abi == Abi::RustCall && !args.is_empty() {\n-                    let (tup, args) = args.split_last().unwrap();\n-                    (args, Some(tup))\n-                } else {\n-                    (&args[..], None)\n-                };\n+        self.set_debug_loc(&mut bx, terminator.source_info);\n+        match terminator.kind {\n+            mir::TerminatorKind::Resume => {\n+                self.codegen_resume_terminator(helper, bx)\n+            }\n \n-                'make_args: for (i, arg) in first_args.iter().enumerate() {\n-                    let mut op = self.codegen_operand(&mut bx, arg);\n-\n-                    if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n-                        if let Pair(..) = op.val {\n-                            // In the case of Rc<Self>, we need to explicitly pass a\n-                            // *mut RcBox<Self> with a Scalar (not ScalarPair) ABI. This is a hack\n-                            // that is understood elsewhere in the compiler as a method on\n-                            // `dyn Trait`.\n-                            // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n-                            // we get a value of a built-in pointer type\n-                            'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n-                                            && !op.layout.ty.is_region_ptr()\n-                            {\n-                                'iter_fields: for i in 0..op.layout.fields.count() {\n-                                    let field = op.extract_field(&mut bx, i);\n-                                    if !field.layout.is_zst() {\n-                                        // we found the one non-zero-sized field that is allowed\n-                                        // now find *its* non-zero-sized field, or stop if it's a\n-                                        // pointer\n-                                        op = field;\n-                                        continue 'descend_newtypes\n-                                    }\n-                                }\n-\n-                                span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n-                            }\n+            mir::TerminatorKind::Abort => {\n+                bx.abort();\n+                bx.unreachable();\n+            }\n \n-                            // now that we have `*dyn Trait` or `&dyn Trait`, split it up into its\n-                            // data pointer and vtable. Look up the method in the vtable, and pass\n-                            // the data pointer as the first argument\n-                            match op.val {\n-                                Pair(data_ptr, meta) => {\n-                                    llfn = Some(meth::VirtualIndex::from_index(idx)\n-                                        .get_fn(&mut bx, meta, &fn_ty));\n-                                    llargs.push(data_ptr);\n-                                    continue 'make_args\n-                                }\n-                                other => bug!(\"expected a Pair, got {:?}\", other)\n-                            }\n-                        } else if let Ref(data_ptr, Some(meta), _) = op.val {\n-                            // by-value dynamic dispatch\n-                            llfn = Some(meth::VirtualIndex::from_index(idx)\n-                                .get_fn(&mut bx, meta, &fn_ty));\n-                            llargs.push(data_ptr);\n-                            continue;\n-                        } else {\n-                            span_bug!(span, \"can't codegen a virtual call on {:?}\", op);\n-                        }\n-                    }\n+            mir::TerminatorKind::Goto { target } => {\n+                helper.funclet_br(self, &mut bx, target);\n+            }\n \n-                    // The callee needs to own the argument memory if we pass it\n-                    // by-ref, so make a local copy of non-immediate constants.\n-                    match (arg, op.val) {\n-                        (&mir::Operand::Copy(_), Ref(_, None, _)) |\n-                        (&mir::Operand::Constant(_), Ref(_, None, _)) => {\n-                            let tmp = PlaceRef::alloca(&mut bx, op.layout, \"const\");\n-                            op.val.store(&mut bx, tmp);\n-                            op.val = Ref(tmp.llval, None, tmp.align);\n-                        }\n-                        _ => {}\n-                    }\n+            mir::TerminatorKind::SwitchInt {\n+                ref discr, switch_ty, ref values, ref targets\n+            } => {\n+                self.codegen_switchint_terminator(helper, bx, discr, switch_ty,\n+                                                  values, targets);\n+            }\n \n-                    self.codegen_argument(&mut bx, op, &mut llargs, &fn_ty.args[i]);\n-                }\n-                if let Some(tup) = untuple {\n-                    self.codegen_arguments_untupled(&mut bx, tup, &mut llargs,\n-                        &fn_ty.args[first_args.len()..])\n-                }\n+            mir::TerminatorKind::Return => {\n+                self.codegen_return_terminator(bx);\n+            }\n \n-                let fn_ptr = match (llfn, instance) {\n-                    (Some(llfn), _) => llfn,\n-                    (None, Some(instance)) => bx.get_fn(instance),\n-                    _ => span_bug!(span, \"no llfn for call\"),\n-                };\n+            mir::TerminatorKind::Unreachable => {\n+                bx.unreachable();\n+            }\n \n-                do_call(self, &mut bx, fn_ty, fn_ptr, &llargs,\n-                        destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n-                        cleanup);\n+            mir::TerminatorKind::Drop { ref location, target, unwind } => {\n+                self.codegen_drop_terminator(helper, bx, location, target, unwind);\n+            }\n+\n+            mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n+                self.codegen_assert_terminator(helper, bx, terminator, cond,\n+                                               expected, msg, target, cleanup);\n+            }\n+\n+            mir::TerminatorKind::DropAndReplace { .. } => {\n+                bug!(\"undesugared DropAndReplace in codegen: {:?}\", terminator);\n+            }\n+\n+            mir::TerminatorKind::Call {\n+                ref func,\n+                ref args,\n+                ref destination,\n+                cleanup,\n+                from_hir_call: _\n+            } => {\n+                self.codegen_call_terminator(helper, bx, terminator, func,\n+                                             args, destination, cleanup);\n             }\n             mir::TerminatorKind::GeneratorDrop |\n             mir::TerminatorKind::Yield { .. } => bug!(\"generator ops in codegen\"),"}, {"sha": "dc77d4673cd2a3594b3e9d4865925eb04a3dc7c4", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 58, "deletions": 6, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -5,7 +5,7 @@ use rustc::mir::{self, Mir};\n use rustc::ty::subst::SubstsRef;\n use rustc::session::config::DebugInfo;\n use rustc_mir::monomorphize::Instance;\n-use rustc_target::abi::call::{FnType, PassMode};\n+use rustc_target::abi::call::{FnType, PassMode, IgnoreMode};\n use crate::base;\n use crate::debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n use crate::traits::*;\n@@ -86,6 +86,10 @@ pub struct FunctionCx<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> {\n \n     /// If this function is being monomorphized, this contains the type substitutions used.\n     param_substs: SubstsRef<'tcx>,\n+\n+    /// If this function is a C-variadic function, this contains the `PlaceRef` of the\n+    /// \"spoofed\" `VaList`.\n+    va_list_ref: Option<PlaceRef<'tcx, Bx::Value>>,\n }\n \n impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n@@ -246,13 +250,18 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             assert!(!instance.substs.needs_infer());\n             instance.substs\n         },\n+        va_list_ref: None,\n     };\n \n     let memory_locals = analyze::non_ssa_locals(&fx);\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n-        let args = arg_local_refs(&mut bx, &fx, &fx.scopes, &memory_locals);\n+        // FIXME(dlrobertson): This is ugly. Find a better way of getting the `PlaceRef` or\n+        // `LocalRef` from `arg_local_refs`\n+        let mut va_list_ref = None;\n+        let args = arg_local_refs(&mut bx, &fx, &fx.scopes, &memory_locals, &mut va_list_ref);\n+        fx.va_list_ref = va_list_ref;\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n@@ -433,6 +442,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         debuginfo::MirDebugScope<Bx::DIScope>\n     >,\n     memory_locals: &BitSet<mir::Local>,\n+    va_list_ref: &mut Option<PlaceRef<'tcx, Bx::Value>>,\n ) -> Vec<LocalRef<'tcx, Bx::Value>> {\n     let mir = fx.mir;\n     let tcx = fx.cx.tcx();\n@@ -447,6 +457,15 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         None\n     };\n \n+    // Store the index of the last argument. This is used to\n+    // call va_start on the va_list instead of attempting\n+    // to store_fn_arg.\n+    let last_arg_idx = if fx.fn_ty.args.is_empty() {\n+        None\n+    } else {\n+        Some(fx.fn_ty.args.len() - 1)\n+    };\n+\n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n \n@@ -510,9 +529,16 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             // of putting everything in allocas just so we can use llvm.dbg.declare.\n             let local = |op| LocalRef::Operand(Some(op));\n             match arg.mode {\n-                PassMode::Ignore => {\n+                PassMode::Ignore(IgnoreMode::Zst) => {\n                     return local(OperandRef::new_zst(bx.cx(), arg.layout));\n                 }\n+                PassMode::Ignore(IgnoreMode::CVarArgs) => {\n+                    let backend_type = bx.cx().immediate_backend_type(arg.layout);\n+                    return local(OperandRef {\n+                        val: OperandValue::Immediate(bx.cx().const_undef(backend_type)),\n+                        layout: arg.layout,\n+                    });\n+                }\n                 PassMode::Direct(_) => {\n                     let llarg = bx.get_param(bx.llfn(), llarg_idx as c_uint);\n                     bx.set_value_name(llarg, &name);\n@@ -559,9 +585,35 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             indirect_operand.store(bx, tmp);\n             tmp\n         } else {\n-            let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n-            bx.store_fn_arg(arg, &mut llarg_idx, tmp);\n-            tmp\n+            if fx.fn_ty.c_variadic && last_arg_idx.map(|idx| arg_index == idx).unwrap_or(false) {\n+                let va_list_impl = match arg_decl.ty.ty_adt_def() {\n+                    Some(adt) => adt.non_enum_variant(),\n+                    None => bug!(\"`va_list` language item improperly constructed\")\n+                };\n+                match tcx.type_of(va_list_impl.fields[0].did).sty {\n+                    ty::Ref(_, ty, _) => {\n+                        // If the underlying structure the `VaList` contains is a structure,\n+                        // we need to allocate it (e.g., X86_64 on Linux).\n+                        let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n+                        if let ty::Adt(..) = ty.sty {\n+                            let layout = bx.layout_of(ty);\n+                            // Create an unnamed allocation for the backing structure\n+                            // and store it in the the spoofed `VaList`.\n+                            let backing = PlaceRef::alloca(bx, layout, \"\");\n+                            bx.store(backing.llval, tmp.llval, layout.align.abi);\n+                        }\n+                        // Call `va_start` on the spoofed `VaList`.\n+                        bx.va_start(tmp.llval);\n+                        *va_list_ref = Some(tmp);\n+                        tmp\n+                    }\n+                    _ => bug!(\"improperly constructed `va_list` lang item\"),\n+                }\n+            } else {\n+                let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n+                bx.store_fn_arg(arg, &mut llarg_idx, tmp);\n+                tmp\n+            }\n         };\n         arg_scope.map(|scope| {\n             // Is this a regular argument?"}, {"sha": "cd5278989778ffac031c05d1b92e47883a5a808f", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -20,4 +20,10 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     fn abort(&mut self);\n     fn assume(&mut self, val: Self::Value);\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;\n+    /// Trait method used to inject `va_start` on the \"spoofed\" `VaList` in\n+    /// Rust defined C-variadic functions.\n+    fn va_start(&mut self, val: Self::Value) -> Self::Value;\n+    /// Trait method used to inject `va_end` on the \"spoofed\" `VaList` before\n+    /// Rust defined C-variadic functions return.\n+    fn va_end(&mut self, val: Self::Value) -> Self::Value;\n }"}, {"sha": "35489ab42e73038c056cea9f25597d1903155bca", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -766,8 +766,15 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let def_id = self.cx.tcx.hir().local_def_id(id);\n         let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n+        let inputs = if sig.c_variadic {\n+            // Don't include the spoofed `VaList` in the functions list\n+            // of inputs.\n+            &sig.inputs()[..sig.inputs().len() - 1]\n+        } else {\n+            &sig.inputs()[..]\n+        };\n \n-        for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {\n+        for (input_ty, input_hir) in inputs.iter().zip(&decl.inputs) {\n             self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty);\n         }\n "}, {"sha": "df035aab54c9cdb042b7e04268e67b11615c9678", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1602,10 +1602,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         from_hir_call: bool,\n     ) {\n         debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n-        if args.len() < sig.inputs().len() || (args.len() > sig.inputs().len() && !sig.variadic) {\n+        // Do not count the `VaList` argument as a \"true\" argument to\n+        // a C-variadic function.\n+        let inputs = if sig.c_variadic {\n+            &sig.inputs()[..sig.inputs().len() - 1]\n+        } else {\n+            &sig.inputs()[..]\n+        };\n+        if args.len() < inputs.len() || (args.len() > inputs.len() && !sig.c_variadic) {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n-        for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n+        for (n, (fn_arg, op_arg)) in inputs.iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n             let category = if from_hir_call {\n                 ConstraintCategory::CallArgument"}, {"sha": "059af2dbba944710f23d5e815e6c3d451acf35c8", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                     output.pop();\n                 }\n \n-                if sig.variadic {\n+                if sig.c_variadic {\n                     if !sig.inputs().is_empty() {\n                         output.push_str(\", ...\");\n                     } else {"}, {"sha": "64a2c92d04dbd9289fe7d872843f8c60965599f0", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -190,6 +190,7 @@ impl Sig for ast::Ty {\n                 Ok(replace_text(nested, text))\n             }\n             ast::TyKind::Never => Ok(text_sig(\"!\".to_owned())),\n+            ast::TyKind::CVarArgs => Ok(text_sig(\"...\".to_owned())),\n             ast::TyKind::Tup(ref ts) => {\n                 let mut text = \"(\".to_owned();\n                 let mut defs = vec![];"}, {"sha": "e3fee8e5700c196bb62e68d420a0b481e3fa7fd8", "filename": "src/librustc_target/abi/call/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -99,7 +99,7 @@ pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n     // `extern \"aapcs\"`, then we must use the VFP registers for homogeneous aggregates.\n     let vfp = cx.target_spec().llvm_target.ends_with(\"hf\")\n         && fty.conv != Conv::ArmAapcs\n-        && !fty.variadic;\n+        && !fty.c_variadic;\n \n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret, vfp);"}, {"sha": "fbbd120f934be845fc21ac5e5a5c2245699cdc59", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -23,10 +23,18 @@ mod x86_64;\n mod x86_win64;\n mod wasm32;\n \n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum IgnoreMode {\n+    /// C-variadic arguments.\n+    CVarArgs,\n+    /// A zero-sized type.\n+    Zst,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum PassMode {\n-    /// Ignore the argument (useful for empty struct).\n-    Ignore,\n+    /// Ignore the argument (useful for empty structs and C-variadic args).\n+    Ignore(IgnoreMode),\n     /// Pass the argument directly.\n     Direct(ArgAttributes),\n     /// Pass a pair's elements directly in two arguments.\n@@ -481,7 +489,10 @@ impl<'a, Ty> ArgType<'a, Ty> {\n     }\n \n     pub fn is_ignore(&self) -> bool {\n-        self.mode == PassMode::Ignore\n+        match self.mode {\n+            PassMode::Ignore(_) => true,\n+            _ => false\n+        }\n     }\n }\n \n@@ -520,7 +531,7 @@ pub struct FnType<'a, Ty> {\n     /// LLVM return type.\n     pub ret: ArgType<'a, Ty>,\n \n-    pub variadic: bool,\n+    pub c_variadic: bool,\n \n     pub conv: Conv,\n }"}, {"sha": "6ca3ce88bd6eb37a9aa9aaadf0d35c23812bccfe", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -88,7 +88,7 @@ pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>, flavor: Fla\n \n         for arg in &mut fty.args {\n             let attrs = match arg.mode {\n-                PassMode::Ignore |\n+                PassMode::Ignore(_) |\n                 PassMode::Indirect(_, None) => continue,\n                 PassMode::Direct(ref mut attrs) => attrs,\n                 PassMode::Pair(..) |"}, {"sha": "3f88d0e08b46ae29eb286880dcdb5935fbe80df2", "filename": "src/librustc_traits/chalk_context/program_clauses.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -105,7 +105,7 @@ fn assemble_builtin_sized_impls<'tcx>(\n             let fn_ptr = generic_types::fn_ptr(\n                 tcx,\n                 fn_ptr.inputs_and_output.len(),\n-                fn_ptr.variadic,\n+                fn_ptr.c_variadic,\n                 fn_ptr.unsafety,\n                 fn_ptr.abi\n             );\n@@ -190,11 +190,11 @@ fn wf_clause_for_raw_ptr<'tcx>(\n fn wf_clause_for_fn_ptr<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     arity_and_output: usize,\n-    variadic: bool,\n+    c_variadic: bool,\n     unsafety: hir::Unsafety,\n     abi: abi::Abi\n ) -> Clauses<'tcx> {\n-    let fn_ptr = generic_types::fn_ptr(tcx, arity_and_output, variadic, unsafety, abi);\n+    let fn_ptr = generic_types::fn_ptr(tcx, arity_and_output, c_variadic, unsafety, abi);\n \n     let wf_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(fn_ptr)),\n@@ -503,7 +503,7 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n                         wf_clause_for_fn_ptr(\n                             self.infcx.tcx,\n                             fn_ptr.inputs_and_output.len(),\n-                            fn_ptr.variadic,\n+                            fn_ptr.c_variadic,\n                             fn_ptr.unsafety,\n                             fn_ptr.abi\n                         )"}, {"sha": "f2ce9631f35aba590620b862ac87efc73c397523", "filename": "src/librustc_traits/generic_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -24,7 +24,7 @@ crate fn raw_ptr(tcx: TyCtxt<'_, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx>\n crate fn fn_ptr(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     arity_and_output: usize,\n-    variadic: bool,\n+    c_variadic: bool,\n     unsafety: hir::Unsafety,\n     abi: abi::Abi\n ) -> Ty<'tcx> {\n@@ -37,7 +37,7 @@ crate fn fn_ptr(\n \n     let fn_sig = ty::Binder::bind(ty::FnSig {\n         inputs_and_output,\n-        variadic,\n+        c_variadic,\n         unsafety,\n         abi,\n     });"}, {"sha": "4a88922b50ee2b3fd4a728620d7c60409763aec8", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::subst::{Kind, Subst, InternalSubsts, SubstsRef};\n use rustc::ty::wf::object_region_bounds;\n use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi;\n-use crate::require_c_abi_if_variadic;\n+use crate::require_c_abi_if_c_variadic;\n use smallvec::SmallVec;\n use syntax::ast;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n@@ -1769,7 +1769,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(&t)))\n             }\n             hir::TyKind::BareFn(ref bf) => {\n-                require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n+                require_c_abi_if_c_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n                 tcx.mk_fn_ptr(self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl))\n             }\n             hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n@@ -1823,6 +1823,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             hir::TyKind::Err => {\n                 tcx.types.err\n             }\n+            hir::TyKind::CVarArgs(lt) => {\n+                let va_list_did = match tcx.lang_items().va_list() {\n+                    Some(did) => did,\n+                    None => span_bug!(ast_ty.span,\n+                                      \"`va_list` lang item required for variadics\"),\n+                };\n+                let region = self.ast_region_to_region(&lt, None);\n+                tcx.type_of(va_list_did).subst(tcx, &[region.into()])\n+            }\n         };\n \n         self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);\n@@ -1905,7 +1914,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let bare_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n             input_tys,\n             output_ty,\n-            decl.variadic,\n+            decl.c_variadic,\n             unsafety,\n             abi\n         ));"}, {"sha": "0a4c0eb3aff72c1b25b5a34fb47dee71ec71c67f", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -368,20 +368,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .0;\n         let fn_sig = self.normalize_associated_types_in(call_expr.span, &fn_sig);\n \n+        let inputs = if fn_sig.c_variadic {\n+            if fn_sig.inputs().len() > 1 {\n+                &fn_sig.inputs()[..fn_sig.inputs().len() - 1]\n+            } else {\n+                span_bug!(call_expr.span,\n+                          \"C-variadic functions are only valid with one or more fixed arguments\");\n+            }\n+        } else {\n+            &fn_sig.inputs()[..]\n+        };\n         // Call the generic checker.\n         let expected_arg_tys = self.expected_inputs_for_expected_output(\n             call_expr.span,\n             expected,\n             fn_sig.output(),\n-            fn_sig.inputs(),\n+            inputs,\n         );\n         self.check_argument_types(\n             call_expr.span,\n             call_expr.span,\n-            fn_sig.inputs(),\n+            inputs,\n             &expected_arg_tys[..],\n             arg_exprs,\n-            fn_sig.variadic,\n+            fn_sig.c_variadic,\n             TupleArgumentsFlag::DontTupleArguments,\n             def_span,\n         );\n@@ -414,7 +424,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             fn_sig.inputs(),\n             &expected_arg_tys,\n             arg_exprs,\n-            fn_sig.variadic,\n+            fn_sig.c_variadic,\n             TupleArgumentsFlag::TupleArguments,\n             None,\n         );"}, {"sha": "db89b32be7b68d109acbc19f557bdcb747d495de", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -141,7 +141,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.tcx.mk_fn_sig(\n                 iter::once(self.tcx.intern_tup(sig.inputs())),\n                 sig.output(),\n-                sig.variadic,\n+                sig.c_variadic,\n                 sig.unsafety,\n                 sig.abi,\n             )\n@@ -386,7 +386,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Watch out for some surprises and just ignore the\n         // expectation if things don't see to match up with what we\n         // expect.\n-        if expected_sig.sig.variadic != decl.variadic {\n+        if expected_sig.sig.c_variadic != decl.c_variadic {\n             return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n         } else if expected_sig.sig.inputs_and_output.len() != decl.inputs.len() + 1 {\n             return self.sig_of_closure_with_mismatched_number_of_arguments(\n@@ -404,7 +404,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let bound_sig = ty::Binder::bind(self.tcx.mk_fn_sig(\n             expected_sig.sig.inputs().iter().cloned(),\n             expected_sig.sig.output(),\n-            decl.variadic,\n+            decl.c_variadic,\n             hir::Unsafety::Normal,\n             Abi::RustCall,\n         ));\n@@ -586,7 +586,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let result = ty::Binder::bind(self.tcx.mk_fn_sig(\n             supplied_arguments,\n             supplied_return,\n-            decl.variadic,\n+            decl.c_variadic,\n             hir::Unsafety::Normal,\n             Abi::RustCall,\n         ));\n@@ -621,7 +621,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let result = ty::Binder::bind(self.tcx.mk_fn_sig(\n             supplied_arguments,\n             self.tcx.types.err,\n-            decl.variadic,\n+            decl.c_variadic,\n             hir::Unsafety::Normal,\n             Abi::RustCall,\n         ));"}, {"sha": "924ced2e2a3c77c1cd76729e63734ebd2384fd82", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -337,7 +337,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"va_start\" | \"va_end\" => {\n                 match mk_va_list_ty() {\n                     Some(va_list_ty) => (0, vec![va_list_ty], tcx.mk_unit()),\n-                    None => bug!(\"va_list lang_item must be defined to use va_list intrinsics\")\n+                    None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }\n             }\n \n@@ -364,14 +364,14 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         };\n                         (0, vec![tcx.mk_imm_ref(tcx.mk_region(env_region), va_list_ty)], ret_ty)\n                     }\n-                    None => bug!(\"va_list lang_item must be defined to use va_list intrinsics\")\n+                    None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }\n             }\n \n             \"va_arg\" => {\n                 match mk_va_list_ty() {\n                     Some(va_list_ty) => (1, vec![va_list_ty], param(0)),\n-                    None => bug!(\"va_list lang_item must be defined to use va_list intrinsics\")\n+                    None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }\n             }\n "}, {"sha": "3a430f77b6c64b8373847c0f5224af35d5487250", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -130,7 +130,7 @@ use std::mem::replace;\n use std::ops::{self, Deref};\n use std::slice;\n \n-use crate::require_c_abi_if_variadic;\n+use crate::require_c_abi_if_c_variadic;\n use crate::session::{CompileIncomplete, Session};\n use crate::session::config::EntryFnType;\n use crate::TypeAndSubsts;\n@@ -1072,7 +1072,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     fn_sig = fcx.tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n         revealed_ret_ty,\n-        fn_sig.variadic,\n+        fn_sig.c_variadic,\n         fn_sig.unsafety,\n         fn_sig.abi\n     );\n@@ -1426,7 +1426,7 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n                     }\n \n                     if let hir::ForeignItemKind::Fn(ref fn_decl, _, _) = item.node {\n-                        require_c_abi_if_variadic(tcx, fn_decl, m.abi, item.span);\n+                        require_c_abi_if_c_variadic(tcx, fn_decl, m.abi, item.span);\n                     }\n                 }\n             }\n@@ -2783,7 +2783,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             &method.sig.inputs()[1..]\n         );\n         self.check_argument_types(sp, expr_sp, &method.sig.inputs()[1..], &expected_arg_tys[..],\n-                                  args_no_rcvr, method.sig.variadic, tuple_arguments,\n+                                  args_no_rcvr, method.sig.c_variadic, tuple_arguments,\n                                   self.tcx.hir().span_if_local(method.def_id));\n         method.sig.output()\n     }\n@@ -2862,7 +2862,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             fn_inputs: &[Ty<'tcx>],\n                             mut expected_arg_tys: &[Ty<'tcx>],\n                             args: &'gcx [hir::Expr],\n-                            variadic: bool,\n+                            c_variadic: bool,\n                             tuple_arguments: TupleArgumentsFlag,\n                             def_span: Option<Span>) {\n         let tcx = self.tcx;\n@@ -2886,11 +2886,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let param_count_error = |expected_count: usize,\n                                  arg_count: usize,\n                                  error_code: &str,\n-                                 variadic: bool,\n+                                 c_variadic: bool,\n                                  sugg_unit: bool| {\n             let mut err = tcx.sess.struct_span_err_with_code(sp,\n                 &format!(\"this function takes {}{} but {} {} supplied\",\n-                    if variadic {\"at least \"} else {\"\"},\n+                    if c_variadic { \"at least \" } else { \"\" },\n                     potentially_plural_count(expected_count, \"parameter\"),\n                     potentially_plural_count(arg_count, \"parameter\"),\n                     if arg_count == 1 {\"was\"} else {\"were\"}),\n@@ -2910,7 +2910,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Applicability::MachineApplicable);\n             } else {\n                 err.span_label(sp, format!(\"expected {}{}\",\n-                                           if variadic {\"at least \"} else {\"\"},\n+                                           if c_variadic { \"at least \" } else { \"\" },\n                                            potentially_plural_count(expected_count, \"parameter\")));\n             }\n             err.emit();\n@@ -2944,7 +2944,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         } else if expected_arg_count == supplied_arg_count {\n             fn_inputs.to_vec()\n-        } else if variadic {\n+        } else if c_variadic {\n             if supplied_arg_count >= expected_arg_count {\n                 fn_inputs.to_vec()\n             } else {\n@@ -2991,10 +2991,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.select_obligations_where_possible(false);\n             }\n \n-            // For variadic functions, we don't have a declared type for all of\n+            // For C-variadic functions, we don't have a declared type for all of\n             // the arguments hence we only do our usual type checking with\n             // the arguments who's types we do know.\n-            let t = if variadic {\n+            let t = if c_variadic {\n                 expected_arg_count\n             } else if tuple_arguments == TupleArguments {\n                 args.len()\n@@ -3043,7 +3043,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // We also need to make sure we at least write the ty of the other\n         // arguments which we skipped above.\n-        if variadic {\n+        if c_variadic {\n             fn variadic_error<'tcx>(s: &Session, span: Span, t: Ty<'tcx>, cast_ty: &str) {\n                 use crate::structured_errors::{VariadicError, StructuredDiagnostic};\n                 VariadicError::new(s, span, t, cast_ty).diagnostic().emit();"}, {"sha": "2095c81d0fb0db1893945846097a587ff6551b99", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -136,14 +136,14 @@ fn check_type_alias_enum_variants_enabled<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx,\n     }\n }\n \n-fn require_c_abi_if_variadic(tcx: TyCtxt<'_, '_, '_>,\n-                             decl: &hir::FnDecl,\n-                             abi: Abi,\n-                             span: Span) {\n-    if decl.variadic && !(abi == Abi::C || abi == Abi::Cdecl) {\n+fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_, '_, '_>,\n+                               decl: &hir::FnDecl,\n+                               abi: Abi,\n+                               span: Span) {\n+    if decl.c_variadic && !(abi == Abi::C || abi == Abi::Cdecl) {\n         let mut err = struct_span_err!(tcx.sess, span, E0045,\n-            \"variadic function must have C or cdecl calling convention\");\n-        err.span_label(span, \"variadics require C or cdecl calling convention\").emit();\n+            \"C-variadic function must have C or cdecl calling convention\");\n+        err.span_label(span, \"C-variadics require C or cdecl calling convention\").emit();\n     }\n }\n "}, {"sha": "53dcc258c690b592495010d0e2046700d03f48c3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1752,7 +1752,6 @@ impl Clean<Item> for doctree::Function {\n pub struct FnDecl {\n     pub inputs: Arguments,\n     pub output: FunctionRetTy,\n-    pub variadic: bool,\n     pub attrs: Attributes,\n }\n \n@@ -1831,7 +1830,6 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n         FnDecl {\n             inputs: (&self.0.inputs[..], self.1).clean(cx),\n             output: self.0.output.clean(cx),\n-            variadic: self.0.variadic,\n             attrs: Attributes::default()\n         }\n     }\n@@ -1849,7 +1847,6 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n         FnDecl {\n             output: Return(sig.skip_binder().output().clean(cx)),\n             attrs: Attributes::default(),\n-            variadic: sig.skip_binder().variadic,\n             inputs: Arguments {\n                 values: sig.skip_binder().inputs().iter().map(|t| {\n                     Argument {\n@@ -2252,6 +2249,7 @@ pub enum Type {\n     Slice(Box<Type>),\n     Array(Box<Type>, String),\n     Never,\n+    CVarArgs,\n     Unique(Box<Type>),\n     RawPointer(Mutability, Box<Type>),\n     BorrowedRef {\n@@ -2290,6 +2288,7 @@ pub enum PrimitiveType {\n     Reference,\n     Fn,\n     Never,\n+    CVarArgs,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Copy, Debug)]\n@@ -2469,6 +2468,7 @@ impl PrimitiveType {\n             Reference => \"reference\",\n             Fn => \"fn\",\n             Never => \"never\",\n+            CVarArgs => \"...\",\n         }\n     }\n \n@@ -2518,6 +2518,7 @@ impl Clean<Type> for hir::Ty {\n \n         match self.node {\n             TyKind::Never => Never,\n+            TyKind::CVarArgs(_) => CVarArgs,\n             TyKind::Ptr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n             TyKind::Rptr(ref l, ref m) => {\n                 let lifetime = if l.is_elided() {\n@@ -3654,6 +3655,7 @@ fn build_deref_target_impls(cx: &DocContext<'_, '_, '_>,\n             Reference => None,\n             Fn => None,\n             Never => None,\n+            CVarArgs => tcx.lang_items().va_list(),\n         };\n         if let Some(did) = did {\n             if !did.is_local() {"}, {"sha": "d204a179ca62cb68098cbe9b2dd5ac5b6bf13da7", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -609,6 +609,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n             primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n))\n         }\n         clean::Never => primitive_link(f, PrimitiveType::Never, \"!\"),\n+        clean::CVarArgs => primitive_link(f, PrimitiveType::CVarArgs, \"...\"),\n         clean::RawPointer(m, ref t) => {\n             match **t {\n                 clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n@@ -834,18 +835,10 @@ impl fmt::Display for clean::FunctionRetTy {\n \n impl fmt::Display for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.variadic {\n-            if f.alternate() {\n-                write!(f, \"({args:#}, ...){arrow:#}\", args = self.inputs, arrow = self.output)\n-            } else {\n-                write!(f, \"({args}, ...){arrow}\", args = self.inputs, arrow = self.output)\n-            }\n+        if f.alternate() {\n+            write!(f, \"({args:#}){arrow:#}\", args = self.inputs, arrow = self.output)\n         } else {\n-            if f.alternate() {\n-                write!(f, \"({args:#}){arrow:#}\", args = self.inputs, arrow = self.output)\n-            } else {\n-                write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n-            }\n+            write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n         }\n     }\n }\n@@ -907,12 +900,7 @@ impl<'a> fmt::Display for Function<'a> {\n             }\n         }\n \n-        let mut args_plain = format!(\"({})\", args_plain);\n-\n-        if decl.variadic {\n-            args.push_str(\",<br> ...\");\n-            args_plain.push_str(\", ...\");\n-        }\n+        let args_plain = format!(\"({})\", args_plain);\n \n         let output = if let hir::IsAsync::Async = asyncness {\n             Cow::Owned(decl.sugared_async_return_type())"}, {"sha": "a01a5bb0a36383da7785012885af8b86b9c93bcb", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1643,6 +1643,8 @@ pub enum TyKind {\n     Mac(Mac),\n     /// Placeholder for a kind that has failed to be defined.\n     Err,\n+    /// Placeholder for a `va_list`.\n+    CVarArgs,\n }\n \n impl TyKind {\n@@ -1802,7 +1804,7 @@ impl Arg {\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n     pub output: FunctionRetTy,\n-    pub variadic: bool,\n+    pub c_variadic: bool,\n }\n \n impl FnDecl {"}, {"sha": "e95f05894491b670f6c5e8d9df58bd22951226f1", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -985,7 +985,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         P(ast::FnDecl {\n             inputs,\n             output,\n-            variadic: false\n+            c_variadic: false\n         })\n     }\n "}, {"sha": "1c0b931b289c23d8826d02030b67fb07e3b5bd10", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -471,6 +471,9 @@ declare_features! (\n \n     // #[repr(align(X))] on enums\n     (active, repr_align_enum, \"1.34.0\", Some(57996), None),\n+\n+    // Allows the use of C-variadics\n+    (active, c_variadic, \"1.34.0\", Some(44930), None),\n );\n \n declare_features! (\n@@ -1901,6 +1904,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 if header.asyncness.node.is_async() {\n                     gate_feature_post!(&self, async_await, span, \"async fn is unstable\");\n                 }\n+\n+                if fn_decl.c_variadic {\n+                    gate_feature_post!(&self, c_variadic, span,\n+                                       \"C-varaidic functions are unstable\");\n+                }\n                 // Stability of const fn methods are covered in\n                 // `visit_trait_item` and `visit_impl_item` below; this is\n                 // because default methods don't pass through this point.\n@@ -1929,6 +1937,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 if block.is_none() {\n                     self.check_abi(sig.header.abi, ti.span);\n                 }\n+                if sig.decl.c_variadic {\n+                    gate_feature_post!(&self, c_variadic, ti.span,\n+                                       \"C-varaidic functions are unstable\");\n+                }\n                 if sig.header.constness.node == ast::Constness::Const {\n                     gate_feature_post!(&self, const_fn, ti.span, \"const fn is unstable\");\n                 }"}, {"sha": "802b78086959721be2aed40543a8712feb949a07", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -409,7 +409,8 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n     let Ty { id, node, span } = ty.deref_mut();\n     vis.visit_id(id);\n     match node {\n-        TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err | TyKind::Never => {}\n+        TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err |\n+            TyKind::Never | TyKind::CVarArgs => {}\n         TyKind::Slice(ty) => vis.visit_ty(ty),\n         TyKind::Ptr(mt) => vis.visit_mt(mt),\n         TyKind::Rptr(lt, mt) => {\n@@ -680,7 +681,7 @@ pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T)\n }\n \n pub fn noop_visit_fn_decl<T: MutVisitor>(decl: &mut P<FnDecl>, vis: &mut T) {\n-    let FnDecl { inputs, output, variadic: _ } = decl.deref_mut();\n+    let FnDecl { inputs, output, c_variadic: _ } = decl.deref_mut();\n     visit_vec(inputs, |input| vis.visit_arg(input));\n     match output {\n         FunctionRetTy::Default(span) => vis.visit_span(span),"}, {"sha": "fd5038a8614f25823cf6c0aee5bd3664701d119d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 70, "deletions": 60, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1457,12 +1457,12 @@ impl<'a> Parser<'a> {\n         };\n \n         self.expect_keyword(keywords::Fn)?;\n-        let (inputs, variadic) = self.parse_fn_args(false, true)?;\n+        let (inputs, c_variadic) = self.parse_fn_args(false, true)?;\n         let ret_ty = self.parse_ret_ty(false)?;\n         let decl = P(FnDecl {\n             inputs,\n             output: ret_ty,\n-            variadic,\n+            c_variadic,\n         });\n         Ok(TyKind::BareFn(P(BareFnTy {\n             abi,\n@@ -1543,7 +1543,7 @@ impl<'a> Parser<'a> {\n                 // definition...\n \n                 // We don't allow argument names to be left off in edition 2018.\n-                p.parse_arg_general(p.span.rust_2018(), true)\n+                p.parse_arg_general(p.span.rust_2018(), true, false)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n \n@@ -1613,15 +1613,15 @@ impl<'a> Parser<'a> {\n     /// Parses an optional return type `[ -> TY ]` in a function declaration.\n     fn parse_ret_ty(&mut self, allow_plus: bool) -> PResult<'a, FunctionRetTy> {\n         if self.eat(&token::RArrow) {\n-            Ok(FunctionRetTy::Ty(self.parse_ty_common(allow_plus, true)?))\n+            Ok(FunctionRetTy::Ty(self.parse_ty_common(allow_plus, true, false)?))\n         } else {\n             Ok(FunctionRetTy::Default(self.span.shrink_to_lo()))\n         }\n     }\n \n     /// Parses a type.\n     pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(true, true)\n+        self.parse_ty_common(true, true, false)\n     }\n \n     /// Parses a type in restricted contexts where `+` is not permitted.\n@@ -1631,11 +1631,11 @@ impl<'a> Parser<'a> {\n     /// Example 2: `value1 as TYPE + value2`\n     ///     `+` is prohibited to avoid interactions with expression grammar.\n     fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(false, true)\n+        self.parse_ty_common(false, true, false)\n     }\n \n-    fn parse_ty_common(&mut self, allow_plus: bool, allow_qpath_recovery: bool)\n-                       -> PResult<'a, P<Ty>> {\n+    fn parse_ty_common(&mut self, allow_plus: bool, allow_qpath_recovery: bool,\n+                       allow_c_variadic: bool) -> PResult<'a, P<Ty>> {\n         maybe_whole!(self, NtTy, |x| x);\n \n         let lo = self.span;\n@@ -1772,6 +1772,15 @@ impl<'a> Parser<'a> {\n                     TyKind::Path(None, path)\n                 }\n             }\n+        } else if self.check(&token::DotDotDot) {\n+            if allow_c_variadic {\n+                self.eat(&token::DotDotDot);\n+                TyKind::CVarArgs\n+            } else {\n+                return Err(self.fatal(\n+                    \"only foreign functions are allowed to be C-variadic\"\n+                ));\n+            }\n         } else {\n             let msg = format!(\"expected type, found {}\", self.this_token_descr());\n             return Err(self.fatal(&msg));\n@@ -1959,7 +1968,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// This version of parse arg doesn't necessarily require identifier names.\n-    fn parse_arg_general(&mut self, require_name: bool, is_trait_item: bool) -> PResult<'a, Arg> {\n+    fn parse_arg_general(&mut self, require_name: bool, is_trait_item: bool,\n+                         allow_c_variadic: bool) -> PResult<'a, Arg> {\n         maybe_whole!(self, NtArg, |x| x);\n \n         if let Ok(Some(_)) = self.parse_self_arg() {\n@@ -2008,12 +2018,12 @@ impl<'a> Parser<'a> {\n             }\n \n             self.eat_incorrect_doc_comment(\"a method argument's type\");\n-            (pat, self.parse_ty()?)\n+            (pat, self.parse_ty_common(true, true, allow_c_variadic)?)\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n             let parser_snapshot_before_ty = self.clone();\n             self.eat_incorrect_doc_comment(\"a method argument's type\");\n-            let mut ty = self.parse_ty();\n+            let mut ty = self.parse_ty_common(true, true, allow_c_variadic);\n             if ty.is_ok() && self.token != token::Comma &&\n                self.token != token::CloseDelim(token::Paren) {\n                 // This wasn't actually a type, but a pattern looking like a type,\n@@ -2032,6 +2042,11 @@ impl<'a> Parser<'a> {\n                     (pat, ty)\n                 }\n                 Err(mut err) => {\n+                    // If this is a C-variadic argument and we hit an error, return the\n+                    // error.\n+                    if self.token == token::DotDotDot {\n+                        return Err(err);\n+                    }\n                     // Recover from attempting to parse the argument as a type without pattern.\n                     err.cancel();\n                     mem::replace(self, parser_snapshot_before_ty);\n@@ -2068,7 +2083,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a single function argument.\n     crate fn parse_arg(&mut self) -> PResult<'a, Arg> {\n-        self.parse_arg_general(true, false)\n+        self.parse_arg_general(true, false, false)\n     }\n \n     /// Parses an argument in a lambda header (e.g., `|arg, arg|`).\n@@ -2406,7 +2421,7 @@ impl<'a> Parser<'a> {\n                 }\n                 let span = lo.to(self.prev_span);\n                 let output = if self.eat(&token::RArrow) {\n-                    Some(self.parse_ty_common(false, false)?)\n+                    Some(self.parse_ty_common(false, false, false)?)\n                 } else {\n                     None\n                 };\n@@ -6113,55 +6128,49 @@ impl<'a> Parser<'a> {\n         Ok(where_clause)\n     }\n \n-    fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n+    fn parse_fn_args(&mut self, named_args: bool, allow_c_variadic: bool)\n                      -> PResult<'a, (Vec<Arg> , bool)> {\n         self.expect(&token::OpenDelim(token::Paren))?;\n \n         let sp = self.span;\n-        let mut variadic = false;\n+        let mut c_variadic = false;\n         let (args, recovered): (Vec<Option<Arg>>, bool) =\n             self.parse_seq_to_before_end(\n                 &token::CloseDelim(token::Paren),\n                 SeqSep::trailing_allowed(token::Comma),\n                 |p| {\n-                    if p.token == token::DotDotDot {\n-                        p.bump();\n-                        variadic = true;\n-                        if allow_variadic {\n-                            if p.token != token::CloseDelim(token::Paren) {\n-                                let span = p.span;\n-                                p.span_err(span,\n-                                    \"`...` must be last in argument list for variadic function\");\n-                            }\n-                            Ok(None)\n-                        } else {\n-                            let span = p.prev_span;\n-                            if p.token == token::CloseDelim(token::Paren) {\n-                                // continue parsing to present any further errors\n-                                p.struct_span_err(\n-                                    span,\n-                                    \"only foreign functions are allowed to be variadic\"\n-                                ).emit();\n-                                Ok(Some(dummy_arg(span)))\n-                           } else {\n-                               // this function definition looks beyond recovery, stop parsing\n-                                p.span_err(span,\n-                                           \"only foreign functions are allowed to be variadic\");\n-                                Ok(None)\n-                            }\n-                        }\n+                    // If the argument is a C-variadic argument we should not\n+                    // enforce named arguments.\n+                    let enforce_named_args = if p.token == token::DotDotDot {\n+                        false\n                     } else {\n-                        match p.parse_arg_general(named_args, false) {\n-                            Ok(arg) => Ok(Some(arg)),\n-                            Err(mut e) => {\n-                                e.emit();\n-                                let lo = p.prev_span;\n-                                // Skip every token until next possible arg or end.\n-                                p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n-                                // Create a placeholder argument for proper arg count (#34264).\n-                                let span = lo.to(p.prev_span);\n-                                Ok(Some(dummy_arg(span)))\n+                        named_args\n+                    };\n+                    match p.parse_arg_general(enforce_named_args, false,\n+                                              allow_c_variadic) {\n+                        Ok(arg) => {\n+                            if let TyKind::CVarArgs = arg.ty.node {\n+                                c_variadic = true;\n+                                if p.token != token::CloseDelim(token::Paren) {\n+                                    let span = p.span;\n+                                    p.span_err(span,\n+                                        \"`...` must be the last argument of a C-variadic function\");\n+                                    Ok(None)\n+                                } else {\n+                                    Ok(Some(arg))\n+                                }\n+                            } else {\n+                                Ok(Some(arg))\n                             }\n+                        },\n+                        Err(mut e) => {\n+                            e.emit();\n+                            let lo = p.prev_span;\n+                            // Skip every token until next possible arg or end.\n+                            p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n+                            // Create a placeholder argument for proper arg count (issue #34264).\n+                            let span = lo.to(p.prev_span);\n+                            Ok(Some(dummy_arg(span)))\n                         }\n                     }\n                 }\n@@ -6173,24 +6182,24 @@ impl<'a> Parser<'a> {\n \n         let args: Vec<_> = args.into_iter().filter_map(|x| x).collect();\n \n-        if variadic && args.is_empty() {\n+        if c_variadic && args.is_empty() {\n             self.span_err(sp,\n-                          \"variadic function must be declared with at least one named argument\");\n+                          \"C-variadic function must be declared with at least one named argument\");\n         }\n \n-        Ok((args, variadic))\n+        Ok((args, c_variadic))\n     }\n \n     /// Parses the argument list and result type of a function declaration.\n-    fn parse_fn_decl(&mut self, allow_variadic: bool) -> PResult<'a, P<FnDecl>> {\n+    fn parse_fn_decl(&mut self, allow_c_variadic: bool) -> PResult<'a, P<FnDecl>> {\n \n-        let (args, variadic) = self.parse_fn_args(true, allow_variadic)?;\n+        let (args, c_variadic) = self.parse_fn_args(true, allow_c_variadic)?;\n         let ret_ty = self.parse_ret_ty(true)?;\n \n         Ok(P(FnDecl {\n             inputs: args,\n             output: ret_ty,\n-            variadic,\n+            c_variadic,\n         }))\n     }\n \n@@ -6337,7 +6346,7 @@ impl<'a> Parser<'a> {\n         Ok(P(FnDecl {\n             inputs: fn_inputs,\n             output: self.parse_ret_ty(true)?,\n-            variadic: false\n+            c_variadic: false\n         }))\n     }\n \n@@ -6363,7 +6372,7 @@ impl<'a> Parser<'a> {\n         Ok(P(FnDecl {\n             inputs: inputs_captures,\n             output,\n-            variadic: false\n+            c_variadic: false\n         }))\n     }\n \n@@ -6395,7 +6404,8 @@ impl<'a> Parser<'a> {\n                      abi: Abi)\n                      -> PResult<'a, ItemInfo> {\n         let (ident, mut generics) = self.parse_fn_header()?;\n-        let decl = self.parse_fn_decl(false)?;\n+        let allow_c_variadic = abi == Abi::C && unsafety == Unsafety::Unsafe;\n+        let decl = self.parse_fn_decl(allow_c_variadic)?;\n         generics.where_clause = self.parse_where_clause()?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n         let header = FnHeader { unsafety, asyncness, constness, abi };"}, {"sha": "942bd96939173bf20f4e100f6cb6833617d75b20", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1118,6 +1118,9 @@ impl<'a> State<'a> {\n             ast::TyKind::Mac(ref m) => {\n                 self.print_mac(m)?;\n             }\n+            ast::TyKind::CVarArgs => {\n+                self.s.word(\"...\")?;\n+            }\n         }\n         self.end()\n     }\n@@ -2811,7 +2814,7 @@ impl<'a> State<'a> {\n         -> io::Result<()> {\n         self.popen()?;\n         self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, false))?;\n-        if decl.variadic {\n+        if decl.c_variadic {\n             self.s.word(\", ...\")?;\n         }\n         self.pclose()?;\n@@ -3238,7 +3241,7 @@ mod tests {\n             let decl = ast::FnDecl {\n                 inputs: Vec::new(),\n                 output: ast::FunctionRetTy::Default(syntax_pos::DUMMY_SP),\n-                variadic: false\n+                c_variadic: false\n             };\n             let generics = ast::Generics::default();\n             assert_eq!("}, {"sha": "6b3a30ccb54b76738354be8bc8b4ddda3fe3ae55", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -319,7 +319,7 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             walk_list!(visitor, visit_lifetime, opt_lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Never => {},\n+        TyKind::Never | TyKind::CVarArgs => {}\n         TyKind::Tup(ref tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }"}, {"sha": "09c18ed90b21655536d118ac39bc65da6607541b", "filename": "src/test/codegen/c-variadic.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fcodegen%2Fc-variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fcodegen%2Fc-variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fc-variadic.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -0,0 +1,69 @@\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+#![feature(c_variadic)]\n+#![no_std]\n+use core::ffi::VaList;\n+\n+extern \"C\" {\n+    fn foreign_c_variadic_0(_: i32, ...);\n+    fn foreign_c_variadic_1(_: VaList, ...);\n+}\n+\n+pub unsafe extern \"C\" fn use_foreign_c_variadic_0() {\n+    // Ensure that we correctly call foreign C-variadic functions.\n+    // CHECK: invoke void (i32, ...) @foreign_c_variadic_0(i32 0)\n+    foreign_c_variadic_0(0);\n+    // CHECK: invoke void (i32, ...) @foreign_c_variadic_0(i32 0, i32 42)\n+    foreign_c_variadic_0(0, 42i32);\n+    // CHECK: invoke void (i32, ...) @foreign_c_variadic_0(i32 0, i32 42, i32 1024)\n+    foreign_c_variadic_0(0, 42i32, 1024i32);\n+    // CHECK: invoke void (i32, ...) @foreign_c_variadic_0(i32 0, i32 42, i32 1024, i32 0)\n+    foreign_c_variadic_0(0, 42i32, 1024i32, 0i32);\n+}\n+\n+// Ensure that we do not remove the `va_list` passed to the foreign function when\n+// removing the \"spoofed\" `VaList` that is used by Rust defined C-variadics.\n+pub unsafe extern \"C\" fn use_foreign_c_variadic_1_0(ap: VaList) {\n+    // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap)\n+    foreign_c_variadic_1(ap);\n+}\n+\n+pub unsafe extern \"C\" fn use_foreign_c_variadic_1_1(ap: VaList) {\n+    // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, i32 42)\n+    foreign_c_variadic_1(ap, 42i32);\n+}\n+pub unsafe extern \"C\" fn use_foreign_c_variadic_1_2(ap: VaList) {\n+    // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, i32 2, i32 42)\n+    foreign_c_variadic_1(ap, 2i32, 42i32);\n+}\n+\n+pub unsafe extern \"C\" fn use_foreign_c_variadic_1_3(ap: VaList) {\n+    // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, i32 2, i32 42, i32 0)\n+    foreign_c_variadic_1(ap, 2i32, 42i32, 0i32);\n+}\n+\n+// Ensure that `va_start` and `va_end` are properly injected.\n+#[no_mangle]\n+pub unsafe extern \"C\" fn c_variadic(n: i32, mut ap: ...) -> i32 {\n+    // CHECK: call void @llvm.va_start\n+    let mut sum = 0;\n+    for _ in 0..n {\n+        sum += ap.arg::<i32>();\n+    }\n+    sum\n+    // CHECK: call void @llvm.va_end\n+}\n+\n+// Ensure that we generate the correct `call` signature when calling a Rust\n+// defined C-variadic.\n+pub unsafe fn test_c_variadic_call() {\n+    // CHECK: call i32 (i32, ...) @c_variadic(i32 0)\n+    c_variadic(0);\n+    // CHECK: call i32 (i32, ...) @c_variadic(i32 0, i32 42)\n+    c_variadic(0, 42i32);\n+    // CHECK: call i32 (i32, ...) @c_variadic(i32 0, i32 42, i32 1024)\n+    c_variadic(0, 42i32, 1024i32);\n+    // CHECK: call i32 (i32, ...) @c_variadic(i32 0, i32 42, i32 1024, i32 0)\n+    c_variadic(0, 42i32, 1024i32, 0i32);\n+}"}, {"sha": "96a238afaec05039a5c515bd7b79cfa3317f0523", "filename": "src/test/run-make-fulldeps/c-link-to-rust-va-list-fn/checkrust.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Fcheckrust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Fcheckrust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Fcheckrust.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -18,8 +18,10 @@ macro_rules! continue_if {\n \n unsafe fn compare_c_str(ptr: *const c_char, val: &str) -> bool {\n     let cstr0 = CStr::from_ptr(ptr);\n-    let cstr1 = CString::new(val).unwrap();\n-    &*cstr1 == cstr0\n+    match CString::new(val) {\n+        Ok(cstr1) => &*cstr1 == cstr0,\n+        Err(_) => false,\n+    }\n }\n \n #[no_mangle]\n@@ -68,3 +70,24 @@ pub unsafe extern \"C\" fn check_list_copy_0(mut ap: VaList) -> usize {\n         }\n     })\n }\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn check_varargs_0(_: c_int, mut ap: ...) -> usize {\n+    continue_if!(ap.arg::<c_int>() == 42);\n+    continue_if!(compare_c_str(ap.arg::<*const c_char>(), \"Hello, World!\"));\n+    0\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn check_varargs_1(_: c_int, mut ap: ...) -> usize {\n+    continue_if!(ap.arg::<c_double>().floor() == 3.14f64.floor());\n+    continue_if!(ap.arg::<c_long>() == 12);\n+    continue_if!(ap.arg::<c_char>() == 'A' as c_char);\n+    continue_if!(ap.arg::<c_longlong>() == 1);\n+    0\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn check_varargs_2(_: c_int, mut ap: ...) -> usize {\n+    0\n+}"}, {"sha": "91b060dce26f436f6f9f5d21b7d038784dba115d", "filename": "src/test/run-make-fulldeps/c-link-to-rust-va-list-fn/test.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Ftest.c?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -8,6 +8,9 @@ extern size_t check_list_0(va_list ap);\n extern size_t check_list_1(va_list ap);\n extern size_t check_list_2(va_list ap);\n extern size_t check_list_copy_0(va_list ap);\n+extern size_t check_varargs_0(int fixed, ...);\n+extern size_t check_varargs_1(int fixed, ...);\n+extern size_t check_varargs_2(int fixed, ...);\n \n int test_rust(size_t (*fn)(va_list), ...) {\n     size_t ret = 0;\n@@ -26,5 +29,12 @@ int main(int argc, char* argv[]) {\n     assert(test_rust(check_list_2, 3.14, 12l, 'a', 6.28, \"Hello\", 42, \"World\") == 0);\n \n     assert(test_rust(check_list_copy_0, 6.28, 16, 'A', \"Skip Me!\", \"Correct\") == 0);\n+\n+    assert(check_varargs_0(0, 42, \"Hello, World!\") == 0);\n+\n+    assert(check_varargs_1(0, 3.14, 12l, 'A', 0x1LL) == 0);\n+\n+    assert(check_varargs_2(0, \"All\", \"of\", \"these\", \"are\", \"ignored\", \".\") == 0);\n+\n     return 0;\n }"}, {"sha": "80e0b0102af75f8ff8fd4af4eae9132ff3f75dcb", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -112,7 +112,7 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n                 let decl = P(FnDecl {\n                     inputs: vec![],\n                     output: FunctionRetTy::Default(DUMMY_SP),\n-                    variadic: false,\n+                    c_variadic: false,\n                 });\n                 iter_exprs(depth - 1, &mut |e| g(\n                         ExprKind::Closure(CaptureBy::Value,"}, {"sha": "5af2aea21fcacd94040f88f726176fedf46a66b4", "filename": "src/test/rustdoc/variadic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Frustdoc%2Fvariadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Frustdoc%2Fvariadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fvariadic.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1,4 +1,4 @@\n extern \"C\" {\n-    // @has variadic/fn.foo.html //pre 'pub unsafe extern \"C\" fn foo(x: i32, ...)'\n+    // @has variadic/fn.foo.html //pre 'pub unsafe extern \"C\" fn foo(x: i32, _: ...)'\n     pub fn foo(x: i32, ...);\n }"}, {"sha": "61b2ad4bed576338b2822c765885087de599aac5", "filename": "src/test/ui/c-variadic/variadic-ffi-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "previous_filename": "src/test/ui/variadic/variadic-ffi.rs"}, {"sha": "61d55ce0d3ef9055ac8f12c79386e13b36e2d7a3", "filename": "src/test/ui/c-variadic/variadic-ffi-1.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1,8 +1,8 @@\n-error[E0045]: variadic function must have C or cdecl calling convention\n-  --> $DIR/variadic-ffi.rs:5:5\n+error[E0045]: C-variadic function must have C or cdecl calling convention\n+  --> $DIR/variadic-ffi-1.rs:5:5\n    |\n LL |     fn printf(_: *const u8, ...); //~ ERROR: variadic function must have C or cdecl calling\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variadics require C or cdecl calling convention\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C-variadics require C or cdecl calling convention\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/variadic/variadic-ffi.stderr"}, {"sha": "224ac16f4586abefac49b224a727cf22f09a0faa", "filename": "src/test/ui/c-variadic/variadic-ffi-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-2.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "previous_filename": "src/test/ui/variadic/variadic-ffi-2.rs"}, {"sha": "4c8b8d2b2e1a960bf81069868517a72ac7f6cf67", "filename": "src/test/ui/c-variadic/variadic-ffi-2.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-2.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1,8 +1,8 @@\n-error[E0045]: variadic function must have C or cdecl calling convention\n+error[E0045]: C-variadic function must have C or cdecl calling convention\n   --> $DIR/variadic-ffi-2.rs:3:11\n    |\n LL | fn baz(f: extern \"stdcall\" fn(usize, ...)) {\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variadics require C or cdecl calling convention\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C-variadics require C or cdecl calling convention\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/variadic/variadic-ffi-2.stderr"}, {"sha": "c02d1f54e56492a3ca3c20dd4457f21e78dd73b3", "filename": "src/test/ui/c-variadic/variadic-ffi-3.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-3.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -14,12 +14,10 @@ fn main() {\n         let x: unsafe extern \"C\" fn(f: isize, x: u8) = foo;\n         //~^ ERROR: mismatched types\n         //~| expected type `unsafe extern \"C\" fn(isize, u8)`\n-        //~| found type `unsafe extern \"C\" fn(isize, u8, ...) {foo}`\n \n         let y: extern \"C\" fn(f: isize, x: u8, ...) = bar;\n         //~^ ERROR: mismatched types\n-        //~| expected type `extern \"C\" fn(isize, u8, ...)`\n-        //~| found type `extern \"C\" fn(isize, u8) {bar}`\n+        //~| expected type `for<'r> extern \"C\" fn(isize, u8, std::ffi::VaList<'r>, ...)`\n \n         foo(1, 2, 3f32); //~ ERROR can't pass `f32` to variadic function\n         foo(1, 2, true); //~ ERROR can't pass `bool` to variadic function", "previous_filename": "src/test/ui/variadic/variadic-ffi-3.rs"}, {"sha": "82e3c6cd06fc5218948ce34528ed5afd6ab3cad4", "filename": "src/test/ui/c-variadic/variadic-ffi-3.stderr", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-3.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -23,49 +23,49 @@ LL |         let x: unsafe extern \"C\" fn(f: isize, x: u8) = foo;\n    |                                                        ^^^ expected non-variadic fn, found variadic function\n    |\n    = note: expected type `unsafe extern \"C\" fn(isize, u8)`\n-              found type `unsafe extern \"C\" fn(isize, u8, ...) {foo}`\n+              found type `for<'r> unsafe extern \"C\" fn(isize, u8, std::ffi::VaList<'r>, ...) {foo}`\n \n error[E0308]: mismatched types\n-  --> $DIR/variadic-ffi-3.rs:19:54\n+  --> $DIR/variadic-ffi-3.rs:18:54\n    |\n LL |         let y: extern \"C\" fn(f: isize, x: u8, ...) = bar;\n    |                                                      ^^^ expected variadic fn, found non-variadic function\n    |\n-   = note: expected type `extern \"C\" fn(isize, u8, ...)`\n+   = note: expected type `for<'r> extern \"C\" fn(isize, u8, std::ffi::VaList<'r>, ...)`\n               found type `extern \"C\" fn(isize, u8) {bar}`\n \n error[E0617]: can't pass `f32` to variadic function\n-  --> $DIR/variadic-ffi-3.rs:24:19\n+  --> $DIR/variadic-ffi-3.rs:22:19\n    |\n LL |         foo(1, 2, 3f32); //~ ERROR can't pass `f32` to variadic function\n    |                   ^^^^ help: cast the value to `c_double`: `3f32 as c_double`\n \n error[E0617]: can't pass `bool` to variadic function\n-  --> $DIR/variadic-ffi-3.rs:25:19\n+  --> $DIR/variadic-ffi-3.rs:23:19\n    |\n LL |         foo(1, 2, true); //~ ERROR can't pass `bool` to variadic function\n    |                   ^^^^ help: cast the value to `c_int`: `true as c_int`\n \n error[E0617]: can't pass `i8` to variadic function\n-  --> $DIR/variadic-ffi-3.rs:26:19\n+  --> $DIR/variadic-ffi-3.rs:24:19\n    |\n LL |         foo(1, 2, 1i8); //~ ERROR can't pass `i8` to variadic function\n    |                   ^^^ help: cast the value to `c_int`: `1i8 as c_int`\n \n error[E0617]: can't pass `u8` to variadic function\n-  --> $DIR/variadic-ffi-3.rs:27:19\n+  --> $DIR/variadic-ffi-3.rs:25:19\n    |\n LL |         foo(1, 2, 1u8); //~ ERROR can't pass `u8` to variadic function\n    |                   ^^^ help: cast the value to `c_uint`: `1u8 as c_uint`\n \n error[E0617]: can't pass `i16` to variadic function\n-  --> $DIR/variadic-ffi-3.rs:28:19\n+  --> $DIR/variadic-ffi-3.rs:26:19\n    |\n LL |         foo(1, 2, 1i16); //~ ERROR can't pass `i16` to variadic function\n    |                   ^^^^ help: cast the value to `c_int`: `1i16 as c_int`\n \n error[E0617]: can't pass `u16` to variadic function\n-  --> $DIR/variadic-ffi-3.rs:29:19\n+  --> $DIR/variadic-ffi-3.rs:27:19\n    |\n LL |         foo(1, 2, 1u16); //~ ERROR can't pass `u16` to variadic function\n    |                   ^^^^ help: cast the value to `c_uint`: `1u16 as c_uint`", "previous_filename": "src/test/ui/variadic/variadic-ffi-3.stderr"}, {"sha": "9101be56456463361a4f6b6c5a19f413d8438e27", "filename": "src/test/ui/c-variadic/variadic-ffi-4.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -0,0 +1,29 @@\n+#![crate_type=\"lib\"]\n+#![no_std]\n+#![feature(c_variadic)]\n+\n+use core::ffi::VaList;\n+\n+pub unsafe extern \"C\" fn no_escape0<'a>(_: usize, ap: ...) -> VaList<'a> {\n+    ap //~ ERROR: explicit lifetime required\n+}\n+\n+pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaList<'static> {\n+    ap //~ ERROR: explicit lifetime required\n+}\n+\n+pub unsafe extern \"C\" fn no_escape2(_: usize, ap: ...) {\n+    let _ = ap.copy(|ap| { ap }); //~ ERROR: cannot infer an appropriate lifetime\n+}\n+\n+pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+    *ap0 = ap1; //~ ERROR: mismatched types\n+}\n+\n+pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+    ap0 = &mut ap1;\n+    //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+    //~^^ ERROR: mismatched types\n+    //~^^^ ERROR: mismatched types\n+    //~^^^^ ERROR: cannot infer an appropriate lifetime\n+}"}, {"sha": "1d752be065c4aad1ef5924df62a3244c71dc9987", "filename": "src/test/ui/c-variadic/variadic-ffi-4.stderr", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -0,0 +1,198 @@\n+error[E0621]: explicit lifetime required in the type of `ap`\n+  --> $DIR/variadic-ffi-4.rs:8:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape0<'a>(_: usize, ap: ...) -> VaList<'a> {\n+   |                                                       --- help: add explicit lifetime `'a` to the type of `ap`: `core::ffi::VaList<'a>`\n+LL |     ap //~ ERROR: explicit lifetime required\n+   |     ^^ lifetime `'a` required\n+\n+error[E0621]: explicit lifetime required in the type of `ap`\n+  --> $DIR/variadic-ffi-4.rs:12:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaList<'static> {\n+   |                                                   --- help: add explicit lifetime `'static` to the type of `ap`: `core::ffi::VaList<'static>`\n+LL |     ap //~ ERROR: explicit lifetime required\n+   |     ^^ lifetime `'static` required\n+\n+error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+  --> $DIR/variadic-ffi-4.rs:16:28\n+   |\n+LL |     let _ = ap.copy(|ap| { ap }); //~ ERROR: cannot infer an appropriate lifetime\n+   |                            ^^\n+   |\n+note: first, the lifetime cannot outlive the anonymous lifetime #2 defined on the body at 16:21...\n+  --> $DIR/variadic-ffi-4.rs:16:21\n+   |\n+LL |     let _ = ap.copy(|ap| { ap }); //~ ERROR: cannot infer an appropriate lifetime\n+   |                     ^^^^^^^^^^^\n+   = note: ...so that the expression is assignable:\n+           expected core::ffi::VaList<'_>\n+              found core::ffi::VaList<'_>\n+note: but, the lifetime must be valid for the method call at 16:13...\n+  --> $DIR/variadic-ffi-4.rs:16:13\n+   |\n+LL |     let _ = ap.copy(|ap| { ap }); //~ ERROR: cannot infer an appropriate lifetime\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+note: ...so type `core::ffi::VaList<'_>` of expression is valid during the expression\n+  --> $DIR/variadic-ffi-4.rs:16:13\n+   |\n+LL |     let _ = ap.copy(|ap| { ap }); //~ ERROR: cannot infer an appropriate lifetime\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/variadic-ffi-4.rs:20:12\n+   |\n+LL |     *ap0 = ap1; //~ ERROR: mismatched types\n+   |            ^^^ lifetime mismatch\n+   |\n+   = note: expected type `core::ffi::VaList<'_>`\n+              found type `core::ffi::VaList<'_>`\n+note: the anonymous lifetime #3 defined on the function body at 19:1...\n+  --> $DIR/variadic-ffi-4.rs:19:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+LL | |     *ap0 = ap1; //~ ERROR: mismatched types\n+LL | | }\n+   | |_^\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 19:1\n+  --> $DIR/variadic-ffi-4.rs:19:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+LL | |     *ap0 = ap1; //~ ERROR: mismatched types\n+LL | | }\n+   | |_^\n+\n+error[E0490]: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+  --> $DIR/variadic-ffi-4.rs:24:11\n+   |\n+LL |     ap0 = &mut ap1;\n+   |           ^^^^^^^^\n+   |\n+note: the type is valid for the anonymous lifetime #1 defined on the function body at 23:1\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+note: but the borrow lasts for the anonymous lifetime #3 defined on the function body at 23:1\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/variadic-ffi-4.rs:24:11\n+   |\n+LL |     ap0 = &mut ap1;\n+   |           ^^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected type `&mut core::ffi::VaList<'_>`\n+              found type `&mut core::ffi::VaList<'_>`\n+note: the anonymous lifetime #3 defined on the function body at 23:1...\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 23:1\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/variadic-ffi-4.rs:24:11\n+   |\n+LL |     ap0 = &mut ap1;\n+   |           ^^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected type `&mut core::ffi::VaList<'_>`\n+              found type `&mut core::ffi::VaList<'_>`\n+note: the anonymous lifetime #2 defined on the function body at 23:1...\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+note: ...does not necessarily outlive the anonymous lifetime #3 defined on the function body at 23:1\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+\n+error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements\n+  --> $DIR/variadic-ffi-4.rs:24:11\n+   |\n+LL |     ap0 = &mut ap1;\n+   |           ^^^^^^^^\n+   |\n+note: first, the lifetime cannot outlive the anonymous lifetime #3 defined on the function body at 23:1...\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+note: ...so that the type `core::ffi::VaList<'_>` is not borrowed for too long\n+  --> $DIR/variadic-ffi-4.rs:24:11\n+   |\n+LL |     ap0 = &mut ap1;\n+   |           ^^^^^^^^\n+note: but, the lifetime must be valid for the anonymous lifetime #1 defined on the function body at 23:1...\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/variadic-ffi-4.rs:24:11\n+   |\n+LL |     ap0 = &mut ap1;\n+   |           ^^^^^^^^\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors occurred: E0308, E0490, E0495, E0621.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "d96482ff4d17aa982052229bd788ea48cd5ddae6", "filename": "src/test/ui/c-variadic/variadic-ffi-5.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-5.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -0,0 +1,31 @@\n+#![crate_type=\"lib\"]\n+#![no_std]\n+#![feature(c_variadic)]\n+// The tests in this file are similar to that of variadic-ffi-4, but this\n+// one enables nll.\n+#![feature(nll)]\n+\n+use core::ffi::VaList;\n+\n+pub unsafe extern \"C\" fn no_escape0<'a>(_: usize, ap: ...) -> VaList<'a> {\n+    ap //~ ERROR: explicit lifetime required\n+}\n+\n+pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaList<'static> {\n+    ap //~ ERROR: explicit lifetime required\n+}\n+\n+pub unsafe extern \"C\" fn no_escape2(_: usize, ap: ...) {\n+    let _ = ap.copy(|ap| { ap }); //~ ERROR: lifetime may not live long enough\n+}\n+\n+pub unsafe extern \"C\" fn no_escape3(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+    *ap0 = ap1; //~ ERROR: lifetime may not live long enough\n+}\n+\n+pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+    ap0 = &mut ap1;\n+    //~^ ERROR: lifetime may not live long enough\n+    //~^^ ERROR: lifetime may not live long enough\n+    //~^^^ ERROR: `ap1` does not live long enough\n+}"}, {"sha": "2d452872baf4ecc06796ad37d0773a7fdfafca40", "filename": "src/test/ui/c-variadic/variadic-ffi-5.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-5.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -0,0 +1,73 @@\n+error[E0621]: explicit lifetime required in the type of `ap`\n+  --> $DIR/variadic-ffi-5.rs:11:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape0<'a>(_: usize, ap: ...) -> VaList<'a> {\n+   |                                                       --- help: add explicit lifetime `'a` to the type of `ap`: `core::ffi::VaList<'a>`\n+LL |     ap //~ ERROR: explicit lifetime required\n+   |     ^^ lifetime `'a` required\n+\n+error[E0621]: explicit lifetime required in the type of `ap`\n+  --> $DIR/variadic-ffi-5.rs:15:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaList<'static> {\n+   |                                                   --- help: add explicit lifetime `'static` to the type of `ap`: `core::ffi::VaList<'static>`\n+LL |     ap //~ ERROR: explicit lifetime required\n+   |     ^^ lifetime `'static` required\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-5.rs:19:28\n+   |\n+LL |     let _ = ap.copy(|ap| { ap }); //~ ERROR: lifetime may not live long enough\n+   |                      ---   ^^ returning this value requires that `'1` must outlive `'2`\n+   |                      | |\n+   |                      | return type of closure is core::ffi::VaList<'2>\n+   |                      has type `core::ffi::VaList<'1>`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-5.rs:23:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape3(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+   |                                               ---               ------- has type `core::ffi::VaList<'1>`\n+   |                                               |\n+   |                                               has type `&mut core::ffi::VaList<'2>`\n+LL |     *ap0 = ap1; //~ ERROR: lifetime may not live long enough\n+   |     ^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-5.rs:27:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+   |                                               -------               ------- has type `core::ffi::VaList<'2>`\n+   |                                               |\n+   |                                               has type `&mut core::ffi::VaList<'1>`\n+LL |     ap0 = &mut ap1;\n+   |     ^^^^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-5.rs:27:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+   |                                               -------               ------- has type `core::ffi::VaList<'1>`\n+   |                                               |\n+   |                                               has type `&mut core::ffi::VaList<'2>`\n+LL |     ap0 = &mut ap1;\n+   |     ^^^^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+\n+error[E0597]: `ap1` does not live long enough\n+  --> $DIR/variadic-ffi-5.rs:27:11\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+   |                                                        - let's call the lifetime of this reference `'1`\n+LL |     ap0 = &mut ap1;\n+   |     ------^^^^^^^^\n+   |     |     |\n+   |     |     borrowed value does not live long enough\n+   |     assignment requires that `ap1` is borrowed for `'1`\n+...\n+LL | }\n+   |  - `ap1` dropped here while still borrowed\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors occurred: E0597, E0621.\n+For more information about an error, try `rustc --explain E0597`."}, {"sha": "4dd8a2d452181eeaadccadf32590799ce627b972", "filename": "src/test/ui/c-variadic/variadic-ffi-6.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -0,0 +1,13 @@\n+#![crate_type=\"lib\"]\n+#![feature(c_variadic)]\n+\n+pub unsafe extern \"C\" fn use_vararg_lifetime(\n+    x: usize,\n+    y: ...\n+) -> &usize { //~ ERROR missing lifetime specifier\n+    &0\n+}\n+\n+pub unsafe extern \"C\" fn use_normal_arg_lifetime(x: &usize, y: ...) -> &usize { // OK\n+    x\n+}"}, {"sha": "76bd18959a51f730bbc36c1e7b6f10d6c10cb3be", "filename": "src/test/ui/c-variadic/variadic-ffi-6.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -0,0 +1,11 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/variadic-ffi-6.rs:7:6\n+   |\n+LL | ) -> &usize { //~ ERROR missing lifetime specifier\n+   |      ^ help: consider giving it an explicit bounded or 'static lifetime: `&'static`\n+   |\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "0ce91f0a401031b3a1591c7681f06883032cba83", "filename": "src/test/ui/error-codes/E0045.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Ferror-codes%2FE0045.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Ferror-codes%2FE0045.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0045.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1,8 +1,8 @@\n-error[E0045]: variadic function must have C or cdecl calling convention\n+error[E0045]: C-variadic function must have C or cdecl calling convention\n   --> $DIR/E0045.rs:1:17\n    |\n LL | extern \"Rust\" { fn foo(x: u8, ...); }   //~ ERROR E0045\n-   |                 ^^^^^^^^^^^^^^^^^^^ variadics require C or cdecl calling convention\n+   |                 ^^^^^^^^^^^^^^^^^^^ C-variadics require C or cdecl calling convention\n \n error: aborting due to previous error\n "}, {"sha": "51f13c7dbd5404e3670fb65327967bf2679e87e0", "filename": "src/test/ui/error-codes/E0617.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Ferror-codes%2FE0617.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Ferror-codes%2FE0617.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0617.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -22,7 +22,7 @@ fn main() {\n         //~^ ERROR can't pass `u16` to variadic function\n         //~| HELP cast the value to `c_uint`\n         printf(::std::ptr::null(), printf);\n-        //~^ ERROR can't pass `unsafe extern \"C\" fn(*const i8, ...) {printf}` to variadic function\n-        //~| HELP cast the value to `unsafe extern \"C\" fn(*const i8, ...)`\n+        //~^ ERROR can't pass `for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaList<'r>, ...) {printf}` to variadic function\n+        //~| HELP cast the value to `for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaList<'r>, ...)`\n     }\n }"}, {"sha": "8387d5c7e93a5fb05d2bdb0f16f69c873a972935", "filename": "src/test/ui/error-codes/E0617.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Ferror-codes%2FE0617.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Ferror-codes%2FE0617.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0617.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -28,15 +28,15 @@ error[E0617]: can't pass `u16` to variadic function\n LL |         printf(::std::ptr::null(), 0u16);\n    |                                    ^^^^ help: cast the value to `c_uint`: `0u16 as c_uint`\n \n-error[E0617]: can't pass `unsafe extern \"C\" fn(*const i8, ...) {printf}` to variadic function\n+error[E0617]: can't pass `for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaList<'r>, ...) {printf}` to variadic function\n   --> $DIR/E0617.rs:24:36\n    |\n LL |         printf(::std::ptr::null(), printf);\n    |                                    ^^^^^^\n-help: cast the value to `unsafe extern \"C\" fn(*const i8, ...)`\n+help: cast the value to `for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaList<'r>, ...)`\n    |\n-LL |         printf(::std::ptr::null(), printf as unsafe extern \"C\" fn(*const i8, ...));\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         printf(::std::ptr::null(), printf as for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaList<'r>, ...));\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "5801a2a89e2c18c80f4e54fc8cb75656a1a3aff4", "filename": "src/test/ui/feature-gate/feature-gate-c_variadic.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-c_variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-c_variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-c_variadic.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -0,0 +1,4 @@\n+#![crate_type=\"lib\"]\n+\n+pub unsafe extern \"C\" fn test(_: i32, ap: ...) { }\n+//~^ C-varaidic functions are unstable"}, {"sha": "a876e16fdea41665142764bff28dc4a254a91aa2", "filename": "src/test/ui/feature-gate/feature-gate-c_variadic.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-c_variadic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-c_variadic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-c_variadic.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: C-varaidic functions are unstable (see issue #44930)\n+  --> $DIR/feature-gate-c_variadic.rs:3:1\n+   |\n+LL | pub unsafe extern \"C\" fn test(_: i32, ap: ...) { }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(c_variadic)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "8d23f0e477077676cb2e2b4773f8d8a98bc5d22a", "filename": "src/test/ui/invalid/invalid-variadic-function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1,3 +1,3 @@\n extern \"C\" fn foo(x: u8, ...);\n-//~^ ERROR only foreign functions are allowed to be variadic\n+//~^ ERROR only foreign functions are allowed to be C-variadic\n //~| ERROR expected one of `->`, `where`, or `{`, found `;`"}, {"sha": "b2dbf8b9190848ef69c0886ebb9becb71be116b7", "filename": "src/test/ui/invalid/invalid-variadic-function.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1,4 +1,4 @@\n-error: only foreign functions are allowed to be variadic\n+error: only foreign functions are allowed to be C-variadic\n   --> $DIR/invalid-variadic-function.rs:1:26\n    |\n LL | extern \"C\" fn foo(x: u8, ...);"}, {"sha": "b308e644ad9f89dc743cd8a58e5d34f2ce6198b1", "filename": "src/test/ui/parser/recover-enum2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fparser%2Frecover-enum2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fparser%2Frecover-enum2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-enum2.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -10,11 +10,11 @@ error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `{`\n LL |             Nope(i32 {}) //~ ERROR: found `{`\n    |                      ^ expected one of 7 possible tokens here\n \n-error: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `+`, `,`, `::`, `<`, `?`, `[`, `_`, `crate`, `dyn`, `extern`, `fn`, `for`, `impl`, `pub`, `unsafe`, `}`, or lifetime, found `{`\n+error: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `+`, `,`, `...`, `::`, `<`, `?`, `[`, `_`, `crate`, `dyn`, `extern`, `fn`, `for`, `impl`, `pub`, `unsafe`, `}`, or lifetime, found `{`\n   --> $DIR/recover-enum2.rs:27:22\n    |\n LL |             Nope(i32 {}) //~ ERROR: found `{`\n-   |                      ^ expected one of 23 possible tokens here\n+   |                      ^ expected one of 24 possible tokens here\n \n error: expected expression, found reserved identifier `_`\n   --> $DIR/recover-enum2.rs:32:22"}, {"sha": "ce83cc87abe00f937b45e97d4d4c60a6a29a62d3", "filename": "src/test/ui/parser/variadic-ffi-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1,5 +1,5 @@\n fn foo(x: isize, ...) {\n-    //~^ ERROR: only foreign functions are allowed to be variadic\n+    //~^ ERROR: only foreign functions are allowed to be C-variadic\n }\n \n fn main() {}"}, {"sha": "8ea4d194396faa0082cd2598cab38d97d9e46829", "filename": "src/test/ui/parser/variadic-ffi-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1,4 +1,4 @@\n-error: only foreign functions are allowed to be variadic\n+error: only foreign functions are allowed to be C-variadic\n   --> $DIR/variadic-ffi-3.rs:1:18\n    |\n LL | fn foo(x: isize, ...) {"}, {"sha": "5f8b3f8f539b8df463f457d8ae7ac8724bdc84ed", "filename": "src/test/ui/parser/variadic-ffi-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1,5 +1,5 @@\n extern \"C\" fn foo(x: isize, ...) {\n-    //~^ ERROR: only foreign functions are allowed to be variadic\n+    //~^ ERROR: only foreign functions are allowed to be C-variadic\n }\n \n fn main() {}"}, {"sha": "69fbf84869c13bf7ad809dc6ab54f6c0bc21fae4", "filename": "src/test/ui/parser/variadic-ffi-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.stderr?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -1,4 +1,4 @@\n-error: only foreign functions are allowed to be variadic\n+error: only foreign functions are allowed to be C-variadic\n   --> $DIR/variadic-ffi-4.rs:1:29\n    |\n LL | extern \"C\" fn foo(x: isize, ...) {"}, {"sha": "cd60f36b1d273a012eb1b2611ec5d7ccd5c74271", "filename": "src/tools/tidy/src/unstable_book.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1999a2288123173b2e487865c9a04386173025f7/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999a2288123173b2e487865c9a04386173025f7/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs?ref=1999a2288123173b2e487865c9a04386173025f7", "patch": "@@ -82,25 +82,27 @@ pub fn check(path: &path::Path, bad: &mut bool) {\n         !lang_features.contains_key(name)\n     }).collect();\n \n+    // Library features\n     let unstable_lib_feature_names = collect_unstable_feature_names(&lib_features);\n     let unstable_book_lib_features_section_file_names =\n         collect_unstable_book_lib_features_section_file_names(path);\n \n-    // Check for Unstable Book sections that don't have a corresponding unstable feature\n-    for feature_name in &unstable_book_lib_features_section_file_names -\n-                        &unstable_lib_feature_names {\n-        tidy_error!(bad,\n-                    \"The Unstable Book has a 'library feature' section '{}' which doesn't \\\n-                     correspond to an unstable library feature\",\n-                    feature_name)\n-    }\n-\n     // Language features\n-\n     let unstable_lang_feature_names = collect_unstable_feature_names(&lang_features);\n     let unstable_book_lang_features_section_file_names =\n         collect_unstable_book_lang_features_section_file_names(path);\n \n+    // Check for Unstable Book sections that don't have a corresponding unstable feature\n+    for feature_name in &unstable_book_lib_features_section_file_names -\n+                        &unstable_lib_feature_names {\n+        if !unstable_lang_feature_names.contains(&feature_name) {\n+            tidy_error!(bad,\n+                        \"The Unstable Book has a 'library feature' section '{}' which doesn't \\\n+                         correspond to an unstable library feature\",\n+                        feature_name);\n+        }\n+    }\n+\n     // Check for Unstable Book sections that don't have a corresponding unstable feature.\n     for feature_name in &unstable_book_lang_features_section_file_names -\n                         &unstable_lang_feature_names {"}]}