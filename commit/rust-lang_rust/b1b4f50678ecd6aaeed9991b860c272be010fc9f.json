{"sha": "b1b4f50678ecd6aaeed9991b860c272be010fc9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYjRmNTA2NzhlY2Q2YWFlZWQ5OTkxYjg2MGMyNzJiZTAxMGZjOWY=", "commit": {"author": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-01-28T05:25:43Z"}, "committer": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-02-27T07:01:41Z"}, "message": "add StepBy for RangeInclusive", "tree": {"sha": "cdeb33a16e24501d7cfd1a27cd67ef0796965701", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdeb33a16e24501d7cfd1a27cd67ef0796965701"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1b4f50678ecd6aaeed9991b860c272be010fc9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1b4f50678ecd6aaeed9991b860c272be010fc9f", "html_url": "https://github.com/rust-lang/rust/commit/b1b4f50678ecd6aaeed9991b860c272be010fc9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1b4f50678ecd6aaeed9991b860c272be010fc9f/comments", "author": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "committer": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24cc90262bd5ec52aa421103ef7c89a0697b046d", "url": "https://api.github.com/repos/rust-lang/rust/commits/24cc90262bd5ec52aa421103ef7c89a0697b046d", "html_url": "https://github.com/rust-lang/rust/commit/24cc90262bd5ec52aa421103ef7c89a0697b046d"}], "stats": {"total": 116, "additions": 109, "deletions": 7}, "files": [{"sha": "8cea98d2a21f1b7b6279cd51cb0b865d99f0b6b4", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 108, "deletions": 4, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/b1b4f50678ecd6aaeed9991b860c272be010fc9f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b4f50678ecd6aaeed9991b860c272be010fc9f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=b1b4f50678ecd6aaeed9991b860c272be010fc9f", "patch": "@@ -306,7 +306,7 @@ use default::Default;\n use marker;\n use mem;\n use num::{Zero, One};\n-use ops::{self, Add, Sub, FnMut, Mul, RangeFrom};\n+use ops::{self, Add, Sub, FnMut, Mul};\n use option::Option::{self, Some, None};\n use marker::Sized;\n use usize;\n@@ -4286,7 +4286,7 @@ step_impl_no_between!(u64 i64);\n ///\n /// The resulting iterator handles overflow by stopping. The `A`\n /// parameter is the type being iterated over, while `R` is the range\n-/// type (usually one of `std::ops::{Range, RangeFrom}`.\n+/// type (usually one of `std::ops::{Range, RangeFrom, RangeInclusive}`.\n #[derive(Clone)]\n #[unstable(feature = \"step_by\", reason = \"recent addition\",\n            issue = \"27741\")]\n@@ -4295,7 +4295,7 @@ pub struct StepBy<A, R> {\n     range: R,\n }\n \n-impl<A: Step> RangeFrom<A> {\n+impl<A: Step> ops::RangeFrom<A> {\n     /// Creates an iterator starting at the same point, but stepping by\n     /// the given amount at each iteration.\n     ///\n@@ -4355,8 +4355,44 @@ impl<A: Step> ops::Range<A> {\n     }\n }\n \n+impl<A: Step> ops::RangeInclusive<A> {\n+    /// Creates an iterator with the same range, but stepping by the\n+    /// given amount at each iteration.\n+    ///\n+    /// The resulting iterator handles overflow by stopping.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(step_by, inclusive_range_syntax)]\n+    ///\n+    /// for i in (0...10).step_by(2) {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// 0\n+    /// 2\n+    /// 4\n+    /// 6\n+    /// 8\n+    /// 10\n+    /// ```\n+    #[unstable(feature = \"step_by\", reason = \"recent addition\",\n+               issue = \"27741\")]\n+    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n+        StepBy {\n+            step_by: by,\n+            range: self\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Iterator for StepBy<A, RangeFrom<A>> where\n+impl<A> Iterator for StepBy<A, ops::RangeFrom<A>> where\n     A: Clone,\n     for<'a> &'a A: Add<&'a A, Output = A>\n {\n@@ -4412,6 +4448,74 @@ impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n     }\n }\n \n+#[unstable(feature = \"inclusive_range\",\n+           reason = \"recently added, follows RFC\",\n+           issue = \"28237\")]\n+impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        use ops::RangeInclusive::*;\n+\n+        // this function has a sort of odd structure due to borrowck issues\n+        // we may need to replace self.range, so borrows of start and end need to end early\n+\n+        let (finishing, n) = match self.range {\n+            Empty { .. } => return None, // empty iterators yield no values\n+\n+            NonEmpty { ref mut start, ref mut end } => {\n+                let zero = A::zero();\n+                let rev = self.step_by < zero;\n+\n+                // march start towards (maybe past!) end and yield the old value\n+                if (rev && start >= end) ||\n+                   (!rev && start <= end)\n+                {\n+                    match start.step(&self.step_by) {\n+                        Some(mut n) => {\n+                            mem::swap(start, &mut n);\n+                            (None, Some(n)) // yield old value, remain non-empty\n+                        },\n+                        None => {\n+                            let mut n = end.clone();\n+                            mem::swap(start, &mut n);\n+                            (None, Some(n)) // yield old value, remain non-empty\n+                        }\n+                    }\n+                } else {\n+                    // found range in inconsistent state (start at or past end), so become empty\n+                    (Some(mem::replace(end, zero)), None)\n+                }\n+            }\n+        };\n+\n+        // turn into an empty iterator if we've reached the end\n+        if let Some(end) = finishing {\n+            self.range = Empty { at: end };\n+        }\n+\n+        n\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        use ops::RangeInclusive::*;\n+\n+        match self.range {\n+            Empty { .. } => (0, Some(0)),\n+\n+            NonEmpty { ref start, ref end } =>\n+                match Step::steps_between(start,\n+                                          end,\n+                                          &self.step_by) {\n+                    Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n+                    None       => (0, None)\n+                }\n+        }\n+    }\n+}\n+\n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "c1bc6adf7b8a47a78c4a69dca4bcdd5f1693edd4", "filename": "src/test/run-pass/range_inclusive.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1b4f50678ecd6aaeed9991b860c272be010fc9f/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b4f50678ecd6aaeed9991b860c272be010fc9f/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange_inclusive.rs?ref=b1b4f50678ecd6aaeed9991b860c272be010fc9f", "patch": "@@ -10,7 +10,7 @@\n \n // Test inclusive range syntax.\n \n-#![feature(inclusive_range_syntax, inclusive_range)]\n+#![feature(inclusive_range_syntax, inclusive_range, step_by)]\n \n use std::ops::{RangeInclusive, RangeToInclusive};\n \n@@ -35,14 +35,12 @@ pub fn main() {\n     }\n     assert_eq!(count, 55);\n \n-    /* FIXME\n     let mut count = 0;\n     for i in (0_usize...10).step_by(2) {\n         assert!(i >= 0 && i <= 10 && i % 2 == 0);\n         count += i;\n     }\n     assert_eq!(count, 30);\n-    */\n \n     let _ = 0_usize...4+4-3;\n     let _ = 0...foo();"}]}