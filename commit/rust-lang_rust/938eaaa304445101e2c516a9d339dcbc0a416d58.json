{"sha": "938eaaa304445101e2c516a9d339dcbc0a416d58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzOGVhYWEzMDQ0NDUxMDFlMmM1MTZhOWQzMzlkY2JjMGE0MTZkNTg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T00:03:02Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T16:20:12Z"}, "message": "rustc: de-@ adt::Repr.", "tree": {"sha": "109c3186caabc8ad38198fb1dc2131342e251586", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/109c3186caabc8ad38198fb1dc2131342e251586"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/938eaaa304445101e2c516a9d339dcbc0a416d58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/938eaaa304445101e2c516a9d339dcbc0a416d58", "html_url": "https://github.com/rust-lang/rust/commit/938eaaa304445101e2c516a9d339dcbc0a416d58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/938eaaa304445101e2c516a9d339dcbc0a416d58/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "344ce1703616dc329dc11f827d91f71ca25205fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/344ce1703616dc329dc11f827d91f71ca25205fc", "html_url": "https://github.com/rust-lang/rust/commit/344ce1703616dc329dc11f827d91f71ca25205fc"}], "stats": {"total": 120, "additions": 61, "deletions": 59}, "files": [{"sha": "55f8b3d1fd22772a5e1800ca488f4a642147bcbc", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=938eaaa304445101e2c516a9d339dcbc0a416d58", "patch": "@@ -225,6 +225,7 @@ use util::ppaux::{Repr, vec_map_to_str};\n \n use collections::HashMap;\n use std::cell::Cell;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::ast::Ident;\n use syntax::ast_util::path_to_ident;\n@@ -250,7 +251,7 @@ pub enum VecLenOpt {\n // range)\n enum Opt {\n     lit(Lit),\n-    var(ty::Disr, @adt::Repr),\n+    var(ty::Disr, Rc<adt::Repr>),\n     range(@ast::Expr, @ast::Expr),\n     vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n@@ -351,8 +352,8 @@ fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n             let (llval, _) = consts::get_const_val(bcx.ccx(), lit_id);\n             return single_result(rslt(bcx, llval));\n         }\n-        var(disr_val, repr) => {\n-            return adt::trans_case(bcx, repr, disr_val);\n+        var(disr_val, ref repr) => {\n+            return adt::trans_case(bcx, &**repr, disr_val);\n         }\n         range(l1, l2) => {\n             let (l1, _) = consts::const_expr(ccx, l1, true);\n@@ -1561,7 +1562,7 @@ fn compile_submatch_continue<'a, 'b>(\n             expr::with_field_tys(tcx, pat_ty, Some(pat_id), |discr, field_tys| {\n                 let rec_vals = rec_fields.iter().map(|field_name| {\n                         let ix = ty::field_idx_strict(tcx, field_name.name, field_tys);\n-                        adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n+                        adt::trans_field_ptr(bcx, &*pat_repr, val, discr, ix)\n                         }).collect::<Vec<_>>();\n                 compile_submatch(\n                         bcx,\n@@ -1587,7 +1588,7 @@ fn compile_submatch_continue<'a, 'b>(\n           _ => ccx.sess().bug(\"non-tuple type in tuple pattern\")\n         };\n         let tup_vals = Vec::from_fn(n_tup_elts, |i| {\n-            adt::trans_field_ptr(bcx, tup_repr, val, 0, i)\n+            adt::trans_field_ptr(bcx, &*tup_repr, val, 0, i)\n         });\n         compile_submatch(bcx,\n                          enter_tup(bcx,\n@@ -1616,7 +1617,7 @@ fn compile_submatch_continue<'a, 'b>(\n \n         let struct_repr = adt::represent_type(bcx.ccx(), struct_ty);\n         let llstructvals = Vec::from_fn(struct_element_count, |i| {\n-            adt::trans_field_ptr(bcx, struct_repr, val, 0, i)\n+            adt::trans_field_ptr(bcx, &*struct_repr, val, 0, i)\n         });\n         compile_submatch(bcx,\n                          enter_tuple_struct(bcx, dm, m, col, val,\n@@ -1652,8 +1653,8 @@ fn compile_submatch_continue<'a, 'b>(\n     debug!(\"test_val={}\", bcx.val_to_str(test_val));\n     if opts.len() > 0u {\n         match *opts.get(0) {\n-            var(_, repr) => {\n-                let (the_kind, val_opt) = adt::trans_switch(bcx, repr, val);\n+            var(_, ref repr) => {\n+                let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val);\n                 kind = the_kind;\n                 for &tval in val_opt.iter() { test_val = tval; }\n             }\n@@ -1799,9 +1800,9 @@ fn compile_submatch_continue<'a, 'b>(\n         let mut size = 0u;\n         let mut unpacked = Vec::new();\n         match *opt {\n-            var(disr_val, repr) => {\n+            var(disr_val, ref repr) => {\n                 let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n-                    extract_variant_args(opt_cx, repr, disr_val, val);\n+                    extract_variant_args(opt_cx, &**repr, disr_val, val);\n                 size = argvals.len();\n                 unpacked = argvals;\n                 opt_cx = new_bcx;\n@@ -2219,7 +2220,7 @@ fn bind_irrefutable_pat<'a>(\n                                                          enum_id,\n                                                          var_id);\n                     let args = extract_variant_args(bcx,\n-                                                    repr,\n+                                                    &*repr,\n                                                     vinfo.disr_val,\n                                                     val);\n                     for sub_pat in sub_pats.iter() {\n@@ -2240,7 +2241,7 @@ fn bind_irrefutable_pat<'a>(\n                             // This is the tuple struct case.\n                             let repr = adt::represent_node(bcx, pat.id);\n                             for (i, elem) in elems.iter().enumerate() {\n-                                let fldptr = adt::trans_field_ptr(bcx, repr,\n+                                let fldptr = adt::trans_field_ptr(bcx, &*repr,\n                                                                   val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx, *elem,\n                                                            fldptr, binding_mode,\n@@ -2263,7 +2264,7 @@ fn bind_irrefutable_pat<'a>(\n             expr::with_field_tys(tcx, pat_ty, Some(pat.id), |discr, field_tys| {\n                 for f in fields.iter() {\n                     let ix = ty::field_idx_strict(tcx, f.ident.name, field_tys);\n-                    let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n+                    let fldptr = adt::trans_field_ptr(bcx, &*pat_repr, val,\n                                                       discr, ix);\n                     bcx = bind_irrefutable_pat(bcx, f.pat, fldptr,\n                                                binding_mode, cleanup_scope);\n@@ -2273,7 +2274,7 @@ fn bind_irrefutable_pat<'a>(\n         ast::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             for (i, elem) in elems.iter().enumerate() {\n-                let fldptr = adt::trans_field_ptr(bcx, repr, val, 0, i);\n+                let fldptr = adt::trans_field_ptr(bcx, &*repr, val, 0, i);\n                 bcx = bind_irrefutable_pat(bcx, *elem, fldptr,\n                                            binding_mode, cleanup_scope);\n             }"}, {"sha": "fbd638b6191f6c9f3dbeaaf4bd8d6dd998fd7620", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=938eaaa304445101e2c516a9d339dcbc0a416d58", "patch": "@@ -45,8 +45,8 @@\n \n use std::container::Map;\n use libc::c_ulonglong;\n-use std::option::{Option, Some, None};\n use std::num::{Bitwise};\n+use std::rc::Rc;\n \n use lib::llvm::{ValueRef, True, IntEQ, IntNE};\n use middle::trans::_match;\n@@ -115,22 +115,22 @@ pub struct Struct {\n  * these, for places in trans where the `ty::t` isn't directly\n  * available.\n  */\n-pub fn represent_node(bcx: &Block, node: ast::NodeId) -> @Repr {\n+pub fn represent_node(bcx: &Block, node: ast::NodeId) -> Rc<Repr> {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n /// Decides how to represent a given type.\n-pub fn represent_type(cx: &CrateContext, t: ty::t) -> @Repr {\n+pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n     debug!(\"Representing: {}\", ty_to_str(cx.tcx(), t));\n     match cx.adt_reprs.borrow().find(&t) {\n-        Some(repr) => return *repr,\n+        Some(repr) => return repr.clone(),\n         None => {}\n     }\n \n-    let repr = @represent_type_uncached(cx, t);\n+    let repr = Rc::new(represent_type_uncached(cx, t));\n     debug!(\"Represented as: {:?}\", repr)\n-    cx.adt_reprs.borrow_mut().insert(t, repr);\n-    return repr;\n+    cx.adt_reprs.borrow_mut().insert(t, repr.clone());\n+    repr\n }\n \n fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {"}, {"sha": "4fe26ea0b94acf64a5661e8b36a8176eabbb80f3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=938eaaa304445101e2c516a9d339dcbc0a416d58", "patch": "@@ -660,7 +660,7 @@ pub fn iter_structural_ty<'r,\n           let repr = adt::represent_type(cx.ccx(), t);\n           expr::with_field_tys(cx.tcx(), t, None, |discr, field_tys| {\n               for (i, field_ty) in field_tys.iter().enumerate() {\n-                  let llfld_a = adt::trans_field_ptr(cx, repr, av, discr, i);\n+                  let llfld_a = adt::trans_field_ptr(cx, &*repr, av, discr, i);\n                   cx = f(cx, llfld_a, field_ty.mt.ty);\n               }\n           })\n@@ -678,7 +678,7 @@ pub fn iter_structural_ty<'r,\n       ty::ty_tup(ref args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           for (i, arg) in args.iter().enumerate() {\n-              let llfld_a = adt::trans_field_ptr(cx, repr, av, 0, i);\n+              let llfld_a = adt::trans_field_ptr(cx, &*repr, av, 0, i);\n               cx = f(cx, llfld_a, *arg);\n           }\n       }\n@@ -693,9 +693,9 @@ pub fn iter_structural_ty<'r,\n           // NB: we must hit the discriminant first so that structural\n           // comparison know not to proceed when the discriminants differ.\n \n-          match adt::trans_switch(cx, repr, av) {\n+          match adt::trans_switch(cx, &*repr, av) {\n               (_match::single, None) => {\n-                  cx = iter_variant(cx, repr, av, &**variants.get(0),\n+                  cx = iter_variant(cx, &*repr, av, &**variants.get(0),\n                                     substs.tps.as_slice(), f);\n               }\n               (_match::switch, Some(lldiscrim_a)) => {\n@@ -710,7 +710,7 @@ pub fn iter_structural_ty<'r,\n                       let variant_cx =\n                           fcx.new_temp_block(\"enum-iter-variant-\".to_owned() +\n                                              variant.disr_val.to_str());\n-                      match adt::trans_case(cx, repr, variant.disr_val) {\n+                      match adt::trans_case(cx, &*repr, variant.disr_val) {\n                           _match::single_result(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n                           }\n@@ -719,7 +719,7 @@ pub fn iter_structural_ty<'r,\n                       }\n                       let variant_cx =\n                           iter_variant(variant_cx,\n-                                       repr,\n+                                       &*repr,\n                                        av,\n                                        &**variant,\n                                        substs.tps.as_slice(),\n@@ -1512,10 +1512,10 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n \n     if !type_is_zero_size(fcx.ccx, result_ty) {\n         let repr = adt::represent_type(ccx, result_ty);\n-        adt::trans_start_init(bcx, repr, fcx.llretptr.get().unwrap(), disr);\n+        adt::trans_start_init(bcx, &*repr, fcx.llretptr.get().unwrap(), disr);\n         for (i, arg_datum) in arg_datums.move_iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(bcx,\n-                                                 repr,\n+                                                 &*repr,\n                                                  fcx.llretptr.get().unwrap(),\n                                                  disr,\n                                                  i);"}, {"sha": "759e48e633f062ff19f17d160e2bce7b15fb4828", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=938eaaa304445101e2c516a9d339dcbc0a416d58", "patch": "@@ -130,7 +130,7 @@ fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n fn const_deref_newtype(cx: &CrateContext, v: ValueRef, t: ty::t)\n     -> ValueRef {\n     let repr = adt::represent_type(cx, t);\n-    adt::const_get_field(cx, repr, v, 0, 0)\n+    adt::const_get_field(cx, &*repr, v, 0, 0)\n }\n \n fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n@@ -418,7 +418,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.name, field_tys);\n-                  (adt::const_get_field(cx, brepr, bv, discr, ix), inlineable)\n+                  (adt::const_get_field(cx, &*brepr, bv, discr, ix), inlineable)\n               })\n           }\n \n@@ -491,7 +491,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               (expr::cast_enum, expr::cast_integral) |\n               (expr::cast_enum, expr::cast_float)  => {\n                 let repr = adt::represent_type(cx, basety);\n-                let discr = adt::const_get_discrim(cx, repr, v);\n+                let discr = adt::const_get_discrim(cx, &*repr, v);\n                 let iv = C_integral(cx.int_type, discr, false);\n                 let ety_cast = expr::cast_type_kind(ety);\n                 match ety_cast {\n@@ -524,7 +524,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n               let (vals, inlineable) = map_list(es.as_slice());\n-              (adt::trans_const(cx, repr, 0, vals.as_slice()), inlineable)\n+              (adt::trans_const(cx, &*repr, 0, vals.as_slice()), inlineable)\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n@@ -544,15 +544,15 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                           None => {\n                               match base_val {\n                                 Some((bv, inlineable)) => {\n-                                    (adt::const_get_field(cx, repr, bv, discr, ix),\n+                                    (adt::const_get_field(cx, &*repr, bv, discr, ix),\n                                      inlineable)\n                                 }\n                                 None => cx.sess().span_bug(e.span, \"missing struct field\")\n                               }\n                           }\n                       }\n                   }));\n-                  (adt::trans_const(cx, repr, discr, cs),\n+                  (adt::trans_const(cx, &*repr, discr, cs),\n                    inlineable.iter().fold(true, |a, &b| a && b))\n               })\n           }\n@@ -632,7 +632,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                     let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n-                    (adt::trans_const(cx, repr, vinfo.disr_val, []), true)\n+                    (adt::trans_const(cx, &*repr, vinfo.disr_val, []), true)\n                 }\n                 Some(ast::DefStruct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx(), e);\n@@ -651,7 +651,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n-                      (adt::trans_const(cx, repr, 0, arg_vals.as_slice()),\n+                      (adt::trans_const(cx, &*repr, 0, arg_vals.as_slice()),\n                        inlineable)\n                   }\n                   Some(ast::DefVariant(enum_did, variant_did, _)) => {\n@@ -662,7 +662,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                                                            variant_did);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n                       (adt::trans_const(cx,\n-                                        repr,\n+                                        &*repr,\n                                         vinfo.disr_val,\n                                         arg_vals.as_slice()), inlineable)\n                   }"}, {"sha": "ebbb3d06bc44e86db665cee3742515ba38e4ff0e", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=938eaaa304445101e2c516a9d339dcbc0a416d58", "patch": "@@ -31,6 +31,7 @@ use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n use std::cell::{Cell, RefCell};\n use std::c_str::ToCStr;\n use std::ptr;\n+use std::rc::Rc;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -92,7 +93,7 @@ pub struct CrateContext {\n \n     pub lltypes: RefCell<HashMap<ty::t, Type>>,\n     pub llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n-    pub adt_reprs: RefCell<HashMap<ty::t, @adt::Repr>>,\n+    pub adt_reprs: RefCell<HashMap<ty::t, Rc<adt::Repr>>>,\n     pub symbol_hasher: RefCell<Sha256>,\n     pub type_hashcodes: RefCell<HashMap<ty::t, ~str>>,\n     pub all_llvm_symbols: RefCell<HashSet<~str>>,"}, {"sha": "4dd929e16f7252f9531151fa732ea3197e937bad", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=938eaaa304445101e2c516a9d339dcbc0a416d58", "patch": "@@ -1389,7 +1389,7 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n }\n \n struct GeneralMemberDescriptionFactory {\n-    type_rep: @adt::Repr,\n+    type_rep: Rc<adt::Repr>,\n     variants: Rc<Vec<Rc<ty::VariantInfo>>>,\n     discriminant_type_metadata: ValueRef,\n     containing_scope: DIScope,\n@@ -1662,7 +1662,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                 llvm_type: enum_llvm_type,\n                 file_metadata: file_metadata,\n                 member_description_factory: GeneralMD(GeneralMemberDescriptionFactory {\n-                    type_rep: type_rep,\n+                    type_rep: type_rep.clone(),\n                     variants: variants,\n                     discriminant_type_metadata: discriminant_type_metadata,\n                     containing_scope: containing_scope,"}, {"sha": "3c1dfedcac6162bdd91cd8f9f46790294ae24ba9", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=938eaaa304445101e2c516a9d339dcbc0a416d58", "patch": "@@ -443,7 +443,7 @@ fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n             let ix = ty::field_idx_strict(bcx.tcx(), field.name, field_tys);\n             let d = base_datum.get_element(\n                 field_tys[ix].mt.ty,\n-                |srcval| adt::trans_field_ptr(bcx, repr, srcval, discr, ix));\n+                |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, ix));\n             DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n         })\n }\n@@ -679,7 +679,7 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n             let numbered_fields: Vec<(uint, @ast::Expr)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n-            trans_adt(bcx, repr, 0, numbered_fields.as_slice(), None, dest)\n+            trans_adt(bcx, &*repr, 0, numbered_fields.as_slice(), None, dest)\n         }\n         ast::ExprLit(lit) => {\n             match lit.node {\n@@ -797,7 +797,7 @@ fn trans_def_dps_unadjusted<'a>(\n                 // Nullary variant.\n                 let ty = expr_ty(bcx, ref_expr);\n                 let repr = adt::represent_type(bcx.ccx(), ty);\n-                adt::trans_start_init(bcx, repr, lldest,\n+                adt::trans_start_init(bcx, &*repr, lldest,\n                                       variant_info.disr_val);\n                 return bcx;\n             }\n@@ -807,7 +807,7 @@ fn trans_def_dps_unadjusted<'a>(\n             match ty::get(ty).sty {\n                 ty::ty_struct(did, _) if ty::has_dtor(bcx.tcx(), did) => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n-                    adt::trans_start_init(bcx, repr, lldest, 0);\n+                    adt::trans_start_init(bcx, &*repr, lldest, 0);\n                 }\n                 _ => {}\n             }\n@@ -1004,7 +1004,7 @@ fn trans_rec_or_struct<'a>(\n         };\n \n         let repr = adt::represent_type(bcx.ccx(), ty);\n-        trans_adt(bcx, repr, discr, numbered_fields.as_slice(), optbase, dest)\n+        trans_adt(bcx, &*repr, discr, numbered_fields.as_slice(), optbase, dest)\n     })\n }\n \n@@ -1239,8 +1239,8 @@ fn trans_gc<'a>(mut bcx: &'a Block<'a>,\n         SaveIn(addr) => {\n             let expr_ty = expr_ty(bcx, expr);\n             let repr = adt::represent_type(bcx.ccx(), expr_ty);\n-            adt::trans_start_init(bcx, repr, addr, 0);\n-            let field_dest = adt::trans_field_ptr(bcx, repr, addr, 0, 0);\n+            adt::trans_start_init(bcx, &*repr, addr, 0);\n+            let field_dest = adt::trans_field_ptr(bcx, &*repr, addr, 0, 0);\n             contents_datum.store_to(bcx, field_dest)\n         }\n     }\n@@ -1580,7 +1580,7 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n                 bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n             let llexpr_ptr = datum.to_llref();\n             let lldiscrim_a =\n-                adt::trans_get_discr(bcx, repr, llexpr_ptr, Some(Type::i64(ccx)));\n+                adt::trans_get_discr(bcx, &*repr, llexpr_ptr, Some(Type::i64(ccx)));\n             match k_out {\n                 cast_integral => int_cast(bcx, ll_t_out,\n                                           val_ty(lldiscrim_a),"}, {"sha": "02da7f9797df6d7ab4305cc9028ba0395686a444", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=938eaaa304445101e2c516a9d339dcbc0a416d58", "patch": "@@ -224,7 +224,7 @@ fn trans_struct_drop_flag<'a>(bcx: &'a Block<'a>,\n                               substs: &ty::substs)\n                               -> &'a Block<'a> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n-    let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n+    let drop_flag = adt::trans_drop_flag_ptr(bcx, &*repr, v0);\n     with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag)), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n@@ -265,7 +265,7 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n     // this scope.\n     let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n     for (i, fld) in field_tys.iter().enumerate() {\n-        let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n+        let llfld_a = adt::trans_field_ptr(bcx, &*repr, v0, 0, i);\n         bcx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope),\n                                   llfld_a,\n                                   fld.mt.ty);"}, {"sha": "ed956b74ea9b80144fb580193cf770dadb5ccacb", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=938eaaa304445101e2c516a9d339dcbc0a416d58", "patch": "@@ -320,7 +320,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                 };\n                 let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n                 let arg = BitCast(bcx, arg, llptrty);\n-                let ret = adt::trans_get_discr(bcx, repr, arg, Some(Type::i64(ccx)));\n+                let ret = adt::trans_get_discr(bcx, &*repr, arg, Some(Type::i64(ccx)));\n                 Store(bcx, ret, fcx.llretptr.get().unwrap());\n                 match fcx.llreturn.get() {\n                     Some(llreturn) => Br(bcx, llreturn),\n@@ -345,7 +345,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                         for (j, a) in v.args.iter().enumerate() {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n-                            let ptr = adt::trans_field_ptr(bcx, repr, null, v.disr_val, j);\n+                            let ptr = adt::trans_field_ptr(bcx, &*repr, null, v.disr_val, j);\n                             let offset = p2i(ccx, ptr);\n                             let field_args = [this.c_uint(j),\n                                                offset,"}, {"sha": "0a539d5e6c6ba65b3c7afe38aa0930326753075c", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/938eaaa304445101e2c516a9d339dcbc0a416d58/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=938eaaa304445101e2c516a9d339dcbc0a416d58", "patch": "@@ -142,7 +142,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n         ty::ty_tup(..) | ty::ty_enum(..) => {\n             let repr = adt::represent_type(cx, t);\n-            adt::sizing_type_of(cx, repr)\n+            adt::sizing_type_of(cx, &*repr)\n         }\n \n         ty::ty_struct(..) => {\n@@ -152,7 +152,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n                 Type::vector(&type_of(cx, et), n as u64)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n-                adt::sizing_type_of(cx, repr)\n+                adt::sizing_type_of(cx, &*repr)\n             }\n         }\n \n@@ -213,7 +213,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         // of the enum's variants refers to the enum itself.\n         let repr = adt::represent_type(cx, t);\n         let name = llvm_type_name(cx, an_enum, did, substs.tps.as_slice());\n-        adt::incomplete_type_of(cx, repr, name)\n+        adt::incomplete_type_of(cx, &*repr, name)\n       }\n       ty::ty_box(typ) => {\n           Type::at_box(cx, type_of(cx, typ)).ptr_to()\n@@ -259,7 +259,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_trait(..) => Type::opaque_trait(cx),\n       ty::ty_tup(..) => {\n           let repr = adt::represent_type(cx, t);\n-          adt::type_of(cx, repr)\n+          adt::type_of(cx, &*repr)\n       }\n       ty::ty_struct(did, ref substs) => {\n           if ty::type_is_simd(cx.tcx(), t) {\n@@ -275,7 +275,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n                                         a_struct,\n                                         did,\n                                         substs.tps.as_slice());\n-              adt::incomplete_type_of(cx, repr, name)\n+              adt::incomplete_type_of(cx, &*repr, name)\n           }\n       }\n \n@@ -297,7 +297,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     match ty::get(t).sty {\n         ty::ty_enum(..) | ty::ty_struct(..) if !ty::type_is_simd(cx.tcx(), t) => {\n             let repr = adt::represent_type(cx, t);\n-            adt::finish_type_of(cx, repr, &mut llty);\n+            adt::finish_type_of(cx, &*repr, &mut llty);\n         }\n         _ => ()\n     }"}]}