{"sha": "572892c324cde896df0c4a1e9ed4896b1832a4fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3Mjg5MmMzMjRjZGU4OTZkZjBjNGExZTllZDQ4OTZiMTgzMmE0ZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-26T03:26:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-26T03:26:10Z"}, "message": "Auto merge of #60852 - alexcrichton:std-backtrace, r=sfackler\n\nstd: Depend on `backtrace` crate from crates.io\n\nThis commit removes all in-tree support for generating backtraces in\nfavor of depending on the `backtrace` crate on crates.io. This resolves\na very longstanding piece of duplication where the standard library has\nlong contained the ability to generate a backtrace on panics, but the\ncode was later extracted and duplicated on crates.io with the\n`backtrace` crate. Since that fork each implementation has seen various\nimprovements one way or another, but typically `backtrace`-the-crate has\nlagged behind libstd in one way or another.\n\nThe goal here is to remove this duplication of a fairly critical piece\nof code and ensure that there's only one source of truth for generating\nbacktraces between the standard library and the crate on crates.io.\nRecently I've been working to bring the `backtrace` crate on crates.io\nup to speed with the support in the standard library which includes:\n\n* Support for `StackWalkEx` on MSVC to recover inline frames with\n  debuginfo.\n* Using `libbacktrace` by default on MinGW targets.\n* Supporting `libbacktrace` on OSX as an option.\n* Ensuring all the requisite support in `backtrace`-the-crate compiles\n  with `#![no_std]`.\n* Updating the `libbacktrace` implementation in `backtrace`-the-crate to\n  initialize the global state with the correct filename where necessary.\n\nAfter reviewing the code in libstd the `backtrace` crate should be at\nexact feature parity with libstd today. The backtraces generated should\nhave the same symbols and same number of frames in general, and there's\nnot known divergence from libstd currently.\n\nNote that one major difference between libstd's backtrace support and\nthe `backtrace` crate is that on OSX the crates.io crate enables the\n`coresymbolication` feature by default. This feature, however, uses\nprivate internal APIs that aren't published for OSX. While they provide\nmore accurate backtraces this isn't appropriate for libstd distributed\nas a binary, so libstd's dependency on the `backtrace` crate explicitly\ndisables this feature and forces OSX to use `libbacktrace` as a\nsymbolication strategy.\n\nThe long-term goal of this refactoring is to eventually move us towards\na world where we can drop `libbacktrace` entirely and simply use Gimli\nand the surrounding crates for backtrace support. That's still aways off\nbut hopefully will much more easily enabled by having the source of\ntruth for backtraces live in crates.io!\n\nProcedurally if we go forward with this I'd like to transfer the\n`backtrace-rs` crate to the rust-lang GitHub organization as well, but I\nfigured I'd hold off on that until we get closer to merging.", "tree": {"sha": "842f57dd778012d44da6c7d7c8578b36970a590d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/842f57dd778012d44da6c7d7c8578b36970a590d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/572892c324cde896df0c4a1e9ed4896b1832a4fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/572892c324cde896df0c4a1e9ed4896b1832a4fd", "html_url": "https://github.com/rust-lang/rust/commit/572892c324cde896df0c4a1e9ed4896b1832a4fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/572892c324cde896df0c4a1e9ed4896b1832a4fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "483567e097c7634afa745fe5c59abc0e75026385", "url": "https://api.github.com/repos/rust-lang/rust/commits/483567e097c7634afa745fe5c59abc0e75026385", "html_url": "https://github.com/rust-lang/rust/commit/483567e097c7634afa745fe5c59abc0e75026385"}, {"sha": "d1040fe329a8db99ae0aae47975830a0829d7792", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1040fe329a8db99ae0aae47975830a0829d7792", "html_url": "https://github.com/rust-lang/rust/commit/d1040fe329a8db99ae0aae47975830a0829d7792"}], "stats": {"total": 2369, "additions": 207, "deletions": 2162}, "files": [{"sha": "ebb27fafdb367d0f59fb362bc8238e7b9586701b", "filename": "Cargo.lock", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -105,16 +105,23 @@ dependencies = [\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"autocfg\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"backtrace\"\n-version = \"0.3.11\"\n+version = \"0.3.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n+ \"autocfg 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"backtrace-sys 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-std-workspace-core 1.0.0\",\n ]\n \n [[package]]\n@@ -335,8 +342,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"cfg-if\"\n-version = \"0.1.6\"\n+version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"compiler_builtins 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-std-workspace-core 1.0.0\",\n+]\n \n [[package]]\n name = \"chalk-engine\"\n@@ -562,7 +573,7 @@ name = \"crc32fast\"\n version = \"1.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -598,7 +609,7 @@ version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crossbeam-utils 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -612,7 +623,7 @@ version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -624,15 +635,15 @@ name = \"crossbeam-utils\"\n version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"crossbeam-utils\"\n version = \"0.6.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -814,15 +825,15 @@ name = \"error-chain\"\n version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"backtrace 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace 0.3.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"error-chain\"\n version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"backtrace 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace 0.3.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -837,7 +848,7 @@ name = \"failure\"\n version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"backtrace 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace 0.3.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -862,7 +873,7 @@ name = \"filetime\"\n version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"redox_syscall 0.1.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1356,7 +1367,7 @@ name = \"log\"\n version = \"0.4.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1642,7 +1653,7 @@ name = \"net2\"\n version = \"0.2.33\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1711,7 +1722,7 @@ version = \"0.10.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"foreign-types 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1767,7 +1778,7 @@ name = \"packed_simd\"\n version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2351,7 +2362,7 @@ name = \"rustc\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n- \"backtrace 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace 0.3.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"chalk-engine 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2409,7 +2420,7 @@ name = \"rustc-ap-rustc_data_structures\"\n version = \"407.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2481,7 +2492,7 @@ name = \"rustc-ap-syntax_pos\"\n version = \"407.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-arena 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-rustc_data_structures 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-serialize 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2708,7 +2719,7 @@ dependencies = [\n name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"jobserver 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3291,7 +3302,7 @@ name = \"socket2\"\n version = \"0.3.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"redox_syscall 0.1.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3307,7 +3318,7 @@ name = \"std\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n- \"backtrace-sys 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace 0.3.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n@@ -3319,7 +3330,6 @@ dependencies = [\n  \"panic_unwind 0.0.0\",\n  \"profiler_builtins 0.0.0\",\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_asan 0.0.0\",\n  \"rustc_lsan 0.0.0\",\n  \"rustc_msan 0.0.0\",\n@@ -3462,7 +3472,7 @@ name = \"syntax_pos\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_macros 0.1.0\",\n  \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3486,7 +3496,7 @@ name = \"tempfile\"\n version = \"3.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"redox_syscall 0.1.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -4091,7 +4101,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum arrayref 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d382e583f07208808f6b1249e60848879ba3543f57c32277bf52d69c2f0f0ee\"\n \"checksum arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1e964f9e24d588183fcb43503abda40d288c8657dfc27311516ce2f05675aef\"\n \"checksum atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a7d5b8723950951411ee34d271d99dddcc2035a16ab25310ea2c8cfd4369652\"\n-\"checksum backtrace 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"18b65ea1161bfb2dd6da6fade5edd4dbd08fba85012123dd333d2fd1b90b2782\"\n+\"checksum autocfg 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e49efa51329a5fd37e7c79db4621af617cd4e3e5bc224939808d076077077bf\"\n+\"checksum backtrace 0.3.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1c50b4cb6d852a8567d98bb11c03f91ccec4dfbd88778bc1b92789c624081283\"\n \"checksum backtrace-sys 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ea90dd7b012b3d1a2cb6bec16670a0db2c95d4e931e84f4047e0460c1b34c8d\"\n \"checksum bit-set 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6f1efcc46c18245a69c38fcc5cc650f16d3a59d034f3106e9ed63748f695730a\"\n \"checksum bit-vec 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4440d5cb623bb7390ae27fec0bb6c61111969860f8e3ae198bfa0663645e67cf\"\n@@ -4109,7 +4120,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum bytesize 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"716960a18f978640f25101b5cbf1c6f6b0d3192fab36a2d98ca96f0ecbe41010\"\n \"checksum cargo_metadata 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"585784cac9b05c93a53b17a0b24a5cdd1dfdda5256f030e089b549d2390cc720\"\n \"checksum cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5e5f3fee5eeb60324c2781f1e41286bdee933850fff9b3c672587fed5ec58c83\"\n-\"checksum cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"082bb9b28e00d3c9d39cc03e64ce4cea0f1bb9b3fde493f0cbc008472d22bdf4\"\n+\"checksum cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"89431bba4e6b7092fb5fcd00a6f6ca596c55cc26b2f1e6dcdd08a1f4933f66b2\"\n \"checksum chalk-engine 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"17ec698a6f053a23bfbe646d9f2fde4b02abc19125595270a99e6f44ae0bdd1a\"\n \"checksum chalk-macros 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"295635afd6853aa9f20baeb7f0204862440c0fe994c5a253d5f479dac41d047e\"\n \"checksum chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"45912881121cb26fad7c38c17ba7daa18764771836b34fab7d3fbd93ed633878\""}, {"sha": "d22dc9a71a40f110682bb3da5dc00b93a741f72d", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -23,8 +23,18 @@ compiler_builtins = { version = \"0.1.15\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n unwind = { path = \"../libunwind\" }\n hashbrown = { version = \"0.3.0\", features = ['rustc-dep-of-std'] }\n-rustc-demangle = { version = \"0.1.10\", features = ['rustc-dep-of-std'] }\n-backtrace-sys = { version = \"0.1.24\", features = [\"rustc-dep-of-std\"], optional = true }\n+\n+[dependencies.backtrace]\n+version = \"0.3.25\"\n+default-features = false # don't use coresymbolication on OSX\n+features = [\n+  \"rustc-dep-of-std\", # enable build support for integrating into libstd\n+  \"dbghelp\",          # backtrace/symbolize on MSVC\n+  \"libbacktrace\",     # symbolize on most platforms\n+  \"libunwind\",        # backtrace on most platforms\n+  \"dladdr\",           # symbolize on platforms w/o libbacktrace\n+]\n+optional = true\n \n [dev-dependencies]\n rand = \"0.6.1\"\n@@ -51,7 +61,6 @@ cc = \"1.0\"\n [features]\n default = [\"std_detect_file_io\", \"std_detect_dlsym_getauxval\"]\n \n-backtrace = [\"backtrace-sys\"]\n panic-unwind = [\"panic_unwind\"]\n profiler = [\"profiler_builtins\"]\n compiler-builtins-c = [\"alloc/compiler-builtins-c\"]"}, {"sha": "17719a29b6ed637f7a688720a56863e9fc819794", "filename": "src/libstd/sys/cloudabi/backtrace.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fcloudabi%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fcloudabi%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fbacktrace.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,116 +0,0 @@\n-use crate::error::Error;\n-use crate::ffi::CStr;\n-use crate::fmt;\n-use crate::intrinsics;\n-use crate::io;\n-use crate::sys_common::backtrace::Frame;\n-\n-use unwind as uw;\n-\n-pub struct BacktraceContext;\n-\n-struct Context<'a> {\n-    idx: usize,\n-    frames: &'a mut [Frame],\n-}\n-\n-#[derive(Debug)]\n-struct UnwindError(uw::_Unwind_Reason_Code);\n-\n-impl Error for UnwindError {\n-    fn description(&self) -> &'static str {\n-        \"unexpected return value while unwinding\"\n-    }\n-}\n-\n-impl fmt::Display for UnwindError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}: {:?}\", self.description(), self.0)\n-    }\n-}\n-\n-#[inline(never)] // if we know this is a function call, we can skip it when\n-                 // tracing\n-pub fn unwind_backtrace(frames: &mut [Frame]) -> io::Result<(usize, BacktraceContext)> {\n-    let mut cx = Context { idx: 0, frames };\n-    let result_unwind = unsafe {\n-        uw::_Unwind_Backtrace(trace_fn, &mut cx as *mut Context<'_> as *mut libc::c_void)\n-    };\n-    // See libunwind:src/unwind/Backtrace.c for the return values.\n-    // No, there is no doc.\n-    match result_unwind {\n-        // These return codes seem to be benign and need to be ignored for backtraces\n-        // to show up properly on all tested platforms.\n-        uw::_URC_END_OF_STACK | uw::_URC_FATAL_PHASE1_ERROR | uw::_URC_FAILURE => {\n-            Ok((cx.idx, BacktraceContext))\n-        }\n-        _ => Err(io::Error::new(\n-            io::ErrorKind::Other,\n-            UnwindError(result_unwind),\n-        )),\n-    }\n-}\n-\n-extern \"C\" fn trace_fn(\n-    ctx: *mut uw::_Unwind_Context,\n-    arg: *mut libc::c_void,\n-) -> uw::_Unwind_Reason_Code {\n-    let cx = unsafe { &mut *(arg as *mut Context<'_>) };\n-    if cx.idx >= cx.frames.len() {\n-        return uw::_URC_NORMAL_STOP;\n-    }\n-\n-    let mut ip_before_insn = 0;\n-    let mut ip = unsafe { uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void };\n-    if !ip.is_null() && ip_before_insn == 0 {\n-        // this is a non-signaling frame, so `ip` refers to the address\n-        // after the calling instruction. account for that.\n-        ip = (ip as usize - 1) as *mut _;\n-    }\n-\n-    let symaddr = unsafe { uw::_Unwind_FindEnclosingFunction(ip) };\n-    cx.frames[cx.idx] = Frame {\n-        symbol_addr: symaddr as *mut u8,\n-        exact_position: ip as *mut u8,\n-        inline_context: 0,\n-    };\n-    cx.idx += 1;\n-\n-    uw::_URC_NO_REASON\n-}\n-\n-pub fn foreach_symbol_fileline<F>(_: Frame, _: F, _: &BacktraceContext) -> io::Result<bool>\n-where\n-    F: FnMut(&[u8], u32) -> io::Result<()>,\n-{\n-    // No way to obtain this information on CloudABI.\n-    Ok(false)\n-}\n-\n-pub fn resolve_symname<F>(frame: Frame, callback: F, _: &BacktraceContext) -> io::Result<()>\n-where\n-    F: FnOnce(Option<&str>) -> io::Result<()>,\n-{\n-    unsafe {\n-        let mut info: Dl_info = intrinsics::init();\n-        let symname =\n-            if dladdr(frame.exact_position as *mut _, &mut info) == 0 || info.dli_sname.is_null() {\n-                None\n-            } else {\n-                CStr::from_ptr(info.dli_sname).to_str().ok()\n-            };\n-        callback(symname)\n-    }\n-}\n-\n-#[repr(C)]\n-struct Dl_info {\n-    dli_fname: *const libc::c_char,\n-    dli_fbase: *mut libc::c_void,\n-    dli_sname: *const libc::c_char,\n-    dli_saddr: *mut libc::c_void,\n-}\n-\n-extern \"C\" {\n-    fn dladdr(addr: *const libc::c_void, info: *mut Dl_info) -> libc::c_int;\n-}"}, {"sha": "c3b8bbd042606e17e1581d236a7fdb0975aebe21", "filename": "src/libstd/sys/cloudabi/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -4,8 +4,6 @@ use crate::mem;\n #[path = \"../unix/alloc.rs\"]\n pub mod alloc;\n pub mod args;\n-#[cfg(feature = \"backtrace\")]\n-pub mod backtrace;\n #[path = \"../unix/cmath.rs\"]\n pub mod cmath;\n pub mod condvar;"}, {"sha": "8ea2783580a4769358c171a55db26782df707e33", "filename": "src/libstd/sys/redox/backtrace/mod.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fmod.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,32 +0,0 @@\n-/// See sys/unix/backtrace/mod.rs for an explanation of the method used here.\n-\n-pub use self::tracing::unwind_backtrace;\n-pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n-\n-// tracing impls:\n-mod tracing;\n-// symbol resolvers:\n-mod printing;\n-\n-pub mod gnu {\n-    use crate::io;\n-    use crate::fs;\n-    use crate::vec::Vec;\n-    use crate::ffi::OsStr;\n-    use crate::os::unix::ffi::OsStrExt;\n-    use crate::io::Read;\n-    use libc::c_char;\n-\n-    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n-        let mut exefile = fs::File::open(\"sys:exe\")?;\n-        let mut exename = Vec::new();\n-        exefile.read_to_end(&mut exename)?;\n-        if exename.last() == Some(&b'\\n') {\n-            exename.pop();\n-        }\n-        let file = fs::File::open(OsStr::from_bytes(&exename))?;\n-        Ok((exename.into_iter().map(|c| c as c_char).collect(), file))\n-    }\n-}\n-\n-pub struct BacktraceContext;"}, {"sha": "489eed4562debf3a1a88bf359456a98baff3b4af", "filename": "src/libstd/sys/redox/backtrace/printing.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1 +0,0 @@\n-pub use crate::sys_common::gnu::libbacktrace::{foreach_symbol_fileline, resolve_symname};"}, {"sha": "13f34338fd33b2b7d620643ec8438b08e7882f70", "filename": "src/libstd/sys/redox/backtrace/tracing.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,99 +0,0 @@\n-use crate::error::Error;\n-use crate::fmt;\n-use crate::io;\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-\n-use unwind as uw;\n-\n-struct Context<'a> {\n-    idx: usize,\n-    frames: &'a mut [Frame],\n-}\n-\n-#[derive(Debug)]\n-struct UnwindError(uw::_Unwind_Reason_Code);\n-\n-impl Error for UnwindError {\n-    fn description(&self) -> &'static str {\n-        \"unexpected return value while unwinding\"\n-    }\n-}\n-\n-impl fmt::Display for UnwindError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}: {:?}\", self.description(), self.0)\n-    }\n-}\n-\n-#[inline(never)] // if we know this is a function call, we can skip it when\n-                 // tracing\n-pub fn unwind_backtrace(frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n-    let mut cx = Context {\n-        idx: 0,\n-        frames: frames,\n-    };\n-    let result_unwind = unsafe {\n-        uw::_Unwind_Backtrace(trace_fn,\n-                              &mut cx as *mut Context<'_>\n-                              as *mut libc::c_void)\n-    };\n-    // See libunwind:src/unwind/Backtrace.c for the return values.\n-    // No, there is no doc.\n-    match result_unwind {\n-        // These return codes seem to be benign and need to be ignored for backtraces\n-        // to show up properly on all tested platforms.\n-        uw::_URC_END_OF_STACK | uw::_URC_FATAL_PHASE1_ERROR | uw::_URC_FAILURE => {\n-            Ok((cx.idx, BacktraceContext))\n-        }\n-        _ => {\n-            Err(io::Error::new(io::ErrorKind::Other,\n-                               UnwindError(result_unwind)))\n-        }\n-    }\n-}\n-\n-extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n-                   arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n-    let cx = unsafe { &mut *(arg as *mut Context<'_>) };\n-    if cx.idx >= cx.frames.len() {\n-        return uw::_URC_NORMAL_STOP;\n-    }\n-\n-    let mut ip_before_insn = 0;\n-    let mut ip = unsafe {\n-        uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n-    };\n-    if !ip.is_null() && ip_before_insn == 0 {\n-        // this is a non-signaling frame, so `ip` refers to the address\n-        // after the calling instruction. account for that.\n-        ip = (ip as usize - 1) as *mut _;\n-    }\n-\n-    // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n-    // it appears to work fine without it, so we only use\n-    // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n-    // slightly more accurate stack trace in the process.\n-    //\n-    // This is often because panic involves the last instruction of a\n-    // function being \"call std::rt::begin_unwind\", with no ret\n-    // instructions after it. This means that the return instruction\n-    // pointer points *outside* of the calling function, and by\n-    // unwinding it we go back to the original function.\n-    let symaddr = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n-        ip\n-    } else {\n-        unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n-    };\n-\n-    cx.frames[cx.idx] = Frame {\n-        symbol_addr: symaddr as *mut u8,\n-        exact_position: ip as *mut u8,\n-        inline_context: 0,\n-    };\n-    cx.idx += 1;\n-\n-    uw::_URC_NO_REASON\n-}"}, {"sha": "354184f8af6e71dda54c0b3e9e6a19425ccc89c0", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -8,8 +8,6 @@ pub use self::rand::hashmap_random_keys;\n #[path = \"../unix/alloc.rs\"]\n pub mod alloc;\n pub mod args;\n-#[cfg(feature = \"backtrace\")]\n-pub mod backtrace;\n pub mod cmath;\n pub mod condvar;\n pub mod env;"}, {"sha": "326737a2418637369ac4fd7679ae2bb132c424fa", "filename": "src/libstd/sys/sgx/backtrace.rs", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fsgx%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fsgx%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fbacktrace.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,98 +0,0 @@\n-use crate::io;\n-use crate::error::Error;\n-use crate::fmt;\n-use crate::sys_common::backtrace::Frame;\n-use crate::sys::sgx::abi::mem::image_base;\n-\n-use unwind as uw;\n-\n-pub struct BacktraceContext;\n-\n-struct Context<'a> {\n-    idx: usize,\n-    frames: &'a mut [Frame],\n-}\n-\n-#[derive(Debug)]\n-struct UnwindError(uw::_Unwind_Reason_Code);\n-\n-impl Error for UnwindError {\n-    fn description(&self) -> &'static str {\n-        \"unexpected return value while unwinding\"\n-    }\n-}\n-\n-impl fmt::Display for UnwindError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}: {:?}\", self.description(), self.0)\n-    }\n-}\n-\n-#[inline(never)] // this function call can be skipped it when tracing.\n-pub fn unwind_backtrace(frames: &mut [Frame]) -> io::Result<(usize, BacktraceContext)> {\n-    let mut cx = Context { idx: 0, frames };\n-    let result_unwind = unsafe {\n-        uw::_Unwind_Backtrace(trace_fn, &mut cx as *mut Context<'_> as *mut libc::c_void)\n-    };\n-    // See libunwind:src/unwind/Backtrace.c for the return values.\n-    // No, there is no doc.\n-    let res = match result_unwind {\n-        // These return codes seem to be benign and need to be ignored for backtraces\n-        // to show up properly on all tested platforms.\n-        uw::_URC_END_OF_STACK | uw::_URC_FATAL_PHASE1_ERROR | uw::_URC_FAILURE => {\n-            Ok((cx.idx, BacktraceContext))\n-        }\n-        _ => Err(io::Error::new(\n-            io::ErrorKind::Other,\n-            UnwindError(result_unwind),\n-        )),\n-    };\n-    res\n-}\n-\n-extern \"C\" fn trace_fn(\n-    ctx: *mut uw::_Unwind_Context,\n-    arg: *mut libc::c_void,\n-) -> uw::_Unwind_Reason_Code {\n-    let cx = unsafe { &mut *(arg as *mut Context<'_>) };\n-    if cx.idx >= cx.frames.len() {\n-        return uw::_URC_NORMAL_STOP;\n-    }\n-\n-    let mut ip_before_insn = 0;\n-    let mut ip = unsafe { uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void };\n-    if !ip.is_null() && ip_before_insn == 0 {\n-        // this is a non-signaling frame, so `ip` refers to the address\n-        // after the calling instruction. account for that.\n-        ip = (ip as usize - 1) as *mut _;\n-    }\n-\n-    let symaddr = unsafe { uw::_Unwind_FindEnclosingFunction(ip) };\n-    cx.frames[cx.idx] = Frame {\n-        symbol_addr: symaddr as *mut u8,\n-        exact_position: ip as *mut u8,\n-        inline_context: 0,\n-    };\n-    cx.idx += 1;\n-\n-    uw::_URC_NO_REASON\n-}\n-\n-// To reduce TCB size in Sgx enclave, we do not want to implement resolve_symname functionality.\n-// Rather, we print the offset of the address here, which could be later mapped to correct function.\n-pub fn resolve_symname<F>(frame: Frame,\n-                          callback: F,\n-                          _: &BacktraceContext) -> io::Result<()>\n-    where F: FnOnce(Option<&str>) -> io::Result<()>\n-{\n-    callback(Some(&format!(\"0x{:x}\",\n-            (frame.symbol_addr.wrapping_offset_from(image_base() as _)))))\n-}\n-\n-pub fn foreach_symbol_fileline<F>(_: Frame,\n-                                  _: F,\n-                                  _: &BacktraceContext) -> io::Result<bool>\n-    where F: FnMut(&[u8], u32) -> io::Result<()>\n-{\n-    Ok(false)\n-}"}, {"sha": "01f5536ed7a6594a614d77c0896fbab98aa1883a", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -12,8 +12,6 @@ mod waitqueue;\n \n pub mod alloc;\n pub mod args;\n-#[cfg(feature = \"backtrace\")]\n-pub mod backtrace;\n pub mod cmath;\n pub mod condvar;\n pub mod env;"}, {"sha": "0887e5a4df937ed97486ceb77367defe4ab1f833", "filename": "src/libstd/sys/unix/backtrace/mod.rs", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,110 +0,0 @@\n-/// Backtrace support built on libgcc with some extra OS-specific support\n-///\n-/// Some methods of getting a backtrace:\n-///\n-/// * The backtrace() functions on unix. It turns out this doesn't work very\n-///   well for green threads on macOS, and the address to symbol portion of it\n-///   suffers problems that are described below.\n-///\n-/// * Using libunwind. This is more difficult than it sounds because libunwind\n-///   isn't installed everywhere by default. It's also a bit of a hefty library,\n-///   so possibly not the best option. When testing, libunwind was excellent at\n-///   getting both accurate backtraces and accurate symbols across platforms.\n-///   This route was not chosen in favor of the next option, however.\n-///\n-/// * We're already using libgcc_s for exceptions in rust (triggering thread\n-///   unwinding and running destructors on the stack), and it turns out that it\n-///   conveniently comes with a function that also gives us a backtrace. All of\n-///   these functions look like _Unwind_*, but it's not quite the full\n-///   repertoire of the libunwind API. Due to it already being in use, this was\n-///   the chosen route of getting a backtrace.\n-///\n-/// After choosing libgcc_s for backtraces, the sad part is that it will only\n-/// give us a stack trace of instruction pointers. Thankfully these instruction\n-/// pointers are accurate (they work for green and native threads), but it's\n-/// then up to us again to figure out how to translate these addresses to\n-/// symbols. As with before, we have a few options. Before, that, a little bit\n-/// of an interlude about symbols. This is my very limited knowledge about\n-/// symbol tables, and this information is likely slightly wrong, but the\n-/// general idea should be correct.\n-///\n-/// When talking about symbols, it's helpful to know a few things about where\n-/// symbols are located. Some symbols are located in the dynamic symbol table\n-/// of the executable which in theory means that they're available for dynamic\n-/// linking and lookup. Other symbols end up only in the local symbol table of\n-/// the file. This loosely corresponds to pub and priv functions in Rust.\n-///\n-/// Armed with this knowledge, we know that our solution for address to symbol\n-/// translation will need to consult both the local and dynamic symbol tables.\n-/// With that in mind, here's our options of translating an address to\n-/// a symbol.\n-///\n-/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n-///   behind the scenes to translate, and this is why backtrace() was not used.\n-///   Conveniently, this method works fantastically on macOS. It appears dladdr()\n-///   uses magic to consult the local symbol table, or we're putting everything\n-///   in the dynamic symbol table anyway. Regardless, for macOS, this is the\n-///   method used for translation. It's provided by the system and easy to do.o\n-///\n-///   Sadly, all other systems have a dladdr() implementation that does not\n-///   consult the local symbol table. This means that most functions are blank\n-///   because they don't have symbols. This means that we need another solution.\n-///\n-/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n-///   libgcc_s version of the libunwind api), but involves taking a dependency\n-///   to libunwind. We may pursue this route in the future if we bundle\n-///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n-///   this time to provide this functionality.\n-///\n-/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n-///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n-///   so in theory it could invoke readelf, parse the output, and consult the\n-///   local/dynamic symbol tables from there. This ended up not getting chosen\n-///   due to the craziness of the idea plus the advent of the next option.\n-///\n-/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n-///   the gcc repository which provides backtrace and symbol translation\n-///   functionality. All we really need from it is the backtrace functionality,\n-///   and we only really need this on everything that's not macOS, so this is the\n-///   chosen route for now.\n-///\n-/// In summary, the current situation uses libgcc_s to get a trace of stack\n-/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n-/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n-/// all unix platforms we support right now, so it at least gets the job done.\n-\n-pub use self::tracing::unwind_backtrace;\n-pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n-\n-// tracing impls:\n-mod tracing;\n-// symbol resolvers:\n-mod printing;\n-\n-#[cfg(not(target_os = \"emscripten\"))]\n-pub mod gnu {\n-    use crate::io;\n-    use crate::fs;\n-\n-    use libc::c_char;\n-\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n-        Err(io::Error::new(io::ErrorKind::Other, \"Not implemented\"))\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n-        use crate::env;\n-        use crate::os::unix::ffi::OsStrExt;\n-\n-        let filename = env::current_exe()?;\n-        let file = fs::File::open(&filename)?;\n-        let mut filename_cstr: Vec<_> = filename.as_os_str().as_bytes().iter()\n-            .map(|&x| x as c_char).collect();\n-        filename_cstr.push(0); // Null terminate\n-        Ok((filename_cstr, file))\n-    }\n-}\n-\n-pub struct BacktraceContext;"}, {"sha": "cf3bda640e92b52a16bb1680153dc0a6e7d03d39", "filename": "src/libstd/sys/unix/backtrace/printing/dladdr.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,34 +0,0 @@\n-use crate::io;\n-use crate::intrinsics;\n-use crate::ffi::CStr;\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-\n-pub fn resolve_symname<F>(frame: Frame,\n-                          callback: F,\n-                          _: &BacktraceContext) -> io::Result<()>\n-    where F: FnOnce(Option<&str>) -> io::Result<()>\n-{\n-    unsafe {\n-        let mut info: Dl_info = intrinsics::init();\n-        let symname = if dladdr(frame.exact_position as *mut _, &mut info) == 0 ||\n-                         info.dli_sname.is_null() {\n-            None\n-        } else {\n-            CStr::from_ptr(info.dli_sname).to_str().ok()\n-        };\n-        callback(symname)\n-    }\n-}\n-\n-#[repr(C)]\n-struct Dl_info {\n-    dli_fname: *const libc::c_char,\n-    dli_fbase: *mut libc::c_void,\n-    dli_sname: *const libc::c_char,\n-    dli_saddr: *mut libc::c_void,\n-}\n-\n-extern {\n-    fn dladdr(addr: *const libc::c_void, info: *mut Dl_info) -> libc::c_int;\n-}"}, {"sha": "d090caede437abc25749831a46fe2d99896a7300", "filename": "src/libstd/sys/unix/backtrace/printing/mod.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,33 +0,0 @@\n-mod dladdr;\n-\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-use crate::io;\n-\n-#[cfg(target_os = \"emscripten\")]\n-pub use self::dladdr::resolve_symname;\n-\n-#[cfg(target_os = \"emscripten\")]\n-pub fn foreach_symbol_fileline<F>(_: Frame, _: F, _: &BacktraceContext) -> io::Result<bool>\n-where\n-    F: FnMut(&[u8], u32) -> io::Result<()>\n-{\n-    Ok(false)\n-}\n-\n-#[cfg(not(target_os = \"emscripten\"))]\n-pub use crate::sys_common::gnu::libbacktrace::foreach_symbol_fileline;\n-\n-#[cfg(not(target_os = \"emscripten\"))]\n-pub fn resolve_symname<F>(frame: Frame, callback: F, bc: &BacktraceContext) -> io::Result<()>\n-where\n-    F: FnOnce(Option<&str>) -> io::Result<()>\n-{\n-    crate::sys_common::gnu::libbacktrace::resolve_symname(frame, |symname| {\n-        if symname.is_some() {\n-            callback(symname)\n-        } else {\n-            dladdr::resolve_symname(frame, callback, bc)\n-        }\n-    }, bc)\n-}"}, {"sha": "a628d107ad6fbd94f523f7c49a951cdea4c941c6", "filename": "src/libstd/sys/unix/backtrace/tracing/backtrace_fn.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,39 +0,0 @@\n-/// As always - iOS on arm uses SjLj exceptions and\n-/// _Unwind_Backtrace is even not available there. Still,\n-/// backtraces could be extracted using a backtrace function,\n-/// which thanks god is public\n-///\n-/// As mentioned in a huge comment block in `super::super`, backtrace\n-/// doesn't play well with green threads, so while it is extremely nice and\n-/// simple to use it should be used only on iOS devices as the only viable\n-/// option.\n-\n-use crate::io;\n-use crate::ptr;\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-\n-#[inline(never)] // if we know this is a function call, we can skip it when\n-                 // tracing\n-pub fn unwind_backtrace(frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n-    const FRAME_LEN: usize = 100;\n-    assert!(FRAME_LEN >= frames.len());\n-    let mut raw_frames = [ptr::null_mut(); FRAME_LEN];\n-    let nb_frames = unsafe {\n-        backtrace(raw_frames.as_mut_ptr(), raw_frames.len() as libc::c_int)\n-    } as usize;\n-    for (from, to) in raw_frames.iter().zip(frames.iter_mut()).take(nb_frames) {\n-        *to = Frame {\n-            exact_position: *from as *mut u8,\n-            symbol_addr: *from as *mut u8,\n-            inline_context: 0,\n-        };\n-    }\n-    Ok((nb_frames as usize, BacktraceContext))\n-}\n-\n-extern {\n-    fn backtrace(buf: *mut *mut libc::c_void, sz: libc::c_int) -> libc::c_int;\n-}"}, {"sha": "e6379132bafbe35552adac17dd543aaef39accf4", "filename": "src/libstd/sys/unix/backtrace/tracing/gcc_s.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,99 +0,0 @@\n-use crate::error::Error;\n-use crate::fmt;\n-use crate::io;\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-\n-use unwind as uw;\n-\n-struct Context<'a> {\n-    idx: usize,\n-    frames: &'a mut [Frame],\n-}\n-\n-#[derive(Debug)]\n-struct UnwindError(uw::_Unwind_Reason_Code);\n-\n-impl Error for UnwindError {\n-    fn description(&self) -> &'static str {\n-        \"unexpected return value while unwinding\"\n-    }\n-}\n-\n-impl fmt::Display for UnwindError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}: {:?}\", self.description(), self.0)\n-    }\n-}\n-\n-#[inline(never)] // if we know this is a function call, we can skip it when\n-                 // tracing\n-pub fn unwind_backtrace(frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n-    let mut cx = Context {\n-        idx: 0,\n-        frames,\n-    };\n-    let result_unwind = unsafe {\n-        uw::_Unwind_Backtrace(trace_fn,\n-                              &mut cx as *mut Context<'_>\n-                              as *mut libc::c_void)\n-    };\n-    // See libunwind:src/unwind/Backtrace.c for the return values.\n-    // No, there is no doc.\n-    match result_unwind {\n-        // These return codes seem to be benign and need to be ignored for backtraces\n-        // to show up properly on all tested platforms.\n-        uw::_URC_END_OF_STACK | uw::_URC_FATAL_PHASE1_ERROR | uw::_URC_FAILURE => {\n-            Ok((cx.idx, BacktraceContext))\n-        }\n-        _ => {\n-            Err(io::Error::new(io::ErrorKind::Other,\n-                               UnwindError(result_unwind)))\n-        }\n-    }\n-}\n-\n-extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n-                   arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n-    let cx = unsafe { &mut *(arg as *mut Context<'_>) };\n-    if cx.idx >= cx.frames.len() {\n-        return uw::_URC_NORMAL_STOP;\n-    }\n-\n-    let mut ip_before_insn = 0;\n-    let mut ip = unsafe {\n-        uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n-    };\n-    if !ip.is_null() && ip_before_insn == 0 {\n-        // this is a non-signaling frame, so `ip` refers to the address\n-        // after the calling instruction. account for that.\n-        ip = (ip as usize - 1) as *mut _;\n-    }\n-\n-    // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n-    // it appears to work fine without it, so we only use\n-    // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n-    // slightly more accurate stack trace in the process.\n-    //\n-    // This is often because panic involves the last instruction of a\n-    // function being \"call std::rt::begin_unwind\", with no ret\n-    // instructions after it. This means that the return instruction\n-    // pointer points *outside* of the calling function, and by\n-    // unwinding it we go back to the original function.\n-    let symaddr = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n-        ip\n-    } else {\n-        unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n-    };\n-\n-    cx.frames[cx.idx] = Frame {\n-        symbol_addr: symaddr as *mut u8,\n-        exact_position: ip as *mut u8,\n-        inline_context: 0,\n-    };\n-    cx.idx += 1;\n-\n-    uw::_URC_NO_REASON\n-}"}, {"sha": "11863e6454525b2c955b2103ac33dca3799a92ea", "filename": "src/libstd/sys/unix/backtrace/tracing/mod.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fmod.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,8 +0,0 @@\n-pub use self::imp::*;\n-\n-#[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-#[path = \"gcc_s.rs\"]\n-mod imp;\n-#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n-#[path = \"backtrace_fn.rs\"]\n-mod imp;"}, {"sha": "821623db2721e54216103b4d6532b4f1be37fbe2", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -27,8 +27,6 @@ pub mod weak;\n pub mod alloc;\n pub mod args;\n pub mod android;\n-#[cfg(feature = \"backtrace\")]\n-pub mod backtrace;\n pub mod cmath;\n pub mod condvar;\n pub mod env;"}, {"sha": "7d56b298997aa33631d953f2dbd2a24849d8f9bb", "filename": "src/libstd/sys/wasi/backtrace.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwasi%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwasi%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fbacktrace.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,27 +0,0 @@\n-use crate::io;\n-use crate::sys::unsupported;\n-use crate::sys_common::backtrace::Frame;\n-\n-pub struct BacktraceContext;\n-\n-pub fn unwind_backtrace(_frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n-    unsupported()\n-}\n-\n-pub fn resolve_symname<F>(_frame: Frame,\n-                          _callback: F,\n-                          _: &BacktraceContext) -> io::Result<()>\n-    where F: FnOnce(Option<&str>) -> io::Result<()>\n-{\n-    unsupported()\n-}\n-\n-pub fn foreach_symbol_fileline<F>(_: Frame,\n-                                  _: F,\n-                                  _: &BacktraceContext) -> io::Result<bool>\n-    where F: FnMut(&[u8], u32) -> io::Result<()>\n-{\n-    unsupported()\n-}"}, {"sha": "e22434439f5bba61cf96266afd29e8eafeb57633", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -21,8 +21,6 @@ use crate::os::raw::c_char;\n \n pub mod alloc;\n pub mod args;\n-#[cfg(feature = \"backtrace\")]\n-pub mod backtrace;\n #[path = \"../wasm/cmath.rs\"]\n pub mod cmath;\n #[path = \"../wasm/condvar.rs\"]"}, {"sha": "7d56b298997aa33631d953f2dbd2a24849d8f9bb", "filename": "src/libstd/sys/wasm/backtrace.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwasm%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwasm%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fbacktrace.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,27 +0,0 @@\n-use crate::io;\n-use crate::sys::unsupported;\n-use crate::sys_common::backtrace::Frame;\n-\n-pub struct BacktraceContext;\n-\n-pub fn unwind_backtrace(_frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n-    unsupported()\n-}\n-\n-pub fn resolve_symname<F>(_frame: Frame,\n-                          _callback: F,\n-                          _: &BacktraceContext) -> io::Result<()>\n-    where F: FnOnce(Option<&str>) -> io::Result<()>\n-{\n-    unsupported()\n-}\n-\n-pub fn foreach_symbol_fileline<F>(_: Frame,\n-                                  _: F,\n-                                  _: &BacktraceContext) -> io::Result<bool>\n-    where F: FnMut(&[u8], u32) -> io::Result<()>\n-{\n-    unsupported()\n-}"}, {"sha": "9ea8bd1653851326d8512c3b98ef6c9d8c884391", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -23,8 +23,6 @@ use crate::time::Duration;\n \n pub mod alloc;\n pub mod args;\n-#[cfg(feature = \"backtrace\")]\n-pub mod backtrace;\n pub mod cmath;\n pub mod env;\n pub mod fs;"}, {"sha": "7ac1f8122f781ce5e2a5a5bf04cbb12caa219851", "filename": "src/libstd/sys/windows/backtrace/backtrace_gnu.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fbacktrace_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fbacktrace_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fbacktrace_gnu.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,53 +0,0 @@\n-use crate::io;\n-use crate::sys::c;\n-use crate::path::PathBuf;\n-use crate::fs::{OpenOptions, File};\n-use crate::sys::ext::fs::OpenOptionsExt;\n-use crate::sys::handle::Handle;\n-\n-use libc::c_char;\n-use super::super::{fill_utf16_buf, os2path, to_u16s, wide_char_to_multi_byte};\n-\n-fn query_full_process_image_name() -> io::Result<PathBuf> {\n-    unsafe {\n-        let process_handle = Handle::new(c::OpenProcess(c::PROCESS_QUERY_INFORMATION,\n-                                                        c::FALSE,\n-                                                        c::GetCurrentProcessId()));\n-        fill_utf16_buf(|buf, mut sz| {\n-            if c::QueryFullProcessImageNameW(process_handle.raw(), 0, buf, &mut sz) == 0 {\n-                0\n-            } else {\n-                sz\n-            }\n-        }, os2path)\n-    }\n-}\n-\n-fn lock_and_get_executable_filename() -> io::Result<(PathBuf, File)> {\n-    // We query the current image name, open the file without FILE_SHARE_DELETE so it\n-    // can't be moved and then get the current image name again. If the names are the\n-    // same than we have successfully locked the file\n-    let image_name1 = query_full_process_image_name()?;\n-    let file = OpenOptions::new()\n-                .read(true)\n-                .share_mode(c::FILE_SHARE_READ | c::FILE_SHARE_WRITE)\n-                .open(&image_name1)?;\n-    let image_name2 = query_full_process_image_name()?;\n-\n-    if image_name1 != image_name2 {\n-        return Err(io::Error::new(io::ErrorKind::Other,\n-                                  \"executable moved while trying to lock it\"));\n-    }\n-\n-    Ok((image_name1, file))\n-}\n-\n-// Get the executable filename for libbacktrace\n-// This returns the path in the ANSI code page and a File which should remain open\n-// for as long as the path should remain valid\n-pub fn get_executable_filename() -> io::Result<(Vec<c_char>, File)> {\n-    let (executable, file) = lock_and_get_executable_filename()?;\n-    let u16_executable = to_u16s(executable.into_os_string())?;\n-    Ok((wide_char_to_multi_byte(c::CP_ACP, c::WC_NO_BEST_FIT_CHARS,\n-                                &u16_executable, true)?, file))\n-}"}, {"sha": "c5b0cc8721087d1e0ffcbbf86bfb12c8233179e4", "filename": "src/libstd/sys/windows/backtrace/mod.rs", "status": "removed", "additions": 0, "deletions": 355, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,355 +0,0 @@\n-//! As always, windows has something very different than unix, we mainly want\n-//! to avoid having to depend too much on libunwind for windows.\n-//!\n-//! If you google around, you'll find a fair bit of references to built-in\n-//! functions to get backtraces on windows. It turns out that most of these are\n-//! in an external library called dbghelp. I was unable to find this library\n-//! via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n-//! of it.\n-//!\n-//! You'll also find that there's a function called CaptureStackBackTrace\n-//! mentioned frequently (which is also easy to use), but sadly I didn't have a\n-//! copy of that function in my mingw install (maybe it was broken?). Instead,\n-//! this takes the route of using StackWalk64 in order to walk the stack.\n-\n-#![allow(deprecated)] // dynamic_lib\n-\n-use crate::io;\n-use crate::mem;\n-use crate::ptr;\n-use crate::sys::c;\n-use crate::sys::dynamic_lib::DynamicLibrary;\n-use crate::sys_common::backtrace::Frame;\n-\n-use libc::c_void;\n-\n-macro_rules! sym {\n-    ($lib:expr, $e:expr, $t:ident) => (\n-        $lib.symbol($e).map(|f| unsafe {\n-            $crate::mem::transmute::<usize, $t>(f)\n-        })\n-    )\n-}\n-\n-mod printing;\n-\n-#[cfg(target_env = \"gnu\")]\n-#[path = \"backtrace_gnu.rs\"]\n-pub mod gnu;\n-\n-pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n-use self::printing::{load_printing_fns_64, load_printing_fns_ex};\n-\n-pub fn unwind_backtrace(frames: &mut [Frame]) -> io::Result<(usize, BacktraceContext)> {\n-    let dbghelp = DynamicLibrary::open(\"dbghelp.dll\")?;\n-\n-    // Fetch the symbols necessary from dbghelp.dll\n-    let SymInitialize = sym!(dbghelp, \"SymInitialize\", SymInitializeFn)?;\n-    let SymCleanup = sym!(dbghelp, \"SymCleanup\", SymCleanupFn)?;\n-\n-    // StackWalkEx might not be present and we'll fall back to StackWalk64\n-    let sw_var = match sym!(dbghelp, \"StackWalkEx\", StackWalkExFn) {\n-        Ok(StackWalkEx) => {\n-            StackWalkVariant::StackWalkEx(StackWalkEx, load_printing_fns_ex(&dbghelp)?)\n-        }\n-        Err(e) => match sym!(dbghelp, \"StackWalk64\", StackWalk64Fn) {\n-            Ok(StackWalk64) => {\n-                StackWalkVariant::StackWalk64(StackWalk64, load_printing_fns_64(&dbghelp)?)\n-            }\n-            Err(..) => return Err(e),\n-        },\n-    };\n-\n-    // Allocate necessary structures for doing the stack walk\n-    let process = unsafe { c::GetCurrentProcess() };\n-\n-    let backtrace_context = BacktraceContext {\n-        handle: process,\n-        SymCleanup,\n-        StackWalkVariant: sw_var,\n-        dbghelp,\n-    };\n-\n-    // Initialize this process's symbols\n-    let ret = unsafe { SymInitialize(process, ptr::null_mut(), c::TRUE) };\n-    if ret != c::TRUE {\n-        return Ok((0, backtrace_context));\n-    }\n-\n-    // And now that we're done with all the setup, do the stack walking!\n-    match backtrace_context.StackWalkVariant {\n-        StackWalkVariant::StackWalkEx(StackWalkEx, _) => {\n-            set_frames(StackWalkEx, frames).map(|i| (i, backtrace_context))\n-        }\n-\n-        StackWalkVariant::StackWalk64(StackWalk64, _) => {\n-            set_frames(StackWalk64, frames).map(|i| (i, backtrace_context))\n-        }\n-    }\n-}\n-\n-fn set_frames<W: StackWalker>(StackWalk: W, frames: &mut [Frame]) -> io::Result<usize> {\n-    let process = unsafe { c::GetCurrentProcess() };\n-    let thread = unsafe { c::GetCurrentProcess() };\n-    let mut context: c::CONTEXT = unsafe { mem::zeroed() };\n-    unsafe { c::RtlCaptureContext(&mut context) };\n-    let mut frame = W::Item::new();\n-    let image = frame.init(&context);\n-\n-    let mut i = 0;\n-    while i < frames.len()\n-        && StackWalk.walk(image, process, thread, &mut frame, &mut context) == c::TRUE\n-    {\n-        let addr = frame.get_addr();\n-        frames[i] = Frame {\n-            symbol_addr: addr,\n-            exact_position: addr,\n-            inline_context: frame.get_inline_context(),\n-        };\n-\n-        i += 1\n-    }\n-    Ok(i)\n-}\n-\n-type SymInitializeFn = unsafe extern \"system\" fn(c::HANDLE, *mut c_void, c::BOOL) -> c::BOOL;\n-type SymCleanupFn = unsafe extern \"system\" fn(c::HANDLE) -> c::BOOL;\n-\n-type StackWalkExFn = unsafe extern \"system\" fn(\n-    c::DWORD,\n-    c::HANDLE,\n-    c::HANDLE,\n-    *mut c::STACKFRAME_EX,\n-    *mut c::CONTEXT,\n-    *mut c_void,\n-    *mut c_void,\n-    *mut c_void,\n-    *mut c_void,\n-    c::DWORD,\n-) -> c::BOOL;\n-\n-type StackWalk64Fn = unsafe extern \"system\" fn(\n-    c::DWORD,\n-    c::HANDLE,\n-    c::HANDLE,\n-    *mut c::STACKFRAME64,\n-    *mut c::CONTEXT,\n-    *mut c_void,\n-    *mut c_void,\n-    *mut c_void,\n-    *mut c_void,\n-) -> c::BOOL;\n-\n-trait StackWalker {\n-    type Item: StackFrame;\n-\n-    fn walk(\n-        &self,\n-        _: c::DWORD,\n-        _: c::HANDLE,\n-        _: c::HANDLE,\n-        _: &mut Self::Item,\n-        _: &mut c::CONTEXT\n-    ) -> c::BOOL;\n-}\n-\n-impl StackWalker for StackWalkExFn {\n-    type Item = c::STACKFRAME_EX;\n-    fn walk(\n-        &self,\n-        image: c::DWORD,\n-        process: c::HANDLE,\n-        thread: c::HANDLE,\n-        frame: &mut Self::Item,\n-        context: &mut c::CONTEXT,\n-    ) -> c::BOOL {\n-        unsafe {\n-            self(\n-                image,\n-                process,\n-                thread,\n-                frame,\n-                context,\n-                ptr::null_mut(),\n-                ptr::null_mut(),\n-                ptr::null_mut(),\n-                ptr::null_mut(),\n-                0,\n-            )\n-        }\n-    }\n-}\n-\n-impl StackWalker for StackWalk64Fn {\n-    type Item = c::STACKFRAME64;\n-    fn walk(\n-        &self,\n-        image: c::DWORD,\n-        process: c::HANDLE,\n-        thread: c::HANDLE,\n-        frame: &mut Self::Item,\n-        context: &mut c::CONTEXT,\n-    ) -> c::BOOL {\n-        unsafe {\n-            self(\n-                image,\n-                process,\n-                thread,\n-                frame,\n-                context,\n-                ptr::null_mut(),\n-                ptr::null_mut(),\n-                ptr::null_mut(),\n-                ptr::null_mut(),\n-            )\n-        }\n-    }\n-}\n-\n-trait StackFrame {\n-    fn new() -> Self;\n-    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD;\n-    fn get_addr(&self) -> *const u8;\n-    fn get_inline_context(&self) -> u32;\n-}\n-\n-impl StackFrame for c::STACKFRAME_EX {\n-    fn new() -> c::STACKFRAME_EX {\n-        unsafe { mem::zeroed() }\n-    }\n-\n-    #[cfg(target_arch = \"x86\")]\n-    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n-        self.AddrPC.Offset = ctx.Eip as u64;\n-        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrStack.Offset = ctx.Esp as u64;\n-        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrFrame.Offset = ctx.Ebp as u64;\n-        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        c::IMAGE_FILE_MACHINE_I386\n-    }\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n-        self.AddrPC.Offset = ctx.Rip as u64;\n-        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrStack.Offset = ctx.Rsp as u64;\n-        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrFrame.Offset = ctx.Rbp as u64;\n-        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        c::IMAGE_FILE_MACHINE_AMD64\n-    }\n-\n-    #[cfg(target_arch = \"arm\")]\n-    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n-        self.AddrPC.Offset = ctx.Pc as u64;\n-        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrStack.Offset = ctx.Sp as u64;\n-        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrFrame.Offset = ctx.R11 as u64;\n-        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        c::IMAGE_FILE_MACHINE_ARMNT\n-    }\n-\n-    #[cfg(target_arch = \"aarch64\")]\n-    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n-        self.AddrPC.Offset = ctx.Pc as u64;\n-        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrStack.Offset = ctx.Sp as u64;\n-        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrFrame.Offset = ctx.Fp as u64;\n-        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        c::IMAGE_FILE_MACHINE_ARM64\n-    }\n-\n-    fn get_addr(&self) -> *const u8 {\n-        (self.AddrPC.Offset - 1) as *const u8\n-    }\n-\n-    fn get_inline_context(&self) -> u32 {\n-        self.InlineFrameContext\n-    }\n-}\n-\n-impl StackFrame for c::STACKFRAME64 {\n-    fn new() -> c::STACKFRAME64 {\n-        unsafe { mem::zeroed() }\n-    }\n-\n-    #[cfg(target_arch = \"x86\")]\n-    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n-        self.AddrPC.Offset = ctx.Eip as u64;\n-        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrStack.Offset = ctx.Esp as u64;\n-        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrFrame.Offset = ctx.Ebp as u64;\n-        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        c::IMAGE_FILE_MACHINE_I386\n-    }\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n-        self.AddrPC.Offset = ctx.Rip as u64;\n-        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrStack.Offset = ctx.Rsp as u64;\n-        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrFrame.Offset = ctx.Rbp as u64;\n-        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        c::IMAGE_FILE_MACHINE_AMD64\n-    }\n-\n-    #[cfg(target_arch = \"arm\")]\n-    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n-        self.AddrPC.Offset = ctx.Pc as u64;\n-        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrStack.Offset = ctx.Sp as u64;\n-        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrFrame.Offset = ctx.R11 as u64;\n-        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        c::IMAGE_FILE_MACHINE_ARMNT\n-    }\n-\n-    #[cfg(target_arch = \"aarch64\")]\n-    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n-        self.AddrPC.Offset = ctx.Pc as u64;\n-        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrStack.Offset = ctx.Sp as u64;\n-        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        self.AddrFrame.Offset = ctx.Fp as u64;\n-        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-        c::IMAGE_FILE_MACHINE_ARM64\n-    }\n-\n-    fn get_addr(&self) -> *const u8 {\n-        (self.AddrPC.Offset - 1) as *const u8\n-    }\n-\n-    fn get_inline_context(&self) -> u32 {\n-        0\n-    }\n-}\n-\n-enum StackWalkVariant {\n-    StackWalkEx(StackWalkExFn, printing::PrintingFnsEx),\n-    StackWalk64(StackWalk64Fn, printing::PrintingFns64),\n-}\n-\n-pub struct BacktraceContext {\n-    handle: c::HANDLE,\n-    SymCleanup: SymCleanupFn,\n-    // Only used in printing for msvc and not gnu\n-    // The gnu version is effectively a ZST dummy.\n-    #[allow(dead_code)]\n-    StackWalkVariant: StackWalkVariant,\n-    // keeping DynamycLibrary loaded until its functions no longer needed\n-    #[allow(dead_code)]\n-    dbghelp: DynamicLibrary,\n-}\n-\n-impl Drop for BacktraceContext {\n-    fn drop(&mut self) {\n-        unsafe {\n-            (self.SymCleanup)(self.handle);\n-        }\n-    }\n-}"}, {"sha": "9497d51ac1799b0f361f14fd6b762b505781f9a2", "filename": "src/libstd/sys/windows/backtrace/printing/mod.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmod.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,24 +0,0 @@\n-#[cfg(target_env = \"msvc\")]\n-#[path = \"msvc.rs\"]\n-mod printing;\n-\n-#[cfg(target_env = \"gnu\")]\n-mod printing {\n-    pub use crate::sys_common::gnu::libbacktrace::{foreach_symbol_fileline, resolve_symname};\n-\n-    // dummy functions to mirror those present in msvc version.\n-    use crate::sys::dynamic_lib::DynamicLibrary;\n-    use crate::io;\n-    pub struct PrintingFnsEx {}\n-    pub struct PrintingFns64 {}\n-    pub fn load_printing_fns_ex(_: &DynamicLibrary) -> io::Result<PrintingFnsEx> {\n-        Ok(PrintingFnsEx{})\n-    }\n-    pub fn load_printing_fns_64(_: &DynamicLibrary) -> io::Result<PrintingFns64> {\n-        Ok(PrintingFns64{})\n-    }\n-}\n-\n-pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n-pub use self::printing::{load_printing_fns_ex, load_printing_fns_64,\n-                         PrintingFnsEx, PrintingFns64};"}, {"sha": "13a1512d0eb39e421a9dc4195bd43b46a6859776", "filename": "src/libstd/sys/windows/backtrace/printing/msvc.rs", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,208 +0,0 @@\n-use crate::ffi::CStr;\n-use crate::io;\n-use crate::mem;\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys::backtrace::StackWalkVariant;\n-use crate::sys::c;\n-use crate::sys::dynamic_lib::DynamicLibrary;\n-use crate::sys_common::backtrace::Frame;\n-\n-use libc::{c_char, c_ulong};\n-\n-// Structs holding printing functions and loaders for them\n-// Two versions depending on whether dbghelp.dll has StackWalkEx or not\n-// (the former being in newer Windows versions, the older being in Win7 and before)\n-pub struct PrintingFnsEx {\n-    resolve_symname: SymFromInlineContextFn,\n-    sym_get_line: SymGetLineFromInlineContextFn,\n-}\n-pub struct PrintingFns64 {\n-    resolve_symname: SymFromAddrFn,\n-    sym_get_line: SymGetLineFromAddr64Fn,\n-}\n-\n-pub fn load_printing_fns_ex(dbghelp: &DynamicLibrary) -> io::Result<PrintingFnsEx> {\n-    Ok(PrintingFnsEx {\n-        resolve_symname: sym!(dbghelp, \"SymFromInlineContext\", SymFromInlineContextFn)?,\n-        sym_get_line: sym!(\n-            dbghelp,\n-            \"SymGetLineFromInlineContext\",\n-            SymGetLineFromInlineContextFn\n-        )?,\n-    })\n-}\n-pub fn load_printing_fns_64(dbghelp: &DynamicLibrary) -> io::Result<PrintingFns64> {\n-    Ok(PrintingFns64 {\n-        resolve_symname: sym!(dbghelp, \"SymFromAddr\", SymFromAddrFn)?,\n-        sym_get_line: sym!(dbghelp, \"SymGetLineFromAddr64\", SymGetLineFromAddr64Fn)?,\n-    })\n-}\n-\n-type SymFromAddrFn =\n-    unsafe extern \"system\" fn(c::HANDLE, u64, *mut u64, *mut c::SYMBOL_INFO) -> c::BOOL;\n-type SymFromInlineContextFn =\n-    unsafe extern \"system\" fn(c::HANDLE, u64, c::ULONG, *mut u64, *mut c::SYMBOL_INFO) -> c::BOOL;\n-\n-type SymGetLineFromAddr64Fn =\n-    unsafe extern \"system\" fn(c::HANDLE, u64, *mut u32, *mut c::IMAGEHLP_LINE64) -> c::BOOL;\n-type SymGetLineFromInlineContextFn = unsafe extern \"system\" fn(\n-    c::HANDLE,\n-    u64,\n-    c::ULONG,\n-    u64,\n-    *mut c::DWORD,\n-    *mut c::IMAGEHLP_LINE64,\n-) -> c::BOOL;\n-\n-/// Converts a pointer to symbol to its string value.\n-pub fn resolve_symname<F>(frame: Frame, callback: F, context: &BacktraceContext) -> io::Result<()>\n-where\n-    F: FnOnce(Option<&str>) -> io::Result<()>,\n-{\n-    match context.StackWalkVariant {\n-        StackWalkVariant::StackWalkEx(_, ref fns) => resolve_symname_internal(\n-            |process: c::HANDLE,\n-             symbol_address: u64,\n-             inline_context: c::ULONG,\n-             info: *mut c::SYMBOL_INFO| unsafe {\n-                let mut displacement = 0u64;\n-                (fns.resolve_symname)(\n-                    process,\n-                    symbol_address,\n-                    inline_context,\n-                    &mut displacement,\n-                    info,\n-                )\n-            },\n-            frame,\n-            callback,\n-            context,\n-        ),\n-        StackWalkVariant::StackWalk64(_, ref fns) => resolve_symname_internal(\n-            |process: c::HANDLE,\n-             symbol_address: u64,\n-             _inline_context: c::ULONG,\n-             info: *mut c::SYMBOL_INFO| unsafe {\n-                let mut displacement = 0u64;\n-                (fns.resolve_symname)(process, symbol_address, &mut displacement, info)\n-            },\n-            frame,\n-            callback,\n-            context,\n-        ),\n-    }\n-}\n-\n-fn resolve_symname_internal<F, R>(\n-    mut symbol_resolver: R,\n-    frame: Frame,\n-    callback: F,\n-    context: &BacktraceContext,\n-) -> io::Result<()>\n-where\n-    F: FnOnce(Option<&str>) -> io::Result<()>,\n-    R: FnMut(c::HANDLE, u64, c::ULONG, *mut c::SYMBOL_INFO) -> c::BOOL,\n-{\n-    unsafe {\n-        let mut info: c::SYMBOL_INFO = mem::zeroed();\n-        info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n-        // the struct size in C.  the value is different to\n-        // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n-        // due to struct alignment.\n-        info.SizeOfStruct = 88;\n-\n-        let ret = symbol_resolver(\n-            context.handle,\n-            frame.symbol_addr as u64,\n-            frame.inline_context,\n-            &mut info,\n-        );\n-        let valid_range = if ret == c::TRUE && frame.symbol_addr as usize >= info.Address as usize {\n-            if info.Size != 0 {\n-                (frame.symbol_addr as usize) < info.Address as usize + info.Size as usize\n-            } else {\n-                true\n-            }\n-        } else {\n-            false\n-        };\n-        let symname = if valid_range {\n-            let ptr = info.Name.as_ptr() as *const c_char;\n-            CStr::from_ptr(ptr).to_str().ok()\n-        } else {\n-            None\n-        };\n-        callback(symname)\n-    }\n-}\n-\n-pub fn foreach_symbol_fileline<F>(\n-    frame: Frame,\n-    callback: F,\n-    context: &BacktraceContext,\n-) -> io::Result<bool>\n-where\n-    F: FnMut(&[u8], u32) -> io::Result<()>,\n-{\n-    match context.StackWalkVariant {\n-        StackWalkVariant::StackWalkEx(_, ref fns) => foreach_symbol_fileline_iternal(\n-            |process: c::HANDLE,\n-             frame_address: u64,\n-             inline_context: c::ULONG,\n-             line: *mut c::IMAGEHLP_LINE64| unsafe {\n-                let mut displacement = 0u32;\n-                (fns.sym_get_line)(\n-                    process,\n-                    frame_address,\n-                    inline_context,\n-                    0,\n-                    &mut displacement,\n-                    line,\n-                )\n-            },\n-            frame,\n-            callback,\n-            context,\n-        ),\n-        StackWalkVariant::StackWalk64(_, ref fns) => foreach_symbol_fileline_iternal(\n-            |process: c::HANDLE,\n-             frame_address: u64,\n-             _inline_context: c::ULONG,\n-             line: *mut c::IMAGEHLP_LINE64| unsafe {\n-                let mut displacement = 0u32;\n-                (fns.sym_get_line)(process, frame_address, &mut displacement, line)\n-            },\n-            frame,\n-            callback,\n-            context,\n-        ),\n-    }\n-}\n-\n-fn foreach_symbol_fileline_iternal<F, G>(\n-    mut line_getter: G,\n-    frame: Frame,\n-    mut callback: F,\n-    context: &BacktraceContext,\n-) -> io::Result<bool>\n-where\n-    F: FnMut(&[u8], u32) -> io::Result<()>,\n-    G: FnMut(c::HANDLE, u64, c::ULONG, *mut c::IMAGEHLP_LINE64) -> c::BOOL,\n-{\n-    unsafe {\n-        let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();\n-        line.SizeOfStruct = mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n-\n-        let ret = line_getter(\n-            context.handle,\n-            frame.exact_position as u64,\n-            frame.inline_context,\n-            &mut line,\n-        );\n-        if ret == c::TRUE {\n-            let name = CStr::from_ptr(line.Filename).to_bytes();\n-            callback(name, line.LineNumber as u32)?;\n-        }\n-        Ok(false)\n-    }\n-}"}, {"sha": "6ad338660c338c9ab662688a92770712adef9dc7", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 371, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -5,8 +5,6 @@\n #![unstable(issue = \"0\", feature = \"windows_c\")]\n \n use crate::os::raw::{c_int, c_uint, c_ulong, c_long, c_longlong, c_ushort, c_char};\n-#[cfg(target_arch = \"x86_64\")]\n-use crate::os::raw::c_ulonglong;\n use crate::ptr;\n \n use libc::{wchar_t, size_t, c_void};\n@@ -33,10 +31,6 @@ pub type WORD = u16;\n pub type CHAR = c_char;\n pub type ULONG_PTR = usize;\n pub type ULONG = c_ulong;\n-#[cfg(target_arch = \"x86_64\")]\n-pub type ULONGLONG = u64;\n-#[cfg(target_arch = \"x86_64\")]\n-pub type DWORDLONG = ULONGLONG;\n \n pub type LPBOOL = *mut BOOL;\n pub type LPBYTE = *mut BYTE;\n@@ -108,11 +102,6 @@ pub const SECURITY_SQOS_PRESENT: DWORD = 0x00100000;\n \n pub const FIONBIO: c_ulong = 0x8004667e;\n \n-#[cfg(target_arch = \"arm\")]\n-const ARM_MAX_BREAKPOINTS: usize = 8;\n-#[cfg(target_arch = \"arm\")]\n-const ARM_MAX_WATCHPOINTS: usize = 1;\n-\n #[repr(C)]\n #[derive(Copy)]\n pub struct WIN32_FIND_DATAW {\n@@ -270,22 +259,6 @@ pub const WAIT_OBJECT_0: DWORD = 0x00000000;\n pub const WAIT_TIMEOUT: DWORD = 258;\n pub const WAIT_FAILED: DWORD = 0xFFFFFFFF;\n \n-#[cfg(target_env = \"msvc\")]\n-#[cfg(feature = \"backtrace\")]\n-pub const MAX_SYM_NAME: usize = 2000;\n-#[cfg(target_arch = \"x86\")]\n-#[cfg(feature = \"backtrace\")]\n-pub const IMAGE_FILE_MACHINE_I386: DWORD = 0x014c;\n-#[cfg(target_arch = \"x86_64\")]\n-#[cfg(feature = \"backtrace\")]\n-pub const IMAGE_FILE_MACHINE_AMD64: DWORD = 0x8664;\n-#[cfg(target_arch = \"aarch64\")]\n-#[cfg(feature = \"backtrace\")]\n-pub const IMAGE_FILE_MACHINE_ARM64: DWORD = 0xAA64;\n-#[cfg(target_arch = \"arm\")]\n-#[cfg(feature = \"backtrace\")]\n-pub const IMAGE_FILE_MACHINE_ARMNT: DWORD = 0x01c4;\n-\n pub const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n pub const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n@@ -580,41 +553,6 @@ pub struct OVERLAPPED {\n     pub hEvent: HANDLE,\n }\n \n-#[repr(C)]\n-#[cfg(target_env = \"msvc\")]\n-#[cfg(feature = \"backtrace\")]\n-pub struct SYMBOL_INFO {\n-    pub SizeOfStruct: c_ulong,\n-    pub TypeIndex: c_ulong,\n-    pub Reserved: [u64; 2],\n-    pub Index: c_ulong,\n-    pub Size: c_ulong,\n-    pub ModBase: u64,\n-    pub Flags: c_ulong,\n-    pub Value: u64,\n-    pub Address: u64,\n-    pub Register: c_ulong,\n-    pub Scope: c_ulong,\n-    pub Tag: c_ulong,\n-    pub NameLen: c_ulong,\n-    pub MaxNameLen: c_ulong,\n-    // note that windows has this as 1, but it basically just means that\n-    // the name is inline at the end of the struct. For us, we just bump\n-    // the struct size up to MAX_SYM_NAME.\n-    pub Name: [c_char; MAX_SYM_NAME],\n-}\n-\n-#[repr(C)]\n-#[cfg(target_env = \"msvc\")]\n-#[cfg(feature = \"backtrace\")]\n-pub struct IMAGEHLP_LINE64 {\n-    pub SizeOfStruct: u32,\n-    pub Key: *const c_void,\n-    pub LineNumber: u32,\n-    pub Filename: *const c_char,\n-    pub Address: u64,\n-}\n-\n #[repr(C)]\n #[allow(dead_code)] // we only use some variants\n pub enum ADDRESS_MODE {\n@@ -624,280 +562,8 @@ pub enum ADDRESS_MODE {\n     AddrModeFlat,\n }\n \n-#[repr(C)]\n-#[cfg(feature = \"backtrace\")]\n-pub struct ADDRESS64 {\n-    pub Offset: u64,\n-    pub Segment: u16,\n-    pub Mode: ADDRESS_MODE,\n-}\n-\n-#[repr(C)]\n-#[cfg(feature = \"backtrace\")]\n-pub struct STACKFRAME_EX {\n-    pub AddrPC: ADDRESS64,\n-    pub AddrReturn: ADDRESS64,\n-    pub AddrFrame: ADDRESS64,\n-    pub AddrStack: ADDRESS64,\n-    pub AddrBStore: ADDRESS64,\n-    pub FuncTableEntry: *mut c_void,\n-    pub Params: [u64; 4],\n-    pub Far: BOOL,\n-    pub Virtual: BOOL,\n-    pub Reserved: [u64; 3],\n-    pub KdHelp: KDHELP64,\n-    pub StackFrameSize: DWORD,\n-    pub InlineFrameContext: DWORD,\n-}\n-\n-#[repr(C)]\n-#[cfg(feature = \"backtrace\")]\n-pub struct STACKFRAME64 {\n-    pub AddrPC: ADDRESS64,\n-    pub AddrReturn: ADDRESS64,\n-    pub AddrFrame: ADDRESS64,\n-    pub AddrStack: ADDRESS64,\n-    pub AddrBStore: ADDRESS64,\n-    pub FuncTableEntry: *mut c_void,\n-    pub Params: [u64; 4],\n-    pub Far: BOOL,\n-    pub Virtual: BOOL,\n-    pub Reserved: [u64; 3],\n-    pub KdHelp: KDHELP64,\n-}\n-\n-#[repr(C)]\n-#[cfg(feature = \"backtrace\")]\n-pub struct KDHELP64 {\n-    pub Thread: u64,\n-    pub ThCallbackStack: DWORD,\n-    pub ThCallbackBStore: DWORD,\n-    pub NextCallback: DWORD,\n-    pub FramePointer: DWORD,\n-    pub KiCallUserMode: u64,\n-    pub KeUserCallbackDispatcher: u64,\n-    pub SystemRangeStart: u64,\n-    pub KiUserExceptionDispatcher: u64,\n-    pub StackBase: u64,\n-    pub StackLimit: u64,\n-    pub Reserved: [u64; 5],\n-}\n-\n-#[cfg(target_arch = \"x86\")]\n-#[repr(C)]\n-pub struct CONTEXT {\n-    pub ContextFlags: DWORD,\n-    pub Dr0: DWORD,\n-    pub Dr1: DWORD,\n-    pub Dr2: DWORD,\n-    pub Dr3: DWORD,\n-    pub Dr6: DWORD,\n-    pub Dr7: DWORD,\n-    pub FloatSave: FLOATING_SAVE_AREA,\n-    pub SegGs: DWORD,\n-    pub SegFs: DWORD,\n-    pub SegEs: DWORD,\n-    pub SegDs: DWORD,\n-    pub Edi: DWORD,\n-    pub Esi: DWORD,\n-    pub Ebx: DWORD,\n-    pub Edx: DWORD,\n-    pub Ecx: DWORD,\n-    pub Eax: DWORD,\n-    pub Ebp: DWORD,\n-    pub Eip: DWORD,\n-    pub SegCs: DWORD,\n-    pub EFlags: DWORD,\n-    pub Esp: DWORD,\n-    pub SegSs: DWORD,\n-    pub ExtendedRegisters: [u8; 512],\n-}\n-\n-#[cfg(target_arch = \"x86\")]\n-#[repr(C)]\n-pub struct FLOATING_SAVE_AREA {\n-    pub ControlWord: DWORD,\n-    pub StatusWord: DWORD,\n-    pub TagWord: DWORD,\n-    pub ErrorOffset: DWORD,\n-    pub ErrorSelector: DWORD,\n-    pub DataOffset: DWORD,\n-    pub DataSelector: DWORD,\n-    pub RegisterArea: [u8; 80],\n-    pub Cr0NpxState: DWORD,\n-}\n-\n-#[cfg(target_arch = \"x86_64\")]\n-#[repr(C, align(16))]\n-pub struct CONTEXT {\n-    pub P1Home: DWORDLONG,\n-    pub P2Home: DWORDLONG,\n-    pub P3Home: DWORDLONG,\n-    pub P4Home: DWORDLONG,\n-    pub P5Home: DWORDLONG,\n-    pub P6Home: DWORDLONG,\n-\n-    pub ContextFlags: DWORD,\n-    pub MxCsr: DWORD,\n-\n-    pub SegCs: WORD,\n-    pub SegDs: WORD,\n-    pub SegEs: WORD,\n-    pub SegFs: WORD,\n-    pub SegGs: WORD,\n-    pub SegSs: WORD,\n-    pub EFlags: DWORD,\n-\n-    pub Dr0: DWORDLONG,\n-    pub Dr1: DWORDLONG,\n-    pub Dr2: DWORDLONG,\n-    pub Dr3: DWORDLONG,\n-    pub Dr6: DWORDLONG,\n-    pub Dr7: DWORDLONG,\n-\n-    pub Rax: DWORDLONG,\n-    pub Rcx: DWORDLONG,\n-    pub Rdx: DWORDLONG,\n-    pub Rbx: DWORDLONG,\n-    pub Rsp: DWORDLONG,\n-    pub Rbp: DWORDLONG,\n-    pub Rsi: DWORDLONG,\n-    pub Rdi: DWORDLONG,\n-    pub R8:  DWORDLONG,\n-    pub R9:  DWORDLONG,\n-    pub R10: DWORDLONG,\n-    pub R11: DWORDLONG,\n-    pub R12: DWORDLONG,\n-    pub R13: DWORDLONG,\n-    pub R14: DWORDLONG,\n-    pub R15: DWORDLONG,\n-\n-    pub Rip: DWORDLONG,\n-\n-    pub FltSave: FLOATING_SAVE_AREA,\n-\n-    pub VectorRegister: [M128A; 26],\n-    pub VectorControl: DWORDLONG,\n-\n-    pub DebugControl: DWORDLONG,\n-    pub LastBranchToRip: DWORDLONG,\n-    pub LastBranchFromRip: DWORDLONG,\n-    pub LastExceptionToRip: DWORDLONG,\n-    pub LastExceptionFromRip: DWORDLONG,\n-}\n-\n-#[cfg(target_arch = \"x86_64\")]\n-#[repr(C, align(16))]\n-pub struct M128A {\n-    pub Low:  c_ulonglong,\n-    pub High: c_longlong\n-}\n-\n-#[cfg(target_arch = \"x86_64\")]\n-#[repr(C, align(16))]\n-pub struct FLOATING_SAVE_AREA {\n-    _Dummy: [u8; 512] // FIXME: Fill this out\n-}\n-\n-#[cfg(target_arch = \"arm\")]\n-#[repr(C)]\n-pub struct CONTEXT {\n-    pub ContextFlags: ULONG,\n-    pub R0: ULONG,\n-    pub R1: ULONG,\n-    pub R2: ULONG,\n-    pub R3: ULONG,\n-    pub R4: ULONG,\n-    pub R5: ULONG,\n-    pub R6: ULONG,\n-    pub R7: ULONG,\n-    pub R8: ULONG,\n-    pub R9: ULONG,\n-    pub R10: ULONG,\n-    pub R11: ULONG,\n-    pub R12: ULONG,\n-    pub Sp: ULONG,\n-    pub Lr: ULONG,\n-    pub Pc: ULONG,\n-    pub Cpsr: ULONG,\n-    pub Fpscr: ULONG,\n-    pub Padding: ULONG,\n-    pub D: [u64; 32],\n-    pub Bvr: [ULONG; ARM_MAX_BREAKPOINTS],\n-    pub Bcr: [ULONG; ARM_MAX_BREAKPOINTS],\n-    pub Wvr: [ULONG; ARM_MAX_WATCHPOINTS],\n-    pub Wcr: [ULONG; ARM_MAX_WATCHPOINTS],\n-    pub Padding2: [ULONG; 2]\n-}\n-\n-// FIXME(#43348): This structure is used for backtrace only, and a fake\n-// definition is provided here only to allow rustdoc to pass type-check. This\n-// will not appear in the final documentation. This should be also defined for\n-// other architectures supported by Windows such as ARM, and for historical\n-// interest, maybe MIPS and PowerPC as well.\n-#[cfg(all(rustdoc, not(any(target_arch = \"x86_64\", target_arch = \"x86\",\n-      target_arch = \"aarch64\", target_arch = \"arm\"))))]\n pub enum CONTEXT {}\n \n-#[cfg(target_arch = \"aarch64\")]\n-pub const ARM64_MAX_BREAKPOINTS: usize = 8;\n-\n-#[cfg(target_arch = \"aarch64\")]\n-pub const ARM64_MAX_WATCHPOINTS: usize = 2;\n-\n-#[cfg(target_arch = \"aarch64\")]\n-#[repr(C)]\n-pub struct ARM64_NT_NEON128 {\n-    pub D: [f64; 2],\n-}\n-\n-#[cfg(target_arch = \"aarch64\")]\n-#[repr(C, align(16))]\n-pub struct CONTEXT {\n-    pub ContextFlags: DWORD,\n-    pub Cpsr: DWORD,\n-    pub X0: u64,\n-    pub X1: u64,\n-    pub X2: u64,\n-    pub X3: u64,\n-    pub X4: u64,\n-    pub X5: u64,\n-    pub X6: u64,\n-    pub X7: u64,\n-    pub X8: u64,\n-    pub X9: u64,\n-    pub X10: u64,\n-    pub X11: u64,\n-    pub X12: u64,\n-    pub X13: u64,\n-    pub X14: u64,\n-    pub X15: u64,\n-    pub X16: u64,\n-    pub X17: u64,\n-    pub X18: u64,\n-    pub X19: u64,\n-    pub X20: u64,\n-    pub X21: u64,\n-    pub X22: u64,\n-    pub X23: u64,\n-    pub X24: u64,\n-    pub X25: u64,\n-    pub X26: u64,\n-    pub X27: u64,\n-    pub X28: u64,\n-    pub Fp: u64,\n-    pub Lr: u64,\n-    pub Sp: u64,\n-    pub Pc: u64,\n-    pub V: [ARM64_NT_NEON128; 32],\n-    pub Fpcr: DWORD,\n-    pub Fpsr: DWORD,\n-    pub Bcr: [DWORD; ARM64_MAX_BREAKPOINTS],\n-    pub Bvr: [DWORD; ARM64_MAX_BREAKPOINTS],\n-    pub Wcr: [DWORD; ARM64_MAX_WATCHPOINTS],\n-    pub Wvr: [DWORD; ARM64_MAX_WATCHPOINTS],\n-}\n-\n #[repr(C)]\n pub struct SOCKADDR_STORAGE_LH {\n     pub ss_family: ADDRESS_FAMILY,\n@@ -1220,8 +886,6 @@ extern \"system\" {\n     pub fn FindNextFileW(findFile: HANDLE, findFileData: LPWIN32_FIND_DATAW)\n                          -> BOOL;\n     pub fn FindClose(findFile: HANDLE) -> BOOL;\n-    #[cfg(feature = \"backtrace\")]\n-    pub fn RtlCaptureContext(ctx: *mut CONTEXT);\n     pub fn getsockopt(s: SOCKET,\n                       level: c_int,\n                       optname: c_int,\n@@ -1252,10 +916,6 @@ extern \"system\" {\n                        res: *mut *mut ADDRINFOA) -> c_int;\n     pub fn freeaddrinfo(res: *mut ADDRINFOA);\n \n-    #[cfg(feature = \"backtrace\")]\n-    pub fn LoadLibraryW(name: LPCWSTR) -> HMODULE;\n-    #[cfg(feature = \"backtrace\")]\n-    pub fn FreeLibrary(handle: HMODULE) -> BOOL;\n     pub fn GetProcAddress(handle: HMODULE,\n                           name: LPCSTR) -> *mut c_void;\n     pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n@@ -1361,34 +1021,3 @@ compat_fn! {\n         panic!(\"rwlocks not available\")\n     }\n }\n-\n-#[cfg(all(target_env = \"gnu\", feature = \"backtrace\"))]\n-mod gnu {\n-    use super::*;\n-\n-    pub const PROCESS_QUERY_INFORMATION: DWORD = 0x0400;\n-\n-    pub const CP_ACP: UINT = 0;\n-\n-    pub const WC_NO_BEST_FIT_CHARS: DWORD = 0x00000400;\n-\n-    extern \"system\" {\n-        pub fn OpenProcess(dwDesiredAccess: DWORD,\n-                           bInheritHandle: BOOL,\n-                           dwProcessId: DWORD) -> HANDLE;\n-    }\n-\n-    compat_fn! {\n-        kernel32:\n-\n-        pub fn QueryFullProcessImageNameW(_hProcess: HANDLE,\n-                                          _dwFlags: DWORD,\n-                                          _lpExeName: LPWSTR,\n-                                          _lpdwSize: LPDWORD) -> BOOL {\n-            SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n-        }\n-    }\n-}\n-\n-#[cfg(all(target_env = \"gnu\", feature = \"backtrace\"))]\n-pub use self::gnu::*;"}, {"sha": "b9d5105cb73070e484055b050165eb3d42bfffe7", "filename": "src/libstd/sys/windows/dynamic_lib.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwindows%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys%2Fwindows%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fdynamic_lib.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,44 +0,0 @@\n-use crate::os::windows::prelude::*;\n-\n-use crate::ffi::{CString, OsStr};\n-use crate::io;\n-use crate::sys::c;\n-\n-pub struct DynamicLibrary {\n-    handle: c::HMODULE,\n-}\n-\n-impl DynamicLibrary {\n-    pub fn open(filename: &str) -> io::Result<DynamicLibrary> {\n-        let filename = OsStr::new(filename)\n-                             .encode_wide()\n-                             .chain(Some(0))\n-                             .collect::<Vec<_>>();\n-        let result = unsafe {\n-            c::LoadLibraryW(filename.as_ptr())\n-        };\n-        if result.is_null() {\n-            Err(io::Error::last_os_error())\n-        } else {\n-            Ok(DynamicLibrary { handle: result })\n-        }\n-    }\n-\n-    pub fn symbol(&self, symbol: &str) -> io::Result<usize> {\n-        let symbol = CString::new(symbol)?;\n-        unsafe {\n-            match c::GetProcAddress(self.handle, symbol.as_ptr()) as usize {\n-                0 => Err(io::Error::last_os_error()),\n-                n => Ok(n),\n-            }\n-        }\n-    }\n-}\n-\n-impl Drop for DynamicLibrary {\n-    fn drop(&mut self) {\n-        unsafe {\n-            c::FreeLibrary(self.handle);\n-        }\n-    }\n-}"}, {"sha": "1cb5553912981a532a4273d107855e543a69d6ae", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -14,13 +14,9 @@ pub use self::rand::hashmap_random_keys;\n \n pub mod alloc;\n pub mod args;\n-#[cfg(feature = \"backtrace\")]\n-pub mod backtrace;\n pub mod c;\n pub mod cmath;\n pub mod condvar;\n-#[cfg(feature = \"backtrace\")]\n-pub mod dynamic_lib;\n pub mod env;\n pub mod ext;\n pub mod fast_thread_local;"}, {"sha": "a01b31e948b4e0930f212645787b7a70737bea05", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 153, "deletions": 151, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -2,40 +2,17 @@\n /// supported platforms.\n \n use crate::env;\n-use crate::io::prelude::*;\n use crate::io;\n+use crate::io::prelude::*;\n+use crate::mem;\n use crate::path::{self, Path};\n use crate::ptr;\n-use crate::str;\n use crate::sync::atomic::{self, Ordering};\n use crate::sys::mutex::Mutex;\n \n-use rustc_demangle::demangle;\n-\n-pub use crate::sys::backtrace::{\n-    unwind_backtrace,\n-    resolve_symname,\n-    foreach_symbol_fileline,\n-    BacktraceContext\n-};\n-\n-#[cfg(target_pointer_width = \"64\")]\n-pub const HEX_WIDTH: usize = 18;\n-\n-#[cfg(target_pointer_width = \"32\")]\n-pub const HEX_WIDTH: usize = 10;\n-\n-/// Represents an item in the backtrace list. See `unwind_backtrace` for how\n-/// it is created.\n-#[derive(Debug, Copy, Clone)]\n-pub struct Frame {\n-    /// Exact address of the call that failed.\n-    pub exact_position: *const u8,\n-    /// Address of the enclosing function.\n-    pub symbol_addr: *const u8,\n-    /// Which inlined function is this frame referring to\n-    pub inline_context: u32,\n-}\n+use backtrace::{BytesOrWideString, Frame, Symbol};\n+\n+pub const HEX_WIDTH: usize = 2 + 2 * mem::size_of::<usize>();\n \n /// Max number of frames to print.\n const MAX_NB_FRAMES: usize = 100;\n@@ -49,7 +26,7 @@ pub fn print(w: &mut dyn Write, format: PrintFormat) -> io::Result<()> {\n     // test mode immediately return here to optimize away any references to the\n     // libbacktrace symbols\n     if cfg!(test) {\n-        return Ok(())\n+        return Ok(());\n     }\n \n     // Use a lock to prevent mixed output in multithreading context.\n@@ -63,75 +40,39 @@ pub fn print(w: &mut dyn Write, format: PrintFormat) -> io::Result<()> {\n }\n \n fn _print(w: &mut dyn Write, format: PrintFormat) -> io::Result<()> {\n-    let mut frames = [Frame {\n-        exact_position: ptr::null(),\n-        symbol_addr: ptr::null(),\n-        inline_context: 0,\n-    }; MAX_NB_FRAMES];\n-    let (nb_frames, context) = unwind_backtrace(&mut frames)?;\n-    let (skipped_before, skipped_after) =\n-        filter_frames(&frames[..nb_frames], format, &context);\n-    if skipped_before + skipped_after > 0 {\n-        writeln!(w, \"note: Some details are omitted, \\\n-                     run with `RUST_BACKTRACE=full` for a verbose backtrace.\")?;\n-    }\n     writeln!(w, \"stack backtrace:\")?;\n \n-    let filtered_frames = &frames[..nb_frames - skipped_after];\n-    for (index, frame) in filtered_frames.iter().skip(skipped_before).enumerate() {\n-        resolve_symname(*frame, |symname| {\n-            output(w, index, *frame, symname, format)\n-        }, &context)?;\n-        let has_more_filenames = foreach_symbol_fileline(*frame, |file, line| {\n-            output_fileline(w, file, line, format)\n-        }, &context)?;\n-        if has_more_filenames {\n-            w.write_all(b\" <... and possibly more>\")?;\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-/// Returns a number of frames to remove at the beginning and at the end of the\n-/// backtrace, according to the backtrace format.\n-fn filter_frames(frames: &[Frame],\n-                 format: PrintFormat,\n-                 context: &BacktraceContext) -> (usize, usize)\n-{\n-    if format == PrintFormat::Full {\n-        return (0, 0);\n-    }\n-\n-    let skipped_before = 0;\n-\n-    let skipped_after = frames.len() - frames.iter().position(|frame| {\n-        let mut is_marker = false;\n-        let _ = resolve_symname(*frame, |symname| {\n-            if let Some(mangled_symbol_name) = symname {\n-                // Use grep to find the concerned functions\n-                if mangled_symbol_name.contains(\"__rust_begin_short_backtrace\") {\n-                    is_marker = true;\n-                }\n+    let mut printer = Printer::new(format, w);\n+    unsafe {\n+        backtrace::trace_unsynchronized(|frame| {\n+            let mut hit = false;\n+            backtrace::resolve_frame_unsynchronized(frame, |symbol| {\n+                hit = true;\n+                printer.output(frame, Some(symbol));\n+            });\n+            if !hit {\n+                printer.output(frame, None);\n             }\n-            Ok(())\n-        }, context);\n-        is_marker\n-    }).unwrap_or(frames.len());\n-\n-    if skipped_before + skipped_after >= frames.len() {\n-        // Avoid showing completely empty backtraces\n-        return (0, 0);\n+            !printer.done\n+        });\n     }\n-\n-    (skipped_before, skipped_after)\n+    if printer.skipped {\n+        writeln!(\n+            w,\n+            \"note: Some details are omitted, \\\n+             run with `RUST_BACKTRACE=full` for a verbose backtrace.\"\n+        )?;\n+    }\n+    Ok(())\n }\n \n-\n /// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`.\n #[inline(never)]\n pub fn __rust_begin_short_backtrace<F, T>(f: F) -> T\n-    where F: FnOnce() -> T, F: Send, T: Send\n+where\n+    F: FnOnce() -> T,\n+    F: Send,\n+    T: Send,\n {\n     f()\n }\n@@ -156,88 +97,149 @@ pub fn log_enabled() -> Option<PrintFormat> {\n         _ => return Some(PrintFormat::Full),\n     }\n \n-    let val = env::var_os(\"RUST_BACKTRACE\").and_then(|x|\n+    let val = env::var_os(\"RUST_BACKTRACE\").and_then(|x| {\n         if &x == \"0\" {\n             None\n         } else if &x == \"full\" {\n             Some(PrintFormat::Full)\n         } else {\n             Some(PrintFormat::Short)\n         }\n+    });\n+    ENABLED.store(\n+        match val {\n+            Some(v) => v as isize,\n+            None => 1,\n+        },\n+        Ordering::SeqCst,\n     );\n-    ENABLED.store(match val {\n-        Some(v) => v as isize,\n-        None => 1,\n-    }, Ordering::SeqCst);\n     val\n }\n \n-/// Prints the symbol of the backtrace frame.\n-///\n-/// These output functions should now be used everywhere to ensure consistency.\n-/// You may want to also use `output_fileline`.\n-fn output(w: &mut dyn Write, idx: usize, frame: Frame,\n-              s: Option<&str>, format: PrintFormat) -> io::Result<()> {\n-    // Remove the `17: 0x0 - <unknown>` line.\n-    if format == PrintFormat::Short && frame.exact_position == ptr::null() {\n-        return Ok(());\n+struct Printer<'a, 'b> {\n+    format: PrintFormat,\n+    done: bool,\n+    skipped: bool,\n+    idx: usize,\n+    out: &'a mut (dyn Write + 'b),\n+}\n+\n+impl<'a, 'b> Printer<'a, 'b> {\n+    fn new(format: PrintFormat, out: &'a mut (dyn Write + 'b)) -> Printer<'a, 'b> {\n+        Printer { format, done: false, skipped: false, idx: 0, out }\n     }\n-    match format {\n-        PrintFormat::Full => write!(w,\n-                                    \"  {:2}: {:2$?} - \",\n-                                    idx,\n-                                    frame.exact_position,\n-                                    HEX_WIDTH)?,\n-        PrintFormat::Short => write!(w, \"  {:2}: \", idx)?,\n+\n+    /// Prints the symbol of the backtrace frame.\n+    ///\n+    /// These output functions should now be used everywhere to ensure consistency.\n+    /// You may want to also use `output_fileline`.\n+    fn output(&mut self, frame: &Frame, symbol: Option<&Symbol>) {\n+        if self.idx > MAX_NB_FRAMES {\n+            self.done = true;\n+            self.skipped = true;\n+            return;\n+        }\n+        if self._output(frame, symbol).is_err() {\n+            self.done = true;\n+        }\n+        self.idx += 1;\n     }\n-    match s {\n-        Some(string) => {\n-            let symbol = demangle(string);\n-            match format {\n-                PrintFormat::Full => write!(w, \"{}\", symbol)?,\n-                // strip the trailing hash if short mode\n-                PrintFormat::Short => write!(w, \"{:#}\", symbol)?,\n+\n+    fn _output(&mut self, frame: &Frame, symbol: Option<&Symbol>) -> io::Result<()> {\n+        if self.format == PrintFormat::Short {\n+            if let Some(sym) = symbol.and_then(|s| s.name()).and_then(|s| s.as_str()) {\n+                if sym.contains(\"__rust_begin_short_backtrace\") {\n+                    self.skipped = true;\n+                    self.done = true;\n+                    return Ok(());\n+                }\n+            }\n+\n+            // Remove the `17: 0x0 - <unknown>` line.\n+            if self.format == PrintFormat::Short && frame.ip() == ptr::null_mut() {\n+                self.skipped = true;\n+                return Ok(());\n             }\n         }\n-        None => w.write_all(b\"<unknown>\")?,\n-    }\n-    w.write_all(b\"\\n\")\n-}\n \n-/// Prints the filename and line number of the backtrace frame.\n-///\n-/// See also `output`.\n-#[allow(dead_code)]\n-fn output_fileline(w: &mut dyn Write,\n-                   file: &[u8],\n-                   line: u32,\n-                   format: PrintFormat) -> io::Result<()> {\n-    // prior line: \"  ##: {:2$} - func\"\n-    w.write_all(b\"\")?;\n-    match format {\n-        PrintFormat::Full => write!(w,\n-                                    \"           {:1$}\",\n-                                    \"\",\n-                                    HEX_WIDTH)?,\n-        PrintFormat::Short => write!(w, \"           \")?,\n-    }\n+        match self.format {\n+            PrintFormat::Full => {\n+                write!(self.out, \"  {:2}: {:2$?} - \", self.idx, frame.ip(), HEX_WIDTH)?\n+            }\n+            PrintFormat::Short => write!(self.out, \"  {:2}: \", self.idx)?,\n+        }\n \n-    let file = str::from_utf8(file).unwrap_or(\"<unknown>\");\n-    let file_path = Path::new(file);\n-    let mut already_printed = false;\n-    if format == PrintFormat::Short && file_path.is_absolute() {\n-        if let Ok(cwd) = env::current_dir() {\n-            if let Ok(stripped) = file_path.strip_prefix(&cwd) {\n-                if let Some(s) = stripped.to_str() {\n-                    write!(w, \"  at .{}{}:{}\", path::MAIN_SEPARATOR, s, line)?;\n-                    already_printed = true;\n+        match symbol.and_then(|s| s.name()) {\n+            Some(symbol) => {\n+                match self.format {\n+                    PrintFormat::Full => write!(self.out, \"{}\", symbol)?,\n+                    // strip the trailing hash if short mode\n+                    PrintFormat::Short => write!(self.out, \"{:#}\", symbol)?,\n                 }\n             }\n+            None => self.out.write_all(b\"<unknown>\")?,\n         }\n-    }\n-    if !already_printed {\n-        write!(w, \"  at {}:{}\", file, line)?;\n+        self.out.write_all(b\"\\n\")?;\n+        if let Some(sym) = symbol {\n+            self.output_fileline(sym)?;\n+        }\n+        Ok(())\n     }\n \n-    w.write_all(b\"\\n\")\n+    /// Prints the filename and line number of the backtrace frame.\n+    ///\n+    /// See also `output`.\n+    fn output_fileline(&mut self, symbol: &Symbol) -> io::Result<()> {\n+        #[cfg(windows)]\n+        let path_buf;\n+        let file = match symbol.filename_raw() {\n+            #[cfg(unix)]\n+            Some(BytesOrWideString::Bytes(bytes)) => {\n+                use crate::os::unix::prelude::*;\n+                Path::new(crate::ffi::OsStr::from_bytes(bytes))\n+            }\n+            #[cfg(not(unix))]\n+            Some(BytesOrWideString::Bytes(bytes)) => {\n+                Path::new(crate::str::from_utf8(bytes).unwrap_or(\"<unknown>\"))\n+            }\n+            #[cfg(windows)]\n+            Some(BytesOrWideString::Wide(wide)) => {\n+                use crate::os::windows::prelude::*;\n+                path_buf = crate::ffi::OsString::from_wide(wide);\n+                Path::new(&path_buf)\n+            }\n+            #[cfg(not(windows))]\n+            Some(BytesOrWideString::Wide(_wide)) => {\n+                Path::new(\"<unknown>\")\n+            }\n+            None => return Ok(()),\n+        };\n+        let line = match symbol.lineno() {\n+            Some(line) => line,\n+            None => return Ok(()),\n+        };\n+        // prior line: \"  ##: {:2$} - func\"\n+        self.out.write_all(b\"\")?;\n+        match self.format {\n+            PrintFormat::Full => write!(self.out, \"           {:1$}\", \"\", HEX_WIDTH)?,\n+            PrintFormat::Short => write!(self.out, \"           \")?,\n+        }\n+\n+        let mut already_printed = false;\n+        if self.format == PrintFormat::Short && file.is_absolute() {\n+            if let Ok(cwd) = env::current_dir() {\n+                if let Ok(stripped) = file.strip_prefix(&cwd) {\n+                    if let Some(s) = stripped.to_str() {\n+                        write!(self.out, \"  at .{}{}:{}\", path::MAIN_SEPARATOR, s, line)?;\n+                        already_printed = true;\n+                    }\n+                }\n+            }\n+        }\n+        if !already_printed {\n+            write!(self.out, \"  at {}:{}\", file.display(), line)?;\n+        }\n+\n+        self.out.write_all(b\"\\n\")\n+    }\n }"}, {"sha": "6cd050242dd950e6090f725a969dc157193418a0", "filename": "src/libstd/sys_common/gnu/libbacktrace.rs", "status": "removed", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,175 +0,0 @@\n-use backtrace_sys::backtrace_state;\n-\n-use crate::ffi::CStr;\n-use crate::io;\n-use crate::mem;\n-use crate::ptr;\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-\n-pub fn foreach_symbol_fileline<F>(frame: Frame,\n-                                  mut f: F,\n-                                  _: &BacktraceContext) -> io::Result<bool>\n-where F: FnMut(&[u8], u32) -> io::Result<()>\n-{\n-    // pcinfo may return an arbitrary number of file:line pairs,\n-    // in the order of stack trace (i.e., inlined calls first).\n-    // in order to avoid allocation, we stack-allocate a fixed size of entries.\n-    const FILELINE_SIZE: usize = 32;\n-    let mut fileline_buf = [(ptr::null(), !0); FILELINE_SIZE];\n-    let ret;\n-    let fileline_count = {\n-        let state = unsafe { init_state() };\n-        if state.is_null() {\n-            return Err(io::Error::new(\n-                io::ErrorKind::Other,\n-                \"failed to allocate libbacktrace state\")\n-            )\n-        }\n-        let mut fileline_win: &mut [FileLine] = &mut fileline_buf;\n-        let fileline_addr = &mut fileline_win as *mut &mut [FileLine];\n-        ret = unsafe {\n-            backtrace_sys::backtrace_pcinfo(\n-                state,\n-                frame.exact_position as libc::uintptr_t,\n-                pcinfo_cb,\n-                error_cb,\n-                fileline_addr as *mut libc::c_void,\n-            )\n-        };\n-        FILELINE_SIZE - fileline_win.len()\n-    };\n-    if ret == 0 {\n-        for &(file, line) in &fileline_buf[..fileline_count] {\n-            if file.is_null() { continue; } // just to be sure\n-            let file = unsafe { CStr::from_ptr(file).to_bytes() };\n-            f(file, line)?;\n-        }\n-        Ok(fileline_count == FILELINE_SIZE)\n-    } else {\n-        Ok(false)\n-    }\n-}\n-\n-/// Converts a pointer to symbol to its string value.\n-pub fn resolve_symname<F>(frame: Frame,\n-                          callback: F,\n-                          _: &BacktraceContext) -> io::Result<()>\n-    where F: FnOnce(Option<&str>) -> io::Result<()>\n-{\n-    let symname = {\n-        let state = unsafe { init_state() };\n-        if state.is_null() {\n-            return Err(io::Error::new(\n-                io::ErrorKind::Other,\n-                \"failed to allocate libbacktrace state\")\n-            )\n-        }\n-        let mut data: *const libc::c_char = ptr::null();\n-        let data_addr = &mut data as *mut *const libc::c_char;\n-        let ret = unsafe {\n-            backtrace_sys::backtrace_syminfo(\n-                state,\n-                frame.symbol_addr as libc::uintptr_t,\n-                syminfo_cb,\n-                error_cb,\n-                data_addr as *mut libc::c_void,\n-            )\n-        };\n-        if ret == 0 || data.is_null() {\n-            None\n-        } else {\n-            unsafe {\n-                CStr::from_ptr(data).to_str().ok()\n-            }\n-        }\n-    };\n-    callback(symname)\n-}\n-\n-////////////////////////////////////////////////////////////////////////\n-// helper callbacks\n-////////////////////////////////////////////////////////////////////////\n-\n-type FileLine = (*const libc::c_char, u32);\n-\n-extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,\n-                   _errnum: libc::c_int) {\n-    // do nothing for now\n-}\n-extern fn syminfo_cb(data: *mut libc::c_void,\n-                     _pc: libc::uintptr_t,\n-                     symname: *const libc::c_char,\n-                     _symval: libc::uintptr_t,\n-                     _symsize: libc::uintptr_t) {\n-    let slot = data as *mut *const libc::c_char;\n-    unsafe { *slot = symname; }\n-}\n-extern fn pcinfo_cb(data: *mut libc::c_void,\n-                    _pc: libc::uintptr_t,\n-                    filename: *const libc::c_char,\n-                    lineno: libc::c_int,\n-                    _function: *const libc::c_char) -> libc::c_int {\n-    if !filename.is_null() {\n-        let slot = data as *mut &mut [FileLine];\n-        let buffer = unsafe {ptr::read(slot)};\n-\n-        // if the buffer is not full, add file:line to the buffer\n-        // and adjust the buffer for next possible calls to pcinfo_cb.\n-        if !buffer.is_empty() {\n-            buffer[0] = (filename, lineno as u32);\n-            unsafe { ptr::write(slot, &mut buffer[1..]); }\n-        }\n-    }\n-\n-    0\n-}\n-\n-// The libbacktrace API supports creating a state, but it does not\n-// support destroying a state. I personally take this to mean that a\n-// state is meant to be created and then live forever.\n-//\n-// I would love to register an at_exit() handler which cleans up this\n-// state, but libbacktrace provides no way to do so.\n-//\n-// With these constraints, this function has a statically cached state\n-// that is calculated the first time this is requested. Remember that\n-// backtracing all happens serially (one global lock).\n-//\n-// Things don't work so well on not-Linux since libbacktrace can't track\n-// down that executable this is. We at one point used env::current_exe but\n-// it turns out that there are some serious security issues with that\n-// approach.\n-//\n-// Specifically, on certain platforms like BSDs, a malicious actor can cause\n-// an arbitrary file to be placed at the path returned by current_exe.\n-// libbacktrace does not behave defensively in the presence of ill-formed\n-// DWARF information, and has been demonstrated to segfault in at least one\n-// case. There is no evidence at the moment to suggest that a more carefully\n-// constructed file can't cause arbitrary code execution. As a result of all\n-// of this, we don't hint libbacktrace with the path to the current process.\n-unsafe fn init_state() -> *mut backtrace_state {\n-    static mut STATE: *mut backtrace_state = ptr::null_mut();\n-    if !STATE.is_null() { return STATE  }\n-\n-    let filename = match crate::sys::backtrace::gnu::get_executable_filename() {\n-        Ok((filename, file)) => {\n-            // filename is purposely leaked here since libbacktrace requires\n-            // it to stay allocated permanently, file is also leaked so that\n-            // the file stays locked\n-            let filename_ptr = filename.as_ptr();\n-            mem::forget(filename);\n-            mem::forget(file);\n-            filename_ptr\n-        },\n-        Err(_) => ptr::null(),\n-    };\n-\n-    STATE = backtrace_sys::backtrace_create_state(\n-        filename,\n-        0,\n-        error_cb,\n-        ptr::null_mut(),\n-    );\n-    STATE\n-}"}, {"sha": "d6959697f2a3d5ee0f7d8c7095b6bb756b76b3f1", "filename": "src/libstd/sys_common/gnu/mod.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys_common%2Fgnu%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483567e097c7634afa745fe5c59abc0e75026385/src%2Flibstd%2Fsys_common%2Fgnu%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fgnu%2Fmod.rs?ref=483567e097c7634afa745fe5c59abc0e75026385", "patch": "@@ -1,5 +0,0 @@\n-#![allow(missing_docs)]\n-#![allow(non_camel_case_types)]\n-#![allow(non_snake_case)]\n-\n-pub mod libbacktrace;"}, {"sha": "c4daedefd8e6d20c34dc088108eb613678a0c2d5", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -77,12 +77,6 @@ cfg_if! {\n     }\n }\n \n-#[cfg(feature = \"backtrace\")]\n-#[cfg(any(all(unix, not(target_os = \"emscripten\")),\n-          all(windows, target_env = \"gnu\"),\n-          target_os = \"redox\"))]\n-pub mod gnu;\n-\n // common error constructors\n \n /// A trait for viewing representations from std types"}, {"sha": "18d682640db011ce963cb5136632e287a297d215", "filename": "src/tools/rustc-workspace-hack/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -38,6 +38,7 @@ features = [\n   \"objbase\",\n   \"profileapi\",\n   \"processenv\",\n+  \"processthreadsapi\",\n   \"psapi\",\n   \"schannel\",\n   \"securitybaseapi\","}, {"sha": "ad3ac986c94f6c8f6561ff646e5bde5b1fe9178e", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -64,6 +64,7 @@ const WHITELIST: &[Crate<'_>] = &[\n     Crate(\"aho-corasick\"),\n     Crate(\"arrayvec\"),\n     Crate(\"atty\"),\n+    Crate(\"autocfg\"),\n     Crate(\"backtrace\"),\n     Crate(\"backtrace-sys\"),\n     Crate(\"bitflags\"),"}, {"sha": "837be69f7caddff7834166ed1eaf7bfee410f659", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572892c324cde896df0c4a1e9ed4896b1832a4fd/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=572892c324cde896df0c4a1e9ed4896b1832a4fd", "patch": "@@ -61,6 +61,7 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"src/libstd/net/test.rs\",\n     \"src/libstd/sys_common/mod.rs\",\n     \"src/libstd/sys_common/net.rs\",\n+    \"src/libstd/sys_common/backtrace.rs\",\n     \"src/libterm\", // Not sure how to make this crate portable, but test crate needs it.\n     \"src/libtest\", // Probably should defer to unstable `std::sys` APIs.\n     \"src/libstd/sync/mpsc\", // some tests are only run on non-emscripten"}]}