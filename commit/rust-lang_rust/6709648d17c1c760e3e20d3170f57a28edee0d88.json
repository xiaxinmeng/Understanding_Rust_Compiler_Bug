{"sha": "6709648d17c1c760e3e20d3170f57a28edee0d88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3MDk2NDhkMTdjMWM3NjBlM2UyMGQzMTcwZjU3YTI4ZWRlZTBkODg=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-27T12:56:22Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-25T10:23:37Z"}, "message": "Use more of OwnerNode.", "tree": {"sha": "51faf66c004d0aad65b406a106ab7a36a1afd87d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51faf66c004d0aad65b406a106ab7a36a1afd87d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6709648d17c1c760e3e20d3170f57a28edee0d88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6709648d17c1c760e3e20d3170f57a28edee0d88", "html_url": "https://github.com/rust-lang/rust/commit/6709648d17c1c760e3e20d3170f57a28edee0d88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6709648d17c1c760e3e20d3170f57a28edee0d88/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b88083a58c557d7f7f2289333f45944785465cf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b88083a58c557d7f7f2289333f45944785465cf1", "html_url": "https://github.com/rust-lang/rust/commit/b88083a58c557d7f7f2289333f45944785465cf1"}], "stats": {"total": 97, "additions": 43, "deletions": 54}, "files": [{"sha": "60dddce2f5bfec25c4e80b7d9766ae6ded3cc9e8", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 43, "deletions": 54, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6709648d17c1c760e3e20d3170f57a28edee0d88/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6709648d17c1c760e3e20d3170f57a28edee0d88/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=6709648d17c1c760e3e20d3170f57a28edee0d88", "patch": "@@ -1,6 +1,6 @@\n use self::collector::NodeCollector;\n \n-use crate::hir::{AttributeMap, IndexedHir};\n+use crate::hir::{AttributeMap, IndexedHir, Owner};\n use crate::ty::TyCtxt;\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -121,13 +121,13 @@ pub struct ParentOwnerIterator<'map, 'hir> {\n }\n \n impl<'hir> Iterator for ParentOwnerIterator<'_, 'hir> {\n-    type Item = (HirId, Node<'hir>);\n+    type Item = (HirId, OwnerNode<'hir>);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if self.current_id.local_id.index() != 0 {\n             self.current_id.local_id = ItemLocalId::new(0);\n-            if let Some(node) = self.map.find(self.current_id) {\n-                return Some((self.current_id, node));\n+            if let Some(node) = self.map.tcx.hir_owner(self.current_id.owner) {\n+                return Some((self.current_id, node.node));\n             }\n         }\n         if self.current_id == CRATE_HIR_ID {\n@@ -144,8 +144,8 @@ impl<'hir> Iterator for ParentOwnerIterator<'_, 'hir> {\n             self.current_id = HirId::make_owner(parent_id);\n \n             // If this `HirId` doesn't have an entry, skip it and look for its `parent_id`.\n-            if let Some(node) = self.map.find(self.current_id) {\n-                return Some((self.current_id, node));\n+            if let Some(node) = self.map.tcx.hir_owner(self.current_id.owner) {\n+                return Some((self.current_id, node.node));\n             }\n         }\n     }\n@@ -331,10 +331,12 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n-        self.get_if_local(id).and_then(|node| match &node {\n-            Node::ImplItem(impl_item) => Some(&impl_item.generics),\n-            Node::TraitItem(trait_item) => Some(&trait_item.generics),\n-            Node::Item(Item {\n+        let id = id.as_local()?;\n+        let node = self.tcx.hir_owner(id)?;\n+        match node.node {\n+            OwnerNode::ImplItem(impl_item) => Some(&impl_item.generics),\n+            OwnerNode::TraitItem(trait_item) => Some(&trait_item.generics),\n+            OwnerNode::Item(Item {\n                 kind:\n                     ItemKind::Fn(_, generics, _)\n                     | ItemKind::TyAlias(_, generics)\n@@ -347,35 +349,23 @@ impl<'hir> Map<'hir> {\n                 ..\n             }) => Some(generics),\n             _ => None,\n-        })\n+        }\n     }\n \n     pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n-        match self.find(id.hir_id()).unwrap() {\n-            Node::Item(item) => item,\n-            _ => bug!(),\n-        }\n+        self.tcx.hir_owner(id.def_id).unwrap().node.expect_item()\n     }\n \n     pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n-        match self.find(id.hir_id()).unwrap() {\n-            Node::TraitItem(item) => item,\n-            _ => bug!(),\n-        }\n+        self.tcx.hir_owner(id.def_id).unwrap().node.expect_trait_item()\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n-        match self.find(id.hir_id()).unwrap() {\n-            Node::ImplItem(item) => item,\n-            _ => bug!(),\n-        }\n+        self.tcx.hir_owner(id.def_id).unwrap().node.expect_impl_item()\n     }\n \n     pub fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        match self.find(id.hir_id()).unwrap() {\n-            Node::ForeignItem(item) => item,\n-            _ => bug!(),\n-        }\n+        self.tcx.hir_owner(id.def_id).unwrap().node.expect_foreign_item()\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n@@ -519,10 +509,12 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n-        let hir_id = self.local_def_id_to_hir_id(module);\n-        match self.get(hir_id) {\n-            Node::Item(&Item { span, kind: ItemKind::Mod(ref m), .. }) => (m, span, hir_id),\n-            Node::Crate(item) => (&item, item.inner, hir_id),\n+        let hir_id = HirId::make_owner(module);\n+        match self.tcx.hir_owner(module).map(|o| o.node) {\n+            Some(OwnerNode::Item(&Item { span, kind: ItemKind::Mod(ref m), .. })) => {\n+                (m, span, hir_id)\n+            }\n+            Some(OwnerNode::Crate(item)) => (item, item.inner, hir_id),\n             node => panic!(\"not a module: {:?}\", node),\n         }\n     }\n@@ -659,24 +651,20 @@ impl<'hir> Map<'hir> {\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n-        for (hir_id, node) in self.parent_owner_iter(hir_id) {\n-            if let Node::Crate(_)\n-            | Node::Item(_)\n-            | Node::ForeignItem(_)\n-            | Node::TraitItem(_)\n-            | Node::ImplItem(_) = node\n-            {\n-                return hir_id;\n-            }\n+        if let Some((hir_id, _node)) = self.parent_owner_iter(hir_id).next() {\n+            // A MacroDef does not have children.\n+            debug_assert!(!matches!(_node, OwnerNode::MacroDef(_)));\n+            hir_id\n+        } else {\n+            CRATE_HIR_ID\n         }\n-        CRATE_HIR_ID\n     }\n \n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub(super) fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n         for (hir_id, node) in self.parent_owner_iter(hir_id) {\n-            if let Node::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n+            if let OwnerNode::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n                 return hir_id;\n             }\n         }\n@@ -749,31 +737,32 @@ impl<'hir> Map<'hir> {\n \n     pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n-        if let Some(node) = self.find(parent) {\n-            if let Node::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }) = node {\n+        if let Some(node) = self.tcx.hir_owner(self.local_def_id(parent)) {\n+            if let OwnerNode::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }) = node.node\n+            {\n                 return *abi;\n             }\n         }\n         bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n     }\n \n     pub fn expect_item(&self, id: HirId) -> &'hir Item<'hir> {\n-        match self.find(id) {\n-            Some(Node::Item(item)) => item,\n+        match self.tcx.hir_owner(id.expect_owner()) {\n+            Some(Owner { node: OwnerNode::Item(item) }) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_impl_item(&self, id: HirId) -> &'hir ImplItem<'hir> {\n-        match self.find(id) {\n-            Some(Node::ImplItem(item)) => item,\n+        match self.tcx.hir_owner(id.expect_owner()) {\n+            Some(Owner { node: OwnerNode::ImplItem(item) }) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_trait_item(&self, id: HirId) -> &'hir TraitItem<'hir> {\n-        match self.find(id) {\n-            Some(Node::TraitItem(item)) => item,\n+        match self.tcx.hir_owner(id.expect_owner()) {\n+            Some(Owner { node: OwnerNode::TraitItem(item) }) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(id)),\n         }\n     }\n@@ -786,15 +775,15 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn expect_foreign_item(&self, id: HirId) -> &'hir ForeignItem<'hir> {\n-        match self.find(id) {\n-            Some(Node::ForeignItem(item)) => item,\n+        match self.tcx.hir_owner(id.expect_owner()) {\n+            Some(Owner { node: OwnerNode::ForeignItem(item) }) => item,\n             _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_macro_def(&self, id: HirId) -> &'hir MacroDef<'hir> {\n-        match self.find(id) {\n-            Some(Node::MacroDef(macro_def)) => macro_def,\n+        match self.tcx.hir_owner(id.expect_owner()) {\n+            Some(Owner { node: OwnerNode::MacroDef(macro_def) }) => macro_def,\n             _ => bug!(\"expected macro def, found {}\", self.node_to_string(id)),\n         }\n     }"}]}