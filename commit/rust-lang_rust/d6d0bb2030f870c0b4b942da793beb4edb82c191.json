{"sha": "d6d0bb2030f870c0b4b942da793beb4edb82c191", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZDBiYjIwMzBmODcwYzBiNGI5NDJkYTc5M2JlYjRlZGI4MmMxOTE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-12-15T16:17:52Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-12-15T21:43:09Z"}, "message": "Added `-Z print-region-graph` debugging option; produces graphviz\nvisualization of region inference constraint graph.\n\nOptionally uses environment variables `RUST_REGION_GRAPH=<path_template>`\nand `RUST_REGION_GRAPH_NODE=<node-id>` to select which file to output\nto and which AST node to print.\n\nNote that in some cases of method AST's, the identification of AST\nnode is based on the id for the *body* of the method; this is largely\ndue to having the body node-id already available at the relevant point\nin the control-flow of rustc in its current incarnation. Ideally we\nwould handle identifying AST's by name in addition to node-id,\ne.g. the same way that the pretty-printer supports path suffixes as\nwell as node-ids for identifying subtrees to print.", "tree": {"sha": "c65101446101808feeb638177fdf9209e21483ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c65101446101808feeb638177fdf9209e21483ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6d0bb2030f870c0b4b942da793beb4edb82c191", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6d0bb2030f870c0b4b942da793beb4edb82c191", "html_url": "https://github.com/rust-lang/rust/commit/d6d0bb2030f870c0b4b942da793beb4edb82c191", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6d0bb2030f870c0b4b942da793beb4edb82c191/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5e0624a3216a9cf155370a71c9901e56638fa0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5e0624a3216a9cf155370a71c9901e56638fa0d", "html_url": "https://github.com/rust-lang/rust/commit/a5e0624a3216a9cf155370a71c9901e56638fa0d"}], "stats": {"total": 296, "additions": 277, "deletions": 19}, "files": [{"sha": "3a84712016eaeb4fc1a9c4b634ae71ddb7206ed2", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=d6d0bb2030f870c0b4b942da793beb4edb82c191", "patch": "@@ -814,8 +814,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.region_vars.new_bound(debruijn)\n     }\n \n-    pub fn resolve_regions_and_report_errors(&self) {\n-        let errors = self.region_vars.resolve_regions();\n+    pub fn resolve_regions_and_report_errors(&self, subject_node_id: ast::NodeId) {\n+        let errors = self.region_vars.resolve_regions(subject_node_id);\n         self.report_region_errors(&errors); // see error_reporting.rs\n     }\n "}, {"sha": "7be3ec158625c2a79c9162bec1c93a3e24117ec6", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=d6d0bb2030f870c0b4b942da793beb4edb82c191", "patch": "@@ -0,0 +1,227 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module provides linkage between libgraphviz traits and\n+//! `rustc::middle::typeck::infer::region_inference`, generating a\n+//! rendering of the graph represented by the list of `Constraint`\n+//! instances (which make up the edges of the graph), as well as the\n+//! origin for each constraint (which are attached to the labels on\n+//! each edge).\n+\n+/// For clarity, rename the graphviz crate locally to dot.\n+use graphviz as dot;\n+\n+use middle::ty;\n+use super::Constraint;\n+use middle::typeck::infer::SubregionOrigin;\n+use middle::typeck::infer::region_inference::RegionVarBindings;\n+use session::config;\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::ppaux::Repr;\n+\n+use std::collections::hash_map::Vacant;\n+use std::io::{mod, File};\n+use std::os;\n+use std::sync::atomic;\n+use syntax::ast;\n+\n+fn print_help_message() {\n+    println!(\"\\\n+-Z print-region-graph by default prints a region constraint graph for every \\n\\\n+function body, to the path `/tmp/constraints.nodeXXX.dot`, where the XXX is \\n\\\n+replaced with the node id of the function under analysis.                   \\n\\\n+                                                                            \\n\\\n+To select one particular function body, set `RUST_REGION_GRAPH_NODE=XXX`,   \\n\\\n+where XXX is the node id desired.                                           \\n\\\n+                                                                            \\n\\\n+To generate output to some path other than the default                      \\n\\\n+`/tmp/constraints.nodeXXX.dot`, set `RUST_REGION_GRAPH=/path/desired.dot`;  \\n\\\n+occurrences of the character `%` in the requested path will be replaced with\\n\\\n+the node id of the function under analysis.                                 \\n\\\n+                                                                            \\n\\\n+(Since you requested help via RUST_REGION_GRAPH=help, no region constraint  \\n\\\n+graphs will be printed.                                                     \\n\\\n+\");\n+}\n+\n+pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a, 'tcx>,\n+                                             subject_node: ast::NodeId) {\n+    let tcx = region_vars.tcx;\n+\n+    if !region_vars.tcx.sess.debugging_opt(config::PRINT_REGION_GRAPH) {\n+        return;\n+    }\n+\n+    let requested_node : Option<ast::NodeId> =\n+        os::getenv(\"RUST_REGION_GRAPH_NODE\").and_then(|s|from_str(s.as_slice()));\n+\n+    if requested_node.is_some() && requested_node != Some(subject_node) {\n+        return;\n+    }\n+\n+    let requested_output = os::getenv(\"RUST_REGION_GRAPH\");\n+    debug!(\"requested_output: {} requested_node: {}\",\n+           requested_output, requested_node);\n+\n+    let output_path = {\n+        let output_template = match requested_output {\n+            Some(ref s) if s.as_slice() == \"help\" => {\n+                static PRINTED_YET : atomic::AtomicBool = atomic::INIT_ATOMIC_BOOL;\n+                if !PRINTED_YET.load(atomic::SeqCst) {\n+                    print_help_message();\n+                    PRINTED_YET.store(true, atomic::SeqCst);\n+                }\n+                return;\n+            }\n+\n+            Some(other_path) => other_path,\n+            None => \"/tmp/constraints.node%.dot\".to_string(),\n+        };\n+\n+        if output_template.len() == 0 {\n+            tcx.sess.bug(\"empty string provided as RUST_REGION_GRAPH\");\n+        }\n+\n+        if output_template.contains_char('%') {\n+            let mut new_str = String::new();\n+            for c in output_template.chars() {\n+                if c == '%' {\n+                    new_str.push_str(subject_node.to_string().as_slice());\n+                } else {\n+                    new_str.push(c);\n+                }\n+            }\n+            new_str\n+        } else {\n+            output_template\n+        }\n+    };\n+\n+    let constraints = &*region_vars.constraints.borrow();\n+    match dump_region_constraints_to(tcx, constraints, output_path.as_slice()) {\n+        Ok(()) => {}\n+        Err(e) => {\n+            let msg = format!(\"io error dumping region constraints: {}\", e);\n+            region_vars.tcx.sess.err(msg.as_slice())\n+        }\n+    }\n+}\n+\n+struct ConstraintGraph<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    graph_name: String,\n+    map: &'a FnvHashMap<Constraint, SubregionOrigin<'tcx>>,\n+    node_ids: FnvHashMap<Node, uint>,\n+}\n+\n+#[deriving(Clone, Hash, PartialEq, Eq, Show)]\n+enum Node {\n+    RegionVid(ty::RegionVid),\n+    Region(ty::Region),\n+}\n+\n+type Edge = Constraint;\n+\n+impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>,\n+           name: String,\n+           map: &'a ConstraintMap<'tcx>) -> ConstraintGraph<'a, 'tcx> {\n+        let mut i = 0;\n+        let mut node_ids = FnvHashMap::new();\n+        {\n+            let add_node = |node| {\n+                if let Vacant(e) = node_ids.entry(node) {\n+                    e.set(i);\n+                    i += 1;\n+                }\n+            };\n+\n+            for (n1, n2) in map.keys().map(|c|constraint_to_nodes(c)) {\n+                add_node(n1);\n+                add_node(n2);\n+            }\n+        }\n+\n+        ConstraintGraph { tcx: tcx,\n+                          graph_name: name,\n+                          map: map,\n+                          node_ids: node_ids }\n+    }\n+}\n+\n+impl<'a, 'tcx> dot::Labeller<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n+    fn graph_id(&self) -> dot::Id {\n+        dot::Id::new(self.graph_name.as_slice()).unwrap()\n+    }\n+    fn node_id(&self, n: &Node) -> dot::Id {\n+        dot::Id::new(format!(\"node_{}\", self.node_ids.get(n).unwrap())).unwrap()\n+    }\n+    fn node_label(&self, n: &Node) -> dot::LabelText {\n+        match *n {\n+            Node::RegionVid(n_vid) =>\n+                dot::LabelText::label(format!(\"{}\", n_vid)),\n+            Node::Region(n_rgn) =>\n+                dot::LabelText::label(format!(\"{}\", n_rgn.repr(self.tcx))),\n+        }\n+    }\n+    fn edge_label(&self, e: &Edge) -> dot::LabelText {\n+        dot::LabelText::label(format!(\"{}\", self.map.get(e).unwrap().repr(self.tcx)))\n+    }\n+}\n+\n+fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n+    match *c {\n+        Constraint::ConstrainVarSubVar(rv_1, rv_2) => (Node::RegionVid(rv_1),\n+                                                       Node::RegionVid(rv_2)),\n+        Constraint::ConstrainRegSubVar(r_1, rv_2) => (Node::Region(r_1),\n+                                                      Node::RegionVid(rv_2)),\n+        Constraint::ConstrainVarSubReg(rv_1, r_2) => (Node::RegionVid(rv_1),\n+                                                      Node::Region(r_2)),\n+    }\n+}\n+\n+impl<'a, 'tcx> dot::GraphWalk<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n+    fn nodes(&self) -> dot::Nodes<Node> {\n+        let mut set = FnvHashSet::new();\n+        for constraint in self.map.keys() {\n+            let (n1, n2) = constraint_to_nodes(constraint);\n+            set.insert(n1);\n+            set.insert(n2);\n+        }\n+        debug!(\"constraint graph has {} nodes\", set.len());\n+        set.into_iter().collect()\n+    }\n+    fn edges(&self) -> dot::Edges<Edge> {\n+        debug!(\"constraint graph has {} edges\", self.map.len());\n+        self.map.keys().map(|e|*e).collect()\n+    }\n+    fn source(&self, edge: &Edge) -> Node {\n+        let (n1, _) = constraint_to_nodes(edge);\n+        debug!(\"edge {} has source {}\", edge, n1);\n+        n1\n+    }\n+    fn target(&self, edge: &Edge) -> Node {\n+        let (_, n2) = constraint_to_nodes(edge);\n+        debug!(\"edge {} has target {}\", edge, n2);\n+        n2\n+    }\n+}\n+\n+pub type ConstraintMap<'tcx> = FnvHashMap<Constraint, SubregionOrigin<'tcx>>;\n+\n+fn dump_region_constraints_to<'a, 'tcx:'a >(tcx: &'a ty::ctxt<'tcx>,\n+                                            map: &ConstraintMap<'tcx>,\n+                                            path: &str) -> io::IoResult<()> {\n+    debug!(\"dump_region_constraints map (len: {}) path: {}\", map.len(), path);\n+    let g = ConstraintGraph::new(tcx, format!(\"region_constraints\"), map);\n+    let mut f = File::create(&Path::new(path));\n+    debug!(\"dump_region_constraints calling render\");\n+    dot::render(&g, &mut f)\n+}"}, {"sha": "acd49f3f8dfa842b706481dfe9c1e140be262b87", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=d6d0bb2030f870c0b4b942da793beb4edb82c191", "patch": "@@ -37,9 +37,10 @@ use std::uint;\n use syntax::ast;\n \n mod doc;\n+mod graphviz;\n \n // A constraint that influences the inference process.\n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n pub enum Constraint {\n     // One region variable is subregion of another\n     ConstrainVarSubVar(RegionVid, RegionVid),\n@@ -706,10 +707,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// fixed-point iteration to find region values which satisfy all\n     /// constraints, assuming such values can be found; if they cannot,\n     /// errors are reported.\n-    pub fn resolve_regions(&self) -> Vec<RegionResolutionError<'tcx>> {\n+    pub fn resolve_regions(&self, subject_node: ast::NodeId) -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = vec!();\n-        let v = self.infer_variable_values(&mut errors);\n+        let v = self.infer_variable_values(&mut errors, subject_node);\n         *self.values.borrow_mut() = Some(v);\n         errors\n     }\n@@ -958,14 +959,15 @@ type RegionGraph = graph::Graph<(), Constraint>;\n \n impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn infer_variable_values(&self,\n-                             errors: &mut Vec<RegionResolutionError<'tcx>>)\n-                             -> Vec<VarValue>\n+                             errors: &mut Vec<RegionResolutionError<'tcx>>,\n+                             subject: ast::NodeId) -> Vec<VarValue>\n     {\n         let mut var_data = self.construct_var_data();\n \n         // Dorky hack to cause `dump_constraints` to only get called\n         // if debug mode is enabled:\n         debug!(\"----() End constraint listing {}---\", self.dump_constraints());\n+        graphviz::maybe_print_constraints_for(self, subject);\n \n         self.expansion(var_data.as_mut_slice());\n         self.contraction(var_data.as_mut_slice());"}, {"sha": "b3b44b60b6ead979a40dc9a97c759f78da4f2188", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=d6d0bb2030f870c0b4b942da793beb4edb82c191", "patch": "@@ -276,7 +276,8 @@ debugging_opts!(\n         FLOWGRAPH_PRINT_MOVES,\n         FLOWGRAPH_PRINT_ASSIGNS,\n         FLOWGRAPH_PRINT_ALL,\n-        PRINT_SYSROOT\n+        PRINT_SYSROOT,\n+        PRINT_REGION_GRAPH\n     ]\n     0\n )\n@@ -322,7 +323,10 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n      (\"flowgraph-print-all\", \"Include all dataflow analysis data in \\\n                        --pretty flowgraph output\", FLOWGRAPH_PRINT_ALL),\n      (\"print-sysroot\", \"Print the sysroot as used by this rustc invocation\",\n-      PRINT_SYSROOT)]\n+      PRINT_SYSROOT),\n+     (\"print-region-graph\", \"Prints region inference graph. \\\n+                             Use with RUST_REGION_GRAPH=help for more info\",\n+      PRINT_REGION_GRAPH)]\n }\n \n #[deriving(Clone)]"}, {"sha": "ad0046a1ad4b5679bdf71246d5d93a138c4f41dd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d6d0bb2030f870c0b4b942da793beb4edb82c191", "patch": "@@ -1190,7 +1190,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // Finally, resolve all regions. This catches wily misuses of lifetime\n     // parameters.\n-    infcx.resolve_regions_and_report_errors();\n+    infcx.resolve_regions_and_report_errors(impl_m_body_id);\n \n     /// Check that region bounds on impl method are the same as those on the trait. In principle,\n     /// it could be ok for there to be fewer region bounds on the impl method, but this leads to an"}, {"sha": "501b9775f7f119be52a76674f3d7ca02b21c63fe", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d6d0bb2030f870c0b4b942da793beb4edb82c191", "patch": "@@ -139,27 +139,31 @@ use syntax::visit::Visitor;\n use std::cell::{RefCell};\n use std::collections::hash_map::{Vacant, Occupied};\n \n+use self::RepeatingScope::Repeating;\n+use self::SubjectNode::Subject;\n+\n+\n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n \n pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n-    let mut rcx = Rcx::new(fcx, e.id);\n+    let mut rcx = Rcx::new(fcx, Repeating(e.id), Subject(e.id));\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         rcx.visit_expr(e);\n         rcx.visit_region_obligations(e.id);\n     }\n-    fcx.infcx().resolve_regions_and_report_errors();\n+    rcx.resolve_regions_and_report_errors();\n }\n \n pub fn regionck_item(fcx: &FnCtxt, item: &ast::Item) {\n-    let mut rcx = Rcx::new(fcx, item.id);\n+    let mut rcx = Rcx::new(fcx, Repeating(item.id), Subject(item.id));\n     rcx.visit_region_obligations(item.id);\n-    fcx.infcx().resolve_regions_and_report_errors();\n+    rcx.resolve_regions_and_report_errors();\n }\n \n pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, decl: &ast::FnDecl, blk: &ast::Block) {\n-    let mut rcx = Rcx::new(fcx, blk.id);\n+    let mut rcx = Rcx::new(fcx, Repeating(blk.id), Subject(id));\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         rcx.visit_fn_body(id, decl, blk);\n@@ -169,15 +173,15 @@ pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, decl: &ast::FnDecl, blk: &ast:\n     // particularly around closure bounds.\n     vtable::select_all_fcx_obligations_or_error(fcx);\n \n-    fcx.infcx().resolve_regions_and_report_errors();\n+    rcx.resolve_regions_and_report_errors();\n }\n \n /// Checks that the types in `component_tys` are well-formed. This will add constraints into the\n /// region graph. Does *not* run `resolve_regions_and_report_errors` and so forth.\n pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   span: Span,\n                                                   component_tys: &[Ty<'tcx>]) {\n-    let mut rcx = Rcx::new(fcx, 0);\n+    let mut rcx = Rcx::new(fcx, Repeating(0), SubjectNode::None);\n     for &component_ty in component_tys.iter() {\n         // Check that each type outlives the empty region. Since the\n         // empty region is a subregion of all others, this can't fail\n@@ -225,6 +229,9 @@ pub struct Rcx<'a, 'tcx: 'a> {\n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n \n+    // id of AST node being analyzed (the subject of the analysis).\n+    subject: SubjectNode,\n+\n     // Possible region links we will establish if an upvar\n     // turns out to be unique/mutable\n     maybe_links: MaybeLinkMap<'tcx>\n@@ -251,11 +258,17 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n     }\n }\n \n+pub enum RepeatingScope { Repeating(ast::NodeId) }\n+pub enum SubjectNode { Subject(ast::NodeId), None }\n+\n impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     pub fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n-               initial_repeating_scope: ast::NodeId) -> Rcx<'a, 'tcx> {\n+               initial_repeating_scope: RepeatingScope,\n+               subject: SubjectNode) -> Rcx<'a, 'tcx> {\n+        let Repeating(initial_repeating_scope) = initial_repeating_scope;\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n+              subject: subject,\n               region_param_pairs: Vec::new(),\n               maybe_links: RefCell::new(FnvHashMap::new()) }\n     }\n@@ -425,6 +438,18 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         debug!(\"<< relate_free_regions\");\n     }\n+\n+    fn resolve_regions_and_report_errors(&self) {\n+        let subject_node_id = match self.subject {\n+            Subject(s) => s,\n+            SubjectNode::None => {\n+                self.tcx().sess.bug(\"cannot resolve_regions_and_report_errors \\\n+                                     without subject node\");\n+            }\n+        };\n+\n+        self.fcx.infcx().resolve_regions_and_report_errors(subject_node_id);\n+    }\n }\n \n impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {"}, {"sha": "962bb575dc8413f9dd74e2ba4091fe9c221b1185", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d0bb2030f870c0b4b942da793beb4edb82c191/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d6d0bb2030f870c0b4b942da793beb4edb82c191", "patch": "@@ -2237,6 +2237,6 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                 format!(\"mismatched self type: expected `{}`\",\n                         ppaux::ty_to_string(crate_context.tcx, required_type))\n         }));\n-        infcx.resolve_regions_and_report_errors();\n+        infcx.resolve_regions_and_report_errors(body_id);\n     }\n }"}]}