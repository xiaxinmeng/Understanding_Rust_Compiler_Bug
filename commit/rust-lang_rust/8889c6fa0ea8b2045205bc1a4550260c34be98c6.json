{"sha": "8889c6fa0ea8b2045205bc1a4550260c34be98c6", "node_id": "C_kwDOAAsO6NoAKDg4ODljNmZhMGVhOGIyMDQ1MjA1YmMxYTQ1NTAyNjBjMzRiZTk4YzY", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-16T10:01:15Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-16T10:01:15Z"}, "message": "Account for variance in outlives obligations.", "tree": {"sha": "0ca0523e8ff865296ff994ed4474fc6025404de9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ca0523e8ff865296ff994ed4474fc6025404de9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8889c6fa0ea8b2045205bc1a4550260c34be98c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8889c6fa0ea8b2045205bc1a4550260c34be98c6", "html_url": "https://github.com/rust-lang/rust/commit/8889c6fa0ea8b2045205bc1a4550260c34be98c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8889c6fa0ea8b2045205bc1a4550260c34be98c6/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e7edf3684ac96f57f918afdb560c4af7afafb60", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e7edf3684ac96f57f918afdb560c4af7afafb60", "html_url": "https://github.com/rust-lang/rust/commit/4e7edf3684ac96f57f918afdb560c4af7afafb60"}], "stats": {"total": 29, "additions": 20, "deletions": 9}, "files": [{"sha": "2f5e2e417a6fd44a288c15966c3c0032d5850bbb", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8889c6fa0ea8b2045205bc1a4550260c34be98c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8889c6fa0ea8b2045205bc1a4550260c34be98c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=8889c6fa0ea8b2045205bc1a4550260c34be98c6", "patch": "@@ -344,12 +344,14 @@ where\n         // the problem is to add `T: 'r`, which isn't true. So, if there are no\n         // inference variables, we use a verify constraint instead of adding\n         // edges, which winds up enforcing the same condition.\n+        let is_opaque = alias_ty.kind(self.tcx) == ty::Opaque;\n         if approx_env_bounds.is_empty()\n             && trait_bounds.is_empty()\n-            && (alias_ty.needs_infer() || alias_ty.kind(self.tcx) == ty::Opaque)\n+            && (alias_ty.needs_infer() || is_opaque)\n         {\n             debug!(\"no declared bounds\");\n-            self.substs_must_outlive(alias_ty.substs, origin, region);\n+            let opt_variances = is_opaque.then(|| self.tcx.variances_of(alias_ty.def_id));\n+            self.substs_must_outlive(alias_ty.substs, origin, region, opt_variances);\n             return;\n         }\n \n@@ -395,22 +397,31 @@ where\n         self.delegate.push_verify(origin, GenericKind::Alias(alias_ty), region, verify_bound);\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn substs_must_outlive(\n         &mut self,\n         substs: SubstsRef<'tcx>,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n+        opt_variances: Option<&[ty::Variance]>,\n     ) {\n         let constraint = origin.to_constraint_category();\n-        for k in substs {\n+        for (index, k) in substs.iter().enumerate() {\n             match k.unpack() {\n                 GenericArgKind::Lifetime(lt) => {\n-                    self.delegate.push_sub_region_constraint(\n-                        origin.clone(),\n-                        region,\n-                        lt,\n-                        constraint,\n-                    );\n+                    let variance = if let Some(variances) = opt_variances {\n+                        variances[index]\n+                    } else {\n+                        ty::Invariant\n+                    };\n+                    if variance == ty::Invariant {\n+                        self.delegate.push_sub_region_constraint(\n+                            origin.clone(),\n+                            region,\n+                            lt,\n+                            constraint,\n+                        );\n+                    }\n                 }\n                 GenericArgKind::Type(ty) => {\n                     self.type_must_outlive(origin.clone(), ty, region, constraint);"}]}