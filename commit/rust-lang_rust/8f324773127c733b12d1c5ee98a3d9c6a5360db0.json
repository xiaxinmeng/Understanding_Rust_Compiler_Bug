{"sha": "8f324773127c733b12d1c5ee98a3d9c6a5360db0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMzI0NzczMTI3YzczM2IxMmQxYzVlZTk4YTNkOWM2YTUzNjBkYjA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-26T15:27:22Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-26T15:27:22Z"}, "message": "more type safety", "tree": {"sha": "4cc6186b417ae6cff6bec44f17ce53b1af574010", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cc6186b417ae6cff6bec44f17ce53b1af574010"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f324773127c733b12d1c5ee98a3d9c6a5360db0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f324773127c733b12d1c5ee98a3d9c6a5360db0", "html_url": "https://github.com/rust-lang/rust/commit/8f324773127c733b12d1c5ee98a3d9c6a5360db0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f324773127c733b12d1c5ee98a3d9c6a5360db0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "071a19537d4399fd04d1e9594ab7878502a12d21", "url": "https://api.github.com/repos/rust-lang/rust/commits/071a19537d4399fd04d1e9594ab7878502a12d21", "html_url": "https://github.com/rust-lang/rust/commit/071a19537d4399fd04d1e9594ab7878502a12d21"}], "stats": {"total": 145, "additions": 82, "deletions": 63}, "files": [{"sha": "c2df5ce00a94d6c5ca70195b5953052e7166b2c8", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8f324773127c733b12d1c5ee98a3d9c6a5360db0/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f324773127c733b12d1c5ee98a3d9c6a5360db0/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=8f324773127c733b12d1c5ee98a3d9c6a5360db0", "patch": "@@ -1,5 +1,4 @@\n use std::{\n-    marker::PhantomData,\n     hash::{Hash, Hasher},\n     sync::Arc,\n };\n@@ -10,7 +9,7 @@ use ra_arena::{RawId, ArenaId, impl_arena_id};\n use mbe::MacroRules;\n \n use crate::{\n-    Module, DefDatabase, SourceItemId, SourceFileItemId, AstId,\n+    Module, DefDatabase, AstId, FileAstId,\n };\n \n #[derive(Debug, Default)]\n@@ -123,6 +122,7 @@ impl From<MacroCallId> for HirFileId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+\n pub struct MacroDefId(pub(crate) AstId<ast::MacroCall>);\n \n pub(crate) fn macro_def_query(db: &impl DefDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n@@ -161,26 +161,25 @@ impl MacroCallLoc {\n #[derive(Debug)]\n pub struct ItemLoc<N: AstNode> {\n     pub(crate) module: Module,\n-    raw: SourceItemId,\n-    _ty: PhantomData<N>,\n+    ast_id: AstId<N>,\n }\n \n impl<N: AstNode> PartialEq for ItemLoc<N> {\n     fn eq(&self, other: &Self) -> bool {\n-        self.module == other.module && self.raw == other.raw\n+        self.module == other.module && self.ast_id == other.ast_id\n     }\n }\n impl<N: AstNode> Eq for ItemLoc<N> {}\n impl<N: AstNode> Hash for ItemLoc<N> {\n     fn hash<H: Hasher>(&self, hasher: &mut H) {\n         self.module.hash(hasher);\n-        self.raw.hash(hasher);\n+        self.ast_id.hash(hasher);\n     }\n }\n \n impl<N: AstNode> Clone for ItemLoc<N> {\n     fn clone(&self) -> ItemLoc<N> {\n-        ItemLoc { module: self.module, raw: self.raw, _ty: PhantomData }\n+        ItemLoc { module: self.module, ast_id: self.ast_id }\n     }\n }\n \n@@ -208,25 +207,18 @@ pub(crate) trait AstItemDef<N: AstNode>: ArenaId + Clone {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<N>, Self>;\n     fn from_ast(ctx: LocationCtx<&impl DefDatabase>, ast: &N) -> Self {\n         let items = ctx.db.file_items(ctx.file_id);\n-        let item_id = items.id_of(ctx.file_id, ast.syntax());\n-        Self::from_source_item_id_unchecked(ctx, item_id)\n+        let item_id = items.ast_id(ast);\n+        Self::from_ast_id(ctx, item_id)\n     }\n-    fn from_source_item_id_unchecked(\n-        ctx: LocationCtx<&impl DefDatabase>,\n-        item_id: SourceFileItemId,\n-    ) -> Self {\n-        let raw = SourceItemId { file_id: ctx.file_id, item_id };\n-        let loc = ItemLoc { module: ctx.module, raw, _ty: PhantomData };\n-\n+    fn from_ast_id(ctx: LocationCtx<&impl DefDatabase>, ast_id: FileAstId<N>) -> Self {\n+        let loc = ItemLoc { module: ctx.module, ast_id: ast_id.with_file_id(ctx.file_id) };\n         Self::interner(ctx.db.as_ref()).loc2id(&loc)\n     }\n     fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<N>) {\n         let int = Self::interner(db.as_ref());\n         let loc = int.id2loc(self);\n-        let syntax = db.file_item(loc.raw);\n-        let ast =\n-            N::cast(&syntax).unwrap_or_else(|| panic!(\"invalid ItemLoc: {:?}\", loc.raw)).to_owned();\n-        (loc.raw.file_id, ast)\n+        let ast = loc.ast_id.to_node(db);\n+        (loc.ast_id.file_id(), ast)\n     }\n     fn module(self, db: &impl DefDatabase) -> Module {\n         let int = Self::interner(db.as_ref());"}, {"sha": "b1f388b065ba58ddb030456944694bd182c0ec33", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f324773127c733b12d1c5ee98a3d9c6a5360db0/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f324773127c733b12d1c5ee98a3d9c6a5360db0/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=8f324773127c733b12d1c5ee98a3d9c6a5360db0", "patch": "@@ -48,7 +48,7 @@ mod marks;\n use crate::{\n     db::{HirDatabase, DefDatabase},\n     name::{AsName, KnownName},\n-    source_id::{SourceFileItemId, FileAstId, AstId},\n+    source_id::{FileAstId, AstId},\n };\n \n pub use self::{"}, {"sha": "39cadc94aab3101bcdafaeb9383ff2a5869cbbdb", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8f324773127c733b12d1c5ee98a3d9c6a5360db0/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f324773127c733b12d1c5ee98a3d9c6a5360db0/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=8f324773127c733b12d1c5ee98a3d9c6a5360db0", "patch": "@@ -429,23 +429,24 @@ where\n     fn define_def(&mut self, def: &raw::DefData) {\n         let module = Module { krate: self.def_collector.def_map.krate, module_id: self.module_id };\n         let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id.into());\n-        macro_rules! id {\n-            () => {\n-                AstItemDef::from_source_item_id_unchecked(ctx, def.source_item_id)\n+\n+        macro_rules! def {\n+            ($kind:ident, $ast_id:ident) => {\n+                $kind { id: AstItemDef::from_ast_id(ctx, $ast_id) }.into()\n             };\n         }\n         let name = def.name.clone();\n         let def: PerNs<ModuleDef> = match def.kind {\n-            raw::DefKind::Function => PerNs::values(Function { id: id!() }.into()),\n-            raw::DefKind::Struct => {\n-                let s = Struct { id: id!() }.into();\n+            raw::DefKind::Function(ast_id) => PerNs::values(def!(Function, ast_id)),\n+            raw::DefKind::Struct(ast_id) => {\n+                let s = def!(Struct, ast_id);\n                 PerNs::both(s, s)\n             }\n-            raw::DefKind::Enum => PerNs::types(Enum { id: id!() }.into()),\n-            raw::DefKind::Const => PerNs::values(Const { id: id!() }.into()),\n-            raw::DefKind::Static => PerNs::values(Static { id: id!() }.into()),\n-            raw::DefKind::Trait => PerNs::types(Trait { id: id!() }.into()),\n-            raw::DefKind::TypeAlias => PerNs::types(TypeAlias { id: id!() }.into()),\n+            raw::DefKind::Enum(ast_id) => PerNs::types(def!(Enum, ast_id)),\n+            raw::DefKind::Const(ast_id) => PerNs::values(def!(Const, ast_id)),\n+            raw::DefKind::Static(ast_id) => PerNs::values(def!(Static, ast_id)),\n+            raw::DefKind::Trait(ast_id) => PerNs::types(def!(Trait, ast_id)),\n+            raw::DefKind::TypeAlias(ast_id) => PerNs::types(def!(TypeAlias, ast_id)),\n         };\n         let resolution = Resolution { def, import: None };\n         self.def_collector.update(self.module_id, None, &[(name, resolution)])"}, {"sha": "984478adcdd6df50afec674a75da2188f60ed30c", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8f324773127c733b12d1c5ee98a3d9c6a5360db0/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f324773127c733b12d1c5ee98a3d9c6a5360db0/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=8f324773127c733b12d1c5ee98a3d9c6a5360db0", "patch": "@@ -12,7 +12,7 @@ use ra_syntax::{\n \n use crate::{\n     DefDatabase, Name, AsName, Path, HirFileId, ModuleSource,\n-    SourceFileItemId, SourceFileItems, FileAstId,\n+    SourceFileItems, FileAstId,\n };\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n@@ -138,20 +138,19 @@ impl_arena_id!(Def);\n \n #[derive(Debug, PartialEq, Eq)]\n pub(super) struct DefData {\n-    pub(super) source_item_id: SourceFileItemId,\n     pub(super) name: Name,\n     pub(super) kind: DefKind,\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub(super) enum DefKind {\n-    Function,\n-    Struct,\n-    Enum,\n-    Const,\n-    Static,\n-    Trait,\n-    TypeAlias,\n+    Function(FileAstId<ast::FnDef>),\n+    Struct(FileAstId<ast::StructDef>),\n+    Enum(FileAstId<ast::EnumDef>),\n+    Const(FileAstId<ast::ConstDef>),\n+    Static(FileAstId<ast::StaticDef>),\n+    Trait(FileAstId<ast::TraitDef>),\n+    TypeAlias(FileAstId<ast::TypeAliasDef>),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -200,18 +199,31 @@ impl RawItemsCollector {\n                 // impls don't participate in name resolution\n                 return;\n             }\n-            ast::ModuleItemKind::StructDef(it) => (DefKind::Struct, it.name()),\n-            ast::ModuleItemKind::EnumDef(it) => (DefKind::Enum, it.name()),\n-            ast::ModuleItemKind::FnDef(it) => (DefKind::Function, it.name()),\n-            ast::ModuleItemKind::TraitDef(it) => (DefKind::Trait, it.name()),\n-            ast::ModuleItemKind::TypeAliasDef(it) => (DefKind::TypeAlias, it.name()),\n-            ast::ModuleItemKind::ConstDef(it) => (DefKind::Const, it.name()),\n-            ast::ModuleItemKind::StaticDef(it) => (DefKind::Static, it.name()),\n+            ast::ModuleItemKind::StructDef(it) => {\n+                (DefKind::Struct(self.source_file_items.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::EnumDef(it) => {\n+                (DefKind::Enum(self.source_file_items.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::FnDef(it) => {\n+                (DefKind::Function(self.source_file_items.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::TraitDef(it) => {\n+                (DefKind::Trait(self.source_file_items.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::TypeAliasDef(it) => {\n+                (DefKind::TypeAlias(self.source_file_items.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::ConstDef(it) => {\n+                (DefKind::Const(self.source_file_items.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::StaticDef(it) => {\n+                (DefKind::Static(self.source_file_items.ast_id(it)), it.name())\n+            }\n         };\n         if let Some(name) = name {\n             let name = name.as_name();\n-            let source_item_id = self.source_file_items.id_of_unchecked(item.syntax());\n-            let def = self.raw_items.defs.alloc(DefData { name, kind, source_item_id });\n+            let def = self.raw_items.defs.alloc(DefData { name, kind });\n             self.push_item(current_module, RawItem::Def(def))\n         }\n     }"}, {"sha": "2c855897a39fd3bfa19219e0be2fbf17d2ba81d9", "filename": "crates/ra_hir/src/source_id.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8f324773127c733b12d1c5ee98a3d9c6a5360db0/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f324773127c733b12d1c5ee98a3d9c6a5360db0/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_id.rs?ref=8f324773127c733b12d1c5ee98a3d9c6a5360db0", "patch": "@@ -1,11 +1,11 @@\n-use std::{marker::PhantomData, sync::Arc};\n+use std::{marker::PhantomData, sync::Arc, hash::{Hash, Hasher}};\n \n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_syntax::{SyntaxNodePtr, TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n \n use crate::{HirFileId, DefDatabase};\n \n-#[derive(Debug, PartialEq, Eq, Hash)]\n+#[derive(Debug)]\n pub(crate) struct AstId<N: AstNode> {\n     file_id: HirFileId,\n     file_ast_id: FileAstId<N>,\n@@ -16,9 +16,20 @@ impl<N: AstNode> Clone for AstId<N> {\n         *self\n     }\n }\n-\n impl<N: AstNode> Copy for AstId<N> {}\n \n+impl<N: AstNode> PartialEq for AstId<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.file_id, self.file_ast_id) == (other.file_id, other.file_ast_id)\n+    }\n+}\n+impl<N: AstNode> Eq for AstId<N> {}\n+impl<N: AstNode> Hash for AstId<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        (self.file_id, self.file_ast_id).hash(hasher);\n+    }\n+}\n+\n impl<N: AstNode> AstId<N> {\n     pub(crate) fn file_id(&self) -> HirFileId {\n         self.file_id\n@@ -30,7 +41,7 @@ impl<N: AstNode> AstId<N> {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Hash)]\n+#[derive(Debug)]\n pub(crate) struct FileAstId<N: AstNode> {\n     raw: SourceFileItemId,\n     _ty: PhantomData<N>,\n@@ -41,9 +52,20 @@ impl<N: AstNode> Clone for FileAstId<N> {\n         *self\n     }\n }\n-\n impl<N: AstNode> Copy for FileAstId<N> {}\n \n+impl<N: AstNode> PartialEq for FileAstId<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.raw == other.raw\n+    }\n+}\n+impl<N: AstNode> Eq for FileAstId<N> {}\n+impl<N: AstNode> Hash for FileAstId<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.raw.hash(hasher);\n+    }\n+}\n+\n impl<N: AstNode> FileAstId<N> {\n     pub(crate) fn with_file_id(self, file_id: HirFileId) -> AstId<N> {\n         AstId { file_id, file_ast_id: self }\n@@ -116,14 +138,6 @@ impl SourceFileItems {\n     fn alloc(&mut self, item: &SyntaxNode) -> SourceFileItemId {\n         self.arena.alloc(SyntaxNodePtr::new(item))\n     }\n-    pub(crate) fn id_of(&self, file_id: HirFileId, item: &SyntaxNode) -> SourceFileItemId {\n-        assert_eq!(\n-            self.file_id, file_id,\n-            \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n-            self.file_id, file_id\n-        );\n-        self.id_of_unchecked(item)\n-    }\n     pub(crate) fn id_of_unchecked(&self, item: &SyntaxNode) -> SourceFileItemId {\n         let ptr = SyntaxNodePtr::new(item);\n         if let Some((id, _)) = self.arena.iter().find(|(_id, i)| **i == ptr) {"}]}