{"sha": "45ddf50cebd8f3353383e473327911c1f8b34cd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZGRmNTBjZWJkOGYzMzUzMzgzZTQ3MzMyNzkxMWMxZjhiMzRjZDY=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-29T22:33:11Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-02-03T22:52:03Z"}, "message": "Add new path module\n\nImplements [RFC 474](https://github.com/rust-lang/rfcs/pull/474); see\nthat RFC for details/motivation for this change.\n\nThis initial commit does not include additional normalization or\nplatform-specific path extensions. These will be done in follow up\ncommits or PRs.", "tree": {"sha": "f9f41a11f529a8f41a24e9ac52450011d9c63afb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9f41a11f529a8f41a24e9ac52450011d9c63afb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45ddf50cebd8f3353383e473327911c1f8b34cd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45ddf50cebd8f3353383e473327911c1f8b34cd6", "html_url": "https://github.com/rust-lang/rust/commit/45ddf50cebd8f3353383e473327911c1f8b34cd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45ddf50cebd8f3353383e473327911c1f8b34cd6/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e39f0bc0e96f76610104918edaa5912f4f352df", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e39f0bc0e96f76610104918edaa5912f4f352df", "html_url": "https://github.com/rust-lang/rust/commit/3e39f0bc0e96f76610104918edaa5912f4f352df"}], "stats": {"total": 2585, "additions": 2576, "deletions": 9}, "files": [{"sha": "07a4f17796c4994f14638ac3258ee15a0da40b4e", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=45ddf50cebd8f3353383e473327911c1f8b34cd6", "patch": "@@ -24,6 +24,7 @@ pub use self::os_str::OsStr;\n mod c_str;\n mod os_str;\n \n+// FIXME (#21670): these should be defined in the os_str module\n /// Freely convertible to an `&OsStr` slice.\n pub trait AsOsStr {\n     /// Convert to an `&OsStr` slice."}, {"sha": "4d7292b6eb417469e4aea7a03002ca0063a10fe2", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=45ddf50cebd8f3353383e473327911c1f8b34cd6", "patch": "@@ -41,7 +41,7 @@ use string::{String, CowString};\n use ops;\n use cmp;\n use hash::{Hash, Hasher, Writer};\n-use path::{Path, GenericPath};\n+use old_path::{Path, GenericPath};\n \n use sys::os_str::{Buf, Slice};\n use sys_common::{AsInner, IntoInner, FromInner};"}, {"sha": "3fd45ea6a7bc07cd59c63ec2ac1662b1a609ad5e", "filename": "src/libstd/path.rs", "status": "added", "additions": 2567, "deletions": 0, "changes": 2567, "blob_url": "https://github.com/rust-lang/rust/blob/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=45ddf50cebd8f3353383e473327911c1f8b34cd6", "patch": "@@ -0,0 +1,2567 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Cross-platform path manipulation.\n+//!\n+//! This module provides two types, `PathBuf` and `Path` (akin to `String` and\n+//! `str`), for working with paths abstractly. These types are thin wrappers\n+//! around `OsString` and `OsStr` respectively, meaning that they work directly\n+//! on strings according to the local platform's path syntax.\n+//!\n+//! ## Simple usage\n+//!\n+//! Path manipulation involves both parsing components from slices and building\n+//! new owned paths.\n+//!\n+//! To parse a path, you can create a `Path` slice from a `str`\n+//! slice and start asking questions:\n+//!\n+//! ```rust\n+//! use std::path::Path;\n+//!\n+//! let path = Path::new(\"/tmp/foo/bar.txt\");\n+//! let file = path.file_name();\n+//! let extension = path.extension();\n+//! let parent_dir = path.parent();\n+//! ```\n+//!\n+//! To build or modify paths, use `PathBuf`:\n+//!\n+//! ```rust\n+//! use std::path::PathBuf;\n+//!\n+//! let mut path = PathBuf::new(\"c:\\\\\");\n+//! path.push(\"windows\");\n+//! path.push(\"system32\");\n+//! path.set_extension(\"dll\");\n+//! ```\n+//!\n+//! ## Path components and normalization\n+//!\n+//! The path APIs are built around the notion of \"components\", which roughly\n+//! correspond to the substrings between path separators (`/` and, on Windows,\n+//! `\\`). The APIs for path parsing are largely specified in terms of the path's\n+//! components, so it's important to clearly understand how those are determined.\n+//!\n+//! A path can always be reconstructed into an equivalent path by putting\n+//! together its components via `push`. Syntactically, the paths may differ by\n+//! the normalization described below.\n+//!\n+//! ### Component types\n+//!\n+//! Components come in several types:\n+//!\n+//! * Normal components are the default: standard references to files or\n+//! directories. The path `a/b` has two normal components, `a` and `b`.\n+//!\n+//! * Current directory components represent the `.` character. For example,\n+//! `a/.` has a normal component `a` and a current directory component.\n+//!\n+//! * The root directory component represents a separator that designates\n+//!   starting from root. For example, `/a/b` has a root directory component\n+//!   followed by normal components `a` and `b`.\n+//!\n+//! On Windows, two additional component types come into play:\n+//!\n+//! * Prefix components, of which there is a large variety. For example, `C:`\n+//! and `\\\\server\\share` are prefixes. The path `C:windows` has a prefix\n+//! component `C:` and a normal component `windows`; the path `C:\\windows` has a\n+//! prefix component `C:`, a root directory component, and a normal component\n+//! `windows`.\n+//!\n+//! * Empty components, a special case for so-called \"verbatim\" paths where very\n+//! little normalization is allowed. For example, `\\\\?\\C:\\` has a \"verbatim\"\n+//! prefix `\\\\?\\C:`, a root component, and an empty component (as a way of\n+//! representing the trailing `\\`. Such a trailing `\\` is in fact the only\n+//! situation in which an empty component is produced.\n+//!\n+//! ### Normalization\n+//!\n+//! Aside from splitting on the separator(s), there is a small amount of\n+//! \"normalization\":\n+//!\n+//! * Repeated separators are ignored: `a/b` and `a//b` both have components `a`\n+//!   and `b`.\n+//!\n+//! * Paths ending in a separator are treated as if they has a current directory\n+//!   component at the end (or, in verbatim paths, an empty component).  For\n+//!   example, while `a/b` has components `a` and `b`, the paths `a/b/` and\n+//!   `a/b/.` both have components `a`, `b`, and `.` (current directory).  The\n+//!   reason for this normalization is that `a/b` and `a/b/` are treated\n+//!   differently in some contexts, but `a/b/` and `a/b/.` are always treated\n+//!   the same.\n+//!\n+//! No other normalization takes place by default. In particular, `a/./b/` and\n+//! `a/b` are treated distinctly in terms of components, as are `a/c` and\n+//! `a/b/../c`. Further normalization is possible to build on top of the\n+//! components APIs, and will be included in this library very soon.\n+\n+#![unstable(feature = \"path\")]\n+\n+use core::prelude::*;\n+\n+use borrow::BorrowFrom;\n+use cmp;\n+use iter;\n+use mem;\n+use ops::{self, Deref};\n+use string::CowString;\n+use vec::Vec;\n+use fmt;\n+\n+use ffi::{OsStr, OsString, AsOsStr};\n+\n+use self::platform::{is_sep, is_verbatim_sep, MAIN_SEP_STR, parse_prefix, Prefix};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// GENERAL NOTES\n+////////////////////////////////////////////////////////////////////////////////\n+//\n+// Parsing in this module is done by directly transmuting OsStr to [u8] slices,\n+// taking advantage of the fact that OsStr always encodes ASCII characters\n+// as-is.  Eventually, this transmutation should be replaced by direct uses of\n+// OsStr APIs for parsing, but it will take a while for those to become\n+// available.\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Platform-specific definitions\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// The following modules give the most basic tools for parsing paths on various\n+// platforms. The bulk of the code is devoted to parsing prefixes on Windows.\n+\n+#[cfg(unix)]\n+mod platform {\n+    use core::prelude::*;\n+    use ffi::OsStr;\n+\n+    #[inline]\n+    pub fn is_sep(b: u8) -> bool {\n+        b == b'/'\n+    }\n+\n+    #[inline]\n+    pub fn is_verbatim_sep(b: u8) -> bool {\n+        b == b'/'\n+    }\n+\n+    pub fn parse_prefix(_: &OsStr) -> Option<Prefix> {\n+        None\n+    }\n+\n+    #[derive(Copy, Clone, Show, Hash, PartialEq, Eq)]\n+    pub struct Prefix<'a>;\n+\n+    impl<'a> Prefix<'a> {\n+        #[inline]\n+        pub fn len(&self) -> usize { 0 }\n+        #[inline]\n+        pub fn is_verbatim(&self) -> bool { false }\n+        #[inline]\n+        pub fn is_drive(&self) -> bool { false }\n+        #[inline]\n+        pub fn has_implicit_root(&self) -> bool { false }\n+    }\n+\n+    pub const MAIN_SEP_STR: &'static str = \"/\";\n+}\n+\n+#[cfg(windows)]\n+mod platform {\n+    use core::prelude::*;\n+\n+    use super::{Path, os_str_as_u8_slice, u8_slice_as_os_str};\n+    use ffi::OsStr;\n+    use ascii::*;\n+\n+    #[inline]\n+    pub fn is_sep(b: u8) -> bool {\n+        b == b'/' || b == b'\\\\'\n+    }\n+\n+    #[inline]\n+    pub fn is_verbatim_sep(b: u8) -> bool {\n+        b == b'\\\\'\n+    }\n+\n+    pub fn parse_prefix<'a>(path: &'a OsStr) -> Option<Prefix> {\n+        use self::Prefix::*;\n+        unsafe {\n+            // The unsafety here stems from converting between &OsStr and &[u8]\n+            // and back. This is safe to do because (1) we only look at ASCII\n+            // contents of the encoding and (2) new &OsStr values are produced\n+            // only from ASCII-bounded slices of existing &OsStr values.\n+            let mut path = os_str_as_u8_slice(path);\n+\n+            if path.starts_with(br\"\\\\\") {\n+                // \\\\\n+                path = &path[2..];\n+                if path.starts_with(br\"?\\\") {\n+                    // \\\\?\\\n+                    path = &path[2..];\n+                    if path.starts_with(br\"UNC\\\") {\n+                        // \\\\?\\UNC\\server\\share\n+                        path = &path[4..];\n+                        let (server, share) = match parse_two_comps(path, is_verbatim_sep) {\n+                            Some((server, share)) => (u8_slice_as_os_str(server),\n+                                                      u8_slice_as_os_str(share)),\n+                            None => (u8_slice_as_os_str(path),\n+                                     u8_slice_as_os_str(&[])),\n+                        };\n+                        return Some(VerbatimUNC(server, share));\n+                    } else {\n+                        // \\\\?\\path\n+                        let idx = path.position_elem(&b'\\\\');\n+                        if idx == Some(2) && path[1] == b':' {\n+                            let c = path[0];\n+                            if c.is_ascii() && (c as char).is_alphabetic() {\n+                                // \\\\?\\C:\\ path\n+                                let slice = u8_slice_as_os_str(&path[0..1]);\n+                                return Some(VerbatimDisk(slice));\n+                            }\n+                        }\n+                        let slice = &path[.. idx.unwrap_or(path.len())];\n+                        return Some(Verbatim(u8_slice_as_os_str(slice)));\n+                    }\n+                } else if path.starts_with(b\".\\\\\") {\n+                    // \\\\.\\path\n+                    path = &path[2..];\n+                    let slice = &path[.. path.position_elem(&b'\\\\').unwrap_or(path.len())];\n+                    return Some(DeviceNS(u8_slice_as_os_str(slice)));\n+                }\n+                match parse_two_comps(path, is_sep) {\n+                    Some((server, share)) if server.len() > 0 && share.len() > 0 => {\n+                        // \\\\server\\share\n+                        return Some(UNC(u8_slice_as_os_str(server),\n+                                        u8_slice_as_os_str(share)));\n+                    }\n+                    _ => ()\n+                }\n+            } else if path.len() > 1 && path[1] == b':' {\n+                // C:\n+                let c = path[0];\n+                if c.is_ascii() && (c as char).is_alphabetic() {\n+                    return Some(Disk(u8_slice_as_os_str(&path[0..1])));\n+                }\n+            }\n+            return None;\n+        }\n+\n+        fn parse_two_comps(mut path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> {\n+            let first = match path.iter().position(|x| f(*x)) {\n+                None => return None,\n+                Some(x) => &path[.. x]\n+            };\n+            path = &path[(first.len()+1)..];\n+            let idx = path.iter().position(|x| f(*x));\n+            let second = &path[.. idx.unwrap_or(path.len())];\n+            Some((first, second))\n+        }\n+    }\n+\n+    /// Windows path prefixes.\n+    ///\n+    /// Windows uses a variety of path styles, including references to drive\n+    /// volumes (like `C:`), network shared (like `\\\\server\\share`) and\n+    /// others. In addition, some path prefixes are \"verbatim\", in which case\n+    /// `/` is *not* treated as a separator and essentially no normalization is\n+    /// performed.\n+    #[derive(Copy, Clone, Debug, Hash, Eq)]\n+    pub enum Prefix<'a> {\n+        /// Prefix `\\\\?\\`, together with the given component immediately following it.\n+        Verbatim(&'a OsStr),\n+\n+        /// Prefix `\\\\?\\UNC\\`, with the \"server\" and \"share\" components following it.\n+        VerbatimUNC(&'a OsStr, &'a OsStr),\n+\n+        /// Prefix like `\\\\?\\C:\\`, for the given drive letter\n+        VerbatimDisk(&'a OsStr),\n+\n+        /// Prefix `\\\\.\\`, together with the given component immediately following it.\n+        DeviceNS(&'a OsStr),\n+\n+        /// Prefix `\\\\server\\share`, with the given \"server\" and \"share\" components.\n+        UNC(&'a OsStr, &'a OsStr),\n+\n+        /// Prefix `C:` for the given disk drive.\n+        Disk(&'a OsStr),\n+    }\n+\n+    impl<'a> Prefix<'a> {\n+        #[inline]\n+        pub fn len(&self) -> usize {\n+            use self::Prefix::*;\n+            fn os_str_len(s: &OsStr) -> usize {\n+                unsafe { os_str_as_u8_slice(s).len() }\n+            }\n+            match *self {\n+                Verbatim(x) => 4 + os_str_len(x),\n+                VerbatimUNC(x,y) => 8 + os_str_len(x) +\n+                    if os_str_len(y) > 0 { 1 + os_str_len(y) }\n+                    else { 0 },\n+                VerbatimDisk(_) => 6,\n+                UNC(x,y) => 2 + os_str_len(x) +\n+                    if os_str_len(y) > 0 { 1 + os_str_len(y) }\n+                    else { 0 },\n+                DeviceNS(x) => 4 + os_str_len(x),\n+                Disk(_) => 2\n+            }\n+\n+        }\n+\n+        #[inline]\n+        pub fn is_verbatim(&self) -> bool {\n+            use self::Prefix::*;\n+            match *self {\n+                Verbatim(_) | VerbatimDisk(_) | VerbatimUNC(_, _) => true,\n+                _ => false\n+            }\n+        }\n+\n+        #[inline]\n+        pub fn is_drive(&self) -> bool {\n+            match *self {\n+                Prefix::Disk(_) => true,\n+                _ => false,\n+            }\n+        }\n+\n+        #[inline]\n+        pub fn has_implicit_root(&self) -> bool {\n+            !self.is_drive()\n+        }\n+    }\n+\n+    impl<'a> ops::PartialEq for Prefix<'a> {\n+        fn eq(&self, other: &Prefix<'a>) -> bool {\n+            use self::Prefix::*;\n+            match (*self, *other) {\n+                (Verbatim(x), Verbatim(y)) => x == y,\n+                (VerbatimUNC(x1, x2), Verbatim(y1, y2)) => x1 == y1 && x2 == y2,\n+                (VerbatimDisk(x), VerbatimDisk(y)) =>\n+                    os_str_as_u8_slice(x).eq_ignore_ascii_case(os_str_as_u8_slice(y)),\n+                (DeviceNS(x), DeviceNS(y)) => x == y,\n+                (UNC(x1, x2), UNC(y1, y2)) => x1 == y1 && x2 == y2,\n+                (Disk(x), Disk(y)) =>\n+                    os_str_as_u8_slice(x).eq_ignore_ascii_case(os_str_as_u8_slice(y)),\n+                _ => false,\n+            }\n+        }\n+    }\n+\n+    pub const MAIN_SEP_STR: &'static str = \"\\\\\";\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Misc helpers\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// Iterate through `iter` while it matches `prefix`; return `None` if `prefix`\n+// is not a prefix of `iter`, otherwise return `Some(iter_after_prefix)` giving\n+// `iter` after having exhausted `prefix`.\n+fn iter_after<A, I, J>(mut iter: I, mut prefix: J) -> Option<I> where\n+    I: Iterator<Item=A> + Clone, J: Iterator<Item=A>, A: PartialEq\n+{\n+    loop {\n+        let mut iter_next = iter.clone();\n+        match (iter_next.next(), prefix.next()) {\n+            (Some(x), Some(y)) => {\n+                if x != y { return None }\n+            }\n+            (Some(_), None) => return Some(iter),\n+            (None, None) => return Some(iter),\n+            (None, Some(_)) => return None,\n+        }\n+        iter = iter_next;\n+    }\n+}\n+\n+// See note at the top of this module to understand why these are used:\n+fn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n+    unsafe { mem::transmute(s) }\n+}\n+unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n+    mem::transmute(s)\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Cross-platform parsing\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Says whether the path ends in a separator character and therefore needs to\n+/// be treated as if it ended with an additional `.`\n+fn has_suffix(s: &[u8], prefix: Option<Prefix>) -> bool {\n+    let (prefix_len, verbatim) = if let Some(p) = prefix {\n+        (p.len(), p.is_verbatim())\n+    } else { (0, false) };\n+    if prefix_len > 0 && prefix_len == s.len() && !verbatim { return true; }\n+    let mut splits = s[prefix_len..].split(|b| is_sep(*b));\n+    let last = splits.next_back().unwrap();\n+    let more = splits.next_back().is_some();\n+    more && last == b\"\"\n+}\n+\n+/// Says whether the first byte after the prefix is a separator.\n+fn has_physical_root(s: &[u8], prefix: Option<Prefix>) -> bool {\n+    let path = if let Some(p) = prefix { &s[p.len()..] } else { s };\n+    path.len() > 0 && is_sep(path[0])\n+}\n+\n+fn parse_single_component(comp: &[u8]) -> Option<Component> {\n+    match comp {\n+        b\".\" => Some(Component::CurDir),\n+        b\"..\" => Some(Component::ParentDir),\n+        b\"\" => None,\n+        _ => Some(Component::Normal(unsafe { u8_slice_as_os_str(comp) }))\n+    }\n+}\n+\n+// basic workhorse for splitting stem and extension\n+#[allow(unused_unsafe)] // FIXME\n+fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n+    unsafe {\n+        if os_str_as_u8_slice(file) == b\"..\" { return (Some(file), None) }\n+\n+        // The unsafety here stems from converting between &OsStr and &[u8]\n+        // and back. This is safe to do because (1) we only look at ASCII\n+        // contents of the encoding and (2) new &OsStr values are produced\n+        // only from ASCII-bounded slices of existing &OsStr values.\n+\n+        let mut iter = os_str_as_u8_slice(file).rsplitn(1, |b| *b == b'.');\n+        let after = iter.next();\n+        let before = iter.next();\n+        if before == Some(b\"\") {\n+            (Some(file), None)\n+        } else {\n+            (before.map(|s| u8_slice_as_os_str(s)),\n+             after.map(|s| u8_slice_as_os_str(s)))\n+        }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// The core iterators\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Component parsing works by a double-ended state machine; the cursors at the\n+/// front and back of the path each keep track of what parts of the path have\n+/// been consumed so far.\n+///\n+/// Going front to back, a path is made up of a prefix, a root component, a body\n+/// (of normal components), and a suffix/emptycomponent (normalized `.` or ``\n+/// for a path ending with the separator)\n+#[derive(Copy, Clone, PartialEq, PartialOrd, Show)]\n+enum State {\n+    Prefix = 0,         // c:\n+    Root = 1,           // /\n+    Body = 2,           // foo/bar/baz\n+    Suffix = 3,         // .\n+    Done = 4,\n+}\n+\n+/// A single component of a path.\n+///\n+/// See the module documentation for an in-depth explanation of components and\n+/// their role in the API.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Show)]\n+pub enum Component<'a> {\n+    /// A Windows path prefix, e.g. `C:` or `\\server\\share`\n+    Prefix(&'a OsStr),\n+\n+    /// An empty component. Only used on Windows for the last component of\n+    /// verbatim paths ending with a separator (e.g. the last component of\n+    /// `\\\\?\\C:\\windows\\` but not `\\\\?\\C:\\windows` or `C:\\windows`).\n+    Empty,\n+\n+    /// The root directory component, appears after any prefix and before anything else\n+    RootDir,\n+\n+    /// A reference to the current directory, i.e. `.`\n+    CurDir,\n+\n+    /// A reference to the parent directory, i.e. `..`\n+    ParentDir,\n+\n+    /// A normal component, i.e. `a` and `b` in `a/b`\n+    Normal(&'a OsStr),\n+}\n+\n+impl<'a> Component<'a> {\n+    /// Extract the underlying `OsStr` slice\n+    pub fn as_os_str(self) -> &'a OsStr {\n+        match self {\n+            Component::Prefix(path) => path,\n+            Component::Empty => OsStr::from_str(\"\"),\n+            Component::RootDir => OsStr::from_str(MAIN_SEP_STR),\n+            Component::CurDir => OsStr::from_str(\".\"),\n+            Component::ParentDir => OsStr::from_str(\"..\"),\n+            Component::Normal(path) => path,\n+        }\n+    }\n+}\n+\n+/// The core iterator giving the components of a path.\n+///\n+/// See the module documentation for an in-depth explanation of components and\n+/// their role in the API.\n+#[derive(Clone)]\n+pub struct Components<'a> {\n+    // The path left to parse components from\n+    path: &'a [u8],\n+\n+    // The prefix as it was originally parsed, if any\n+    prefix: Option<Prefix<'a>>,\n+\n+    // true if path *physically* has a root separator; for most Windows\n+    // prefixes, it may have a \"logical\" rootseparator for the purposes of\n+    // normalization, e.g.  \\\\server\\share == \\\\server\\share\\.\n+    has_physical_root: bool,\n+\n+    // The iterator is double-ended, and these two states keep track of what has\n+    // been produced from either end\n+    front: State,\n+    back: State,\n+}\n+\n+/// An iterator over the components of a path, as `OsStr` slices.\n+#[derive(Clone)]\n+pub struct Iter<'a> {\n+    inner: Components<'a>\n+}\n+\n+impl<'a> Components<'a> {\n+    // how long is the prefix, if any?\n+    #[inline]\n+    fn prefix_len(&self) -> usize {\n+        self.prefix.as_ref().map(Prefix::len).unwrap_or(0)\n+    }\n+\n+    #[inline]\n+    fn prefix_verbatim(&self) -> bool {\n+        self.prefix.as_ref().map(Prefix::is_verbatim).unwrap_or(false)\n+    }\n+\n+    /// how much of the prefix is left from the point of view of iteration?\n+    #[inline]\n+    fn prefix_remaining(&self) -> usize {\n+        if self.front == State::Prefix { self.prefix_len() }\n+        else { 0 }\n+    }\n+\n+    fn prefix_and_root(&self) -> usize {\n+        let root = if self.front <= State::Root && self.has_physical_root { 1 } else { 0 };\n+        self.prefix_remaining() + root\n+    }\n+\n+    // is the iteration complete?\n+    #[inline]\n+    fn finished(&self) -> bool {\n+        self.front == State::Done || self.back == State::Done || self.front > self.back\n+    }\n+\n+    #[inline]\n+    fn is_sep(&self, b: u8) -> bool {\n+        if self.prefix_verbatim() {\n+            is_verbatim_sep(b)\n+        } else {\n+            is_sep(b)\n+        }\n+    }\n+\n+    /// Extract a slice corresponding to the portion of the path remaining for iteration.\n+    pub fn as_path(&self) -> &'a Path {\n+        let mut comps = self.clone();\n+        if comps.front == State::Body { comps.trim_left(); }\n+        if comps.back == State::Body { comps.trim_right(); }\n+        if comps.path.is_empty() && comps.front < comps.back && comps.back == State::Suffix {\n+            Path::new(\".\")\n+        } else {\n+            unsafe { Path::from_u8_slice(comps.path) }\n+        }\n+    }\n+\n+    /// Is the *original* path rooted?\n+    fn has_root(&self) -> bool {\n+        if self.has_physical_root { return true }\n+        if let Some(p) = self.prefix {\n+            if p.has_implicit_root() { return true }\n+        }\n+        false\n+    }\n+\n+    // parse a component from the left, saying how many bytes to consume to\n+    // remove the component\n+    fn parse_next_component(&self) -> (usize, Option<Component<'a>>) {\n+        debug_assert!(self.front == State::Body);\n+        let (extra, comp) = match self.path.iter().position(|b| self.is_sep(*b)) {\n+            None => (0, self.path),\n+            Some(i) => (1, &self.path[.. i]),\n+        };\n+        (comp.len() + extra, parse_single_component(comp))\n+    }\n+\n+    // parse a component from the right, saying how many bytes to consume to\n+    // remove the component\n+    fn parse_next_component_back(&self) -> (usize, Option<Component<'a>>) {\n+        debug_assert!(self.back == State::Body);\n+        let start = self.prefix_and_root();\n+        let (extra, comp) = match self.path[start..].iter().rposition(|b| self.is_sep(*b)) {\n+            None => (0, &self.path[start ..]),\n+            Some(i) => (1, &self.path[start + i + 1 ..]),\n+        };\n+        (comp.len() + extra, parse_single_component(comp))\n+    }\n+\n+    // trim away repeated separators (i.e. emtpy components) on the left\n+    fn trim_left(&mut self) {\n+        while !self.path.is_empty() {\n+            let (size, comp) = self.parse_next_component();\n+            if comp.is_some() {\n+                return;\n+            } else {\n+                self.path = &self.path[size ..];\n+            }\n+        }\n+    }\n+\n+    // trim away repeated separators (i.e. emtpy components) on the right\n+    fn trim_right(&mut self) {\n+        while self.path.len() > self.prefix_and_root() {\n+            let (size, comp) = self.parse_next_component_back();\n+            if comp.is_some() {\n+                return;\n+            } else {\n+                self.path = &self.path[.. self.path.len() - size];\n+            }\n+        }\n+    }\n+\n+    /// Examine the next component without consuming it.\n+    pub fn peek(&self) -> Option<Component<'a>> {\n+        self.clone().next()\n+    }\n+}\n+\n+impl<'a> Iter<'a> {\n+    /// Extract a slice corresponding to the portion of the path remaining for iteration.\n+    pub fn as_path(&self) -> &'a Path {\n+        self.inner.as_path()\n+    }\n+}\n+\n+impl<'a> Iterator for Iter<'a> {\n+    type Item = &'a OsStr;\n+\n+    fn next(&mut self) -> Option<&'a OsStr> {\n+        self.inner.next().map(Component::as_os_str)\n+    }\n+}\n+\n+impl<'a> DoubleEndedIterator for Iter<'a> {\n+    fn next_back(&mut self) -> Option<&'a OsStr> {\n+        self.inner.next_back().map(Component::as_os_str)\n+    }\n+}\n+\n+impl<'a> Iterator for Components<'a> {\n+    type Item = Component<'a>;\n+\n+    fn next(&mut self) -> Option<Component<'a>> {\n+        while !self.finished() {\n+            match self.front {\n+                State::Prefix if self.prefix_len() > 0 => {\n+                    self.front = State::Root;\n+                    debug_assert!(self.prefix_len() <= self.path.len());\n+                    let prefix = &self.path[.. self.prefix_len()];\n+                    self.path = &self.path[self.prefix_len() .. ];\n+                    return Some(Component::Prefix(unsafe { u8_slice_as_os_str(prefix) }))\n+                }\n+                State::Prefix => {\n+                    self.front = State::Root;\n+                }\n+                State::Root => {\n+                    self.front = State::Body;\n+                    if self.has_physical_root {\n+                        debug_assert!(self.path.len() > 0);\n+                        self.path = &self.path[1..];\n+                        return Some(Component::RootDir)\n+                    } else if let Some(p) = self.prefix {\n+                        if p.has_implicit_root() && !p.is_verbatim() {\n+                            return Some(Component::RootDir)\n+                        }\n+                    }\n+                }\n+                State::Body if !self.path.is_empty() => {\n+                    let (size, comp) = self.parse_next_component();\n+                    self.path = &self.path[size ..];\n+                    if comp.is_some() { return comp }\n+                }\n+                State::Body => {\n+                    self.front = State::Suffix;\n+                }\n+                State::Suffix => {\n+                    self.front = State::Done;\n+                    if self.prefix_verbatim() {\n+                        return Some(Component::Empty)\n+                    } else {\n+                        return Some(Component::CurDir)\n+                    }\n+                }\n+                State::Done => unreachable!()\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'a> DoubleEndedIterator for Components<'a> {\n+    fn next_back(&mut self) -> Option<Component<'a>> {\n+        while !self.finished() {\n+            match self.back {\n+                State::Suffix => {\n+                    self.back = State::Body;\n+                    if self.prefix_verbatim() {\n+                        return Some(Component::Empty)\n+                    } else {\n+                        return Some(Component::CurDir)\n+                    }\n+                }\n+                State::Body if self.path.len() > self.prefix_and_root() => {\n+                    let (size, comp) = self.parse_next_component_back();\n+                    self.path = &self.path[.. self.path.len() - size];\n+                    if comp.is_some() { return comp }\n+                }\n+                State::Body => {\n+                    self.back = State::Root;\n+                }\n+                State::Root => {\n+                    self.back = State::Prefix;\n+                    if self.has_physical_root {\n+                        self.path = &self.path[.. self.path.len() - 1];\n+                        return Some(Component::RootDir)\n+                    } else if let Some(p) = self.prefix {\n+                        if p.has_implicit_root() && !p.is_verbatim() {\n+                            return Some(Component::RootDir)\n+                        }\n+                    }\n+                }\n+                State::Prefix if self.prefix_len() > 0 => {\n+                    self.back = State::Done;\n+                    return Some(Component::Prefix(unsafe {\n+                        u8_slice_as_os_str(self.path)\n+                    }))\n+                }\n+                State::Prefix => {\n+                    self.back = State::Done;\n+                    return None\n+                }\n+                State::Done => unreachable!()\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+fn optional_path(path: &Path) -> Option<&Path> {\n+    if path.as_u8_slice().is_empty() { None } else { Some(path) }\n+}\n+\n+impl<'a> cmp::PartialEq for Components<'a> {\n+    fn eq(&self, other: &Components<'a>) -> bool {\n+        iter::order::eq(self.clone(), other.clone())\n+    }\n+}\n+\n+impl<'a> cmp::Eq for Components<'a> {}\n+\n+impl<'a> cmp::PartialOrd for Components<'a> {\n+    fn partial_cmp(&self, other: &Components<'a>) -> Option<cmp::Ordering> {\n+        iter::order::partial_cmp(self.clone(), other.clone())\n+    }\n+}\n+\n+impl<'a> cmp::Ord for Components<'a> {\n+    fn cmp(&self, other: &Components<'a>) -> cmp::Ordering {\n+        iter::order::cmp(self.clone(), other.clone())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Basic types and traits\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// An owned, mutable path (akin to `String`).\n+///\n+/// This type provides methods like `push` and `set_extension` that mutate the\n+/// path in place. It also implements `Deref` to `Path`, meaning that all\n+/// methods on `Path` slices are available on `PathBuf` values as well.\n+///\n+/// More details about the overall approach can be found in\n+/// the module documentation.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::path::PathBuf;\n+///\n+/// let mut path = PathBuf::new(\"c:\\\\\");\n+/// path.push(\"windows\");\n+/// path.push(\"system32\");\n+/// path.set_extension(\"dll\");\n+/// ```\n+#[derive(Clone, Hash)]\n+pub struct PathBuf {\n+    inner: OsString\n+}\n+\n+impl PathBuf {\n+    fn as_mut_vec(&mut self) -> &mut Vec<u8> {\n+        unsafe { mem::transmute(self) }\n+    }\n+\n+    /// Allocate a `PathBuf` with initial contents given by the\n+    /// argument.\n+    pub fn new<S: ?Sized + AsOsStr>(s: &S) -> PathBuf {\n+        PathBuf { inner: s.as_os_str().to_os_string() }\n+    }\n+\n+    /// Extend `self` with `path`.\n+    ///\n+    /// If `path` is absolute, it replaces the current path.\n+    ///\n+    /// On Windows:\n+    ///\n+    /// * if `path` has a root but no prefix (e.g. `\\windows`), it\n+    ///   replaces everything except for the prefix (if any) of `self`.\n+    /// * if `path` has a prefix but no root, it replaces `self.\n+    pub fn push<P: ?Sized>(&mut self, path: &P) where P: AsPath {\n+        // in general, a separator is needed if the rightmost byte is not a separator\n+        let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep(*c)).unwrap_or(false);\n+\n+        // in the special case of `C:` on Windows, do *not* add a separator\n+        {\n+            let comps = self.components();\n+            if comps.prefix_len() > 0 &&\n+                comps.prefix_len() == comps.path.len() &&\n+                comps.prefix.unwrap().is_drive()\n+            {\n+                need_sep = false\n+            }\n+        }\n+\n+        let path = path.as_path();\n+\n+        // absolute `path` replaces `self`\n+        if path.is_absolute() || path.prefix().is_some() {\n+            self.as_mut_vec().truncate(0);\n+\n+        // `path` has a root but no prefix, e.g. `\\windows` (Windows only)\n+        } else if path.has_root() {\n+            let prefix_len = self.components().prefix_remaining();\n+            self.as_mut_vec().truncate(prefix_len);\n+\n+        // `path` is a pure relative path\n+        } else if need_sep {\n+            self.inner.push_os_str(OsStr::from_str(MAIN_SEP_STR));\n+        }\n+\n+        self.inner.push_os_str(path.as_os_str());\n+    }\n+\n+    /// Truncate `self` to `self.parent()`.\n+    ///\n+    /// Returns `None` and does nothing if `self.parent()` is `None`.\n+    pub fn pop(&mut self) -> bool {\n+        match self.parent().map(|p| p.as_u8_slice().len()) {\n+            Some(len) => {\n+                self.as_mut_vec().truncate(len);\n+                true\n+            }\n+            None => false\n+        }\n+    }\n+\n+    /// Updates `self.file_name()` to `file_name`.\n+    ///\n+    /// If `self.file_name()` was `None`, this is equivalent to pushing\n+    /// `file_name`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::path::{Path, PathBuf};\n+    ///\n+    /// let mut buf = PathBuf::new(\"/foo/\");\n+    /// assert!(buf.file_name() == None);\n+    /// buf.set_file_name(\"bar\");\n+    /// assert!(buf == PathBuf::new(\"/foo/bar\"));\n+    /// assert!(buf.file_name().is_some());\n+    /// buf.set_file_name(\"baz.txt\");\n+    /// assert!(buf == PathBuf::new(\"/foo/baz.txt\"));\n+    /// ```\n+    pub fn set_file_name<S: ?Sized>(&mut self, file_name: &S) where S: AsOsStr {\n+        if self.file_name().is_some() && !self.pop() {\n+            // Given that there is a file name, this is reachable only for\n+            // Windows paths like c:file or paths like `foo`, but not `c:\\` or\n+            // `/`.\n+            let prefix_len = self.components().prefix_remaining();\n+            self.as_mut_vec().truncate(prefix_len);\n+        }\n+        self.push(file_name.as_os_str());\n+    }\n+\n+    /// Updates `self.extension()` to `extension`.\n+    ///\n+    /// If `self.file_name()` is `None`, does nothing and returns `false`.\n+    ///\n+    /// Otherwise, returns `tru`; if `self.exension()` is `None`, the extension\n+    /// is added; otherwise it is replaced.\n+    pub fn set_extension<S: ?Sized + AsOsStr>(&mut self, extension: &S) -> bool {\n+        if self.file_name().is_none() { return false; }\n+\n+        let mut stem = match self.file_stem() {\n+            Some(stem) => stem.to_os_string(),\n+            None => OsString::from_str(\"\"),\n+        };\n+\n+        let extension = extension.as_os_str();\n+        if os_str_as_u8_slice(extension).len() > 0 {\n+            stem.push_os_str(OsStr::from_str(\".\"));\n+            stem.push_os_str(extension.as_os_str());\n+        }\n+        self.set_file_name(&stem);\n+\n+        true\n+    }\n+}\n+\n+impl<'a, P: ?Sized + 'a> iter::FromIterator<&'a P> for PathBuf where P: AsPath {\n+    fn from_iter<I: Iterator<Item = &'a P>>(iter: I) -> PathBuf {\n+        let mut buf = PathBuf::new(\"\");\n+        buf.extend(iter);\n+        buf\n+    }\n+}\n+\n+impl<'a, P: ?Sized + 'a> iter::Extend<&'a P> for PathBuf where P: AsPath {\n+    fn extend<I: Iterator<Item = &'a P>>(&mut self, iter: I) {\n+        for p in iter {\n+            self.push(p)\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for PathBuf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        fmt::Debug::fmt(&**self, formatter)\n+    }\n+}\n+\n+impl ops::Deref for PathBuf {\n+    type Target = Path;\n+\n+    fn deref(&self) -> &Path {\n+        unsafe { mem::transmute(&self.inner[]) }\n+    }\n+}\n+\n+impl BorrowFrom<PathBuf> for Path {\n+    fn borrow_from(owned: &PathBuf) -> &Path {\n+        owned.deref()\n+    }\n+}\n+\n+impl cmp::PartialEq for PathBuf {\n+    fn eq(&self, other: &PathBuf) -> bool {\n+        self.components() == other.components()\n+    }\n+}\n+\n+impl cmp::Eq for PathBuf {}\n+\n+impl cmp::PartialOrd for PathBuf {\n+    fn partial_cmp(&self, other: &PathBuf) -> Option<cmp::Ordering> {\n+        self.components().partial_cmp(&other.components())\n+    }\n+}\n+\n+impl cmp::Ord for PathBuf {\n+    fn cmp(&self, other: &PathBuf) -> cmp::Ordering {\n+        self.components().cmp(&other.components())\n+    }\n+}\n+\n+/// A slice of a path (akin to `str`).\n+///\n+/// This type supports a number of operations for inspecting a path, including\n+/// breaking the path into its components (separated by `/` or `\\`, depending on\n+/// the platform), extracting the file name, determining whether the path is\n+/// absolute, and so on. More details about the overall approach can be found in\n+/// the module documentation.\n+///\n+/// This is an *unsized* type, meaning that it must always be used with behind a\n+/// pointer like `&` or `Box`.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::path::Path;\n+///\n+/// let path = Path::new(\"/tmp/foo/bar.txt\");\n+/// let file = path.file_name();\n+/// let extension = path.extension();\n+/// let parent_dir = path.parent();\n+/// ```\n+///\n+pub struct Path {\n+    inner: OsStr\n+}\n+\n+impl Path {\n+    // The following (private!) function allows construction of a path from a u8\n+    // slice, which is only safe when it is known to follow the OsStr encoding.\n+    unsafe fn from_u8_slice(s: &[u8]) -> &Path {\n+        mem::transmute(s)\n+    }\n+    // The following (private!) function reveals the byte encoding used for OsStr.\n+    fn as_u8_slice(&self) -> &[u8] {\n+        unsafe { mem::transmute(self) }\n+    }\n+\n+    /// Directly wrap a string slice as a `Path` slice.\n+    ///\n+    /// This is a cost-free conversion.\n+    pub fn new<S: ?Sized + AsOsStr>(s: &S) -> &Path {\n+        unsafe { mem::transmute(s.as_os_str()) }\n+    }\n+\n+    /// Yield a `&str` slice if the `Path` is valid unicode.\n+    ///\n+    /// This conversion may entail doing a check for UTF-8 validity.\n+    pub fn to_str(&self) -> Option<&str> {\n+        self.inner.to_str()\n+    }\n+\n+    /// Convert a `Path` to a `CowString`.\n+    ///\n+    /// Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    pub fn to_string_lossy(&self) -> CowString {\n+        self.inner.to_string_lossy()\n+    }\n+\n+    /// Convert a `Path` to an owned `PathBuf`.\n+    pub fn to_path_buf(&self) -> PathBuf {\n+        PathBuf::new(self)\n+    }\n+\n+    /// A path is *absolute* if it is indepedent of the current directory.\n+    ///\n+    /// * On Unix, a path is absolute if it starts with the root, so\n+    /// `is_absolute` and `has_root` are equivalent.\n+    ///\n+    /// * On Windows, a path is absolute if it has a prefix and starts with the\n+    /// root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not. In\n+    /// other words, `path.is_absolute() == path.prefix().is_some() && path.has_root()`.\n+    pub fn is_absolute(&self) -> bool {\n+        self.has_root() &&\n+            (cfg!(unix) || self.prefix().is_some())\n+    }\n+\n+    /// A path is *relative* if it is not absolute.\n+    pub fn is_relative(&self) -> bool {\n+        !self.is_absolute()\n+    }\n+\n+    /// Returns the *prefix* of a path, if any.\n+    ///\n+    /// Prefixes are relevant only for Windows paths, and consist of volumes\n+    /// like `C:`, UNC prefixes like `\\\\server`, and others described in more\n+    /// detail in `std::os::windows::PathExt`.\n+    pub fn prefix(&self) -> Option<&Path> {\n+        let iter = self.components();\n+        optional_path(unsafe {\n+            Path::from_u8_slice(\n+                &self.as_u8_slice()[.. iter.prefix_remaining()])\n+        })\n+    }\n+\n+    /// A path has a root if the body of the path begins with the directory separator.\n+    ///\n+    /// * On Unix, a path has a root if it begins with `/`.\n+    ///\n+    /// * On Windows, a path has a root if it:\n+    ///     * has no prefix and begins with a separator, e.g. `\\\\windows`\n+    ///     * has a prefix followed by a separator, e.g. `c:\\windows` but not `c:windows`\n+    ///     * has any non-disk prefix, e.g. `\\\\server\\share`\n+    pub fn has_root(&self) -> bool {\n+         self.components().has_root()\n+    }\n+\n+    /// The path without its final component.\n+    ///\n+    /// Does nothing, returning `None` if the path consists of just a prefix\n+    /// and/or root directory reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/foo/bar\");\n+    /// let foo = path.parent().unwrap();\n+    /// assert!(foo == Path::new(\"/foo\"));\n+    /// let root = foo.parent().unwrap();\n+    /// assert!(root == Path::new(\"/\"));\n+    /// assert!(root.parent() == None);\n+    /// ```\n+    pub fn parent(&self) -> Option<&Path> {\n+        let mut comps = self.components();\n+        let comp = comps.next_back();\n+        let rest = optional_path(comps.as_path());\n+\n+        match (comp, comps.next_back()) {\n+            (Some(Component::CurDir), Some(Component::RootDir)) => None,\n+            (Some(Component::CurDir), Some(Component::Prefix(_))) => None,\n+            (Some(Component::Empty), Some(Component::RootDir)) => None,\n+            (Some(Component::Empty), Some(Component::Prefix(_))) => None,\n+            (Some(Component::Prefix(_)), None) => None,\n+            (Some(Component::RootDir), Some(Component::Prefix(_))) => None,\n+            _ => rest\n+        }\n+    }\n+\n+    /// The final component of the path, if it is a normal file.\n+    ///\n+    /// If the path terminates in `.`, `..`, or consists solely or a root of\n+    /// prefix, `file` will return `None`.\n+    pub fn file_name(&self) -> Option<&OsStr> {\n+        self.components().next_back().and_then(|p| match p {\n+            Component::Normal(p) => Some(p.as_os_str()),\n+            _ => None\n+        })\n+    }\n+\n+    /// Returns a path that, when joined onto `base`, yields `self`.\n+    pub fn relative_from<'a, P: ?Sized>(&'a self, base: &'a P) -> Option<&Path> where\n+        P: AsPath\n+    {\n+        iter_after(self.components(), base.as_path().components()).map(|c| c.as_path())\n+    }\n+\n+    /// Determines whether `base` is a prefix of `self`.\n+    pub fn starts_with<P: ?Sized>(&self, base: &P) -> bool where P: AsPath {\n+        iter_after(self.components(), base.as_path().components()).is_some()\n+    }\n+\n+    /// Determines whether `base` is a suffix of `self`.\n+    pub fn ends_with<P: ?Sized>(&self, child: &P) -> bool where P: AsPath {\n+        iter_after(self.components().rev(), child.as_path().components().rev()).is_some()\n+    }\n+\n+    /// Extract the stem (non-extension) portion of `self.file()`.\n+    ///\n+    /// The stem is:\n+    ///\n+    /// * None, if there is no file name;\n+    /// * The entire file name if there is no embedded `.`;\n+    /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n+    /// * Otherwise, the portion of the file name before the final `.`\n+    pub fn file_stem(&self) -> Option<&OsStr> {\n+        self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.or(after))\n+    }\n+\n+    /// Extract the extension of `self.file()`, if possible.\n+    ///\n+    /// The extension is:\n+    ///\n+    /// * None, if there is no file name;\n+    /// * None, if there is no embedded `.`;\n+    /// * None, if the file name begins with `.` and has no other `.`s within;\n+    /// * Otherwise, the portion of the file name after the final `.`\n+    pub fn extension(&self) -> Option<&OsStr> {\n+        self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.and(after))\n+    }\n+\n+    /// Creates an owned `PathBuf` with `path` adjoined to `self`.\n+    ///\n+    /// See `PathBuf::push` for more details on what it means to adjoin a path.\n+    pub fn join<P: ?Sized>(&self, path: &P) -> PathBuf where P: AsPath {\n+        let mut buf = self.to_path_buf();\n+        buf.push(path);\n+        buf\n+    }\n+\n+    /// Creates an owned `PathBuf` like `self` but with the given file name.\n+    ///\n+    /// See `PathBuf::set_file_name` for more details.\n+    pub fn with_file_name<S: ?Sized>(&self, file_name: &S) -> PathBuf where S: AsOsStr {\n+        let mut buf = self.to_path_buf();\n+        buf.set_file_name(file_name);\n+        buf\n+    }\n+\n+    /// Creates an owned `PathBuf` like `self` but with the given extension.\n+    ///\n+    /// See `PathBuf::set_extension` for more details.\n+    pub fn with_extension<S: ?Sized>(&self, extension: &S) -> PathBuf where S: AsOsStr {\n+        let mut buf = self.to_path_buf();\n+        buf.set_extension(extension);\n+        buf\n+    }\n+\n+    /// Produce an iterator over the components of the path.\n+    pub fn components(&self) -> Components {\n+        let prefix = parse_prefix(self.as_os_str());\n+        Components {\n+            path: self.as_u8_slice(),\n+            prefix: prefix,\n+            has_physical_root: has_physical_root(self.as_u8_slice(), prefix),\n+            front: State::Prefix,\n+            back: if has_suffix(self.as_u8_slice(), prefix) { State::Suffix }\n+                  else { State::Body },\n+        }\n+    }\n+\n+    /// Produce an iterator over the path's components viewed as `OsStr` slices.\n+    pub fn iter(&self) -> Iter {\n+        Iter { inner: self.components() }\n+    }\n+\n+    /// Returns an object that implements `Display` for safely printing paths\n+    /// that may contain non-Unicode data.\n+    pub fn display(&self) -> Display {\n+        Display { path: self }\n+    }\n+}\n+\n+impl AsOsStr for Path {\n+    fn as_os_str(&self) -> &OsStr {\n+        &self.inner\n+    }\n+}\n+\n+impl fmt::Debug for Path {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.inner.fmt(formatter)\n+    }\n+}\n+\n+/// Helper struct for safely printing paths with `format!()` and `{}`\n+pub struct Display<'a> {\n+    path: &'a Path\n+}\n+\n+impl<'a> fmt::Debug for Display<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.path.to_string_lossy(), f)\n+    }\n+}\n+\n+impl<'a> fmt::Display for Display<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.path.to_string_lossy(), f)\n+    }\n+}\n+\n+impl cmp::PartialEq for Path {\n+    fn eq(&self, other: &Path) -> bool {\n+        iter::order::eq(self.components(), other.components())\n+    }\n+}\n+\n+impl cmp::Eq for Path {}\n+\n+impl cmp::PartialOrd for Path {\n+    fn partial_cmp(&self, other: &Path) -> Option<cmp::Ordering> {\n+        self.components().partial_cmp(&other.components())\n+    }\n+}\n+\n+impl cmp::Ord for Path {\n+    fn cmp(&self, other: &Path) -> cmp::Ordering {\n+        self.components().cmp(&other.components())\n+    }\n+}\n+\n+/// Freely convertible to a `Path`.\n+pub trait AsPath {\n+    /// Convert to a `Path`.\n+    fn as_path(&self) -> &Path;\n+}\n+\n+impl<T: AsOsStr + ?Sized> AsPath for T {\n+    fn as_path(&self) -> &Path { Path::new(self.as_os_str()) }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use ffi::OsStr;\n+    use core::prelude::*;\n+    use string::{ToString, String};\n+    use vec::Vec;\n+\n+    macro_rules! t(\n+        ($path:expr, iter: $iter:expr) => (\n+            {\n+                let path = Path::new($path);\n+\n+                // Forward iteration\n+                let comps = path.iter()\n+                    .map(|p| p.to_string_lossy().into_owned())\n+                    .collect::<Vec<String>>();\n+                let exp: &[&str] = &$iter;\n+                let exps = exp.iter().map(|s| s.to_string()).collect::<Vec<String>>();\n+                assert!(comps == exps, \"iter: Expected {:?}, found {:?}\",\n+                        exps, comps);\n+\n+                // Reverse iteration\n+                let comps = Path::new($path).iter().rev()\n+                    .map(|p| p.to_string_lossy().into_owned())\n+                    .collect::<Vec<String>>();\n+                let exps = exps.into_iter().rev().collect::<Vec<String>>();\n+                assert!(comps == exps, \"iter().rev(): Expected {:?}, found {:?}\",\n+                        exps, comps);\n+            }\n+        );\n+\n+        ($path:expr, has_root: $has_root:expr, is_absolute: $is_absolute:expr) => (\n+            {\n+                let path = Path::new($path);\n+\n+                let act_root = path.has_root();\n+                assert!(act_root == $has_root, \"has_root: Expected {:?}, found {:?}\",\n+                        $has_root, act_root);\n+\n+                let act_abs = path.is_absolute();\n+                assert!(act_abs == $is_absolute, \"is_absolute: Expected {:?}, found {:?}\",\n+                        $is_absolute, act_abs);\n+            }\n+        );\n+\n+        ($path:expr, parent: $parent:expr, file_name: $file:expr) => (\n+            {\n+                let path = Path::new($path);\n+\n+                let parent = path.parent().map(|p| p.to_str().unwrap());\n+                let exp_parent: Option<&str> = $parent;\n+                assert!(parent == exp_parent, \"parent: Expected {:?}, found {:?}\",\n+                        exp_parent, parent);\n+\n+                let file = path.file_name().map(|p| p.to_str().unwrap());\n+                let exp_file: Option<&str> = $file;\n+                assert!(file == exp_file, \"file_name: Expected {:?}, found {:?}\",\n+                        exp_file, file);\n+            }\n+        );\n+\n+        ($path:expr, file_stem: $file_stem:expr, extension: $extension:expr) => (\n+            {\n+                let path = Path::new($path);\n+\n+                let stem = path.file_stem().map(|p| p.to_str().unwrap());\n+                let exp_stem: Option<&str> = $file_stem;\n+                assert!(stem == exp_stem, \"file_stem: Expected {:?}, found {:?}\",\n+                        exp_stem, stem);\n+\n+                let ext = path.extension().map(|p| p.to_str().unwrap());\n+                let exp_ext: Option<&str> = $extension;\n+                assert!(ext == exp_ext, \"extension: Expected {:?}, found {:?}\",\n+                        exp_ext, ext);\n+            }\n+        );\n+\n+        ($path:expr, iter: $iter:expr,\n+                     has_root: $has_root:expr, is_absolute: $is_absolute:expr,\n+                     parent: $parent:expr, file_name: $file:expr,\n+                     file_stem: $file_stem:expr, extension: $extension:expr) => (\n+            {\n+                t!($path, iter: $iter);\n+                t!($path, has_root: $has_root, is_absolute: $is_absolute);\n+                t!($path, parent: $parent, file_name: $file);\n+                t!($path, file_stem: $file_stem, extension: $extension);\n+            }\n+        );\n+    );\n+\n+    #[test]\n+    #[cfg(unix)]\n+    pub fn test_decompositions_unix() {\n+        t!(\"\",\n+           iter: [],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo\",\n+           iter: [\"foo\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n+           extension: None\n+           );\n+\n+        t!(\"/\",\n+           iter: [\"/\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"/foo\",\n+           iter: [\"/\", \"foo\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"/\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n+           extension: None\n+           );\n+\n+        t!(\"foo/\",\n+           iter: [\"foo\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"/foo/\",\n+           iter: [\"/\", \"foo\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"/foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/bar\",\n+           iter: [\"foo\", \"bar\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"/foo/bar\",\n+           iter: [\"/\", \"foo\", \"bar\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"/foo\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"///foo///\",\n+           iter: [\"/\", \"foo\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"///foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"///foo///bar\",\n+           iter: [\"/\", \"foo\", \"bar\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"///foo\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"./.\",\n+           iter: [\".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"./.\",\n+           iter: [\".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"/..\",\n+           iter: [\"/\", \"..\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"/\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"../\",\n+           iter: [\"..\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"..\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/.\",\n+           iter: [\"foo\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/..\",\n+           iter: [\"foo\", \"..\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/./\",\n+           iter: [\"foo\", \".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/.\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/./bar\",\n+           iter: [\"foo\", \".\", \"bar\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/.\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"foo/../\",\n+           iter: [\"foo\", \"..\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/..\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/../bar\",\n+           iter: [\"foo\", \"..\", \"bar\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/..\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"./a\",\n+           iter: [\".\", \"a\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: Some(\"a\"),\n+           file_stem: Some(\"a\"),\n+           extension: None\n+           );\n+\n+        t!(\".\",\n+           iter: [\".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"./\",\n+           iter: [\".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"a/b\",\n+           iter: [\"a\", \"b\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n+           extension: None\n+           );\n+\n+        t!(\"a//b\",\n+           iter: [\"a\", \"b\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n+           extension: None\n+           );\n+\n+        t!(\"a/./b\",\n+           iter: [\"a\", \".\", \"b\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a/.\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n+           extension: None\n+           );\n+\n+        t!(\"a/b/c\",\n+           iter: [\"a\", \"b\", \"c\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a/b\"),\n+           file_name: Some(\"c\"),\n+           file_stem: Some(\"c\"),\n+           extension: None\n+           );\n+    }\n+\n+    #[test]\n+    #[cfg(windows)]\n+    pub fn test_decompositions_windows() {\n+        t!(\"\",\n+           iter: [],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo\",\n+           iter: [\"foo\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n+           extension: None\n+           );\n+\n+        t!(\"/\",\n+           iter: [\"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\",\n+           iter: [\"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"c:\",\n+           iter: [\"c:\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"c:\\\\\",\n+           iter: [\"c:\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"c:\\\\\",\n+           iter: [\"c:\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"c:/\",\n+           iter: [\"c:\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"/foo\",\n+           iter: [\"\\\\\", \"foo\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"/\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n+           extension: None\n+           );\n+\n+        t!(\"foo/\",\n+           iter: [\"foo\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"/foo/\",\n+           iter: [\"\\\\\", \"foo\", \".\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"/foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/bar\",\n+           iter: [\"foo\", \"bar\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"/foo/bar\",\n+           iter: [\"\\\\\", \"foo\", \"bar\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"/foo\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"///foo///\",\n+           iter: [\"\\\\\", \"foo\", \".\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"///foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"///foo///bar\",\n+           iter: [\"\\\\\", \"foo\", \"bar\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"///foo\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"./.\",\n+           iter: [\".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"./.\",\n+           iter: [\".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"/..\",\n+           iter: [\"\\\\\", \"..\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"/\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"../\",\n+           iter: [\"..\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"..\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/.\",\n+           iter: [\"foo\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/..\",\n+           iter: [\"foo\", \"..\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/./\",\n+           iter: [\"foo\", \".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/.\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/./bar\",\n+           iter: [\"foo\", \".\", \"bar\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/.\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"foo/../\",\n+           iter: [\"foo\", \"..\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/..\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/../bar\",\n+           iter: [\"foo\", \"..\", \"bar\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/..\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"./a\",\n+           iter: [\".\", \"a\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: Some(\"a\"),\n+           file_stem: Some(\"a\"),\n+           extension: None\n+           );\n+\n+        t!(\".\",\n+           iter: [\".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"./\",\n+           iter: [\".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"a/b\",\n+           iter: [\"a\", \"b\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n+           extension: None\n+           );\n+\n+        t!(\"a//b\",\n+           iter: [\"a\", \"b\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n+           extension: None\n+           );\n+\n+        t!(\"a/./b\",\n+           iter: [\"a\", \".\", \"b\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a/.\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n+           extension: None\n+           );\n+\n+        t!(\"a/b/c\",\n+           iter: [\"a\", \"b\", \"c\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a/b\"),\n+           file_name: Some(\"c\"),\n+           file_stem: Some(\"c\"),\n+           extension: None);\n+\n+        t!(\"a\\\\b\\\\c\",\n+           iter: [\"a\", \"b\", \"c\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a\\\\b\"),\n+           file_name: Some(\"c\"),\n+           file_stem: Some(\"c\"),\n+           extension: None\n+           );\n+\n+        t!(\"\\\\a\",\n+           iter: [\"\\\\\", \"a\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"\\\\\"),\n+           file_name: Some(\"a\"),\n+           file_stem: Some(\"a\"),\n+           extension: None\n+           );\n+\n+        t!(\"c:\\\\foo.txt\",\n+           iter: [\"c:\", \"\\\\\", \"foo.txt\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"c:\\\\\"),\n+           file_name: Some(\"foo.txt\"),\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+        t!(\"\\\\\\\\server\\\\share\\\\foo.txt\",\n+           iter: [\"\\\\\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\server\\\\share\\\\\"),\n+           file_name: Some(\"foo.txt\"),\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+        t!(\"\\\\\\\\server\\\\share\",\n+           iter: [\"\\\\\\\\server\\\\share\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\server\",\n+           iter: [\"\\\\\", \"server\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"\\\\\"),\n+           file_name: Some(\"server\"),\n+           file_stem: Some(\"server\"),\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\bar\\\\foo.txt\",\n+           iter: [\"\\\\\\\\?\\\\bar\", \"\\\\\", \"foo.txt\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\?\\\\bar\\\\\"),\n+           file_name: Some(\"foo.txt\"),\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\bar\",\n+           iter: [\"\\\\\\\\?\\\\bar\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\\",\n+           iter: [\"\\\\\\\\?\\\\\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo.txt\",\n+           iter: [\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\"),\n+           file_name: Some(\"foo.txt\"),\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\UNC\\\\server\",\n+           iter: [\"\\\\\\\\?\\\\UNC\\\\server\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\UNC\\\\\",\n+           iter: [\"\\\\\\\\?\\\\UNC\\\\\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\C:\\\\foo.txt\",\n+           iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\", \"foo.txt\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\?\\\\C:\\\\\"),\n+           file_name: Some(\"foo.txt\"),\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+\n+        t!(\"\\\\\\\\?\\\\C:\\\\\",\n+           iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\", \"\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\?\\\\C:\",\n+           iter: [\"\\\\\\\\?\\\\C:\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\?\\\\foo/bar\",\n+           iter: [\"\\\\\\\\?\\\\foo/bar\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\?\\\\C:/foo\",\n+           iter: [\"\\\\\\\\?\\\\C:/foo\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\.\\\\foo\\\\bar\",\n+           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\.\\\\foo\\\\\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\.\\\\foo\",\n+           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\.\\\\foo/bar\",\n+           iter: [\"\\\\\\\\.\\\\foo/bar\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\.\\\\foo\\\\bar/baz\",\n+           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\", \"baz\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\.\\\\foo\\\\bar\"),\n+           file_name: Some(\"baz\"),\n+           file_stem: Some(\"baz\"),\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\.\\\\\",\n+           iter: [\"\\\\\\\\.\\\\\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\a\\\\b\\\\\",\n+           iter: [\"\\\\\\\\?\\\\a\", \"\\\\\", \"b\", \"\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\?\\\\a\\\\b\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+    }\n+\n+    #[test]\n+    pub fn test_stem_ext() {\n+        t!(\"foo\",\n+           file_stem: Some(\"foo\"),\n+           extension: None\n+           );\n+\n+        t!(\"foo.\",\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"\")\n+           );\n+\n+        t!(\".foo\",\n+           file_stem: Some(\".foo\"),\n+           extension: None\n+           );\n+\n+        t!(\"foo.txt\",\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+        t!(\"foo.bar.txt\",\n+           file_stem: Some(\"foo.bar\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+        t!(\"foo.bar.\",\n+           file_stem: Some(\"foo.bar\"),\n+           extension: Some(\"\")\n+           );\n+\n+        t!(\".\",\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"..\",\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\",\n+           file_stem: None,\n+           extension: None\n+           );\n+    }\n+\n+    #[test]\n+    pub fn test_push() {\n+        macro_rules! tp(\n+            ($path:expr, $push:expr, $expected:expr) => ( {\n+                let mut actual = PathBuf::new($path);\n+                actual.push($push);\n+                assert!(actual.to_str() == Some($expected),\n+                        \"pushing {:?} onto {:?}: Expected {:?}, got {:?}\",\n+                        $push, $path, $expected, actual.to_str().unwrap());\n+            });\n+        );\n+\n+        if cfg!(unix) {\n+            tp!(\"\", \"foo\", \"foo\");\n+            tp!(\"foo\", \"bar\", \"foo/bar\");\n+            tp!(\"foo/\", \"bar\", \"foo/bar\");\n+            tp!(\"foo//\", \"bar\", \"foo//bar\");\n+            tp!(\"foo/.\", \"bar\", \"foo/./bar\");\n+            tp!(\"foo./.\", \"bar\", \"foo././bar\");\n+            tp!(\"foo\", \"\", \"foo/\");\n+            tp!(\"foo\", \".\", \"foo/.\");\n+            tp!(\"foo\", \"..\", \"foo/..\");\n+            tp!(\"foo\", \"/\", \"/\");\n+            tp!(\"/foo/bar\", \"/\", \"/\");\n+            tp!(\"/foo/bar\", \"/baz\", \"/baz\");\n+            tp!(\"/foo/bar\", \"./baz\", \"/foo/bar/./baz\");\n+        } else {\n+            tp!(\"\", \"foo\", \"foo\");\n+            tp!(\"foo\", \"bar\", r\"foo\\bar\");\n+            tp!(\"foo/\", \"bar\", r\"foo/bar\");\n+            tp!(r\"foo\\\", \"bar\", r\"foo\\bar\");\n+            tp!(\"foo//\", \"bar\", r\"foo//bar\");\n+            tp!(r\"foo\\\\\", \"bar\", r\"foo\\\\bar\");\n+            tp!(\"foo/.\", \"bar\", r\"foo/.\\bar\");\n+            tp!(\"foo./.\", \"bar\", r\"foo./.\\bar\");\n+            tp!(r\"foo\\.\", \"bar\", r\"foo\\.\\bar\");\n+            tp!(r\"foo.\\.\", \"bar\", r\"foo.\\.\\bar\");\n+            tp!(\"foo\", \"\", \"foo\\\\\");\n+            tp!(\"foo\", \".\", r\"foo\\.\");\n+            tp!(\"foo\", \"..\", r\"foo\\..\");\n+            tp!(\"foo\", \"/\", \"/\");\n+            tp!(\"foo\", r\"\\\", r\"\\\");\n+            tp!(\"/foo/bar\", \"/\", \"/\");\n+            tp!(r\"\\foo\\bar\", r\"\\\", r\"\\\");\n+            tp!(\"/foo/bar\", \"/baz\", \"/baz\");\n+            tp!(\"/foo/bar\", r\"\\baz\", r\"\\baz\");\n+            tp!(\"/foo/bar\", \"./baz\", r\"/foo/bar\\./baz\");\n+            tp!(\"/foo/bar\", r\".\\baz\", r\"/foo/bar\\.\\baz\");\n+\n+            tp!(\"c:\\\\\", \"windows\", \"c:\\\\windows\");\n+            tp!(\"c:\", \"windows\", \"c:windows\");\n+\n+            tp!(\"a\\\\b\\\\c\", \"d\", \"a\\\\b\\\\c\\\\d\");\n+            tp!(\"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n+            tp!(\"a\\\\b\", \"c\\\\d\", \"a\\\\b\\\\c\\\\d\");\n+            tp!(\"a\\\\b\", \"\\\\c\\\\d\", \"\\\\c\\\\d\");\n+            tp!(\"a\\\\b\", \".\", \"a\\\\b\\\\.\");\n+            tp!(\"a\\\\b\", \"..\\\\c\", \"a\\\\b\\\\..\\\\c\");\n+            tp!(\"a\\\\b\", \"C:a.txt\", \"C:a.txt\");\n+            tp!(\"a\\\\b\", \"C:\\\\a.txt\", \"C:\\\\a.txt\");\n+            tp!(\"C:\\\\a\", \"C:\\\\b.txt\", \"C:\\\\b.txt\");\n+            tp!(\"C:\\\\a\\\\b\\\\c\", \"C:d\", \"C:d\");\n+            tp!(\"C:a\\\\b\\\\c\", \"C:d\", \"C:d\");\n+            tp!(\"C:\", r\"a\\b\\c\", r\"C:a\\b\\c\");\n+            tp!(\"C:\", r\"..\\a\", r\"C:..\\a\");\n+            tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\server\\\\share\\\\foo\\\\bar\");\n+            tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"C:baz\", \"C:baz\");\n+            tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n+            tp!(\"\\\\\\\\?\\\\C:a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n+            tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\c\\\\d\", \"C:\\\\c\\\\d\");\n+            tp!(\"\\\\\\\\?\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\");\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\");\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:\\\\a\", \"C:\\\\a\");\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:a\", \"C:a\");\n+\n+            // Note: modified from old path API\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\", \"foo\", \"\\\\\\\\?\\\\UNC\\\\server\\\\foo\");\n+\n+            tp!(\"C:\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n+            tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\");\n+            tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"C:a\", \"C:a\");\n+            // again, not sure about the following, but I'm assuming \\\\.\\ should be verbatim\n+            tp!(\"\\\\\\\\.\\\\foo\", \"..\\\\bar\", \"\\\\\\\\.\\\\foo\\\\..\\\\bar\");\n+\n+            tp!(\"\\\\\\\\?\\\\C:\", \"foo\", \"\\\\\\\\?\\\\C:\\\\foo\"); // this is a weird one\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_pop() {\n+        macro_rules! tp(\n+            ($path:expr, $expected:expr, $output:expr) => ( {\n+                let mut actual = PathBuf::new($path);\n+                let output = actual.pop();\n+                assert!(actual.to_str() == Some($expected) && output == $output,\n+                        \"popping from {:?}: Expected {:?}/{:?}, got {:?}/{:?}\",\n+                        $path, $expected, $output,\n+                        actual.to_str().unwrap(), output);\n+            });\n+        );\n+\n+        tp!(\"\", \"\", false);\n+        tp!(\"/\", \"/\", false);\n+        tp!(\"foo\", \"foo\", false);\n+        tp!(\".\", \".\", false);\n+        tp!(\"/foo\", \"/\", true);\n+        tp!(\"/foo/bar\", \"/foo\", true);\n+        tp!(\"foo/bar\", \"foo\", true);\n+        tp!(\"foo/.\", \"foo\", true);\n+        tp!(\"foo//bar\", \"foo\", true);\n+\n+        if cfg!(windows) {\n+            tp!(\"a\\\\b\\\\c\", \"a\\\\b\", true);\n+            tp!(\"\\\\a\", \"\\\\\", true);\n+            tp!(\"\\\\\", \"\\\\\", false);\n+\n+            tp!(\"C:\\\\a\\\\b\", \"C:\\\\a\", true);\n+            tp!(\"C:\\\\a\", \"C:\\\\\", true);\n+            tp!(\"C:\\\\\", \"C:\\\\\", false);\n+            tp!(\"C:a\\\\b\", \"C:a\", true);\n+            tp!(\"C:a\", \"C:\", true);\n+            tp!(\"C:\", \"C:\", false);\n+            tp!(\"\\\\\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\server\\\\share\\\\a\", true);\n+            tp!(\"\\\\\\\\server\\\\share\\\\a\", \"\\\\\\\\server\\\\share\\\\\", true);\n+            tp!(\"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\", false);\n+            tp!(\"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", true);\n+            tp!(\"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\\\\\", true);\n+            tp!(\"\\\\\\\\?\\\\a\", \"\\\\\\\\?\\\\a\", false);\n+            tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", true);\n+            tp!(\"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\", true);\n+            tp!(\"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\\", false);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", true);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\", true);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", false);\n+            tp!(\"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", true);\n+            tp!(\"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\\\\\", true);\n+            tp!(\"\\\\\\\\.\\\\a\", \"\\\\\\\\.\\\\a\", false);\n+\n+            tp!(\"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\\\\b\", true);\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_set_file_name() {\n+        macro_rules! tfn(\n+                ($path:expr, $file:expr, $expected:expr) => ( {\n+                let mut p = PathBuf::new($path);\n+                p.set_file_name($file);\n+                assert!(p.to_str() == Some($expected),\n+                        \"setting file name of {:?} to {:?}: Expected {:?}, got {:?}\",\n+                        $path, $file, $expected,\n+                        p.to_str().unwrap());\n+            });\n+        );\n+\n+        tfn!(\"foo\", \"foo\", \"foo\");\n+        tfn!(\"foo\", \"bar\", \"bar\");\n+        tfn!(\"foo\", \"\", \"\");\n+        tfn!(\"\", \"foo\", \"foo\");\n+        tfn!(\".\", \"foo\", \"./foo\");\n+        tfn!(\"foo/\", \"bar\", \"foo/bar\");\n+        tfn!(\"foo/.\", \"bar\", \"foo/./bar\");\n+        tfn!(\"..\", \"foo\", \"../foo\");\n+        tfn!(\"foo/..\", \"bar\", \"foo/../bar\");\n+        tfn!(\"/\", \"foo\", \"/foo\");\n+    }\n+\n+    #[test]\n+    pub fn test_set_extension() {\n+        macro_rules! tfe(\n+                ($path:expr, $ext:expr, $expected:expr, $output:expr) => ( {\n+                let mut p = PathBuf::new($path);\n+                let output = p.set_extension($ext);\n+                assert!(p.to_str() == Some($expected) && output == $output,\n+                        \"setting extension of {:?} to {:?}: Expected {:?}/{:?}, got {:?}/{:?}\",\n+                        $path, $ext, $expected, $output,\n+                        p.to_str().unwrap(), output);\n+            });\n+        );\n+\n+        tfe!(\"foo\", \"txt\", \"foo.txt\", true);\n+        tfe!(\"foo.bar\", \"txt\", \"foo.txt\", true);\n+        tfe!(\"foo.bar.baz\", \"txt\", \"foo.bar.txt\", true);\n+        tfe!(\".test\", \"txt\", \".test.txt\", true);\n+        tfe!(\"foo.txt\", \"\", \"foo\", true);\n+        tfe!(\"foo\", \"\", \"foo\", true);\n+        tfe!(\"\", \"foo\", \"\", false);\n+        tfe!(\".\", \"foo\", \".\", false);\n+        tfe!(\"foo/\", \"bar\", \"foo/\", false);\n+        tfe!(\"foo/.\", \"bar\", \"foo/.\", false);\n+        tfe!(\"..\", \"foo\", \"..\",  false);\n+        tfe!(\"foo/..\", \"bar\", \"foo/..\", false);\n+        tfe!(\"/\", \"foo\", \"/\", false);\n+    }\n+\n+    #[test]\n+    pub fn test_compare() {\n+        macro_rules! tc(\n+            ($path1:expr, $path2:expr, eq: $eq:expr,\n+             starts_with: $starts_with:expr, ends_with: $ends_with:expr,\n+             relative_from: $relative_from:expr) => ({\n+                 let path1 = Path::new($path1);\n+                 let path2 = Path::new($path2);\n+\n+                 let eq = path1 == path2;\n+                 assert!(eq == $eq, \"{:?} == {:?}, expected {:?}, got {:?}\",\n+                         $path1, $path2, $eq, eq);\n+\n+                 let starts_with = path1.starts_with(path2);\n+                 assert!(starts_with == $starts_with,\n+                         \"{:?}.starts_with({:?}), expected {:?}, got {:?}\", $path1, $path2,\n+                         $starts_with, starts_with);\n+\n+                 let ends_with = path1.ends_with(path2);\n+                 assert!(ends_with == $ends_with,\n+                         \"{:?}.ends_with({:?}), expected {:?}, got {:?}\", $path1, $path2,\n+                         $ends_with, ends_with);\n+\n+                 let relative_from = path1.relative_from(path2).map(|p| p.to_str().unwrap());\n+                 let exp: Option<&str> = $relative_from;\n+                 assert!(relative_from == exp,\n+                         \"{:?}.relative_from({:?}), expected {:?}, got {:?}\", $path1, $path2,\n+                         exp, relative_from);\n+            });\n+        );\n+\n+        tc!(\"\", \"\",\n+            eq: true,\n+            starts_with: true,\n+            ends_with: true,\n+            relative_from: Some(\"\")\n+            );\n+\n+        tc!(\"foo\", \"\",\n+            eq: false,\n+            starts_with: true,\n+            ends_with: true,\n+            relative_from: Some(\"foo\")\n+            );\n+\n+        tc!(\"\", \"foo\",\n+            eq: false,\n+            starts_with: false,\n+            ends_with: false,\n+            relative_from: None\n+            );\n+\n+        tc!(\"foo\", \"foo\",\n+            eq: true,\n+            starts_with: true,\n+            ends_with: true,\n+            relative_from: Some(\"\")\n+            );\n+\n+        tc!(\"foo/\", \"foo\",\n+            eq: false,\n+            starts_with: true,\n+            ends_with: false,\n+            relative_from: Some(\".\")\n+            );\n+\n+        tc!(\"foo/bar\", \"foo\",\n+            eq: false,\n+            starts_with: true,\n+            ends_with: false,\n+            relative_from: Some(\"bar\")\n+            );\n+\n+        tc!(\"foo/bar/baz\", \"foo/bar\",\n+            eq: false,\n+            starts_with: true,\n+            ends_with: false,\n+            relative_from: Some(\"baz\")\n+            );\n+\n+        tc!(\"foo/bar\", \"foo/bar/baz\",\n+            eq: false,\n+            starts_with: false,\n+            ends_with: false,\n+            relative_from: None\n+            );\n+\n+        tc!(\"./foo/bar/\", \".\",\n+            eq: false,\n+            starts_with: true,\n+            ends_with: true,\n+            relative_from: Some(\"foo/bar/\")\n+            );\n+    }\n+}"}, {"sha": "a2c93dea6a4f504283da80a06635a9c99e88d343", "filename": "src/libstd/sys/unix/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs?ref=45ddf50cebd8f3353383e473327911c1f8b34cd6", "patch": "@@ -20,7 +20,7 @@ use str;\n use string::{String, CowString};\n use mem;\n \n-#[derive(Clone)]\n+#[derive(Clone, Hash)]\n pub struct Buf {\n     pub inner: Vec<u8>\n }"}, {"sha": "af94b56bf1f71aaf39433a4072093ca4ee64475e", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=45ddf50cebd8f3353383e473327911c1f8b34cd6", "patch": "@@ -18,7 +18,7 @@ use result::Result;\n use option::Option;\n use mem;\n \n-#[derive(Clone)]\n+#[derive(Clone, Hash)]\n pub struct Buf {\n     pub inner: Wtf8Buf\n }"}, {"sha": "b37c71bc326270ba0d745fe883275e2fd44d9f4c", "filename": "src/test/run-pass/issue-15149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15149.rs?ref=45ddf50cebd8f3353383e473327911c1f8b34cd6", "patch": "@@ -11,7 +11,7 @@\n use std::slice::SliceExt;\n use std::old_io::{Command, fs, USER_RWX};\n use std::os;\n-use std::path::BytesContainer;\n+use std::old_path::BytesContainer;\n use std::rand::random;\n \n fn main() {"}, {"sha": "0d85f61e51350d7dbc3715882505ab855f3f3d6e", "filename": "src/test/run-pass/issue-3424.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3424.rs?ref=45ddf50cebd8f3353383e473327911c1f8b34cd6", "patch": "@@ -1,4 +1,3 @@\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -15,8 +14,8 @@\n #![feature(box_syntax)]\n #![feature(unboxed_closures)]\n \n-use std::path::{Path};\n-use std::path;\n+use std::old_path::{Path};\n+use std::old_path;\n use std::result;\n use std::thunk::Thunk;\n \n@@ -28,7 +27,7 @@ fn tester()\n         result::Result::Ok(\"more blah\".to_string())\n     };\n \n-    let path = path::Path::new(\"blah\");\n+    let path = old_path::Path::new(\"blah\");\n     assert!(loader(&path).is_ok());\n }\n "}, {"sha": "c6fd55272610957b83f1f05a1c11beb360f4f7f4", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45ddf50cebd8f3353383e473327911c1f8b34cd6/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=45ddf50cebd8f3353383e473327911c1f8b34cd6", "patch": "@@ -20,7 +20,7 @@ use std::old_io;\n use std::old_io::fs;\n use std::old_io::Command;\n use std::os;\n-use std::path::Path;\n+use std::old_path::Path;\n \n fn main() {\n     let my_args = os::args();"}]}