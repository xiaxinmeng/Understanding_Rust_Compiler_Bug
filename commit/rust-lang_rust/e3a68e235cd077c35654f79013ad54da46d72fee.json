{"sha": "e3a68e235cd077c35654f79013ad54da46d72fee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzYTY4ZTIzNWNkMDc3YzM1NjU0Zjc5MDEzYWQ1NGRhNDZkNzJmZWU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-05-04T18:28:13Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-05T18:26:07Z"}, "message": "Bring back \"pred\" syntax for writing predicates for check\n\nThis commit reinstates the requirement that the predicate in a\n\"check\" must be a manifest call to a special kind of function\ndeclared with the new \"pred\" keyword instead of \"fn\". Preds must\nhave a boolean return type and can only call other preds; they\ncan't have any effects (as enforced by the typechecker).\nThe arguments to a predicate in a check expression must be\nslot variables or literals.", "tree": {"sha": "7838fc4a8937e2637cf7e3531d9c8e17feaff34b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7838fc4a8937e2637cf7e3531d9c8e17feaff34b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3a68e235cd077c35654f79013ad54da46d72fee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3a68e235cd077c35654f79013ad54da46d72fee", "html_url": "https://github.com/rust-lang/rust/commit/e3a68e235cd077c35654f79013ad54da46d72fee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3a68e235cd077c35654f79013ad54da46d72fee/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9c9982f0aeb9e6e176007ef5c0490dd18834814", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9c9982f0aeb9e6e176007ef5c0490dd18834814", "html_url": "https://github.com/rust-lang/rust/commit/d9c9982f0aeb9e6e176007ef5c0490dd18834814"}], "stats": {"total": 177, "additions": 155, "deletions": 22}, "files": [{"sha": "574ebd4a63c549e1712c0c18bae8cfa5d834a52c", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=e3a68e235cd077c35654f79013ad54da46d72fee", "patch": "@@ -346,7 +346,13 @@ type constr = spanned[constr_];\n \n type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n type fn_decl = rec(vec[arg] inputs,\n-                   @ty output);\n+                   @ty output,\n+                   purity purity);\n+tag purity {\n+    pure_fn;   // declared with \"pred\"\n+    impure_fn; // declared with \"fn\"\n+}\n+\n type _fn = rec(fn_decl decl,\n                proto proto,\n                block body);"}, {"sha": "4153533afee9bf78835f9f4ce297224372071b1e", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=e3a68e235cd077c35654f79013ad54da46d72fee", "patch": "@@ -141,6 +141,7 @@ fn keyword_table() -> std.map.hashmap[str, token.token] {\n     keywords.insert(\"auto\", token.AUTO);\n \n     keywords.insert(\"fn\", token.FN);\n+    keywords.insert(\"pred\", token.PRED);\n     keywords.insert(\"iter\", token.ITER);\n \n     keywords.insert(\"import\", token.IMPORT);"}, {"sha": "e355290d7b0439d07a1d1d62f7bec53125141fc4", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=e3a68e235cd077c35654f79013ad54da46d72fee", "patch": "@@ -242,6 +242,7 @@ fn parse_proto(parser p) -> ast.proto {\n     alt (p.peek()) {\n         case (token.ITER) { p.bump(); ret ast.proto_iter; }\n         case (token.FN) { p.bump(); ret ast.proto_fn; }\n+        case (token.PRED) { p.bump(); ret ast.proto_fn; }\n         case (?t) { unexpected(p, t); }\n     }\n     fail;\n@@ -1767,7 +1768,7 @@ fn parse_ty_params(parser p) -> vec[ast.ty_param] {\n     ret ty_params;\n }\n \n-fn parse_fn_decl(parser p) -> ast.fn_decl {\n+fn parse_fn_decl(parser p, ast.purity purity) -> ast.fn_decl {\n     auto pf = parse_arg;\n     let util.common.spanned[vec[ast.arg]] inputs =\n         // FIXME: passing parse_arg as an lval doesn't work at the\n@@ -1790,11 +1791,12 @@ fn parse_fn_decl(parser p) -> ast.fn_decl {\n     } else {\n         output = @spanned(inputs.span.lo, inputs.span.hi, ast.ty_nil);\n     }\n-    ret rec(inputs=inputs.node, output=output);\n+    // FIXME\n+    ret rec(inputs=inputs.node, output=output, purity=purity);\n }\n \n-fn parse_fn(parser p, ast.proto proto) -> ast._fn {\n-    auto decl = parse_fn_decl(p);\n+fn parse_fn(parser p, ast.proto proto, ast.purity purity) -> ast._fn {\n+    auto decl = parse_fn_decl(p, purity);\n     auto body = parse_block(p);\n     ret rec(decl = decl,\n             proto = proto,\n@@ -1808,11 +1810,11 @@ fn parse_fn_header(parser p)\n     ret tup(id, ty_params);\n }\n \n-fn parse_item_fn_or_iter(parser p) -> @ast.item {\n+fn parse_item_fn_or_iter(parser p, ast.purity purity) -> @ast.item {\n     auto lo = p.get_lo_pos();\n     auto proto = parse_proto(p);\n     auto t = parse_fn_header(p);\n-    auto f = parse_fn(p, proto);\n+    auto f = parse_fn(p, proto, purity);\n     auto item = ast.item_fn(t._0, f, t._1,\n                             p.next_def_id(), ast.ann_none);\n     ret @spanned(lo, f.body.span.hi, item);\n@@ -1830,7 +1832,7 @@ fn parse_method(parser p) -> @ast.method {\n     auto lo = p.get_lo_pos();\n     auto proto = parse_proto(p);\n     auto ident = parse_ident(p);\n-    auto f = parse_fn(p, proto);\n+    auto f = parse_fn(p, proto, ast.impure_fn);\n     auto meth = rec(ident=ident, meth=f,\n                     id=p.next_def_id(), ann=ast.ann_none);\n     ret @spanned(lo, f.body.span.hi, meth);\n@@ -1843,7 +1845,8 @@ fn parse_dtor(parser p) -> @ast.method {\n     let vec[ast.arg] inputs = vec();\n     let @ast.ty output = @spanned(lo, lo, ast.ty_nil);\n     let ast.fn_decl d = rec(inputs=inputs,\n-                            output=output);\n+                            output=output,\n+                            purity=ast.impure_fn);\n     let ast._fn f = rec(decl = d,\n                         proto = ast.proto_fn,\n                         body = b);\n@@ -1946,7 +1949,7 @@ fn parse_item_native_fn(parser p) -> @ast.native_item {\n     auto lo = p.get_lo_pos();\n     expect(p, token.FN);\n     auto t = parse_fn_header(p);\n-    auto decl = parse_fn_decl(p);\n+    auto decl = parse_fn_decl(p, ast.impure_fn);\n     auto link_name = none[str];\n     if (p.peek() == token.EQ) {\n         p.bump();\n@@ -2155,6 +2158,7 @@ fn peeking_at_item(parser p) -> bool {\n         case (token.GC) { ret true; }\n         case (token.CONST) { ret true; }\n         case (token.FN) { ret true; }\n+        case (token.PRED) { ret true; }\n         case (token.ITER) { ret true; }\n         case (token.MOD) { ret true; }\n         case (token.TYPE) { ret true; }\n@@ -2176,11 +2180,17 @@ fn parse_item(parser p) -> @ast.item {\n \n         case (token.FN) {\n             assert (lyr == ast.layer_value);\n-            ret parse_item_fn_or_iter(p);\n+            ret parse_item_fn_or_iter(p, ast.impure_fn);\n         }\n+\n+        case (token.PRED) {\n+            assert (lyr == ast.layer_value);\n+            ret parse_item_fn_or_iter(p, ast.pure_fn);\n+        }\n+\n         case (token.ITER) {\n             assert (lyr == ast.layer_value);\n-            ret parse_item_fn_or_iter(p);\n+            ret parse_item_fn_or_iter(p, ast.impure_fn);\n         }\n         case (token.MOD) {\n             assert (lyr == ast.layer_value);"}, {"sha": "b0fa0588cfaae2b97ff46c66e756490f392393e1", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=e3a68e235cd077c35654f79013ad54da46d72fee", "patch": "@@ -156,6 +156,7 @@ tag token {\n \n     /* Callable type constructors */\n     FN;\n+    PRED;\n     ITER;\n \n     /* Object type and related keywords */\n@@ -340,6 +341,7 @@ fn to_str(token t) -> str {\n \n         /* Callable type constructors */\n         case (FN) { ret \"fn\"; }\n+        case (PRED) { ret \"pred\"; }\n         case (ITER) { ret \"iter\"; }\n \n         /* Object type */"}, {"sha": "b37f7be835ec67da575a5e77c33bb8963525306c", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=e3a68e235cd077c35654f79013ad54da46d72fee", "patch": "@@ -30,6 +30,7 @@ import front.ast.def;\n import front.ast.def_id;\n import front.ast.ann;\n import front.ast.mt;\n+import front.ast.purity;\n \n import std._uint;\n import std._vec;\n@@ -301,7 +302,8 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e,\n          vec[arg] inputs,\n-         @ty output) -> ast.fn_decl)              fold_fn_decl,\n+         @ty output,\n+         purity p) -> ast.fn_decl)                fold_fn_decl,\n \n      (fn(&ENV e, &ast._mod m) -> ast._mod)        fold_mod,\n \n@@ -900,7 +902,7 @@ fn fold_fn_decl[ENV](&ENV env, ast_fold[ENV] fld,\n         inputs += vec(fold_arg(env, fld, a));\n     }\n     auto output = fold_ty[ENV](env, fld, decl.output);\n-    ret fld.fold_fn_decl(env, inputs, output);\n+    ret fld.fold_fn_decl(env, inputs, output, decl.purity);\n }\n \n fn fold_fn[ENV](&ENV env, ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n@@ -1542,8 +1544,9 @@ fn identity_fold_block[ENV](&ENV e, &span sp, &ast.block_ blk) -> block {\n \n fn identity_fold_fn_decl[ENV](&ENV e,\n                               vec[arg] inputs,\n-                              @ty output) -> ast.fn_decl {\n-    ret rec(inputs=inputs, output=output);\n+                              @ty output,\n+                              purity p) -> ast.fn_decl {\n+    ret rec(inputs=inputs, output=output, purity=p);\n }\n \n fn identity_fold_fn[ENV](&ENV e,\n@@ -1732,7 +1735,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_ann = bind identity_fold_ann[ENV](_,_),\n \n          fold_fn = bind identity_fold_fn[ENV](_,_,_,_),\n-         fold_fn_decl = bind identity_fold_fn_decl[ENV](_,_,_),\n+         fold_fn_decl = bind identity_fold_fn_decl[ENV](_,_,_,_),\n          fold_mod = bind identity_fold_mod[ENV](_,_),\n          fold_native_mod = bind identity_fold_native_mod[ENV](_,_),\n          fold_crate = bind identity_fold_crate[ENV](_,_,_,_),"}, {"sha": "4cea077ff49a81c6481cb66d31ad45b296d227da", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 108, "deletions": 4, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e3a68e235cd077c35654f79013ad54da46d72fee", "patch": "@@ -8,7 +8,7 @@ import driver.session;\n import util.common;\n import util.common.span;\n import util.common.plain_ann;\n-\n+import util.common.new_def_hash;\n import util.common.log_expr_err;\n \n import middle.ty;\n@@ -40,6 +40,7 @@ import std.map.hashmap;\n import std.option;\n import std.option.none;\n import std.option.some;\n+import std.option.from_maybe;\n \n import pretty.pprust;\n \n@@ -53,6 +54,7 @@ tag any_item {\n }\n \n type ty_item_table = hashmap[ast.def_id,any_item];\n+type fn_purity_table = hashmap[ast.def_id, ast.purity];\n \n type unify_cache_entry = tup(ty.t,ty.t,vec[mutable ty.t]);\n type unify_cache = hashmap[unify_cache_entry,ty.Unify.result];\n@@ -62,13 +64,15 @@ type crate_ctxt = rec(session.session sess,\n                       @ty_item_table item_items,\n                       vec[ast.obj_field] obj_fields,\n                       option.t[ast.def_id] this_obj,\n+                      @fn_purity_table fn_purity_table,\n                       mutable int next_var_id,\n                       unify_cache unify_cache,\n                       mutable uint cache_hits,\n                       mutable uint cache_misses,\n                       ty.ctxt tcx);\n \n type fn_ctxt = rec(ty.t ret_ty,\n+                   ast.purity purity,\n                    @ty_table locals,\n                    @crate_ctxt ccx);\n \n@@ -1673,6 +1677,62 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n     ret @fold.respan[ast.pat_](pat.span, new_pat);\n }\n \n+fn require_impure(&session.session sess,\n+      &ast.purity f_purity, &span sp) -> () {\n+    alt (f_purity) {\n+        case (ast.impure_fn) {\n+            ret;\n+        }\n+        case (ast.pure_fn) {\n+            sess.span_err(sp,\n+               \"Found impure expression in pure function decl\");\n+        }\n+    }\n+}\n+\n+fn get_function_purity(@crate_ctxt ccx, &ast.def_id d_id) -> ast.purity {\n+    let option.t[ast.purity] o = ccx.fn_purity_table.find(d_id);\n+    ret from_maybe[ast.purity](ast.impure_fn, o);\n+}\n+\n+fn require_pure_call(@crate_ctxt ccx,\n+    &ast.purity caller_purity, @ast.expr callee, &span sp) -> () {\n+    alt (caller_purity) {\n+        case (ast.impure_fn) {\n+            ret;\n+        }\n+        case (ast.pure_fn) {\n+            alt (callee.node) {\n+                case (ast.expr_path(_, some[ast.def](ast.def_fn(?d_id)), _)) {\n+                    alt (get_function_purity(ccx, d_id)) {\n+                            case (ast.pure_fn) {\n+                                ret;\n+                            }\n+                            case (_) {\n+                                ccx.sess.span_err(sp,\n+                                  \"Pure function calls impure function\");\n+\n+                            }\n+                        }\n+                }\n+                case (_) {\n+                    ccx.sess.span_err(sp,\n+                      \"Pure function calls unknown function\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn require_pure_function(@crate_ctxt ccx, &ast.def_id d_id, &span sp) -> () {\n+    alt (get_function_purity(ccx, d_id)) {\n+        case (ast.impure_fn) {\n+            ccx.sess.span_err(sp, \"Found non-predicate in check expression\");\n+        }\n+        case (_) { ret; }\n+    }\n+}\n+\n fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     //fcx.ccx.sess.span_warn(expr.span, \"typechecking expr \" +\n     //                       pretty.pprust.expr_to_str(expr));\n@@ -1916,6 +1976,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_put(?expr_opt, _)) {\n+            require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n+\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n                     auto nil = ty.mk_nil(fcx.ccx.tcx);\n@@ -1965,7 +2027,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             alt (e.node) {\n                 case (ast.expr_call(?operator, ?operands, _)) {\n                     alt (operator.node) {\n-                        case (ast.expr_path(?oper_name, ?d_id, _)) {\n+                        case (ast.expr_path(?oper_name,\n+                                some[ast.def](ast.def_fn(?d_id)), _)) {\n \n                             for (@ast.expr operand in operands) {\n                                 if (! ast.is_constraint_arg(operand)) {\n@@ -1975,8 +2038,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                 }\n                             }\n                             \n-                         /* operator must be a pure function */\n-                         /* FIXME: need more checking */\n+                            require_pure_function(fcx.ccx, d_id, expr.span);\n+\n                             ret @fold.respan[ast.expr_]\n                                 (expr.span, ast.expr_check(expr_t,\n                                    plain_ann(fcx.ccx.tcx)));\n@@ -2005,6 +2068,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_assign(?lhs, ?rhs, _)) {\n+            require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n+\n             auto checked = check_assignment(fcx, lhs, rhs);\n             auto newexpr = ast.expr_assign(checked._0,\n                                            checked._1,\n@@ -2013,6 +2078,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_assign_op(?op, ?lhs, ?rhs, _)) {\n+            require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n+\n             auto checked = check_assignment(fcx, lhs, rhs);\n             auto newexpr = ast.expr_assign_op(op,\n                                               checked._0,\n@@ -2022,6 +2089,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_send(?lhs, ?rhs, _)) {\n+            require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n+\n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n             auto rhs_t = expr_ty(fcx.ccx.tcx, rhs_0);\n@@ -2045,6 +2114,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_recv(?lhs, ?rhs, _)) {\n+            require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n+\n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n             auto lhs_t1 = expr_ty(fcx.ccx.tcx, lhs_0);\n@@ -2250,6 +2321,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_call(?f, ?args, _)) {\n+            /* here we're kind of hosed, as f can be any expr\n+             need to restrict it to being an explicit expr_path if we're\n+            inside a pure function, and need an environment mapping from \n+            function name onto purity-designation */\n+            require_pure_call(fcx.ccx, fcx.purity, f, expr.span);\n+\n             auto result = check_call(fcx, f, args);\n             auto f_1 = result._0;\n             auto args_1 = result._1;\n@@ -2302,6 +2379,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             auto ann = triv_ann(t);\n \n+            require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n+\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_self_method(id, ann));\n         }\n@@ -2725,6 +2804,7 @@ fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n     // for checking the initializer expression.\n     auto rty = ann_to_type(ann);\n     let @fn_ctxt fcx = @rec(ret_ty = rty,\n+                            purity = ast.pure_fn,\n                             locals = @common.new_def_hash[ty.t](),\n                             ccx = ccx);\n     auto e_ = check_expr(fcx, e);\n@@ -2755,6 +2835,7 @@ fn check_fn(&@crate_ctxt ccx, &ast.fn_decl decl, ast.proto proto,\n     }\n \n     let @fn_ctxt fcx = @rec(ret_ty = ast_ty_to_ty_crate(ccx, decl.output),\n+                            purity = decl.purity,\n                             locals = local_ty_table,\n                             ccx = ccx);\n \n@@ -2834,6 +2915,26 @@ fn eq_unify_cache_entry(&unify_cache_entry a, &unify_cache_entry b) -> bool {\n     ret true;\n }\n \n+fn mk_fn_purity_table(@ast.crate crate) -> @fn_purity_table {\n+    auto res = @new_def_hash[ast.purity]();\n+\n+    fn do_one(@fn_purity_table t, @ast.item i) -> () {\n+        alt (i.node) {\n+            case (ast.item_fn(_, ?f, _, ?d_id, _)) {\n+                t.insert(d_id, f.decl.purity);\n+            }\n+            case (_) {}\n+        }\n+    }\n+\n+    auto do_one_fn = bind do_one(res,_);\n+    auto v = walk.default_visitor();\n+\n+    auto add_fn_entry_visitor = rec(visit_item_post=do_one_fn with v);\n+\n+    walk.walk_crate(add_fn_entry_visitor, *crate);\n+    ret res;\n+}\n \n type typecheck_result = tup(@ast.crate, ty.type_cache);\n \n@@ -2848,12 +2949,15 @@ fn check_crate(ty.ctxt tcx, @ast.crate crate)\n     auto eqer = eq_unify_cache_entry;\n     auto unify_cache =\n         map.mk_hashmap[unify_cache_entry,ty.Unify.result](hasher, eqer);\n+    auto fpt =\n+        mk_fn_purity_table(crate); // use a variation on Collect\n \n     auto ccx = @rec(sess=sess,\n                     type_cache=result._1,\n                     item_items=result._2,\n                     obj_fields=fields,\n                     this_obj=none[ast.def_id],\n+                    fn_purity_table = fpt,\n                     mutable next_var_id=0,\n                     unify_cache=unify_cache,\n                     mutable cache_hits=0u,"}, {"sha": "c87a86796ff484d3dd6c693aaf70c14d12d67de3", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a68e235cd077c35654f79013ad54da46d72fee/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=e3a68e235cd077c35654f79013ad54da46d72fee", "patch": "@@ -790,7 +790,14 @@ fn print_pat(ps s, &@ast.pat pat) {\n \n fn print_fn(ps s, ast.fn_decl decl, str name,\n                    vec[ast.ty_param] typarams) {\n-    wrd1(s, \"fn\");\n+    alt (decl.purity) {\n+        case (ast.impure_fn) {\n+            wrd1(s, \"fn\");\n+        }\n+        case (_) {\n+            wrd1(s, \"pred\");\n+        }\n+    }\n     wrd(s.s, name);\n     print_type_params(s, typarams);\n     popen(s);"}]}