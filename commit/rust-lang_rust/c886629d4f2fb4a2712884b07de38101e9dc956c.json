{"sha": "c886629d4f2fb4a2712884b07de38101e9dc956c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ODY2MjlkNGYyZmI0YTI3MTI4ODRiMDdkZTM4MTAxZTlkYzk1NmM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-08T19:39:30Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-15T21:14:05Z"}, "message": "rustc: Implement monomorphic default methods. r=nmatsakis", "tree": {"sha": "285357b2ea22cffb28c7f30583041be2311947bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/285357b2ea22cffb28c7f30583041be2311947bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c886629d4f2fb4a2712884b07de38101e9dc956c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c886629d4f2fb4a2712884b07de38101e9dc956c", "html_url": "https://github.com/rust-lang/rust/commit/c886629d4f2fb4a2712884b07de38101e9dc956c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c886629d4f2fb4a2712884b07de38101e9dc956c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a1aa9fb5356dc43e649b86622bd12463722d2af", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a1aa9fb5356dc43e649b86622bd12463722d2af", "html_url": "https://github.com/rust-lang/rust/commit/2a1aa9fb5356dc43e649b86622bd12463722d2af"}], "stats": {"total": 938, "additions": 638, "deletions": 300}, "files": [{"sha": "972d48a6135313c1f949dfc2efa98b5b4c2f0fd7", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -124,5 +124,7 @@ enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_legacy_boxed_trait = 0x63\n }\n \n+const tag_item_trait_method_sort: uint = 0x70;\n+\n type link_meta = {name: ~str, vers: ~str, extras_hash: ~str};\n "}, {"sha": "ea6bd499a3b5e4a18c80ca34e85bd1385690bdff", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -23,6 +23,7 @@ export get_region_param;\n export get_enum_variants;\n export get_impls_for_mod;\n export get_trait_methods;\n+export get_provided_trait_methods;\n export get_method_names_if_trait;\n export get_item_attrs;\n export each_path;\n@@ -31,6 +32,12 @@ export get_impl_traits;\n export get_impl_method;\n export get_item_path;\n export maybe_get_item_ast, found_ast, found, found_parent, not_found;\n+export ProvidedTraitMethodInfo;\n+\n+struct ProvidedTraitMethodInfo {\n+    ty: ty::method,\n+    def_id: ast::def_id\n+}\n \n fn get_symbol(cstore: cstore::cstore, def: ast::def_id) -> ~str {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n@@ -99,6 +106,13 @@ fn get_trait_methods(tcx: ty::ctxt, def: ast::def_id) -> @~[ty::method] {\n     decoder::get_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n+fn get_provided_trait_methods(tcx: ty::ctxt, def: ast::def_id) ->\n+        ~[ProvidedTraitMethodInfo] {\n+    let cstore = tcx.cstore;\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n+}\n+\n fn get_method_names_if_trait(cstore: cstore::cstore, def: ast::def_id)\n     -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n "}, {"sha": "f0911bd1aa27ac7abf0e2817166c79df6ca0bf0e", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -19,6 +19,7 @@ use syntax::diagnostic::span_handler;\n use common::*;\n use syntax::parse::token::ident_interner;\n use hash::{Hash, HashUtil};\n+use csearch::ProvidedTraitMethodInfo;\n \n export class_dtor;\n export get_class_fields;\n@@ -40,6 +41,7 @@ export get_crate_hash;\n export get_crate_vers;\n export get_impls_for_mod;\n export get_trait_methods;\n+export get_provided_trait_methods;\n export get_method_names_if_trait;\n export get_item_attrs;\n export get_crate_module_paths;\n@@ -164,6 +166,13 @@ fn item_family(item: ebml::Doc) -> Family {\n     }\n }\n \n+fn item_method_sort(item: ebml::Doc) -> char {\n+    for ebml::tagged_docs(item, tag_item_trait_method_sort) |doc| {\n+        return str::from_bytes(ebml::doc_data(doc))[0] as char;\n+    }\n+    return 'r';\n+}\n+\n fn item_symbol(item: ebml::Doc) -> ~str {\n     let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n     return str::from_bytes(ebml::doc_data(sym));\n@@ -701,21 +710,60 @@ fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(intr, mth);\n         let ty = doc_type(mth, tcx, cdata);\n+        let def_id = item_def_id(mth, cdata);\n         let fty = match ty::get(ty).sty {\n           ty::ty_fn(f) => f,\n           _ => {\n             tcx.diag.handler().bug(\n                 ~\"get_trait_methods: id has non-function type\");\n         } };\n         let self_ty = get_self_ty(mth);\n-        result.push({ident: name, tps: bounds, fty: fty,\n-                           self_ty: self_ty,\n-                           vis: ast::public});\n+        result.push({ident: name, tps: bounds, fty: fty, self_ty: self_ty,\n+                     vis: ast::public, def_id: def_id});\n     }\n     debug!(\"get_trait_methods: }\");\n     @result\n }\n \n+fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n+                              id: ast::node_id, tcx: ty::ctxt) ->\n+        ~[ProvidedTraitMethodInfo] {\n+    let data = cdata.data;\n+    let item = lookup_item(id, data);\n+    let mut result = ~[];\n+\n+    for ebml::tagged_docs(item, tag_item_trait_method) |mth| {\n+        if item_method_sort(mth) != 'p' { loop; }\n+\n+        let did = item_def_id(mth, cdata);\n+\n+        let bounds = item_ty_param_bounds(mth, tcx, cdata);\n+        let name = item_name(intr, mth);\n+        let ty = doc_type(mth, tcx, cdata);\n+\n+        let fty;\n+        match ty::get(ty).sty {\n+            ty::ty_fn(f) => fty = f,\n+            _ => {\n+                tcx.diag.handler().bug(~\"get_provided_trait_methods(): id \\\n+                                         has non-function type\");\n+            }\n+        }\n+\n+        let self_ty = get_self_ty(mth);\n+        let ty_method = {ident: name, tps: bounds, fty: fty, self_ty: self_ty,\n+                         vis: ast::public, def_id: did};\n+        let provided_trait_method_info = ProvidedTraitMethodInfo {\n+            ty: ty_method,\n+            def_id: did\n+        };\n+\n+        vec::push(&mut result, move provided_trait_method_info);\n+    }\n+\n+    return move result;\n+}\n+\n // If the item in question is a trait, returns its set of methods and\n // their self types. Otherwise, returns none. This overlaps in an\n // annoying way with get_trait_methods."}, {"sha": "652af81659a08d64e600136ef3a1f64fd9dd9684", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -388,6 +388,12 @@ fn encode_self_type(ebml_w: ebml::Serializer, self_type: ast::self_ty_) {\n     ebml_w.end_tag();\n }\n \n+fn encode_method_sort(ebml_w: ebml::Serializer, sort: char) {\n+    ebml_w.start_tag(tag_item_trait_method_sort);\n+    ebml_w.writer.write(&[ sort as u8 ]);\n+    ebml_w.end_tag();\n+}\n+\n /* Returns an index of items in this class */\n fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                          id: node_id, path: ast_map::path,\n@@ -726,6 +732,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n         }\n       }\n       item_trait(tps, traits, ms) => {\n+        let provided_methods = dvec::DVec();\n+\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -746,12 +754,21 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                 encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n                 encode_family(ebml_w, purity_fn_family(mty.fty.meta.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n+                encode_method_sort(ebml_w, 'r');\n                 ebml_w.end_tag();\n               }\n               provided(m) => {\n-                encode_info_for_method(ecx, ebml_w, path,\n-                                       should_inline(m.attrs), item.id,\n-                                       m, m.tps);\n+                provided_methods.push(m);\n+\n+                ebml_w.start_tag(tag_item_trait_method);\n+                encode_def_id(ebml_w, local_def(m.id));\n+                encode_name(ecx, ebml_w, mty.ident);\n+                encode_type_param_bounds(ebml_w, ecx, m.tps);\n+                encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n+                encode_family(ebml_w, purity_fn_family(mty.fty.meta.purity));\n+                encode_self_type(ebml_w, mty.self_ty);\n+                encode_method_sort(ebml_w, 'p');\n+                ebml_w.end_tag();\n               }\n             }\n             i += 1u;\n@@ -785,7 +802,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n             ebml_w.end_tag();\n         }\n \n-\n+        // Finally, output all the provided methods as items.\n+        for provided_methods.each |m| {\n+            index.push({val: m.id, pos: ebml_w.writer.tell()});\n+            encode_info_for_method(ecx, ebml_w, path, true, item.id, *m,\n+                                   m.tps);\n+        }\n       }\n       item_mac(*) => fail ~\"item macros unimplemented\"\n     }"}, {"sha": "4f170fd050be83c4637909eb7da6760c57f025b6", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -4680,15 +4680,18 @@ impl Resolver {\n     }\n \n     fn search_for_traits_containing_method(name: ident) -> @DVec<def_id> {\n+        debug!(\"(searching for traits containing method) looking for '%s'\",\n+               self.session.str_of(name));\n+\n         let found_traits = @DVec();\n         let mut search_module = self.current_module;\n         loop {\n             // Look for the current trait.\n             match copy self.current_trait_refs {\n                 Some(trait_def_ids) => {\n                     for trait_def_ids.each |trait_def_id| {\n-                        self.add_trait_info_if_containing_method\n-                            (found_traits, *trait_def_id, name);\n+                        self.add_trait_info_if_containing_method(\n+                            found_traits, *trait_def_id, name);\n                     }\n                 }\n                 None => {\n@@ -4702,8 +4705,8 @@ impl Resolver {\n                     Some(def) => {\n                         match def.def {\n                             def_ty(trait_def_id) => {\n-                                self.add_trait_info_if_containing_method\n-                                    (found_traits, trait_def_id, name);\n+                                self.add_trait_info_if_containing_method(\n+                                    found_traits, trait_def_id, name);\n                             }\n                             _ => {\n                                 // Continue.\n@@ -4730,8 +4733,8 @@ impl Resolver {\n                                 match def.def {\n                                     def_ty(trait_def_id) => {\n                                         self.\n-                                        add_trait_info_if_containing_method\n-                                        (found_traits, trait_def_id, name);\n+                                        add_trait_info_if_containing_method(\n+                                        found_traits, trait_def_id, name);\n                                     }\n                                     _ => {\n                                         // Continue.\n@@ -4766,6 +4769,12 @@ impl Resolver {\n                                            trait_def_id: def_id,\n                                            name: ident) {\n \n+        debug!(\"(adding trait info if containing method) trying trait %d:%d \\\n+                for method '%s'\",\n+               trait_def_id.crate,\n+               trait_def_id.node,\n+               self.session.str_of(name));\n+\n         match self.trait_info.find(trait_def_id) {\n             Some(trait_info) if trait_info.contains_key(name) => {\n                 debug!(\"(adding trait info if containing method) found trait \\"}, {"sha": "93e8435d3e957b0f213ed3e250a2c82d9744b420", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 26, "deletions": 68, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -206,7 +206,7 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n     assert ix < variant.args.len();\n \n     let arg_lltys = vec::map(variant.args, |aty| {\n-        type_of(ccx, ty::subst_tps(ccx.tcx, ty_substs, *aty))\n+        type_of(ccx, ty::subst_tps(ccx.tcx, ty_substs, None, *aty))\n     });\n     let typed_blobptr = PointerCast(bcx, llblobptr,\n                                     T_ptr(T_struct(arg_lltys)));\n@@ -385,16 +385,16 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n     let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n     if (substs.is_not_empty()) {\n         let did = if did.crate != ast::local_crate {\n-            inline::maybe_instantiate_inline(ccx, did)\n+            inline::maybe_instantiate_inline(ccx, did, true)\n         } else { did };\n         assert did.crate == ast::local_crate;\n-        monomorphize::monomorphic_fn(ccx, did, substs, None, None).val\n+        monomorphize::monomorphic_fn(ccx, did, substs, None, None, None).val\n     } else if did.crate == ast::local_crate {\n         get_item_val(ccx, did.node)\n     } else {\n         let tcx = ccx.tcx;\n         let name = csearch::get_symbol(ccx.sess.cstore, did);\n-        let class_ty = ty::subst_tps(tcx, substs,\n+        let class_ty = ty::subst_tps(tcx, substs, None,\n                           ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n         get_extern_fn(ccx.externs, ccx.llmod, name, lib::llvm::CCallConv,\n@@ -529,7 +529,8 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             let v_id = variant.id;\n             for vec::each(fn_ty.sig.inputs) |a| {\n                 let llfldp_a = GEP_enum(cx, a_tup, tid, v_id, tps, j);\n-                let ty_subst = ty::subst_tps(ccx.tcx, tps, a.ty);\n+                // XXX: Is \"None\" right here?\n+                let ty_subst = ty::subst_tps(ccx.tcx, tps, None, a.ty);\n                 cx = f(cx, llfldp_a, ty_subst);\n                 j += 1u;\n             }\n@@ -1392,8 +1393,11 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n-                    llfndecl: ValueRef, id: ast::node_id,\n+fn new_fn_ctxt_w_id(ccx: @crate_ctxt,\n+                    path: path,\n+                    llfndecl: ValueRef,\n+                    id: ast::node_id,\n+                    impl_id: Option<ast::def_id>,\n                     param_substs: Option<param_substs>,\n                     sp: Option<span>) -> fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n@@ -1410,6 +1414,7 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n           lllocals: HashMap(),\n           llupvars: HashMap(),\n           id: id,\n+          impl_id: impl_id,\n           param_substs: param_substs,\n           span: sp,\n           path: path,\n@@ -1418,7 +1423,7 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n \n fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n                sp: Option<span>) -> fn_ctxt {\n-    return new_fn_ctxt_w_id(ccx, path, llfndecl, -1, None, sp);\n+    return new_fn_ctxt_w_id(ccx, path, llfndecl, -1, None, None, sp);\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1561,14 +1566,15 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                  ty_self: self_arg,\n                  param_substs: Option<param_substs>,\n                  id: ast::node_id,\n+                 impl_id: Option<ast::def_id>,\n                  maybe_load_env: fn(fn_ctxt),\n                  finish: fn(block)) {\n     ccx.stats.n_closures += 1;\n     let _icx = ccx.insn_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n-    let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, param_substs,\n+    let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, impl_id, param_substs,\n                                   Some(body.span));\n     let raw_llargs = create_llargs_for_fn_args(fcx, ty_self, decl.inputs);\n \n@@ -1620,14 +1626,15 @@ fn trans_fn(ccx: @crate_ctxt,\n             llfndecl: ValueRef,\n             ty_self: self_arg,\n             param_substs: Option<param_substs>,\n-            id: ast::node_id) {\n+            id: ast::node_id,\n+            impl_id: Option<ast::def_id>) {\n     let do_time = ccx.sess.trans_stats();\n     let start = if do_time { time::get_time() }\n                 else { {sec: 0i64, nsec: 0i32} };\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     ccx.stats.n_fns += 1;\n     trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n-                  param_substs, id,\n+                  param_substs, id, impl_id,\n                   |fcx| {\n                       if ccx.sess.opts.extra_debuginfo {\n                           debuginfo::create_function(fcx);\n@@ -1654,7 +1661,7 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n          ty: varg.ty,\n          ident: special_idents::arg,\n          id: varg.id});\n-    let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, variant.node.id,\n+    let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, variant.node.id, None,\n                                param_substs, None);\n     let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n     let ty_param_substs = match param_substs {\n@@ -1704,7 +1711,7 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n   let mut class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n   /* Substitute in the class type if necessary */\n     do option::iter(&psubsts) |ss| {\n-    class_ty = ty::subst_tps(tcx, ss.tys, class_ty);\n+    class_ty = ty::subst_tps(tcx, ss.tys, ss.self_ty, class_ty);\n   }\n \n   /* The dtor takes a (null) output pointer, and a self argument,\n@@ -1724,7 +1731,7 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n   }\n   /* Translate the dtor body */\n   trans_fn(ccx, path, ast_util::dtor_dec(),\n-           body, lldecl, impl_self(class_ty), psubsts, dtor_id);\n+           body, lldecl, impl_self(class_ty), psubsts, dtor_id, None);\n   lldecl\n }\n \n@@ -1777,7 +1784,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n                      vec::append(*path, ~[path_name(item.ident)]),\n-                     decl, body, llfndecl, no_self, None, item.id);\n+                     decl, body, llfndecl, no_self, None, item.id, None);\n         } else {\n             for vec::each(body.node.stmts) |stmt| {\n                 match stmt.node {\n@@ -1789,48 +1796,8 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             }\n         }\n       }\n-      ast::item_impl(tps, trait_refs, self_ast_ty, ms) => {\n-        meth::trans_impl(ccx, *path, item.ident, ms, tps, None);\n-\n-        // Translate any methods that have provided implementations.\n-        for trait_refs.each |trait_ref_ptr| {\n-            let trait_def = ccx.tcx.def_map.get(trait_ref_ptr.ref_id);\n-\n-            // XXX: Cross-crate default methods.\n-            let trait_id = def_id_of_def(trait_def);\n-            if trait_id.crate != ast::local_crate {\n-                loop;\n-            }\n-\n-            // Get the self type.\n-            let self_ty;\n-            match ccx.tcx.ast_ty_to_ty_cache.get(self_ast_ty) {\n-                ty::atttce_resolved(self_type) => self_ty = self_type,\n-                ty::atttce_unresolved => {\n-                    ccx.tcx.sess.impossible_case(item.span,\n-                                                 ~\"didn't cache self ast ty\");\n-                }\n-            }\n-\n-            match ccx.tcx.items.get(trait_id.node) {\n-                ast_map::node_item(trait_item, _) => {\n-                    match trait_item.node {\n-                        ast::item_trait(tps, _, trait_methods) => {\n-                            trans_trait(ccx, tps, trait_methods, path,\n-                                        item.ident, self_ty);\n-                        }\n-                        _ => {\n-                            ccx.tcx.sess.impossible_case(item.span,\n-                                                         ~\"trait item not a \\\n-                                                           trait\");\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    ccx.tcx.sess.impossible_case(item.span, ~\"no trait item\");\n-                }\n-            }\n-        }\n+      ast::item_impl(tps, _, _, ms) => {\n+        meth::trans_impl(ccx, *path, item.ident, ms, tps, None, item.id);\n       }\n       ast::item_mod(m) => {\n         trans_mod(ccx, m);\n@@ -1871,16 +1838,7 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     // If there are ty params, the ctor will get monomorphized\n \n     // Translate methods\n-    meth::trans_impl(ccx, *path, ident, struct_def.methods, tps, None);\n-}\n-\n-fn trans_trait(ccx: @crate_ctxt, tps: ~[ast::ty_param],\n-               trait_methods: ~[ast::trait_method],\n-               path: @ast_map::path, ident: ast::ident,\n-               self_ty: ty::t) {\n-    // Translate any methods that have provided implementations\n-    let (_, provided_methods) = ast_util::split_trait_methods(trait_methods);\n-    meth::trans_impl(ccx, *path, ident, provided_methods, tps, Some(self_ty));\n+    meth::trans_impl(ccx, *path, ident, struct_def.methods, tps, None, id);\n }\n \n // Translate a module. Doing this amounts to translating the items in the\n@@ -2035,7 +1993,7 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n        // this to item_symbols\n        match substs {\n          Some(ss) => {\n-           let mono_ty = ty::subst_tps(ccx.tcx, ss.tys, t);\n+           let mono_ty = ty::subst_tps(ccx.tcx, ss.tys, ss.self_ty, t);\n            mangle_exported_name(\n                ccx,\n                vec::append(path,"}, {"sha": "133f4647e683ec735891c4fde0ebc338d056728a", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -184,21 +184,31 @@ fn trans_fn_ref_with_vtables(\n     // Polytype of the function item (may have type params)\n     let fn_tpt = ty::lookup_item_type(tcx, def_id);\n \n+    // Modify the def_id if this is a default method; we want to be\n+    // monomorphizing the trait's code.\n+    let (def_id, opt_impl_did) =\n+            match tcx.provided_method_sources.find(def_id) {\n+        None => (def_id, None),\n+        Some(source) => (source.method_id, Some(source.impl_id))\n+    };\n+\n     // Check whether this fn has an inlined copy and, if so, redirect\n     // def_id to the local id of the inlined copy.\n     let def_id = {\n         if def_id.crate != ast::local_crate {\n-            inline::maybe_instantiate_inline(ccx, def_id)\n+            let may_translate = opt_impl_did.is_none();\n+            inline::maybe_instantiate_inline(ccx, def_id, may_translate)\n         } else {\n             def_id\n         }\n     };\n \n-    // We must monomorphise if the fn has type parameters or is a rust\n-    // intrinsic.  In particular, if we see an intrinsic that is\n-    // inlined from a different crate, we want to reemit the intrinsic\n-    // instead of trying to call it in the other crate.\n-    let must_monomorphise = type_params.len() > 0 || {\n+    // We must monomorphise if the fn has type parameters, is a rust\n+    // intrinsic, or is a default method.  In particular, if we see an\n+    // intrinsic that is inlined from a different crate, we want to reemit the\n+    // intrinsic instead of trying to call it in the other crate.\n+    let must_monomorphise = type_params.len() > 0 ||\n+        opt_impl_did.is_some() || {\n         if def_id.crate == ast::local_crate {\n             let map_node = session::expect(\n                 ccx.sess,\n@@ -222,7 +232,7 @@ fn trans_fn_ref_with_vtables(\n \n         let mut {val, must_cast} =\n             monomorphize::monomorphic_fn(ccx, def_id, type_params,\n-                                         vtables, Some(ref_id));\n+                                         vtables, opt_impl_did, Some(ref_id));\n         if must_cast && ref_id != 0 {\n             // Monotype of the REFERENCE to the function (type params\n             // are subst'd)\n@@ -317,7 +327,9 @@ fn trans_rtcall_or_lang_call_with_type_params(bcx: block,\n             match callee.data {\n                 Fn(fn_data) => {\n                     let substituted = ty::subst_tps(callee.bcx.tcx(),\n-                                                    type_params, fty);\n+                                                    type_params,\n+                                                    None,\n+                                                    fty);\n                     let mut llfnty = type_of::type_of(callee.bcx.ccx(),\n                                                       substituted);\n                     llfnty = T_ptr(struct_elt(llfnty, 0));"}, {"sha": "3997076f98713155bed3f0011b02167205806e3e", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -372,7 +372,7 @@ fn trans_expr_fn(bcx: block,\n         let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck,\n                                                    ret_handle);\n         trans_closure(ccx, sub_path, decl, body, llfn, no_self,\n-                      bcx.fcx.param_substs, id, |fcx| {\n+                      bcx.fcx.param_substs, id, None, |fcx| {\n             load_environment(fcx, cdata_ty, cap_vars,\n                              ret_handle.is_some(), ck);\n                       }, |bcx| {\n@@ -395,7 +395,7 @@ fn trans_expr_fn(bcx: block,\n         }\n         ty::proto_bare => {\n             trans_closure(ccx, sub_path, decl, body, llfn, no_self, None,\n-                          id, |_fcx| { }, |_bcx| { });\n+                          id, None, |_fcx| { }, |_bcx| { });\n             rslt(bcx, C_null(T_opaque_box_ptr(ccx)))\n         }\n         ty::proto_vstore(ty::vstore_fixed(_)) => {"}, {"sha": "0fa22dd65ba7b1834d4adbfbd878dc881e5e7284", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -181,9 +181,12 @@ struct ValSelfData {\n \n enum local_val { local_mem(ValueRef), local_imm(ValueRef), }\n \n+// Here `self_ty` is the real type of the self parameter to this method. It\n+// will only be set in the case of default methods.\n type param_substs = {tys: ~[ty::t],\n                      vtables: Option<typeck::vtable_res>,\n-                     bounds: @~[ty::param_bounds]};\n+                     bounds: @~[ty::param_bounds],\n+                     self_ty: Option<ty::t>};\n \n fn param_substs_to_str(tcx: ty::ctxt, substs: &param_substs) -> ~str {\n     fmt!(\"param_substs {tys:%?, vtables:%?, bounds:%?}\",\n@@ -220,6 +223,10 @@ type fn_ctxt = @{\n     mut llreturn: BasicBlockRef,\n     // The 'self' value currently in use in this function, if there\n     // is one.\n+    //\n+    // NB: This is the type of the self *variable*, not the self *type*. The\n+    // self type is set only for default methods, while the self variable is\n+    // set for all methods.\n     mut llself: Option<ValSelfData>,\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n@@ -240,6 +247,9 @@ type fn_ctxt = @{\n     // a user-defined function.\n     id: ast::node_id,\n \n+    // The def_id of the impl we're inside, or None if we aren't inside one.\n+    impl_id: Option<ast::def_id>,\n+\n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n     param_substs: Option<param_substs>,\n@@ -1110,7 +1120,11 @@ enum mono_param_id {\n               datum::DatumMode),\n }\n \n-type mono_id_ = {def: ast::def_id, params: ~[mono_param_id]};\n+type mono_id_ = {\n+    def: ast::def_id,\n+    params: ~[mono_param_id],\n+    impl_did_opt: Option<ast::def_id>\n+};\n \n type mono_id = @mono_id_;\n \n@@ -1193,7 +1207,9 @@ fn path_str(sess: session::session, p: path) -> ~str {\n \n fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n     match bcx.fcx.param_substs {\n-        Some(substs) => ty::subst_tps(bcx.tcx(), substs.tys, t),\n+        Some(substs) => {\n+            ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n+        }\n         _ => { assert !ty::type_has_params(t); t }\n     }\n }\n@@ -1213,7 +1229,9 @@ fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     let params = ty::node_id_to_type_params(tcx, id);\n     match bcx.fcx.param_substs {\n       Some(substs) => {\n-        vec::map(params, |t| ty::subst_tps(tcx, substs.tys, *t))\n+        do vec::map(params) |t| {\n+            ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n+        }\n       }\n       _ => params\n     }\n@@ -1241,7 +1259,9 @@ fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n         typeck::vtable_static(trait_id, tys, sub) => {\n             let tys = match fcx.param_substs {\n                 Some(substs) => {\n-                    vec::map(tys, |t| ty::subst_tps(tcx, substs.tys, *t))\n+                    do vec::map(tys) |t| {\n+                        ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n+                    }\n                 }\n                 _ => tys\n             };"}, {"sha": "08abe986be6ff8da4a17c3a131335dbd9ed731fb", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -793,7 +793,9 @@ fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n \n             // This cast should not be necessary. We should cast self *once*,\n             // but right now this conflicts with default methods.\n-            let llselfty = T_ptr(type_of::type_of(bcx.ccx(), self_info.t));\n+            let real_self_ty = monomorphize_type(bcx, self_info.t);\n+            let llselfty = T_ptr(type_of::type_of(bcx.ccx(), real_self_ty));\n+\n             let casted_val = PointerCast(bcx, self_info.v, llselfty);\n             Datum {\n                 val: casted_val,"}, {"sha": "5a6260ae27008135ef18a4582fbe3c0d7f50ae4b", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -794,7 +794,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n {\n     debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n \n-    let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id,\n+    let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id, None,\n                                Some(substs), Some(item.span));\n     let mut bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n     match ccx.sess.str_of(item.ident) {\n@@ -1025,7 +1025,7 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n             )));\n         let llty = type_of_fn_from_ty(ccx, t);\n         let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n-        trans_fn(ccx, path, decl, body, llfndecl, no_self, None, id);\n+        trans_fn(ccx, path, decl, body, llfndecl, no_self, None, id, None);\n         return llfndecl;\n     }\n "}, {"sha": "d3cc23094ee873a211046d1a7b2d540f3970f63b", "filename": "src/rustc/middle/trans/inline.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -5,9 +5,12 @@ use syntax::ast_map::{path, path_mod, path_name};\n use base::{trans_item, get_item_val, self_arg, trans_fn,\n               impl_self, get_insn_ctxt};\n \n-fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n-    -> ast::def_id\n-{\n+// `translate` will be true if this function is allowed to translate the\n+// item and false otherwise. Currently, this parameter is set to false when\n+// translating default methods.\n+fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id,\n+                            translate: bool)\n+    -> ast::def_id {\n     let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n     match ccx.external.find(fn_id) {\n       Some(Some(node_id)) => {\n@@ -31,7 +34,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n           csearch::found(ast::ii_item(item)) => {\n             ccx.external.insert(fn_id, Some(item.id));\n             ccx.stats.n_inlines += 1;\n-            trans_item(ccx, *item);\n+            if translate { trans_item(ccx, *item); }\n             local_def(item.id)\n           }\n           csearch::found(ast::ii_foreign(item)) => {\n@@ -53,7 +56,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n               _ => ccx.sess.bug(~\"maybe_instantiate_inline: item has a \\\n                     non-enum parent\")\n             }\n-            trans_item(ccx, *item);\n+            if translate { trans_item(ccx, *item); }\n             local_def(my_id)\n           }\n           csearch::found_parent(_, _) => {\n@@ -65,13 +68,14 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n             ccx.external.insert(fn_id, Some(mth.id));\n             let {bounds: impl_bnds, region_param: _, ty: impl_ty} =\n                 ty::lookup_item_type(ccx.tcx, impl_did);\n-            if (*impl_bnds).len() + mth.tps.len() == 0u {\n+            if translate && (*impl_bnds).len() + mth.tps.len() == 0u {\n                 let llfn = get_item_val(ccx, mth.id);\n                 let path = vec::append(\n                     ty::item_path(ccx.tcx, impl_did),\n                     ~[path_name(mth.ident)]);\n                 trans_fn(ccx, path, mth.decl, mth.body,\n-                         llfn, impl_self(impl_ty), None, mth.id);\n+                         llfn, impl_self(impl_ty), None, mth.id,\n+                         Some(impl_did));\n             }\n             local_def(mth.id)\n           }\n@@ -83,3 +87,4 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n       }\n     }\n }\n+"}, {"sha": "89b101ab8759899680d52db35f991f46aa0e2ba1", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 72, "deletions": 19, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -28,15 +28,30 @@ see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n               methods: ~[@ast::method], tps: ~[ast::ty_param],\n-              self_ty: Option<ty::t>) {\n+              self_ty: Option<ty::t>, id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n     if tps.len() > 0u { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n     for vec::each(methods) |method| {\n         if method.tps.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n             let path = vec::append_one(sub_path, path_name(method.ident));\n-            trans_method(ccx, path, *method, None, self_ty, llfn);\n+\n+            let param_substs_opt;\n+            match self_ty {\n+                None => param_substs_opt = None,\n+                Some(self_ty) => {\n+                    param_substs_opt = Some({\n+                        tys: ~[],\n+                        vtables: None,\n+                        bounds: @~[],\n+                        self_ty: Some(self_ty)\n+                    });\n+                }\n+            }\n+\n+            trans_method(ccx, path, *method, param_substs_opt, self_ty, llfn,\n+                         ast_util::local_def(id));\n         }\n     }\n }\n@@ -54,13 +69,15 @@ Translates a (possibly monomorphized) method body.\n   will be none if this is not a default method and must always be present\n   if this is a default method.\n - `llfn`: the LLVM ValueRef for the method\n+- `impl_id`: the node ID of the impl this method is inside\n */\n fn trans_method(ccx: @crate_ctxt,\n                 path: path,\n                 method: &ast::method,\n                 param_substs: Option<param_substs>,\n                 base_self_ty: Option<ty::t>,\n-                llfn: ValueRef) {\n+                llfn: ValueRef,\n+                impl_id: ast::def_id) {\n \n     // figure out how self is being passed\n     let self_arg = match method.self_ty.node {\n@@ -76,8 +93,10 @@ fn trans_method(ccx: @crate_ctxt,\n             Some(provided_self_ty) => self_ty = provided_self_ty\n         }\n         let self_ty = match param_substs {\n-          None => self_ty,\n-          Some({tys: ref tys, _}) => ty::subst_tps(ccx.tcx, *tys, self_ty)\n+            None => self_ty,\n+            Some({tys: ref tys, _}) => {\n+                ty::subst_tps(ccx.tcx, *tys, None, self_ty)\n+            }\n         };\n         match method.self_ty.node {\n           ast::sty_value => {\n@@ -98,15 +117,20 @@ fn trans_method(ccx: @crate_ctxt,\n              llfn,\n              self_arg,\n              param_substs,\n-             method.id);\n+             method.id,\n+             Some(impl_id));\n }\n \n-fn trans_self_arg(bcx: block, base: @ast::expr,\n+fn trans_self_arg(bcx: block,\n+                  base: @ast::expr,\n                   mentry: typeck::method_map_entry) -> Result {\n     let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n     let mut temp_cleanups = ~[];\n+\n+    // Compute the mode and type of self.\n     let self_arg = {mode: mentry.self_arg.mode,\n                     ty: monomorphize_type(bcx, mentry.self_arg.ty)};\n+\n     let result = trans_arg_expr(bcx, self_arg, base,\n                                 &mut temp_cleanups, None, DontAutorefArg);\n \n@@ -120,11 +144,31 @@ fn trans_self_arg(bcx: block, base: @ast::expr,\n }\n \n fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n-                       self: @ast::expr, mentry: typeck::method_map_entry)\n-    -> Callee\n-{\n+                       self: @ast::expr, mentry: typeck::method_map_entry) ->\n+                       Callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n-    match mentry.origin {\n+\n+    // Replace method_self with method_static here.\n+    let mut origin = mentry.origin;\n+    match origin {\n+        typeck::method_self(copy trait_id, copy method_index) => {\n+            // Get the ID of the impl we're inside.\n+            let impl_def_id = bcx.fcx.impl_id.get();\n+\n+            io::println(fmt!(\"impl_def_id is %?\", impl_def_id));\n+\n+            // Get the ID of the method we're calling.\n+            let method_name =\n+                ty::trait_methods(bcx.tcx(), trait_id)[method_index].ident;\n+            let method_id = method_with_name(bcx.ccx(), impl_def_id,\n+                                             method_name);\n+            origin = typeck::method_static(method_id);\n+        }\n+        typeck::method_static(*) | typeck::method_param(*) |\n+        typeck::method_trait(*) => {}\n+    }\n+\n+    match origin {\n         typeck::method_static(did) => {\n             let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n             let Result {bcx, val} = trans_self_arg(bcx, self, mentry);\n@@ -155,7 +199,7 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n             trans_trait_callee(bcx, callee_id, off, self, vstore)\n         }\n         typeck::method_self(*) => {\n-            bcx.tcx().sess.span_bug(self.span, ~\"self method call\");\n+            fail ~\"method_self should have been handled above\"\n         }\n     }\n }\n@@ -519,13 +563,21 @@ fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n     match origin {\n         typeck::vtable_static(impl_id, substs, sub_vtables) => {\n             monomorphize::make_mono_id(\n-                ccx, impl_id, substs,\n-                if (*sub_vtables).len() == 0u { None }\n-                else { Some(sub_vtables) }, None)\n+                ccx,\n+                impl_id,\n+                substs,\n+                if (*sub_vtables).len() == 0u {\n+                    None\n+                } else {\n+                    Some(sub_vtables)\n+                },\n+                None,\n+                None)\n         }\n         typeck::vtable_trait(trait_id, substs) => {\n             @{def: trait_id,\n-              params: vec::map(substs, |t| mono_precise(*t, None))}\n+              params: vec::map(substs, |t| mono_precise(*t, None)),\n+              impl_did_opt: None}\n         }\n         // can't this be checked at the callee?\n         _ => fail ~\"vtable_id\"\n@@ -571,7 +623,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n \n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n     make_vtable(ccx, vec::map(*ty::trait_methods(tcx, trt_id), |im| {\n-        let fty = ty::subst_tps(tcx, substs, ty::mk_fn(tcx, im.fty));\n+        let fty = ty::subst_tps(tcx, substs, None, ty::mk_fn(tcx, im.fty));\n         if (*im.tps).len() > 0u || ty::type_has_self(fty) {\n             C_null(T_ptr(T_nil()))\n         } else {\n@@ -580,10 +632,11 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n                 // If the method is in another crate, need to make an inlined\n                 // copy first\n                 if m_id.crate != ast::local_crate {\n-                    m_id = inline::maybe_instantiate_inline(ccx, m_id);\n+                    // XXX: Set impl ID here?\n+                    m_id = inline::maybe_instantiate_inline(ccx, m_id, true);\n                 }\n                 monomorphize::monomorphic_fn(ccx, m_id, substs,\n-                                             Some(vtables), None).val\n+                                             Some(vtables), None, None).val\n             } else if m_id.crate == ast::local_crate {\n                 get_item_val(ccx, m_id.node)\n             } else {"}, {"sha": "f6763206e18ceab13856a0027e89aea1b391b346", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -16,9 +16,9 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n                   fn_id: ast::def_id,\n                   real_substs: ~[ty::t],\n                   vtables: Option<typeck::vtable_res>,\n-                  ref_id: Option<ast::node_id>)\n-    -> {val: ValueRef, must_cast: bool}\n-{\n+                  impl_did_opt: Option<ast::def_id>,\n+                  ref_id: Option<ast::node_id>) ->\n+                  {val: ValueRef, must_cast: bool} {\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs, |t| {\n@@ -31,7 +31,8 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n     for real_substs.each() |s| { assert !ty::type_has_params(*s); }\n     for substs.each() |s| { assert !ty::type_has_params(*s); }\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n-    let hash_id = make_mono_id(ccx, fn_id, substs, vtables, Some(param_uses));\n+    let hash_id = make_mono_id(ccx, fn_id, substs, vtables, impl_did_opt,\n+                               Some(param_uses));\n     if vec::any(hash_id.params,\n                 |p| match *p { mono_precise(_, _) => false, _ => true }) {\n         must_cast = true;\n@@ -73,8 +74,11 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n       }\n       ast_map::node_dtor(_, dtor, _, pt) =>\n           (pt, special_idents::dtor, dtor.span),\n-      ast_map::node_trait_method(*) => {\n-        ccx.tcx.sess.bug(~\"Can't monomorphize a trait method\")\n+      ast_map::node_trait_method(@ast::provided(m), _, pt) => {\n+        (pt, m.ident, m.span)\n+      }\n+      ast_map::node_trait_method(@ast::required(_), _, _) => {\n+        ccx.tcx.sess.bug(~\"Can't monomorphize a required trait method\")\n       }\n       ast_map::node_expr(*) => {\n         ccx.tcx.sess.bug(~\"Can't monomorphize an expr\")\n@@ -93,7 +97,18 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n           ccx.tcx.sess.bug(~\"Can't monomorphize a local\")\n       }\n     };\n-    let mono_ty = ty::subst_tps(ccx.tcx, substs, llitem_ty);\n+\n+    // Look up the impl type if we're translating a default method.\n+    // XXX: Generics.\n+    let impl_ty_opt;\n+    match impl_did_opt {\n+        None => impl_ty_opt = None,\n+        Some(impl_did) => {\n+            impl_ty_opt = Some(ty::lookup_item_type(ccx.tcx, impl_did).ty);\n+        }\n+    }\n+\n+    let mono_ty = ty::subst_tps(ccx.tcx, substs, impl_ty_opt, llitem_ty);\n     let llfty = type_of_fn_from_ty(ccx, mono_ty);\n \n     ccx.stats.n_monos += 1;\n@@ -118,12 +133,18 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n         lldecl\n     };\n \n-    let psubsts = Some({tys: substs, vtables: vtables, bounds: tpt.bounds});\n+    let psubsts = Some({\n+        tys: substs,\n+        vtables: vtables,\n+        bounds: tpt.bounds,\n+        self_ty: impl_ty_opt\n+    });\n+\n     let lldecl = match map_node {\n       ast_map::node_item(i@@{node: ast::item_fn(decl, _, _, body), _}, _) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(i.attrs, d);\n-        trans_fn(ccx, pt, decl, body, d, no_self, psubsts, fn_id.node);\n+        trans_fn(ccx, pt, decl, body, d, no_self, psubsts, fn_id.node, None);\n         d\n       }\n       ast_map::node_item(*) => {\n@@ -154,11 +175,19 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n         }\n         d\n       }\n-      ast_map::node_method(mth, _, _) => {\n+      ast_map::node_method(mth, supplied_impl_did, _) => {\n         // XXX: What should the self type be here?\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(mth.attrs, d);\n-        meth::trans_method(ccx, pt, mth, psubsts, None, d);\n+\n+        // Override the impl def ID if necessary.\n+        let impl_did;\n+        match impl_did_opt {\n+            None => impl_did = supplied_impl_did,\n+            Some(override_impl_did) => impl_did = override_impl_did\n+        }\n+\n+        meth::trans_method(ccx, pt, mth, psubsts, None, d, impl_did);\n         d\n       }\n       ast_map::node_dtor(_, dtor, _, pt) => {\n@@ -171,6 +200,15 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n         trans_class_dtor(ccx, *pt, dtor.node.body,\n           dtor.node.id, psubsts, Some(hash_id), parent_id)\n       }\n+      ast_map::node_trait_method(@ast::provided(mth), _, pt) => {\n+        let d = mk_lldecl();\n+        set_inline_hint_if_appr(mth.attrs, d);\n+        io::println(fmt!(\"monomorphic_fn impl_did_opt is %?\", impl_did_opt));\n+        meth::trans_method(ccx, *pt, mth, psubsts, None, d,\n+                           impl_did_opt.get());\n+        d\n+      }\n+\n       // Ugh -- but this ensures any new variants won't be forgotten\n       ast_map::node_expr(*) |\n       ast_map::node_stmt(*) |\n@@ -226,6 +264,7 @@ fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> Option<ty::t> {\n \n fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n                 vtables: Option<typeck::vtable_res>,\n+                impl_did_opt: Option<ast::def_id>,\n                 param_uses: Option<~[type_use::type_uses]>) -> mono_id {\n     let precise_param_ids = match vtables {\n       Some(vts) => {\n@@ -295,5 +334,5 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n           })\n       }\n     };\n-    @{def: item, params: param_ids}\n+    @{def: item, params: param_ids, impl_did_opt: impl_did_opt}\n }"}, {"sha": "8ccc8a28de3a2e88b38375e81ba1fe1098aa652e", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -40,8 +40,13 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       Some(uses) => return uses,\n       None => ()\n     }\n-    let fn_id_loc = if fn_id.crate == local_crate { fn_id }\n-                    else { inline::maybe_instantiate_inline(ccx, fn_id) };\n+\n+    let fn_id_loc = if fn_id.crate == local_crate {\n+        fn_id\n+    } else {\n+        inline::maybe_instantiate_inline(ccx, fn_id, true)\n+    };\n+\n     // Conservatively assume full use for recursive loops\n     ccx.type_use_cache.insert(fn_id, vec::from_elem(n_tps, 3u));\n "}, {"sha": "a0ca46ee017824353bb446782a620ba7513693be", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -19,6 +19,7 @@ use syntax::ast::*;\n use syntax::print::pprust::*;\n use util::ppaux::{ty_to_str, proto_ty_to_str, tys_to_str};\n \n+export ProvidedMethodSource;\n export TyVid, IntVid, FnVid, RegionVid, vid;\n export br_hashmap;\n export is_instantiable;\n@@ -207,7 +208,8 @@ type method = {ident: ast::ident,\n                tps: @~[param_bounds],\n                fty: FnTy,\n                self_ty: ast::self_ty_,\n-               vis: ast::visibility};\n+               vis: ast::visibility,\n+               def_id: ast::def_id};\n \n type mt = {ty: t, mutbl: ast::mutability};\n \n@@ -314,6 +316,11 @@ enum AutoRefKind {\n     AutoPtr\n }\n \n+struct ProvidedMethodSource {\n+    method_id: ast::def_id,\n+    impl_id: ast::def_id\n+}\n+\n type ctxt =\n     @{diag: syntax::diagnostic::span_handler,\n       interner: HashMap<intern_key, t_box>,\n@@ -356,7 +363,8 @@ type ctxt =\n       adjustments: HashMap<ast::node_id, @AutoAdjustment>,\n       normalized_cache: HashMap<t, t>,\n       lang_items: middle::lang_items::LanguageItems,\n-      legacy_boxed_traits: HashMap<node_id, ()>};\n+      legacy_boxed_traits: HashMap<node_id, ()>,\n+      provided_method_sources: HashMap<ast::def_id, ProvidedMethodSource>};\n \n enum tbox_flag {\n     has_params = 1,\n@@ -879,7 +887,8 @@ fn mk_ctxt(s: session::session,\n       adjustments: HashMap(),\n       normalized_cache: new_ty_hash(),\n       lang_items: move lang_items,\n-      legacy_boxed_traits: HashMap()}\n+      legacy_boxed_traits: HashMap(),\n+      provided_method_sources: HashMap()}\n }\n \n \n@@ -1392,13 +1401,23 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n }\n \n // Substitute *only* type parameters.  Used in trans where regions are erased.\n-fn subst_tps(cx: ctxt, tps: &[t], typ: t) -> t {\n-    if tps.len() == 0u { return typ; }\n+fn subst_tps(cx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n+    if tps.len() == 0u && self_ty_opt.is_none() { return typ; }\n     let tb = ty::get(typ);\n-    if !tbox_has_flag(tb, has_params) { return typ; }\n+    if self_ty_opt.is_none() && !tbox_has_flag(tb, has_params) { return typ; }\n     match tb.sty {\n-      ty_param(p) => tps[p.idx],\n-      ref sty => fold_sty_to_ty(cx, sty, |t| subst_tps(cx, tps, t))\n+        ty_param(p) => tps[p.idx],\n+        ty_self => {\n+            match self_ty_opt {\n+                None => cx.sess.bug(~\"ty_self unexpected here\"),\n+                Some(self_ty) => {\n+                    subst_tps(cx, tps, self_ty_opt, self_ty)\n+                }\n+            }\n+        }\n+        ref sty => {\n+            fold_sty_to_ty(cx, sty, |t| subst_tps(cx, tps, self_ty_opt, t))\n+        }\n     }\n }\n \n@@ -3328,20 +3347,18 @@ fn store_trait_methods(cx: ctxt, id: ast::node_id, ms: @~[method]) {\n     cx.trait_method_cache.insert(ast_util::local_def(id), ms);\n }\n \n-fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[@ast::method] {\n+fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n     if is_local(id) {\n         match cx.items.find(id.node) {\n             Some(ast_map::node_item(@{node: item_trait(_, _, ms),_}, _)) =>\n                 match ast_util::split_trait_methods(ms) {\n-                   (_, p) => p\n+                   (_, p) => p.map(|method| method.ident)\n                 },\n             _ => cx.sess.bug(fmt!(\"provided_trait_methods: %? is not a trait\",\n                                   id))\n         }\n-    }\n-    else {\n-        // FIXME #2794: default methods for traits don't work cross-crate\n-        ~[]\n+    } else {\n+        csearch::get_provided_trait_methods(cx, id).map(|info| info.ty.ident)\n     }\n }\n \n@@ -3599,10 +3616,12 @@ fn enum_variant_with_id(cx: ctxt, enum_id: ast::def_id,\n // the type cache. Returns the type parameters and type.\n fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n     match cx.tcache.find(did) {\n-      Some(tpt) => return tpt,\n-      None => {\n+      Some(tpt) => {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already\n+        return tpt;\n+      }\n+      None => {\n         assert did.crate != ast::local_crate;\n         let tyt = csearch::get_type(cx, did);\n         cx.tcache.insert(did, tyt);"}, {"sha": "077d34700b8d40268abb9187214c80fbb5c79d46", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -62,6 +62,7 @@ use util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n use util::common::{indent, indenter};\n use std::list;\n use list::{List, Nil, Cons};\n+use dvec::DVec;\n \n export check_crate;\n export infer;\n@@ -174,12 +175,6 @@ impl vtable_origin {\n \n type vtable_map = HashMap<ast::node_id, vtable_res>;\n \n-// Stores information about provided methods, aka \"default methods\" in traits.\n-// Maps from a trait's def_id to a MethodInfo about\n-// that method in that trait.\n-type provided_methods_map = HashMap<ast::node_id,\n-                                    ~[@resolve::MethodInfo]>;\n-\n type ty_param_substs_and_ty = {substs: ty::substs, ty: ty::t};\n \n type crate_ctxt_ = {// A mapping from method call sites to traits that have\n@@ -188,7 +183,6 @@ type crate_ctxt_ = {// A mapping from method call sites to traits that have\n                     method_map: method_map,\n                     vtable_map: vtable_map,\n                     coherence_info: @coherence::CoherenceInfo,\n-                    provided_methods_map: provided_methods_map,\n                     tcx: ty::ctxt};\n \n enum crate_ctxt {\n@@ -340,7 +334,6 @@ fn check_crate(tcx: ty::ctxt,\n                             method_map: std::map::HashMap(),\n                             vtable_map: std::map::HashMap(),\n                             coherence_info: @coherence::CoherenceInfo(),\n-                            provided_methods_map: std::map::HashMap(),\n                             tcx: tcx});\n     collect::collect_item_types(ccx, crate);\n     coherence::check_coherence(ccx, crate);"}, {"sha": "04be0047548286bd0f5ff349b69630d90745edca", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -69,7 +69,7 @@ obtained the type `Foo`, we would never match this method.\n \n */\n \n-use coherence::get_base_type_def_id;\n+use coherence::{ProvidedMethodInfo, get_base_type_def_id};\n use middle::resolve::{Impl, MethodInfo};\n use middle::ty::*;\n use syntax::ast::{def_id, sty_by_ref, sty_value, sty_region, sty_box,\n@@ -146,7 +146,7 @@ impl LookupContext {\n \n         // Prepare the list of candidates\n         self.push_inherent_candidates(self_ty);\n-        self.push_extension_candidates();\n+        self.push_extension_candidates(self_ty);\n \n         let enum_dids = DVec();\n         let mut self_ty = self_ty;\n@@ -251,14 +251,16 @@ impl LookupContext {\n         }\n     }\n \n-    fn push_extension_candidates(&self) {\n+    fn push_extension_candidates(&self, self_ty: ty::t) {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n         let opt_applicable_traits = self.fcx.ccx.trait_map.find(self.expr.id);\n         for opt_applicable_traits.each |applicable_traits| {\n             for applicable_traits.each |trait_did| {\n                 let coherence_info = self.fcx.ccx.coherence_info;\n+\n+                // Look for explicit implementations.\n                 let opt_impl_infos =\n                     coherence_info.extension_methods.find(*trait_did);\n                 for opt_impl_infos.each |impl_infos| {\n@@ -267,12 +269,21 @@ impl LookupContext {\n                             &self.extension_candidates, *impl_info);\n                     }\n                 }\n+\n+                // Look for default methods.\n+                match coherence_info.provided_methods.find(*trait_did) {\n+                    Some(methods) => {\n+                        self.push_candidates_from_provided_methods(\n+                            &self.extension_candidates, self_ty, *trait_did,\n+                            methods);\n+                    }\n+                    None => {}\n+                }\n             }\n         }\n     }\n \n-    fn push_inherent_candidates_from_param(&self, param_ty: param_ty)\n-    {\n+    fn push_inherent_candidates_from_param(&self, param_ty: param_ty) {\n         debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n                param_ty);\n         let _indenter = indenter();\n@@ -348,8 +359,7 @@ impl LookupContext {\n                                            self_ty: ty::t,\n                                            did: def_id,\n                                            substs: &ty::substs,\n-                                           vstore: ty::vstore)\n-    {\n+                                           vstore: ty::vstore) {\n         debug!(\"push_inherent_candidates_from_trait(did=%s, substs=%s)\",\n                self.did_to_str(did),\n                substs_to_str(self.tcx(), substs));\n@@ -423,8 +433,7 @@ impl LookupContext {\n         });\n     }\n \n-    fn push_inherent_impl_candidates_for_type(did: def_id)\n-    {\n+    fn push_inherent_impl_candidates_for_type(did: def_id) {\n         let opt_impl_infos =\n             self.fcx.ccx.coherence_info.inherent_methods.find(did);\n         for opt_impl_infos.each |impl_infos| {\n@@ -436,8 +445,7 @@ impl LookupContext {\n     }\n \n     fn push_candidates_from_impl(&self, candidates: &DVec<Candidate>,\n-                                 impl_info: &resolve::Impl)\n-    {\n+                                 impl_info: &resolve::Impl) {\n         if !self.impl_dups.insert(impl_info.did, ()) {\n             return; // already visited\n         }\n@@ -471,12 +479,47 @@ impl LookupContext {\n         });\n     }\n \n+    fn push_candidates_from_provided_methods(\n+            &self,\n+            candidates: &DVec<Candidate>,\n+            self_ty: ty::t,\n+            trait_def_id: def_id,\n+            methods: @DVec<@ProvidedMethodInfo>) {\n+        debug!(\"(pushing candidates from provided methods) considering trait \\\n+                id %d:%d\",\n+               trait_def_id.crate,\n+               trait_def_id.node);\n+\n+        for methods.each |provided_method_info| {\n+            if provided_method_info.method_info.ident != self.m_name { loop; }\n+\n+            debug!(\"(pushing candidates from provided methods) adding \\\n+                    candidate\");\n+\n+            // XXX: Needs to support generics.\n+            let dummy_substs = { self_r: None, self_ty: None, tps: ~[] };\n+            let (impl_ty, impl_substs) =\n+                self.create_rcvr_ty_and_substs_for_method(\n+                    provided_method_info.method_info.self_type,\n+                    self_ty,\n+                    dummy_substs);\n+\n+            candidates.push(Candidate {\n+                rcvr_ty: impl_ty,\n+                rcvr_substs: move impl_substs,\n+                num_method_tps: provided_method_info.method_info.n_tps,\n+                self_mode: get_mode_from_self_type(\n+                    provided_method_info.method_info.self_type),\n+                origin: method_static(provided_method_info.method_info.did)\n+            });\n+        }\n+    }\n+\n     fn create_rcvr_ty_and_substs_for_method(&self,\n                                             self_decl: ast::self_ty_,\n                                             self_ty: ty::t,\n                                             +self_substs: ty::substs)\n-        -> (ty::t, ty::substs)\n-    {\n+        -> (ty::t, ty::substs) {\n         // If the self type includes a region (like &self), we need to\n         // ensure that the receiver substitutions have a self region.\n         // If the receiver type does not itself contain borrowed\n@@ -693,8 +736,7 @@ impl LookupContext {\n     fn confirm_candidate(&self,\n                          self_ty: ty::t,\n                          candidate: &Candidate)\n-        -> method_map_entry\n-    {\n+        -> method_map_entry {\n         let tcx = self.tcx();\n         let fty = self.fn_ty_from_origin(&candidate.origin);\n "}, {"sha": "345b8246b4278d27391a9f9d0b148146553a5287", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -444,7 +444,7 @@ fn connect_trait_tps(fcx: @fn_ctxt, expr: @ast::expr, impl_tys: ~[ty::t],\n \n     // XXX: This should work for multiple traits.\n     let ity = ty::impl_traits(tcx, impl_did, vstore)[0];\n-    let trait_ty = ty::subst_tps(tcx, impl_tys, ity);\n+    let trait_ty = ty::subst_tps(tcx, impl_tys, None, ity);\n     debug!(\"(connect trait tps) trait type is %?, impl did is %?\",\n            ty::get(trait_ty).sty, impl_did);\n     match ty::get(trait_ty).sty {"}, {"sha": "9a9a8dda6e4d8f03cc920556e434ddf1e022719a", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 179, "deletions": 116, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -4,20 +4,21 @@\n // has at most one implementation for each type. Then we build a mapping from\n // each trait in the system to its implementations.\n \n-use metadata::csearch::{each_path, get_impl_traits, get_impls_for_mod};\n+use metadata::csearch::{ProvidedTraitMethodInfo, each_path, get_impl_traits};\n+use metadata::csearch::{get_impls_for_mod};\n use metadata::cstore::{cstore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n-use middle::ty::{get, lookup_item_type, subst, t, ty_box};\n-use middle::ty::{ty_uniq, ty_ptr, ty_rptr, ty_enum};\n+use middle::ty::{ProvidedMethodSource, get, lookup_item_type, subst, t};\n+use middle::ty::{ty_box, ty_uniq, ty_ptr, ty_rptr, ty_enum};\n use middle::ty::{ty_class, ty_nil, ty_bot, ty_bool, ty_int, ty_uint};\n use middle::ty::{ty_float, ty_estr, ty_evec, ty_rec};\n use middle::ty::{ty_fn, ty_trait, ty_tup, ty_infer};\n use middle::ty::{ty_param, ty_self, ty_type, ty_opaque_box};\n use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_is_ty_var};\n use middle::typeck::infer::{infer_ctxt, can_mk_subty};\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n-use syntax::ast::{crate, def_id, def_mod};\n+use syntax::ast::{crate, def_id, def_mod, def_ty};\n use syntax::ast::{item, item_class, item_const, item_enum, item_fn};\n use syntax::ast::{item_foreign_mod, item_impl, item_mac, item_mod};\n use syntax::ast::{item_trait, item_ty, local_crate, method, node_id};\n@@ -118,6 +119,21 @@ fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n     }\n }\n \n+// Stores the method info and definition ID of the associated trait method for\n+// each instantiation of each provided method.\n+struct ProvidedMethodInfo {\n+    method_info: @MethodInfo,\n+    trait_method_def_id: def_id\n+}\n+\n+// Stores information about provided methods (a.k.a. default methods) in\n+// implementations.\n+//\n+// This is a map from ID of each implementation to the method info and trait\n+// method ID of each of the default methods belonging to the trait that that\n+// implementation implements.\n+type ProvidedMethodsMap = HashMap<def_id,@DVec<@ProvidedMethodInfo>>;\n+\n struct CoherenceInfo {\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n@@ -128,14 +144,20 @@ struct CoherenceInfo {\n     extension_methods: HashMap<def_id,@DVec<@Impl>>,\n \n     // A mapping from a supertrait to its subtraits.\n-    supertrait_to_subtraits: HashMap<def_id,@DVec<def_id>>\n+    supertrait_to_subtraits: HashMap<def_id,@DVec<def_id>>,\n+\n+    // A mapping from an implementation ID to the method info and trait method\n+    // ID of the provided (a.k.a. default) methods in the traits that that\n+    // implementation implements.\n+    provided_methods: ProvidedMethodsMap,\n }\n \n fn CoherenceInfo() -> CoherenceInfo {\n     CoherenceInfo {\n         inherent_methods: HashMap(),\n         extension_methods: HashMap(),\n-        supertrait_to_subtraits: HashMap()\n+        supertrait_to_subtraits: HashMap(),\n+        provided_methods: HashMap(),\n     }\n }\n \n@@ -165,68 +187,6 @@ struct CoherenceChecker {\n }\n \n impl CoherenceChecker {\n-    // Create a mapping containing a MethodInfo for every provided\n-    // method in every trait.\n-    fn build_provided_methods_map(crate: @crate) {\n-        let sess = self.crate_context.tcx.sess;\n-\n-        let pmm = self.crate_context.provided_methods_map;\n-\n-        visit_crate(*crate, (), mk_simple_visitor(@{\n-            visit_item: |item| {\n-                match item.node {\n-                  item_trait(_, _, trait_methods) => {\n-                    for trait_methods.each |trait_method| {\n-                        debug!(\"(building provided methods map) checking \\\n-                                trait `%s` with id %d\",\n-                                sess.str_of(item.ident), item.id);\n-\n-                        match *trait_method {\n-                            required(_) => { /* fall through */}\n-                            provided(m) => {\n-                                // For every provided method in the\n-                                // trait, store a MethodInfo.\n-                                let mi = method_to_MethodInfo(m);\n-\n-                                match pmm.find(item.id) {\n-                                    Some(mis) => {\n-                                      // If the trait already has an\n-                                      // entry in the\n-                                      // provided_methods_map, we just\n-                                      // need to add this method to\n-                                      // that entry.\n-                                      debug!(\"(building provided \\\n-                                              methods map) adding \\\n-                                              method `%s` to entry for \\\n-                                              existing trait\",\n-                                              sess.str_of(mi.ident));\n-                                      let mut method_infos = mis;\n-                                      method_infos.push(mi);\n-                                      pmm.insert(item.id, method_infos);\n-                                    }\n-                                    None => {\n-                                      // If the trait doesn't have an\n-                                      // entry yet, create one.\n-                                      debug!(\"(building provided \\\n-                                              methods map) creating new \\\n-                                              entry for method `%s`\",\n-                                              sess.str_of(mi.ident));\n-                                      pmm.insert(item.id, ~[mi]);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                  }\n-                  _ => {\n-                    // Nothing to do.\n-                  }\n-                };\n-            },\n-            .. *default_simple_visitor()\n-        }));\n-    }\n-\n     fn check_coherence(crate: @crate) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n@@ -307,6 +267,7 @@ impl CoherenceChecker {\n                         self.crate_context.tcx.sess.parse_sess.interner),\n                     self.crate_context.tcx.sess.str_of(item.ident));\n \n+            self.instantiate_default_methods(item.id, trait_did);\n             let implementation = self.create_impl_from_item(item);\n             self.add_trait_method(trait_did, implementation);\n         }\n@@ -321,6 +282,7 @@ impl CoherenceChecker {\n                 // Nothing to do.\n             }\n             Some(base_type_def_id) => {\n+                // XXX: Gather up default methods?\n                 let implementation = self.create_impl_from_item(item);\n                 self.add_inherent_method(base_type_def_id, implementation);\n \n@@ -330,6 +292,68 @@ impl CoherenceChecker {\n         }\n     }\n \n+    // Creates default method IDs and performs type substitutions for an impl\n+    // and trait pair. Then, for each provided method in the trait, inserts a\n+    // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n+    fn instantiate_default_methods(impl_id: ast::node_id,\n+                                   trait_did: ast::def_id) {\n+        for self.each_provided_trait_method(trait_did) |trait_method| {\n+            // Synthesize an ID.\n+            let tcx = self.crate_context.tcx;\n+            let new_id = syntax::parse::next_node_id(tcx.sess.parse_sess);\n+            let new_did = local_def(new_id);\n+\n+            // XXX: Perform substitutions.\n+            let new_polytype = ty::lookup_item_type(tcx, trait_method.def_id);\n+            tcx.tcache.insert(new_did, new_polytype);\n+\n+            // Pair the new synthesized ID up with the\n+            // ID of the method.\n+            let source = ProvidedMethodSource {\n+                method_id: trait_method.def_id,\n+                impl_id: local_def(impl_id)\n+            };\n+\n+            self.crate_context.tcx.provided_method_sources.insert(new_did,\n+                                                                  source);\n+\n+            let provided_method_info =\n+                @ProvidedMethodInfo {\n+                    method_info: @{\n+                        did: new_did,\n+                        n_tps: trait_method.tps.len(),\n+                        ident: trait_method.ident,\n+                        self_type: trait_method.self_ty\n+                    },\n+                    trait_method_def_id: trait_method.def_id\n+                };\n+\n+            let pmm = self.crate_context.coherence_info.provided_methods;\n+            match pmm.find(local_def(impl_id)) {\n+                Some(mis) => {\n+                    // If the trait already has an entry in the\n+                    // provided_methods_map, we just need to add this\n+                    // method to that entry.\n+                    debug!(\"(checking implementation) adding method `%s` \\\n+                            to entry for existing trait\",\n+                            self.crate_context.tcx.sess.str_of(\n+                                provided_method_info.method_info.ident));\n+                    mis.push(provided_method_info);\n+                }\n+                None => {\n+                    // If the trait doesn't have an entry yet, create one.\n+                    debug!(\"(checking implementation) creating new entry \\\n+                            for method `%s`\",\n+                            self.crate_context.tcx.sess.str_of(\n+                                provided_method_info.method_info.ident));\n+                    let method_infos = @DVec();\n+                    method_infos.push(provided_method_info);\n+                    pmm.insert(local_def(impl_id), method_infos);\n+                }\n+            }\n+        }\n+    }\n+\n     fn register_inherited_trait(item: @item, supertraits: ~[@trait_ref]) {\n         // XXX: This is wrong. We need to support substitutions; e.g.\n         // trait Foo : Bar<int>.\n@@ -354,8 +378,7 @@ impl CoherenceChecker {\n     fn add_inherent_method(base_def_id: def_id, implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.inherent_methods\n-            .find(base_def_id) {\n-\n+                  .find(base_def_id) {\n             None => {\n                 implementation_list = @DVec();\n                 self.crate_context.coherence_info.inherent_methods\n@@ -372,8 +395,7 @@ impl CoherenceChecker {\n     fn add_trait_method(trait_id: def_id, implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.extension_methods\n-                .find(trait_id) {\n-\n+                  .find(trait_id) {\n             None => {\n                 implementation_list = @DVec();\n                 self.crate_context.coherence_info.extension_methods\n@@ -413,6 +435,26 @@ impl CoherenceChecker {\n         }\n     }\n \n+    fn each_provided_trait_method(\n+            trait_did: ast::def_id,\n+            f: &fn(x: &ty::method) -> bool) {\n+        // Make a list of all the names of the provided methods.\n+        // XXX: This is horrible.\n+        let provided_method_idents = HashMap();\n+        let tcx = self.crate_context.tcx;\n+        for ty::provided_trait_methods(tcx, trait_did).each |ident| {\n+            provided_method_idents.insert(*ident, ());\n+        }\n+\n+        for ty::trait_methods(tcx, trait_did).each |method| {\n+            if provided_method_idents.contains_key(method.ident) {\n+                if !f(method) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n     fn polytypes_unify(polytype_a: ty_param_bounds_and_ty,\n                        polytype_b: ty_param_bounds_and_ty)\n                     -> bool {\n@@ -449,7 +491,6 @@ impl CoherenceChecker {\n \n     fn get_self_type_for_implementation(implementation: @Impl)\n                                      -> ty_param_bounds_and_ty {\n-\n         return self.crate_context.tcx.tcache.get(implementation.did);\n     }\n \n@@ -552,33 +593,15 @@ impl CoherenceChecker {\n \n     // Converts an implementation in the AST to an Impl structure.\n     fn create_impl_from_item(item: @item) -> @Impl {\n-\n-        fn add_provided_methods(inherent_methods: ~[@MethodInfo],\n-                                all_provided_methods: ~[@MethodInfo],\n-                                sess: driver::session::session)\n-            -> ~[@MethodInfo] {\n-\n-            let mut methods = inherent_methods;\n-\n-            // If there's no inherent method with the same name as a\n-            // provided method, add that provided method to `methods`.\n+        fn add_provided_methods(all_methods: &mut ~[@MethodInfo],\n+                                all_provided_methods: ~[@ProvidedMethodInfo],\n+                                sess: driver::session::session) {\n             for all_provided_methods.each |provided_method| {\n-                let mut method_inherent_to_impl = false;\n-                for inherent_methods.each |inherent_method| {\n-                    if provided_method.ident == inherent_method.ident {\n-                        method_inherent_to_impl = true;\n-                    }\n-                }\n-\n-                if !method_inherent_to_impl {\n-                    debug!(\n-                        \"(creating impl) adding provided method `%s` to impl\",\n-                        sess.str_of(provided_method.ident));\n-                    methods.push(*provided_method);\n-                }\n+                debug!(\n+                    \"(creating impl) adding provided method `%s` to impl\",\n+                    sess.str_of(provided_method.method_info.ident));\n+                vec::push(all_methods, provided_method.method_info);\n             }\n-\n-            return methods;\n         }\n \n         match item.node {\n@@ -598,24 +621,22 @@ impl CoherenceChecker {\n                     let trait_did =\n                         self.trait_ref_to_trait_def_id(*trait_ref);\n \n-                    match self.crate_context.provided_methods_map\n-                        .find(trait_did.node) {\n+                    match self.crate_context\n+                              .coherence_info\n+                              .provided_methods\n+                              .find(local_def(item.id)) {\n                         None => {\n                             debug!(\"(creating impl) trait with node_id `%d` \\\n                                     has no provided methods\", trait_did.node);\n                             /* fall through */\n                         }\n-                        Some(all_provided)\n-                                    => {\n+                        Some(all_provided) => {\n                             debug!(\"(creating impl) trait with node_id `%d` \\\n                                     has provided methods\", trait_did.node);\n-                            // Selectively add only those provided\n-                            // methods that aren't inherent to the\n-                            // trait.\n-\n-                            // XXX: could probably be doing this with filter.\n-                            methods = add_provided_methods(\n-                                methods, all_provided,\n+                            // Add all provided methods.\n+                            add_provided_methods(\n+                                &mut methods,\n+                                all_provided.get(),\n                                 self.crate_context.tcx.sess);\n                         }\n                     }\n@@ -758,6 +779,41 @@ impl CoherenceChecker {\n         }\n     }\n \n+    fn add_default_methods_for_external_trait(trait_def_id: ast::def_id) {\n+        let tcx = self.crate_context.tcx;\n+        let pmm = self.crate_context.coherence_info.provided_methods;\n+\n+        if pmm.contains_key(trait_def_id) { return; }\n+\n+        debug!(\"(adding default methods for trait) processing trait\");\n+\n+        for csearch::get_provided_trait_methods(tcx,\n+                                                trait_def_id).each |info| {\n+            debug!(\"(adding default methods for trait) found default method\");\n+\n+            // Create a new def ID for this provided method.\n+            let parse_sess = &self.crate_context.tcx.sess.parse_sess;\n+            let new_did = local_def(syntax::parse::next_node_id(*parse_sess));\n+\n+            let provided_method_info =\n+                @ProvidedMethodInfo {\n+                    method_info: @{\n+                        did: new_did,\n+                        n_tps: info.ty.tps.len(),\n+                        ident: info.ty.ident,\n+                        self_type: info.ty.self_ty\n+                    },\n+                    trait_method_def_id: info.def_id\n+                };\n+\n+            let method_infos = @DVec();\n+            method_infos.push(provided_method_info);\n+            pmm.insert(trait_def_id, method_infos);\n+        }\n+    }\n+\n+    // Adds implementations and traits from external crates to the coherence\n+    // info.\n     fn add_external_crates() {\n         let impls_seen = HashMap();\n \n@@ -768,28 +824,35 @@ impl CoherenceChecker {\n                                       { crate: crate_number, node: 0 });\n \n             for each_path(crate_store, crate_number) |path_entry| {\n-                let module_def_id;\n                 match path_entry.def_like {\n                     dl_def(def_mod(def_id)) => {\n-                        module_def_id = def_id;\n+                        self.add_impls_for_module(impls_seen,\n+                                                  crate_store,\n+                                                  def_id);\n+                    }\n+                    dl_def(def_ty(def_id)) => {\n+                        let tcx = self.crate_context.tcx;\n+                        let polytype = csearch::get_type(tcx, def_id);\n+                        match ty::get(polytype.ty).sty {\n+                            ty::ty_trait(*) => {\n+                                self.add_default_methods_for_external_trait(\n+                                    def_id);\n+                            }\n+                            _ => {}\n+                        }\n                     }\n                     dl_def(_) | dl_impl(_) | dl_field => {\n                         // Skip this.\n                         loop;\n                     }\n                 }\n-\n-                self.add_impls_for_module(impls_seen,\n-                                          crate_store,\n-                                          module_def_id);\n             }\n         }\n     }\n }\n \n fn check_coherence(crate_context: @crate_ctxt, crate: @crate) {\n     let coherence_checker = @CoherenceChecker(crate_context);\n-    (*coherence_checker).build_provided_methods_map(crate);\n     (*coherence_checker).check_coherence(crate);\n }\n "}, {"sha": "9e51225f172f2360e5e3acd9e30462b9946570c7", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -212,9 +212,15 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n     match tcx.items.get(id) {\n       ast_map::node_item(@{node: ast::item_trait(params, _, ms), _}, _) => {\n         store_methods::<ast::trait_method>(ccx, id, ms, |m| {\n+            let def_id;\n+            match *m {\n+                ast::required(ty_method) => def_id = local_def(ty_method.id),\n+                ast::provided(method) => def_id = local_def(method.id)\n+            }\n+\n             let trait_bounds = ty_param_bounds(ccx, params);\n             let ty_m = trait_method_to_ty_method(*m);\n-            let method_ty = ty_of_ty_method(ccx, ty_m, region_paramd);\n+            let method_ty = ty_of_ty_method(ccx, ty_m, region_paramd, def_id);\n             if ty_m.self_ty.node == ast::sty_static {\n                 make_static_method_ty(ccx, ty_m, region_paramd,\n                                       method_ty, trait_ty, trait_bounds);\n@@ -373,7 +379,7 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n \n               let provided_methods = ty::provided_trait_methods(tcx, did);\n               match vec::find(provided_methods, |provided_method|\n-                              provided_method.ident == trait_m.ident) {\n+                              *provided_method == trait_m.ident) {\n                 Some(_) => {\n                     // If there's a provided method with the name we\n                     // want, then we're fine; nothing else to do.\n@@ -546,19 +552,22 @@ fn ty_of_method(ccx: @crate_ctxt,\n                         m.purity, @~[],\n                         m.decl, None, m.span),\n      self_ty: m.self_ty.node,\n-     vis: m.vis}\n+     vis: m.vis,\n+     def_id: local_def(m.id)}\n }\n \n fn ty_of_ty_method(self: @crate_ctxt,\n                    m: ast::ty_method,\n-                   rp: Option<ty::region_variance>) -> ty::method {\n+                   rp: Option<ty::region_variance>,\n+                   id: ast::def_id) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(self, m.tps),\n      fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare, m.purity,\n                         @~[], m.decl, None, m.span),\n      // assume public, because this is only invoked on trait methods\n      self_ty: m.self_ty.node,\n-     vis: ast::public}\n+     vis: ast::public,\n+     def_id: id}\n }\n \n /*"}, {"sha": "6a05d9589130ea224f45ddbb33fe964494bc1eeb", "filename": "src/test/run-pass/default-method-simple.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Ftest%2Frun-pass%2Fdefault-method-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886629d4f2fb4a2712884b07de38101e9dc956c/src%2Ftest%2Frun-pass%2Fdefault-method-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault-method-simple.rs?ref=c886629d4f2fb4a2712884b07de38101e9dc956c", "patch": "@@ -0,0 +1,23 @@\n+trait Foo {\n+    fn f() {\n+        io::println(\"Hello!\");\n+        self.g();\n+    }\n+    fn g();\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+impl A : Foo {\n+    fn g() {\n+        io::println(\"Goodbye!\");\n+    }\n+}\n+\n+fn main() {\n+    let a = A { x: 1 };\n+    a.f();\n+}\n+"}]}