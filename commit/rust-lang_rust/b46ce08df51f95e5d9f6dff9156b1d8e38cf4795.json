{"sha": "b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NmNlMDhkZjUxZjk1ZTVkOWY2ZGZmOTE1NmIxZDhlMzhjZjQ3OTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-10T02:22:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-10T02:22:47Z"}, "message": "Auto merge of #37678 - eddyb:rollup, r=eddyb\n\nRollup of 5 pull requests\n\n- Successful merges: #37402, #37412, #37661, #37664, #37667\n- Failed merges:", "tree": {"sha": "605693ae8861f9ce5371e3ad076f6013e2a37fc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/605693ae8861f9ce5371e3ad076f6013e2a37fc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "html_url": "https://github.com/rust-lang/rust/commit/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8", "html_url": "https://github.com/rust-lang/rust/commit/0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8"}, {"sha": "3a5b45aae5142635e2b14c139a69c684bf3f1a19", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a5b45aae5142635e2b14c139a69c684bf3f1a19", "html_url": "https://github.com/rust-lang/rust/commit/3a5b45aae5142635e2b14c139a69c684bf3f1a19"}], "stats": {"total": 4351, "additions": 1827, "deletions": 2524}, "files": [{"sha": "28403711cd701f212db25d4e9b59cbdf69b47a3b", "filename": "src/doc/book/syntax-index.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Fdoc%2Fbook%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Fdoc%2Fbook%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsyntax-index.md?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -94,6 +94,7 @@\n * `|=` (`var |= expr`): bitwise or & assignment. Overloadable (`BitOrAssign`).\n * `||` (`expr || expr`): logical or.\n * `_`: \"ignored\" pattern binding (see [Patterns (Ignoring bindings)]). Also used to make integer-literals readable (see [Reference (Integer literals)]).\n+* `?` (`expr?`): Error propagation. Returns early when `Err(_)` is encountered, unwraps otherwise. Similar to the [`try!` macro].\n \n ## Other Syntax\n \n@@ -210,6 +211,7 @@\n [Functions]: functions.html\n [Generics]: generics.html\n [Iterators]: iterators.html\n+[`try!` macro]: error-handling.html#the-try-macro\n [Lifetimes]: lifetimes.html\n [Loops (`for`)]: loops.html#for\n [Loops (`loop`)]: loops.html#loop"}, {"sha": "0596e476d5f6c14dfb7271a04e5a84f5ab289440", "filename": "src/doc/reference.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -2863,8 +2863,8 @@ assert_eq!(x, y);\n \n ### Unary operator expressions\n \n-Rust defines the following unary operators. They are all written as prefix operators,\n-before the expression they apply to.\n+Rust defines the following unary operators. With the exception of `?`, they are\n+all written as prefix operators, before the expression they apply to.\n \n * `-`\n   : Negation. Signed integer types and floating-point types support negation. It\n@@ -2893,6 +2893,10 @@ before the expression they apply to.\n     If the `&` or `&mut` operators are applied to an rvalue, a\n     temporary value is created; the lifetime of this temporary value\n     is defined by [syntactic rules](#temporary-lifetimes).\n+* `?`\n+  : Propagating errors if applied to `Err(_)` and unwrapping if\n+    applied to `Ok(_)`. Only works on the `Result<T, E>` type,\n+    and written in postfix notation.\n \n ### Binary operator expressions\n "}, {"sha": "853f81ceaa9b8746ddf9a9df54414671d7e07c4c", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -53,7 +53,7 @@ pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),\n // now hopefully.\n #[no_mangle]\n pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n-    return abort();\n+    abort();\n \n     #[cfg(unix)]\n     unsafe fn abort() -> ! {"}, {"sha": "22c7d14be29d205dbe172c7a96ca322605d7df6d", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -33,25 +33,25 @@ struct LoopScope {\n }\n \n pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           blk: &hir::Block) -> CFG {\n+                           body: &hir::Expr) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n \n     // `fn_exit` is target of return exprs, which lies somewhere\n-    // outside input `blk`. (Distinguishing `fn_exit` and `block_exit`\n+    // outside input `body`. (Distinguishing `fn_exit` and `body_exit`\n     // also resolves chicken-and-egg problem that arises if you try to\n-    // have return exprs jump to `block_exit` during construction.)\n+    // have return exprs jump to `body_exit` during construction.)\n     let fn_exit = graph.add_node(CFGNodeData::Exit);\n-    let block_exit;\n+    let body_exit;\n \n     let mut cfg_builder = CFGBuilder {\n         graph: graph,\n         fn_exit: fn_exit,\n         tcx: tcx,\n         loop_scopes: Vec::new()\n     };\n-    block_exit = cfg_builder.block(blk, entry);\n-    cfg_builder.add_contained_edge(block_exit, fn_exit);\n+    body_exit = cfg_builder.expr(body, entry);\n+    cfg_builder.add_contained_edge(body_exit, fn_exit);\n     let CFGBuilder {graph, ..} = cfg_builder;\n     CFG {graph: graph,\n          entry: entry,"}, {"sha": "43434b884c8d4b7e55b96c41c678565362ad7ef4", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -59,8 +59,8 @@ pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n     pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         blk: &hir::Block) -> CFG {\n-        construct::construct(tcx, blk)\n+                         body: &hir::Expr) -> CFG {\n+        construct::construct(tcx, body)\n     }\n \n     pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {"}, {"sha": "351feaba0346ab7e47a28146a074c0623f614528", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -103,11 +103,11 @@ pub enum DepNode<D: Clone + Debug> {\n     // nodes. Often we map multiple tables to the same node if there\n     // is no point in distinguishing them (e.g., both the type and\n     // predicates for an item wind up in `ItemSignature`).\n-    ImplOrTraitItems(D),\n+    AssociatedItems(D),\n     ItemSignature(D),\n     FieldTy(D),\n     SizedConstraint(D),\n-    ImplOrTraitItemDefIds(D),\n+    AssociatedItemDefIds(D),\n     InherentImpls(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n@@ -153,10 +153,10 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransCrateItem,\n             TypeckItemType,\n             TypeckItemBody,\n-            ImplOrTraitItems,\n+            AssociatedItems,\n             ItemSignature,\n             FieldTy,\n-            ImplOrTraitItemDefIds,\n+            AssociatedItemDefIds,\n             InherentImpls,\n             TraitImpls,\n             ReprHints,\n@@ -219,11 +219,11 @@ impl<D: Clone + Debug> DepNode<D> {\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),\n             TransCrateItem(ref d) => op(d).map(TransCrateItem),\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n-            ImplOrTraitItems(ref d) => op(d).map(ImplOrTraitItems),\n+            AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n             FieldTy(ref d) => op(d).map(FieldTy),\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n-            ImplOrTraitItemDefIds(ref d) => op(d).map(ImplOrTraitItemDefIds),\n+            AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),"}, {"sha": "ec09877ae121cdfeba73bc638f2ecf3492afee51", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -672,120 +672,6 @@ extern \"C\" {\n ```\n \"##,\n \n-E0269: r##\"\n-A returned value was expected but not all control paths return one.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0269\n-fn abracada_FAIL() -> String {\n-    \"this won't work\".to_string();\n-    // error: not all control paths return a value\n-}\n-```\n-\n-In the previous code, the function is supposed to return a `String`, however,\n-the code returns nothing (because of the ';'). Another erroneous code would be:\n-\n-```compile_fail\n-fn abracada_FAIL(b: bool) -> u32 {\n-    if b {\n-        0\n-    } else {\n-        \"a\" // It fails because an `u32` was expected and something else is\n-            // returned.\n-    }\n-}\n-```\n-\n-It is advisable to find out what the unhandled cases are and check for them,\n-returning an appropriate value or panicking if necessary. Check if you need\n-to remove a semicolon from the last expression, like in the first erroneous\n-code example.\n-\"##,\n-\n-E0270: r##\"\n-Rust lets you define functions which are known to never return, i.e. are\n-'diverging', by marking its return type as `!`.\n-\n-For example, the following functions never return:\n-\n-```no_run\n-fn foo() -> ! {\n-    loop {}\n-}\n-\n-fn bar() -> ! {\n-    foo() // foo() is diverging, so this will diverge too\n-}\n-\n-fn baz() -> ! {\n-    panic!(); // this macro internally expands to a call to a diverging function\n-}\n-```\n-\n-Such functions can be used in a place where a value is expected without\n-returning a value of that type, for instance:\n-\n-```no_run\n-fn foo() -> ! {\n-    loop {}\n-}\n-\n-let x = 3;\n-\n-let y = match x {\n-    1 => 1,\n-    2 => 4,\n-    _ => foo() // diverging function called here\n-};\n-\n-println!(\"{}\", y)\n-```\n-\n-If the third arm of the match block is reached, since `foo()` doesn't ever\n-return control to the match block, it is fine to use it in a place where an\n-integer was expected. The `match` block will never finish executing, and any\n-point where `y` (like the print statement) is needed will not be reached.\n-\n-However, if we had a diverging function that actually does finish execution:\n-\n-```ignore\n-fn foo() -> ! {\n-    loop {break;}\n-}\n-```\n-\n-Then we would have an unknown value for `y` in the following code:\n-\n-```no_run\n-fn foo() -> ! {\n-    loop {}\n-}\n-\n-let x = 3;\n-\n-let y = match x {\n-    1 => 1,\n-    2 => 4,\n-    _ => foo()\n-};\n-\n-println!(\"{}\", y);\n-```\n-\n-In the previous example, the print statement was never reached when the\n-wildcard match arm was hit, so we were okay with `foo()` not returning an\n-integer that we could set to `y`. But in this example, `foo()` actually does\n-return control, so the print statement will be executed with an uninitialized\n-value.\n-\n-Obviously we cannot have functions which are allowed to be used in such\n-positions and yet can return control. So, if you are defining a function that\n-returns `!`, make sure that there is no way for it to actually finish\n-executing.\n-\"##,\n-\n E0271: r##\"\n This is because of a type mismatch between the associated type of some\n trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)"}, {"sha": "9932e5fe6862305cd366b9fd34f38ced1191f38d", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -138,7 +138,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_where_predicate(&mut self, predicate: &'v WherePredicate) {\n         walk_where_predicate(self, predicate)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, id: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Expr, s: Span, id: NodeId) {\n         walk_fn(self, fk, fd, b, s, id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n@@ -635,13 +635,13 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n                                    function_kind: FnKind<'v>,\n                                    function_declaration: &'v FnDecl,\n-                                   function_body: &'v Block,\n+                                   function_body: &'v Expr,\n                                    _span: Span,\n                                    id: NodeId) {\n     visitor.visit_id(id);\n     walk_fn_decl(visitor, function_declaration);\n     walk_fn_kind(visitor, function_kind);\n-    visitor.visit_block(function_body)\n+    visitor.visit_expr(function_body)\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n@@ -925,7 +925,7 @@ impl<'v> Visitor<'v> for IdRangeComputingVisitor {\n /// Computes the id range for a single fn body, ignoring nested items.\n pub fn compute_id_range_for_fn_body(fk: FnKind,\n                                     decl: &FnDecl,\n-                                    body: &Block,\n+                                    body: &Expr,\n                                     sp: Span,\n                                     id: NodeId)\n                                     -> IdRange {"}, {"sha": "b985298e47cc2f8ed0d7ccecab551a0edae0e99f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -595,12 +595,13 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemConst(self.lower_ty(t), self.lower_expr(e))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n+                let body = self.lower_block(body);\n                 hir::ItemFn(self.lower_fn_decl(decl),\n                             self.lower_unsafety(unsafety),\n                             self.lower_constness(constness),\n                             abi,\n                             self.lower_generics(generics),\n-                            self.lower_block(body))\n+                            self.expr_block(body, ThinVec::new()))\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n@@ -665,7 +666,10 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     TraitItemKind::Method(ref sig, ref body) => {\n                         hir::MethodTraitItem(this.lower_method_sig(sig),\n-                                             body.as_ref().map(|x| this.lower_block(x)))\n+                                             body.as_ref().map(|x| {\n+                            let body = this.lower_block(x);\n+                            this.expr_block(body, ThinVec::new())\n+                        }))\n                     }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n                         hir::TypeTraitItem(this.lower_bounds(bounds),\n@@ -691,8 +695,9 @@ impl<'a> LoweringContext<'a> {\n                         hir::ImplItemKind::Const(this.lower_ty(ty), this.lower_expr(expr))\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n+                        let body = this.lower_block(body);\n                         hir::ImplItemKind::Method(this.lower_method_sig(sig),\n-                                                  this.lower_block(body))\n+                                                  this.expr_block(body, ThinVec::new()))\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n                     ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n@@ -1110,7 +1115,7 @@ impl<'a> LoweringContext<'a> {\n                     self.with_parent_def(e.id, |this| {\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         this.lower_block(body),\n+                                         this.lower_expr(body),\n                                          fn_decl_span)\n                     })\n                 }"}, {"sha": "325a90ea91e0ec25b18cd60d50f9c3fa4a548a66", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -21,11 +21,9 @@\n //! nested within a uniquely determined `FnLike`), and users can ask\n //! for the `Code` associated with a particular NodeId.\n \n-pub use self::Code::*;\n-\n use hir as ast;\n use hir::map::{self, Node};\n-use hir::{Block, FnDecl};\n+use hir::{Expr, FnDecl};\n use hir::intravisit::FnKind;\n use syntax::abi;\n use syntax::ast::{Attribute, Name, NodeId};\n@@ -50,7 +48,7 @@ pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n /// Components shared by fn-like things (fn items, methods, closures).\n pub struct FnParts<'a> {\n     pub decl: &'a FnDecl,\n-    pub body: &'a Block,\n+    pub body: &'a Expr,\n     pub kind: FnKind<'a>,\n     pub span: Span,\n     pub id:   NodeId,\n@@ -77,29 +75,32 @@ impl MaybeFnLike for ast::Expr {\n     }\n }\n \n-/// Carries either an FnLikeNode or a Block, as these are the two\n+/// Carries either an FnLikeNode or a Expr, as these are the two\n /// constructs that correspond to \"code\" (as in, something from which\n /// we can construct a control-flow graph).\n #[derive(Copy, Clone)]\n pub enum Code<'a> {\n-    FnLikeCode(FnLikeNode<'a>),\n-    BlockCode(&'a Block),\n+    FnLike(FnLikeNode<'a>),\n+    Expr(&'a Expr),\n }\n \n impl<'a> Code<'a> {\n     pub fn id(&self) -> NodeId {\n         match *self {\n-            FnLikeCode(node) => node.id(),\n-            BlockCode(block) => block.id,\n+            Code::FnLike(node) => node.id(),\n+            Code::Expr(block) => block.id,\n         }\n     }\n \n-    /// Attempts to construct a Code from presumed FnLike or Block node input.\n-    pub fn from_node(node: Node) -> Option<Code> {\n-        if let map::NodeBlock(block) = node {\n-            Some(BlockCode(block))\n-        } else {\n-            FnLikeNode::from_node(node).map(|fn_like| FnLikeCode(fn_like))\n+    /// Attempts to construct a Code from presumed FnLike or Expr node input.\n+    pub fn from_node(map: &map::Map<'a>, id: NodeId) -> Option<Code<'a>> {\n+        match map.get(id) {\n+            map::NodeBlock(_) => {\n+                //  Use the parent, hopefully an expression node.\n+                Code::from_node(map, map.get_parent_node(id))\n+            }\n+            map::NodeExpr(expr) => Some(Code::Expr(expr)),\n+            node => FnLikeNode::from_node(node).map(Code::FnLike)\n         }\n     }\n }\n@@ -114,7 +115,7 @@ struct ItemFnParts<'a> {\n     abi:      abi::Abi,\n     vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n-    body:     &'a Block,\n+    body:     &'a Expr,\n     id:       NodeId,\n     span:     Span,\n     attrs:    &'a [Attribute],\n@@ -124,14 +125,14 @@ struct ItemFnParts<'a> {\n /// for use when implementing FnLikeNode operations.\n struct ClosureParts<'a> {\n     decl: &'a FnDecl,\n-    body: &'a Block,\n+    body: &'a Expr,\n     id: NodeId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: &'a Block, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(d: &'a FnDecl, b: &'a Expr, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n         ClosureParts {\n             decl: d,\n             body: b,\n@@ -171,9 +172,9 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n-    pub fn body(self) -> &'a Block {\n+    pub fn body(self) -> &'a Expr {\n         self.handle(|i: ItemFnParts<'a>|  &*i.body,\n-                    |_, _, _: &'a ast::MethodSig, _, body: &'a ast::Block, _, _|  body,\n+                    |_, _, _: &'a ast::MethodSig, _, body: &'a ast::Expr, _, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n@@ -214,7 +215,7 @@ impl<'a> FnLikeNode<'a> {\n                   Name,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n-                  &'a ast::Block,\n+                  &'a ast::Expr,\n                   Span,\n                   &'a [Attribute])\n                   -> A,"}, {"sha": "e23a721da08a693371e891c9c841d23818a3ae00", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -211,7 +211,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Block, s: Span, id: NodeId) {\n+                b: &'ast Expr, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }"}, {"sha": "6b5b8101a146ca57fd92184ab0300bd74030e905", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -904,7 +904,7 @@ pub enum Expr_ {\n     /// A closure (for example, `move |a, b, c| {a + b + c}`).\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    ExprClosure(CaptureClause, P<FnDecl>, P<Block>, Span),\n+    ExprClosure(CaptureClause, P<FnDecl>, P<Expr>, Span),\n     /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n@@ -1035,7 +1035,7 @@ pub enum TraitItem_ {\n     /// must contain a value)\n     ConstTraitItem(P<Ty>, Option<P<Expr>>),\n     /// A method with an optional body\n-    MethodTraitItem(MethodSig, Option<P<Block>>),\n+    MethodTraitItem(MethodSig, Option<P<Expr>>),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n@@ -1060,7 +1060,7 @@ pub enum ImplItemKind {\n     /// of the expression\n     Const(P<Ty>, P<Expr>),\n     /// A method implementation with the given signature and body\n-    Method(MethodSig, P<Block>),\n+    Method(MethodSig, P<Expr>),\n     /// An associated type\n     Type(P<Ty>),\n }\n@@ -1501,7 +1501,7 @@ pub enum Item_ {\n     /// A `const` item\n     ItemConst(P<Ty>, P<Expr>),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Block>),\n+    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Expr>),\n     /// A module\n     ItemMod(Mod),\n     /// An external module"}, {"sha": "2c4ffb853c1f3af157a3d5e4d57e45a3e80191f0", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -713,7 +713,9 @@ impl<'a> State<'a> {\n                               typarams,\n                               &item.vis)?;\n                 word(&mut self.s, \" \")?;\n-                self.print_block_with_attrs(&body, &item.attrs)?;\n+                self.end()?; // need to close a box\n+                self.end()?; // need to close a box\n+                self.print_expr(&body)?;\n             }\n             hir::ItemMod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n@@ -1002,7 +1004,9 @@ impl<'a> State<'a> {\n                 self.print_method_sig(ti.name, sig, &hir::Inherited)?;\n                 if let Some(ref body) = *body {\n                     self.nbsp()?;\n-                    self.print_block_with_attrs(body, &ti.attrs)?;\n+                    self.end()?; // need to close a box\n+                    self.end()?; // need to close a box\n+                    self.print_expr(body)?;\n                 } else {\n                     word(&mut self.s, \";\")?;\n                 }\n@@ -1034,7 +1038,9 @@ impl<'a> State<'a> {\n                 self.head(\"\")?;\n                 self.print_method_sig(ii.name, sig, &ii.vis)?;\n                 self.nbsp()?;\n-                self.print_block_with_attrs(body, &ii.attrs)?;\n+                self.end()?; // need to close a box\n+                self.end()?; // need to close a box\n+                self.print_expr(body)?;\n             }\n             hir::ImplItemKind::Type(ref ty) => {\n                 self.print_associated_type(ii.name, None, Some(ty))?;\n@@ -1402,26 +1408,10 @@ impl<'a> State<'a> {\n                 self.print_fn_block_args(&decl)?;\n                 space(&mut self.s)?;\n \n-                let default_return = match decl.output {\n-                    hir::DefaultReturn(..) => true,\n-                    _ => false,\n-                };\n+                // this is a bare expression\n+                self.print_expr(body)?;\n+                self.end()?; // need to close a box\n \n-                if !default_return || !body.stmts.is_empty() || body.expr.is_none() {\n-                    self.print_block_unclosed(&body)?;\n-                } else {\n-                    // we extract the block, so as not to create another set of boxes\n-                    match body.expr.as_ref().unwrap().node {\n-                        hir::ExprBlock(ref blk) => {\n-                            self.print_block_unclosed(&blk)?;\n-                        }\n-                        _ => {\n-                            // this is a bare expression\n-                            self.print_expr(body.expr.as_ref().map(|e| &**e).unwrap())?;\n-                            self.end()?; // need to close a box\n-                        }\n-                    }\n-                }\n                 // a box will be closed by print_expr, but we didn't want an overall\n                 // wrapper so we closed the corresponding opening. so create an\n                 // empty box to satisfy the close."}, {"sha": "f44f82860077e21498288a59f723c02962d33ad0", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -838,7 +838,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'v>, decl: &'v hir::FnDecl,\n-                body: &'v hir::Block, span: Span, id: ast::NodeId) {\n+                body: &'v hir::Expr, span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n@@ -994,10 +994,10 @@ impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n     }\n \n     fn visit_fn(&mut self, fk: ast_visit::FnKind, decl: &ast::FnDecl,\n-                body: &ast::Block, span: Span, id: ast::NodeId) {\n-        run_lints!(self, check_fn, early_passes, fk, decl, body, span, id);\n-        ast_visit::walk_fn(self, fk, decl, body, span);\n-        run_lints!(self, check_fn_post, early_passes, fk, decl, body, span, id);\n+                span: Span, id: ast::NodeId) {\n+        run_lints!(self, check_fn, early_passes, fk, decl, span, id);\n+        ast_visit::walk_fn(self, fk, decl, span);\n+        run_lints!(self, check_fn_post, early_passes, fk, decl, span, id);\n     }\n \n     fn visit_variant_data(&mut self,"}, {"sha": "6f7102229f8d6150ecef22853b687cfe78b26216", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -151,9 +151,9 @@ pub trait LateLintPass: LintPass {\n     fn check_ty(&mut self, _: &LateContext, _: &hir::Ty) { }\n     fn check_generics(&mut self, _: &LateContext, _: &hir::Generics) { }\n     fn check_fn(&mut self, _: &LateContext,\n-        _: FnKind, _: &hir::FnDecl, _: &hir::Block, _: Span, _: ast::NodeId) { }\n+        _: FnKind, _: &hir::FnDecl, _: &hir::Expr, _: Span, _: ast::NodeId) { }\n     fn check_fn_post(&mut self, _: &LateContext,\n-        _: FnKind, _: &hir::FnDecl, _: &hir::Block, _: Span, _: ast::NodeId) { }\n+        _: FnKind, _: &hir::FnDecl, _: &hir::Expr, _: Span, _: ast::NodeId) { }\n     fn check_trait_item(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n     fn check_trait_item_post(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n     fn check_impl_item(&mut self, _: &LateContext, _: &hir::ImplItem) { }\n@@ -200,9 +200,9 @@ pub trait EarlyLintPass: LintPass {\n     fn check_ty(&mut self, _: &EarlyContext, _: &ast::Ty) { }\n     fn check_generics(&mut self, _: &EarlyContext, _: &ast::Generics) { }\n     fn check_fn(&mut self, _: &EarlyContext,\n-        _: ast_visit::FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n+        _: ast_visit::FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) { }\n     fn check_fn_post(&mut self, _: &EarlyContext,\n-        _: ast_visit::FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n+        _: ast_visit::FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) { }\n     fn check_trait_item(&mut self, _: &EarlyContext, _: &ast::TraitItem) { }\n     fn check_trait_item_post(&mut self, _: &EarlyContext, _: &ast::TraitItem) { }\n     fn check_impl_item(&mut self, _: &EarlyContext, _: &ast::ImplItem) { }"}, {"sha": "a1f226ab11d80df8b4bd9f3b9815b62828429550", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -147,7 +147,7 @@ pub trait CrateStore<'tcx> {\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n \n     // impl info\n-    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>;\n+    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>;\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>;\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity;\n@@ -157,8 +157,8 @@ pub trait CrateStore<'tcx> {\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId>;\n-    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<ty::ImplOrTraitItem<'tcx>>;\n+    fn associated_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> Option<ty::AssociatedItem>;\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n@@ -311,8 +311,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     }\n \n     // impl info\n-    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>\n-        { bug!(\"impl_or_trait_items\") }\n+    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>\n+        { bug!(\"associated_items\") }\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity { bug!(\"impl_polarity\") }\n@@ -323,8 +323,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId> { bug!(\"trait_of_item\") }\n-    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<ty::ImplOrTraitItem<'tcx>> { bug!(\"impl_or_trait_item\") }\n+    fn associated_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> Option<ty::AssociatedItem> { bug!(\"associated_item\") }\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }"}, {"sha": "1ec3d0db8e0aa3a4a57efcc6371a48a70d1c4b75", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n //                                ^^^^^^^^^^^^^ only needed for pretty printing\n-    pub fn propagate(&mut self, cfg: &cfg::CFG, blk: &hir::Block) {\n+    pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Expr) {\n         //! Performs the data flow analysis.\n \n         if self.bits_per_id == 0 {\n@@ -524,17 +524,17 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n         debug!(\"{}\", {\n             let mut v = Vec::new();\n-            self.pretty_print_to(box &mut v, blk).unwrap();\n+            self.pretty_print_to(box &mut v, body).unwrap();\n             String::from_utf8(v).unwrap()\n         });\n     }\n \n     fn pretty_print_to<'b>(&self, wr: Box<io::Write + 'b>,\n-                           blk: &hir::Block) -> io::Result<()> {\n+                           body: &hir::Expr) -> io::Result<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self, None);\n         ps.cbox(pprust::indent_unit)?;\n         ps.ibox(0)?;\n-        ps.print_block(blk)?;\n+        ps.print_expr(body)?;\n         pp::eof(&mut ps.s)\n     }\n }"}, {"sha": "23fc5911259dc920685fa5b65364afe2d62678ef", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -471,11 +471,10 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n         if let Some(impl_list) =\n                 self.tcx.inherent_impls.borrow().get(&self.tcx.map.local_def_id(id)) {\n-            for impl_did in impl_list.iter() {\n-                for &item_did in &impl_items[impl_did][..] {\n+            for &impl_did in impl_list.iter() {\n+                for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n                     if let Some(item_node_id) = self.tcx.map.as_local_node_id(item_did) {\n                         if self.live_symbols.contains(&item_node_id) {\n                             return true;\n@@ -567,7 +566,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"method\");\n                 }\n-                intravisit::walk_block(self, body)\n+                intravisit::walk_expr(self, body)\n             }\n             hir::ImplItemKind::Type(..) => {}\n         }\n@@ -576,11 +575,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     // Overwrite so that we don't warn the trait item itself.\n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         match trait_item.node {\n-            hir::ConstTraitItem(_, Some(ref expr)) => {\n-                intravisit::walk_expr(self, expr)\n-            }\n+            hir::ConstTraitItem(_, Some(ref body))|\n             hir::MethodTraitItem(_, Some(ref body)) => {\n-                intravisit::walk_block(self, body)\n+                intravisit::walk_expr(self, body)\n             }\n             hir::ConstTraitItem(_, None) |\n             hir::MethodTraitItem(_, None) |"}, {"sha": "5634e2012c971209c9d0afbce238f3ddcb6cfaa3", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self, fn_kind: FnKind<'v>, fn_decl: &'v hir::FnDecl,\n-                block: &'v hir::Block, span: Span, id: ast::NodeId) {\n+                block: &'v hir::Expr, span: Span, id: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             FnKind::ItemFn(_, _, unsafety, ..) =>"}, {"sha": "231da576f2b99d8f821a1d2aeed6480fac018a05", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -227,8 +227,8 @@ impl OverloadedCallType {\n     }\n \n     fn from_method_id(tcx: TyCtxt, method_id: DefId) -> OverloadedCallType {\n-        let method = tcx.impl_or_trait_item(method_id);\n-        OverloadedCallType::from_trait_id(tcx, method.container().id())\n+        let method = tcx.associated_item(method_id);\n+        OverloadedCallType::from_trait_id(tcx, method.container.id())\n     }\n }\n \n@@ -290,14 +290,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     pub fn walk_fn(&mut self,\n                    decl: &hir::FnDecl,\n-                   body: &hir::Block) {\n+                   body: &hir::Expr) {\n         self.walk_arg_patterns(decl, body);\n-        self.walk_block(body);\n+        self.consume_expr(body);\n     }\n \n     fn walk_arg_patterns(&mut self,\n                          decl: &hir::FnDecl,\n-                         body: &hir::Block) {\n+                         body: &hir::Expr) {\n         for arg in &decl.inputs {\n             let arg_ty = return_if_err!(self.mc.infcx.node_ty(arg.pat.id));\n "}, {"sha": "7dbf9aa74144d4a4254aba531afbde1ca8ab4cb1", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, id: ast::NodeId) {\n+                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"intrinsicck: closure outside of function\")\n         }"}, {"sha": "a654d65bc67961af65392e9a8abf56b26f921555", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 22, "deletions": 71, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -123,10 +123,9 @@ use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n-use syntax::codemap::original_sp;\n use syntax::parse::token::keywords;\n use syntax::ptr::P;\n-use syntax_pos::{BytePos, Span};\n+use syntax_pos::Span;\n \n use hir::Expr;\n use hir;\n@@ -187,7 +186,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt) -> String {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, id: NodeId) {\n+                b: &'v hir::Expr, s: Span, id: NodeId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n     fn visit_local(&mut self, l: &hir::Local) { visit_local(self, l); }\n@@ -352,9 +351,9 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, n: NodeId) {\n-        check_fn(self, fk, fd, b, s, n);\n+    fn visit_fn(&mut self, _: FnKind<'v>, _: &'v hir::FnDecl,\n+                _: &'v hir::Expr, _: Span, _: NodeId) {\n+        // do not check contents of nested fns\n     }\n     fn visit_local(&mut self, l: &hir::Local) {\n         check_local(self, l);\n@@ -370,7 +369,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n fn visit_fn(ir: &mut IrMaps,\n             fk: FnKind,\n             decl: &hir::FnDecl,\n-            body: &hir::Block,\n+            body: &hir::Expr,\n             sp: Span,\n             id: ast::NodeId) {\n     debug!(\"visit_fn\");\n@@ -405,10 +404,10 @@ fn visit_fn(ir: &mut IrMaps,\n \n     // compute liveness\n     let mut lsets = Liveness::new(&mut fn_maps, specials);\n-    let entry_ln = lsets.compute(decl, body);\n+    let entry_ln = lsets.compute(body);\n \n     // check for various error conditions\n-    lsets.visit_block(body);\n+    lsets.visit_expr(body);\n     lsets.check_ret(id, sp, fk, entry_ln, body);\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n@@ -821,17 +820,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     // _______________________________________________________________________\n \n-    fn compute(&mut self, decl: &hir::FnDecl, body: &hir::Block) -> LiveNode {\n+    fn compute(&mut self, body: &hir::Expr) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug!(\"compute: using id for block, {}\", block_to_string(body));\n+        debug!(\"compute: using id for body, {}\", expr_to_string(body));\n \n         let exit_ln = self.s.exit_ln;\n-        let entry_ln: LiveNode =\n-            self.with_loop_nodes(body.id, exit_ln, exit_ln,\n-              |this| this.propagate_through_fn_block(decl, body));\n+        let entry_ln: LiveNode = self.with_loop_nodes(body.id, exit_ln, exit_ln, |this| {\n+            // the fallthrough exit is only for those cases where we do not\n+            // explicitly return:\n+            let s = this.s;\n+            this.init_from_succ(s.fallthrough_ln, s.exit_ln);\n+            this.acc(s.fallthrough_ln, s.clean_exit_var, ACC_READ);\n+\n+            this.propagate_through_expr(body, s.fallthrough_ln)\n+        });\n \n         // hack to skip the loop unless debug! is enabled:\n         debug!(\"^^ liveness computation results for body {} (entry={:?})\",\n@@ -846,20 +851,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(&mut self, _: &hir::FnDecl, blk: &hir::Block)\n-                                  -> LiveNode {\n-        // the fallthrough exit is only for those cases where we do not\n-        // explicitly return:\n-        let s = self.s;\n-        self.init_from_succ(s.fallthrough_ln, s.exit_ln);\n-        if blk.expr.is_none() {\n-            self.acc(s.fallthrough_ln, s.no_ret_var, ACC_READ)\n-        }\n-        self.acc(s.fallthrough_ln, s.clean_exit_var, ACC_READ);\n-\n-        self.propagate_through_block(blk, s.fallthrough_ln)\n-    }\n-\n     fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode)\n                                -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n@@ -1448,15 +1439,6 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n     }\n }\n \n-fn check_fn(_v: &Liveness,\n-            _fk: FnKind,\n-            _decl: &hir::FnDecl,\n-            _body: &hir::Block,\n-            _sp: Span,\n-            _id: NodeId) {\n-    // do not check contents of nested fns\n-}\n-\n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::Binder<Ty<'tcx>> {\n         let fn_ty = self.ir.tcx.tables().node_id_to_type(id);\n@@ -1472,7 +1454,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  sp: Span,\n                  _fk: FnKind,\n                  entry_ln: LiveNode,\n-                 body: &hir::Block)\n+                 body: &hir::Expr)\n     {\n         // within the fn body, late-bound regions are liberated\n         // and must outlive the *call-site* of the function.\n@@ -1481,13 +1463,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 self.ir.tcx.region_maps.call_site_extent(id, body.id),\n                 &self.fn_ret(id));\n \n-        if fn_ret.is_never() {\n-            // FIXME(durka) this rejects code like `fn foo(x: !) -> ! { x }`\n-            if self.live_on_entry(entry_ln, self.s.clean_exit_var).is_some() {\n-                span_err!(self.ir.tcx.sess, sp, E0270,\n-                          \"computation may converge in a function marked as diverging\");\n-            }\n-        } else if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n+        if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n             let t_ret_subst = fn_ret.subst(self.ir.tcx, &param_env.free_substs);\n             let is_nil = self.ir.tcx.infer_ctxt(None, Some(param_env),\n@@ -1498,32 +1474,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             // for nil return types, it is ok to not return a value expl.\n             if !is_nil {\n-                let ends_with_stmt = match body.expr {\n-                    None if !body.stmts.is_empty() =>\n-                        match body.stmts.last().unwrap().node {\n-                            hir::StmtSemi(ref e, _) => {\n-                                self.ir.tcx.tables().expr_ty(&e) == fn_ret\n-                            },\n-                            _ => false\n-                        },\n-                    _ => false\n-                };\n-                let mut err = struct_span_err!(self.ir.tcx.sess,\n-                                               sp,\n-                                               E0269,\n-                                               \"not all control paths return a value\");\n-                if ends_with_stmt {\n-                    let last_stmt = body.stmts.last().unwrap();\n-                    let original_span = original_sp(self.ir.tcx.sess.codemap(),\n-                                                    last_stmt.span, sp);\n-                    let span_semicolon = Span {\n-                        lo: original_span.hi - BytePos(1),\n-                        hi: original_span.hi,\n-                        expn_id: original_span.expn_id\n-                    };\n-                    err.span_help(span_semicolon, \"consider removing this semicolon:\");\n-                }\n-                err.emit();\n+                span_bug!(sp, \"not all control paths return a value\");\n             }\n         }\n     }"}, {"sha": "7868e700f2701c0c03cb1e2ed6005d83aa4dba12", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -248,9 +248,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemFn(.., ref search_block) => {\n+                    hir::ItemFn(.., ref body) => {\n                         if item_might_be_inlined(&item) {\n-                            intravisit::walk_block(self, &search_block)\n+                            self.visit_expr(body);\n                         }\n                     }\n \n@@ -278,11 +278,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::MethodTraitItem(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    hir::ConstTraitItem(_, Some(ref expr)) => {\n-                        self.visit_expr(&expr);\n-                    }\n+                    hir::ConstTraitItem(_, Some(ref body)) |\n                     hir::MethodTraitItem(_, Some(ref body)) => {\n-                        intravisit::walk_block(self, body);\n+                        self.visit_expr(body);\n                     }\n                     hir::TypeTraitItem(..) => {}\n                 }\n@@ -295,7 +293,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Method(ref sig, ref body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n-                            intravisit::walk_block(self, body)\n+                            self.visit_expr(body)\n                         }\n                     }\n                     hir::ImplItemKind::Type(_) => {}"}, {"sha": "34a6a547d9440fb84a391ff851152b6fb3602e61", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -490,12 +490,7 @@ impl RegionMaps {\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n-        let expr_extent = self.node_extent(expr_id);\n-        // For some reason, the expr's scope itself is skipped here.\n-        let mut id = match scope_map[expr_extent.0 as usize].into_option() {\n-            Some(i) => i,\n-            _ => return None\n-        };\n+        let mut id = self.node_extent(expr_id);\n \n         while let Some(p) = scope_map[id.0 as usize].into_option() {\n             match code_extents[p.0 as usize] {\n@@ -1086,7 +1081,7 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &hir::Item) {\n fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               kind: FnKind,\n               decl: &hir::FnDecl,\n-              body: &hir::Block,\n+              body: &hir::Expr,\n               sp: Span,\n               id: ast::NodeId) {\n     debug!(\"region::resolve_fn(id={:?}, \\\n@@ -1128,7 +1123,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n         parent: fn_decl_scope,\n         var_parent: fn_decl_scope\n     };\n-    visitor.visit_block(body);\n+    visitor.visit_expr(body);\n \n     // Restore context we had at the start.\n     visitor.cx = outer_cx;\n@@ -1191,7 +1186,7 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, n: NodeId) {\n+                b: &'v Expr, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n     }\n     fn visit_arm(&mut self, a: &Arm) {"}, {"sha": "292d9592ceb0cf0bc60a978e49d95244397760f8", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, fn_id: ast::NodeId) {\n+                b: &'v hir::Expr, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_early_late(fn_id,decl, generics, |this| {\n@@ -403,7 +403,7 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n+fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n     struct GatherLabels<'a> {\n         sess: &'a Session,\n         scope: Scope<'a>,\n@@ -415,7 +415,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n-    gather.visit_block(b);\n+    gather.visit_expr(b);\n     return;\n \n     impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n@@ -493,7 +493,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn add_scope_and_walk_fn<'b>(&mut self,\n                                  fk: FnKind,\n                                  fd: &hir::FnDecl,\n-                                 fb: &'b hir::Block,\n+                                 fb: &'b hir::Expr,\n                                  _span: Span,\n                                  fn_id: ast::NodeId) {\n \n@@ -516,7 +516,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         extract_labels(self, fb);\n \n         self.with(FnScope { fn_id: fn_id, body_id: fb.id, s: self.scope },\n-                  |_old_scope, this| this.visit_block(fb))\n+                  |_old_scope, this| this.visit_expr(fb))\n     }\n \n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where"}, {"sha": "d79833998d6c8ec442ae048f4dccb1bb2eef5b48", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -529,14 +529,11 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // items.\n         hir::ItemImpl(.., Some(ref t), _, ref impl_items) => {\n             let trait_did = tcx.expect_def(t.ref_id).def_id();\n-            let trait_items = tcx.trait_items(trait_did);\n-\n             for impl_item in impl_items {\n-                let item = trait_items.iter().find(|item| {\n-                    item.name() == impl_item.name\n-                }).unwrap();\n+                let item = tcx.associated_items(trait_did)\n+                    .find(|item| item.name == impl_item.name).unwrap();\n                 if warn_about_defns {\n-                    maybe_do_stability_check(tcx, item.def_id(), impl_item.span, cb);\n+                    maybe_do_stability_check(tcx, item.def_id, impl_item.span, cb);\n                 }\n             }\n         }\n@@ -685,15 +682,8 @@ fn is_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) -> bool {\n }\n \n fn is_staged_api<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> bool {\n-    match tcx.trait_item_of_item(id) {\n-        Some(trait_method_id) if trait_method_id != id => {\n-            is_staged_api(tcx, trait_method_id)\n-        }\n-        _ => {\n-            *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n-                || tcx.sess.cstore.is_staged_api(id.krate))\n-        }\n-    }\n+    *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n+        || tcx.sess.cstore.is_staged_api(id.krate))\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {"}, {"sha": "7e70fdb92e68b6ce1d9a476819a91822eac3226e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -663,25 +663,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                          in the supertrait listing\"\n                 }\n \n-                ObjectSafetyViolation::Method(method,\n+                ObjectSafetyViolation::Method(name,\n                                               MethodViolationCode::StaticMethod) => {\n-                    buf = format!(\"method `{}` has no receiver\",\n-                                  method.name);\n+                    buf = format!(\"method `{}` has no receiver\", name);\n                     &buf\n                 }\n \n-                ObjectSafetyViolation::Method(method,\n+                ObjectSafetyViolation::Method(name,\n                                               MethodViolationCode::ReferencesSelf) => {\n                     buf = format!(\"method `{}` references the `Self` type \\\n                                        in its arguments or return type\",\n-                                  method.name);\n+                                  name);\n                     &buf\n                 }\n \n-                ObjectSafetyViolation::Method(method,\n+                ObjectSafetyViolation::Method(name,\n                                               MethodViolationCode::Generic) => {\n-                    buf = format!(\"method `{}` has generic type parameters\",\n-                                  method.name);\n+                    buf = format!(\"method `{}` has generic type parameters\", name);\n                     &buf\n                 }\n             };"}, {"sha": "36405df6325af31618be834348c5ac2909512ad6", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -578,18 +578,14 @@ pub fn get_vtable_methods<'a, 'tcx>(\n     supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n         tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n \n-        let trait_item_def_ids = tcx.impl_or_trait_items(trait_ref.def_id());\n-        let trait_methods = (0..trait_item_def_ids.len()).filter_map(move |i| {\n-            match tcx.impl_or_trait_item(trait_item_def_ids[i]) {\n-                ty::MethodTraitItem(m) => Some(m),\n-                _ => None\n-            }\n-        });\n+        let trait_methods = tcx.associated_items(trait_ref.def_id())\n+            .filter(|item| item.kind == ty::AssociatedKind::Method);\n \n         // Now list each method's DefId and Substs (for within its trait).\n         // If the method can never be called from this object, produce None.\n         trait_methods.map(move |trait_method| {\n             debug!(\"get_vtable_methods: trait_method={:?}\", trait_method);\n+            let def_id = trait_method.def_id;\n \n             // Some methods cannot be called on an object; skip those.\n             if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n@@ -599,21 +595,21 @@ pub fn get_vtable_methods<'a, 'tcx>(\n \n             // the method may have some early-bound lifetimes, add\n             // regions for those\n-            let substs = Substs::for_item(tcx, trait_method.def_id,\n-                                            |_, _| tcx.mk_region(ty::ReErased),\n-                                            |def, _| trait_ref.substs().type_for_def(def));\n+            let substs = Substs::for_item(tcx, def_id,\n+                                          |_, _| tcx.mk_region(ty::ReErased),\n+                                          |def, _| trait_ref.substs().type_for_def(def));\n \n             // It's possible that the method relies on where clauses that\n             // do not hold for this particular set of type parameters.\n             // Note that this method could then never be called, so we\n             // do not want to try and trans it, in that case (see #23435).\n-            let predicates = trait_method.predicates.instantiate_own(tcx, substs);\n+            let predicates = tcx.lookup_predicates(def_id).instantiate_own(tcx, substs);\n             if !normalize_and_test_predicates(tcx, predicates.predicates) {\n                 debug!(\"get_vtable_methods: predicates do not hold\");\n                 return None;\n             }\n \n-            Some((trait_method.def_id, substs))\n+            Some((def_id, substs))\n         })\n     })\n }"}, {"sha": "c783bd561bb1a7bd73042397359218cb2424fe6f", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -22,11 +22,10 @@ use super::elaborate_predicates;\n use hir::def_id::DefId;\n use traits;\n use ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n-use std::rc::Rc;\n use syntax::ast;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum ObjectSafetyViolation<'tcx> {\n+pub enum ObjectSafetyViolation {\n     /// Self : Sized declared on the trait\n     SizedSelf,\n \n@@ -35,7 +34,7 @@ pub enum ObjectSafetyViolation<'tcx> {\n     SupertraitSelf,\n \n     /// Method has something illegal\n-    Method(Rc<ty::Method<'tcx>>, MethodViolationCode),\n+    Method(ast::Name, MethodViolationCode),\n }\n \n /// Reasons a method might not be object-safe.\n@@ -77,7 +76,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// because `object_safety_violations` can't be used during\n     /// type collection.\n     pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n-                                            -> Vec<ObjectSafetyViolation<'tcx>>\n+                                            -> Vec<ObjectSafetyViolation>\n     {\n         let mut violations = vec![];\n \n@@ -93,29 +92,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn object_safety_violations(self, trait_def_id: DefId)\n-                                    -> Vec<ObjectSafetyViolation<'tcx>>\n+                                    -> Vec<ObjectSafetyViolation>\n     {\n         traits::supertrait_def_ids(self, trait_def_id)\n             .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n             .collect()\n     }\n \n     fn object_safety_violations_for_trait(self, trait_def_id: DefId)\n-                                          -> Vec<ObjectSafetyViolation<'tcx>>\n+                                          -> Vec<ObjectSafetyViolation>\n     {\n         // Check methods for violations.\n-        let mut violations: Vec<_> =\n-            self.trait_items(trait_def_id).iter()\n+        let mut violations: Vec<_> = self.associated_items(trait_def_id)\n+            .filter(|item| item.kind == ty::AssociatedKind::Method)\n             .filter_map(|item| {\n-                match *item {\n-                    ty::MethodTraitItem(ref m) => {\n-                        self.object_safety_violation_for_method(trait_def_id, &m)\n-                            .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n-                    }\n-                    _ => None,\n-                }\n-            })\n-            .collect();\n+                self.object_safety_violation_for_method(trait_def_id, &item)\n+                    .map(|code| ObjectSafetyViolation::Method(item.name, code))\n+            }).collect();\n \n         // Check the trait itself.\n         if self.trait_has_sized_self(trait_def_id) {\n@@ -198,7 +191,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns `Some(_)` if this method makes the containing trait not object safe.\n     fn object_safety_violation_for_method(self,\n                                           trait_def_id: DefId,\n-                                          method: &ty::Method<'gcx>)\n+                                          method: &ty::AssociatedItem)\n                                           -> Option<MethodViolationCode>\n     {\n         // Any method that has a `Self : Sized` requisite is otherwise\n@@ -216,7 +209,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// otherwise ensure that they cannot be used when `Self=Trait`.\n     pub fn is_vtable_safe_method(self,\n                                  trait_def_id: DefId,\n-                                 method: &ty::Method<'gcx>)\n+                                 method: &ty::AssociatedItem)\n                                  -> bool\n     {\n         // Any method that has a `Self : Sized` requisite can't be called.\n@@ -233,26 +226,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `Self:Sized`.\n     fn virtual_call_violation_for_method(self,\n                                          trait_def_id: DefId,\n-                                         method: &ty::Method<'tcx>)\n+                                         method: &ty::AssociatedItem)\n                                          -> Option<MethodViolationCode>\n     {\n         // The method's first parameter must be something that derefs (or\n         // autorefs) to `&self`. For now, we only accept `self`, `&self`\n         // and `Box<Self>`.\n-        match method.explicit_self {\n-            ty::ExplicitSelfCategory::Static => {\n-                return Some(MethodViolationCode::StaticMethod);\n-            }\n-\n-            ty::ExplicitSelfCategory::ByValue |\n-            ty::ExplicitSelfCategory::ByReference(..) |\n-            ty::ExplicitSelfCategory::ByBox => {\n-            }\n+        if !method.method_has_self_argument {\n+            return Some(MethodViolationCode::StaticMethod);\n         }\n \n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n-        let ref sig = method.fty.sig;\n+        let ref sig = self.lookup_item_type(method.def_id).ty.fn_sig();\n         for &input_ty in &sig.0.inputs[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);\n@@ -263,7 +249,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if !method.generics.types.is_empty() {\n+        if !self.lookup_generics(method.def_id).types.is_empty() {\n             return Some(MethodViolationCode::Generic);\n         }\n "}, {"sha": "b1ab61b09757e69babf1719dd7d415768a097858", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -33,8 +33,6 @@ use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n use util::common::FN_OUTPUT_NAME;\n \n-use std::rc::Rc;\n-\n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n@@ -945,7 +943,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                         // an error when we confirm the candidate\n                         // (which will ultimately lead to `normalize_to_error`\n                         // being invoked).\n-                        node_item.item.ty.is_some()\n+                        node_item.item.has_value\n                     } else {\n                         node_item.item.defaultness.is_default()\n                     };\n@@ -1305,7 +1303,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n \n     match assoc_ty {\n         Some(node_item) => {\n-            let ty = node_item.item.ty.unwrap_or_else(|| {\n+            let ty = if !node_item.item.has_value {\n                 // This means that the impl is missing a definition for the\n                 // associated type. This error will be reported by the type\n                 // checker method `check_impl_items_against_trait`, so here we\n@@ -1314,7 +1312,9 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n                        node_item.item.name,\n                        obligation.predicate.trait_ref);\n                 tcx.types.err\n-            });\n+            } else {\n+                tcx.lookup_item_type(node_item.item.def_id).ty\n+            };\n             let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n             Progress {\n                 ty: ty.subst(tcx, substs),\n@@ -1339,27 +1339,25 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'gcx, 'tcx>,\n     impl_def_id: DefId,\n     assoc_ty_name: ast::Name)\n-    -> Option<specialization_graph::NodeItem<Rc<ty::AssociatedType<'tcx>>>>\n+    -> Option<specialization_graph::NodeItem<ty::AssociatedItem>>\n {\n     let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n \n     if selcx.projection_mode() == Reveal::ExactMatch {\n         let impl_node = specialization_graph::Node::Impl(impl_def_id);\n         for item in impl_node.items(selcx.tcx()) {\n-            if let ty::TypeTraitItem(assoc_ty) = item {\n-                if assoc_ty.name == assoc_ty_name {\n-                    return Some(specialization_graph::NodeItem {\n-                        node: specialization_graph::Node::Impl(impl_def_id),\n-                        item: assoc_ty,\n-                    });\n-                }\n+            if item.kind == ty::AssociatedKind::Type && item.name == assoc_ty_name {\n+                return Some(specialization_graph::NodeItem {\n+                    node: specialization_graph::Node::Impl(impl_def_id),\n+                    item: item,\n+                });\n             }\n         }\n         None\n     } else {\n         selcx.tcx().lookup_trait_def(trait_def_id)\n             .ancestors(impl_def_id)\n-            .type_defs(selcx.tcx(), assoc_ty_name)\n+            .defs(selcx.tcx(), assoc_ty_name, ty::AssociatedKind::Type)\n             .next()\n     }\n }"}, {"sha": "91c40a5cc85161872f5a37ff4764676014741e2b", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -120,7 +120,8 @@ pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n     let trait_def = tcx.lookup_trait_def(trait_def_id);\n \n-    match trait_def.ancestors(impl_data.impl_def_id).fn_defs(tcx, name).next() {\n+    let ancestors = trait_def.ancestors(impl_data.impl_def_id);\n+    match ancestors.defs(tcx, name, ty::AssociatedKind::Method).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);"}, {"sha": "5a6809f1fad6829824078529e8d4b106f492645e", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 14, "deletions": 128, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::Rc;\n-\n use super::{OverlapError, specializes};\n \n use hir::def_id::DefId;\n use traits::{self, Reveal};\n-use ty::{self, TyCtxt, ImplOrTraitItem, TraitDef, TypeFoldable};\n+use ty::{self, TyCtxt, TraitDef, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n use syntax::ast::Name;\n use util::nodemap::{DefIdMap, FxHashMap};\n@@ -285,12 +283,10 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> NodeItems<'a, 'gcx> {\n-        NodeItems {\n-            tcx: tcx.global_tcx(),\n-            items: tcx.impl_or_trait_items(self.def_id()),\n-            idx: 0,\n-        }\n+    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+    pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                 -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n+        tcx.associated_items(self.def_id())\n     }\n \n     pub fn def_id(&self) -> DefId {\n@@ -301,28 +297,6 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n }\n \n-/// An iterator over the items defined within a trait or impl.\n-pub struct NodeItems<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    items: Rc<Vec<DefId>>,\n-    idx: usize\n-}\n-\n-impl<'a, 'tcx> Iterator for NodeItems<'a, 'tcx> {\n-    type Item = ImplOrTraitItem<'tcx>;\n-    fn next(&mut self) -> Option<ImplOrTraitItem<'tcx>> {\n-        if self.idx < self.items.len() {\n-            let item_def_id = self.items[self.idx];\n-            let items_table = self.tcx.impl_or_trait_items.borrow();\n-            let item = items_table[&item_def_id].clone();\n-            self.idx += 1;\n-            Some(item)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n pub struct Ancestors<'a, 'tcx: 'a> {\n     trait_def: &'a TraitDef<'tcx>,\n     current_source: Option<Node>,\n@@ -358,104 +332,16 @@ impl<T> NodeItem<T> {\n     }\n }\n \n-pub struct TypeDefs<'a, 'tcx: 'a> {\n-    // generally only invoked once or twice, so the box doesn't hurt\n-    iter: Box<Iterator<Item = NodeItem<Rc<ty::AssociatedType<'tcx>>>> + 'a>,\n-}\n-\n-impl<'a, 'tcx> Iterator for TypeDefs<'a, 'tcx> {\n-    type Item = NodeItem<Rc<ty::AssociatedType<'tcx>>>;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.iter.next()\n-    }\n-}\n-\n-pub struct FnDefs<'a, 'tcx: 'a> {\n-    // generally only invoked once or twice, so the box doesn't hurt\n-    iter: Box<Iterator<Item = NodeItem<Rc<ty::Method<'tcx>>>> + 'a>,\n-}\n-\n-impl<'a, 'tcx> Iterator for FnDefs<'a, 'tcx> {\n-    type Item = NodeItem<Rc<ty::Method<'tcx>>>;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.iter.next()\n-    }\n-}\n-\n-pub struct ConstDefs<'a, 'tcx: 'a> {\n-    // generally only invoked once or twice, so the box doesn't hurt\n-    iter: Box<Iterator<Item = NodeItem<Rc<ty::AssociatedConst<'tcx>>>> + 'a>,\n-}\n-\n-impl<'a, 'tcx> Iterator for ConstDefs<'a, 'tcx> {\n-    type Item = NodeItem<Rc<ty::AssociatedConst<'tcx>>>;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.iter.next()\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> Ancestors<'a, 'tcx> {\n-    /// Search the items from the given ancestors, returning each type definition\n-    /// with the given name.\n-    pub fn type_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> TypeDefs<'a, 'gcx> {\n-        let iter = self.flat_map(move |node| {\n-            node.items(tcx)\n-                .filter_map(move |item| {\n-                    if let ty::TypeTraitItem(assoc_ty) = item {\n-                        if assoc_ty.name == name {\n-                            return Some(NodeItem {\n-                                node: node,\n-                                item: assoc_ty,\n-                            });\n-                        }\n-                    }\n-                    None\n-                })\n-\n-        });\n-        TypeDefs { iter: Box::new(iter) }\n-    }\n-\n-    /// Search the items from the given ancestors, returning each fn definition\n-    /// with the given name.\n-    pub fn fn_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> FnDefs<'a, 'gcx> {\n-        let iter = self.flat_map(move |node| {\n-            node.items(tcx)\n-                .filter_map(move |item| {\n-                    if let ty::MethodTraitItem(method) = item {\n-                        if method.name == name {\n-                            return Some(NodeItem {\n-                                node: node,\n-                                item: method,\n-                            });\n-                        }\n-                    }\n-                    None\n-                })\n-\n-        });\n-        FnDefs { iter: Box::new(iter) }\n-    }\n-\n-    /// Search the items from the given ancestors, returning each const\n-    /// definition with the given name.\n-    pub fn const_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> ConstDefs<'a, 'gcx> {\n-        let iter = self.flat_map(move |node| {\n-            node.items(tcx)\n-                .filter_map(move |item| {\n-                    if let ty::ConstTraitItem(konst) = item {\n-                        if konst.name == name {\n-                            return Some(NodeItem {\n-                                node: node,\n-                                item: konst,\n-                            });\n-                        }\n-                    }\n-                    None\n-                })\n-\n-        });\n-        ConstDefs { iter: Box::new(iter) }\n+    /// Search the items from the given ancestors, returning each definition\n+    /// with the given name and the given kind.\n+    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+    pub fn defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name, kind: ty::AssociatedKind)\n+                -> impl Iterator<Item = NodeItem<ty::AssociatedItem>> + 'a {\n+        self.flat_map(move |node| {\n+            node.items(tcx).filter(move |item| item.kind == kind && item.name == name)\n+                           .map(move |item| NodeItem { node: node, item: item })\n+        })\n     }\n }\n "}, {"sha": "9346bbd30f9ceb2485db154e88e44c162480e732", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -477,8 +477,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let mut entries = 0;\n         // Count number of methods and add them to the total offset.\n         // Skip over associated types and constants.\n-        for trait_item in &self.trait_items(trait_ref.def_id())[..] {\n-            if let ty::MethodTraitItem(_) = *trait_item {\n+        for trait_item in self.associated_items(trait_ref.def_id()) {\n+            if trait_item.kind == ty::AssociatedKind::Method {\n                 entries += 1;\n             }\n         }\n@@ -495,17 +495,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // add them to the total offset.\n         // Skip over associated types and constants.\n         let mut entries = object.vtable_base;\n-        for trait_item in &self.trait_items(object.upcast_trait_ref.def_id())[..] {\n-            if trait_item.def_id() == method_def_id {\n+        for trait_item in self.associated_items(object.upcast_trait_ref.def_id()) {\n+            if trait_item.def_id == method_def_id {\n                 // The item with the ID we were given really ought to be a method.\n-                assert!(match *trait_item {\n-                    ty::MethodTraitItem(_) => true,\n-                    _ => false\n-                });\n-\n+                assert_eq!(trait_item.kind, ty::AssociatedKind::Method);\n                 return entries;\n             }\n-            if let ty::MethodTraitItem(_) = *trait_item {\n+            if trait_item.kind == ty::AssociatedKind::Method {\n                 entries += 1;\n             }\n         }"}, {"sha": "60a48ba580a0deca18da0de083cf263d7792344a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -403,14 +403,10 @@ pub struct GlobalCtxt<'tcx> {\n     pub tables: RefCell<Tables<'tcx>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n-    pub impl_or_trait_items: RefCell<DepTrackingMap<maps::ImplOrTraitItems<'tcx>>>,\n+    pub associated_items: RefCell<DepTrackingMap<maps::AssociatedItems<'tcx>>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    pub impl_or_trait_item_def_ids: RefCell<DepTrackingMap<maps::ImplOrTraitItemDefIds<'tcx>>>,\n-\n-    /// A cache for the trait_items() routine; note that the routine\n-    /// itself pushes the `TraitItems` dependency node.\n-    trait_items_cache: RefCell<DepTrackingMap<maps::TraitItems<'tcx>>>,\n+    pub associated_item_def_ids: RefCell<DepTrackingMap<maps::AssociatedItemDefIds<'tcx>>>,\n \n     pub impl_trait_refs: RefCell<DepTrackingMap<maps::ImplTraitRefs<'tcx>>>,\n     pub trait_defs: RefCell<DepTrackingMap<maps::TraitDefs<'tcx>>>,\n@@ -822,9 +818,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FxHashMap()),\n             tc_cache: RefCell::new(FxHashMap()),\n-            impl_or_trait_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            impl_or_trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            trait_items_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            associated_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            associated_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,\n@@ -1539,15 +1534,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_substs(iter::once(s).chain(t.into_iter().cloned()).map(Kind::from))\n     }\n \n-    pub fn trait_items(self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'gcx>>> {\n-        self.trait_items_cache.memoize(trait_did, || {\n-            let def_ids = self.impl_or_trait_items(trait_did);\n-            Rc::new(def_ids.iter()\n-                           .map(|&def_id| self.impl_or_trait_item(def_id))\n-                           .collect())\n-        })\n-    }\n-\n     /// Obtain the representation annotation for a struct definition.\n     pub fn lookup_repr_hints(self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n         self.repr_hint_cache.memoize(did, || {"}, {"sha": "43abb61e7fcd83ff08943bd24180d8a96e922c21", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -16,7 +16,7 @@ use ty::{self, Ty};\n use std::cell::RefCell;\n use std::marker::PhantomData;\n use std::rc::Rc;\n-use syntax::{attr, ast};\n+use syntax::attr;\n \n macro_rules! dep_map_ty {\n     ($ty_name:ident : $node_name:ident ($key:ty) -> $value:ty) => {\n@@ -32,18 +32,16 @@ macro_rules! dep_map_ty {\n     }\n }\n \n-dep_map_ty! { ImplOrTraitItems: ImplOrTraitItems(DefId) -> ty::ImplOrTraitItem<'tcx> }\n+dep_map_ty! { AssociatedItems: AssociatedItems(DefId) -> ty::AssociatedItem }\n dep_map_ty! { Tcache: ItemSignature(DefId) -> Ty<'tcx> }\n dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n-dep_map_ty! { ImplOrTraitItemDefIds: ImplOrTraitItemDefIds(DefId) -> Rc<Vec<DefId>> }\n+dep_map_ty! { AssociatedItemDefIds: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n-dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n-dep_map_ty! { InlinedClosures: Hir(DefId) -> ast::NodeId }\n dep_map_ty! { Mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>> }"}, {"sha": "1d260fd65feffba808d69a2217b61c51ba28544d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 152, "deletions": 244, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -10,9 +10,8 @@\n \n pub use self::Variance::*;\n pub use self::DtorKind::*;\n-pub use self::ImplOrTraitItemContainer::*;\n+pub use self::AssociatedItemContainer::*;\n pub use self::BorrowKind::*;\n-pub use self::ImplOrTraitItem::*;\n pub use self::IntVarValue::*;\n pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n@@ -135,12 +134,12 @@ impl DtorKind {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum ImplOrTraitItemContainer {\n+pub enum AssociatedItemContainer {\n     TraitContainer(DefId),\n     ImplContainer(DefId),\n }\n \n-impl ImplOrTraitItemContainer {\n+impl AssociatedItemContainer {\n     pub fn id(&self) -> DefId {\n         match *self {\n             TraitContainer(id) => id,\n@@ -183,58 +182,34 @@ impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n     }\n }\n \n-#[derive(Clone)]\n-pub enum ImplOrTraitItem<'tcx> {\n-    ConstTraitItem(Rc<AssociatedConst<'tcx>>),\n-    MethodTraitItem(Rc<Method<'tcx>>),\n-    TypeTraitItem(Rc<AssociatedType<'tcx>>),\n-}\n-\n-impl<'tcx> ImplOrTraitItem<'tcx> {\n-    pub fn def(&self) -> Def {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => Def::AssociatedConst(associated_const.def_id),\n-            MethodTraitItem(ref method) => Def::Method(method.def_id),\n-            TypeTraitItem(ref ty) => Def::AssociatedTy(ty.def_id),\n-        }\n-    }\n-\n-    pub fn def_id(&self) -> DefId {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => associated_const.def_id,\n-            MethodTraitItem(ref method) => method.def_id,\n-            TypeTraitItem(ref associated_type) => associated_type.def_id,\n-        }\n-    }\n-\n-    pub fn name(&self) -> Name {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => associated_const.name,\n-            MethodTraitItem(ref method) => method.name,\n-            TypeTraitItem(ref associated_type) => associated_type.name,\n-        }\n-    }\n+#[derive(Copy, Clone, Debug)]\n+pub struct AssociatedItem {\n+    pub def_id: DefId,\n+    pub name: Name,\n+    pub kind: AssociatedKind,\n+    pub vis: Visibility,\n+    pub defaultness: hir::Defaultness,\n+    pub has_value: bool,\n+    pub container: AssociatedItemContainer,\n \n-    pub fn vis(&self) -> Visibility {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => associated_const.vis,\n-            MethodTraitItem(ref method) => method.vis,\n-            TypeTraitItem(ref associated_type) => associated_type.vis,\n-        }\n-    }\n+    /// Whether this is a method with an explicit self\n+    /// as its first argument, allowing method calls.\n+    pub method_has_self_argument: bool,\n+}\n \n-    pub fn container(&self) -> ImplOrTraitItemContainer {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => associated_const.container,\n-            MethodTraitItem(ref method) => method.container,\n-            TypeTraitItem(ref associated_type) => associated_type.container,\n-        }\n-    }\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n+pub enum AssociatedKind {\n+    Const,\n+    Method,\n+    Type\n+}\n \n-    pub fn as_opt_method(&self) -> Option<Rc<Method<'tcx>>> {\n-        match *self {\n-            MethodTraitItem(ref m) => Some((*m).clone()),\n-            _ => None,\n+impl AssociatedItem {\n+    pub fn def(&self) -> Def {\n+        match self.kind {\n+            AssociatedKind::Const => Def::AssociatedConst(self.def_id),\n+            AssociatedKind::Method => Def::Method(self.def_id),\n+            AssociatedKind::Type => Def::AssociatedTy(self.def_id),\n         }\n     }\n }\n@@ -308,64 +283,6 @@ impl Visibility {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Method<'tcx> {\n-    pub name: Name,\n-    pub generics: &'tcx Generics<'tcx>,\n-    pub predicates: GenericPredicates<'tcx>,\n-    pub fty: &'tcx BareFnTy<'tcx>,\n-    pub explicit_self: ExplicitSelfCategory<'tcx>,\n-    pub vis: Visibility,\n-    pub defaultness: hir::Defaultness,\n-    pub has_body: bool,\n-    pub def_id: DefId,\n-    pub container: ImplOrTraitItemContainer,\n-}\n-\n-impl<'tcx> Method<'tcx> {\n-    pub fn container_id(&self) -> DefId {\n-        match self.container {\n-            TraitContainer(id) => id,\n-            ImplContainer(id) => id,\n-        }\n-    }\n-}\n-\n-impl<'tcx> PartialEq for Method<'tcx> {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool { self.def_id == other.def_id }\n-}\n-\n-impl<'tcx> Eq for Method<'tcx> {}\n-\n-impl<'tcx> Hash for Method<'tcx> {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        self.def_id.hash(s)\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-pub struct AssociatedConst<'tcx> {\n-    pub name: Name,\n-    pub ty: Ty<'tcx>,\n-    pub vis: Visibility,\n-    pub defaultness: hir::Defaultness,\n-    pub def_id: DefId,\n-    pub container: ImplOrTraitItemContainer,\n-    pub has_value: bool\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-pub struct AssociatedType<'tcx> {\n-    pub name: Name,\n-    pub ty: Option<Ty<'tcx>>,\n-    pub vis: Visibility,\n-    pub defaultness: hir::Defaultness,\n-    pub def_id: DefId,\n-    pub container: ImplOrTraitItemContainer,\n-}\n-\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Copy)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n@@ -1288,19 +1205,10 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     hir::ImplItemKind::Method(_, ref body) => {\n-                        let method_def_id = tcx.map.local_def_id(id);\n-                        match tcx.impl_or_trait_item(method_def_id) {\n-                            MethodTraitItem(ref method_ty) => {\n-                                tcx.construct_parameter_environment(\n-                                    impl_item.span,\n-                                    method_ty.def_id,\n-                                    tcx.region_maps.call_site_extent(id, body.id))\n-                            }\n-                            _ => {\n-                                bug!(\"ParameterEnvironment::for_item(): \\\n-                                      got non-method item from impl method?!\")\n-                            }\n-                        }\n+                        tcx.construct_parameter_environment(\n+                            impl_item.span,\n+                            tcx.map.local_def_id(id),\n+                            tcx.region_maps.call_site_extent(id, body.id))\n                     }\n                 }\n             }\n@@ -1319,27 +1227,17 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback\n                         // to the method id).\n-                        let method_def_id = tcx.map.local_def_id(id);\n-                        match tcx.impl_or_trait_item(method_def_id) {\n-                            MethodTraitItem(ref method_ty) => {\n-                                let extent = if let Some(ref body) = *body {\n-                                    // default impl: use call_site extent as free_id_outlive bound.\n-                                    tcx.region_maps.call_site_extent(id, body.id)\n-                                } else {\n-                                    // no default impl: use item extent as free_id_outlive bound.\n-                                    tcx.region_maps.item_extent(id)\n-                                };\n-                                tcx.construct_parameter_environment(\n-                                    trait_item.span,\n-                                    method_ty.def_id,\n-                                    extent)\n-                            }\n-                            _ => {\n-                                bug!(\"ParameterEnvironment::for_item(): \\\n-                                      got non-method item from provided \\\n-                                      method?!\")\n-                            }\n-                        }\n+                        let extent = if let Some(ref body) = *body {\n+                            // default impl: use call_site extent as free_id_outlive bound.\n+                            tcx.region_maps.call_site_extent(id, body.id)\n+                        } else {\n+                            // no default impl: use item extent as free_id_outlive bound.\n+                            tcx.region_maps.item_extent(id)\n+                        };\n+                        tcx.construct_parameter_environment(\n+                            trait_item.span,\n+                            tcx.map.local_def_id(id),\n+                            extent)\n                     }\n                 }\n             }\n@@ -2065,7 +1963,7 @@ impl LvaluePreference {\n }\n \n /// Helper for looking things up in the various maps that are populated during\n-/// typeck::collect (e.g., `tcx.impl_or_trait_items`, `tcx.tcache`, etc).  All of\n+/// typeck::collect (e.g., `tcx.associated_items`, `tcx.tcache`, etc).  All of\n /// these share the pattern that if the id is local, it should have been loaded\n /// into the map by the `typeck::collect` phase.  If the def-id is external,\n /// then we have to go consult the crate loading code (and cache the result for\n@@ -2204,13 +2102,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn provided_trait_methods(self, id: DefId) -> Vec<Rc<Method<'gcx>>> {\n-        self.impl_or_trait_items(id).iter().filter_map(|&def_id| {\n-            match self.impl_or_trait_item(def_id) {\n-                MethodTraitItem(ref m) if m.has_body => Some(m.clone()),\n-                _ => None\n-            }\n-        }).collect()\n+    pub fn provided_trait_methods(self, id: DefId) -> Vec<AssociatedItem> {\n+        self.associated_items(id)\n+            .filter(|item| item.kind == AssociatedKind::Method && item.has_value)\n+            .collect()\n     }\n \n     pub fn trait_impl_polarity(self, id: DefId) -> hir::ImplPolarity {\n@@ -2243,17 +2138,105 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn impl_or_trait_item(self, id: DefId) -> ImplOrTraitItem<'gcx> {\n-        lookup_locally_or_in_crate_store(\n-            \"impl_or_trait_items\", id, &self.impl_or_trait_items,\n-            || self.sess.cstore.impl_or_trait_item(self.global_tcx(), id)\n-                   .expect(\"missing ImplOrTraitItem in metadata\"))\n+    pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n+        self.associated_items.memoize(def_id, || {\n+            if !def_id.is_local() {\n+                return self.sess.cstore.associated_item(self.global_tcx(), def_id)\n+                           .expect(\"missing AssociatedItem in metadata\");\n+            }\n+\n+            let id = self.map.as_local_node_id(def_id).unwrap();\n+            let parent_id = self.map.get_parent(id);\n+            let parent_def_id = self.map.local_def_id(parent_id);\n+            match self.map.get(id) {\n+                ast_map::NodeTraitItem(trait_item) => {\n+                    let (kind, has_self, has_value) = match trait_item.node {\n+                        hir::MethodTraitItem(ref sig, ref body) => {\n+                            (AssociatedKind::Method, sig.decl.get_self().is_some(),\n+                             body.is_some())\n+                        }\n+                        hir::ConstTraitItem(_, ref value) => {\n+                            (AssociatedKind::Const, false, value.is_some())\n+                        }\n+                        hir::TypeTraitItem(_, ref ty) => {\n+                            (AssociatedKind::Type, false, ty.is_some())\n+                        }\n+                    };\n+\n+                    AssociatedItem {\n+                        name: trait_item.name,\n+                        kind: kind,\n+                        vis: Visibility::from_hir(&hir::Inherited, id, self),\n+                        defaultness: hir::Defaultness::Default,\n+                        has_value: has_value,\n+                        def_id: def_id,\n+                        container: TraitContainer(parent_def_id),\n+                        method_has_self_argument: has_self\n+                    }\n+                }\n+                ast_map::NodeImplItem(impl_item) => {\n+                    let (kind, has_self) = match impl_item.node {\n+                        hir::ImplItemKind::Method(ref sig, _) => {\n+                            (AssociatedKind::Method, sig.decl.get_self().is_some())\n+                        }\n+                        hir::ImplItemKind::Const(..) => (AssociatedKind::Const, false),\n+                        hir::ImplItemKind::Type(..) => (AssociatedKind::Type, false)\n+                    };\n+\n+                    // Trait impl items are always public.\n+                    let public = hir::Public;\n+                    let parent_item = self.map.expect_item(parent_id);\n+                    let vis = if let hir::ItemImpl(.., Some(_), _, _) = parent_item.node {\n+                        &public\n+                    } else {\n+                        &impl_item.vis\n+                    };\n+\n+                    AssociatedItem {\n+                        name: impl_item.name,\n+                        kind: kind,\n+                        vis: Visibility::from_hir(vis, id, self),\n+                        defaultness: impl_item.defaultness,\n+                        has_value: true,\n+                        def_id: def_id,\n+                        container: ImplContainer(parent_def_id),\n+                        method_has_self_argument: has_self\n+                    }\n+                }\n+                item => bug!(\"associated_item: {:?} not an associated item\", item)\n+            }\n+        })\n     }\n \n-    pub fn impl_or_trait_items(self, id: DefId) -> Rc<Vec<DefId>> {\n-        lookup_locally_or_in_crate_store(\n-            \"impl_or_trait_items\", id, &self.impl_or_trait_item_def_ids,\n-            || Rc::new(self.sess.cstore.impl_or_trait_items(id)))\n+    pub fn associated_item_def_ids(self, def_id: DefId) -> Rc<Vec<DefId>> {\n+        self.associated_item_def_ids.memoize(def_id, || {\n+            if !def_id.is_local() {\n+                return Rc::new(self.sess.cstore.associated_item_def_ids(def_id));\n+            }\n+\n+            let id = self.map.as_local_node_id(def_id).unwrap();\n+            let item = self.map.expect_item(id);\n+            match item.node {\n+                hir::ItemTrait(.., ref trait_items) => {\n+                    Rc::new(trait_items.iter().map(|trait_item| {\n+                        self.map.local_def_id(trait_item.id)\n+                    }).collect())\n+                }\n+                hir::ItemImpl(.., ref impl_items) => {\n+                    Rc::new(impl_items.iter().map(|impl_item| {\n+                        self.map.local_def_id(impl_item.id)\n+                    }).collect())\n+                }\n+                _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\")\n+            }\n+        })\n+    }\n+\n+    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+    pub fn associated_items(self, def_id: DefId)\n+                            -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n+        let def_ids = self.associated_item_def_ids(def_id);\n+        (0..def_ids.len()).map(move |i| self.associated_item(def_ids[i]))\n     }\n \n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n@@ -2539,31 +2522,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         def.flags.set(def.flags.get() | TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n-    /// Load primitive inherent implementations if necessary\n-    pub fn populate_implementations_for_primitive_if_necessary(self,\n-                                                               primitive_def_id: DefId) {\n-        if primitive_def_id.is_local() {\n-            return\n-        }\n-\n-        // The primitive is not local, hence we are reading this out\n-        // of metadata.\n-        let _ignore = self.dep_graph.in_ignore();\n-\n-        if self.populated_external_primitive_impls.borrow().contains(&primitive_def_id) {\n-            return\n-        }\n-\n-        debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\",\n-               primitive_def_id);\n-\n-        let impl_items = self.sess.cstore.impl_or_trait_items(primitive_def_id);\n-\n-        // Store the implementation info.\n-        self.impl_or_trait_item_def_ids.borrow_mut().insert(primitive_def_id, Rc::new(impl_items));\n-        self.populated_external_primitive_impls.borrow_mut().insert(primitive_def_id);\n-    }\n-\n     /// Populates the type context with all the inherent implementations for\n     /// the given type if necessary.\n     pub fn populate_inherent_implementations_for_type_if_necessary(self,\n@@ -2584,11 +2542,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                type_id);\n \n         let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n-        for &impl_def_id in &inherent_impls {\n-            // Store the implementation info.\n-            let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n-            self.impl_or_trait_item_def_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n-        }\n \n         self.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n         self.populated_external_types.borrow_mut().insert(type_id);\n@@ -2617,23 +2570,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         for impl_def_id in self.sess.cstore.implementations_of_trait(Some(trait_id)) {\n-            let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n \n             // Record the trait->implementation mapping.\n             let parent = self.sess.cstore.impl_parent(impl_def_id).unwrap_or(trait_id);\n             def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n-\n-            // For any methods that use a default implementation, add them to\n-            // the map. This is a bit unfortunate.\n-            for &impl_item_def_id in &impl_items {\n-                // load impl items eagerly for convenience\n-                // FIXME: we may want to load these lazily\n-                self.impl_or_trait_item(impl_item_def_id);\n-            }\n-\n-            // Store the implementation info.\n-            self.impl_or_trait_item_def_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n         }\n \n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n@@ -2679,17 +2620,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.impl_or_trait_item(self.global_tcx(), def_id)\n+            return self.sess.cstore.associated_item(self.global_tcx(), def_id)\n                        .and_then(|item| {\n-                match item.container() {\n+                match item.container {\n                     TraitContainer(_) => None,\n                     ImplContainer(def_id) => Some(def_id),\n                 }\n             });\n         }\n-        match self.impl_or_trait_items.borrow().get(&def_id).cloned() {\n+        match self.associated_items.borrow().get(&def_id).cloned() {\n             Some(trait_item) => {\n-                match trait_item.container() {\n+                match trait_item.container {\n                     TraitContainer(_) => None,\n                     ImplContainer(def_id) => Some(def_id),\n                 }\n@@ -2705,9 +2646,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if def_id.krate != LOCAL_CRATE {\n             return self.sess.cstore.trait_of_item(def_id);\n         }\n-        match self.impl_or_trait_items.borrow().get(&def_id) {\n-            Some(impl_or_trait_item) => {\n-                match impl_or_trait_item.container() {\n+        match self.associated_items.borrow().get(&def_id) {\n+            Some(associated_item) => {\n+                match associated_item.container {\n                     TraitContainer(def_id) => Some(def_id),\n                     ImplContainer(_) => None\n                 }\n@@ -2716,30 +2657,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// If the given def ID describes an item belonging to a trait, (either a\n-    /// default method or an implementation of a trait method), return the ID of\n-    /// the method inside trait definition (this means that if the given def ID\n-    /// is already that of the original trait method, then the return value is\n-    /// the same).\n-    /// Otherwise, return `None`.\n-    pub fn trait_item_of_item(self, def_id: DefId) -> Option<DefId> {\n-        let impl_or_trait_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n-            Some(m) => m.clone(),\n-            None => return None,\n-        };\n-        match impl_or_trait_item.container() {\n-            TraitContainer(_) => Some(impl_or_trait_item.def_id()),\n-            ImplContainer(def_id) => {\n-                self.trait_id_of_impl(def_id).and_then(|trait_did| {\n-                    let name = impl_or_trait_item.name();\n-                    self.trait_items(trait_did).iter()\n-                        .find(|item| item.name() == name)\n-                        .map(|item| item.def_id())\n-                })\n-            }\n-        }\n-    }\n-\n     /// Construct a parameter environment suitable for static contexts or other contexts where there\n     /// are no free type/lifetime parameters in scope.\n     pub fn empty_parameter_environment(self) -> ParameterEnvironment<'tcx> {\n@@ -2856,15 +2773,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// The category of explicit self.\n-#[derive(Clone, Copy, Eq, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n-pub enum ExplicitSelfCategory<'tcx> {\n-    Static,\n-    ByValue,\n-    ByReference(&'tcx Region, hir::Mutability),\n-    ByBox,\n-}\n-\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,"}, {"sha": "01b44ced8e08ec0308e0b3ba0fd88af13a4b1176", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -670,18 +670,6 @@ impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ImplOrTraitItem<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ImplOrTraitItem(\")?;\n-        match *self {\n-            ty::ImplOrTraitItem::MethodTraitItem(ref i) => write!(f, \"{:?}\", i),\n-            ty::ImplOrTraitItem::ConstTraitItem(ref i) => write!(f, \"{:?}\", i),\n-            ty::ImplOrTraitItem::TypeTraitItem(ref i) => write!(f, \"{:?}\", i),\n-        }?;\n-        write!(f, \")\")\n-    }\n-}\n-\n impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"fn\")?;\n@@ -995,20 +983,6 @@ impl fmt::Display for ty::InferTy {\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::ExplicitSelfCategory<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(match *self {\n-            ty::ExplicitSelfCategory::Static => \"static\",\n-            ty::ExplicitSelfCategory::ByValue => \"self\",\n-            ty::ExplicitSelfCategory::ByReference(_, hir::MutMutable) => {\n-                \"&mut self\"\n-            }\n-            ty::ExplicitSelfCategory::ByReference(_, hir::MutImmutable) => \"&self\",\n-            ty::ExplicitSelfCategory::ByBox => \"Box<self>\",\n-        })\n-    }\n-}\n-\n impl fmt::Display for ty::ParamTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.name)"}, {"sha": "5ed628d7dcae5f8be847efa4e5c71043bfd67c3f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -190,7 +190,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      fn_id: ast::NodeId,\n                                      decl: &hir::FnDecl,\n-                                     body: &hir::Block) {\n+                                     body: &hir::Expr) {\n     debug!(\"check_loans(body id={})\", body.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);"}, {"sha": "8f2afa7f808227d1f2eef48a54505112c7c9db01", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -42,7 +42,7 @@ mod move_error;\n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     fn_id: NodeId,\n                                     decl: &hir::FnDecl,\n-                                    body: &hir::Block)\n+                                    body: &hir::Expr)\n                                     -> (Vec<Loan<'tcx>>,\n                                         move_data::MoveData<'tcx>) {\n     let mut glcx = GatherLoanCtxt {"}, {"sha": "836832de5b9c40f52d55daba45721962135764a7", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -58,7 +58,7 @@ pub struct MoveDataParamEnv<'tcx> {\n pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n                     fk: FnKind,\n                     _decl: &hir::FnDecl,\n-                    body: &hir::Block,\n+                    body: &hir::Expr,\n                     _sp: Span,\n                     id: ast::NodeId,\n                     attributes: &[ast::Attribute]) {"}, {"sha": "fb842f70a54a15bc71e68829d326f53704607bd2", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -47,9 +47,7 @@ use syntax_pos::{MultiSpan, Span};\n use errors::DiagnosticBuilder;\n \n use rustc::hir;\n-use rustc::hir::{FnDecl, Block};\n-use rustc::hir::intravisit;\n-use rustc::hir::intravisit::{Visitor, FnKind};\n+use rustc::hir::intravisit::{self, Visitor, FnKind};\n \n pub mod check_loans;\n \n@@ -65,8 +63,8 @@ pub struct LoanDataFlowOperator;\n pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(..) |\n             FnKind::Method(..) => {\n@@ -159,7 +157,7 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n fn borrowck_fn(this: &mut BorrowckCtxt,\n                fk: FnKind,\n                decl: &hir::FnDecl,\n-               body: &hir::Block,\n+               body: &hir::Expr,\n                sp: Span,\n                id: ast::NodeId,\n                attributes: &[ast::Attribute]) {\n@@ -200,7 +198,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                           fk: FnKind,\n                                           decl: &hir::FnDecl,\n                                           cfg: &cfg::CFG,\n-                                          body: &hir::Block,\n+                                          body: &hir::Expr,\n                                           sp: Span,\n                                           id: ast::NodeId)\n                                           -> AnalysisData<'a, 'tcx>"}, {"sha": "32bda5e11620ac2429a3dd22be4257b4dc18adf4", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -656,7 +656,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                cfg: &cfg::CFG,\n                id_range: IdRange,\n                decl: &hir::FnDecl,\n-               body: &hir::Block)\n+               body: &hir::Expr)\n                -> FlowedMoveData<'a, 'tcx> {\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,"}, {"sha": "e0e8a215919217c126c940138e8bf06278c1b85c", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for OuterVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, id: ast::NodeId) {\n+                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"check_match: closure outside of function\")\n         }\n@@ -113,7 +113,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, n: ast::NodeId) {\n+                b: &'v hir::Expr, s: Span, n: ast::NodeId) {\n         intravisit::walk_fn(self, fk, fd, b, s, n);\n \n         for input in &fd.inputs {"}, {"sha": "5f0c94744a1185f78b63246241a8c395fec2d734", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -857,11 +857,10 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               callee => signal!(e, CallOn(callee)),\n           };\n           let (decl, result) = if let Some(fn_like) = lookup_const_fn_by_id(tcx, did) {\n-              (fn_like.decl(), &fn_like.body().expr)\n+              (fn_like.decl(), fn_like.body())\n           } else {\n               signal!(e, NonConstPath)\n           };\n-          let result = result.as_ref().expect(\"const fn has no result expression\");\n           assert_eq!(decl.inputs.len(), args.len());\n \n           let mut call_args = DefIdMap();\n@@ -1091,13 +1090,8 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // when constructing the inference context above.\n         match selection {\n             traits::VtableImpl(ref impl_data) => {\n-                let ac = tcx.impl_or_trait_items(impl_data.impl_def_id)\n-                    .iter().filter_map(|&def_id| {\n-                        match tcx.impl_or_trait_item(def_id) {\n-                            ty::ConstTraitItem(ic) => Some(ic),\n-                            _ => None\n-                        }\n-                    }).find(|ic| ic.name == ti.name);\n+                let ac = tcx.associated_items(impl_data.impl_def_id)\n+                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == ti.name);\n                 match ac {\n                     Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                     None => match ti.node {"}, {"sha": "7e60c40220f84eed8acb55dac747dc42f71be9c6", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -455,8 +455,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             1 => panic!(\"make_input should have provided valid inputs\"),\n             _ => early_error(sopts.error_format, \"multiple input filenames provided\"),\n         }\n-\n-        None\n     }\n \n     fn late_callback(&mut self,"}, {"sha": "ecbf28c1082f989e2e58f19d2065efe38095e6ea", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -701,8 +701,8 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n                                        mut out: W)\n                                        -> io::Result<()> {\n     let cfg = match code {\n-        blocks::BlockCode(block) => cfg::CFG::new(tcx, &block),\n-        blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &fn_like.body()),\n+        blocks::Code::Expr(expr) => cfg::CFG::new(tcx, expr),\n+        blocks::Code::FnLike(fn_like) => cfg::CFG::new(tcx, fn_like.body()),\n     };\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n@@ -717,12 +717,12 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n             let r = dot::render(&lcfg, &mut out);\n             return expand_err_details(r);\n         }\n-        blocks::BlockCode(_) => {\n+        blocks::Code::Expr(_) => {\n             tcx.sess.err(\"--pretty flowgraph with -Z flowgraph-print annotations requires \\\n                           fn-like node id.\");\n             return Ok(());\n         }\n-        blocks::FnLikeCode(fn_like) => {\n+        blocks::Code::FnLike(fn_like) => {\n             let (bccx, analysis_data) =\n                 borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_like.to_fn_parts(), &cfg);\n \n@@ -990,8 +990,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n                 });\n \n-                let code = blocks::Code::from_node(node);\n-                match code {\n+                match blocks::Code::from_node(&tcx.map, nodeid) {\n                     Some(code) => {\n                         let variants = gather_flowgraph_variants(tcx.sess);\n "}, {"sha": "6320a923d690c720004d972187252c76e93729e7", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -29,10 +29,10 @@ pub enum MethodLateContext {\n \n pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n     let def_id = cx.tcx.map.local_def_id(id);\n-    match cx.tcx.impl_or_trait_items.borrow().get(&def_id) {\n+    match cx.tcx.associated_items.borrow().get(&def_id) {\n         None => span_bug!(span, \"missing method descriptor?!\"),\n         Some(item) => {\n-            match item.container() {\n+            match item.container {\n                 ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n                 ty::ImplContainer(cid) => {\n                     match cx.tcx.impl_trait_ref(cid) {\n@@ -250,7 +250,7 @@ impl LateLintPass for NonSnakeCase {\n                 cx: &LateContext,\n                 fk: FnKind,\n                 _: &hir::FnDecl,\n-                _: &hir::Block,\n+                _: &hir::Expr,\n                 span: Span,\n                 id: ast::NodeId) {\n         match fk {"}, {"sha": "c19b3c40f65c09ad40481e33cdc2ad429e32ead0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -222,7 +222,7 @@ impl LateLintPass for UnsafeCode {\n                 cx: &LateContext,\n                 fk: FnKind,\n                 _: &hir::FnDecl,\n-                _: &hir::Block,\n+                _: &hir::Expr,\n                 span: Span,\n                 _: ast::NodeId) {\n         match fk {\n@@ -812,13 +812,13 @@ impl LateLintPass for UnconditionalRecursion {\n                 cx: &LateContext,\n                 fn_kind: FnKind,\n                 _: &hir::FnDecl,\n-                blk: &hir::Block,\n+                blk: &hir::Expr,\n                 sp: Span,\n                 id: ast::NodeId) {\n         let method = match fn_kind {\n             FnKind::ItemFn(..) => None,\n             FnKind::Method(..) => {\n-                cx.tcx.impl_or_trait_item(cx.tcx.map.local_def_id(id)).as_opt_method()\n+                Some(cx.tcx.associated_item(cx.tcx.map.local_def_id(id)))\n             }\n             // closures can't recur, so they don't matter.\n             FnKind::Closure(_) => return,\n@@ -937,7 +937,7 @@ impl LateLintPass for UnconditionalRecursion {\n \n         // Check if the expression `id` performs a call to `method`.\n         fn expr_refers_to_this_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                method: &ty::Method,\n+                                                method: &ty::AssociatedItem,\n                                                 id: ast::NodeId)\n                                                 -> bool {\n             use rustc::ty::adjustment::*;\n@@ -986,14 +986,14 @@ impl LateLintPass for UnconditionalRecursion {\n         // Check if the method call to the method with the ID `callee_id`\n         // and instantiated with `callee_substs` refers to method `method`.\n         fn method_call_refers_to_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                  method: &ty::Method,\n+                                                  method: &ty::AssociatedItem,\n                                                   callee_id: DefId,\n                                                   callee_substs: &Substs<'tcx>,\n                                                   expr_id: ast::NodeId)\n                                                   -> bool {\n-            let callee_item = tcx.impl_or_trait_item(callee_id);\n+            let callee_item = tcx.associated_item(callee_id);\n \n-            match callee_item.container() {\n+            match callee_item.container {\n                 // This is an inherent method, so the `def_id` refers\n                 // directly to the method definition.\n                 ty::ImplContainer(_) => callee_id == method.def_id,\n@@ -1034,7 +1034,7 @@ impl LateLintPass for UnconditionalRecursion {\n                                 let container = ty::ImplContainer(vtable_impl.impl_def_id);\n                                 // It matches if it comes from the same impl,\n                                 // and has the same method name.\n-                                container == method.container && callee_item.name() == method.name\n+                                container == method.container && callee_item.name == method.name\n                             }\n \n                             // There's no way to know if this call is"}, {"sha": "0668d362037dd3450a3f98c37086cde0f35b1eba", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -99,7 +99,7 @@ impl LateLintPass for UnusedMut {\n                 cx: &LateContext,\n                 _: FnKind,\n                 decl: &hir::FnDecl,\n-                _: &hir::Block,\n+                _: &hir::Expr,\n                 _: Span,\n                 _: ast::NodeId) {\n         for a in &decl.inputs {"}, {"sha": "8656bb8bf00360f459f62c26190cc1c531265988", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -136,7 +136,7 @@ fn main() {\n     let mut parts = version_output.split('.');\n     if let (Some(major), Some(minor)) = (parts.next().and_then(|s| s.parse::<u32>().ok()),\n                                          parts.next().and_then(|s| s.parse::<u32>().ok())) {\n-        if major > 3 || (major == 3 && minor >= 8) {\n+        if major > 3 || (major == 3 && minor >= 9) {\n             cmd.arg(\"--link-static\");\n         }\n     }"}, {"sha": "18ce514c9c42d302f4ceaf8c4127c5fa88d6a83a", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -144,7 +144,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId> {\n+    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId> {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n         self.get_crate_data(def_id.krate)\n@@ -182,11 +182,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def_id.krate).get_trait_of_item(def_id.index)\n     }\n \n-    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<ty::ImplOrTraitItem<'tcx>>\n+    fn associated_item<'a>(&self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> Option<ty::AssociatedItem>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_impl_or_trait_item(def.index, tcx)\n+        self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n \n     fn is_const_fn(&self, did: DefId) -> bool\n@@ -427,9 +427,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                 // the logic to do that already exists in `middle`. In order to\n                 // reuse that code, it needs to be able to look up the traits for\n                 // inlined items.\n-                let ty_trait_item = tcx.impl_or_trait_item(def_id).clone();\n+                let ty_trait_item = tcx.associated_item(def_id).clone();\n                 let trait_item_def_id = tcx.map.local_def_id(trait_item.id);\n-                tcx.impl_or_trait_items.borrow_mut()\n+                tcx.associated_items.borrow_mut()\n                    .insert(trait_item_def_id, ty_trait_item);\n             }\n             Some(&InlinedItem::ImplItem(_, ref impl_item)) => {"}, {"sha": "7973cd880fe344d7aa60bececd8c1910369a480e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -36,7 +36,6 @@ use std::borrow::Cow;\n use std::cell::Ref;\n use std::io;\n use std::mem;\n-use std::rc::Rc;\n use std::str;\n use std::u32;\n \n@@ -792,10 +791,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id).mir.map(|mir| mir.decode((self, tcx)))\n     }\n \n-    pub fn get_impl_or_trait_item(&self,\n-                                  id: DefIndex,\n-                                  tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                  -> Option<ty::ImplOrTraitItem<'tcx>> {\n+    pub fn get_associated_item(&self, id: DefIndex) -> Option<ty::AssociatedItem> {\n         let item = self.entry(id);\n         let parent_and_name = || {\n             let def_key = item.def_key.decode(self);\n@@ -806,52 +802,43 @@ impl<'a, 'tcx> CrateMetadata {\n         Some(match item.kind {\n             EntryKind::AssociatedConst(container) => {\n                 let (parent, name) = parent_and_name();\n-                ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n+                ty::AssociatedItem {\n                     name: name,\n-                    ty: item.ty.unwrap().decode((self, tcx)),\n+                    kind: ty::AssociatedKind::Const,\n                     vis: item.visibility,\n                     defaultness: container.defaultness(),\n+                    has_value: container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n-                    has_value: container.has_body(),\n-                }))\n+                    method_has_self_argument: false\n+                }\n             }\n             EntryKind::Method(data) => {\n                 let (parent, name) = parent_and_name();\n-                let ity = item.ty.unwrap().decode((self, tcx));\n-                let fty = match ity.sty {\n-                    ty::TyFnDef(.., fty) => fty,\n-                    _ => {\n-                        bug!(\"the type {:?} of the method {:?} is not a function?\",\n-                             ity,\n-                             name)\n-                    }\n-                };\n-\n                 let data = data.decode(self);\n-                ty::MethodTraitItem(Rc::new(ty::Method {\n+                ty::AssociatedItem {\n                     name: name,\n-                    generics: tcx.lookup_generics(self.local_def_id(id)),\n-                    predicates: item.predicates.unwrap().decode((self, tcx)),\n-                    fty: fty,\n-                    explicit_self: data.explicit_self.decode((self, tcx)),\n+                    kind: ty::AssociatedKind::Method,\n                     vis: item.visibility,\n                     defaultness: data.container.defaultness(),\n-                    has_body: data.container.has_body(),\n+                    has_value: data.container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: data.container.with_def_id(parent),\n-                }))\n+                    method_has_self_argument: data.has_self\n+                }\n             }\n             EntryKind::AssociatedType(container) => {\n                 let (parent, name) = parent_and_name();\n-                ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n+                ty::AssociatedItem {\n                     name: name,\n-                    ty: item.ty.map(|ty| ty.decode((self, tcx))),\n+                    kind: ty::AssociatedKind::Type,\n                     vis: item.visibility,\n                     defaultness: container.defaultness(),\n+                    has_value: container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n-                }))\n+                    method_has_self_argument: false\n+                }\n             }\n             _ => return None,\n         })"}, {"sha": "2379e744c49e14e5971c110cd09141826a4d2870", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -457,19 +457,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n         let ast_item = tcx.map.expect_trait_item(node_id);\n-        let trait_item = tcx.impl_or_trait_item(def_id);\n+        let trait_item = tcx.associated_item(def_id);\n \n-        let container = |has_body| if has_body {\n+        let container = if trait_item.has_value {\n             AssociatedContainer::TraitWithDefault\n         } else {\n             AssociatedContainer::TraitRequired\n         };\n \n-        let kind = match trait_item {\n-            ty::ConstTraitItem(ref associated_const) => {\n-                EntryKind::AssociatedConst(container(associated_const.has_value))\n-            }\n-            ty::MethodTraitItem(ref method_ty) => {\n+        let kind = match trait_item.kind {\n+            ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n+            ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::MethodTraitItem(ref sig, _) = ast_item.node {\n                     FnData {\n                         constness: hir::Constness::NotConst,\n@@ -478,39 +476,44 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 } else {\n                     bug!()\n                 };\n-                let data = MethodData {\n+                EntryKind::Method(self.lazy(&MethodData {\n                     fn_data: fn_data,\n-                    container: container(method_ty.has_body),\n-                    explicit_self: self.lazy(&method_ty.explicit_self),\n-                };\n-                EntryKind::Method(self.lazy(&data))\n+                    container: container,\n+                    has_self: trait_item.method_has_self_argument,\n+                }))\n             }\n-            ty::TypeTraitItem(_) => EntryKind::AssociatedType(container(false)),\n+            ty::AssociatedKind::Type => EntryKind::AssociatedType(container),\n         };\n \n         Entry {\n             kind: kind,\n-            visibility: trait_item.vis().simplify(),\n+            visibility: trait_item.vis.simplify(),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n-            ty: match trait_item {\n-                ty::ConstTraitItem(_) |\n-                ty::MethodTraitItem(_) => Some(self.encode_item_type(def_id)),\n-                ty::TypeTraitItem(ref associated_type) => {\n-                    associated_type.ty.map(|ty| self.lazy(&ty))\n+            ty: match trait_item.kind {\n+                ty::AssociatedKind::Const |\n+                ty::AssociatedKind::Method => {\n+                    Some(self.encode_item_type(def_id))\n+                }\n+                ty::AssociatedKind::Type => {\n+                    if trait_item.has_value {\n+                        Some(self.encode_item_type(def_id))\n+                    } else {\n+                        None\n+                    }\n                 }\n             },\n             inherent_impls: LazySeq::empty(),\n             variances: LazySeq::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: if let ty::ConstTraitItem(_) = trait_item {\n-                let trait_def_id = trait_item.container().id();\n+            ast: if trait_item.kind == ty::AssociatedKind::Const {\n+                let trait_def_id = trait_item.container.id();\n                 Some(self.encode_inlined_item(InlinedItemRef::TraitItem(trait_def_id, ast_item)))\n             } else {\n                 None\n@@ -522,17 +525,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.map.expect_impl_item(node_id);\n-        let impl_item = self.tcx.impl_or_trait_item(def_id);\n-        let impl_def_id = impl_item.container().id();\n+        let impl_item = self.tcx.associated_item(def_id);\n+        let impl_def_id = impl_item.container.id();\n \n-        let container = match ast_item.defaultness {\n+        let container = match impl_item.defaultness {\n             hir::Defaultness::Default => AssociatedContainer::ImplDefault,\n             hir::Defaultness::Final => AssociatedContainer::ImplFinal,\n         };\n \n-        let kind = match impl_item {\n-            ty::ConstTraitItem(_) => EntryKind::AssociatedConst(container),\n-            ty::MethodTraitItem(ref method_ty) => {\n+        let kind = match impl_item.kind {\n+            ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n+            ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n                     FnData {\n                         constness: sig.constness,\n@@ -541,17 +544,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 } else {\n                     bug!()\n                 };\n-                let data = MethodData {\n+                EntryKind::Method(self.lazy(&MethodData {\n                     fn_data: fn_data,\n                     container: container,\n-                    explicit_self: self.lazy(&method_ty.explicit_self),\n-                };\n-                EntryKind::Method(self.lazy(&data))\n+                    has_self: impl_item.method_has_self_argument,\n+                }))\n             }\n-            ty::TypeTraitItem(_) => EntryKind::AssociatedType(container),\n+            ty::AssociatedKind::Type => EntryKind::AssociatedType(container)\n         };\n \n-        let (ast, mir) = if let ty::ConstTraitItem(_) = impl_item {\n+        let (ast, mir) = if impl_item.kind == ty::AssociatedKind::Const {\n             (true, true)\n         } else if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n             let generics = self.tcx.lookup_generics(def_id);\n@@ -565,20 +567,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: kind,\n-            visibility: impl_item.vis().simplify(),\n+            visibility: impl_item.vis.simplify(),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n-            ty: match impl_item {\n-                ty::ConstTraitItem(_) |\n-                ty::MethodTraitItem(_) => Some(self.encode_item_type(def_id)),\n-                ty::TypeTraitItem(ref associated_type) => {\n-                    associated_type.ty.map(|ty| self.lazy(&ty))\n-                }\n-            },\n+            ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n             variances: LazySeq::empty(),\n             generics: Some(self.encode_generics(def_id)),\n@@ -758,7 +754,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n                 hir::ItemImpl(..) |\n                 hir::ItemTrait(..) => {\n-                    self.lazy_seq(tcx.impl_or_trait_items(def_id).iter().map(|&def_id| {\n+                    self.lazy_seq(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n                         assert!(def_id.is_local());\n                         def_id.index\n                     }))\n@@ -880,14 +876,14 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 self.encode_fields(def_id);\n             }\n             hir::ItemImpl(..) => {\n-                for &trait_item_def_id in &self.tcx.impl_or_trait_items(def_id)[..] {\n+                for &trait_item_def_id in &self.tcx.associated_item_def_ids(def_id)[..] {\n                     self.record(trait_item_def_id,\n                                 EncodeContext::encode_info_for_impl_item,\n                                 trait_item_def_id);\n                 }\n             }\n             hir::ItemTrait(..) => {\n-                for &item_def_id in &self.tcx.impl_or_trait_items(def_id)[..] {\n+                for &item_def_id in &self.tcx.associated_item_def_ids(def_id)[..] {\n                     self.record(item_def_id,\n                                 EncodeContext::encode_info_for_trait_item,\n                                 item_def_id);"}, {"sha": "ff2a764571025fb64a650b9692bbbd69c0f5a879", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -245,7 +245,7 @@ pub enum EntryKind<'tcx> {\n     Trait(Lazy<TraitData<'tcx>>),\n     Impl(Lazy<ImplData<'tcx>>),\n     DefaultImpl(Lazy<ImplData<'tcx>>),\n-    Method(Lazy<MethodData<'tcx>>),\n+    Method(Lazy<MethodData>),\n     AssociatedType(AssociatedContainer),\n     AssociatedConst(AssociatedContainer),\n }\n@@ -300,7 +300,7 @@ pub enum AssociatedContainer {\n }\n \n impl AssociatedContainer {\n-    pub fn with_def_id(&self, def_id: DefId) -> ty::ImplOrTraitItemContainer {\n+    pub fn with_def_id(&self, def_id: DefId) -> ty::AssociatedItemContainer {\n         match *self {\n             AssociatedContainer::TraitRequired |\n             AssociatedContainer::TraitWithDefault => ty::TraitContainer(def_id),\n@@ -310,7 +310,7 @@ impl AssociatedContainer {\n         }\n     }\n \n-    pub fn has_body(&self) -> bool {\n+    pub fn has_value(&self) -> bool {\n         match *self {\n             AssociatedContainer::TraitRequired => false,\n \n@@ -332,10 +332,10 @@ impl AssociatedContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct MethodData<'tcx> {\n+pub struct MethodData {\n     pub fn_data: FnData,\n     pub container: AssociatedContainer,\n-    pub explicit_self: Lazy<ty::ExplicitSelfCategory<'tcx>>,\n+    pub has_self: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "902798ec980061fe0bcfdf6276b45b7bbd65dd77", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -156,7 +156,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        fn_id: ast::NodeId,\n                                        arguments: A,\n                                        return_ty: Ty<'gcx>,\n-                                       ast_block: &'gcx hir::Block)\n+                                       ast_body: &'gcx hir::Expr)\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec)\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n@@ -166,7 +166,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let span = tcx.map.span(fn_id);\n     let mut builder = Builder::new(hir, span, arguments.len(), return_ty);\n \n-    let body_id = ast_block.id;\n+    let body_id = ast_body.id;\n     let call_site_extent =\n         tcx.region_maps.lookup_code_extent(\n             CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id });\n@@ -176,7 +176,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let mut block = START_BLOCK;\n     unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n         unpack!(block = builder.in_scope(arg_extent, block, |builder| {\n-            builder.args_and_body(block, return_ty, &arguments, arg_extent, ast_block)\n+            builder.args_and_body(block, &arguments, arg_extent, ast_body)\n         }));\n         // Attribute epilogue to function's closing brace\n         let fn_end = Span { lo: span.hi, ..span };\n@@ -310,10 +310,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n-                     return_ty: Ty<'tcx>,\n                      arguments: &[(Ty<'gcx>, Option<&'gcx hir::Pat>)],\n                      argument_extent: CodeExtent,\n-                     ast_block: &'gcx hir::Block)\n+                     ast_body: &'gcx hir::Expr)\n                      -> BlockAnd<()>\n     {\n         // Allocate locals for the function arguments\n@@ -342,12 +341,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             if let Some(pattern) = pattern {\n                 let pattern = Pattern::from_hir(self.hir.tcx(), pattern);\n-                scope = self.declare_bindings(scope, ast_block.span, &pattern);\n+                scope = self.declare_bindings(scope, ast_body.span, &pattern);\n                 unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n-            self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n+            self.schedule_drop(pattern.as_ref().map_or(ast_body.span, |pat| pat.span),\n                                argument_extent, &lvalue, ty);\n \n         }\n@@ -357,13 +356,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.visibility_scope = visibility_scope;\n         }\n \n-        // FIXME(#32959): temporary hack for the issue at hand\n-        let return_is_unit = return_ty.is_nil();\n-        // start the first basic block and translate the body\n-        unpack!(block = self.ast_block(&Lvalue::Local(RETURN_POINTER),\n-                return_is_unit, block, ast_block));\n-\n-        block.unit()\n+        let body = self.hir.mirror(ast_body);\n+        self.into(&Lvalue::Local(RETURN_POINTER), block, body)\n     }\n \n     fn get_unit_temp(&mut self) -> Lvalue<'tcx> {"}, {"sha": "ecc2d8fe050adc23be4a56ecb8277856e20c3240", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -147,20 +147,14 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         -> (Ty<'tcx>, Literal<'tcx>) {\n         let method_name = token::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n-        for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n-            match *trait_item {\n-                ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n-                    if method.name == method_name {\n-                        let method_ty = self.tcx.lookup_item_type(method.def_id);\n-                        let method_ty = method_ty.ty.subst(self.tcx, substs);\n-                        return (method_ty, Literal::Item {\n-                            def_id: method.def_id,\n-                            substs: substs,\n-                        });\n-                    }\n-                }\n-                ty::ImplOrTraitItem::ConstTraitItem(..) |\n-                ty::ImplOrTraitItem::TypeTraitItem(..) => {}\n+        for item in self.tcx.associated_items(trait_def_id) {\n+            if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n+                let method_ty = self.tcx.lookup_item_type(item.def_id);\n+                let method_ty = method_ty.ty.subst(self.tcx, substs);\n+                return (method_ty, Literal::Item {\n+                    def_id: item.def_id,\n+                    substs: substs,\n+                });\n             }\n         }\n "}, {"sha": "af2f9adfc9a8ccc77aa9c4909ae2f789627db8a1", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: FnKind<'tcx>,\n                 decl: &'tcx hir::FnDecl,\n-                body: &'tcx hir::Block,\n+                body: &'tcx hir::Expr,\n                 span: Span,\n                 id: ast::NodeId) {\n         // fetch the fully liberated fn signature (that is, all bound"}, {"sha": "02a0b3ab28d622026e73f87f912a7e92d0ad4ab6", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn fn_like(&mut self,\n                fk: FnKind,\n                fd: &hir::FnDecl,\n-               b: &hir::Block,\n+               b: &hir::Expr,\n                s: Span,\n                fn_id: ast::NodeId)\n                -> ConstQualif {\n@@ -265,7 +265,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: FnKind<'v>,\n                 fd: &'v hir::FnDecl,\n-                b: &'v hir::Block,\n+                b: &'v hir::Expr,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         self.fn_like(fk, fd, b, s, fn_id);\n@@ -542,7 +542,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                     v.handle_const_fn_call(e, did, node_ty)\n                 }\n                 Some(Def::Method(did)) => {\n-                    match v.tcx.impl_or_trait_item(did).container() {\n+                    match v.tcx.associated_item(did).container {\n                         ty::ImplContainer(_) => {\n                             v.handle_const_fn_call(e, did, node_ty)\n                         }\n@@ -557,7 +557,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         }\n         hir::ExprMethodCall(..) => {\n             let method = v.tcx.tables().method_map[&method_call];\n-            let is_const = match v.tcx.impl_or_trait_item(method.def_id).container() {\n+            let is_const = match v.tcx.associated_item(method.def_id).container {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(e, method.def_id, node_ty),\n                 ty::TraitContainer(_) => false\n             };"}, {"sha": "417987d9664e0f3533e651fa0d9e74b4e92db517", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -164,7 +164,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_fn(&mut self,\n                 fk: hir_visit::FnKind<'v>,\n                 fd: &'v hir::FnDecl,\n-                b: &'v hir::Block,\n+                b: &'v hir::Expr,\n                 s: Span,\n                 id: NodeId) {\n         self.record(\"FnDecl\", Id::None, fd);\n@@ -295,11 +295,10 @@ impl<'v> ast_visit::Visitor for StatCollector<'v> {\n     fn visit_fn(&mut self,\n                 fk: ast_visit::FnKind,\n                 fd: &ast::FnDecl,\n-                b: &ast::Block,\n                 s: Span,\n                 _: NodeId) {\n         self.record(\"FnDecl\", Id::None, fd);\n-        ast_visit::walk_fn(self, fk, fd, b, s)\n+        ast_visit::walk_fn(self, fk, fd, s)\n     }\n \n     fn visit_trait_item(&mut self, ti: &ast::TraitItem) {"}, {"sha": "e58cd893819339636d12191b447389d37fcc862b", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n                 self.with_context(Loop, |v| v.visit_block(&b));\n             }\n             hir::ExprClosure(.., ref b, _) => {\n-                self.with_context(Closure, |v| v.visit_block(&b));\n+                self.with_context(Closure, |v| v.visit_expr(&b));\n             }\n             hir::ExprBreak(_) => self.require_loop(\"break\", e.span),\n             hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),"}, {"sha": "d55ce4c356384618062967a8f35089f8131f343b", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: intravisit::FnKind<'v>,\n                 fd: &'v hir::FnDecl,\n-                b: &'v hir::Block,\n+                b: &'v hir::Expr,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         // FIXME (@jroesch) change this to be an inference context"}, {"sha": "dc7399e228908bee2ad0a3daec05455c8527ffaa", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -399,7 +399,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n     // Checks that a method is in scope.\n     fn check_method(&mut self, span: Span, method_def_id: DefId) {\n-        match self.tcx.impl_or_trait_item(method_def_id).container() {\n+        match self.tcx.associated_item(method_def_id).container {\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n             ty::TraitContainer(trait_def_id) if !self.item_is_accessible(trait_def_id) => {"}, {"sha": "cb8dd7250b496e550fa79eafad23f6fb807f6a4c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -456,7 +456,7 @@ impl<'b> Resolver<'b> {\n                 self.define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n \n                 // If this is a trait, add all the trait item names to the trait info.\n-                let trait_item_def_ids = self.session.cstore.impl_or_trait_items(def_id);\n+                let trait_item_def_ids = self.session.cstore.associated_item_def_ids(def_id);\n                 for trait_item_def_id in trait_item_def_ids {\n                     let trait_item_name = self.session.cstore.def_key(trait_item_def_id)\n                                               .disambiguated_data.data.get_opt_name()"}, {"sha": "664efc27fbb53045326c491938e7f334f4047d46", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -596,21 +596,52 @@ impl<'a> Visitor for Resolver<'a> {\n     fn visit_fn(&mut self,\n                 function_kind: FnKind,\n                 declaration: &FnDecl,\n-                block: &Block,\n                 _: Span,\n                 node_id: NodeId) {\n         let rib_kind = match function_kind {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_generics(generics);\n                 ItemRibKind\n             }\n-            FnKind::Method(_, sig, _) => {\n+            FnKind::Method(_, sig, _, _) => {\n                 self.visit_generics(&sig.generics);\n                 MethodRibKind(!sig.decl.has_self())\n             }\n-            FnKind::Closure => ClosureRibKind(node_id),\n+            FnKind::Closure(_) => ClosureRibKind(node_id),\n         };\n-        self.resolve_function(rib_kind, declaration, block);\n+\n+        // Create a value rib for the function.\n+        self.value_ribs.push(Rib::new(rib_kind));\n+\n+        // Create a label rib for the function.\n+        self.label_ribs.push(Rib::new(rib_kind));\n+\n+        // Add each argument to the rib.\n+        let mut bindings_list = FxHashMap();\n+        for argument in &declaration.inputs {\n+            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n+\n+            self.visit_ty(&argument.ty);\n+\n+            debug!(\"(resolving function) recorded argument\");\n+        }\n+        visit::walk_fn_ret_ty(self, &declaration.output);\n+\n+        // Resolve the function body.\n+        match function_kind {\n+            FnKind::ItemFn(.., body) |\n+            FnKind::Method(.., body) => {\n+                self.visit_block(body);\n+            }\n+            FnKind::Closure(body) => {\n+                self.visit_expr(body);\n+            }\n+        };\n+\n+        debug!(\"(resolving function) leaving function\");\n+\n+        self.label_ribs.pop();\n+        self.value_ribs.pop();\n     }\n }\n \n@@ -1856,36 +1887,6 @@ impl<'a> Resolver<'a> {\n         self.value_ribs.pop();\n     }\n \n-    fn resolve_function(&mut self,\n-                        rib_kind: RibKind<'a>,\n-                        declaration: &FnDecl,\n-                        block: &Block) {\n-        // Create a value rib for the function.\n-        self.value_ribs.push(Rib::new(rib_kind));\n-\n-        // Create a label rib for the function.\n-        self.label_ribs.push(Rib::new(rib_kind));\n-\n-        // Add each argument to the rib.\n-        let mut bindings_list = FxHashMap();\n-        for argument in &declaration.inputs {\n-            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n-\n-            self.visit_ty(&argument.ty);\n-\n-            debug!(\"(resolving function) recorded argument\");\n-        }\n-        visit::walk_fn_ret_ty(self, &declaration.output);\n-\n-        // Resolve the function body.\n-        self.visit_block(block);\n-\n-        debug!(\"(resolving function) leaving function\");\n-\n-        self.label_ribs.pop();\n-        self.value_ribs.pop();\n-    }\n-\n     fn resolve_trait_reference(&mut self,\n                                id: NodeId,\n                                trait_path: &Path,"}, {"sha": "36c6a6760137f20f1c20ffac98461a311406b541", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -32,7 +32,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::map::{Node, NodeItem};\n use rustc::session::Session;\n-use rustc::ty::{self, TyCtxt, ImplOrTraitItem, ImplOrTraitItemContainer};\n+use rustc::ty::{self, TyCtxt, AssociatedItemContainer};\n \n use std::collections::HashSet;\n use std::collections::hash_map::DefaultHasher;\n@@ -402,19 +402,19 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             // with the right name.\n             if !self.span.filter_generated(Some(method_data.span), span) {\n                 let container =\n-                    self.tcx.impl_or_trait_item(self.tcx.map.local_def_id(id)).container();\n+                    self.tcx.associated_item(self.tcx.map.local_def_id(id)).container;\n                 let mut trait_id;\n                 let mut decl_id = None;\n                 match container {\n-                    ImplOrTraitItemContainer::ImplContainer(id) => {\n+                    AssociatedItemContainer::ImplContainer(id) => {\n                         trait_id = self.tcx.trait_id_of_impl(id);\n \n                         match trait_id {\n                             Some(id) => {\n-                                for item in &**self.tcx.trait_items(id) {\n-                                    if let &ImplOrTraitItem::MethodTraitItem(ref m) = item {\n-                                        if m.name == name {\n-                                            decl_id = Some(m.def_id);\n+                                for item in self.tcx.associated_items(id) {\n+                                    if item.kind == ty::AssociatedKind::Method {\n+                                        if item.name == name {\n+                                            decl_id = Some(item.def_id);\n                                             break;\n                                         }\n                                     }\n@@ -429,7 +429,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             }\n                         }\n                     }\n-                    ImplOrTraitItemContainer::TraitContainer(id) => {\n+                    AssociatedItemContainer::TraitContainer(id) => {\n                         trait_id = Some(id);\n                     }\n                 }\n@@ -916,11 +916,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         // Modules or types in the path prefix.\n         match self.tcx.expect_def(id) {\n             Def::Method(did) => {\n-                let ti = self.tcx.impl_or_trait_item(did);\n-                if let ty::MethodTraitItem(m) = ti {\n-                    if m.explicit_self == ty::ExplicitSelfCategory::Static {\n-                        self.write_sub_path_trait_truncated(path);\n-                    }\n+                let ti = self.tcx.associated_item(did);\n+                if ti.kind == ty::AssociatedKind::Method && ti.method_has_self_argument {\n+                    self.write_sub_path_trait_truncated(path);\n                 }\n             }\n             Def::Fn(..) |\n@@ -1414,7 +1412,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                 }\n \n                 // walk the body\n-                self.nest(ex.id, |v| v.visit_block(&body));\n+                self.nest(ex.id, |v| v.visit_expr(body));\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n             ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {"}, {"sha": "fded34d2c856c74bf0e436dc4c51ddb539084c1a", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 15, "deletions": 42, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -313,7 +313,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                            name: ast::Name, span: Span) -> Option<FunctionData> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let (qualname, parent_scope, vis, docs) =\n+        let (qualname, parent_scope, decl_id, vis, docs) =\n           match self.tcx.impl_of_method(self.tcx.map.local_def_id(id)) {\n             Some(impl_id) => match self.tcx.map.get_if_local(impl_id) {\n                 Some(NodeItem(item)) => {\n@@ -323,12 +323,19 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             result.push_str(&rustc::hir::print::ty_to_string(&ty));\n \n                             let trait_id = self.tcx.trait_id_of_impl(impl_id);\n+                            let mut decl_id = None;\n                             if let Some(def_id) = trait_id {\n                                 result.push_str(\" as \");\n                                 result.push_str(&self.tcx.item_path_str(def_id));\n+                                self.tcx.associated_items(def_id)\n+                                    .find(|item| item.name == name)\n+                                    .map(|item| decl_id = Some(item.def_id));\n                             }\n                             result.push_str(\">\");\n-                            (result, trait_id, From::from(&item.vis), docs_for_attrs(&item.attrs))\n+\n+                            (result, trait_id, decl_id,\n+                             From::from(&item.vis),\n+                             docs_for_attrs(&item.attrs))\n                         }\n                         _ => {\n                             span_bug!(span,\n@@ -351,7 +358,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     match self.tcx.map.get_if_local(def_id) {\n                         Some(NodeItem(item)) => {\n                             (format!(\"::{}\", self.tcx.item_path_str(def_id)),\n-                             Some(def_id),\n+                             Some(def_id), None,\n                              From::from(&item.vis),\n                              docs_for_attrs(&item.attrs))\n                         }\n@@ -373,15 +380,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n         let qualname = format!(\"{}::{}\", qualname, name);\n \n-        let def_id = self.tcx.map.local_def_id(id);\n-        let decl_id = self.tcx.trait_item_of_item(def_id).and_then(|new_def_id| {\n-            if new_def_id != def_id {\n-                Some(new_def_id)\n-            } else {\n-                None\n-            }\n-        });\n-\n         let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n         filter!(self.span_utils, sub_span, span, None);\n         Some(FunctionData {\n@@ -473,7 +471,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ExprKind::MethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let method_id = self.tcx.tables().method_map[&method_call].def_id;\n-                let (def_id, decl_id) = match self.tcx.impl_or_trait_item(method_id).container() {\n+                let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n                 };\n@@ -535,21 +533,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let sub_span = self.span_utils.sub_span_for_meth_name(path.span);\n                 filter!(self.span_utils, sub_span, path.span, None);\n                 let def_id = if decl_id.is_local() {\n-                    let ti = self.tcx.impl_or_trait_item(decl_id);\n-                    match ti.container() {\n-                        ty::TraitContainer(def_id) => {\n-                            self.tcx\n-                                .trait_items(def_id)\n-                                .iter()\n-                                .find(|mr| mr.name() == ti.name() && self.trait_method_has_body(mr))\n-                                .map(|mr| mr.def_id())\n-                        }\n-                        ty::ImplContainer(def_id) => {\n-                            Some(*self.tcx.impl_or_trait_items(def_id).iter().find(|&&mr| {\n-                                self.tcx.impl_or_trait_item(mr).name() == ti.name()\n-                            }).unwrap())\n-                        }\n-                    }\n+                    let ti = self.tcx.associated_item(decl_id);\n+                    self.tcx.associated_items(ti.container.id())\n+                        .find(|item| item.name == ti.name && item.has_value)\n+                        .map(|item| item.def_id)\n                 } else {\n                     None\n                 };\n@@ -582,20 +569,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    fn trait_method_has_body(&self, mr: &ty::ImplOrTraitItem) -> bool {\n-        let def_id = mr.def_id();\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-            let trait_item = self.tcx.map.expect_trait_item(node_id);\n-            if let hir::TraitItem_::MethodTraitItem(_, Some(_)) = trait_item.node {\n-                true\n-            } else {\n-                false\n-            }\n-        } else {\n-            false\n-        }\n-    }\n-\n     pub fn get_field_ref_data(&self,\n                               field_ref: &ast::Field,\n                               variant: ty::VariantDef,"}, {"sha": "2c0ba36f3b412fd4c7cbbcf1e1d0bc73936320c7", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -844,17 +844,12 @@ fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n            param_substs);\n \n     if let Some(trait_def_id) = scx.tcx().trait_of_item(fn_def_id) {\n-        match scx.tcx().impl_or_trait_item(fn_def_id) {\n-            ty::MethodTraitItem(ref method) => {\n-                debug!(\" => trait method, attempting to find impl\");\n-                do_static_trait_method_dispatch(scx,\n-                                                method,\n-                                                trait_def_id,\n-                                                fn_substs,\n-                                                param_substs)\n-            }\n-            _ => bug!()\n-        }\n+        debug!(\" => trait method, attempting to find impl\");\n+        do_static_trait_method_dispatch(scx,\n+                                        &scx.tcx().associated_item(fn_def_id),\n+                                        trait_def_id,\n+                                        fn_substs,\n+                                        param_substs)\n     } else {\n         debug!(\" => regular function\");\n         // The function is not part of an impl or trait, no dispatching\n@@ -866,7 +861,7 @@ fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n // Given a trait-method and substitution information, find out the actual\n // implementation of the trait method.\n fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                             trait_method: &ty::Method,\n+                                             trait_method: &ty::AssociatedItem,\n                                              trait_id: DefId,\n                                              callee_substs: &'tcx Substs<'tcx>,\n                                              param_substs: &'tcx Substs<'tcx>)\n@@ -1187,7 +1182,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                         continue;\n                     }\n \n-                    if !method.generics.types.is_empty() {\n+                    if !tcx.lookup_generics(method.def_id).types.is_empty() {\n                         continue;\n                     }\n "}, {"sha": "b8d346b11c13f1500c4c4c2e2063b87b95777e72", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -248,13 +248,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             let vtable = common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref);\n             if let traits::VtableImpl(vtable_impl) = vtable {\n                 let name = ccx.tcx().item_name(instance.def);\n-                let ac = ccx.tcx().impl_or_trait_items(vtable_impl.impl_def_id)\n-                    .iter().filter_map(|&def_id| {\n-                        match ccx.tcx().impl_or_trait_item(def_id) {\n-                            ty::ConstTraitItem(ac) => Some(ac),\n-                            _ => None\n-                        }\n-                    }).find(|ic| ic.name == name);\n+                let ac = ccx.tcx().associated_items(vtable_impl.impl_def_id)\n+                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n                 if let Some(ac) = ac {\n                     instance = Instance::new(ac.def_id, vtable_impl.substs);\n                 }"}, {"sha": "513b4860d5e8748fd30a739b7d45bec9e248fecf", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 101, "deletions": 133, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -107,11 +107,6 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn get_type_parameter_bounds(&self, span: Span, def_id: ast::NodeId)\n                                  -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>;\n \n-    /// Returns true if the trait with id `trait_def_id` defines an\n-    /// associated type with the name `name`.\n-    fn trait_defines_associated_type_named(&self, trait_def_id: DefId, name: ast::Name)\n-                                           -> bool;\n-\n     /// Return an (optional) substitution to convert bound type parameters that\n     /// are in scope into free ones. This function should only return Some\n     /// within a fn body.\n@@ -831,6 +826,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                         Some(self_ty))\n     }\n \n+    fn trait_defines_associated_type_named(&self,\n+                                           trait_def_id: DefId,\n+                                           assoc_name: ast::Name)\n+                                           -> bool\n+    {\n+        self.tcx().associated_items(trait_def_id).any(|item| {\n+            item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n+        })\n+    }\n+\n     fn ast_type_binding_to_poly_projection_predicate(\n         &self,\n         path_id: ast::NodeId,\n@@ -1144,20 +1149,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let mut associated_types = FxHashSet::default();\n         for tr in traits::supertraits(tcx, principal) {\n-            if let Some(trait_id) = tcx.map.as_local_node_id(tr.def_id()) {\n-                use collect::trait_associated_type_names;\n-\n-                associated_types.extend(trait_associated_type_names(tcx, trait_id)\n-                    .map(|name| (tr.def_id(), name)))\n-            } else {\n-                let trait_items = tcx.impl_or_trait_items(tr.def_id());\n-                associated_types.extend(trait_items.iter().filter_map(|&def_id| {\n-                    match tcx.impl_or_trait_item(def_id) {\n-                        ty::TypeTraitItem(ref item) => Some(item.name),\n-                        _ => None\n-                    }\n-                }).map(|name| (tr.def_id(), name)));\n-            }\n+            associated_types.extend(tcx.associated_items(tr.def_id())\n+                .filter(|item| item.kind == ty::AssociatedKind::Type)\n+                .map(|item| (tr.def_id(), item.name)));\n         }\n \n         for projection_bound in &projection_bounds {\n@@ -1260,14 +1254,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         if bounds.len() > 1 {\n             let spans = bounds.iter().map(|b| {\n-                self.tcx().impl_or_trait_items(b.def_id()).iter()\n-                .find(|&&def_id| {\n-                    match self.tcx().impl_or_trait_item(def_id) {\n-                        ty::TypeTraitItem(ref item) => item.name.as_str() == assoc_name,\n-                        _ => false\n-                    }\n+                self.tcx().associated_items(b.def_id()).find(|item| {\n+                    item.kind == ty::AssociatedKind::Type && item.name.as_str() == assoc_name\n                 })\n-                .and_then(|&def_id| self.tcx().map.as_local_node_id(def_id))\n+                .and_then(|item| self.tcx().map.as_local_node_id(item.def_id))\n                 .and_then(|node_id| self.tcx().map.opt_span(node_id))\n             });\n \n@@ -1383,25 +1373,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_did = bound.0.def_id;\n         let ty = self.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n \n-        let item_did = if let Some(trait_id) = tcx.map.as_local_node_id(trait_did) {\n-            // `ty::trait_items` used below requires information generated\n-            // by type collection, which may be in progress at this point.\n-            match tcx.map.expect_item(trait_id).node {\n-                hir::ItemTrait(.., ref trait_items) => {\n-                    let item = trait_items.iter()\n-                                          .find(|i| i.name == assoc_name)\n-                                          .expect(\"missing associated type\");\n-                    tcx.map.local_def_id(item.id)\n-                }\n-                _ => bug!()\n-            }\n-        } else {\n-            let trait_items = tcx.trait_items(trait_did);\n-            let item = trait_items.iter().find(|i| i.name() == assoc_name);\n-            item.expect(\"missing associated type\").def_id()\n-        };\n-\n-        (ty, Def::AssociatedTy(item_did))\n+        let item = tcx.associated_items(trait_did).find(|i| i.name == assoc_name);\n+        (ty, Def::AssociatedTy(item.expect(\"missing associated type\").def_id))\n     }\n \n     fn qpath_to_ty(&self,\n@@ -1694,13 +1667,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyBareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n                 let anon_scope = rscope.anon_type_scope();\n-                let (bare_fn_ty, _) =\n-                    self.ty_of_method_or_bare_fn(bf.unsafety,\n-                                                 bf.abi,\n-                                                 None,\n-                                                 &bf.decl,\n-                                                 anon_scope,\n-                                                 anon_scope);\n+                let bare_fn_ty = self.ty_of_method_or_bare_fn(bf.unsafety,\n+                                                              bf.abi,\n+                                                              None,\n+                                                              &bf.decl,\n+                                                              anon_scope,\n+                                                              anon_scope);\n \n                 // Find any late-bound regions declared in return type that do\n                 // not appear in the arguments. These are not wellformed.\n@@ -1842,7 +1814,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         sig: &hir::MethodSig,\n                         untransformed_self_ty: Ty<'tcx>,\n                         anon_scope: Option<AnonTypeScope>)\n-                        -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory<'tcx>) {\n+                        -> &'tcx ty::BareFnTy<'tcx> {\n         self.ty_of_method_or_bare_fn(sig.unsafety,\n                                      sig.abi,\n                                      Some(untransformed_self_ty),\n@@ -1857,7 +1829,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                          decl: &hir::FnDecl,\n                          anon_scope: Option<AnonTypeScope>)\n                          -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, None, anon_scope).0\n+        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, None, anon_scope)\n     }\n \n     fn ty_of_method_or_bare_fn(&self,\n@@ -1867,7 +1839,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                decl: &hir::FnDecl,\n                                arg_anon_scope: Option<AnonTypeScope>,\n                                ret_anon_scope: Option<AnonTypeScope>)\n-                               -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory<'tcx>)\n+                               -> &'tcx ty::BareFnTy<'tcx>\n     {\n         debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -1880,13 +1852,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // lifetime elision, we can determine it in two ways. First (determined\n         // here), if self is by-reference, then the implied output region is the\n         // region of the self parameter.\n-        let (self_ty, explicit_self_category) = match (opt_untransformed_self_ty, decl.get_self()) {\n+        let (self_ty, explicit_self) = match (opt_untransformed_self_ty, decl.get_self()) {\n             (Some(untransformed_self_ty), Some(explicit_self)) => {\n                 let self_type = self.determine_self_type(&rb, untransformed_self_ty,\n                                                          &explicit_self);\n-                (Some(self_type.0), self_type.1)\n+                (Some(self_type), Some(ExplicitSelf::determine(untransformed_self_ty, self_type)))\n             }\n-            _ => (None, ty::ExplicitSelfCategory::Static),\n+            _ => (None, None),\n         };\n \n         // HACK(eddyb) replace the fake self type in the AST with the actual type.\n@@ -1901,8 +1873,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // Second, if there was exactly one lifetime (either a substitution or a\n         // reference) in the arguments, then any anonymous regions in the output\n         // have that lifetime.\n-        let implied_output_region = match explicit_self_category {\n-            ty::ExplicitSelfCategory::ByReference(region, _) => Ok(*region),\n+        let implied_output_region = match explicit_self {\n+            Some(ExplicitSelf::ByReference(region, _)) => Ok(*region),\n             _ => {\n                 // `pat_to_string` is expensive and\n                 // `find_implied_output_region` only needs its result when\n@@ -1928,103 +1900,38 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"ty_of_method_or_bare_fn: input_tys={:?}\", input_tys);\n         debug!(\"ty_of_method_or_bare_fn: output_ty={:?}\", output_ty);\n \n-        (self.tcx().mk_bare_fn(ty::BareFnTy {\n+        self.tcx().mk_bare_fn(ty::BareFnTy {\n             unsafety: unsafety,\n             abi: abi,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: input_tys,\n                 output: output_ty,\n                 variadic: decl.variadic\n             }),\n-        }), explicit_self_category)\n+        })\n     }\n \n     fn determine_self_type<'a>(&self,\n                                rscope: &RegionScope,\n                                untransformed_self_ty: Ty<'tcx>,\n                                explicit_self: &hir::ExplicitSelf)\n-                               -> (Ty<'tcx>, ty::ExplicitSelfCategory<'tcx>)\n+                               -> Ty<'tcx>\n     {\n-        return match explicit_self.node {\n-            SelfKind::Value(..) => {\n-                (untransformed_self_ty, ty::ExplicitSelfCategory::ByValue)\n-            }\n+        match explicit_self.node {\n+            SelfKind::Value(..) => untransformed_self_ty,\n             SelfKind::Region(ref lifetime, mutability) => {\n                 let region =\n                     self.opt_ast_region_to_region(\n                                              rscope,\n                                              explicit_self.span,\n                                              lifetime);\n-                (self.tcx().mk_ref(region,\n+                self.tcx().mk_ref(region,\n                     ty::TypeAndMut {\n                         ty: untransformed_self_ty,\n                         mutbl: mutability\n-                    }),\n-                 ty::ExplicitSelfCategory::ByReference(region, mutability))\n-            }\n-            SelfKind::Explicit(ref ast_type, _) => {\n-                let explicit_type = self.ast_ty_to_ty(rscope, &ast_type);\n-\n-                // We wish to (for now) categorize an explicit self\n-                // declaration like `self: SomeType` into either `self`,\n-                // `&self`, `&mut self`, or `Box<self>`. We do this here\n-                // by some simple pattern matching. A more precise check\n-                // is done later in `check_method_self_type()`.\n-                //\n-                // Examples:\n-                //\n-                // ```\n-                // impl Foo for &T {\n-                //     // Legal declarations:\n-                //     fn method1(self: &&T); // ExplicitSelfCategory::ByReference\n-                //     fn method2(self: &T); // ExplicitSelfCategory::ByValue\n-                //     fn method3(self: Box<&T>); // ExplicitSelfCategory::ByBox\n-                //\n-                //     // Invalid cases will be caught later by `check_method_self_type`:\n-                //     fn method_err1(self: &mut T); // ExplicitSelfCategory::ByReference\n-                // }\n-                // ```\n-                //\n-                // To do the check we just count the number of \"modifiers\"\n-                // on each type and compare them. If they are the same or\n-                // the impl has more, we call it \"by value\". Otherwise, we\n-                // look at the outermost modifier on the method decl and\n-                // call it by-ref, by-box as appropriate. For method1, for\n-                // example, the impl type has one modifier, but the method\n-                // type has two, so we end up with\n-                // ExplicitSelfCategory::ByReference.\n-\n-                let impl_modifiers = count_modifiers(untransformed_self_ty);\n-                let method_modifiers = count_modifiers(explicit_type);\n-\n-                debug!(\"determine_explicit_self_category(self_info.untransformed_self_ty={:?} \\\n-                       explicit_type={:?} \\\n-                       modifiers=({},{})\",\n-                       untransformed_self_ty,\n-                       explicit_type,\n-                       impl_modifiers,\n-                       method_modifiers);\n-\n-                let category = if impl_modifiers >= method_modifiers {\n-                    ty::ExplicitSelfCategory::ByValue\n-                } else {\n-                    match explicit_type.sty {\n-                        ty::TyRef(r, mt) => ty::ExplicitSelfCategory::ByReference(r, mt.mutbl),\n-                        ty::TyBox(_) => ty::ExplicitSelfCategory::ByBox,\n-                        _ => ty::ExplicitSelfCategory::ByValue,\n-                    }\n-                };\n-\n-                (explicit_type, category)\n-            }\n-        };\n-\n-        fn count_modifiers(ty: Ty) -> usize {\n-            match ty.sty {\n-                ty::TyRef(_, mt) => count_modifiers(mt.ty) + 1,\n-                ty::TyBox(t) => count_modifiers(t) + 1,\n-                _ => 0,\n+                    })\n             }\n+            SelfKind::Explicit(ref ast_type, _) => self.ast_ty_to_ty(rscope, &ast_type)\n         }\n     }\n \n@@ -2334,3 +2241,64 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n         vec\n     }\n }\n+\n+pub enum ExplicitSelf<'tcx> {\n+    ByValue,\n+    ByReference(&'tcx ty::Region, hir::Mutability),\n+    ByBox\n+}\n+\n+impl<'tcx> ExplicitSelf<'tcx> {\n+    /// We wish to (for now) categorize an explicit self\n+    /// declaration like `self: SomeType` into either `self`,\n+    /// `&self`, `&mut self`, or `Box<self>`. We do this here\n+    /// by some simple pattern matching. A more precise check\n+    /// is done later in `check_method_self_type()`.\n+    ///\n+    /// Examples:\n+    ///\n+    /// ```\n+    /// impl Foo for &T {\n+    ///     // Legal declarations:\n+    ///     fn method1(self: &&T); // ExplicitSelf::ByReference\n+    ///     fn method2(self: &T); // ExplicitSelf::ByValue\n+    ///     fn method3(self: Box<&T>); // ExplicitSelf::ByBox\n+    ///\n+    ///     // Invalid cases will be caught later by `check_method_self_type`:\n+    ///     fn method_err1(self: &mut T); // ExplicitSelf::ByReference\n+    /// }\n+    /// ```\n+    ///\n+    /// To do the check we just count the number of \"modifiers\"\n+    /// on each type and compare them. If they are the same or\n+    /// the impl has more, we call it \"by value\". Otherwise, we\n+    /// look at the outermost modifier on the method decl and\n+    /// call it by-ref, by-box as appropriate. For method1, for\n+    /// example, the impl type has one modifier, but the method\n+    /// type has two, so we end up with\n+    /// ExplicitSelf::ByReference.\n+    pub fn determine(untransformed_self_ty: Ty<'tcx>,\n+                     self_arg_ty: Ty<'tcx>)\n+                     -> ExplicitSelf<'tcx> {\n+        fn count_modifiers(ty: Ty) -> usize {\n+            match ty.sty {\n+                ty::TyRef(_, mt) => count_modifiers(mt.ty) + 1,\n+                ty::TyBox(t) => count_modifiers(t) + 1,\n+                _ => 0,\n+            }\n+        }\n+\n+        let impl_modifiers = count_modifiers(untransformed_self_ty);\n+        let method_modifiers = count_modifiers(self_arg_ty);\n+\n+        if impl_modifiers >= method_modifiers {\n+            ExplicitSelf::ByValue\n+        } else {\n+            match self_arg_ty.sty {\n+                ty::TyRef(r, mt) => ExplicitSelf::ByReference(r, mt.mutbl),\n+                ty::TyBox(_) => ExplicitSelf::ByBox,\n+                _ => ExplicitSelf::ByValue,\n+            }\n+        }\n+    }\n+}"}, {"sha": "ca630624cdb3889aafc18b40fce0b4e1b2ccc8af", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n-use check::{FnCtxt, Expectation};\n+use check::{FnCtxt, Expectation, Diverges};\n use util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -360,9 +360,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n         true\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_match(&self,\n                        expr: &'gcx hir::Expr,\n                        discrim: &'gcx hir::Expr,\n@@ -390,14 +388,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             discrim_ty = self.next_ty_var();\n             self.check_expr_has_type(discrim, discrim_ty);\n         };\n+        let discrim_diverges = self.diverges.get();\n+        self.diverges.set(Diverges::Maybe);\n \n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n-        for arm in arms {\n+        let all_arm_pats_diverge: Vec<_> = arms.iter().map(|arm| {\n+            let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n+                self.diverges.set(Diverges::Maybe);\n                 self.check_pat(&p, discrim_ty);\n+                all_pats_diverge &= self.diverges.get();\n             }\n-        }\n+            all_pats_diverge\n+        }).collect();\n \n         // Now typecheck the blocks.\n         //\n@@ -410,6 +414,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // type in that case)\n         let expected = expected.adjust_for_branches(self);\n         let mut result_ty = self.next_diverging_ty_var();\n+        let mut all_arms_diverge = Diverges::WarnedAlways;\n         let coerce_first = match expected {\n             // We don't coerce to `()` so that if the match expression is a\n             // statement it's branches can have any consistent type. That allows\n@@ -422,11 +427,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => result_ty\n         };\n \n-        for (i, arm) in arms.iter().enumerate() {\n+        for (i, (arm, pats_diverge)) in arms.iter().zip(all_arm_pats_diverge).enumerate() {\n             if let Some(ref e) = arm.guard {\n+                self.diverges.set(pats_diverge);\n                 self.check_expr_has_type(e, tcx.types.bool);\n             }\n+\n+            self.diverges.set(pats_diverge);\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n+            all_arms_diverge &= self.diverges.get();\n \n             if result_ty.references_error() || arm_ty.references_error() {\n                 result_ty = tcx.types.err;\n@@ -476,11 +485,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n         }\n \n+        // We won't diverge unless the discriminant or all arms diverge.\n+        self.diverges.set(discrim_diverges | all_arms_diverge);\n+\n         result_ty\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_pat_struct(&self,\n                         pat: &'gcx hir::Pat,\n                         path: &hir::Path,"}, {"sha": "af834f3f84d4775c986801a0325e855adecd4716", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -23,7 +23,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               expr: &hir::Expr,\n                               _capture: hir::CaptureClause,\n                               decl: &'gcx hir::FnDecl,\n-                              body: &'gcx hir::Block,\n+                              body: &'gcx hir::Expr,\n                               expected: Expectation<'tcx>)\n                               -> Ty<'tcx> {\n         debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n@@ -44,7 +44,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                      expr: &hir::Expr,\n                      opt_kind: Option<ty::ClosureKind>,\n                      decl: &'gcx hir::FnDecl,\n-                     body: &'gcx hir::Block,\n+                     body: &'gcx hir::Expr,\n                      expected_sig: Option<ty::FnSig<'tcx>>)\n                      -> Ty<'tcx> {\n         let expr_def_id = self.tcx.map.local_def_id(expr.id);"}, {"sha": "ffde940b3f48a83b1788c2321e0fc69f39beb228", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 98, "deletions": 55, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::hir;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::ty;\n@@ -23,6 +24,7 @@ use syntax_pos::Span;\n use CrateCtxt;\n use super::assoc;\n use super::{Inherited, FnCtxt};\n+use astconv::ExplicitSelf;\n \n /// Checks that a method from an impl conforms to the signature of\n /// the same method as declared in the trait.\n@@ -36,11 +38,11 @@ use super::{Inherited, FnCtxt};\n /// - impl_trait_ref: the TraitRef corresponding to the trait implementation\n \n pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                     impl_m: &ty::Method<'tcx>,\n+                                     impl_m: &ty::AssociatedItem,\n                                      impl_m_span: Span,\n                                      impl_m_body_id: ast::NodeId,\n-                                     trait_m: &ty::Method<'tcx>,\n-                                     impl_trait_ref: &ty::TraitRef<'tcx>,\n+                                     trait_m: &ty::AssociatedItem,\n+                                     impl_trait_ref: ty::TraitRef<'tcx>,\n                                      trait_item_span: Option<Span>,\n                                      old_broken_mode: bool) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n@@ -49,7 +51,8 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     if let Err(ErrorReported) = compare_self_type(ccx,\n                                                   impl_m,\n                                                   impl_m_span,\n-                                                  trait_m) {\n+                                                  trait_m,\n+                                                  impl_trait_ref) {\n         return;\n     }\n \n@@ -81,16 +84,16 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                          impl_m: &ty::Method<'tcx>,\n+                                          impl_m: &ty::AssociatedItem,\n                                           impl_m_span: Span,\n                                           impl_m_body_id: ast::NodeId,\n-                                          trait_m: &ty::Method<'tcx>,\n-                                          impl_trait_ref: &ty::TraitRef<'tcx>,\n+                                          trait_m: &ty::AssociatedItem,\n+                                          impl_trait_ref: ty::TraitRef<'tcx>,\n                                           old_broken_mode: bool)\n                                           -> Result<(), ErrorReported> {\n     let tcx = ccx.tcx;\n \n-    let trait_to_impl_substs = &impl_trait_ref.substs;\n+    let trait_to_impl_substs = impl_trait_ref.substs;\n \n     // This code is best explained by example. Consider a trait:\n     //\n@@ -165,18 +168,23 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Create mapping from trait to skolemized.\n     let trait_to_skol_substs = impl_to_skol_substs.rebase_onto(tcx,\n-                                                               impl_m.container_id(),\n+                                                               impl_m.container.id(),\n                                                                trait_to_impl_substs.subst(tcx,\n                                                                           impl_to_skol_substs));\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n+    let impl_m_generics = tcx.lookup_generics(impl_m.def_id);\n+    let trait_m_generics = tcx.lookup_generics(trait_m.def_id);\n+    let impl_m_predicates = tcx.lookup_predicates(impl_m.def_id);\n+    let trait_m_predicates = tcx.lookup_predicates(trait_m.def_id);\n+\n     // Check region bounds.\n     check_region_bounds_on_impl_method(ccx,\n                                        impl_m_span,\n                                        impl_m,\n-                                       &trait_m.generics,\n-                                       &impl_m.generics,\n+                                       &trait_m_generics,\n+                                       &impl_m_generics,\n                                        trait_to_skol_substs,\n                                        impl_to_skol_substs)?;\n \n@@ -185,7 +193,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // environment. We can't just use `impl_env.caller_bounds`,\n     // however, because we want to replace all late-bound regions with\n     // region variables.\n-    let impl_predicates = tcx.lookup_predicates(impl_m.predicates.parent.unwrap());\n+    let impl_predicates = tcx.lookup_predicates(impl_m_predicates.parent.unwrap());\n     let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n \n     debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n@@ -198,7 +206,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // We then register the obligations from the impl_m and check to see\n     // if all constraints hold.\n     hybrid_preds.predicates\n-                .extend(trait_m.predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n+                .extend(trait_m_predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n \n     // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n@@ -219,7 +227,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n-        let impl_m_own_bounds = impl_m.predicates.instantiate_own(tcx, impl_to_skol_substs);\n+        let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_skol_substs);\n         let (impl_m_own_bounds, _) = infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n                                                        infer::HigherRankedType,\n                                                        &ty::Binder(impl_m_own_bounds.predicates));\n@@ -260,10 +268,19 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let tcx = infcx.tcx;\n         let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n \n+        let m_fty = |method: &ty::AssociatedItem| {\n+            match tcx.lookup_item_type(method.def_id).ty.sty {\n+                ty::TyFnDef(_, _, f) => f,\n+                _ => bug!()\n+            }\n+        };\n+        let impl_m_fty = m_fty(impl_m);\n+        let trait_m_fty = m_fty(trait_m);\n+\n         let (impl_sig, _) =\n             infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n                                                             infer::HigherRankedType,\n-                                                            &impl_m.fty.sig);\n+                                                            &impl_m_fty.sig);\n         let impl_sig =\n             impl_sig.subst(tcx, impl_to_skol_substs);\n         let impl_sig =\n@@ -273,15 +290,15 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  impl_m_body_id,\n                                                  &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: impl_m.fty.unsafety,\n-            abi: impl_m.fty.abi,\n+            unsafety: impl_m_fty.unsafety,\n+            abi: impl_m_fty.abi,\n             sig: ty::Binder(impl_sig.clone()),\n         }));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n         let trait_sig = tcx.liberate_late_bound_regions(\n             infcx.parameter_environment.free_id_outlive,\n-            &trait_m.fty.sig);\n+            &trait_m_fty.sig);\n         let trait_sig =\n             trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n@@ -291,8 +308,8 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  impl_m_body_id,\n                                                  &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: trait_m.fty.unsafety,\n-            abi: trait_m.fty.abi,\n+            unsafety: trait_m_fty.unsafety,\n+            abi: trait_m_fty.abi,\n             sig: ty::Binder(trait_sig.clone()),\n         }));\n \n@@ -367,7 +384,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                 span: Span,\n-                                                impl_m: &ty::Method<'tcx>,\n+                                                impl_m: &ty::AssociatedItem,\n                                                 trait_generics: &ty::Generics<'tcx>,\n                                                 impl_generics: &ty::Generics<'tcx>,\n                                                 trait_to_skol_substs: &Substs<'tcx>,\n@@ -413,9 +430,9 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n                                                      terr: &TypeError,\n                                                      origin: TypeOrigin,\n-                                                     impl_m: &ty::Method,\n+                                                     impl_m: &ty::AssociatedItem,\n                                                      impl_sig: ty::FnSig<'tcx>,\n-                                                     trait_m: &ty::Method,\n+                                                     trait_m: &ty::AssociatedItem,\n                                                      trait_sig: ty::FnSig<'tcx>)\n                                                      -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n@@ -505,9 +522,10 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n }\n \n fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                               impl_m: &ty::Method<'tcx>,\n+                               impl_m: &ty::AssociatedItem,\n                                impl_m_span: Span,\n-                               trait_m: &ty::Method<'tcx>)\n+                               trait_m: &ty::AssociatedItem,\n+                               impl_trait_ref: ty::TraitRef<'tcx>)\n                                -> Result<(), ErrorReported>\n {\n     let tcx = ccx.tcx;\n@@ -518,58 +536,75 @@ fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // that the error messages you get out of this code are a bit more\n     // inscrutable, particularly for cases where one method has no\n     // self.\n-    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n-        (&ty::ExplicitSelfCategory::Static, &ty::ExplicitSelfCategory::Static) => {}\n-        (&ty::ExplicitSelfCategory::Static, _) => {\n+\n+    let self_string = |method: &ty::AssociatedItem| {\n+        let untransformed_self_ty = match method.container {\n+            ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n+            ty::TraitContainer(_) => tcx.mk_self_type()\n+        };\n+        let method_ty = tcx.lookup_item_type(method.def_id).ty;\n+        let self_arg_ty = *method_ty.fn_sig().input(0).skip_binder();\n+        match ExplicitSelf::determine(untransformed_self_ty, self_arg_ty) {\n+            ExplicitSelf::ByValue => \"self\".to_string(),\n+            ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_string(),\n+            ExplicitSelf::ByReference(_, hir::MutMutable) => \"&mut self\".to_string(),\n+            _ => format!(\"self: {}\", self_arg_ty)\n+        }\n+    };\n+\n+    match (trait_m.method_has_self_argument, impl_m.method_has_self_argument) {\n+        (false, false) | (true, true) => {}\n+\n+        (false, true) => {\n+            let self_descr = self_string(impl_m);\n             let mut err = struct_span_err!(tcx.sess,\n                                            impl_m_span,\n                                            E0185,\n                                            \"method `{}` has a `{}` declaration in the impl, but \\\n                                             not in the trait\",\n                                            trait_m.name,\n-                                           impl_m.explicit_self);\n-            err.span_label(impl_m_span,\n-                           &format!(\"`{}` used in impl\", impl_m.explicit_self));\n+                                           self_descr);\n+            err.span_label(impl_m_span, &format!(\"`{}` used in impl\", self_descr));\n             if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n-                err.span_label(span,\n-                               &format!(\"trait declared without `{}`\", impl_m.explicit_self));\n+                err.span_label(span, &format!(\"trait declared without `{}`\", self_descr));\n             }\n             err.emit();\n             return Err(ErrorReported);\n         }\n-        (_, &ty::ExplicitSelfCategory::Static) => {\n+\n+        (true, false) => {\n+            let self_descr = self_string(trait_m);\n             let mut err = struct_span_err!(tcx.sess,\n                                            impl_m_span,\n                                            E0186,\n                                            \"method `{}` has a `{}` declaration in the trait, but \\\n                                             not in the impl\",\n                                            trait_m.name,\n-                                           trait_m.explicit_self);\n+                                           self_descr);\n             err.span_label(impl_m_span,\n-                           &format!(\"expected `{}` in impl\", trait_m.explicit_self));\n+                           &format!(\"expected `{}` in impl\", self_descr));\n             if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n-                err.span_label(span, &format!(\"`{}` used in trait\", trait_m.explicit_self));\n+                err.span_label(span, &format!(\"`{}` used in trait\", self_descr));\n             }\n             err.emit();\n             return Err(ErrorReported);\n         }\n-        _ => {\n-            // Let the type checker catch other errors below\n-        }\n     }\n \n     Ok(())\n }\n \n fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                        impl_m: &ty::Method<'tcx>,\n+                                        impl_m: &ty::AssociatedItem,\n                                         impl_m_span: Span,\n-                                        trait_m: &ty::Method<'tcx>,\n+                                        trait_m: &ty::AssociatedItem,\n                                         trait_item_span: Option<Span>)\n                                         -> Result<(), ErrorReported> {\n     let tcx = ccx.tcx;\n-    let num_impl_m_type_params = impl_m.generics.types.len();\n-    let num_trait_m_type_params = trait_m.generics.types.len();\n+    let impl_m_generics = tcx.lookup_generics(impl_m.def_id);\n+    let trait_m_generics = tcx.lookup_generics(trait_m.def_id);\n+    let num_impl_m_type_params = impl_m_generics.types.len();\n+    let num_trait_m_type_params = trait_m_generics.types.len();\n     if num_impl_m_type_params != num_trait_m_type_params {\n         let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n         let span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n@@ -630,15 +665,23 @@ fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                impl_m: &ty::Method<'tcx>,\n+                                                impl_m: &ty::AssociatedItem,\n                                                 impl_m_span: Span,\n-                                                trait_m: &ty::Method<'tcx>,\n+                                                trait_m: &ty::AssociatedItem,\n                                                 trait_item_span: Option<Span>)\n                                                 -> Result<(), ErrorReported> {\n     let tcx = ccx.tcx;\n-    if impl_m.fty.sig.0.inputs.len() != trait_m.fty.sig.0.inputs.len() {\n-        let trait_number_args = trait_m.fty.sig.0.inputs.len();\n-        let impl_number_args = impl_m.fty.sig.0.inputs.len();\n+    let m_fty = |method: &ty::AssociatedItem| {\n+        match tcx.lookup_item_type(method.def_id).ty.sty {\n+            ty::TyFnDef(_, _, f) => f,\n+            _ => bug!()\n+        }\n+    };\n+    let impl_m_fty = m_fty(impl_m);\n+    let trait_m_fty = m_fty(trait_m);\n+    if impl_m_fty.sig.0.inputs.len() != trait_m_fty.sig.0.inputs.len() {\n+        let trait_number_args = trait_m_fty.sig.0.inputs.len();\n+        let impl_number_args = impl_m_fty.sig.0.inputs.len();\n         let trait_m_node_id = tcx.map.as_local_node_id(trait_m.def_id);\n         let trait_span = if let Some(trait_id) = trait_m_node_id {\n             match tcx.map.expect_trait_item(trait_id).node {\n@@ -708,10 +751,10 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                    impl_c: &ty::AssociatedConst<'tcx>,\n+                                    impl_c: &ty::AssociatedItem,\n                                     impl_c_span: Span,\n-                                    trait_c: &ty::AssociatedConst<'tcx>,\n-                                    impl_trait_ref: &ty::TraitRef<'tcx>) {\n+                                    trait_c: &ty::AssociatedItem,\n+                                    impl_trait_ref: ty::TraitRef<'tcx>) {\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let tcx = ccx.tcx;\n@@ -723,7 +766,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // because we shouldn't really have to deal with lifetimes or\n         // predicates. In fact some of this should probably be put into\n         // shared functions because of DRY violations...\n-        let trait_to_impl_substs = &impl_trait_ref.substs;\n+        let trait_to_impl_substs = impl_trait_ref.substs;\n \n         // Create a parameter environment that represents the implementation's\n         // method.\n@@ -742,8 +785,8 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                trait_to_skol_substs);\n \n         // Compute skolemized form of impl and trait const tys.\n-        let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n-        let trait_ty = trait_c.ty.subst(tcx, trait_to_skol_substs);\n+        let impl_ty = tcx.lookup_item_type(impl_c.def_id).ty.subst(tcx, impl_to_skol_substs);\n+        let trait_ty = tcx.lookup_item_type(trait_c.def_id).ty.subst(tcx, trait_to_skol_substs);\n         let mut origin = TypeOrigin::Misc(impl_c_span);\n \n         let err = infcx.commit_if_ok(|_| {"}, {"sha": "a06b3e70881a5204c1af7a7267c4fece982ac712", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -553,9 +553,9 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             // attributes attached to the impl's generics.\n             let dtor_method = adt_def.destructor()\n                 .expect(\"dtorck type without destructor impossible\");\n-            let method = tcx.impl_or_trait_item(dtor_method);\n-            let impl_id: DefId = method.container().id();\n-            let revised_ty = revise_self_ty(tcx, adt_def, impl_id, substs);\n+            let method = tcx.associated_item(dtor_method);\n+            let impl_def_id = method.container.id();\n+            let revised_ty = revise_self_ty(tcx, adt_def, impl_def_id, substs);\n             return DropckKind::RevisedSelf(revised_ty);\n         }\n         ty::TyTrait(..) | ty::TyProjection(..) | ty::TyAnon(..) => {"}, {"sha": "3894a7a2097eb9375153acb3df8d45258c8b7708", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 34, "deletions": 56, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -37,16 +37,6 @@ impl<'a, 'gcx, 'tcx> Deref for ConfirmContext<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct InstantiatedMethodSig<'tcx> {\n-    /// Function signature of the method being invoked. The 0th\n-    /// argument is the receiver.\n-    method_sig: ty::FnSig<'tcx>,\n-\n-    /// Generic bounds on the method's parameters which must be added\n-    /// as pending obligations.\n-    method_predicates: ty::InstantiatedPredicates<'tcx>,\n-}\n-\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn confirm_method(&self,\n                           span: Span,\n@@ -98,31 +88,18 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         debug!(\"all_substs={:?}\", all_substs);\n \n         // Create the final signature for the method, replacing late-bound regions.\n-        let InstantiatedMethodSig { method_sig, method_predicates } =\n-            self.instantiate_method_sig(&pick, all_substs);\n-        let method_self_ty = method_sig.inputs[0];\n+        let (method_ty, method_predicates) = self.instantiate_method_sig(&pick, all_substs);\n \n         // Unify the (adjusted) self type with what the method expects.\n-        self.unify_receivers(self_ty, method_self_ty);\n-\n-        // Create the method type\n-        let def_id = pick.item.def_id();\n-        let method_ty = pick.item.as_opt_method().unwrap();\n-        let fty = self.tcx.mk_fn_def(def_id,\n-                                     all_substs,\n-                                     self.tcx.mk_bare_fn(ty::BareFnTy {\n-                                         sig: ty::Binder(method_sig),\n-                                         unsafety: method_ty.fty.unsafety,\n-                                         abi: method_ty.fty.abi.clone(),\n-                                     }));\n+        self.unify_receivers(self_ty, method_ty.fn_sig().input(0).skip_binder());\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n-        self.add_obligations(fty, all_substs, &method_predicates);\n+        self.add_obligations(method_ty, all_substs, &method_predicates);\n \n         // Create the final `MethodCallee`.\n         let callee = ty::MethodCallee {\n-            def_id: def_id,\n-            ty: fty,\n+            def_id: pick.item.def_id,\n+            ty: method_ty,\n             substs: all_substs,\n         };\n \n@@ -193,15 +170,15 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                              -> &'tcx Substs<'tcx> {\n         match pick.kind {\n             probe::InherentImplPick => {\n-                let impl_def_id = pick.item.container().id();\n+                let impl_def_id = pick.item.container.id();\n                 assert!(self.tcx.impl_trait_ref(impl_def_id).is_none(),\n                         \"impl {:?} is not an inherent impl\",\n                         impl_def_id);\n                 self.impl_self_ty(self.span, impl_def_id).substs\n             }\n \n             probe::ObjectPick => {\n-                let trait_def_id = pick.item.container().id();\n+                let trait_def_id = pick.item.container.id();\n                 self.extract_existential_trait_ref(self_ty, |this, object_ty, principal| {\n                     // The object data has no entry for the Self\n                     // Type. For the purposes of this method call, we\n@@ -244,7 +221,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             }\n \n             probe::TraitPick => {\n-                let trait_def_id = pick.item.container().id();\n+                let trait_def_id = pick.item.container.id();\n \n                 // Make a trait reference `$0 : Trait<$1...$n>`\n                 // consisting entirely of type variables. Later on in\n@@ -299,8 +276,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n-        let method = pick.item.as_opt_method().unwrap();\n-        let num_method_types = method.generics.types.len();\n+        let method_generics = self.tcx.lookup_generics(pick.item.def_id);\n+        let num_method_types = method_generics.types.len();\n \n         if num_supplied_types > 0 && num_supplied_types != num_method_types {\n             if num_method_types == 0 {\n@@ -332,18 +309,15 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // parameters from the type and those from the method.\n         //\n         // FIXME -- permit users to manually specify lifetimes\n-        let supplied_start = substs.params().len() + method.generics.regions.len();\n-        Substs::for_item(self.tcx,\n-                         method.def_id,\n-                         |def, _| {\n+        let supplied_start = substs.params().len() + method_generics.regions.len();\n+        Substs::for_item(self.tcx, pick.item.def_id, |def, _| {\n             let i = def.index as usize;\n             if i < substs.params().len() {\n                 substs.region_at(i)\n             } else {\n                 self.region_var_for_def(self.span, def)\n             }\n-        },\n-                         |def, cur_substs| {\n+        }, |def, cur_substs| {\n             let i = def.index as usize;\n             if i < substs.params().len() {\n                 substs.type_at(i)\n@@ -376,44 +350,48 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn instantiate_method_sig(&mut self,\n                               pick: &probe::Pick<'tcx>,\n                               all_substs: &'tcx Substs<'tcx>)\n-                              -> InstantiatedMethodSig<'tcx> {\n+                              -> (Ty<'tcx>, ty::InstantiatedPredicates<'tcx>) {\n         debug!(\"instantiate_method_sig(pick={:?}, all_substs={:?})\",\n                pick,\n                all_substs);\n \n         // Instantiate the bounds on the method with the\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n-        let method_predicates = pick.item\n-            .as_opt_method()\n-            .unwrap()\n-            .predicates\n-            .instantiate(self.tcx, all_substs);\n-        let method_predicates = self.normalize_associated_types_in(self.span, &method_predicates);\n+        let def_id = pick.item.def_id;\n+        let method_predicates = self.tcx.lookup_predicates(def_id)\n+                                    .instantiate(self.tcx, all_substs);\n+        let method_predicates = self.normalize_associated_types_in(self.span,\n+                                                                   &method_predicates);\n \n         debug!(\"method_predicates after subst = {:?}\", method_predicates);\n \n+        let fty = match self.tcx.lookup_item_type(def_id).ty.sty {\n+            ty::TyFnDef(_, _, f) => f,\n+            _ => bug!()\n+        };\n+\n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n         //\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let method_sig = self.replace_late_bound_regions_with_fresh_var(&pick.item\n-            .as_opt_method()\n-            .unwrap()\n-            .fty\n-            .sig);\n+        let method_sig = self.replace_late_bound_regions_with_fresh_var(&fty.sig);\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={:?}\",\n                method_sig);\n \n         let method_sig = self.instantiate_type_scheme(self.span, all_substs, &method_sig);\n         debug!(\"type scheme substituted, method_sig={:?}\", method_sig);\n \n-        InstantiatedMethodSig {\n-            method_sig: method_sig,\n-            method_predicates: method_predicates,\n-        }\n+        let method_ty = self.tcx.mk_fn_def(def_id, all_substs,\n+                                           self.tcx.mk_bare_fn(ty::BareFnTy {\n+            sig: ty::Binder(method_sig),\n+            unsafety: fty.unsafety,\n+            abi: fty.abi,\n+        }));\n+\n+        (method_ty, method_predicates)\n     }\n \n     fn add_obligations(&mut self,\n@@ -587,7 +565,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n     fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n-        match pick.item.container() {\n+        match pick.item.container {\n             ty::TraitContainer(trait_def_id) => {\n                 callee::check_legal_trait_for_method_call(self.ccx, self.span, trait_def_id)\n             }"}, {"sha": "579a54fb5318df629d10912a06c99df21a55687e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 58, "deletions": 84, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -228,37 +228,39 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Trait must have a method named `m_name` and it should not have\n         // type parameters or early-bound regions.\n         let tcx = self.tcx;\n-        let method_item = self.impl_or_trait_item(trait_def_id, m_name).unwrap();\n-        let method_ty = method_item.as_opt_method().unwrap();\n-        assert_eq!(method_ty.generics.types.len(), 0);\n-        assert_eq!(method_ty.generics.regions.len(), 0);\n+        let method_item = self.associated_item(trait_def_id, m_name).unwrap();\n+        let def_id = method_item.def_id;\n+        let generics = tcx.lookup_generics(def_id);\n+        assert_eq!(generics.types.len(), 0);\n+        assert_eq!(generics.regions.len(), 0);\n \n-        debug!(\"lookup_in_trait_adjusted: method_item={:?} method_ty={:?}\",\n-               method_item,\n-               method_ty);\n+        debug!(\"lookup_in_trait_adjusted: method_item={:?}\", method_item);\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n         //\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let fn_sig =\n-            self.replace_late_bound_regions_with_fresh_var(span, infer::FnCall, &method_ty.fty.sig)\n-                .0;\n+        let original_method_ty = tcx.lookup_item_type(def_id).ty;\n+        let fty = match original_method_ty.sty {\n+            ty::TyFnDef(_, _, f) => f,\n+            _ => bug!()\n+        };\n+        let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n+                                                                    infer::FnCall,\n+                                                                    &fty.sig).0;\n         let fn_sig = self.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n         let transformed_self_ty = fn_sig.inputs[0];\n-        let def_id = method_item.def_id();\n-        let fty = tcx.mk_fn_def(def_id,\n-                                trait_ref.substs,\n-                                tcx.mk_bare_fn(ty::BareFnTy {\n-                                    sig: ty::Binder(fn_sig),\n-                                    unsafety: method_ty.fty.unsafety,\n-                                    abi: method_ty.fty.abi.clone(),\n-                                }));\n-\n-        debug!(\"lookup_in_trait_adjusted: matched method fty={:?} obligation={:?}\",\n-               fty,\n+        let method_ty = tcx.mk_fn_def(def_id, trait_ref.substs,\n+                                      tcx.mk_bare_fn(ty::BareFnTy {\n+            sig: ty::Binder(fn_sig),\n+            unsafety: fty.unsafety,\n+            abi: fty.abi\n+        }));\n+\n+        debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n+               method_ty,\n                obligation);\n \n         // Register obligations for the parameters.  This will include the\n@@ -269,75 +271,53 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // Note that as the method comes from a trait, it should not have\n         // any late-bound regions appearing in its bounds.\n-        let method_bounds = self.instantiate_bounds(span, trait_ref.substs, &method_ty.predicates);\n+        let method_bounds = self.instantiate_bounds(span, def_id, trait_ref.substs);\n         assert!(!method_bounds.has_escaping_regions());\n         self.add_obligations_for_parameters(traits::ObligationCause::misc(span, self.body_id),\n                                             &method_bounds);\n \n         // Also register an obligation for the method type being well-formed.\n-        self.register_wf_obligation(fty, span, traits::MiscObligation);\n+        self.register_wf_obligation(method_ty, span, traits::MiscObligation);\n \n         // FIXME(#18653) -- Try to resolve obligations, giving us more\n         // typing information, which can sometimes be needed to avoid\n         // pathological region inference failures.\n         self.select_obligations_where_possible();\n \n         // Insert any adjustments needed (always an autoref of some mutability).\n-        match self_expr {\n-            None => {}\n-\n-            Some(self_expr) => {\n-                debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n-                       (self-id={}, autoderefs={}, unsize={}, explicit_self={:?})\",\n-                       self_expr.id,\n-                       autoderefs,\n-                       unsize,\n-                       method_ty.explicit_self);\n-\n-                let autoref = match method_ty.explicit_self {\n-                    ty::ExplicitSelfCategory::ByValue => {\n-                        // Trait method is fn(self), no transformation needed.\n-                        assert!(!unsize);\n-                        None\n-                    }\n-\n-                    ty::ExplicitSelfCategory::ByReference(..) => {\n-                        // Trait method is fn(&self) or fn(&mut self), need an\n-                        // autoref. Pull the region etc out of the type of first argument.\n-                        match transformed_self_ty.sty {\n-                            ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ }) => {\n-                                Some(AutoBorrow::Ref(region, mutbl))\n-                            }\n-\n-                            _ => {\n-                                span_bug!(span,\n-                                          \"trait method is &self but first arg is: {}\",\n-                                          transformed_self_ty);\n-                            }\n-                        }\n-                    }\n-\n-                    _ => {\n-                        span_bug!(span,\n-                                  \"unexpected explicit self type in operator method: {:?}\",\n-                                  method_ty.explicit_self);\n-                    }\n-                };\n-\n-                self.write_adjustment(self_expr.id, Adjustment {\n-                    kind: Adjust::DerefRef {\n-                        autoderefs: autoderefs,\n-                        autoref: autoref,\n-                        unsize: unsize\n-                    },\n-                    target: transformed_self_ty\n-                });\n-            }\n+        if let Some(self_expr) = self_expr {\n+            debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n+                    (self-id={}, autoderefs={}, unsize={}, fty={:?})\",\n+                    self_expr.id, autoderefs, unsize, original_method_ty);\n+\n+            let original_sig = original_method_ty.fn_sig();\n+            let autoref = match (&original_sig.input(0).skip_binder().sty,\n+                                 &transformed_self_ty.sty) {\n+                (&ty::TyRef(..), &ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ })) => {\n+                    // Trait method is fn(&self) or fn(&mut self), need an\n+                    // autoref. Pull the region etc out of the type of first argument.\n+                    Some(AutoBorrow::Ref(region, mutbl))\n+                }\n+                _ => {\n+                    // Trait method is fn(self), no transformation needed.\n+                    assert!(!unsize);\n+                    None\n+                }\n+            };\n+\n+            self.write_adjustment(self_expr.id, Adjustment {\n+                kind: Adjust::DerefRef {\n+                    autoderefs: autoderefs,\n+                    autoref: autoref,\n+                    unsize: unsize\n+                },\n+                target: transformed_self_ty\n+            });\n         }\n \n         let callee = ty::MethodCallee {\n             def_id: def_id,\n-            ty: fty,\n+            ty: method_ty,\n             substs: trait_ref.substs,\n         };\n \n@@ -361,7 +341,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let def = pick.item.def();\n         if let probe::InherentImplPick = pick.kind {\n-            if !pick.item.vis().is_accessible_from(self.body_id, &self.tcx.map) {\n+            if !pick.item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n                 let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n                 self.tcx.sess.span_err(span, &msg);\n             }\n@@ -371,14 +351,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Find item with name `item_name` defined in impl/trait `def_id`\n     /// and return it, or `None`, if no such item was defined there.\n-    pub fn impl_or_trait_item(&self,\n-                              def_id: DefId,\n-                              item_name: ast::Name)\n-                              -> Option<ty::ImplOrTraitItem<'tcx>> {\n-        self.tcx\n-            .impl_or_trait_items(def_id)\n-            .iter()\n-            .map(|&did| self.tcx.impl_or_trait_item(did))\n-            .find(|m| m.name() == item_name)\n+    pub fn associated_item(&self, def_id: DefId, item_name: ast::Name)\n+                           -> Option<ty::AssociatedItem> {\n+        self.tcx.associated_items(def_id).find(|item| item.name == item_name)\n     }\n }"}, {"sha": "7068b2dea7263b847a920708c23be6987cc2c756", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 40, "deletions": 69, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -72,7 +72,7 @@ struct CandidateStep<'tcx> {\n #[derive(Debug)]\n struct Candidate<'tcx> {\n     xform_self_ty: Ty<'tcx>,\n-    item: ty::ImplOrTraitItem<'tcx>,\n+    item: ty::AssociatedItem,\n     kind: CandidateKind<'tcx>,\n     import_id: Option<ast::NodeId>,\n }\n@@ -95,7 +95,7 @@ enum CandidateKind<'tcx> {\n \n #[derive(Debug)]\n pub struct Pick<'tcx> {\n-    pub item: ty::ImplOrTraitItem<'tcx>,\n+    pub item: ty::AssociatedItem,\n     pub kind: PickKind<'tcx>,\n     pub import_id: Option<ast::NodeId>,\n \n@@ -384,8 +384,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_inherent_impl_for_primitive(&mut self, lang_def_id: Option<DefId>) {\n         if let Some(impl_def_id) = lang_def_id {\n-            self.tcx.populate_implementations_for_primitive_if_necessary(impl_def_id);\n-\n             self.assemble_inherent_impl_probe(impl_def_id);\n         }\n     }\n@@ -409,7 +407,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n-        let item = match self.impl_or_trait_item(impl_def_id) {\n+        let item = match self.associated_item(impl_def_id) {\n             Some(m) => m,\n             None => {\n                 return;\n@@ -421,7 +419,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n-        if !item.vis().is_accessible_from(self.body_id, &self.tcx.map) {\n+        if !item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n             self.private_candidate = Some(item.def());\n             return;\n         }\n@@ -512,17 +510,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             let xform_self_ty = this.xform_self_ty(&item, trait_ref.self_ty(), trait_ref.substs);\n \n-            if let Some(ref m) = item.as_opt_method() {\n-                debug!(\"found match: trait_ref={:?} substs={:?} m={:?}\",\n-                       trait_ref,\n-                       trait_ref.substs,\n-                       m);\n-                assert_eq!(m.generics.parent_types as usize,\n-                           trait_ref.substs.types().count());\n-                assert_eq!(m.generics.parent_regions as usize,\n-                           trait_ref.substs.regions().count());\n-            }\n-\n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n             // artifacts. This means it is safe to put into the\n@@ -544,13 +531,13 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn elaborate_bounds<F>(&mut self, bounds: &[ty::PolyTraitRef<'tcx>], mut mk_cand: F)\n         where F: for<'b> FnMut(&mut ProbeContext<'b, 'gcx, 'tcx>,\n                                ty::PolyTraitRef<'tcx>,\n-                               ty::ImplOrTraitItem<'tcx>)\n+                               ty::AssociatedItem)\n     {\n         debug!(\"elaborate_bounds(bounds={:?})\", bounds);\n \n         let tcx = self.tcx;\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let item = match self.impl_or_trait_item(bound_trait_ref.def_id()) {\n+            let item = match self.associated_item(bound_trait_ref.def_id()) {\n                 Some(v) => v,\n                 None => {\n                     continue;\n@@ -601,9 +588,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                trait_def_id);\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n-        let trait_items = self.tcx.trait_items(trait_def_id);\n-        let maybe_item = trait_items.iter()\n-            .find(|item| item.name() == self.item_name);\n+        let maybe_item = self.tcx.associated_items(trait_def_id)\n+                             .find(|item| item.name == self.item_name);\n         let item = match maybe_item {\n             Some(i) => i,\n             None => {\n@@ -612,7 +598,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         };\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n-        if !self.has_applicable_self(item) {\n+        if !self.has_applicable_self(&item) {\n             debug!(\"method has inapplicable self\");\n             self.record_static_candidate(TraitSource(trait_def_id));\n             return Ok(());\n@@ -631,7 +617,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      trait_def_id: DefId,\n-                                                     item: ty::ImplOrTraitItem<'tcx>) {\n+                                                     item: ty::AssociatedItem) {\n         let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n \n         // FIXME(arielb1): can we use for_each_relevant_impl here?\n@@ -700,7 +686,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_closure_candidates(&mut self,\n                                    trait_def_id: DefId,\n-                                   item: ty::ImplOrTraitItem<'tcx>)\n+                                   item: ty::AssociatedItem)\n                                    -> Result<(), MethodError<'tcx>> {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n         let tcx = self.tcx;\n@@ -765,7 +751,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_projection_candidates(&mut self,\n                                       trait_def_id: DefId,\n-                                      item: ty::ImplOrTraitItem<'tcx>) {\n+                                      item: ty::AssociatedItem) {\n         debug!(\"assemble_projection_candidates(\\\n                trait_def_id={:?}, \\\n                item={:?})\",\n@@ -820,7 +806,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: DefId,\n-                                        item: ty::ImplOrTraitItem<'tcx>) {\n+                                        item: ty::AssociatedItem) {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n                trait_def_id);\n \n@@ -865,7 +851,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.assemble_extension_candidates_for_all_traits()?;\n \n         let out_of_scope_traits = match self.pick_core() {\n-            Some(Ok(p)) => vec![p.item.container().id()],\n+            Some(Ok(p)) => vec![p.item.container.id()],\n             Some(Err(MethodError::Ambiguity(v))) => {\n                 v.into_iter()\n                     .map(|source| {\n@@ -1065,7 +1051,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // don't have enough information to fully evaluate).\n             let (impl_def_id, substs, ref_obligations) = match probe.kind {\n                 InherentImplCandidate(ref substs, ref ref_obligations) => {\n-                    (probe.item.container().id(), substs, ref_obligations)\n+                    (probe.item.container.id(), substs, ref_obligations)\n                 }\n \n                 ExtensionImplCandidate(impl_def_id, ref substs, ref ref_obligations) => {\n@@ -1128,12 +1114,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     /// use, so it's ok to just commit to \"using the method from the trait Foo\".\n     fn collapse_candidates_to_trait_pick(&self, probes: &[&Candidate<'tcx>]) -> Option<Pick<'tcx>> {\n         // Do all probes correspond to the same trait?\n-        let container = probes[0].item.container();\n+        let container = probes[0].item.container;\n         match container {\n             ty::TraitContainer(_) => {}\n             ty::ImplContainer(_) => return None,\n         }\n-        if probes[1..].iter().any(|p| p.item.container() != container) {\n+        if probes[1..].iter().any(|p| p.item.container != container) {\n             return None;\n         }\n \n@@ -1150,19 +1136,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n-    fn has_applicable_self(&self, item: &ty::ImplOrTraitItem) -> bool {\n+    fn has_applicable_self(&self, item: &ty::AssociatedItem) -> bool {\n         // \"fast track\" -- check for usage of sugar\n-        match *item {\n-            ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n-                match method.explicit_self {\n-                    ty::ExplicitSelfCategory::Static => self.mode == Mode::Path,\n-                    ty::ExplicitSelfCategory::ByValue |\n-                    ty::ExplicitSelfCategory::ByReference(..) |\n-                    ty::ExplicitSelfCategory::ByBox => true,\n-                }\n-            }\n-            ty::ImplOrTraitItem::ConstTraitItem(..) => self.mode == Mode::Path,\n-            _ => false,\n+        match self.mode {\n+            Mode::MethodCall => item.method_has_self_argument,\n+            Mode::Path => true\n         }\n         // FIXME -- check for types that deref to `Self`,\n         // like `Rc<Self>` and so on.\n@@ -1177,24 +1155,26 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn xform_self_ty(&self,\n-                     item: &ty::ImplOrTraitItem<'tcx>,\n+                     item: &ty::AssociatedItem,\n                      impl_ty: Ty<'tcx>,\n                      substs: &Substs<'tcx>)\n                      -> Ty<'tcx> {\n-        match item.as_opt_method() {\n-            Some(ref method) => self.xform_method_self_ty(method, impl_ty, substs),\n-            None => impl_ty,\n+        if item.kind == ty::AssociatedKind::Method && self.mode == Mode::MethodCall {\n+            self.xform_method_self_ty(item.def_id, impl_ty, substs)\n+        } else {\n+            impl_ty\n         }\n     }\n \n     fn xform_method_self_ty(&self,\n-                            method: &Rc<ty::Method<'tcx>>,\n+                            method: DefId,\n                             impl_ty: Ty<'tcx>,\n                             substs: &Substs<'tcx>)\n                             -> Ty<'tcx> {\n+        let self_ty = self.tcx.lookup_item_type(method).ty.fn_sig().input(0);\n         debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n                impl_ty,\n-               method.fty.sig.0.inputs.get(0),\n+               self_ty,\n                substs);\n \n         assert!(!substs.has_escaping_regions());\n@@ -1204,26 +1184,18 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // are given do not include type/lifetime parameters for the\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n-        assert_eq!(substs.types().count(),\n-                   method.generics.parent_types as usize);\n-        assert_eq!(substs.regions().count(),\n-                   method.generics.parent_regions as usize);\n-\n-        if self.mode == Mode::Path {\n-            return impl_ty;\n-        }\n+        let generics = self.tcx.lookup_generics(method);\n+        assert_eq!(substs.types().count(), generics.parent_types as usize);\n+        assert_eq!(substs.regions().count(), generics.parent_regions as usize);\n \n         // Erase any late-bound regions from the method and substitute\n         // in the values from the substitution.\n-        let xform_self_ty = method.fty.sig.input(0);\n-        let xform_self_ty = self.erase_late_bound_regions(&xform_self_ty);\n+        let xform_self_ty = self.erase_late_bound_regions(&self_ty);\n \n-        if method.generics.types.is_empty() && method.generics.regions.is_empty() {\n+        if generics.types.is_empty() && generics.regions.is_empty() {\n             xform_self_ty.subst(self.tcx, substs)\n         } else {\n-            let substs = Substs::for_item(self.tcx,\n-                                          method.def_id,\n-                                          |def, _| {\n+            let substs = Substs::for_item(self.tcx, method, |def, _| {\n                 let i = def.index as usize;\n                 if i < substs.params().len() {\n                     substs.region_at(i)\n@@ -1232,8 +1204,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     // `impl_self_ty()` for an explanation.\n                     self.tcx.mk_region(ty::ReErased)\n                 }\n-            },\n-                                          |def, cur_substs| {\n+            }, |def, cur_substs| {\n                 let i = def.index as usize;\n                 if i < substs.params().len() {\n                     substs.type_at(i)\n@@ -1283,8 +1254,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     /// Find item with name `item_name` defined in impl/trait `def_id`\n     /// and return it, or `None`, if no such item was defined there.\n-    fn impl_or_trait_item(&self, def_id: DefId) -> Option<ty::ImplOrTraitItem<'tcx>> {\n-        self.fcx.impl_or_trait_item(def_id, self.item_name)\n+    fn associated_item(&self, def_id: DefId) -> Option<ty::AssociatedItem> {\n+        self.fcx.associated_item(def_id, self.item_name)\n     }\n }\n \n@@ -1317,11 +1288,11 @@ impl<'tcx> Candidate<'tcx> {\n \n     fn to_source(&self) -> CandidateSource {\n         match self.kind {\n-            InherentImplCandidate(..) => ImplSource(self.item.container().id()),\n+            InherentImplCandidate(..) => ImplSource(self.item.container.id()),\n             ExtensionImplCandidate(def_id, ..) => ImplSource(def_id),\n             ObjectCandidate |\n             TraitCandidate |\n-            WhereClauseCandidate(_) => TraitSource(self.item.container().id()),\n+            WhereClauseCandidate(_) => TraitSource(self.item.container.id()),\n         }\n     }\n }"}, {"sha": "0cb8cf2a58886af8247dcb97fc7271b15538f063", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -89,20 +89,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     CandidateSource::ImplSource(impl_did) => {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n-                        let item = self.impl_or_trait_item(impl_did, item_name)\n+                        let item = self.associated_item(impl_did, item_name)\n                             .or_else(|| {\n-                                self.impl_or_trait_item(self.tcx\n-                                                            .impl_trait_ref(impl_did)\n-                                                            .unwrap()\n-                                                            .def_id,\n-\n-                                                        item_name)\n-                            })\n-                            .unwrap();\n-                        let note_span = self.tcx\n-                            .map\n-                            .span_if_local(item.def_id())\n-                            .or_else(|| self.tcx.map.span_if_local(impl_did));\n+                                self.associated_item(\n+                                    self.tcx.impl_trait_ref(impl_did).unwrap().def_id,\n+\n+                                    item_name\n+                                )\n+                            }).unwrap();\n+                        let note_span = self.tcx.map.span_if_local(item.def_id).or_else(|| {\n+                            self.tcx.map.span_if_local(impl_did)\n+                        });\n \n                         let impl_ty = self.impl_self_ty(span, impl_did).ty;\n \n@@ -127,8 +124,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n-                        let item = self.impl_or_trait_item(trait_did, item_name).unwrap();\n-                        let item_span = self.tcx.map.def_id_span(item.def_id(), span);\n+                        let item = self.associated_item(trait_did, item_name).unwrap();\n+                        let item_span = self.tcx.map.def_id_span(item.def_id, span);\n                         span_note!(err,\n                                    item_span,\n                                    \"candidate #{} is defined in the trait `{}`\",\n@@ -334,8 +331,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // this isn't perfect (that is, there are cases when\n                 // implementing a trait would be legal but is rejected\n                 // here).\n-                (type_is_local || info.def_id.is_local()) &&\n-                self.impl_or_trait_item(info.def_id, item_name).is_some()\n+                (type_is_local || info.def_id.is_local())\n+                    && self.associated_item(info.def_id, item_name).is_some()\n             })\n             .collect::<Vec<_>>();\n "}, {"sha": "08242cff112ceee9221179aa6a3bd69987f4cb7a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 362, "deletions": 308, "changes": 670, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -106,17 +106,18 @@ use util::common::{block_query, ErrorReported, indenter, loop_query};\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n+use std::cmp;\n use std::mem::replace;\n-use std::ops::Deref;\n+use std::ops::{self, Deref};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::{self, Spanned};\n+use syntax::codemap::{self, original_sp, Spanned};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{self, Span};\n+use syntax_pos::{self, BytePos, Span};\n \n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::{self, PatKind};\n@@ -351,6 +352,59 @@ impl UnsafetyState {\n     }\n }\n \n+/// Whether a node ever exits normally or not.\n+/// Tracked semi-automatically (through type variables\n+/// marked as diverging), with some manual adjustments\n+/// for control-flow primitives (approximating a CFG).\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+enum Diverges {\n+    /// Potentially unknown, some cases converge,\n+    /// others require a CFG to determine them.\n+    Maybe,\n+\n+    /// Definitely known to diverge and therefore\n+    /// not reach the next sibling or its parent.\n+    Always,\n+\n+    /// Same as `Always` but with a reachability\n+    /// warning already emitted\n+    WarnedAlways\n+}\n+\n+// Convenience impls for combinig `Diverges`.\n+\n+impl ops::BitAnd for Diverges {\n+    type Output = Self;\n+    fn bitand(self, other: Self) -> Self {\n+        cmp::min(self, other)\n+    }\n+}\n+\n+impl ops::BitOr for Diverges {\n+    type Output = Self;\n+    fn bitor(self, other: Self) -> Self {\n+        cmp::max(self, other)\n+    }\n+}\n+\n+impl ops::BitAndAssign for Diverges {\n+    fn bitand_assign(&mut self, other: Self) {\n+        *self = *self & other;\n+    }\n+}\n+\n+impl ops::BitOrAssign for Diverges {\n+    fn bitor_assign(&mut self, other: Self) {\n+        *self = *self | other;\n+    }\n+}\n+\n+impl Diverges {\n+    fn always(self) -> bool {\n+        self >= Diverges::Always\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n@@ -371,6 +425,12 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     ps: RefCell<UnsafetyState>,\n \n+    /// Whether the last checked node can ever exit.\n+    diverges: Cell<Diverges>,\n+\n+    /// Whether any child nodes have any type errors.\n+    has_errors: Cell<bool>,\n+\n     inh: &'a Inherited<'a, 'gcx, 'tcx>,\n }\n \n@@ -534,7 +594,7 @@ pub fn check_drop_impls(ccx: &CrateCtxt) -> CompileResult {\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            decl: &'tcx hir::FnDecl,\n-                           body: &'tcx hir::Block,\n+                           body: &'tcx hir::Expr,\n                            fn_id: ast::NodeId,\n                            span: Span) {\n     let raw_fty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(fn_id)).ty;\n@@ -558,7 +618,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let fcx = check_fn(&inh, fn_ty.unsafety, fn_id, &fn_sig, decl, fn_id, body);\n \n         fcx.select_all_obligations_and_apply_defaults();\n-        fcx.closure_analyze_fn(body);\n+        fcx.closure_analyze(body);\n         fcx.select_obligations_where_possible();\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n@@ -654,7 +714,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Don't descend into the bodies of nested closures\n     fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n-                _: &'gcx hir::Block, _: Span, _: ast::NodeId) { }\n+                _: &'gcx hir::Expr, _: Span, _: ast::NodeId) { }\n }\n \n /// Helper used by check_bare_fn and check_expr_fn. Does the grungy work of checking a function\n@@ -669,7 +729,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             fn_sig: &ty::FnSig<'tcx>,\n                             decl: &'gcx hir::FnDecl,\n                             fn_id: ast::NodeId,\n-                            body: &'gcx hir::Block)\n+                            body: &'gcx hir::Expr)\n                             -> FnCtxt<'a, 'gcx, 'tcx>\n {\n     let mut fn_sig = fn_sig.clone();\n@@ -709,18 +769,12 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             fcx.write_ty(input.id, arg_ty);\n         }\n \n-        visit.visit_block(body);\n+        visit.visit_expr(body);\n     }\n \n     inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n \n-    // FIXME(aburka) do we need this special case? and should it be is_uninhabited?\n-    let expected = if fcx.ret_ty.is_never() {\n-        NoExpectation\n-    } else {\n-        ExpectHasType(fcx.ret_ty)\n-    };\n-    fcx.check_block_with_expected(body, expected);\n+    fcx.check_expr_coercable_to_type(body, fcx.ret_ty);\n \n     fcx\n }\n@@ -760,7 +814,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n               check_impl_items_against_trait(ccx,\n                                              it.span,\n                                              impl_def_id,\n-                                             &impl_trait_ref,\n+                                             impl_trait_ref,\n                                              impl_items);\n               let trait_def_id = impl_trait_ref.def_id;\n               check_on_unimplemented(ccx, trait_def_id, it);\n@@ -942,21 +996,13 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let ancestors = trait_def.ancestors(impl_id);\n \n-    let parent = match impl_item.node {\n-        hir::ImplItemKind::Const(..) => {\n-            ancestors.const_defs(tcx, impl_item.name).skip(1).next()\n-                .map(|node_item| node_item.map(|parent| parent.defaultness))\n-        }\n-        hir::ImplItemKind::Method(..) => {\n-            ancestors.fn_defs(tcx, impl_item.name).skip(1).next()\n-                .map(|node_item| node_item.map(|parent| parent.defaultness))\n-\n-        }\n-        hir::ImplItemKind::Type(_) => {\n-            ancestors.type_defs(tcx, impl_item.name).skip(1).next()\n-                .map(|node_item| node_item.map(|parent| parent.defaultness))\n-        }\n+    let kind = match impl_item.node {\n+        hir::ImplItemKind::Const(..) => ty::AssociatedKind::Const,\n+        hir::ImplItemKind::Method(..) => ty::AssociatedKind::Method,\n+        hir::ImplItemKind::Type(_) => ty::AssociatedKind::Type\n     };\n+    let parent = ancestors.defs(tcx, impl_item.name, kind).skip(1).next()\n+        .map(|node_item| node_item.map(|parent| parent.defaultness));\n \n     if let Some(parent) = parent {\n         if parent.item.is_final() {\n@@ -969,7 +1015,7 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n                                             impl_id: DefId,\n-                                            impl_trait_ref: &ty::TraitRef<'tcx>,\n+                                            impl_trait_ref: ty::TraitRef<'tcx>,\n                                             impl_items: &[hir::ImplItem]) {\n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n@@ -979,106 +1025,90 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Locate trait definition and items\n     let tcx = ccx.tcx;\n     let trait_def = tcx.lookup_trait_def(impl_trait_ref.def_id);\n-    let trait_items = tcx.trait_items(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n-        let ty_impl_item = tcx.impl_or_trait_item(tcx.map.local_def_id(impl_item.id));\n-        let ty_trait_item = trait_items.iter()\n-            .find(|ac| ac.name() == ty_impl_item.name());\n+        let ty_impl_item = tcx.associated_item(tcx.map.local_def_id(impl_item.id));\n+        let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n+            .find(|ac| ac.name == ty_impl_item.name);\n \n         // Check that impl definition matches trait definition\n         if let Some(ty_trait_item) = ty_trait_item {\n             match impl_item.node {\n                 hir::ImplItemKind::Const(..) => {\n-                    let impl_const = match ty_impl_item {\n-                        ty::ConstTraitItem(ref cti) => cti,\n-                        _ => span_bug!(impl_item.span, \"non-const impl-item for const\")\n-                    };\n-\n                     // Find associated const definition.\n-                    if let &ty::ConstTraitItem(ref trait_const) = ty_trait_item {\n+                    if ty_trait_item.kind == ty::AssociatedKind::Const {\n                         compare_const_impl(ccx,\n-                                           &impl_const,\n+                                           &ty_impl_item,\n                                            impl_item.span,\n-                                           trait_const,\n-                                           &impl_trait_ref);\n+                                           &ty_trait_item,\n+                                           impl_trait_ref);\n                     } else {\n                          let mut err = struct_span_err!(tcx.sess, impl_item.span, E0323,\n                                   \"item `{}` is an associated const, \\\n                                   which doesn't match its trait `{:?}`\",\n-                                  impl_const.name,\n+                                  ty_impl_item.name,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, &format!(\"does not match trait\"));\n                          // We can only get the spans from local trait definition\n                          // Same for E0324 and E0325\n-                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id()) {\n+                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, &format!(\"item in trait\"));\n                          }\n                          err.emit()\n                     }\n                 }\n                 hir::ImplItemKind::Method(_, ref body) => {\n-                    let impl_method = match ty_impl_item {\n-                        ty::MethodTraitItem(ref mti) => mti,\n-                        _ => span_bug!(impl_item.span, \"non-method impl-item for method\")\n-                    };\n-\n-                    let trait_span = tcx.map.span_if_local(ty_trait_item.def_id());\n-                    if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n+                    let trait_span = tcx.map.span_if_local(ty_trait_item.def_id);\n+                    if ty_trait_item.kind == ty::AssociatedKind::Method {\n                         let err_count = tcx.sess.err_count();\n                         compare_impl_method(ccx,\n-                                            &impl_method,\n+                                            &ty_impl_item,\n                                             impl_item.span,\n                                             body.id,\n-                                            &trait_method,\n-                                            &impl_trait_ref,\n+                                            &ty_trait_item,\n+                                            impl_trait_ref,\n                                             trait_span,\n                                             true); // start with old-broken-mode\n                         if err_count == tcx.sess.err_count() {\n                             // old broken mode did not report an error. Try with the new mode.\n                             compare_impl_method(ccx,\n-                                                &impl_method,\n+                                                &ty_impl_item,\n                                                 impl_item.span,\n                                                 body.id,\n-                                                &trait_method,\n-                                                &impl_trait_ref,\n+                                                &ty_trait_item,\n+                                                impl_trait_ref,\n                                                 trait_span,\n                                                 false); // use the new mode\n                         }\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n                                   \"item `{}` is an associated method, \\\n                                   which doesn't match its trait `{:?}`\",\n-                                  impl_method.name,\n+                                  ty_impl_item.name,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, &format!(\"does not match trait\"));\n-                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id()) {\n+                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, &format!(\"item in trait\"));\n                          }\n                          err.emit()\n                     }\n                 }\n                 hir::ImplItemKind::Type(_) => {\n-                    let impl_type = match ty_impl_item {\n-                        ty::TypeTraitItem(ref tti) => tti,\n-                        _ => span_bug!(impl_item.span, \"non-type impl-item for type\")\n-                    };\n-\n-                    if let &ty::TypeTraitItem(ref at) = ty_trait_item {\n-                        if let Some(_) = at.ty {\n+                    if ty_trait_item.kind == ty::AssociatedKind::Type {\n+                        if ty_trait_item.has_value {\n                             overridden_associated_type = Some(impl_item);\n                         }\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0325,\n                                   \"item `{}` is an associated type, \\\n                                   which doesn't match its trait `{:?}`\",\n-                                  impl_type.name,\n+                                  ty_impl_item.name,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, &format!(\"does not match trait\"));\n-                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id()) {\n+                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, &format!(\"item in trait\"));\n                          }\n                          err.emit()\n@@ -1091,70 +1121,55 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n \n     // Check for missing items from trait\n-    let provided_methods = tcx.provided_trait_methods(impl_trait_ref.def_id);\n     let mut missing_items = Vec::new();\n     let mut invalidated_items = Vec::new();\n     let associated_type_overridden = overridden_associated_type.is_some();\n-    for trait_item in trait_items.iter() {\n-        let is_implemented;\n-        let is_provided;\n-\n-        match *trait_item {\n-            ty::ConstTraitItem(ref associated_const) => {\n-                is_provided = associated_const.has_value;\n-                is_implemented = impl_items.iter().any(|ii| {\n-                    match ii.node {\n-                        hir::ImplItemKind::Const(..) => {\n-                            ii.name == associated_const.name\n-                        }\n-                        _ => false,\n-                    }\n-                });\n-            }\n-            ty::MethodTraitItem(ref trait_method) => {\n-                is_provided = provided_methods.iter().any(|m| m.name == trait_method.name);\n-                is_implemented = trait_def.ancestors(impl_id)\n-                    .fn_defs(tcx, trait_method.name)\n-                    .next()\n-                    .map(|node_item| !node_item.node.is_from_trait())\n-                    .unwrap_or(false);\n-            }\n-            ty::TypeTraitItem(ref trait_assoc_ty) => {\n-                is_provided = trait_assoc_ty.ty.is_some();\n-                is_implemented = trait_def.ancestors(impl_id)\n-                    .type_defs(tcx, trait_assoc_ty.name)\n-                    .next()\n-                    .map(|node_item| !node_item.node.is_from_trait())\n-                    .unwrap_or(false);\n-            }\n-        }\n+    for trait_item in tcx.associated_items(impl_trait_ref.def_id) {\n+        let is_implemented = trait_def.ancestors(impl_id)\n+            .defs(tcx, trait_item.name, trait_item.kind)\n+            .next()\n+            .map(|node_item| !node_item.node.is_from_trait())\n+            .unwrap_or(false);\n \n         if !is_implemented {\n-            if !is_provided {\n+            if !trait_item.has_value {\n                 missing_items.push(trait_item);\n             } else if associated_type_overridden {\n-                invalidated_items.push(trait_item.name());\n+                invalidated_items.push(trait_item.name);\n             }\n         }\n     }\n \n+    let signature = |item: &ty::AssociatedItem| {\n+        match item.kind {\n+            ty::AssociatedKind::Method => {\n+                format!(\"{}\", tcx.lookup_item_type(item.def_id).ty.fn_sig().0)\n+            }\n+            ty::AssociatedKind::Type => format!(\"type {};\", item.name.to_string()),\n+            ty::AssociatedKind::Const => {\n+                format!(\"const {}: {:?};\", item.name.to_string(),\n+                        tcx.lookup_item_type(item.def_id).ty)\n+            }\n+        }\n+    };\n+\n     if !missing_items.is_empty() {\n         let mut err = struct_span_err!(tcx.sess, impl_span, E0046,\n             \"not all trait items implemented, missing: `{}`\",\n             missing_items.iter()\n-                  .map(|trait_item| trait_item.name().to_string())\n+                  .map(|trait_item| trait_item.name.to_string())\n                   .collect::<Vec<_>>().join(\"`, `\"));\n         err.span_label(impl_span, &format!(\"missing `{}` in implementation\",\n                 missing_items.iter()\n-                    .map(|trait_item| trait_item.name().to_string())\n+                    .map(|trait_item| trait_item.name.to_string())\n                     .collect::<Vec<_>>().join(\"`, `\")));\n         for trait_item in missing_items {\n-            if let Some(span) = tcx.map.span_if_local(trait_item.def_id()) {\n-                err.span_label(span, &format!(\"`{}` from trait\", trait_item.name()));\n+            if let Some(span) = tcx.map.span_if_local(trait_item.def_id) {\n+                err.span_label(span, &format!(\"`{}` from trait\", trait_item.name));\n             } else {\n                 err.note(&format!(\"`{}` from trait: `{}`\",\n-                                  trait_item.name(),\n-                                  signature(trait_item)));\n+                                  trait_item.name,\n+                                  signature(&trait_item)));\n             }\n         }\n         err.emit();\n@@ -1172,14 +1187,6 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn signature<'a, 'tcx>(item: &ty::ImplOrTraitItem) -> String {\n-    match *item {\n-        ty::MethodTraitItem(ref item) => format!(\"{}\", item.fty.sig.0),\n-        ty::TypeTraitItem(ref item) => format!(\"type {};\", item.name.to_string()),\n-        ty::ConstTraitItem(ref item) => format!(\"const {}: {:?};\", item.name.to_string(), item.ty),\n-    }\n-}\n-\n /// Checks a constant with a given type.\n fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                                    expr: &'tcx hir::Expr,\n@@ -1198,7 +1205,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         fcx.check_expr_coercable_to_type(expr, expected_type);\n \n         fcx.select_all_obligations_and_apply_defaults();\n-        fcx.closure_analyze_const(expr);\n+        fcx.closure_analyze(expr);\n         fcx.select_obligations_where_possible();\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error();\n@@ -1385,19 +1392,6 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(r)\n     }\n \n-    fn trait_defines_associated_type_named(&self,\n-                                           trait_def_id: DefId,\n-                                           assoc_name: ast::Name)\n-                                           -> bool\n-    {\n-        self.tcx().impl_or_trait_items(trait_def_id).iter().any(|&def_id| {\n-            match self.tcx().impl_or_trait_item(def_id) {\n-                ty::TypeTraitItem(ref item) => item.name == assoc_name,\n-                _ => false\n-            }\n-        })\n-    }\n-\n     fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n         self.next_ty_var()\n     }\n@@ -1497,6 +1491,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ret_ty: rty,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n                                                      ast::CRATE_NODE_ID)),\n+            diverges: Cell::new(Diverges::Maybe),\n+            has_errors: Cell::new(false),\n             inh: inh,\n         }\n     }\n@@ -1513,6 +1509,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n+    /// Produce warning on the given node, if the current point in the\n+    /// function is unreachable, and there hasn't been another warning.\n+    fn warn_if_unreachable(&self, id: ast::NodeId, span: Span, kind: &str) {\n+        if self.diverges.get() == Diverges::Always {\n+            self.diverges.set(Diverges::WarnedAlways);\n+\n+            self.tcx.sess.add_lint(lint::builtin::UNREACHABLE_CODE,\n+                                   id, span,\n+                                   format!(\"unreachable {}\", kind));\n+        }\n+    }\n+\n     /// Resolves type variables in `ty` if possible. Unlike the infcx\n     /// version (resolve_type_vars_if_possible), this version will\n     /// also select obligations if it seems useful, in an effort\n@@ -1583,6 +1591,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n                node_id, ty, self.tag());\n         self.tables.borrow_mut().node_types.insert(node_id, ty);\n+\n+        if ty.references_error() {\n+            self.has_errors.set(true);\n+        }\n+\n+        // FIXME(canndrew): This is_never should probably be an is_uninhabited\n+        if ty.is_never() || self.type_var_diverges(ty) {\n+            self.diverges.set(self.diverges.get() | Diverges::Always);\n+        }\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n@@ -1643,12 +1660,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// As `instantiate_type_scheme`, but for the bounds found in a\n     /// generic type scheme.\n-    fn instantiate_bounds(&self,\n-                          span: Span,\n-                          substs: &Substs<'tcx>,\n-                          bounds: &ty::GenericPredicates<'tcx>)\n-                          -> ty::InstantiatedPredicates<'tcx>\n-    {\n+    fn instantiate_bounds(&self, span: Span, def_id: DefId, substs: &Substs<'tcx>)\n+                          -> ty::InstantiatedPredicates<'tcx> {\n+        let bounds = self.tcx.lookup_predicates(def_id);\n         let result = bounds.instantiate(self.tcx, substs);\n         let result = self.normalize_associated_types_in(span, &result.predicates);\n         debug!(\"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}\",\n@@ -2518,21 +2532,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n-        // that are not anonymous functions, then we typecheck the anonymous\n-        // functions. This is so that we have more information about the types\n-        // of arguments when we typecheck the functions. This isn't really the\n-        // right way to do this.\n-        let xs = [false, true];\n-        let mut any_diverges = false; // has any of the arguments diverged?\n-        let mut warned = false; // have we already warned about unreachable code?\n-        for check_blocks in &xs {\n-            let check_blocks = *check_blocks;\n-            debug!(\"check_blocks={}\", check_blocks);\n+        // that are not closures, then we typecheck the closures. This is so\n+        // that we have more information about the types of arguments when we\n+        // typecheck the functions. This isn't really the right way to do this.\n+        for &check_closures in &[false, true] {\n+            debug!(\"check_closures={}\", check_closures);\n \n             // More awful hacks: before we check argument types, try to do\n             // an \"opportunistic\" vtable resolution of any trait bounds on\n             // the call. This helps coercions.\n-            if check_blocks {\n+            if check_closures {\n                 self.select_obligations_where_possible();\n             }\n \n@@ -2547,61 +2556,43 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 supplied_arg_count\n             };\n             for (i, arg) in args.iter().take(t).enumerate() {\n-                if any_diverges && !warned {\n-                    self.tcx\n-                        .sess\n-                        .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                                  arg.id,\n-                                  arg.span,\n-                                  \"unreachable expression\".to_string());\n-                    warned = true;\n+                // Warn only for the first loop (the \"no closures\" one).\n+                // Closure arguments themselves can't be diverging, but\n+                // a previous argument can, e.g. `foo(panic!(), || {})`.\n+                if !check_closures {\n+                    self.warn_if_unreachable(arg.id, arg.span, \"expression\");\n                 }\n-                let is_block = match arg.node {\n+\n+                let is_closure = match arg.node {\n                     hir::ExprClosure(..) => true,\n                     _ => false\n                 };\n \n-                if is_block == check_blocks {\n-                    debug!(\"checking the argument\");\n-                    let formal_ty = formal_tys[i];\n+                if is_closure != check_closures {\n+                    continue;\n+                }\n \n-                    // The special-cased logic below has three functions:\n-                    // 1. Provide as good of an expected type as possible.\n-                    let expected = expected_arg_tys.get(i).map(|&ty| {\n-                        Expectation::rvalue_hint(self, ty)\n-                    });\n+                debug!(\"checking the argument\");\n+                let formal_ty = formal_tys[i];\n \n-                    let checked_ty = self.check_expr_with_expectation(&arg,\n-                                            expected.unwrap_or(ExpectHasType(formal_ty)));\n-                    // 2. Coerce to the most detailed type that could be coerced\n-                    //    to, which is `expected_ty` if `rvalue_hint` returns an\n-                    //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n-                    let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n-                    self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty));\n-\n-                    // 3. Relate the expected type and the formal one,\n-                    //    if the expected type was used for the coercion.\n-                    coerce_ty.map(|ty| self.demand_suptype(arg.span, formal_ty, ty));\n-                }\n+                // The special-cased logic below has three functions:\n+                // 1. Provide as good of an expected type as possible.\n+                let expected = expected_arg_tys.get(i).map(|&ty| {\n+                    Expectation::rvalue_hint(self, ty)\n+                });\n \n-                if let Some(&arg_ty) = self.tables.borrow().node_types.get(&arg.id) {\n-                    // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-                    any_diverges = any_diverges ||\n-                                   self.type_var_diverges(arg_ty) ||\n-                                   arg_ty.is_never();\n-                }\n+                let checked_ty = self.check_expr_with_expectation(&arg,\n+                                        expected.unwrap_or(ExpectHasType(formal_ty)));\n+                // 2. Coerce to the most detailed type that could be coerced\n+                //    to, which is `expected_ty` if `rvalue_hint` returns an\n+                //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n+                let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n+                self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty));\n+\n+                // 3. Relate the expected type and the formal one,\n+                //    if the expected type was used for the coercion.\n+                coerce_ty.map(|ty| self.demand_suptype(arg.span, formal_ty, ty));\n             }\n-            if any_diverges && !warned {\n-                let parent = self.tcx.map.get_parent_node(args[0].id);\n-                self.tcx\n-                    .sess\n-                    .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                              parent,\n-                              sp,\n-                              \"unreachable call\".to_string());\n-                warned = true;\n-            }\n-\n         }\n \n         // We also need to make sure we at least write the ty of the other\n@@ -2852,18 +2843,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        sp: Span,\n                        expected: Expectation<'tcx>) -> Ty<'tcx> {\n         let cond_ty = self.check_expr_has_type(cond_expr, self.tcx.types.bool);\n+        let cond_diverges = self.diverges.get();\n+        self.diverges.set(Diverges::Maybe);\n \n         let expected = expected.adjust_for_branches(self);\n         let then_ty = self.check_block_with_expected(then_blk, expected);\n+        let then_diverges = self.diverges.get();\n+        self.diverges.set(Diverges::Maybe);\n \n         let unit = self.tcx.mk_nil();\n         let (origin, expected, found, result) =\n         if let Some(else_expr) = opt_else_expr {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n-            let origin = TypeOrigin::IfExpression(sp);\n+            let else_diverges = self.diverges.get();\n \n             // Only try to coerce-unify if we have a then expression\n             // to assign coercions to, otherwise it's () or diverging.\n+            let origin = TypeOrigin::IfExpression(sp);\n             let result = if let Some(ref then) = then_blk.expr {\n                 let res = self.try_find_coercion_lub(origin, || Some(&**then),\n                                                      then_ty, else_expr, else_ty);\n@@ -2889,8 +2885,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         })\n                 })\n             };\n+\n+            // We won't diverge unless both branches do (or the condition does).\n+            self.diverges.set(cond_diverges | then_diverges & else_diverges);\n+\n             (origin, then_ty, else_ty, result)\n         } else {\n+            // If the condition is false we can't diverge.\n+            self.diverges.set(cond_diverges);\n+\n             let origin = TypeOrigin::IfExpressionWithNoElse(sp);\n             (origin, unit, then_ty,\n              self.eq_types(true, origin, unit, then_ty)\n@@ -3279,8 +3282,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((variant, did, substs)) = variant {\n             // Check bounds on type arguments used in the path.\n-            let type_predicates = self.tcx.lookup_predicates(did);\n-            let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);\n+            let bounds = self.instantiate_bounds(path.span, did, substs);\n             let cause = traits::ObligationCause::new(path.span, self.body_id,\n                                                      traits::ItemObligation(did));\n             self.add_obligations_for_parameters(cause, &bounds);\n@@ -3352,10 +3354,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                    lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n         debug!(\">> typechecking: expr={:?} expected={:?}\",\n                expr, expected);\n+\n+        // Warn for expressions after diverging siblings.\n+        self.warn_if_unreachable(expr.id, expr.span, \"expression\");\n+\n+        // Hide the outer diverging and has_errors flags.\n+        let old_diverges = self.diverges.get();\n+        let old_has_errors = self.has_errors.get();\n+        self.diverges.set(Diverges::Maybe);\n+        self.has_errors.set(false);\n+\n         let ty = self.check_expr_kind(expr, expected, lvalue_pref);\n \n+        // Warn for non-block expressions with diverging children.\n+        match expr.node {\n+            hir::ExprBlock(_) |\n+            hir::ExprLoop(..) | hir::ExprWhile(..) |\n+            hir::ExprIf(..) | hir::ExprMatch(..) => {}\n+\n+            _ => self.warn_if_unreachable(expr.id, expr.span, \"expression\")\n+        }\n+\n+        // Record the type, which applies it effects.\n+        // We need to do this after the warning above, so that\n+        // we don't warn for the diverging expression itself.\n         self.write_ty(expr.id, ty);\n \n+        // Combine the diverging and has_error flags.\n+        self.diverges.set(self.diverges.get() | old_diverges);\n+        self.has_errors.set(self.has_errors.get() | old_has_errors);\n+\n         debug!(\"type of expr({}) {} is...\", expr.id,\n                pprust::expr_to_string(expr));\n         debug!(\"... {:?}, expected is {:?}\",\n@@ -3580,22 +3608,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  expr.span, expected)\n           }\n           hir::ExprWhile(ref cond, ref body, _) => {\n-            let cond_ty = self.check_expr_has_type(&cond, tcx.types.bool);\n+            self.check_expr_has_type(&cond, tcx.types.bool);\n+            let cond_diverging = self.diverges.get();\n             self.check_block_no_value(&body);\n-            let body_ty = self.node_ty(body.id);\n-            if cond_ty.references_error() || body_ty.references_error() {\n+\n+            // We may never reach the body so it diverging means nothing.\n+            self.diverges.set(cond_diverging);\n+\n+            if self.has_errors.get() {\n                 tcx.types.err\n-            }\n-            else {\n+            } else {\n                 tcx.mk_nil()\n             }\n           }\n           hir::ExprLoop(ref body, _) => {\n             self.check_block_no_value(&body);\n-            if !may_break(tcx, expr.id, &body) {\n-                tcx.types.never\n-            } else {\n+            if may_break(tcx, expr.id, &body) {\n+                // No way to know whether it's diverging because\n+                // of a `break` or an outer `break` or `return.\n+                self.diverges.set(Diverges::Maybe);\n+\n                 tcx.mk_nil()\n+            } else {\n+                tcx.types.never\n             }\n           }\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n@@ -3928,55 +3963,66 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_stmt(&self, stmt: &'gcx hir::Stmt) {\n-        let node_id;\n-        let mut saw_bot = false;\n-        let mut saw_err = false;\n+        // Don't do all the complex logic below for DeclItem.\n         match stmt.node {\n-          hir::StmtDecl(ref decl, id) => {\n-            node_id = id;\n-            match decl.node {\n-              hir::DeclLocal(ref l) => {\n-                  self.check_decl_local(&l);\n-                  let l_t = self.node_ty(l.id);\n-                  saw_bot = saw_bot || self.type_var_diverges(l_t);\n-                  saw_err = saw_err || l_t.references_error();\n-              }\n-              hir::DeclItem(_) => {/* ignore for now */ }\n+            hir::StmtDecl(ref decl, id) => {\n+                match decl.node {\n+                    hir::DeclLocal(_) => {}\n+                    hir::DeclItem(_) => {\n+                        self.write_nil(id);\n+                        return;\n+                    }\n+                }\n             }\n-          }\n-          hir::StmtExpr(ref expr, id) => {\n-            node_id = id;\n-            // Check with expected type of ()\n-            let ty = self.check_expr_has_type(&expr, self.tcx.mk_nil());\n-            saw_bot = saw_bot || self.type_var_diverges(ty);\n-            saw_err = saw_err || ty.references_error();\n-          }\n-          hir::StmtSemi(ref expr, id) => {\n-            node_id = id;\n-            let ty = self.check_expr(&expr);\n-            saw_bot |= self.type_var_diverges(ty);\n-            saw_err |= ty.references_error();\n-          }\n-        }\n-        if saw_bot {\n-            self.write_ty(node_id, self.next_diverging_ty_var());\n+            hir::StmtExpr(..) | hir::StmtSemi(..) => {}\n         }\n-        else if saw_err {\n+\n+        self.warn_if_unreachable(stmt.node.id(), stmt.span, \"statement\");\n+\n+        // Hide the outer diverging and has_errors flags.\n+        let old_diverges = self.diverges.get();\n+        let old_has_errors = self.has_errors.get();\n+        self.diverges.set(Diverges::Maybe);\n+        self.has_errors.set(false);\n+\n+        let node_id = match stmt.node {\n+            hir::StmtDecl(ref decl, id) => {\n+                match decl.node {\n+                    hir::DeclLocal(ref l) => {\n+                        self.check_decl_local(&l);\n+                    }\n+                    hir::DeclItem(_) => {/* ignore for now */ }\n+                }\n+                id\n+            }\n+            hir::StmtExpr(ref expr, id) => {\n+                // Check with expected type of ()\n+                self.check_expr_has_type(&expr, self.tcx.mk_nil());\n+                id\n+            }\n+            hir::StmtSemi(ref expr, id) => {\n+                self.check_expr(&expr);\n+                id\n+            }\n+        };\n+\n+        if self.has_errors.get() {\n             self.write_error(node_id);\n-        }\n-        else {\n+        } else if self.diverges.get().always() {\n+            self.write_ty(node_id, self.next_diverging_ty_var());\n+        } else {\n             self.write_nil(node_id);\n         }\n+\n+        // Combine the diverging and has_error flags.\n+        self.diverges.set(self.diverges.get() | old_diverges);\n+        self.has_errors.set(self.has_errors.get() | old_has_errors);\n     }\n \n     pub fn check_block_no_value(&self, blk: &'gcx hir::Block)  {\n-        let blkty = self.check_block_with_expected(blk, ExpectHasType(self.tcx.mk_nil()));\n-        if blkty.references_error() {\n-            self.write_error(blk.id);\n-        } else {\n-            let nilty = self.tcx.mk_nil();\n-            self.demand_suptype(blk.span, nilty, blkty);\n-        }\n+        let unit = self.tcx.mk_nil();\n+        let ty = self.check_block_with_expected(blk, ExpectHasType(unit));\n+        self.demand_suptype(blk.span, unit, ty);\n     }\n \n     fn check_block_with_expected(&self,\n@@ -3988,72 +4034,81 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             replace(&mut *fcx_ps, unsafety_state)\n         };\n \n-        let mut warned = false;\n-        let mut any_diverges = false;\n-        let mut any_err = false;\n         for s in &blk.stmts {\n             self.check_stmt(s);\n-            let s_id = s.node.id();\n-            let s_ty = self.node_ty(s_id);\n-            if any_diverges && !warned && match s.node {\n-                hir::StmtDecl(ref decl, _) => {\n-                    match decl.node {\n-                        hir::DeclLocal(_) => true,\n-                        _ => false,\n+        }\n+\n+        let mut ty = match blk.expr {\n+            Some(ref e) => self.check_expr_with_expectation(e, expected),\n+            None => self.tcx.mk_nil()\n+        };\n+\n+        if self.diverges.get().always() {\n+            if let ExpectHasType(ety) = expected {\n+                // Avoid forcing a type (only `!` for now) in unreachable code.\n+                // FIXME(aburka) do we need this special case? and should it be is_uninhabited?\n+                if !ety.is_never() {\n+                    if let Some(ref e) = blk.expr {\n+                        // Coerce the tail expression to the right type.\n+                        self.demand_coerce(e, ty, ety);\n                     }\n                 }\n-                hir::StmtExpr(..) | hir::StmtSemi(..) => true,\n-            } {\n-                self.tcx\n-                    .sess\n-                    .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                              s_id,\n-                              s.span,\n-                              \"unreachable statement\".to_string());\n-                warned = true;\n             }\n-            // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-            any_diverges = any_diverges ||\n-                           self.type_var_diverges(s_ty) ||\n-                           s_ty.is_never();\n-            any_err = any_err || s_ty.references_error();\n-        }\n-        let ty = match blk.expr {\n-            None => if any_err {\n-                self.tcx.types.err\n-            } else if any_diverges {\n-                self.next_diverging_ty_var()\n+\n+            ty = self.next_diverging_ty_var();\n+        } else if let ExpectHasType(ety) = expected {\n+            if let Some(ref e) = blk.expr {\n+                // Coerce the tail expression to the right type.\n+                self.demand_coerce(e, ty, ety);\n             } else {\n-                self.tcx.mk_nil()\n-            },\n-            Some(ref e) => {\n-                if any_diverges && !warned {\n-                    self.tcx\n-                        .sess\n-                        .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                                  e.id,\n-                                  e.span,\n-                                  \"unreachable expression\".to_string());\n-                }\n-                let ety = match expected {\n-                    ExpectHasType(ety) => {\n-                        self.check_expr_coercable_to_type(&e, ety);\n-                        ety\n-                    }\n-                    _ => {\n-                        self.check_expr_with_expectation(&e, expected)\n-                    }\n-                };\n+                // We're not diverging and there's an expected type, which,\n+                // in case it's not `()`, could result in an error higher-up.\n+                // We have a chance to error here early and be more helpful.\n+                let origin = TypeOrigin::Misc(blk.span);\n+                let trace = TypeTrace::types(origin, false, ty, ety);\n+                match self.sub_types(false, origin, ty, ety) {\n+                    Ok(InferOk { obligations, .. }) => {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                    },\n+                    Err(err) => {\n+                        let mut err = self.report_and_explain_type_error(trace, &err);\n+\n+                        // Be helpful when the user wrote `{... expr;}` and\n+                        // taking the `;` off is enough to fix the error.\n+                        let mut extra_semi = None;\n+                        if let Some(stmt) = blk.stmts.last() {\n+                            if let hir::StmtSemi(ref e, _) = stmt.node {\n+                                if self.can_sub_types(self.node_ty(e.id), ety).is_ok() {\n+                                    extra_semi = Some(stmt);\n+                                }\n+                            }\n+                        }\n+                        if let Some(last_stmt) = extra_semi {\n+                            let original_span = original_sp(self.tcx.sess.codemap(),\n+                                                            last_stmt.span, blk.span);\n+                            let span_semi = Span {\n+                                lo: original_span.hi - BytePos(1),\n+                                hi: original_span.hi,\n+                                expn_id: original_span.expn_id\n+                            };\n+                            err.span_help(span_semi, \"consider removing this semicolon:\");\n+                        }\n \n-                if any_err {\n-                    self.tcx.types.err\n-                } else if any_diverges {\n-                    self.next_diverging_ty_var()\n-                } else {\n-                    ety\n+                        err.emit();\n+                    }\n                 }\n             }\n-        };\n+\n+            // We already applied the type (and potentially errored),\n+            // use the expected type to avoid further errors out.\n+            ty = ety;\n+        }\n+\n+        if self.has_errors.get() || ty.references_error() {\n+            ty = self.tcx.types.err\n+        }\n+\n         self.write_ty(blk.id, ty);\n \n         *self.ps.borrow_mut() = prev;\n@@ -4149,7 +4204,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // Case 3. Reference to a method or associated const.\n             Def::Method(def_id) |\n             Def::AssociatedConst(def_id) => {\n-                let container = self.tcx.impl_or_trait_item(def_id).container();\n+                let container = self.tcx.associated_item(def_id).container;\n                 match container {\n                     ty::TraitContainer(trait_did) => {\n                         callee::check_legal_trait_for_method_call(self.ccx, span, trait_did)\n@@ -4290,13 +4345,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n         let scheme = self.tcx.lookup_item_type(def.def_id());\n-        let type_predicates = self.tcx.lookup_predicates(def.def_id());\n         assert!(!substs.has_escaping_regions());\n         assert!(!scheme.ty.has_escaping_regions());\n \n         // Add all the obligations that are required, substituting and\n         // normalized appropriately.\n-        let bounds = self.instantiate_bounds(span, &substs, &type_predicates);\n+        let bounds = self.instantiate_bounds(span, def.def_id(), &substs);\n         self.add_obligations_for_parameters(\n             traits::ObligationCause::new(span, self.body_id, traits::ItemObligation(def.def_id())),\n             &bounds);"}, {"sha": "8b4975b7e3a2f723331219af60397986596beed3", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -75,8 +75,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n                 // && and || are a simple case.\n+                let lhs_diverges = self.diverges.get();\n                 self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n                 self.check_expr_coercable_to_type(rhs_expr, tcx.mk_bool());\n+\n+                // Depending on the LHS' value, the RHS can never execute.\n+                self.diverges.set(lhs_diverges);\n+\n                 tcx.mk_bool()\n             }\n             _ => {"}, {"sha": "d4e5e9a5bb355f5b0520b77f2574c23d6ff598dd", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -142,13 +142,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_fn(&self,\n                        fn_id: ast::NodeId,\n                        decl: &hir::FnDecl,\n-                       blk: &hir::Block) {\n+                       body: &hir::Expr) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(blk.id), blk.id, Subject(fn_id));\n+        let mut rcx = RegionCtxt::new(self, RepeatingScope(body.id), body.id, Subject(fn_id));\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, decl, blk, self.tcx.map.span(fn_id));\n+            rcx.visit_fn_body(fn_id, decl, body, self.tcx.map.span(fn_id));\n         }\n \n         rcx.free_region_map.relate_free_regions_from_predicates(\n@@ -268,7 +268,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn visit_fn_body(&mut self,\n                      id: ast::NodeId, // the id of the fn itself\n                      fn_decl: &hir::FnDecl,\n-                     body: &hir::Block,\n+                     body: &hir::Expr,\n                      span: Span)\n     {\n         // When we enter a function, we can derive\n@@ -305,7 +305,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.relate_free_regions(&fn_sig_tys[..], body.id, span);\n         self.link_fn_args(self.tcx.region_maps.node_extent(body.id),\n                           &fn_decl.inputs[..]);\n-        self.visit_block(body);\n+        self.visit_expr(body);\n         self.visit_region_obligations(body.id);\n \n         let call_site_scope = self.call_site_scope.unwrap();\n@@ -480,7 +480,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n     // regions, until regionck, as described in #3238.\n \n     fn visit_fn(&mut self, _fk: intravisit::FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, span: Span, id: ast::NodeId) {\n+                b: &'v hir::Expr, span: Span, id: ast::NodeId) {\n         self.visit_fn_body(id, fd, b, span)\n     }\n \n@@ -825,7 +825,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_expr_fn_block(&mut self,\n                            expr: &hir::Expr,\n-                           body: &hir::Block) {\n+                           body: &hir::Expr) {\n         let repeating_scope = self.set_repeating_scope(body.id);\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);"}, {"sha": "2fea86cb212070844afd79696d14dc6c1100b609", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -57,18 +57,7 @@ use rustc::util::nodemap::NodeMap;\n // PUBLIC ENTRY POINTS\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn closure_analyze_fn(&self, body: &hir::Block) {\n-        let mut seed = SeedBorrowKind::new(self);\n-        seed.visit_block(body);\n-\n-        let mut adjust = AdjustBorrowKind::new(self, seed.temp_closure_kinds);\n-        adjust.visit_block(body);\n-\n-        // it's our job to process these.\n-        assert!(self.deferred_call_resolutions.borrow().is_empty());\n-    }\n-\n-    pub fn closure_analyze_const(&self, body: &hir::Expr) {\n+    pub fn closure_analyze(&self, body: &hir::Expr) {\n         let mut seed = SeedBorrowKind::new(self);\n         seed.visit_expr(body);\n \n@@ -110,7 +99,7 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n     fn check_closure(&mut self,\n                      expr: &hir::Expr,\n                      capture_clause: hir::CaptureClause,\n-                     _body: &hir::Block)\n+                     _body: &hir::Expr)\n     {\n         let closure_def_id = self.fcx.tcx.map.local_def_id(expr.id);\n         if !self.fcx.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n@@ -164,7 +153,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                        id: ast::NodeId,\n                        span: Span,\n                        decl: &hir::FnDecl,\n-                       body: &hir::Block) {\n+                       body: &hir::Expr) {\n         /*!\n          * Analysis starting point.\n          */\n@@ -497,7 +486,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     fn visit_fn(&mut self,\n                 fn_kind: intravisit::FnKind<'v>,\n                 decl: &'v hir::FnDecl,\n-                body: &'v hir::Block,\n+                body: &'v hir::Expr,\n                 span: Span,\n                 id: ast::NodeId)\n     {"}, {"sha": "4136f543cccaf2dd2c1f477141947bb6430f11dc", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 60, "deletions": 55, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use astconv::ExplicitSelf;\n use check::FnCtxt;\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n+\n use hir::def_id::DefId;\n use middle::region::{CodeExtent};\n use rustc::infer::TypeOrigin;\n@@ -156,8 +158,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n                 self.check_variances_for_type_defn(item, ast_generics);\n             }\n-            hir::ItemTrait(.., ref items) => {\n-                self.check_trait(item, items);\n+            hir::ItemTrait(..) => {\n+                self.check_trait(item);\n             }\n             _ => {}\n         }\n@@ -172,32 +174,39 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let free_substs = &fcx.parameter_environment.free_substs;\n             let free_id_outlive = fcx.parameter_environment.free_id_outlive;\n \n-            let item = fcx.tcx.impl_or_trait_item(fcx.tcx.map.local_def_id(item_id));\n+            let item = fcx.tcx.associated_item(fcx.tcx.map.local_def_id(item_id));\n \n-            let (mut implied_bounds, self_ty) = match item.container() {\n+            let (mut implied_bounds, self_ty) = match item.container {\n                 ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n                 ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n                                               fcx.tcx.lookup_item_type(def_id).ty)\n             };\n \n-            match item {\n-                ty::ConstTraitItem(assoc_const) => {\n-                    let ty = fcx.instantiate_type_scheme(span, free_substs, &assoc_const.ty);\n+            match item.kind {\n+                ty::AssociatedKind::Const => {\n+                    let ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                    let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n-                ty::MethodTraitItem(method) => {\n-                    reject_shadowing_type_parameters(fcx.tcx, span, &method.generics);\n-                    let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n-                    let predicates = fcx.instantiate_bounds(span, free_substs, &method.predicates);\n-                    this.check_fn_or_method(fcx, span, &method_ty, &predicates,\n+                ty::AssociatedKind::Method => {\n+                    reject_shadowing_type_parameters(fcx.tcx, span, item.def_id);\n+                    let method_ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                    let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n+                    let predicates = fcx.instantiate_bounds(span, item.def_id, free_substs);\n+                    let fty = match method_ty.sty {\n+                        ty::TyFnDef(_, _, f) => f,\n+                        _ => bug!()\n+                    };\n+                    this.check_fn_or_method(fcx, span, fty, &predicates,\n                                             free_id_outlive, &mut implied_bounds);\n                     let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n-                    this.check_method_receiver(fcx, sig_if_method, &method,\n+                    this.check_method_receiver(fcx, sig_if_method, &item,\n                                                free_id_outlive, self_ty);\n                 }\n-                ty::TypeTraitItem(assoc_type) => {\n-                    if let Some(ref ty) = assoc_type.ty {\n-                        let ty = fcx.instantiate_type_scheme(span, free_substs, ty);\n+                ty::AssociatedKind::Type => {\n+                    if item.has_value {\n+                        let ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                        let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                         fcx.register_wf_obligation(ty, span, code.clone());\n                     }\n                 }\n@@ -248,19 +257,15 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             }\n \n             let free_substs = &fcx.parameter_environment.free_substs;\n-            let predicates = fcx.tcx.lookup_predicates(fcx.tcx.map.local_def_id(item.id));\n-            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            let def_id = fcx.tcx.map.local_def_id(item.id);\n+            let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n             vec![] // no implied bounds in a struct def'n\n         });\n     }\n \n-    fn check_auto_trait(&mut self,\n-                        trait_def_id: DefId,\n-                        items: &[hir::TraitItem],\n-                        span: Span)\n-    {\n+    fn check_auto_trait(&mut self, trait_def_id: DefId, span: Span) {\n         // We want to ensure:\n         //\n         // 1) that there are no items contained within\n@@ -302,7 +307,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         // extraneous predicates created by things like\n         // an associated type inside the trait.\n         let mut err = None;\n-        if !items.is_empty() {\n+        if !self.tcx().associated_item_def_ids(trait_def_id).is_empty() {\n             error_380(self.ccx, span);\n         } else if has_ty_params {\n             err = Some(struct_span_err!(self.tcx().sess, span, E0567,\n@@ -326,32 +331,29 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         }\n     }\n \n-    fn check_trait(&mut self,\n-                   item: &hir::Item,\n-                   items: &[hir::TraitItem])\n-    {\n+    fn check_trait(&mut self, item: &hir::Item) {\n         let trait_def_id = self.tcx().map.local_def_id(item.id);\n \n         if self.tcx().trait_has_default_impl(trait_def_id) {\n-            self.check_auto_trait(trait_def_id, items, item.span);\n+            self.check_auto_trait(trait_def_id, item.span);\n         }\n \n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n-            let predicates = fcx.tcx.lookup_predicates(trait_def_id);\n-            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            let predicates = fcx.instantiate_bounds(item.span, trait_def_id, free_substs);\n             this.check_where_clauses(fcx, item.span, &predicates);\n             vec![]\n         });\n     }\n \n     fn check_item_fn(&mut self,\n                      item: &hir::Item,\n-                     body: &hir::Block)\n+                     body: &hir::Expr)\n     {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n-            let type_scheme = fcx.tcx.lookup_item_type(fcx.tcx.map.local_def_id(item.id));\n+            let def_id = fcx.tcx.map.local_def_id(item.id);\n+            let type_scheme = fcx.tcx.lookup_item_type(def_id);\n             let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n             let bare_fn_ty = match item_ty.sty {\n                 ty::TyFnDef(.., ref bare_fn_ty) => bare_fn_ty,\n@@ -360,8 +362,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 }\n             };\n \n-            let predicates = fcx.tcx.lookup_predicates(fcx.tcx.map.local_def_id(item.id));\n-            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n \n             let mut implied_bounds = vec![];\n             let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body.id);\n@@ -422,8 +423,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 }\n             }\n \n-            let predicates = fcx.tcx.lookup_predicates(item_def_id);\n-            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            let predicates = fcx.instantiate_bounds(item.span, item_def_id, free_substs);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n             fcx.impl_implied_bounds(fcx.tcx.map.local_def_id(item.id), item.span)\n@@ -476,43 +476,47 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     fn check_method_receiver<'fcx, 'tcx>(&mut self,\n                                          fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                          method_sig: &hir::MethodSig,\n-                                         method: &ty::Method<'tcx>,\n+                                         method: &ty::AssociatedItem,\n                                          free_id_outlive: CodeExtent,\n                                          self_ty: ty::Ty<'tcx>)\n     {\n         // check that the type of the method's receiver matches the\n         // method's first parameter.\n-        debug!(\"check_method_receiver({:?},cat={:?},self_ty={:?})\",\n-               method.name, method.explicit_self, self_ty);\n+        debug!(\"check_method_receiver({:?}, self_ty={:?})\",\n+               method, self_ty);\n \n-        let rcvr_ty = match method.explicit_self {\n-            ty::ExplicitSelfCategory::Static => return,\n-            ty::ExplicitSelfCategory::ByValue => self_ty,\n-            ty::ExplicitSelfCategory::ByReference(region, mutability) => {\n-                fcx.tcx.mk_ref(region, ty::TypeAndMut {\n-                    ty: self_ty,\n-                    mutbl: mutability\n-                })\n-            }\n-            ty::ExplicitSelfCategory::ByBox => fcx.tcx.mk_box(self_ty)\n-        };\n+        if !method.method_has_self_argument {\n+            return;\n+        }\n \n         let span = method_sig.decl.inputs[0].pat.span;\n \n         let free_substs = &fcx.parameter_environment.free_substs;\n-        let fty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n-        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.sig);\n+        let method_ty = fcx.tcx.lookup_item_type(method.def_id).ty;\n+        let fty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n+        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.fn_sig());\n \n         debug!(\"check_method_receiver: sig={:?}\", sig);\n \n+        let self_arg_ty = sig.inputs[0];\n+        let rcvr_ty = match ExplicitSelf::determine(self_ty, self_arg_ty) {\n+            ExplicitSelf::ByValue => self_ty,\n+            ExplicitSelf::ByReference(region, mutbl) => {\n+                fcx.tcx.mk_ref(region, ty::TypeAndMut {\n+                    ty: self_ty,\n+                    mutbl: mutbl\n+                })\n+            }\n+            ExplicitSelf::ByBox => fcx.tcx.mk_box(self_ty)\n+        };\n         let rcvr_ty = fcx.instantiate_type_scheme(span, free_substs, &rcvr_ty);\n         let rcvr_ty = fcx.tcx.liberate_late_bound_regions(free_id_outlive,\n                                                           &ty::Binder(rcvr_ty));\n \n         debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n \n         let origin = TypeOrigin::MethodReceiver(span);\n-        fcx.demand_eqtype_with_origin(origin, rcvr_ty, sig.inputs[0]);\n+        fcx.demand_eqtype_with_origin(origin, rcvr_ty, self_arg_ty);\n     }\n \n     fn check_variances_for_type_defn(&self,\n@@ -578,7 +582,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     }\n }\n \n-fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, generics: &ty::Generics) {\n+fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, def_id: DefId) {\n+    let generics = tcx.lookup_generics(def_id);\n     let parent = tcx.lookup_generics(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.types\n                                        .iter()"}, {"sha": "9f3214a0d813e6e88d392810727b598a751178f3", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -49,11 +49,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn resolve_type_vars_in_fn(&self,\n                                    decl: &hir::FnDecl,\n-                                   blk: &hir::Block,\n+                                   body: &hir::Expr,\n                                    item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n-        wbcx.visit_block(blk);\n+        wbcx.visit_expr(body);\n         for arg in &decl.inputs {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n             wbcx.visit_pat(&arg.pat);"}, {"sha": "90541539c1e23551dcdfafa9ef0887eb82d3934d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -38,8 +38,6 @@ use rustc::hir::intravisit;\n use rustc::hir::{Item, ItemImpl};\n use rustc::hir;\n \n-use std::rc::Rc;\n-\n mod orphan;\n mod overlap;\n mod unsafety;\n@@ -113,8 +111,6 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         // If there are no traits, then this implementation must have a\n         // base type.\n \n-        let impl_items = self.create_impl_from_item(item);\n-\n         if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(impl_did) {\n             debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n                    trait_ref,\n@@ -144,8 +140,6 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 self.add_inherent_impl(base_def_id, impl_did);\n             }\n         }\n-\n-        tcx.impl_or_trait_item_def_ids.borrow_mut().insert(impl_did, Rc::new(impl_items));\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n@@ -161,20 +155,6 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         trait_def.record_local_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n \n-    // Converts an implementation in the AST to a vector of items.\n-    fn create_impl_from_item(&self, item: &Item) -> Vec<DefId> {\n-        match item.node {\n-            ItemImpl(.., ref impl_items) => {\n-                impl_items.iter()\n-                    .map(|impl_item| self.crate_context.tcx.map.local_def_id(impl_item.id))\n-                    .collect()\n-            }\n-            _ => {\n-                span_bug!(item.span, \"can't convert a non-impl to an impl\");\n-            }\n-        }\n-    }\n-\n     // Destructors\n     //\n \n@@ -187,10 +167,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n         let drop_trait = tcx.lookup_trait_def(drop_trait);\n \n-        let impl_items = tcx.impl_or_trait_item_def_ids.borrow();\n-\n         drop_trait.for_each_impl(tcx, |impl_did| {\n-            let items = impl_items.get(&impl_did).unwrap();\n+            let items = tcx.associated_item_def_ids(impl_did);\n             if items.is_empty() {\n                 // We'll error out later. For now, just don't ICE.\n                 return;"}, {"sha": "b5aba512a66bd6c0172c5a3b8184fd830c657002", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -48,25 +48,23 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             Value,\n         }\n \n-        fn name_and_namespace<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        def_id: DefId)\n-                                        -> (ast::Name, Namespace) {\n-            let item = tcx.impl_or_trait_item(def_id);\n-            (item.name(),\n-             match item {\n-                 ty::TypeTraitItem(..) => Namespace::Type,\n-                 ty::ConstTraitItem(..) => Namespace::Value,\n-                 ty::MethodTraitItem(..) => Namespace::Value,\n-             })\n-        }\n+        let name_and_namespace = |def_id| {\n+            let item = self.tcx.associated_item(def_id);\n+            (item.name, match item.kind {\n+                ty::AssociatedKind::Type => Namespace::Type,\n+                ty::AssociatedKind::Const |\n+                ty::AssociatedKind::Method => Namespace::Value,\n+            })\n+        };\n \n-        let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n+        let impl_items1 = self.tcx.associated_item_def_ids(impl1);\n+        let impl_items2 = self.tcx.associated_item_def_ids(impl2);\n \n-        for &item1 in &impl_items[&impl1][..] {\n-            let (name, namespace) = name_and_namespace(self.tcx, item1);\n+        for &item1 in &impl_items1[..] {\n+            let (name, namespace) = name_and_namespace(item1);\n \n-            for &item2 in &impl_items[&impl2][..] {\n-                if (name, namespace) == name_and_namespace(self.tcx, item2) {\n+            for &item2 in &impl_items2[..] {\n+                if (name, namespace) == name_and_namespace(item2) {\n                     let msg = format!(\"duplicate definitions with name `{}`\", name);\n                     let node_id = self.tcx.map.as_local_node_id(item1).unwrap();\n                     self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,"}, {"sha": "d92a98485103cd6ef4b8ad5cc1ad3db9ffa9b7c7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 54, "deletions": 183, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -66,7 +66,7 @@ use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n use rustc::ty::subst::Substs;\n-use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n+use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n use rustc::ty::util::IntTypeExt;\n use rscope::*;\n@@ -79,7 +79,6 @@ use rustc_const_math::ConstInt;\n \n use std::cell::RefCell;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::rc::Rc;\n \n use syntax::{abi, ast, attr};\n use syntax::parse::token::keywords;\n@@ -351,24 +350,6 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         })\n     }\n \n-    fn trait_defines_associated_type_named(&self,\n-                                           trait_def_id: DefId,\n-                                           assoc_name: ast::Name)\n-                                           -> bool\n-    {\n-        if let Some(trait_id) = self.tcx().map.as_local_node_id(trait_def_id) {\n-            trait_associated_type_names(self.tcx(), trait_id)\n-                .any(|name| name == assoc_name)\n-        } else {\n-            self.tcx().impl_or_trait_items(trait_def_id).iter().any(|&def_id| {\n-                match self.tcx().impl_or_trait_item(def_id) {\n-                    ty::TypeTraitItem(ref item) => item.name == assoc_name,\n-                    _ => false\n-                }\n-            })\n-        }\n-    }\n-\n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n         None\n     }\n@@ -557,60 +538,6 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                            container: ImplOrTraitItemContainer,\n-                            name: ast::Name,\n-                            id: ast::NodeId,\n-                            vis: &hir::Visibility,\n-                            sig: &hir::MethodSig,\n-                            defaultness: hir::Defaultness,\n-                            has_body: bool,\n-                            untransformed_rcvr_ty: Ty<'tcx>,\n-                            rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n-    let def_id = ccx.tcx.map.local_def_id(id);\n-    let ty_generics = generics_of_def_id(ccx, def_id);\n-\n-    let ty_generic_predicates =\n-        ty_generic_predicates(ccx, &sig.generics, ty_generics.parent, vec![], false);\n-\n-    let (fty, explicit_self_category) = {\n-        let anon_scope = match container {\n-            ImplContainer(_) => Some(AnonTypeScope::new(def_id)),\n-            TraitContainer(_) => None\n-        };\n-        AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                              sig, untransformed_rcvr_ty, anon_scope)\n-    };\n-\n-    let ty_method = ty::Method {\n-        name: name,\n-        generics: ty_generics,\n-        predicates: ty_generic_predicates,\n-        fty: fty,\n-        explicit_self: explicit_self_category,\n-        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n-        defaultness: defaultness,\n-        has_body: has_body,\n-        def_id: def_id,\n-        container: container,\n-    };\n-\n-    let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                                ccx.tcx.map.span(id), def_id);\n-    let fty = ccx.tcx.mk_fn_def(def_id, substs, ty_method.fty);\n-    debug!(\"method {} (id {}) has type {:?}\",\n-            name, id, fty);\n-    ccx.tcx.tcache.borrow_mut().insert(def_id, fty);\n-    write_ty_to_tcx(ccx, id, fty);\n-    ccx.tcx.predicates.borrow_mut().insert(def_id, ty_method.predicates.clone());\n-\n-    debug!(\"writing method type: def_id={:?} mty={:?}\",\n-            def_id, ty_method);\n-\n-    ccx.tcx.impl_or_trait_items.borrow_mut().insert(def_id,\n-        ty::MethodTraitItem(Rc::new(ty_method)));\n-}\n-\n fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            struct_generics: &'tcx ty::Generics<'tcx>,\n                            struct_predicates: &ty::GenericPredicates<'tcx>,\n@@ -631,62 +558,65 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            struct_predicates.clone());\n }\n \n+fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                            container: AssociatedItemContainer,\n+                            id: ast::NodeId,\n+                            sig: &hir::MethodSig,\n+                            untransformed_rcvr_ty: Ty<'tcx>,\n+                            rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    let ty_generics = generics_of_def_id(ccx, def_id);\n+\n+    let ty_generic_predicates =\n+        ty_generic_predicates(ccx, &sig.generics, ty_generics.parent, vec![], false);\n+\n+    let anon_scope = match container {\n+        ImplContainer(_) => Some(AnonTypeScope::new(def_id)),\n+        TraitContainer(_) => None\n+    };\n+    let fty = AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n+                                    sig, untransformed_rcvr_ty, anon_scope);\n+\n+    let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n+                                ccx.tcx.map.span(id), def_id);\n+    let fty = ccx.tcx.mk_fn_def(def_id, substs, fty);\n+    ccx.tcx.tcache.borrow_mut().insert(def_id, fty);\n+    write_ty_to_tcx(ccx, id, fty);\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, ty_generic_predicates);\n+}\n+\n fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                      container: ImplOrTraitItemContainer,\n-                                      name: ast::Name,\n+                                      container: AssociatedItemContainer,\n                                       id: ast::NodeId,\n-                                      vis: &hir::Visibility,\n-                                      defaultness: hir::Defaultness,\n-                                      ty: ty::Ty<'tcx>,\n-                                      has_value: bool)\n+                                      ty: ty::Ty<'tcx>)\n {\n     let predicates = ty::GenericPredicates {\n         parent: Some(container.id()),\n         predicates: vec![]\n     };\n-    ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(id),\n-                                           predicates);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n+    ccx.tcx.tcache.borrow_mut().insert(def_id, ty);\n \n     write_ty_to_tcx(ccx, id, ty);\n-\n-    let associated_const = Rc::new(ty::AssociatedConst {\n-        name: name,\n-        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n-        defaultness: defaultness,\n-        def_id: ccx.tcx.map.local_def_id(id),\n-        container: container,\n-        ty: ty,\n-        has_value: has_value\n-    });\n-    ccx.tcx.impl_or_trait_items.borrow_mut()\n-       .insert(ccx.tcx.map.local_def_id(id), ty::ConstTraitItem(associated_const));\n }\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                     container: ImplOrTraitItemContainer,\n-                                     name: ast::Name,\n+                                     container: AssociatedItemContainer,\n                                      id: ast::NodeId,\n-                                     vis: &hir::Visibility,\n-                                     defaultness: hir::Defaultness,\n                                      ty: Option<Ty<'tcx>>)\n {\n     let predicates = ty::GenericPredicates {\n         parent: Some(container.id()),\n         predicates: vec![]\n     };\n-    ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(id),\n-                                           predicates);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n \n-    let associated_type = Rc::new(ty::AssociatedType {\n-        name: name,\n-        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n-        defaultness: defaultness,\n-        ty: ty,\n-        def_id: ccx.tcx.map.local_def_id(id),\n-        container: container\n-    });\n-    ccx.tcx.impl_or_trait_items.borrow_mut()\n-       .insert(ccx.tcx.map.local_def_id(id), ty::TypeTraitItem(associated_type));\n+    if let Some(ty) = ty {\n+        ccx.tcx.tcache.borrow_mut().insert(def_id, ty);\n+        write_ty_to_tcx(ccx, id, ty);\n+    }\n }\n \n fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n@@ -820,14 +750,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                generics: ty_generics,\n                                                ty: ty,\n                                            });\n-                    // Trait-associated constants are always public.\n-                    let public = &hir::Public;\n-                    let visibility = if opt_trait_ref.is_some() { public } else { &impl_item.vis };\n                     convert_associated_const(ccx, ImplContainer(def_id),\n-                                             impl_item.name, impl_item.id,\n-                                             visibility,\n-                                             impl_item.defaultness,\n-                                             ty, true /* has_value */);\n+                                             impl_item.id, ty);\n                 }\n             }\n \n@@ -844,21 +768,14 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n \n-                    convert_associated_type(ccx, ImplContainer(def_id),\n-                                            impl_item.name, impl_item.id, &impl_item.vis,\n-                                            impl_item.defaultness, Some(typ));\n+                    convert_associated_type(ccx, ImplContainer(def_id), impl_item.id, Some(typ));\n                 }\n             }\n \n             for impl_item in impl_items {\n                 if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-                    // Trait methods are always public.\n-                    let public = &hir::Public;\n-                    let method_vis = if opt_trait_ref.is_some() { public } else { &impl_item.vis };\n-\n                     convert_method(ccx, ImplContainer(def_id),\n-                                   impl_item.name, impl_item.id, method_vis,\n-                                   sig, impl_item.defaultness, true, selfty,\n+                                   impl_item.id, sig, selfty,\n                                    &ty_predicates);\n                 }\n             }\n@@ -880,7 +797,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             // Convert all the associated constants.\n             for trait_item in trait_items {\n-                if let hir::ConstTraitItem(ref ty, ref default) = trait_item.node {\n+                if let hir::ConstTraitItem(ref ty, _) = trait_item.node {\n                     let const_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n                     let ty_generics = generics_of_def_id(ccx, const_def_id);\n                     let ty = ccx.icx(&trait_predicates)\n@@ -890,14 +807,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                generics: ty_generics,\n                                                ty: ty,\n                                            });\n-                    convert_associated_const(ccx,\n-                                             container,\n-                                             trait_item.name,\n-                                             trait_item.id,\n-                                             &hir::Public,\n-                                             hir::Defaultness::Default,\n-                                             ty,\n-                                             default.is_some())\n+                    convert_associated_const(ccx, container, trait_item.id, ty)\n                 }\n             }\n \n@@ -911,39 +821,21 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                         |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n                     });\n \n-                    convert_associated_type(ccx,\n-                                            container,\n-                                            trait_item.name,\n-                                            trait_item.id,\n-                                            &hir::Public,\n-                                            hir::Defaultness::Default,\n-                                            typ);\n+                    convert_associated_type(ccx, container, trait_item.id, typ);\n                 }\n             }\n \n             // Convert all the methods\n             for trait_item in trait_items {\n-                if let hir::MethodTraitItem(ref sig, ref body) = trait_item.node {\n+                if let hir::MethodTraitItem(ref sig, _) = trait_item.node {\n                     convert_method(ccx,\n                                    container,\n-                                   trait_item.name,\n                                    trait_item.id,\n-                                   &hir::Inherited,\n                                    sig,\n-                                   hir::Defaultness::Default,\n-                                   body.is_some(),\n                                    tcx.mk_self_type(),\n                                    &trait_predicates);\n-\n                 }\n             }\n-\n-            // Add an entry mapping\n-            let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n-                ccx.tcx.map.local_def_id(trait_item.id)\n-            }).collect());\n-            tcx.impl_or_trait_item_def_ids.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n-                                                               trait_item_def_ids);\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n@@ -1308,28 +1200,6 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     tcx.intern_trait_def(trait_def)\n }\n \n-pub fn trait_associated_type_names<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                   trait_node_id: ast::NodeId)\n-                                                   -> impl Iterator<Item=ast::Name> + 'a\n-{\n-    let item = match tcx.map.get(trait_node_id) {\n-        hir_map::NodeItem(item) => item,\n-        _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n-    };\n-\n-    let trait_items = match item.node {\n-        hir::ItemTrait(.., ref trait_items) => trait_items,\n-        _ => bug!(\"trait_node_id {} is not a trait\", trait_node_id)\n-    };\n-\n-    trait_items.iter().filter_map(|trait_item| {\n-        match trait_item.node {\n-            hir::TypeTraitItem(..) => Some(trait_item.name),\n-            _ => None,\n-        }\n-    })\n-}\n-\n fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) {\n     let tcx = ccx.tcx;\n     let trait_def = trait_def_of_item(ccx, it);\n@@ -2209,13 +2079,14 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n     let lifetimes_in_associated_types: FxHashSet<_> = impl_items.iter()\n-        .map(|item| ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(item.id)))\n-        .filter_map(|item| match item {\n-            ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n-            ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None\n+        .map(|item|  ccx.tcx.map.local_def_id(item.id))\n+        .filter(|&def_id| {\n+            let item = ccx.tcx.associated_item(def_id);\n+            item.kind == ty::AssociatedKind::Type && item.has_value\n         })\n-        .flat_map(|ty| ctp::parameters_for(&ty, true))\n-        .collect();\n+        .flat_map(|def_id| {\n+            ctp::parameters_for(&ccx.tcx.lookup_item_type(def_id).ty, true)\n+        }).collect();\n \n     for (ty_lifetime, lifetime) in impl_scheme.generics.regions.iter()\n         .zip(&ast_generics.lifetimes)"}, {"sha": "a2955169cbb81d70947c05fb76fde65e1a4a806c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -163,7 +163,7 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       did: DefId) -> clean::Trait {\n     let def = tcx.lookup_trait_def(did);\n-    let trait_items = tcx.trait_items(did).clean(cx);\n+    let trait_items = tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n     let predicates = tcx.lookup_predicates(did);\n     let generics = (def.generics, &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n@@ -307,7 +307,6 @@ pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n \n     for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n         if !def_id.is_local() {\n-            tcx.populate_implementations_for_primitive_if_necessary(def_id);\n             build_impl(cx, tcx, def_id, &mut impls);\n         }\n     }\n@@ -367,43 +366,40 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n     }\n \n     let predicates = tcx.lookup_predicates(did);\n-    let trait_items = tcx.sess.cstore.impl_or_trait_items(did)\n-            .iter()\n-            .filter_map(|&did| {\n-        match tcx.impl_or_trait_item(did) {\n-            ty::ConstTraitItem(ref assoc_const) => {\n-                let did = assoc_const.def_id;\n-                let type_scheme = tcx.lookup_item_type(did);\n-                let default = if assoc_const.has_value {\n+    let trait_items = tcx.associated_items(did).filter_map(|item| {\n+        match item.kind {\n+            ty::AssociatedKind::Const => {\n+                let type_scheme = tcx.lookup_item_type(item.def_id);\n+                let default = if item.has_value {\n                     Some(pprust::expr_to_string(\n-                        lookup_const_by_id(tcx, did, None).unwrap().0))\n+                        lookup_const_by_id(tcx, item.def_id, None).unwrap().0))\n                 } else {\n                     None\n                 };\n                 Some(clean::Item {\n-                    name: Some(assoc_const.name.clean(cx)),\n+                    name: Some(item.name.clean(cx)),\n                     inner: clean::AssociatedConstItem(\n                         type_scheme.ty.clean(cx),\n                         default,\n                     ),\n                     source: clean::Span::empty(),\n                     attrs: vec![],\n                     visibility: None,\n-                    stability: tcx.lookup_stability(did).clean(cx),\n-                    deprecation: tcx.lookup_deprecation(did).clean(cx),\n-                    def_id: did\n+                    stability: tcx.lookup_stability(item.def_id).clean(cx),\n+                    deprecation: tcx.lookup_deprecation(item.def_id).clean(cx),\n+                    def_id: item.def_id\n                 })\n             }\n-            ty::MethodTraitItem(method) => {\n-                if method.vis != ty::Visibility::Public && associated_trait.is_none() {\n+            ty::AssociatedKind::Method => {\n+                if item.vis != ty::Visibility::Public && associated_trait.is_none() {\n                     return None\n                 }\n-                let mut item = method.clean(cx);\n-                item.inner = match item.inner.clone() {\n+                let mut cleaned = item.clean(cx);\n+                cleaned.inner = match cleaned.inner.clone() {\n                     clean::TyMethodItem(clean::TyMethod {\n                         unsafety, decl, generics, abi\n                     }) => {\n-                        let constness = if tcx.sess.cstore.is_const_fn(did) {\n+                        let constness = if tcx.sess.cstore.is_const_fn(item.def_id) {\n                             hir::Constness::Const\n                         } else {\n                             hir::Constness::NotConst\n@@ -419,27 +415,26 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                     }\n                     _ => panic!(\"not a tymethod\"),\n                 };\n-                Some(item)\n+                Some(cleaned)\n             }\n-            ty::TypeTraitItem(ref assoc_ty) => {\n-                let did = assoc_ty.def_id;\n+            ty::AssociatedKind::Type => {\n                 let typedef = clean::Typedef {\n-                    type_: assoc_ty.ty.unwrap().clean(cx),\n+                    type_: tcx.lookup_item_type(item.def_id).ty.clean(cx),\n                     generics: clean::Generics {\n                         lifetimes: vec![],\n                         type_params: vec![],\n                         where_predicates: vec![]\n                     }\n                 };\n                 Some(clean::Item {\n-                    name: Some(assoc_ty.name.clean(cx)),\n+                    name: Some(item.name.clean(cx)),\n                     inner: clean::TypedefItem(typedef, true),\n                     source: clean::Span::empty(),\n                     attrs: vec![],\n                     visibility: None,\n-                    stability: tcx.lookup_stability(did).clean(cx),\n-                    deprecation: tcx.lookup_deprecation(did).clean(cx),\n-                    def_id: did\n+                    stability: tcx.lookup_stability(item.def_id).clean(cx),\n+                    deprecation: tcx.lookup_deprecation(item.def_id).clean(cx),\n+                    def_id: item.def_id\n                 })\n             }\n         }"}, {"sha": "9e29d191946b71957dbc68f07af6b63b33ecb69c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 105, "deletions": 119, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -1338,48 +1338,117 @@ impl Clean<Item> for hir::ImplItem {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n+impl<'tcx> Clean<Item> for ty::AssociatedItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        let generics = (self.generics, &self.predicates).clean(cx);\n-        let mut decl = (self.def_id, &self.fty.sig).clean(cx);\n-        match self.explicit_self {\n-            ty::ExplicitSelfCategory::ByValue => {\n-                decl.inputs.values[0].type_ = Infer;\n+        let inner = match self.kind {\n+            ty::AssociatedKind::Const => {\n+                let ty = cx.tcx().lookup_item_type(self.def_id).ty;\n+                AssociatedConstItem(ty.clean(cx), None)\n             }\n-            ty::ExplicitSelfCategory::ByReference(..) => {\n-                match decl.inputs.values[0].type_ {\n-                    BorrowedRef{ref mut type_, ..} => **type_ = Infer,\n-                    _ => unreachable!(),\n+            ty::AssociatedKind::Method => {\n+                let generics = (cx.tcx().lookup_generics(self.def_id),\n+                                &cx.tcx().lookup_predicates(self.def_id)).clean(cx);\n+                let fty = match cx.tcx().lookup_item_type(self.def_id).ty.sty {\n+                    ty::TyFnDef(_, _, f) => f,\n+                    _ => unreachable!()\n+                };\n+                let mut decl = (self.def_id, &fty.sig).clean(cx);\n+\n+                if self.method_has_self_argument {\n+                    let self_ty = match self.container {\n+                        ty::ImplContainer(def_id) => {\n+                            cx.tcx().lookup_item_type(def_id).ty\n+                        }\n+                        ty::TraitContainer(_) => cx.tcx().mk_self_type()\n+                    };\n+                    let self_arg_ty = *fty.sig.input(0).skip_binder();\n+                    if self_arg_ty == self_ty {\n+                        decl.inputs.values[0].type_ = Infer;\n+                    } else if let ty::TyRef(_, mt) = self_arg_ty.sty {\n+                        if mt.ty == self_ty {\n+                            match decl.inputs.values[0].type_ {\n+                                BorrowedRef{ref mut type_, ..} => **type_ = Infer,\n+                                _ => unreachable!(),\n+                            }\n+                        }\n+                    }\n+                }\n+                let provided = match self.container {\n+                    ty::ImplContainer(_) => false,\n+                    ty::TraitContainer(_) => self.has_value\n+                };\n+                if provided {\n+                    MethodItem(Method {\n+                        unsafety: fty.unsafety,\n+                        generics: generics,\n+                        decl: decl,\n+                        abi: fty.abi,\n+\n+                        // trait methods canot (currently, at least) be const\n+                        constness: hir::Constness::NotConst,\n+                    })\n+                } else {\n+                    TyMethodItem(TyMethod {\n+                        unsafety: fty.unsafety,\n+                        generics: generics,\n+                        decl: decl,\n+                        abi: fty.abi,\n+                    })\n                 }\n             }\n-            _ => {}\n-        }\n-        let provided = match self.container {\n-            ty::ImplContainer(..) => false,\n-            ty::TraitContainer(did) => {\n-                cx.tcx().provided_trait_methods(did).iter().any(|m| {\n-                    m.def_id == self.def_id\n-                })\n+            ty::AssociatedKind::Type => {\n+                let my_name = self.name.clean(cx);\n+\n+                let mut bounds = if let ty::TraitContainer(did) = self.container {\n+                    // When loading a cross-crate associated type, the bounds for this type\n+                    // are actually located on the trait/impl itself, so we need to load\n+                    // all of the generics from there and then look for bounds that are\n+                    // applied to this associated type in question.\n+                    let def = cx.tcx().lookup_trait_def(did);\n+                    let predicates = cx.tcx().lookup_predicates(did);\n+                    let generics = (def.generics, &predicates).clean(cx);\n+                    generics.where_predicates.iter().filter_map(|pred| {\n+                        let (name, self_type, trait_, bounds) = match *pred {\n+                            WherePredicate::BoundPredicate {\n+                                ty: QPath { ref name, ref self_type, ref trait_ },\n+                                ref bounds\n+                            } => (name, self_type, trait_, bounds),\n+                            _ => return None,\n+                        };\n+                        if *name != my_name { return None }\n+                        match **trait_ {\n+                            ResolvedPath { did, .. } if did == self.container.id() => {}\n+                            _ => return None,\n+                        }\n+                        match **self_type {\n+                            Generic(ref s) if *s == \"Self\" => {}\n+                            _ => return None,\n+                        }\n+                        Some(bounds)\n+                    }).flat_map(|i| i.iter().cloned()).collect::<Vec<_>>()\n+                } else {\n+                    vec![]\n+                };\n+\n+                // Our Sized/?Sized bound didn't get handled when creating the generics\n+                // because we didn't actually get our whole set of bounds until just now\n+                // (some of them may have come from the trait). If we do have a sized\n+                // bound, we remove it, and if we don't then we add the `?Sized` bound\n+                // at the end.\n+                match bounds.iter().position(|b| b.is_sized_bound(cx)) {\n+                    Some(i) => { bounds.remove(i); }\n+                    None => bounds.push(TyParamBound::maybe_sized(cx)),\n+                }\n+\n+                let ty = if self.has_value {\n+                    Some(cx.tcx().lookup_item_type(self.def_id).ty)\n+                } else {\n+                    None\n+                };\n+\n+                AssociatedTypeItem(bounds, ty.clean(cx))\n             }\n         };\n-        let inner = if provided {\n-            MethodItem(Method {\n-                unsafety: self.fty.unsafety,\n-                generics: generics,\n-                decl: decl,\n-                abi: self.fty.abi,\n-\n-                // trait methods canot (currently, at least) be const\n-                constness: hir::Constness::NotConst,\n-            })\n-        } else {\n-            TyMethodItem(TyMethod {\n-                unsafety: self.fty.unsafety,\n-                generics: generics,\n-                decl: decl,\n-                abi: self.fty.abi,\n-            })\n-        };\n \n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -1394,16 +1463,6 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::ImplOrTraitItem<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        match *self {\n-            ty::ConstTraitItem(ref cti) => cti.clean(cx),\n-            ty::MethodTraitItem(ref mti) => mti.clean(cx),\n-            ty::TypeTraitItem(ref tti) => tti.clean(cx),\n-        }\n-    }\n-}\n-\n /// A trait reference, which may have higher ranked lifetimes.\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct PolyTrait {\n@@ -2884,79 +2943,6 @@ impl Clean<Deprecation> for attr::Deprecation {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::AssociatedConst<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        Item {\n-            source: DUMMY_SP.clean(cx),\n-            name: Some(self.name.clean(cx)),\n-            attrs: Vec::new(),\n-            inner: AssociatedConstItem(self.ty.clean(cx), None),\n-            visibility: None,\n-            def_id: self.def_id,\n-            stability: None,\n-            deprecation: None,\n-        }\n-    }\n-}\n-\n-impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        let my_name = self.name.clean(cx);\n-\n-        let mut bounds = if let ty::TraitContainer(did) = self.container {\n-            // When loading a cross-crate associated type, the bounds for this type\n-            // are actually located on the trait/impl itself, so we need to load\n-            // all of the generics from there and then look for bounds that are\n-            // applied to this associated type in question.\n-            let def = cx.tcx().lookup_trait_def(did);\n-            let predicates = cx.tcx().lookup_predicates(did);\n-            let generics = (def.generics, &predicates).clean(cx);\n-            generics.where_predicates.iter().filter_map(|pred| {\n-                let (name, self_type, trait_, bounds) = match *pred {\n-                    WherePredicate::BoundPredicate {\n-                        ty: QPath { ref name, ref self_type, ref trait_ },\n-                        ref bounds\n-                    } => (name, self_type, trait_, bounds),\n-                    _ => return None,\n-                };\n-                if *name != my_name { return None }\n-                match **trait_ {\n-                    ResolvedPath { did, .. } if did == self.container.id() => {}\n-                    _ => return None,\n-                }\n-                match **self_type {\n-                    Generic(ref s) if *s == \"Self\" => {}\n-                    _ => return None,\n-                }\n-                Some(bounds)\n-            }).flat_map(|i| i.iter().cloned()).collect::<Vec<_>>()\n-        } else {\n-            vec![]\n-        };\n-\n-        // Our Sized/?Sized bound didn't get handled when creating the generics\n-        // because we didn't actually get our whole set of bounds until just now\n-        // (some of them may have come from the trait). If we do have a sized\n-        // bound, we remove it, and if we don't then we add the `?Sized` bound\n-        // at the end.\n-        match bounds.iter().position(|b| b.is_sized_bound(cx)) {\n-            Some(i) => { bounds.remove(i); }\n-            None => bounds.push(TyParamBound::maybe_sized(cx)),\n-        }\n-\n-        Item {\n-            source: DUMMY_SP.clean(cx),\n-            name: Some(self.name.clean(cx)),\n-            attrs: inline::load_attrs(cx, cx.tcx(), self.def_id),\n-            inner: AssociatedTypeItem(bounds, self.ty.clean(cx)),\n-            visibility: self.vis.clean(cx),\n-            def_id: self.def_id,\n-            stability: cx.tcx().lookup_stability(self.def_id).clean(cx),\n-            deprecation: cx.tcx().lookup_deprecation(self.def_id).clean(cx),\n-        }\n-    }\n-}\n-\n fn lang_struct(cx: &DocContext, did: Option<DefId>,\n                t: ty::Ty, name: &str,\n                fallback: fn(Box<Type>) -> Type) -> Type {"}, {"sha": "f5cd089e923d7c7efe3dbbcdf7001d45656e5e06", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -1017,10 +1017,10 @@ pub enum ExprKind {\n     Loop(P<Block>, Option<SpannedIdent>),\n     /// A `match` block.\n     Match(P<Expr>, Vec<Arm>),\n-    /// A closure (for example, `move |a, b, c| {a + b + c}`)\n+    /// A closure (for example, `move |a, b, c| a + b + c`)\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    Closure(CaptureBy, P<FnDecl>, P<Block>, Span),\n+    Closure(CaptureBy, P<FnDecl>, P<Expr>, Span),\n     /// A block (`{ ... }`)\n     Block(P<Block>),\n "}, {"sha": "c3e28cbb006a07795499c4af50cae727df286ed4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -198,17 +198,13 @@ pub trait AstBuilder {\n     fn lambda_fn_decl(&self,\n                       span: Span,\n                       fn_decl: P<ast::FnDecl>,\n-                      blk: P<ast::Block>,\n+                      body: P<ast::Expr>,\n                       fn_decl_span: Span)\n                       -> P<ast::Expr>;\n \n-    fn lambda(&self, span: Span, ids: Vec<ast::Ident>, blk: P<ast::Block>) -> P<ast::Expr>;\n-    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr>;\n-    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> P<ast::Expr>;\n-\n-    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Expr>) -> P<ast::Expr>;\n-    fn lambda_expr_0(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n-    fn lambda_expr_1(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident>, body: P<ast::Expr>) -> P<ast::Expr>;\n+    fn lambda0(&self, span: Span, body: P<ast::Expr>) -> P<ast::Expr>;\n+    fn lambda1(&self, span: Span, body: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n \n     fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident>,\n                     blk: Vec<ast::Stmt>) -> P<ast::Expr>;\n@@ -940,19 +936,19 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn lambda_fn_decl(&self,\n                       span: Span,\n                       fn_decl: P<ast::FnDecl>,\n-                      blk: P<ast::Block>,\n+                      body: P<ast::Expr>,\n                       fn_decl_span: Span) // span of the `|...|` part\n                       -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref,\n                                                fn_decl,\n-                                               blk,\n+                                               body,\n                                                fn_decl_span))\n     }\n \n     fn lambda(&self,\n               span: Span,\n               ids: Vec<ast::Ident>,\n-              blk: P<ast::Block>)\n+              body: P<ast::Expr>)\n               -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n@@ -962,41 +958,30 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         // part of the lambda, but it probably (maybe?) corresponds to\n         // the entire lambda body. Probably we should extend the API\n         // here, but that's not entirely clear.\n-        self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref, fn_decl, blk, span))\n-    }\n-\n-    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr> {\n-        self.lambda(span, Vec::new(), blk)\n+        self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref, fn_decl, body, span))\n     }\n \n-    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> P<ast::Expr> {\n-        self.lambda(span, vec![ident], blk)\n+    fn lambda0(&self, span: Span, body: P<ast::Expr>) -> P<ast::Expr> {\n+        self.lambda(span, Vec::new(), body)\n     }\n \n-    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident>,\n-                   expr: P<ast::Expr>) -> P<ast::Expr> {\n-        self.lambda(span, ids, self.block_expr(expr))\n-    }\n-    fn lambda_expr_0(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        self.lambda0(span, self.block_expr(expr))\n-    }\n-    fn lambda_expr_1(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n-        self.lambda1(span, self.block_expr(expr), ident)\n+    fn lambda1(&self, span: Span, body: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n+        self.lambda(span, vec![ident], body)\n     }\n \n     fn lambda_stmts(&self,\n                     span: Span,\n                     ids: Vec<ast::Ident>,\n                     stmts: Vec<ast::Stmt>)\n                     -> P<ast::Expr> {\n-        self.lambda(span, ids, self.block(span, stmts))\n+        self.lambda(span, ids, self.expr_block(self.block(span, stmts)))\n     }\n     fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr> {\n-        self.lambda0(span, self.block(span, stmts))\n+        self.lambda0(span, self.expr_block(self.block(span, stmts)))\n     }\n     fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr> {\n-        self.lambda1(span, self.block(span, stmts), ident)\n+        self.lambda1(span, self.expr_block(self.block(span, stmts)), ident)\n     }\n \n     fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Arg {"}, {"sha": "9116b392f178460857b2c33c0977ac615bb52f21", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -354,7 +354,7 @@ declare_features! (\n     // Allows `#[deprecated]` attribute\n     (accepted, deprecated, \"1.9.0\", Some(29935)),\n     // `expr?`\n-    (accepted, question_mark, \"1.14.0\", Some(31436)),\n+    (accepted, question_mark, \"1.13.0\", Some(31436)),\n     // Allows `..` in tuple (struct) patterns\n     (accepted, dotdot_in_tuple_patterns, \"1.14.0\", Some(33627)),\n );\n@@ -1228,12 +1228,11 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n     fn visit_fn(&mut self,\n                 fn_kind: FnKind,\n                 fn_decl: &ast::FnDecl,\n-                block: &ast::Block,\n                 span: Span,\n                 _node_id: NodeId) {\n         // check for const fn declarations\n         match fn_kind {\n-            FnKind::ItemFn(_, _, _, Spanned { node: ast::Constness::Const, .. }, _, _) => {\n+            FnKind::ItemFn(_, _, _, Spanned { node: ast::Constness::Const, .. }, _, _, _) => {\n                 gate_feature_post!(&self, const_fn, span, \"const fn is unstable\");\n             }\n             _ => {\n@@ -1245,13 +1244,13 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         }\n \n         match fn_kind {\n-            FnKind::ItemFn(_, _, _, _, abi, _) |\n-            FnKind::Method(_, &ast::MethodSig { abi, .. }, _) => {\n+            FnKind::ItemFn(_, _, _, _, abi, _, _) |\n+            FnKind::Method(_, &ast::MethodSig { abi, .. }, _, _) => {\n                 self.check_abi(abi, span);\n             }\n             _ => {}\n         }\n-        visit::walk_fn(self, fn_kind, fn_decl, block, span);\n+        visit::walk_fn(self, fn_kind, fn_decl, span);\n     }\n \n     fn visit_trait_item(&mut self, ti: &ast::TraitItem) {"}, {"sha": "2e62f23578d815884167938f18949d42c69beb9a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -1201,7 +1201,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::Closure(capture_clause, decl, body, span) => {\n                 ExprKind::Closure(capture_clause,\n                                   folder.fold_fn_decl(decl),\n-                                  folder.fold_block(body),\n+                                  folder.fold_expr(body),\n                                   folder.new_span(span))\n             }\n             ExprKind::Block(blk) => ExprKind::Block(folder.fold_block(blk)),"}, {"sha": "7d15334ff9f4e3634ef8b977f9edea18ccaa9182", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -3162,25 +3162,12 @@ impl<'a> Parser<'a> {\n         let decl = self.parse_fn_block_decl()?;\n         let decl_hi = self.prev_span.hi;\n         let body = match decl.output {\n-            FunctionRetTy::Default(_) => {\n-                // If no explicit return type is given, parse any\n-                // expr and wrap it up in a dummy block:\n-                let body_expr = self.parse_expr()?;\n-                P(ast::Block {\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: body_expr.span,\n-                    stmts: vec![Stmt {\n-                        span: body_expr.span,\n-                        node: StmtKind::Expr(body_expr),\n-                        id: ast::DUMMY_NODE_ID,\n-                    }],\n-                    rules: BlockCheckMode::Default,\n-                })\n-            }\n+            FunctionRetTy::Default(_) => self.parse_expr()?,\n             _ => {\n                 // If an explicit return type is given, require a\n                 // block to appear (RFC 968).\n-                self.parse_block()?\n+                let body_lo = self.span.lo;\n+                self.parse_block_expr(body_lo, BlockCheckMode::Default, ThinVec::new())?\n             }\n         };\n "}, {"sha": "203c19285ac2c366e01f83b5d4eebc32cd35f772", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -2128,26 +2128,8 @@ impl<'a> State<'a> {\n \n                 try!(self.print_fn_block_args(&decl));\n                 try!(space(&mut self.s));\n-\n-                let default_return = match decl.output {\n-                    ast::FunctionRetTy::Default(..) => true,\n-                    _ => false\n-                };\n-\n-                match body.stmts.last().map(|stmt| &stmt.node) {\n-                    Some(&ast::StmtKind::Expr(ref i_expr)) if default_return &&\n-                                                              body.stmts.len() == 1 => {\n-                        // we extract the block, so as not to create another set of boxes\n-                        if let ast::ExprKind::Block(ref blk) = i_expr.node {\n-                            try!(self.print_block_unclosed_with_attrs(&blk, &i_expr.attrs));\n-                        } else {\n-                            // this is a bare expression\n-                            try!(self.print_expr(&i_expr));\n-                            try!(self.end()); // need to close a box\n-                        }\n-                    }\n-                    _ => try!(self.print_block_unclosed(&body)),\n-                }\n+                try!(self.print_expr(body));\n+                try!(self.end()); // need to close a box\n \n                 // a box will be closed by print_expr, but we didn't want an overall\n                 // wrapper so we closed the corresponding opening. so create an"}, {"sha": "a1f07381db705910e14e766b5520b8d95c463929", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -75,9 +75,9 @@ impl Visitor for NodeCounter {\n         self.count += 1;\n         walk_generics(self, g)\n     }\n-    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, s: Span, _: NodeId) {\n         self.count += 1;\n-        walk_fn(self, fk, fd, b, s)\n+        walk_fn(self, fk, fd, s)\n     }\n     fn visit_trait_item(&mut self, ti: &TraitItem) {\n         self.count += 1;"}, {"sha": "7c1ff617ab64d00b46d07021b15c5f83ab79abb7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -31,13 +31,13 @@ use codemap::Spanned;\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n-    ItemFn(Ident, &'a Generics, Unsafety, Spanned<Constness>, Abi, &'a Visibility),\n+    ItemFn(Ident, &'a Generics, Unsafety, Spanned<Constness>, Abi, &'a Visibility, &'a Block),\n \n     /// fn foo(&self)\n-    Method(Ident, &'a MethodSig, Option<&'a Visibility>),\n+    Method(Ident, &'a MethodSig, Option<&'a Visibility>, &'a Block),\n \n-    /// |x, y| {}\n-    Closure,\n+    /// |x, y| body\n+    Closure(&'a Expr),\n }\n \n /// Each method of the Visitor trait is a hook to be potentially\n@@ -68,8 +68,8 @@ pub trait Visitor: Sized {\n     fn visit_expr_post(&mut self, _ex: &Expr) { }\n     fn visit_ty(&mut self, t: &Ty) { walk_ty(self, t) }\n     fn visit_generics(&mut self, g: &Generics) { walk_generics(self, g) }\n-    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId) {\n-        walk_fn(self, fk, fd, b, s)\n+    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, s: Span, _: NodeId) {\n+        walk_fn(self, fk, fd, s)\n     }\n     fn visit_trait_item(&mut self, ti: &TraitItem) { walk_trait_item(self, ti) }\n     fn visit_impl_item(&mut self, ii: &ImplItem) { walk_impl_item(self, ii) }\n@@ -246,9 +246,8 @@ pub fn walk_item<V: Visitor>(visitor: &mut V, item: &Item) {\n         }\n         ItemKind::Fn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n             visitor.visit_fn(FnKind::ItemFn(item.ident, generics, unsafety,\n-                                            constness, abi, &item.vis),\n+                                            constness, abi, &item.vis, body),\n                              declaration,\n-                             body,\n                              item.span,\n                              item.id)\n         }\n@@ -519,26 +518,27 @@ pub fn walk_fn_decl<V: Visitor>(visitor: &mut V, function_declaration: &FnDecl)\n     visitor.visit_fn_ret_ty(&function_declaration.output)\n }\n \n-pub fn walk_fn_kind<V: Visitor>(visitor: &mut V, function_kind: FnKind) {\n-    match function_kind {\n-        FnKind::ItemFn(_, generics, _, _, _, _) => {\n+pub fn walk_fn<V>(visitor: &mut V, kind: FnKind, declaration: &FnDecl, _span: Span)\n+    where V: Visitor,\n+{\n+    match kind {\n+        FnKind::ItemFn(_, generics, _, _, _, _, body) => {\n             visitor.visit_generics(generics);\n+            walk_fn_decl(visitor, declaration);\n+            visitor.visit_block(body);\n         }\n-        FnKind::Method(_, ref sig, _) => {\n+        FnKind::Method(_, ref sig, _, body) => {\n             visitor.visit_generics(&sig.generics);\n+            walk_fn_decl(visitor, declaration);\n+            visitor.visit_block(body);\n+        }\n+        FnKind::Closure(body) => {\n+            walk_fn_decl(visitor, declaration);\n+            visitor.visit_expr(body);\n         }\n-        FnKind::Closure => {}\n     }\n }\n \n-pub fn walk_fn<V>(visitor: &mut V, kind: FnKind, declaration: &FnDecl, body: &Block, _span: Span)\n-    where V: Visitor,\n-{\n-    walk_fn_kind(visitor, kind);\n-    walk_fn_decl(visitor, declaration);\n-    visitor.visit_block(body)\n-}\n-\n pub fn walk_trait_item<V: Visitor>(visitor: &mut V, trait_item: &TraitItem) {\n     visitor.visit_ident(trait_item.span, trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n@@ -552,8 +552,8 @@ pub fn walk_trait_item<V: Visitor>(visitor: &mut V, trait_item: &TraitItem) {\n             walk_fn_decl(visitor, &sig.decl);\n         }\n         TraitItemKind::Method(ref sig, Some(ref body)) => {\n-            visitor.visit_fn(FnKind::Method(trait_item.ident, sig, None), &sig.decl,\n-                             body, trait_item.span, trait_item.id);\n+            visitor.visit_fn(FnKind::Method(trait_item.ident, sig, None, body),\n+                             &sig.decl, trait_item.span, trait_item.id);\n         }\n         TraitItemKind::Type(ref bounds, ref default) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n@@ -575,8 +575,8 @@ pub fn walk_impl_item<V: Visitor>(visitor: &mut V, impl_item: &ImplItem) {\n             visitor.visit_expr(expr);\n         }\n         ImplItemKind::Method(ref sig, ref body) => {\n-            visitor.visit_fn(FnKind::Method(impl_item.ident, sig, Some(&impl_item.vis)), &sig.decl,\n-                             body, impl_item.span, impl_item.id);\n+            visitor.visit_fn(FnKind::Method(impl_item.ident, sig, Some(&impl_item.vis), body),\n+                             &sig.decl, impl_item.span, impl_item.id);\n         }\n         ImplItemKind::Type(ref ty) => {\n             visitor.visit_ty(ty);\n@@ -711,9 +711,8 @@ pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n             walk_list!(visitor, visit_arm, arms);\n         }\n         ExprKind::Closure(_, ref function_declaration, ref body, _decl_span) => {\n-            visitor.visit_fn(FnKind::Closure,\n+            visitor.visit_fn(FnKind::Closure(body),\n                              function_declaration,\n-                             body,\n                              expression.span,\n                              expression.id)\n         }"}, {"sha": "dc1f7b4e6201e7132f989a8929b0337d7a6652cc", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -133,7 +133,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n                                 cx.ident_of(\"read_struct\"),\n                                 vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n                                      cx.expr_usize(trait_span, nfields),\n-                                     cx.lambda_expr_1(trait_span, result, blkarg)])\n+                                     cx.lambda1(trait_span, result, blkarg)])\n         }\n         StaticEnum(_, ref fields) => {\n             let variant = cx.ident_of(\"i\");\n@@ -165,7 +165,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n             let result =\n                 cx.expr_ok(trait_span,\n                            cx.expr_match(trait_span, cx.expr_ident(trait_span, variant), arms));\n-            let lambda = cx.lambda_expr(trait_span, vec![blkarg, variant], result);\n+            let lambda = cx.lambda(trait_span, vec![blkarg, variant], result);\n             let variant_vec = cx.expr_vec(trait_span, variants);\n             let variant_vec = cx.expr_addr_of(trait_span, variant_vec);\n             let result = cx.expr_method_call(trait_span,\n@@ -176,7 +176,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n                                 decoder,\n                                 cx.ident_of(\"read_enum\"),\n                                 vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n-                                     cx.lambda_expr_1(trait_span, result, blkarg)])\n+                                     cx.lambda1(trait_span, result, blkarg)])\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in derive(Decodable)\"),\n     };"}, {"sha": "ebbddc6e48084464208cd33b9dacce183863b98b", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -197,7 +197,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n                 };\n                 let self_ref = cx.expr_addr_of(span, self_.clone());\n                 let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n-                let lambda = cx.lambda_expr_1(span, enc, blkarg);\n+                let lambda = cx.lambda1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span,\n                                                blkencoder.clone(),\n                                                emit_struct_field,\n@@ -246,7 +246,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n                     let self_ref = cx.expr_addr_of(span, self_.clone());\n                     let enc =\n                         cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n-                    let lambda = cx.lambda_expr_1(span, enc, blkarg);\n+                    let lambda = cx.lambda1(span, enc, blkarg);\n                     let call = cx.expr_method_call(span,\n                                                    blkencoder.clone(),\n                                                    emit_variant_arg,\n@@ -273,7 +273,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n                                                 cx.expr_usize(trait_span, idx),\n                                                 cx.expr_usize(trait_span, fields.len()),\n                                                 blk]);\n-            let blk = cx.lambda_expr_1(trait_span, call, blkarg);\n+            let blk = cx.lambda1(trait_span, call, blkarg);\n             let ret = cx.expr_method_call(trait_span,\n                                           encoder,\n                                           cx.ident_of(\"emit_enum\"),"}, {"sha": "11d90658ab26a710394018faf64437376534dab4", "filename": "src/test/compile-fail/E0138.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2FE0138.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2FE0138.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0138.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -11,10 +11,10 @@\n #![feature(start)]\n \n #[start]\n-fn foo(argc: isize, argv: *const *const u8) -> isize {}\n+fn foo(argc: isize, argv: *const *const u8) -> isize { 0 }\n //~^ NOTE previous `start` function here\n \n #[start]\n-fn f(argc: isize, argv: *const *const u8) -> isize {}\n+fn f(argc: isize, argv: *const *const u8) -> isize { 0 }\n //~^ ERROR E0138\n //~| NOTE multiple `start` functions"}, {"sha": "530a0e415622815150b4d26221f1bbf95ea9561c", "filename": "src/test/compile-fail/consider-removing-last-semi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f() -> String {  //~ ERROR E0269\n+fn f() -> String {  //~ ERROR mismatched types\n     0u8;\n     \"bla\".to_string();  //~ HELP consider removing this semicolon\n }\n \n-fn g() -> String {  //~ ERROR E0269\n+fn g() -> String {  //~ ERROR mismatched types\n     \"this won't work\".to_string();\n     \"removeme\".to_string(); //~ HELP consider removing this semicolon\n }"}, {"sha": "3a27c084133283775744cedb465c7c06446523b3", "filename": "src/test/compile-fail/diverging-fn-tail-35849.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fdiverging-fn-tail-35849.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fdiverging-fn-tail-35849.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiverging-fn-tail-35849.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn _converge() -> ! { //~ ERROR computation may converge\n-    42\n+fn _converge() -> ! {\n+    42 //~ ERROR mismatched types\n }\n \n fn main() { }"}, {"sha": "192f78e41cb43cdf23d71c231f4661fc63ac3870", "filename": "src/test/compile-fail/issue-11714.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-11714.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-11714.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11714.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn blah() -> i32 { //~ ERROR not all control paths return a value\n+fn blah() -> i32 { //~ ERROR mismatched types\n     1\n \n     ; //~ HELP consider removing this semicolon:"}, {"sha": "9406199afc231904e58df233178c4f6c544673eb", "filename": "src/test/compile-fail/issue-13428.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -10,15 +10,15 @@\n \n // Regression test for #13428\n \n-fn foo() -> String {  //~ ERROR not all control paths return a value\n+fn foo() -> String {  //~ ERROR mismatched types\n     format!(\"Hello {}\",\n             \"world\")\n     // Put the trailing semicolon on its own line to test that the\n     // note message gets the offending semicolon exactly\n     ;   //~ HELP consider removing this semicolon\n }\n \n-fn bar() -> String {  //~ ERROR not all control paths return a value\n+fn bar() -> String {  //~ ERROR mismatched types\n     \"foobar\".to_string()\n     ;   //~ HELP consider removing this semicolon\n }"}, {"sha": "81f66e3e2cfeeb855648c2ae8b1d4af4a89a2674", "filename": "src/test/compile-fail/issue-22645.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-22645.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-22645.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22645.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -17,7 +17,7 @@ struct Bob;\n \n impl<RHS: Scalar> Add <RHS> for Bob {\n   type Output = Bob;\n-  fn add(self, rhs : RHS) -> Bob {}\n+  fn add(self, rhs : RHS) -> Bob { Bob }\n }\n \n fn main() {"}, {"sha": "a791758ad1763c630ae2fb9e3ae7454c81da4a57", "filename": "src/test/compile-fail/issue-22684.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-22684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-22684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22684.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -15,7 +15,7 @@ mod foo {\n     }\n \n     pub trait Baz {\n-        fn bar(&self) -> bool {}\n+        fn bar(&self) -> bool { true }\n     }\n     impl Baz for Foo {}\n }"}, {"sha": "97ba222fe45f08204f48595e3a7a21356c302fb3", "filename": "src/test/compile-fail/issue-29161.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -13,7 +13,7 @@ mod a {\n \n     impl Default for A {\n         pub fn default() -> A { //~ ERROR unnecessary visibility qualifier\n-            A;\n+            A\n         }\n     }\n }"}, {"sha": "e5cb81303277112c6617c62b0ebe70d72c4319a0", "filename": "src/test/compile-fail/issue-32323.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-32323.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-32323.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32323.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -13,6 +13,6 @@ pub trait Tr<'a> {\n }\n \n pub fn f<'a, T: Tr<'a>>() -> <T as Tr<'a>>::Out {}\n-//~^ ERROR not all control paths return a value\n+//~^ ERROR mismatched types\n \n pub fn main() {}"}, {"sha": "a77b27150d7978e917a44d64b0e45d30dbc0664b", "filename": "src/test/compile-fail/issue-5239-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -11,7 +11,7 @@\n // Regression test for issue #5239\n \n fn main() {\n-    let x = |ref x: isize| -> isize { x += 1; };\n+    let x = |ref x: isize| { x += 1; };\n     //~^ ERROR E0368\n     //~| NOTE cannot use `+=` on type `&isize`\n }"}, {"sha": "a078cdea4ac4d70be1c1ee2eb0fc6c1ff04690c7", "filename": "src/test/compile-fail/issue-6458-4.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(b: bool) -> Result<bool,String> {\n-    Err(\"bar\".to_string());\n-    //~^ ERROR unable to infer enough type information about `_` [E0282]\n-    //~| NOTE cannot infer type for `_`\n-    //~| NOTE type annotations or generic parameter binding\n+fn foo(b: bool) -> Result<bool,String> { //~ ERROR mismatched types\n+    Err(\"bar\".to_string()); //~ HELP consider removing this semicolon\n }\n \n fn main() {"}, {"sha": "1ee4be08a1c5096e78af89ec9c3d13c39c2b3b87", "filename": "src/test/compile-fail/liveness-forgot-ret.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: not all control paths return a value\n-\n fn god_exists(a: isize) -> bool { return god_exists(a); }\n \n fn f(a: isize) -> isize { if god_exists(a) { return 5; }; }\n+//~^ ERROR mismatched types\n \n fn main() { f(12); }"}, {"sha": "69bceec8c3225ee70366326b172d6b09edbb226a", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -13,6 +13,6 @@ use std::vec::Vec;\n fn main() {\n     let a: Vec<isize> = Vec::new();\n     a.iter().all(|_| -> bool {\n-        //~^ ERROR not all control paths return a value\n+        //~^ ERROR mismatched types\n     });\n }"}, {"sha": "a35eb1af4f336ea6019909e9e7518146ed2446da", "filename": "src/test/compile-fail/liveness-missing-ret2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: not all control paths return a value\n-\n-fn f() -> isize {\n+fn f() -> isize { //~ ERROR mismatched types\n     // Make sure typestate doesn't interpret this match expression as\n     // the function result\n    match true { true => { } _ => {} };"}, {"sha": "ada91c38d48c3fd77b5e19d8b5aa697eb07adff4", "filename": "src/test/compile-fail/liveness-return-last-stmt-semi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -11,16 +11,16 @@\n // regression test for #8005\n \n macro_rules! test { () => { fn foo() -> i32 { 1; } } }\n-                                           //~^ ERROR not all control paths return a value\n+                                           //~^ ERROR mismatched types\n                                            //~| HELP consider removing this semicolon\n \n-fn no_return() -> i32 {} //~ ERROR  not all control paths return a value\n+fn no_return() -> i32 {} //~ ERROR mismatched types\n \n-fn bar(x: u32) -> u32 { //~ ERROR  not all control paths return a value\n+fn bar(x: u32) -> u32 { //~ ERROR mismatched types\n     x * 2; //~ HELP consider removing this semicolon\n }\n \n-fn baz(x: u64) -> u32 { //~ ERROR  not all control paths return a value\n+fn baz(x: u64) -> u32 { //~ ERROR mismatched types\n     x * 2;\n }\n "}, {"sha": "2878cbc7fc15488d6fcfb865390be929d419f7c9", "filename": "src/test/compile-fail/main-wrong-type-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -10,4 +10,5 @@\n \n fn main() -> char {\n //~^ ERROR: main function has wrong type\n+    ' '\n }"}, {"sha": "0f4b0919b6500842c7566ceefa0f099fb0a05bf5", "filename": "src/test/compile-fail/on-unimplemented/on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -16,7 +16,7 @@ trait Foo<Bar, Baz, Quux>\n {}\n \n fn foobar<U: Clone, T: Foo<u8, U, u32>>() -> T {\n-\n+    panic!()\n }\n \n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be built from an iterator over elements of type `{A}`\"]"}, {"sha": "4796548112d9e0ae4b201cda345f95c4b93ec344", "filename": "src/test/compile-fail/private-in-public-lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -13,7 +13,7 @@ mod m1 {\n     struct Priv;\n \n     impl Pub {\n-        pub fn f() -> Priv {} //~ ERROR private type in public interface\n+        pub fn f() -> Priv {Priv} //~ ERROR private type in public interface\n     }\n }\n \n@@ -24,7 +24,7 @@ mod m2 {\n     struct Priv;\n \n     impl Pub {\n-        pub fn f() -> Priv {} //~ ERROR private type in public interface\n+        pub fn f() -> Priv {Priv} //~ ERROR private type in public interface\n     }\n }\n "}, {"sha": "ce40702b3dc2adff68a339c812cfa578a7c5de1d", "filename": "src/test/compile-fail/required-lang-item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -11,6 +11,7 @@\n #![feature(lang_items, no_core)]\n #![no_core]\n \n+#[lang=\"copy\"] pub trait Copy { }\n #[lang=\"sized\"] pub trait Sized { }\n \n // error-pattern:requires `start` lang_item"}, {"sha": "72462468432d9aedb4a6b49a68d0421f48c119ff", "filename": "src/test/compile-fail/unreachable-in-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Funreachable-in-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Funreachable-in-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-in-call.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -24,7 +24,7 @@ fn diverge_first() {\n          get_u8()); //~ ERROR unreachable expression\n }\n fn diverge_second() {\n-    call( //~ ERROR unreachable call\n+    call( //~ ERROR unreachable expression\n         get_u8(),\n         diverge());\n }"}, {"sha": "ffc39008c4e5a1b7ff16274fd63e1c5c485efcaf", "filename": "src/test/compile-fail/where-clauses-unsatisfied.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn equal<T>(_: &T, _: &T) -> bool where T : Eq {\n-}\n+fn equal<T>(a: &T, b: &T) -> bool where T : Eq { a == b }\n \n struct Struct;\n "}, {"sha": "1da6735918012f11be58ef6b620cbaec9b8ca17e", "filename": "src/test/parse-fail/closure-return-syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fparse-fail%2Fclosure-return-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fparse-fail%2Fclosure-return-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fclosure-return-syntax.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -12,5 +12,6 @@\n // unless it uses braces.\n \n fn main() {\n-    let x = || -> i32 22; //~ ERROR expected `{`, found `22`\n+    let x = || -> i32 22;\n+    //~^ ERROR expected one of `!`, `(`, `::`, `<`, or `{`, found `22`\n }"}, {"sha": "24b0f90d08e4d21cc56bf8c2e15e4ea142e8ce25", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 66, "deletions": 58, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -18,18 +18,18 @@\n \n // #4264 fixed-length vector types\n \n-pub fn foo(_: [i32; (3 as usize)]) { }\n+pub fn foo(_: [i32; (3 as usize)]) ({ } as ())\n \n-pub fn bar() {\n-    const FOO: usize = ((5 as usize) - (4 as usize) as usize);\n-    let _: [(); (FOO as usize)] = ([(() as ())] as [(); 1]);\n+pub fn bar() ({\n+                  const FOO: usize = ((5 as usize) - (4 as usize) as usize);\n+                  let _: [(); (FOO as usize)] = ([(() as ())] as [(); 1]);\n \n-    let _: [(); (1 as usize)] = ([(() as ())] as [(); 1]);\n+                  let _: [(); (1 as usize)] = ([(() as ())] as [(); 1]);\n \n-    let _ =\n-        (((&([(1 as i32), (2 as i32), (3 as i32)] as [i32; 3]) as &[i32; 3])\n-             as *const _ as *const [i32; 3]) as *const [i32; (3 as usize)] as\n-            *const [i32; 3]);\n+                  let _ =\n+                      (((&([(1 as i32), (2 as i32), (3 as i32)] as [i32; 3])\n+                            as &[i32; 3]) as *const _ as *const [i32; 3]) as\n+                          *const [i32; (3 as usize)] as *const [i32; 3]);\n \n \n \n@@ -38,58 +38,66 @@\n \n \n \n-    (($crate::fmt::format as\n-         fn(std::fmt::Arguments<'_>) -> std::string::String {std::fmt::format})(((::std::fmt::Arguments::new_v1\n-                                                                                     as\n-                                                                                     fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})(({\n-                                                                                                                                                                                                 static __STATIC_FMTSTR:\n-                                                                                                                                                                                                        &'static [&'static str]\n-                                                                                                                                                                                                        =\n-                                                                                                                                                                                                     (&([(\"test\"\n-                                                                                                                                                                                                             as\n-                                                                                                                                                                                                             &'static str)]\n-                                                                                                                                                                                                           as\n-                                                                                                                                                                                                           [&'static str; 1])\n-                                                                                                                                                                                                         as\n-                                                                                                                                                                                                         &'static [&'static str; 1]);\n-                                                                                                                                                                                                 (__STATIC_FMTSTR\n-                                                                                                                                                                                                     as\n-                                                                                                                                                                                                     &'static [&'static str])\n-                                                                                                                                                                                             }\n-                                                                                                                                                                                                as\n-                                                                                                                                                                                                &[&str]),\n-                                                                                                                                                                                            (&(match (()\n-                                                                                                                                                                                                         as\n-                                                                                                                                                                                                         ())\n-                                                                                                                                                                                                   {\n-                                                                                                                                                                                                   ()\n-                                                                                                                                                                                                   =>\n-                                                                                                                                                                                                   ([]\n-                                                                                                                                                                                                       as\n-                                                                                                                                                                                                       [std::fmt::ArgumentV1<'_>; 0]),\n-                                                                                                                                                                                               }\n-                                                                                                                                                                                                  as\n-                                                                                                                                                                                                  [std::fmt::ArgumentV1<'_>; 0])\n-                                                                                                                                                                                                as\n-                                                                                                                                                                                                &[std::fmt::ArgumentV1<'_>; 0]))\n-                                                                                    as\n-                                                                                    std::fmt::Arguments<'_>))\n-        as std::string::String);\n-}\n+\n+                  (($crate::fmt::format as\n+                       fn(std::fmt::Arguments<'_>) -> std::string::String {std::fmt::format})(((::std::fmt::Arguments::new_v1\n+                                                                                                   as\n+                                                                                                   fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})(({\n+                                                                                                                                                                                                               static __STATIC_FMTSTR:\n+                                                                                                                                                                                                                      &'static [&'static str]\n+                                                                                                                                                                                                                      =\n+                                                                                                                                                                                                                   (&([(\"test\"\n+                                                                                                                                                                                                                           as\n+                                                                                                                                                                                                                           &'static str)]\n+                                                                                                                                                                                                                         as\n+                                                                                                                                                                                                                         [&'static str; 1])\n+                                                                                                                                                                                                                       as\n+                                                                                                                                                                                                                       &'static [&'static str; 1]);\n+                                                                                                                                                                                                               (__STATIC_FMTSTR\n+                                                                                                                                                                                                                   as\n+                                                                                                                                                                                                                   &'static [&'static str])\n+                                                                                                                                                                                                           }\n+                                                                                                                                                                                                              as\n+                                                                                                                                                                                                              &[&str]),\n+                                                                                                                                                                                                          (&(match (()\n+                                                                                                                                                                                                                       as\n+                                                                                                                                                                                                                       ())\n+                                                                                                                                                                                                                 {\n+                                                                                                                                                                                                                 ()\n+                                                                                                                                                                                                                 =>\n+                                                                                                                                                                                                                 ([]\n+                                                                                                                                                                                                                     as\n+                                                                                                                                                                                                                     [std::fmt::ArgumentV1<'_>; 0]),\n+                                                                                                                                                                                                             }\n+                                                                                                                                                                                                                as\n+                                                                                                                                                                                                                [std::fmt::ArgumentV1<'_>; 0])\n+                                                                                                                                                                                                              as\n+                                                                                                                                                                                                              &[std::fmt::ArgumentV1<'_>; 0]))\n+                                                                                                  as\n+                                                                                                  std::fmt::Arguments<'_>))\n+                      as std::string::String);\n+              } as ())\n pub type Foo = [i32; (3 as usize)];\n pub struct Bar {\n     pub x: [i32; (3 as usize)],\n }\n pub struct TupleBar([i32; (4 as usize)]);\n pub enum Baz { BazVariant([i32; (5 as usize)]), }\n-pub fn id<T>(x: T) -> T { (x as T) }\n-pub fn use_id() {\n-    let _ =\n-        ((id::<[i32; (3 as usize)]> as\n-             fn([i32; 3]) -> [i32; 3] {id::<[i32; 3]>})(([(1 as i32),\n-                                                          (2 as i32),\n-                                                          (3 as i32)] as\n-                                                            [i32; 3])) as\n-            [i32; 3]);\n-}\n-fn main() { }\n+pub fn id<T>(x: T) -> T ({ (x as T) } as T)\n+pub fn use_id() ({\n+                     let _ =\n+                         ((id::<[i32; (3 as usize)]> as\n+                              fn([i32; 3]) -> [i32; 3] {id::<[i32; 3]>})(([(1\n+                                                                               as\n+                                                                               i32),\n+                                                                           (2\n+                                                                               as\n+                                                                               i32),\n+                                                                           (3\n+                                                                               as\n+                                                                               i32)]\n+                                                                             as\n+                                                                             [i32; 3]))\n+                             as [i32; 3]);\n+                 } as ())\n+fn main() ({ } as ())"}, {"sha": "1c443020d2e934970fef26d77a8b57fb318bdd82", "filename": "src/test/pretty/stmt_expr_attributes.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -198,14 +198,20 @@ fn _11() {\n                 };\n     let _ = #[attr] || #[attr] ();\n     let _ = #[attr] move || #[attr] ();\n-    let _ = #[attr] || {\n-        #![attr]\n-        #[attr]\n-        () };\n-    let _ = #[attr] move || {\n-        #![attr]\n-        #[attr]\n-        () };\n+    let _ =\n+        #[attr] ||\n+                    {\n+                        #![attr]\n+                        #[attr]\n+                        ()\n+                    };\n+    let _ =\n+        #[attr] move ||\n+                    {\n+                        #![attr]\n+                        #[attr]\n+                        ()\n+                    };\n     let _ =\n         #[attr] {\n                     #![attr]"}, {"sha": "8ea8370ab235d1308b4ff3d19d67e5be9f409405", "filename": "src/test/run-make/graphviz-flowgraph/f00.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff00.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff00.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff00.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -2,6 +2,8 @@ digraph block {\n     N0[label=\"entry\"];\n     N1[label=\"exit\"];\n     N2[label=\"block { }\"];\n+    N3[label=\"expr { }\"];\n     N0 -> N2;\n-    N2 -> N1;\n+    N2 -> N3;\n+    N3 -> N1;\n }"}, {"sha": "5982fbea76902905e78eaa4dc307eacdb10ddf56", "filename": "src/test/run-make/graphviz-flowgraph/f01.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff01.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff01.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff01.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -4,8 +4,10 @@ digraph block {\n     N2[label=\"expr 1\"];\n     N3[label=\"stmt 1;\"];\n     N4[label=\"block { 1; }\"];\n+    N5[label=\"expr { 1; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n-    N4 -> N1;\n+    N4 -> N5;\n+    N5 -> N1;\n }"}, {"sha": "1639785bd68c0abe7c1df7b2e11ae36e37004915", "filename": "src/test/run-make/graphviz-flowgraph/f02.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff02.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff02.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff02.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -4,8 +4,10 @@ digraph block {\n     N2[label=\"local _x\"];\n     N3[label=\"stmt let _x: isize;\"];\n     N4[label=\"block { let _x: isize; }\"];\n+    N5[label=\"expr { let _x: isize; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n-    N4 -> N1;\n+    N4 -> N5;\n+    N5 -> N1;\n }"}, {"sha": "b0ae00d81675a6ee3ccc4a5f4dec9db63cdad371", "filename": "src/test/run-make/graphviz-flowgraph/f03.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -6,10 +6,12 @@ digraph block {\n     N4[label=\"expr 3 + 4\"];\n     N5[label=\"stmt 3 + 4;\"];\n     N6[label=\"block { 3 + 4; }\"];\n+    N7[label=\"expr { 3 + 4; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n-    N6 -> N1;\n+    N6 -> N7;\n+    N7 -> N1;\n }"}, {"sha": "41ace15a4c680d18194f79a45d832ab27e8b92ba", "filename": "src/test/run-make/graphviz-flowgraph/f04.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -5,9 +5,11 @@ digraph block {\n     N3[label=\"local _x\"];\n     N4[label=\"stmt let _x = 4;\"];\n     N5[label=\"block { let _x = 4; }\"];\n+    N6[label=\"expr { let _x = 4; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n-    N5 -> N1;\n+    N5 -> N6;\n+    N6 -> N1;\n }"}, {"sha": "72b8ae71751c2f7d7493ae3ed3a2157c5cb4a02d", "filename": "src/test/run-make/graphviz-flowgraph/f05.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -9,6 +9,7 @@ digraph block {\n     N7[label=\"pat (_x, _y)\"];\n     N8[label=\"stmt let (_x, _y) = (5, 55);\"];\n     N9[label=\"block { let (_x, _y) = (5, 55); }\"];\n+    N10[label=\"expr { let (_x, _y) = (5, 55); }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -17,5 +18,6 @@ digraph block {\n     N6 -> N7;\n     N7 -> N8;\n     N8 -> N9;\n-    N9 -> N1;\n+    N9 -> N10;\n+    N10 -> N1;\n }"}, {"sha": "acba71ef625ff2db3f0afe2ca9ddae3566ab5b98", "filename": "src/test/run-make/graphviz-flowgraph/f06.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -7,11 +7,13 @@ digraph block {\n     N5[label=\"pat S6 { val: _x }\"];\n     N6[label=\"stmt let S6 { val: _x } = S6{val: 6,};\"];\n     N7[label=\"block { let S6 { val: _x } = S6{val: 6,}; }\"];\n+    N8[label=\"expr { let S6 { val: _x } = S6{val: 6,}; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n-    N7 -> N1;\n+    N7 -> N8;\n+    N8 -> N1;\n }"}, {"sha": "251e2b39f14c8fa6be9f4d142417493c62440caa", "filename": "src/test/run-make/graphviz-flowgraph/f07.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -17,6 +17,7 @@ digraph block {\n     N15[label=\"expr x + y\"];\n     N16[label=\"stmt match [7, 77, 777, 7777] { [x, y, ..] => x + y, };\"];\n     N17[label=\"block { match [7, 77, 777, 7777] { [x, y, ..] => x + y, }; }\"];\n+    N18[label=\"expr { match [7, 77, 777, 7777] { [x, y, ..] => x + y, }; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -33,5 +34,6 @@ digraph block {\n     N15 -> N7;\n     N7 -> N16;\n     N16 -> N17;\n-    N17 -> N1;\n+    N17 -> N18;\n+    N18 -> N1;\n }"}, {"sha": "e2779c9414a9e5a9d1e7d75ad9121f313b6c992f", "filename": "src/test/run-make/graphviz-flowgraph/f08.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff08.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff08.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff08.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -16,6 +16,7 @@ digraph block {\n     N14[label=\"block { _y = 888; }\"];\n     N15[label=\"expr if x > 88 { _y = 888; }\"];\n     N16[label=\"block { let x = 8; let _y; if x > 88 { _y = 888; } }\"];\n+    N17[label=\"expr { let x = 8; let _y; if x > 88 { _y = 888; } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -32,5 +33,6 @@ digraph block {\n     N9 -> N15;\n     N14 -> N15;\n     N15 -> N16;\n-    N16 -> N1;\n+    N16 -> N17;\n+    N17 -> N1;\n }"}, {"sha": "536abde91e81a9c3a5323ea77ccb980384c08024", "filename": "src/test/run-make/graphviz-flowgraph/f09.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -24,6 +24,7 @@ digraph block {\n     N22[label=\"expr { _y = 94 + 95; }\"];\n     N23[label=\"expr if x > 92 { _y = 93; } else { _y = 94 + 95; }\"];\n     N24[label=\"block { let x = 91; let _y; if x > 92 { _y = 93; } else { _y = 94 + 95; } }\"];\n+    N25[label=\"expr { let x = 91; let _y; if x > 92 { _y = 93; } else { _y = 94 + 95; } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -48,5 +49,6 @@ digraph block {\n     N14 -> N23;\n     N22 -> N23;\n     N23 -> N24;\n-    N24 -> N1;\n+    N24 -> N25;\n+    N25 -> N1;\n }"}, {"sha": "a3b531b1e2f413b6984fc6f8327f3229616a4943", "filename": "src/test/run-make/graphviz-flowgraph/f10.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -15,6 +15,7 @@ digraph block {\n     N13[label=\"stmt x -= 1;\"];\n     N14[label=\"block { x -= 1; }\"];\n     N15[label=\"block { let mut x = 10; while x > 0 { x -= 1; } }\"];\n+    N16[label=\"expr { let mut x = 10; while x > 0 { x -= 1; } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -30,5 +31,6 @@ digraph block {\n     N13 -> N14;\n     N14 -> N5;\n     N9 -> N15;\n-    N15 -> N1;\n+    N15 -> N16;\n+    N16 -> N1;\n }"}, {"sha": "70034d299ba95f7c1bb03fa7072f15213e6cd73d", "filename": "src/test/run-make/graphviz-flowgraph/f11.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -15,6 +15,7 @@ digraph block {\n     N13[label=\"expr \\\"unreachable\\\"\"];\n     N14[label=\"stmt \\\"unreachable\\\";\"];\n     N15[label=\"block { let mut _x = 11; loop  { _x -= 1; } \\\"unreachable\\\"; }\"];\n+    N16[label=\"expr { let mut _x = 11; loop  { _x -= 1; } \\\"unreachable\\\"; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -29,5 +30,6 @@ digraph block {\n     N12 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n-    N15 -> N1;\n+    N15 -> N16;\n+    N16 -> N1;\n }"}, {"sha": "245afc43504c473660a2bc23c11374722c5c78c9", "filename": "src/test/run-make/graphviz-flowgraph/f12.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -22,6 +22,7 @@ digraph block {\n     N20[label=\"expr if x == 2 { break ; \\\"unreachable\\\"; }\"];\n     N21[label=\"block { x -= 1; if x == 2 { break ; \\\"unreachable\\\"; } }\"];\n     N22[label=\"block { let mut x = 12; loop  { x -= 1; if x == 2 { break ; \\\"unreachable\\\"; } } }\"];\n+    N23[label=\"expr { let mut x = 12; loop  { x -= 1; if x == 2 { break ; \\\"unreachable\\\"; } } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -44,5 +45,6 @@ digraph block {\n     N20 -> N21;\n     N21 -> N5;\n     N6 -> N22;\n-    N22 -> N1;\n+    N22 -> N23;\n+    N23 -> N1;\n }"}, {"sha": "0f268bd0f2aeb530f58a0ad19ab250e5c585c23f", "filename": "src/test/run-make/graphviz-flowgraph/f13.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -24,6 +24,7 @@ digraph block {\n     N22[label=\"expr _y\"];\n     N23[label=\"expr _y = v + 1\"];\n     N24[label=\"block {\\l    let x = E13::E13b(13);\\l    let _y;\\l    match x { E13::E13a => _y = 1, E13::E13b(v) => _y = v + 1, }\\l}\\l\"];\n+    N25[label=\"expr {\\l    let x = E13::E13b(13);\\l    let _y;\\l    match x { E13::E13a => _y = 1, E13::E13b(v) => _y = v + 1, }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -48,5 +49,6 @@ digraph block {\n     N22 -> N23;\n     N23 -> N10;\n     N10 -> N24;\n-    N24 -> N1;\n+    N24 -> N25;\n+    N25 -> N1;\n }"}, {"sha": "719a6cf2619d37f8dfc6f09bc5b390dcd6a90e8a", "filename": "src/test/run-make/graphviz-flowgraph/f14.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -15,6 +15,7 @@ digraph block {\n     N13[label=\"block { return; \\\"unreachable\\\"; }\"];\n     N14[label=\"expr if x > 1 { return; \\\"unreachable\\\"; }\"];\n     N15[label=\"block { let x = 14; if x > 1 { return; \\\"unreachable\\\"; } }\"];\n+    N16[label=\"expr { let x = 14; if x > 1 { return; \\\"unreachable\\\"; } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -30,5 +31,6 @@ digraph block {\n     N7 -> N14;\n     N13 -> N14;\n     N14 -> N15;\n-    N15 -> N1;\n+    N15 -> N16;\n+    N16 -> N1;\n }"}, {"sha": "d8cbd8411e2095b47d48b9c2222a3d70881b4772", "filename": "src/test/run-make/graphviz-flowgraph/f15.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -49,6 +49,7 @@ digraph block {\n     N47[label=\"stmt x -= 5;\"];\n     N48[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2 { break ; \\\"unreachable\\\"; }\\l            y -= 3;\\l        }\\l    y -= 4;\\l    x -= 5;\\l}\\l\"];\n     N49[label=\"block {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { break ; \\\"unreachable\\\"; }\\l                    y -= 3;\\l                }\\l            y -= 4;\\l            x -= 5;\\l        }\\l}\\l\"];\n+    N50[label=\"expr {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { break ; \\\"unreachable\\\"; }\\l                    y -= 3;\\l                }\\l            y -= 4;\\l            x -= 5;\\l        }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -99,5 +100,6 @@ digraph block {\n     N47 -> N48;\n     N48 -> N8;\n     N9 -> N49;\n-    N49 -> N1;\n+    N49 -> N50;\n+    N50 -> N1;\n }"}, {"sha": "b11881247fb6a3d8dd1d2dfb9b7aaa0da916689b", "filename": "src/test/run-make/graphviz-flowgraph/f16.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -52,6 +52,7 @@ digraph block {\n     N50[label=\"expr \\\"unreachable\\\"\"];\n     N51[label=\"stmt \\\"unreachable\\\";\"];\n     N52[label=\"block {\\l    let mut x = 16;\\l    let mut y = 16;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 1 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                }\\l            y -= 1;\\l            x -= 1;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N53[label=\"expr {\\l    let mut x = 16;\\l    let mut y = 16;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 1 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                }\\l            y -= 1;\\l            x -= 1;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -105,5 +106,6 @@ digraph block {\n     N49 -> N50;\n     N50 -> N51;\n     N51 -> N52;\n-    N52 -> N1;\n+    N52 -> N53;\n+    N53 -> N1;\n }"}, {"sha": "705eece77558dcc38d262cd116f6ea9fd5f19084", "filename": "src/test/run-make/graphviz-flowgraph/f17.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -8,12 +8,14 @@ digraph block {\n     N6[label=\"local _v\"];\n     N7[label=\"stmt let _v = [1, 7, 17];\"];\n     N8[label=\"block { let _v = [1, 7, 17]; }\"];\n+    N9[label=\"expr { let _v = [1, 7, 17]; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n     N7 -> N8;\n-    N8 -> N1;\n+    N8 -> N9;\n+    N9 -> N1;\n }"}, {"sha": "c1d6e3023fbc163eb6954560c05fad3a5fdb0621", "filename": "src/test/run-make/graphviz-flowgraph/f18.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -9,6 +9,7 @@ digraph block {\n     N7[label=\"expr inner(inner(18))\"];\n     N8[label=\"stmt inner(inner(18));\"];\n     N9[label=\"block { inner(inner(18)); }\"];\n+    N10[label=\"expr { inner(inner(18)); }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -17,5 +18,6 @@ digraph block {\n     N6 -> N7;\n     N7 -> N8;\n     N8 -> N9;\n-    N9 -> N1;\n+    N9 -> N10;\n+    N10 -> N1;\n }"}, {"sha": "d2f9f41f647beb48e6772f75f402e150abf6941d", "filename": "src/test/run-make/graphviz-flowgraph/f19.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -12,6 +12,7 @@ digraph block {\n     N10[label=\"expr s.inner().inner()\"];\n     N11[label=\"stmt s.inner().inner();\"];\n     N12[label=\"block { let s = S19{x: 19,}; s.inner().inner(); }\"];\n+    N13[label=\"expr { let s = S19{x: 19,}; s.inner().inner(); }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -23,5 +24,6 @@ digraph block {\n     N9 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n-    N12 -> N1;\n+    N12 -> N13;\n+    N13 -> N1;\n }"}, {"sha": "120eab4dac909e6652a53c9688a7220476a6f8b6", "filename": "src/test/run-make/graphviz-flowgraph/f20.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -12,6 +12,7 @@ digraph block {\n     N10[label=\"expr v[20]\"];\n     N11[label=\"stmt v[20];\"];\n     N12[label=\"block { let v = [2, 0, 20]; v[20]; }\"];\n+    N13[label=\"expr { let v = [2, 0, 20]; v[20]; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -23,5 +24,6 @@ digraph block {\n     N9 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n-    N12 -> N1;\n+    N12 -> N13;\n+    N13 -> N1;\n }"}, {"sha": "370dcdd8554da3071f7f2f0609f3277173b853f2", "filename": "src/test/run-make/graphviz-flowgraph/f21.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -47,6 +47,7 @@ digraph block {\n     N45[label=\"stmt \\\"unreachable\\\";\"];\n     N46[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2 { return; \\\"unreachable\\\"; }\\l            y -= 3;\\l            x -= 5;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n     N47[label=\"block {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { return; \\\"unreachable\\\"; }\\l                    y -= 3;\\l                    x -= 5;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l}\\l\"];\n+    N48[label=\"expr {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { return; \\\"unreachable\\\"; }\\l                    y -= 3;\\l                    x -= 5;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -95,5 +96,6 @@ digraph block {\n     N45 -> N46;\n     N46 -> N8;\n     N9 -> N47;\n-    N47 -> N1;\n+    N47 -> N48;\n+    N48 -> N1;\n }"}, {"sha": "9d3bc22831a139f1aee227b24747d12cee5efcbb", "filename": "src/test/run-make/graphviz-flowgraph/f22.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -50,6 +50,7 @@ digraph block {\n     N48[label=\"expr \\\"unreachable\\\"\"];\n     N49[label=\"stmt \\\"unreachable\\\";\"];\n     N50[label=\"block {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { return; \\\"unreachable\\\"; }\\l                    x -= 1;\\l                    y -= 3;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N51[label=\"expr {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { return; \\\"unreachable\\\"; }\\l                    x -= 1;\\l                    y -= 3;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -101,5 +102,6 @@ digraph block {\n     N47 -> N48;\n     N48 -> N49;\n     N49 -> N50;\n-    N50 -> N1;\n+    N50 -> N51;\n+    N51 -> N1;\n }"}, {"sha": "f152977438c505d87a932e5680012be93872eb69", "filename": "src/test/run-make/graphviz-flowgraph/f23.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -52,6 +52,7 @@ digraph block {\n     N50[label=\"block { y -= 1; while z > 0 { z -= 1; } if x > 10 { return; \\\"unreachable\\\"; } }\"];\n     N51[label=\"block {\\l    x -= 1;\\l    while y > 0 {\\l        y -= 1;\\l        while z > 0 { z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n     N52[label=\"block {\\l    let mut x = 23;\\l    let mut y = 23;\\l    let mut z = 23;\\l    while x > 0 {\\l        x -= 1;\\l        while y > 0 {\\l            y -= 1;\\l            while z > 0 { z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n+    N53[label=\"expr {\\l    let mut x = 23;\\l    let mut y = 23;\\l    let mut z = 23;\\l    while x > 0 {\\l        x -= 1;\\l        while y > 0 {\\l            y -= 1;\\l            while z > 0 { z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -107,5 +108,6 @@ digraph block {\n     N24 -> N51;\n     N51 -> N11;\n     N15 -> N52;\n-    N52 -> N1;\n+    N52 -> N53;\n+    N53 -> N1;\n }"}, {"sha": "e40dd014f0a4de54a49a3057ddc612f9ebb0a15a", "filename": "src/test/run-make/graphviz-flowgraph/f24.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -76,6 +76,7 @@ digraph block {\n     N74[label=\"block {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n     N75[label=\"block {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    loop  {\\l        if y == 0 { break ; \\\"unreachable\\\"; }\\l        y -= 1;\\l        loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n     N76[label=\"block {\\l    let mut x = 24;\\l    let mut y = 24;\\l    let mut z = 24;\\l    loop  {\\l        if x == 0 { break ; \\\"unreachable\\\"; }\\l        x -= 1;\\l        loop  {\\l            if y == 0 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l            loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n+    N77[label=\"expr {\\l    let mut x = 24;\\l    let mut y = 24;\\l    let mut z = 24;\\l    loop  {\\l        if x == 0 { break ; \\\"unreachable\\\"; }\\l        x -= 1;\\l        loop  {\\l            if y == 0 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l            loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -155,5 +156,6 @@ digraph block {\n     N29 -> N75;\n     N75 -> N11;\n     N12 -> N76;\n-    N76 -> N1;\n+    N76 -> N77;\n+    N77 -> N1;\n }"}, {"sha": "1e2df1ab5e7b7ba10baf7d45462bf8b808ca8e98", "filename": "src/test/run-make/graphviz-flowgraph/f25.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b46ce08df51f95e5d9f6dff9156b1d8e38cf4795/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot?ref=b46ce08df51f95e5d9f6dff9156b1d8e38cf4795", "patch": "@@ -76,6 +76,7 @@ digraph block {\n     N74[label=\"block {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n     N75[label=\"block {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    \\'a:\\l        loop  {\\l            if y == 0 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l            \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l            if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l        }\\l}\\l\"];\n     N76[label=\"block {\\l    let mut x = 25;\\l    let mut y = 25;\\l    let mut z = 25;\\l    \\'a:\\l        loop  {\\l            if x == 0 { break ; \\\"unreachable\\\"; }\\l            x -= 1;\\l            \\'a:\\l                loop  {\\l                    if y == 0 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l                    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l                }\\l        }\\l}\\l\"];\n+    N77[label=\"expr {\\l    let mut x = 25;\\l    let mut y = 25;\\l    let mut z = 25;\\l    \\'a:\\l        loop  {\\l            if x == 0 { break ; \\\"unreachable\\\"; }\\l            x -= 1;\\l            \\'a:\\l                loop  {\\l                    if y == 0 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l                    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l                }\\l        }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -155,5 +156,6 @@ digraph block {\n     N29 -> N75;\n     N75 -> N11;\n     N12 -> N76;\n-    N76 -> N1;\n+    N76 -> N77;\n+    N77 -> N1;\n }"}]}