{"sha": "154858c4308d771e29ad90057bf199867c271d09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NDg1OGM0MzA4ZDc3MWUyOWFkOTAwNTdiZjE5OTg2N2MyNzFkMDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-26T14:35:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-26T14:35:13Z"}, "message": "Auto merge of #84583 - joshtriplett:target-tier-policy, r=pietroalbini\n\nAdd the target tier policy from accepted RFC 2803", "tree": {"sha": "f4879f4072065c201199890517124cf4f6529553", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4879f4072065c201199890517124cf4f6529553"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/154858c4308d771e29ad90057bf199867c271d09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/154858c4308d771e29ad90057bf199867c271d09", "html_url": "https://github.com/rust-lang/rust/commit/154858c4308d771e29ad90057bf199867c271d09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/154858c4308d771e29ad90057bf199867c271d09/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8212de8eb18a8cc4ab74074f244c386d5e99b281", "url": "https://api.github.com/repos/rust-lang/rust/commits/8212de8eb18a8cc4ab74074f244c386d5e99b281", "html_url": "https://github.com/rust-lang/rust/commit/8212de8eb18a8cc4ab74074f244c386d5e99b281"}, {"sha": "42033df1d4a9b5e16f034f06aa750317894e514d", "url": "https://api.github.com/repos/rust-lang/rust/commits/42033df1d4a9b5e16f034f06aa750317894e514d", "html_url": "https://github.com/rust-lang/rust/commit/42033df1d4a9b5e16f034f06aa750317894e514d"}], "stats": {"total": 643, "additions": 642, "deletions": 1}, "files": [{"sha": "b269aab98142d5241ef2b481dba9be1619ec5e24", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/154858c4308d771e29ad90057bf199867c271d09/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/154858c4308d771e29ad90057bf199867c271d09/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=154858c4308d771e29ad90057bf199867c271d09", "patch": "@@ -13,6 +13,7 @@\n - [JSON Output](json.md)\n - [Tests](tests/index.md)\n - [Platform Support](platform-support.md)\n+- [Target Tier Policy](target-tier-policy.md)\n - [Targets](targets/index.md)\n     - [Built-in Targets](targets/built-in.md)\n     - [Custom Targets](targets/custom.md)"}, {"sha": "7f57d476aa9fbfa03af5968acac0dcb1c497a26a", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154858c4308d771e29ad90057bf199867c271d09/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/154858c4308d771e29ad90057bf199867c271d09/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=154858c4308d771e29ad90057bf199867c271d09", "patch": "@@ -7,7 +7,8 @@\n </style>\n \n Support for different platforms are organized into three tiers, each with a\n-different set of guarantees.\n+different set of guarantees. For more information on the policies for targets\n+at each tier, see the [Target Tier Policy](target-tier-policy.md).\n \n Platforms are identified by their \"target triple\" which is the string to\n inform the compiler what kind of output should be produced. The columns in the"}, {"sha": "463f56099f6e93768e7054f91d2f146cf43a06f2", "filename": "src/doc/rustc/src/target-tier-policy.md", "status": "added", "additions": 639, "deletions": 0, "changes": 639, "blob_url": "https://github.com/rust-lang/rust/blob/154858c4308d771e29ad90057bf199867c271d09/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md", "raw_url": "https://github.com/rust-lang/rust/raw/154858c4308d771e29ad90057bf199867c271d09/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md?ref=154858c4308d771e29ad90057bf199867c271d09", "patch": "@@ -0,0 +1,639 @@\n+# Target Tier Policy\n+\n+Rust provides three tiers of target support:\n+\n+- Rust provides no guarantees about tier 3 targets; they exist in the codebase,\n+  but may or may not build.\n+- Rust's continuous integration checks that tier 2 targets will always build,\n+  but they may or may not pass tests.\n+- Rust's continuous integration checks that tier 1 targets will always build\n+  and pass tests.\n+\n+Adding a new tier 3 target imposes minimal requirements; we focus primarily on\n+avoiding disruption to other ongoing Rust development.\n+\n+Tier 2 and tier 1 targets place work on Rust project developers as a whole, to\n+avoid breaking the target. The broader Rust community may also feel more\n+inclined to support higher-tier targets in their crates (though they are not\n+obligated to do so). Thus, these tiers require commensurate and ongoing efforts\n+from the maintainers of the target, to demonstrate value and to minimize any\n+disruptions to ongoing Rust development.\n+\n+This policy defines the requirements for accepting a proposed target at a given\n+level of support.\n+\n+Each tier builds on all the requirements from the previous tier, unless\n+overridden by a stronger requirement. Targets at tier 2 and tier 1 may also\n+provide *host tools* (such as `rustc` and `cargo`); each of those tiers\n+includes a set of supplementary requirements that must be met if supplying host\n+tools for the target. A target at tier 2 or tier 1 is not required to supply\n+host tools, but if it does, it must meet the corresponding additional\n+requirements for host tools.\n+\n+The policy for each tier also documents the Rust governance teams that must\n+approve the addition of any target at that tier. Those teams are responsible\n+for reviewing and evaluating the target, based on these requirements and their\n+own judgment. Those teams may apply additional requirements, including\n+subjective requirements, such as to deal with issues not foreseen by this\n+policy. (Such requirements may subsequently motivate additions to this policy.)\n+\n+While these criteria attempt to document the policy, that policy still involves\n+human judgment. Targets must fulfill the spirit of the requirements as well, as\n+determined by the judgment of the approving teams. Reviewers and team members\n+evaluating targets and target-specific patches should always use their own best\n+judgment regarding the quality of work, and the suitability of a target for the\n+Rust project. Neither this policy nor any decisions made regarding targets\n+shall create any binding agreement or estoppel by any party.\n+\n+Before filing an issue or pull request (PR) to introduce or promote a target,\n+the target should already meet the corresponding tier requirements. This does\n+not preclude an existing target's maintainers using issues (on the Rust\n+repository or otherwise) to track requirements that have not yet been met, as\n+appropriate; however, before officially proposing the introduction or promotion\n+of a target, it should meet all of the necessary requirements. A target\n+proposal is encouraged to quote the corresponding requirements verbatim as part\n+of explaining how the target meets those requirements.\n+\n+For a list of all supported targets and their corresponding tiers (\"tier 3\",\n+\"tier 2\", \"tier 2 with host tools\", \"tier 1\", or \"tier 1 with host tools\"), see\n+[platform support](platform-support.md).\n+\n+Note that a target must have already received approval for the next lower tier,\n+and spent a reasonable amount of time at that tier, before making a proposal\n+for promotion to the next higher tier; this is true even if a target meets the\n+requirements for several tiers at once. This policy leaves the precise\n+interpretation of \"reasonable amount of time\" up to the approving teams; those\n+teams may scale the amount of time required based on their confidence in the\n+target and its demonstrated track record at its current tier. At a minimum,\n+multiple stable releases of Rust should typically occur between promotions of a\n+target.\n+\n+The availability or tier of a target in stable Rust is not a hard stability\n+guarantee about the future availability or tier of that target. Higher-level\n+target tiers are an increasing commitment to the support of a target, and we\n+will take that commitment and potential disruptions into account when\n+evaluating the potential demotion or removal of a target that has been part of\n+a stable release. The promotion or demotion of a target will not generally\n+affect existing stable releases, only current development and future releases.\n+\n+In this policy, the words \"must\" and \"must not\" specify absolute requirements\n+that a target must meet to qualify for a tier. The words \"should\" and \"should\n+not\" specify requirements that apply in almost all cases, but for which the\n+approving teams may grant an exception for good reason. The word \"may\"\n+indicates something entirely optional, and does not indicate guidance or\n+recommendations. This language is based on [IETF RFC\n+2119](https://tools.ietf.org/html/rfc2119).\n+\n+## Tier 3 target policy\n+\n+At this tier, the Rust project provides no official support for a target, so we\n+place minimal requirements on the introduction of targets.\n+\n+A proposed new tier 3 target must be reviewed and approved by a member of the\n+compiler team based on these requirements. The reviewer may choose to gauge\n+broader compiler team consensus via a Major Change Proposal (MCP).\n+\n+A proposed target or target-specific patch that substantially changes code\n+shared with other targets (not just target-specific code) must be reviewed and\n+approved by the appropriate team for that shared code before acceptance.\n+\n+- A tier 3 target must have a designated developer or developers (the \"target\n+  maintainers\") on record to be CCed when issues arise regarding the target.\n+  (The mechanism to track and CC such developers may evolve over time.)\n+- Targets must use naming consistent with any existing targets; for instance, a\n+  target for the same CPU or OS as an existing Rust target should use the same\n+  name for that CPU or OS. Targets should normally use the same names and\n+  naming conventions as used elsewhere in the broader ecosystem beyond Rust\n+  (such as in other toolchains), unless they have a very good reason to\n+  diverge. Changing the name of a target can be highly disruptive, especially\n+  once the target reaches a higher tier, so getting the name right is important\n+  even for a tier 3 target.\n+  - Target names should not introduce undue confusion or ambiguity unless\n+    absolutely necessary to maintain ecosystem compatibility. For example, if\n+    the name of the target makes people extremely likely to form incorrect\n+    beliefs about what it targets, the name should be changed or augmented to\n+    disambiguate it.\n+- Tier 3 targets may have unusual requirements to build or use, but must not\n+  create legal issues or impose onerous legal terms for the Rust project or for\n+  Rust developers or users.\n+  - The target must not introduce license incompatibilities.\n+  - Anything added to the Rust repository must be under the standard Rust\n+    license (`MIT OR Apache-2.0`).\n+  - The target must not cause the Rust tools or libraries built for any other\n+    host (even when supporting cross-compilation to the target) to depend\n+    on any new dependency less permissive than the Rust licensing policy. This\n+    applies whether the dependency is a Rust crate that would require adding\n+    new license exceptions (as specified by the `tidy` tool in the\n+    rust-lang/rust repository), or whether the dependency is a native library\n+    or binary. In other words, the introduction of the target must not cause a\n+    user installing or running a version of Rust or the Rust tools to be\n+    subject to any new license requirements.\n+  - If the target supports building host tools (such as `rustc` or `cargo`),\n+    those host tools must not depend on proprietary (non-FOSS) libraries, other\n+    than ordinary runtime libraries supplied by the platform and commonly used\n+    by other binaries built for the target. For instance, `rustc` built for the\n+    target may depend on a common proprietary C runtime library or console\n+    output library, but must not depend on a proprietary code generation\n+    library or code optimization library. Rust's license permits such\n+    combinations, but the Rust project has no interest in maintaining such\n+    combinations within the scope of Rust itself, even at tier 3.\n+  - Targets should not require proprietary (non-FOSS) components to link a\n+    functional binary or library.\n+  - \"onerous\" here is an intentionally subjective term. At a minimum, \"onerous\"\n+    legal/licensing terms include but are *not* limited to: non-disclosure\n+    requirements, non-compete requirements, contributor license agreements\n+    (CLAs) or equivalent, \"non-commercial\"/\"research-only\"/etc terms,\n+    requirements conditional on the employer or employment of any particular\n+    Rust developers, revocable terms, any requirements that create liability\n+    for the Rust project or its developers or users, or any requirements that\n+    adversely affect the livelihood or prospects of the Rust project or its\n+    developers or users.\n+- Neither this policy nor any decisions made regarding targets shall create any\n+  binding agreement or estoppel by any party. If any member of an approving\n+  Rust team serves as one of the maintainers of a target, or has any legal or\n+  employment requirement (explicit or implicit) that might affect their\n+  decisions regarding a target, they must recuse themselves from any approval\n+  decisions regarding the target's tier status, though they may otherwise\n+  participate in discussions.\n+  - This requirement does not prevent part or all of this policy from being\n+    cited in an explicit contract or work agreement (e.g. to implement or\n+    maintain support for a target). This requirement exists to ensure that a\n+    developer or team responsible for reviewing and approving a target does not\n+    face any legal threats or obligations that would prevent them from freely\n+    exercising their judgment in such approval, even if such judgment involves\n+    subjective matters or goes beyond the letter of these requirements.\n+- Tier 3 targets should attempt to implement as much of the standard libraries\n+  as possible and appropriate (`core` for most targets, `alloc` for targets\n+  that can support dynamic memory allocation, `std` for targets with an\n+  operating system or equivalent layer of system-provided functionality), but\n+  may leave some code unimplemented (either unavailable or stubbed out as\n+  appropriate), whether because the target makes it impossible to implement or\n+  challenging to implement. The authors of pull requests are not obligated to\n+  avoid calling any portions of the standard library on the basis of a tier 3\n+  target not implementing those portions.\n+- The target must provide documentation for the Rust community explaining how\n+  to build for the target, using cross-compilation if possible. If the target\n+  supports running tests (even if they do not pass), the documentation must\n+  explain how to run tests for the target, using emulation if possible or\n+  dedicated hardware if necessary.\n+- Tier 3 targets must not impose burden on the authors of pull requests, or\n+  other developers in the community, to maintain the target. In particular,\n+  do not post comments (automated or manual) on a PR that derail or suggest a\n+  block on the PR based on a tier 3 target. Do not send automated messages or\n+  notifications (via any medium, including via `@`) to a PR author or others\n+  involved with a PR regarding a tier 3 target, unless they have opted into\n+  such messages.\n+  - Backlinks such as those generated by the issue/PR tracker when linking to\n+    an issue or PR are not considered a violation of this policy, within\n+    reason. However, such messages (even on a separate repository) must not\n+    generate notifications to anyone involved with a PR who has not requested\n+    such notifications.\n+- Patches adding or updating tier 3 targets must not break any existing tier 2\n+  or tier 1 target, and must not knowingly break another tier 3 target without\n+  approval of either the compiler team or the maintainers of the other tier 3\n+  target.\n+  - In particular, this may come up when working on closely related targets,\n+    such as variations of the same architecture with different features. Avoid\n+    introducing unconditional uses of features that another variation of the\n+    target may not have; use conditional compilation or runtime detection, as\n+    appropriate, to let each target run code supported by that target.\n+\n+If a tier 3 target stops meeting these requirements, or the target maintainers\n+no longer have interest or time, or the target shows no signs of activity and\n+has not built for some time, or removing the target would improve the quality\n+of the Rust codebase, we may post a PR to remove it; any such PR will be CCed\n+to the target maintainers (and potentially other people who have previously\n+worked on the target), to check potential interest in improving the situation.\n+\n+## Tier 2 target policy\n+\n+At this tier, the Rust project guarantees that a target builds, and will reject\n+patches that fail to build on a target. Thus, we place requirements that ensure\n+the target will not block forward progress of the Rust project.\n+\n+A proposed new tier 2 target must be reviewed and approved by the compiler team\n+based on these requirements. Such review and approval may occur via a Major\n+Change Proposal (MCP).\n+\n+In addition, the infrastructure team must approve the integration of the target\n+into Continuous Integration (CI), and the tier 2 CI-related requirements. This\n+review and approval may take place in a PR adding the target to CI, or simply\n+by an infrastructure team member reporting the outcome of a team discussion.\n+\n+- A tier 2 target must have value to people other than its maintainers. (It may\n+  still be a niche target, but it must not be exclusively useful for an\n+  inherently closed group.)\n+- A tier 2 target must have a designated team of developers (the \"target\n+  maintainers\") available to consult on target-specific build-breaking issues,\n+  or if necessary to develop target-specific language or library implementation\n+  details. This team must have at least 2 developers.\n+  - The target maintainers should not only fix target-specific issues, but\n+    should use any such issue as an opportunity to educate the Rust community\n+    about portability to their target, and enhance documentation of the target.\n+- The target must not place undue burden on Rust developers not specifically\n+  concerned with that target. Rust developers are expected to not gratuitously\n+  break a tier 2 target, but are not expected to become experts in every tier 2\n+  target, and are not expected to provide target-specific implementations for\n+  every tier 2 target.\n+- The target must provide documentation for the Rust community explaining how\n+  to build for the target using cross-compilation, and explaining how to run\n+  tests for the target. If at all possible, this documentation should show how\n+  to run Rust programs and tests for the target using emulation, to allow\n+  anyone to do so. If the target cannot be feasibly emulated, the documentation\n+  should explain how to obtain and work with physical hardware, cloud systems,\n+  or equivalent.\n+- The target must document its baseline expectations for the features or\n+  versions of CPUs, operating systems, libraries, runtime environments, and\n+  similar.\n+- If introducing a new tier 2 or higher target that is identical to an existing\n+  Rust target except for the baseline expectations for the features or versions\n+  of CPUs, operating systems, libraries, runtime environments, and similar,\n+  then the proposed target must document to the satisfaction of the approving\n+  teams why the specific difference in baseline expectations provides\n+  sufficient value to justify a separate target.\n+  - Note that in some cases, based on the usage of existing targets within the\n+    Rust community, Rust developers or a target's maintainers may wish to\n+    modify the baseline expectations of a target, or split an existing target\n+    into multiple targets with different baseline expectations. A proposal to\n+    do so will be treated similarly to the analogous promotion, demotion, or\n+    removal of a target, according to this policy, with the same team approvals\n+    required.\n+    - For instance, if an OS version has become obsolete and unsupported, a\n+      target for that OS may raise its baseline expectations for OS version\n+      (treated as though removing a target corresponding to the older\n+      versions), or a target for that OS may split out support for older OS\n+      versions into a lower-tier target (treated as though demoting a target\n+      corresponding to the older versions, and requiring justification for a\n+      new target at a lower tier for the older OS versions).\n+- Tier 2 targets must not leave any significant portions of `core` or the\n+  standard library unimplemented or stubbed out, unless they cannot possibly be\n+  supported on the target.\n+  - The right approach to handling a missing feature from a target may depend\n+    on whether the target seems likely to develop the feature in the future. In\n+    some cases, a target may be co-developed along with Rust support, and Rust\n+    may gain new features on the target as that target gains the capabilities\n+    to support those features.\n+  - As an exception, a target identical to an existing tier 1 target except for\n+    lower baseline expectations for the OS, CPU, or similar, may propose to\n+    qualify as tier 2 (but not higher) without support for `std` if the target\n+    will primarily be used in `no_std` applications, to reduce the support\n+    burden for the standard library. In this case, evaluation of the proposed\n+    target's value will take this limitation into account.\n+- The code generation backend for the target should not have deficiencies that\n+  invalidate Rust safety properties, as evaluated by the Rust compiler team.\n+  (This requirement does not apply to arbitrary security enhancements or\n+  mitigations provided by code generation backends, only to those properties\n+  needed to ensure safe Rust code cannot cause undefined behavior or other\n+  unsoundness.) If this requirement does not hold, the target must clearly and\n+  prominently document any such limitations as part of the target's entry in\n+  the target tier list, and ideally also via a failing test in the testsuite.\n+  The Rust compiler team must be satisfied with the balance between these\n+  limitations and the difficulty of implementing the necessary features.\n+  - For example, if Rust relies on a specific code generation feature to ensure\n+    that safe code cannot overflow the stack, the code generation for the\n+    target should support that feature.\n+  - If the Rust compiler introduces new safety properties (such as via new\n+    capabilities of a compiler backend), the Rust compiler team will determine\n+    if they consider those new safety properties a best-effort improvement for\n+    specific targets, or a required property for all Rust targets. In the\n+    latter case, the compiler team may require the maintainers of existing\n+    targets to either implement and confirm support for the property or update\n+    the target tier list with documentation of the missing property.\n+- If the target supports C code, and the target has an interoperable calling\n+  convention for C code, the Rust target must support that C calling convention\n+  for the platform via `extern \"C\"`. The C calling convention does not need to\n+  be the default Rust calling convention for the target, however.\n+- The target must build reliably in CI, for all components that Rust's CI\n+  considers mandatory.\n+- The approving teams may additionally require that a subset of tests pass in\n+  CI, such as enough to build a functional \"hello world\" program, `./x.py test\n+  --no-run`, or equivalent \"smoke tests\". In particular, this requirement may\n+  apply if the target builds host tools, or if the tests in question provide\n+  substantial value via early detection of critical problems.\n+- Building the target in CI must not take substantially longer than the current\n+  slowest target in CI, and should not substantially raise the maintenance\n+  burden of the CI infrastructure. This requirement is subjective, to be\n+  evaluated by the infrastructure team, and will take the community importance\n+  of the target into account.\n+- Tier 2 targets should, if at all possible, support cross-compiling. Tier 2\n+  targets should not require using the target as the host for builds, even if\n+  the target supports host tools.\n+- In addition to the legal requirements for all targets (specified in the tier\n+  3 requirements), because a tier 2 target typically involves the Rust project\n+  building and supplying various compiled binaries, incorporating the target\n+  and redistributing any resulting compiled binaries (e.g. built libraries,\n+  host tools if any) must not impose any onerous license requirements on any\n+  members of the Rust project, including infrastructure team members and those\n+  operating CI systems. This is a subjective requirement, to be evaluated by\n+  the approving teams.\n+  - As an exception to this, if the target's primary purpose is to build\n+    components for a Free and Open Source Software (FOSS) project licensed\n+    under \"copyleft\" terms (terms which require licensing other code under\n+    compatible FOSS terms), such as kernel modules or plugins, then the\n+    standard libraries for the target may potentially be subject to copyleft\n+    terms, as long as such terms are satisfied by Rust's existing practices of\n+    providing full corresponding source code. Note that anything added to the\n+    Rust repository itself must still use Rust's standard license terms.\n+- Tier 2 targets must not impose burden on the authors of pull requests, or\n+  other developers in the community, to ensure that tests pass for the target.\n+  In particular, do not post comments (automated or manual) on a PR that derail\n+  or suggest a block on the PR based on tests failing for the target. Do not\n+  send automated messages or notifications (via any medium, including via `@`)\n+  to a PR author or others involved with a PR regarding the PR breaking tests\n+  on a tier 2 target, unless they have opted into such messages.\n+  - Backlinks such as those generated by the issue/PR tracker when linking to\n+    an issue or PR are not considered a violation of this policy, within\n+    reason. However, such messages (even on a separate repository) must not\n+    generate notifications to anyone involved with a PR who has not requested\n+    such notifications.\n+- The target maintainers should regularly run the testsuite for the target, and\n+  should fix any test failures in a reasonably timely fashion.\n+- All requirements for tier 3 apply.\n+\n+A tier 2 target may be demoted or removed if it no longer meets these\n+requirements. Any proposal for demotion or removal will be CCed to the target\n+maintainers, and will be communicated widely to the Rust community before being\n+dropped from a stable release. (The amount of time between such communication\n+and the next stable release may depend on the nature and severity of the failed\n+requirement, the timing of its discovery, whether the target has been part of a\n+stable release yet, and whether the demotion or removal can be a planned and\n+scheduled action.)\n+\n+In some circumstances, especially if the target maintainers do not respond in a\n+timely fashion, Rust teams may land pull requests that temporarily disable some\n+targets in the nightly compiler, in order to implement a feature not yet\n+supported by those targets. (As an example, this happened when introducing the\n+128-bit types `u128` and `i128`.) Such a pull request will include notification\n+and coordination with the maintainers of such targets, and will ideally happen\n+towards the beginning of a new development cycle to give maintainers time to\n+update their targets. The maintainers of such targets will then be expected to\n+implement the corresponding target-specific support in order to re-enable the\n+target. If the maintainers of such targets cannot provide such support in time\n+for the next stable release, this may result in demoting or removing the\n+targets.\n+\n+### Tier 2 with host tools\n+\n+Some tier 2 targets may additionally have binaries built to run on them as a\n+host (such as `rustc` and `cargo`). This allows the target to be used as a\n+development platform, not just a compilation target.\n+\n+A proposed new tier 2 target with host tools must be reviewed and approved by\n+the compiler team based on these requirements. Such review and approval may\n+occur via a Major Change Proposal (MCP).\n+\n+In addition, the infrastructure team must approve the integration of the\n+target's host tools into Continuous Integration (CI), and the CI-related\n+requirements for host tools. This review and approval may take place in a PR\n+adding the target's host tools to CI, or simply by an infrastructure team\n+member reporting the outcome of a team discussion.\n+\n+- Depending on the target, its capabilities, its performance, and the\n+  likelihood of use for any given tool, the host tools provided for a tier 2\n+  target may include only `rustc` and `cargo`, or may include additional tools\n+  such as `clippy` and `rustfmt`.\n+- Approval of host tools will take into account the additional time required to\n+  build the host tools, and the substantial additional storage required for the\n+  host tools.\n+- The host tools must have direct value to people other than the target's\n+  maintainers. (It may still be a niche target, but the host tools must not be\n+  exclusively useful for an inherently closed group.) This requirement will be\n+  evaluated independently from the corresponding tier 2 requirement.\n+  - The requirement to provide \"direct value\" means that it does not suffice to\n+    argue that having host tools will help the target's maintainers more easily\n+    provide the target to others. The tools themselves must provide value to\n+    others.\n+- There must be a reasonable expectation that the host tools will be used, for\n+  purposes other than to prove that they can be used.\n+- The host tools must build and run reliably in CI (for all components that\n+  Rust's CI considers mandatory), though they may or may not pass tests.\n+- Building host tools for the target must not take substantially longer than\n+  building host tools for other targets, and should not substantially raise the\n+  maintenance burden of the CI infrastructure.\n+- The host tools must provide a substantively similar experience as on other\n+  targets, subject to reasonable target limitations.\n+  - Adding a substantively different interface to an existing tool, or a\n+    target-specific interface to the functionality of an existing tool,\n+    requires design and implementation approval (e.g. RFC/MCP) from the\n+    appropriate approving teams for that tool.\n+    - Such an interface should have a design that could potentially work for\n+      other targets with similar properties.\n+    - This should happen separately from the review and approval of the target,\n+      to simplify the target review and approval processes, and to simplify the\n+      review and approval processes for the proposed new interface.\n+  - By way of example, a target that runs within a sandbox may need to modify\n+    the handling of files, tool invocation, and similar to meet the\n+    expectations and conventions of the sandbox, but must not introduce a\n+    separate \"sandboxed compilation\" interface separate from the CLI interface\n+    without going through the normal approval process for such an interface.\n+    Such an interface should take into account potential other targets with\n+    similar sandboxes.\n+- If the host tools for the platform would normally be expected to be signed or\n+  equivalent (e.g. if running unsigned binaries or similar involves a\n+  \"developer mode\" or an additional prompt), it must be possible for the Rust\n+  project's automated builds to apply the appropriate signature process,\n+  without any manual intervention by either Rust developers, target\n+  maintainers, or a third party. This process must meet the approval of the\n+  infrastructure team.\n+  - This process may require one-time or semi-regular manual steps by the\n+    infrastructure team, such as registration or renewal of a signing key. Any\n+    such manual process must meet the approval of the infrastructure team.\n+  - This process may require the execution of a legal agreement with the\n+    signature provider. Such a legal agreement may be revocable, and may\n+    potentially require a nominal fee, but must not be otherwise onerous. Any\n+    such legal agreement must meet the approval of the infrastructure team.\n+    (The infrastructure team is not expected or required to sign binding legal\n+    agreements on behalf of the Rust project; this review and approval exists\n+    to ensure no terms are onerous or cause problems for infrastructure,\n+    especially if such terms may impose requirements or obligations on people\n+    who have access to target-specific infrastructure.)\n+  - Changes to this process, or to any legal agreements involved, may\n+    cause a target to stop meeting this requirement.\n+  - This process involved must be available under substantially similar\n+    non-onerous terms to the general public. Making it available exclusively to\n+    the Rust project does not suffice.\n+  - This requirement exists to ensure that Rust builds, including nightly\n+    builds, can meet the necessary requirements to allow users to smoothly run\n+    the host tools.\n+- Providing host tools does not exempt a target from requirements to support\n+  cross-compilation if at all possible.\n+- All requirements for tier 2 apply.\n+\n+A target may be promoted directly from tier 3 to tier 2 with host tools if it\n+meets all the necessary requirements, but doing so may introduce substantial\n+additional complexity. If in doubt, the target should qualify for tier 2\n+without host tools first.\n+\n+## Tier 1 target policy\n+\n+At this tier, the Rust project guarantees that a target builds and passes all\n+tests, and will reject patches that fail to build or pass the testsuite on a\n+target. We hold tier 1 targets to our highest standard of requirements.\n+\n+A proposed new tier 1 target must be reviewed and approved by the compiler team\n+based on these requirements. In addition, the release team must approve the\n+viability and value of supporting the target. For a tier 1 target, this will\n+typically take place via a full RFC proposing the target, to be jointly\n+reviewed and approved by the compiler team and release team.\n+\n+In addition, the infrastructure team must approve the integration of the target\n+into Continuous Integration (CI), and the tier 1 CI-related requirements. This\n+review and approval may take place in a PR adding the target to CI, by an\n+infrastructure team member reporting the outcome of a team discussion, or by\n+including the infrastructure team in the RFC proposing the target.\n+\n+- Tier 1 targets must have substantial, widespread interest within the\n+  developer community, and must serve the ongoing needs of multiple production\n+  users of Rust across multiple organizations or projects. These requirements\n+  are subjective, and determined by consensus of the approving teams. A tier 1\n+  target may be demoted or removed if it becomes obsolete or no longer meets\n+  this requirement.\n+- The target maintainer team must include at least 3 developers.\n+- The target must build and pass tests reliably in CI, for all components that\n+  Rust's CI considers mandatory.\n+  - The target must not disable an excessive number of tests or pieces of tests\n+    in the testsuite in order to do so. This is a subjective requirement.\n+  - If the target does not have host tools support, or if the target has low\n+    performance, the infrastructure team may choose to have CI cross-compile\n+    the testsuite from another platform, and then run the compiled tests\n+    either natively or via accurate emulation. However, the approving teams may\n+    take such performance considerations into account when determining the\n+    viability of the target or of its host tools.\n+- The target must provide as much of the Rust standard library as is feasible\n+  and appropriate to provide. For instance, if the target can support dynamic\n+  memory allocation, it must provide an implementation of `alloc` and the\n+  associated data structures.\n+- Building the target and running the testsuite for the target must not take\n+  substantially longer than other targets, and should not substantially raise\n+  the maintenance burden of the CI infrastructure.\n+  - In particular, if building the target takes a reasonable amount of time,\n+    but the target cannot run the testsuite in a timely fashion due to low\n+    performance of either native code or accurate emulation, that alone may\n+    prevent the target from qualifying as tier 1.\n+- If running the testsuite requires additional infrastructure (such as physical\n+  systems running the target), the target maintainers must arrange to provide\n+  such resources to the Rust project, to the satisfaction and approval of the\n+  Rust infrastructure team.\n+  - Such resources may be provided via cloud systems, via emulation, or via\n+    physical hardware.\n+  - If the target requires the use of emulation to meet any of the tier\n+    requirements, the approving teams for those requirements must have high\n+    confidence in the accuracy of the emulation, such that discrepancies\n+    between emulation and native operation that affect test results will\n+    constitute a high-priority bug in either the emulation or the\n+    implementation of the target.\n+  - If it is not possible to run the target via emulation, these resources must\n+    additionally be sufficient for the Rust infrastructure team to make them\n+    available for access by Rust team members, for the purposes of development\n+    and testing. (Note that the responsibility for doing target-specific\n+    development to keep the target well maintained remains with the target\n+    maintainers. This requirement ensures that it is possible for other\n+    Rust developers to test the target, but does not obligate other Rust\n+    developers to make target-specific fixes.)\n+  - Resources provided for CI and similar infrastructure must be available for\n+    continuous exclusive use by the Rust project. Resources provided\n+    for access by Rust team members for development and testing must be\n+    available on an exclusive basis when in use, but need not be available on a\n+    continuous basis when not in use.\n+- Tier 1 targets must not have a hard requirement for signed, verified, or\n+  otherwise \"approved\" binaries. Developers must be able to build, run, and\n+  test binaries for the target on systems they control, or provide such\n+  binaries for others to run. (Doing so may require enabling some appropriate\n+  \"developer mode\" on such systems, but must not require the payment of any\n+  additional fee or other consideration, or agreement to any onerous legal\n+  agreements.)\n+  - The Rust project may decide to supply appropriately signed binaries if\n+    doing so provides a smoother experience for developers using the target,\n+    and a tier 2 target with host tools already requires providing appropriate\n+    mechanisms that enable our infrastructure to provide such signed binaries.\n+    However, this additional tier 1 requirement ensures that Rust developers\n+    can develop and test Rust software for the target (including Rust itself),\n+    and that development or testing for the target is not limited.\n+- All requirements for tier 2 apply.\n+\n+A tier 1 target may be demoted if it no longer meets these requirements but\n+still meets the requirements for a lower tier. Any proposal for demotion of a\n+tier 1 target requires a full RFC process, with approval by the compiler and\n+release teams. Any such proposal will be communicated widely to the Rust\n+community, both when initially proposed and before being dropped from a stable\n+release. A tier 1 target is highly unlikely to be directly removed without\n+first being demoted to tier 2 or tier 3. (The amount of time between such\n+communication and the next stable release may depend on the nature and severity\n+of the failed requirement, the timing of its discovery, whether the target has\n+been part of a stable release yet, and whether the demotion or removal can be a\n+planned and scheduled action.)\n+\n+Raising the baseline expectations of a tier 1 target (such as the minimum CPU\n+features or OS version required) requires the approval of the compiler and\n+release teams, and should be widely communicated as well, but does not\n+necessarily require a full RFC.\n+\n+### Tier 1 with host tools\n+\n+Some tier 1 targets may additionally have binaries built to run on them as a\n+host (such as `rustc` and `cargo`). This allows the target to be used as a\n+development platform, not just a compilation target.\n+\n+A proposed new tier 1 target with host tools must be reviewed and approved by\n+the compiler team based on these requirements. In addition, the release team\n+must approve the viability and value of supporting host tools for the target.\n+For a tier 1 target, this will typically take place via a full RFC proposing\n+the target, to be jointly reviewed and approved by the compiler team and\n+release team.\n+\n+In addition, the infrastructure team must approve the integration of the\n+target's host tools into Continuous Integration (CI), and the CI-related\n+requirements for host tools. This review and approval may take place in a PR\n+adding the target's host tools to CI, by an infrastructure team member\n+reporting the outcome of a team discussion, or by including the infrastructure\n+team in the RFC proposing the target.\n+\n+- Tier 1 targets with host tools should typically include all of the additional\n+  tools such as `clippy` and `rustfmt`, unless there is a target-specific\n+  reason why a tool cannot possibly make sense for the target.\n+  - Unlike with tier 2, for tier 1 we will not exclude specific tools on the\n+    sole basis of them being less likely to be used; rather, we'll take that\n+    into account when considering whether the target should be at tier 1 with\n+    host tools. In general, on any tier 1 target with host tools, people\n+    should be able to expect to find and install all the same components that\n+    they would for any other tier 1 target with host tools.\n+- Approval of host tools will take into account the additional time required to\n+  build the host tools, and the substantial additional storage required for the\n+  host tools.\n+- Host tools for the target must have substantial, widespread interest within\n+  the developer community, and must serve the ongoing needs of multiple\n+  production users of Rust across multiple organizations or projects. These\n+  requirements are subjective, and determined by consensus of the approving\n+  teams. This requirement will be evaluated independently from the\n+  corresponding tier 1 requirement; it is possible for a target to have\n+  sufficient interest for cross-compilation, but not have sufficient interest\n+  for native compilation. The host tools may be dropped if they no longer meet\n+  this requirement, even if the target otherwise qualifies as tier 1.\n+- The host tools must build, run, and pass tests reliably in CI, for all\n+  components that Rust's CI considers mandatory.\n+  - The target must not disable an excessive number of tests or pieces of tests\n+    in the testsuite in order to do so. This is a subjective requirement.\n+- Building the host tools and running the testsuite for the host tools must not\n+  take substantially longer than other targets, and should not substantially raise\n+  the maintenance burden of the CI infrastructure.\n+  - In particular, if building the target's host tools takes a reasonable\n+    amount of time, but the target cannot run the testsuite in a timely fashion\n+    due to low performance of either native code or accurate emulation, that\n+    alone may prevent the target from qualifying as tier 1 with host tools.\n+- Providing host tools does not exempt a target from requirements to support\n+  cross-compilation if at all possible.\n+- All requirements for tier 2 targets with host tools apply.\n+- All requirements for tier 1 apply.\n+\n+A target seeking promotion to tier 1 with host tools should typically either be\n+tier 2 with host tools or tier 1 without host tools, to reduce the number of\n+requirements to simultaneously review and approve.\n+\n+In addition to the general process for demoting a tier 1 target, a tier 1\n+target with host tools may be demoted (including having its host tools dropped,\n+or being demoted to tier 2 with host tools) if it no longer meets these\n+requirements but still meets the requirements for a lower tier. Any proposal\n+for demotion of a tier 1 target (with or without host tools) requires a full\n+RFC process, with approval by the compiler and release teams. Any such proposal\n+will be communicated widely to the Rust community, both when initially proposed\n+and before being dropped from a stable release."}]}