{"sha": "b0dcadfc45bb04be3ba56d8bd62f1331a98949dc", "node_id": "C_kwDOAAsO6NoAKGIwZGNhZGZjNDViYjA0YmUzYmE1NmQ4YmQ2MmYxMzMxYTk4OTQ5ZGM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-07T17:00:33Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-07T17:00:33Z"}, "message": "Move closure/generator type info methods to TyCtxt", "tree": {"sha": "f7c25a3f83910de6deafa50be23816140071a7cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7c25a3f83910de6deafa50be23816140071a7cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc", "html_url": "https://github.com/rust-lang/rust/commit/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b45b9489bb3fb918fbe267154f8dcf4fee61854d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b45b9489bb3fb918fbe267154f8dcf4fee61854d", "html_url": "https://github.com/rust-lang/rust/commit/b45b9489bb3fb918fbe267154f8dcf4fee61854d"}], "stats": {"total": 159, "additions": 84, "deletions": 75}, "files": [{"sha": "a9e3dcf4cb39a7c56663f6bb271c82e0003ea71f", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 67, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=b0dcadfc45bb04be3ba56d8bd62f1331a98949dc", "patch": "@@ -27,9 +27,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_fs_util::path_to_c_string;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::bug;\n-use rustc_middle::mir::{self, GeneratorLayout};\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{\n@@ -1026,33 +1024,6 @@ fn build_struct_type_di_node<'ll, 'tcx>(\n // Tuples\n //=-----------------------------------------------------------------------------\n \n-/// Returns names of captured upvars for closures and generators.\n-///\n-/// Here are some examples:\n-///  - `name__field1__field2` when the upvar is captured by value.\n-///  - `_ref__name__field` when the upvar is captured by reference.\n-///\n-/// For generators this only contains upvars that are shared by all states.\n-fn closure_saved_names_of_captured_variables(tcx: TyCtxt<'_>, def_id: DefId) -> SmallVec<String> {\n-    let body = tcx.optimized_mir(def_id);\n-\n-    body.var_debug_info\n-        .iter()\n-        .filter_map(|var| {\n-            let is_ref = match var.value {\n-                mir::VarDebugInfoContents::Place(place) if place.local == mir::Local::new(1) => {\n-                    // The projection is either `[.., Field, Deref]` or `[.., Field]`. It\n-                    // implies whether the variable is captured by value or by reference.\n-                    matches!(place.projection.last().unwrap(), mir::ProjectionElem::Deref)\n-                }\n-                _ => return None,\n-            };\n-            let prefix = if is_ref { \"_ref__\" } else { \"\" };\n-            Some(prefix.to_owned() + var.name.as_str())\n-        })\n-        .collect()\n-}\n-\n /// Builds the DW_TAG_member debuginfo nodes for the upvars of a closure or generator.\n /// For a generator, this will handle upvars shared by all states.\n fn build_upvar_field_di_nodes<'ll, 'tcx>(\n@@ -1083,7 +1054,7 @@ fn build_upvar_field_di_nodes<'ll, 'tcx>(\n             .all(|&t| t == cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t))\n     );\n \n-    let capture_names = closure_saved_names_of_captured_variables(cx.tcx, def_id);\n+    let capture_names = cx.tcx.closure_saved_names_of_captured_variables(def_id);\n     let layout = cx.layout_of(closure_or_generator_ty);\n \n     up_var_tys\n@@ -1229,43 +1200,6 @@ fn build_union_type_di_node<'ll, 'tcx>(\n     )\n }\n \n-// FIXME(eddyb) maybe precompute this? Right now it's computed once\n-// per generator monomorphization, but it doesn't depend on substs.\n-fn generator_layout_and_saved_local_names<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-) -> (&'tcx GeneratorLayout<'tcx>, IndexVec<mir::GeneratorSavedLocal, Option<Symbol>>) {\n-    let body = tcx.optimized_mir(def_id);\n-    let generator_layout = body.generator_layout().unwrap();\n-    let mut generator_saved_local_names = IndexVec::from_elem(None, &generator_layout.field_tys);\n-\n-    let state_arg = mir::Local::new(1);\n-    for var in &body.var_debug_info {\n-        let mir::VarDebugInfoContents::Place(place) = &var.value else { continue };\n-        if place.local != state_arg {\n-            continue;\n-        }\n-        match place.projection[..] {\n-            [\n-                // Deref of the `Pin<&mut Self>` state argument.\n-                mir::ProjectionElem::Field(..),\n-                mir::ProjectionElem::Deref,\n-                // Field of a variant of the state.\n-                mir::ProjectionElem::Downcast(_, variant),\n-                mir::ProjectionElem::Field(field, _),\n-            ] => {\n-                let name = &mut generator_saved_local_names\n-                    [generator_layout.variant_fields[variant][field]];\n-                if name.is_none() {\n-                    name.replace(var.name);\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-    (generator_layout, generator_saved_local_names)\n-}\n-\n /// Computes the type parameters for a type, if any, for the given metadata.\n fn build_generic_type_param_di_nodes<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,"}, {"sha": "69443b9b828e2caf3a19ba382557c3431ada8169", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs?ref=b0dcadfc45bb04be3ba56d8bd62f1331a98949dc", "patch": "@@ -22,9 +22,9 @@ use crate::{\n     common::CodegenCx,\n     debuginfo::{\n         metadata::{\n-            build_field_di_node, closure_saved_names_of_captured_variables,\n+            build_field_di_node,\n             enums::{tag_base_type, DiscrResult},\n-            file_metadata, generator_layout_and_saved_local_names, size_and_align_of, type_di_node,\n+            file_metadata, size_and_align_of, type_di_node,\n             type_map::{self, Stub, UniqueTypeId},\n             unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS, NO_SCOPE_METADATA,\n             UNKNOWN_LINE_NUMBER,\n@@ -677,9 +677,9 @@ fn build_union_fields_for_direct_tag_generator<'ll, 'tcx>(\n     };\n \n     let (generator_layout, state_specific_upvar_names) =\n-        generator_layout_and_saved_local_names(cx.tcx, generator_def_id);\n+        cx.tcx.generator_layout_and_saved_local_names(generator_def_id);\n \n-    let common_upvar_names = closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n+    let common_upvar_names = cx.tcx.closure_saved_names_of_captured_variables(generator_def_id);\n     let variant_range = generator_substs.variant_range(generator_def_id, cx.tcx);\n     let variant_count = (variant_range.start.as_u32()..variant_range.end.as_u32()).len();\n "}, {"sha": "93419d27a6236c5356a1a4045c7e05b0225794a6", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=b0dcadfc45bb04be3ba56d8bd62f1331a98949dc", "patch": "@@ -4,9 +4,8 @@ use crate::{\n     common::CodegenCx,\n     debuginfo::{\n         metadata::{\n-            closure_saved_names_of_captured_variables,\n             enums::tag_base_type,\n-            file_metadata, generator_layout_and_saved_local_names, size_and_align_of, type_di_node,\n+            file_metadata, size_and_align_of, type_di_node,\n             type_map::{self, Stub, StubInfo, UniqueTypeId},\n             unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS,\n             UNKNOWN_LINE_NUMBER,\n@@ -157,7 +156,7 @@ pub(super) fn build_generator_di_node<'ll, 'tcx>(\n         ),\n         |cx, generator_type_di_node| {\n             let (generator_layout, state_specific_upvar_names) =\n-                generator_layout_and_saved_local_names(cx.tcx, generator_def_id);\n+                cx.tcx.generator_layout_and_saved_local_names(generator_def_id);\n \n             let Variants::Multiple { tag_encoding: TagEncoding::Direct, ref variants, .. } = generator_type_and_layout.variants else {\n                 bug!(\n@@ -167,7 +166,7 @@ pub(super) fn build_generator_di_node<'ll, 'tcx>(\n             };\n \n             let common_upvar_names =\n-                closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n+                cx.tcx.closure_saved_names_of_captured_variables(generator_def_id);\n \n             // Build variant struct types\n             let variant_struct_type_di_nodes: SmallVec<_> = variants"}, {"sha": "9ea8dc6e69fdde0b172103282cd1c384bd3fb5b2", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=b0dcadfc45bb04be3ba56d8bd62f1331a98949dc", "patch": "@@ -1,6 +1,7 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use crate::mir;\n use crate::ty::layout::IntegerExt;\n use crate::ty::{\n     self, DefIdTree, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n@@ -15,6 +16,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::GrowableBitSet;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_span::{sym, DUMMY_SP};\n use rustc_target::abi::{Integer, IntegerType, Size, TargetDataLayout};\n@@ -692,6 +694,80 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn bound_impl_subject(self, def_id: DefId) -> ty::EarlyBinder<ty::ImplSubject<'tcx>> {\n         ty::EarlyBinder(self.impl_subject(def_id))\n     }\n+\n+    /// Returns names of captured upvars for closures and generators.\n+    ///\n+    /// Here are some examples:\n+    ///  - `name__field1__field2` when the upvar is captured by value.\n+    ///  - `_ref__name__field` when the upvar is captured by reference.\n+    ///\n+    /// For generators this only contains upvars that are shared by all states.\n+    pub fn closure_saved_names_of_captured_variables(\n+        self,\n+        def_id: DefId,\n+    ) -> SmallVec<[String; 16]> {\n+        let body = self.optimized_mir(def_id);\n+\n+        body.var_debug_info\n+            .iter()\n+            .filter_map(|var| {\n+                let is_ref = match var.value {\n+                    mir::VarDebugInfoContents::Place(place)\n+                        if place.local == mir::Local::new(1) =>\n+                    {\n+                        // The projection is either `[.., Field, Deref]` or `[.., Field]`. It\n+                        // implies whether the variable is captured by value or by reference.\n+                        matches!(place.projection.last().unwrap(), mir::ProjectionElem::Deref)\n+                    }\n+                    _ => return None,\n+                };\n+                let prefix = if is_ref { \"_ref__\" } else { \"\" };\n+                Some(prefix.to_owned() + var.name.as_str())\n+            })\n+            .collect()\n+    }\n+\n+    // FIXME(eddyb) maybe precompute this? Right now it's computed once\n+    // per generator monomorphization, but it doesn't depend on substs.\n+    pub fn generator_layout_and_saved_local_names(\n+        self,\n+        def_id: DefId,\n+    ) -> (\n+        &'tcx ty::GeneratorLayout<'tcx>,\n+        IndexVec<mir::GeneratorSavedLocal, Option<rustc_span::Symbol>>,\n+    ) {\n+        let tcx = self;\n+        let body = tcx.optimized_mir(def_id);\n+        let generator_layout = body.generator_layout().unwrap();\n+        let mut generator_saved_local_names =\n+            IndexVec::from_elem(None, &generator_layout.field_tys);\n+\n+        let state_arg = mir::Local::new(1);\n+        for var in &body.var_debug_info {\n+            let mir::VarDebugInfoContents::Place(place) = &var.value else { continue };\n+            if place.local != state_arg {\n+                continue;\n+            }\n+            match place.projection[..] {\n+                [\n+                    // Deref of the `Pin<&mut Self>` state argument.\n+                    mir::ProjectionElem::Field(..),\n+                    mir::ProjectionElem::Deref,\n+                    // Field of a variant of the state.\n+                    mir::ProjectionElem::Downcast(_, variant),\n+                    mir::ProjectionElem::Field(field, _),\n+                ] => {\n+                    let name = &mut generator_saved_local_names\n+                        [generator_layout.variant_fields[variant][field]];\n+                    if name.is_none() {\n+                        name.replace(var.name);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        (generator_layout, generator_saved_local_names)\n+    }\n }\n \n struct OpaqueTypeExpander<'tcx> {"}]}