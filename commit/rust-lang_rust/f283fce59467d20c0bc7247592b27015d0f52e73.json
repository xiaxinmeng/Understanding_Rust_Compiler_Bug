{"sha": "f283fce59467d20c0bc7247592b27015d0f52e73", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyODNmY2U1OTQ2N2QyMGMwYmM3MjQ3NTkyYjI3MDE1ZDBmNTJlNzM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-23T15:21:47Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-23T15:21:47Z"}, "message": "Mark (method-)calls with never type as exit points", "tree": {"sha": "64f89a74bfc9c44afaae97ef7d1f6976a9e2a50b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64f89a74bfc9c44afaae97ef7d1f6976a9e2a50b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f283fce59467d20c0bc7247592b27015d0f52e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f283fce59467d20c0bc7247592b27015d0f52e73", "html_url": "https://github.com/rust-lang/rust/commit/f283fce59467d20c0bc7247592b27015d0f52e73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f283fce59467d20c0bc7247592b27015d0f52e73/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc791538d6f6b5cb09010c93b0b645009953dc18", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc791538d6f6b5cb09010c93b0b645009953dc18", "html_url": "https://github.com/rust-lang/rust/commit/cc791538d6f6b5cb09010c93b0b645009953dc18"}], "stats": {"total": 67, "additions": 58, "deletions": 9}, "files": [{"sha": "3a901cbbf866915521221a2472001230ae1e6bc9", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f283fce59467d20c0bc7247592b27015d0f52e73/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283fce59467d20c0bc7247592b27015d0f52e73/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f283fce59467d20c0bc7247592b27015d0f52e73", "patch": "@@ -2075,10 +2075,15 @@ impl Type {\n     pub fn is_unit(&self) -> bool {\n         matches!(self.ty.kind(&Interner), TyKind::Tuple(0, ..))\n     }\n+\n     pub fn is_bool(&self) -> bool {\n         matches!(self.ty.kind(&Interner), TyKind::Scalar(Scalar::Bool))\n     }\n \n+    pub fn is_never(&self) -> bool {\n+        matches!(self.ty.kind(&Interner), TyKind::Never)\n+    }\n+\n     pub fn is_mutable_reference(&self) -> bool {\n         matches!(self.ty.kind(&Interner), TyKind::Ref(hir_ty::Mutability::Mut, ..))\n     }"}, {"sha": "de918ac86f44f297c2c03adb9a91283a838b1b24", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f283fce59467d20c0bc7247592b27015d0f52e73/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283fce59467d20c0bc7247592b27015d0f52e73/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=f283fce59467d20c0bc7247592b27015d0f52e73", "patch": "@@ -36,7 +36,7 @@ pub(crate) fn highlight_related(\n     })?;\n \n     match token.kind() {\n-        QUESTION | RETURN_KW | THIN_ARROW => highlight_exit_points(token),\n+        QUESTION | RETURN_KW | THIN_ARROW => highlight_exit_points(sema, token),\n         AWAIT_KW | ASYNC_KW => highlight_yield_points(token),\n         _ => highlight_references(sema, &syntax, position),\n     }\n@@ -74,8 +74,14 @@ fn highlight_references(\n     Some(res)\n }\n \n-fn highlight_exit_points(token: SyntaxToken) -> Option<Vec<DocumentHighlight>> {\n-    fn hl(body: Option<ast::Expr>) -> Option<Vec<DocumentHighlight>> {\n+fn highlight_exit_points(\n+    sema: &Semantics<RootDatabase>,\n+    token: SyntaxToken,\n+) -> Option<Vec<DocumentHighlight>> {\n+    fn hl(\n+        sema: &Semantics<RootDatabase>,\n+        body: Option<ast::Expr>,\n+    ) -> Option<Vec<DocumentHighlight>> {\n         let mut highlights = Vec::new();\n         let body = body?;\n         walk(&body, |node| {\n@@ -93,9 +99,19 @@ fn highlight_exit_points(token: SyntaxToken) -> Option<Vec<DocumentHighlight>> {\n                             range: token.text_range(),\n                         });\n                     },\n-                    // All the following are different contexts so skip them\n-                    ast::EffectExpr(effect) => return effect.async_token().is_some() || effect.try_token().is_some(),\n-                    ast::ClosureExpr(__) => return true,\n+                    ast::Expr(expr) => match expr {\n+                        ast::Expr::MethodCallExpr(_) | ast::Expr::CallExpr(_) | ast::Expr::MacroCall(_) => {\n+                            if sema.type_of_expr(&expr).map_or(false, |ty| ty.is_never()) {\n+                                highlights.push(DocumentHighlight {\n+                                    access: None,\n+                                    range: expr.syntax().text_range(),\n+                                });\n+                            }\n+                        },\n+                        ast::Expr::EffectExpr(effect) => return effect.async_token().is_some() || effect.try_token().is_some(),\n+                        ast::Expr::ClosureExpr(_) => return true,\n+                        _ => (),\n+                    },\n                     ast::Item(__) => return true,\n                     // Don't look into const args\n                     ast::Path(__) => return true,\n@@ -116,10 +132,10 @@ fn highlight_exit_points(token: SyntaxToken) -> Option<Vec<DocumentHighlight>> {\n     for anc in token.ancestors() {\n         return match_ast! {\n             match anc {\n-                ast::Fn(fn_) => hl(fn_.body().map(ast::Expr::BlockExpr)),\n-                ast::ClosureExpr(closure) => hl(closure.body()),\n+                ast::Fn(fn_) => hl(sema, fn_.body().map(ast::Expr::BlockExpr)),\n+                ast::ClosureExpr(closure) => hl(sema, closure.body()),\n                 ast::EffectExpr(effect) => if effect.async_token().is_some() || effect.try_token().is_some() {\n-                    hl(effect.block_expr().map(ast::Expr::BlockExpr))\n+                    hl(sema, effect.block_expr().map(ast::Expr::BlockExpr))\n                 } else {\n                     continue;\n                 },\n@@ -399,6 +415,34 @@ fn foo() -> u32 {\n     foo$0()\n  // ^^^\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_never_call_is_exit_point() {\n+        check(\n+            r#\"\n+struct Never;\n+impl Never {\n+    fn never(self) -> ! { loop {} }\n+}\n+macro_rules! never {\n+    () => { never() }\n+}\n+fn never() -> ! { loop {} }\n+fn foo() ->$0 u32 {\n+    never();\n+ // ^^^^^^^\n+    never!();\n+ // FIXME sema doesnt give us types for macrocalls\n+\n+    Never.never();\n+ // ^^^^^^^^^^^^^\n+\n+    0\n+ // ^\n+}\n \"#,\n         );\n     }"}]}