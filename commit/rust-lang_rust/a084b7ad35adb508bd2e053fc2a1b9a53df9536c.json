{"sha": "a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "node_id": "C_kwDOAAsO6NoAKGEwODRiN2FkMzVhZGI1MDhiZDJlMDUzZmMyYTFiOWE1M2RmOTUzNmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-18T07:12:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-18T07:12:11Z"}, "message": "Auto merge of #97135 - Dylan-DPC:rollup-06u9pqn, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #94639 (Suggest dereferencing non-lval mutable reference on assignment)\n - #95979 (update coherence docs, fix generator + opaque type ICE)\n - #96378 (Mention traits and types involved in unstable trait upcasting)\n - #96917 (Make HashMap fall back to RtlGenRandom if BCryptGenRandom fails)\n - #97101 (Add tracking issue for ExitCode::exit_process)\n - #97123 (Clean fix for #96223)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "540179ca7bc9385501adc59c6ade1586bc03364a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/540179ca7bc9385501adc59c6ade1586bc03364a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "html_url": "https://github.com/rust-lang/rust/commit/a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77972d2d0134fb597249b3b64dcf9510a790c34e", "url": "https://api.github.com/repos/rust-lang/rust/commits/77972d2d0134fb597249b3b64dcf9510a790c34e", "html_url": "https://github.com/rust-lang/rust/commit/77972d2d0134fb597249b3b64dcf9510a790c34e"}, {"sha": "a2c2720e09202e1f988ff568efa4dcac8a71a504", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2c2720e09202e1f988ff568efa4dcac8a71a504", "html_url": "https://github.com/rust-lang/rust/commit/a2c2720e09202e1f988ff568efa4dcac8a71a504"}], "stats": {"total": 851, "additions": 636, "deletions": 215}, "files": [{"sha": "4d30c0e35e4726d42ba46517da1ff58350a2d41d", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -61,6 +61,9 @@ pub enum Reveal {\n     ///     let x: <() as Assoc>::Output = true;\n     /// }\n     /// ```\n+    ///\n+    /// We also do not reveal the hidden type of opaque types during\n+    /// type-checking.\n     UserFacing,\n \n     /// At codegen time, all monomorphic projections will succeed."}, {"sha": "e56173b2dc50f9013e14b1192d1f4ebcbc5c2137", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -645,7 +645,7 @@ fn orphan_check_trait_ref<'tcx>(\n                 .substs\n                 .types()\n                 .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                .find(|ty| ty_is_local_constructor(*ty, in_crate));\n+                .find(|&ty| ty_is_local_constructor(tcx, ty, in_crate));\n \n             debug!(\"orphan_check_trait_ref: uncovered ty local_type: `{:?}`\", local_type);\n \n@@ -677,7 +677,7 @@ fn contained_non_local_types<'tcx>(\n     ty: Ty<'tcx>,\n     in_crate: InCrate,\n ) -> Vec<Ty<'tcx>> {\n-    if ty_is_local_constructor(ty, in_crate) {\n+    if ty_is_local_constructor(tcx, ty, in_crate) {\n         Vec::new()\n     } else {\n         match fundamental_ty_inner_tys(tcx, ty) {\n@@ -730,7 +730,7 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n     }\n }\n \n-fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n+fn ty_is_local_constructor(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match *ty.kind() {\n@@ -789,11 +789,6 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n             false\n         }\n \n-        ty::Closure(..) => {\n-            // Similar to the `Opaque` case (#83613).\n-            false\n-        }\n-\n         ty::Dynamic(ref tt, ..) => {\n             if let Some(principal) = tt.principal() {\n                 def_id_is_local(principal.def_id(), in_crate)\n@@ -804,8 +799,20 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n \n         ty::Error(_) => true,\n \n-        ty::Generator(..) | ty::GeneratorWitness(..) => {\n-            bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n+        // These variants should never appear during coherence checking because they\n+        // cannot be named directly.\n+        //\n+        // They could be indirectly used through an opaque type. While using opaque types\n+        // in impls causes an error, this path can still be hit afterwards.\n+        //\n+        // See `test/ui/coherence/coherence-with-closure.rs` for an example where this\n+        // could happens.\n+        ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n+            tcx.sess.delay_span_bug(\n+                DUMMY_SP,\n+                format!(\"ty_is_local invoked on closure or generator: {:?}\", ty),\n+            );\n+            true\n         }\n     }\n }"}, {"sha": "266fcc777ef565738b1d83cdc3b6a6af4e76e7c8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -1384,8 +1384,7 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n     fn mk_trait_obligation_with_new_self_ty(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: ty::PolyTraitPredicate<'tcx>,\n-        new_self_ty: Ty<'tcx>,\n+        trait_ref_and_ty: ty::Binder<'tcx, (ty::TraitPredicate<'tcx>, Ty<'tcx>)>,\n     ) -> PredicateObligation<'tcx>;\n \n     fn maybe_report_ambiguity(\n@@ -1923,14 +1922,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     fn mk_trait_obligation_with_new_self_ty(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: ty::PolyTraitPredicate<'tcx>,\n-        new_self_ty: Ty<'tcx>,\n+        trait_ref_and_ty: ty::Binder<'tcx, (ty::TraitPredicate<'tcx>, Ty<'tcx>)>,\n     ) -> PredicateObligation<'tcx> {\n-        assert!(!new_self_ty.has_escaping_bound_vars());\n-\n-        let trait_pred = trait_ref.map_bound_ref(|tr| ty::TraitPredicate {\n+        let trait_pred = trait_ref_and_ty.map_bound_ref(|(tr, new_self_ty)| ty::TraitPredicate {\n             trait_ref: ty::TraitRef {\n-                substs: self.tcx.mk_substs_trait(new_self_ty, &tr.trait_ref.substs[1..]),\n+                substs: self.tcx.mk_substs_trait(*new_self_ty, &tr.trait_ref.substs[1..]),\n                 ..tr.trait_ref\n             },\n             ..*tr"}, {"sha": "c3ee849d857165346ce33eeddb69f73c2da7d49e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 126, "deletions": 120, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -628,17 +628,21 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if let Some(parent_trait_pred) = parent_trait_pred {\n                 real_trait_pred = parent_trait_pred;\n             }\n-            let Some(real_ty) = real_trait_pred.self_ty().no_bound_vars() else {\n-                continue;\n-            };\n+\n+            // Skipping binder here, remapping below\n+            let real_ty = real_trait_pred.self_ty().skip_binder();\n \n             if let ty::Ref(region, base_ty, mutbl) = *real_ty.kind() {\n                 let mut autoderef = Autoderef::new(self, param_env, body_id, span, base_ty, span);\n                 if let Some(steps) = autoderef.find_map(|(ty, steps)| {\n                     // Re-add the `&`\n                     let ty = self.tcx.mk_ref(region, TypeAndMut { ty, mutbl });\n-                    let obligation =\n-                        self.mk_trait_obligation_with_new_self_ty(param_env, real_trait_pred, ty);\n+\n+                    // Remapping bound vars here\n+                    let real_trait_pred_and_ty =\n+                        real_trait_pred.map_bound(|inner_trait_pred| (inner_trait_pred, ty));\n+                    let obligation = self\n+                        .mk_trait_obligation_with_new_self_ty(param_env, real_trait_pred_and_ty);\n                     Some(steps).filter(|_| self.predicate_may_hold(&obligation))\n                 }) {\n                     if steps > 0 {\n@@ -659,10 +663,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n                 } else if real_trait_pred != trait_pred {\n                     // This branch addresses #87437.\n+\n+                    // Remapping bound vars here\n+                    let real_trait_pred_and_base_ty =\n+                        real_trait_pred.map_bound(|inner_trait_pred| (inner_trait_pred, base_ty));\n                     let obligation = self.mk_trait_obligation_with_new_self_ty(\n                         param_env,\n-                        real_trait_pred,\n-                        base_ty,\n+                        real_trait_pred_and_base_ty,\n                     );\n                     if self.predicate_may_hold(&obligation) {\n                         err.span_suggestion_verbose(\n@@ -720,9 +727,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n-        let Some(self_ty) = trait_pred.self_ty().no_bound_vars() else {\n-            return false;\n-        };\n+        // Skipping binder here, remapping below\n+        let self_ty = trait_pred.self_ty().skip_binder();\n \n         let (def_id, output_ty, callable) = match *self_ty.kind() {\n             ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig().output(), \"closure\"),\n@@ -731,14 +737,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n         let msg = format!(\"use parentheses to call the {}\", callable);\n \n-        // `mk_trait_obligation_with_new_self_ty` only works for types with no escaping bound\n-        // variables, so bail out if we have any.\n-        let Some(output_ty) = output_ty.no_bound_vars() else {\n-            return false;\n-        };\n+        // \"We should really create a single list of bound vars from the combined vars\n+        // from the predicate and function, but instead we just liberate the function bound vars\"\n+        let output_ty = self.tcx.liberate_late_bound_regions(def_id, output_ty);\n+\n+        // Remapping bound vars here\n+        let trait_pred_and_self = trait_pred.map_bound(|trait_pred| (trait_pred, output_ty));\n \n         let new_obligation =\n-            self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_pred, output_ty);\n+            self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_pred_and_self);\n \n         match self.evaluate_obligation(&new_obligation) {\n             Ok(\n@@ -842,96 +849,97 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let param_env = obligation.param_env;\n \n         // Try to apply the original trait binding obligation by borrowing.\n-        let mut try_borrowing = |old_pred: ty::PolyTraitPredicate<'tcx>,\n-                                 blacklist: &[DefId]|\n-         -> bool {\n-            if blacklist.contains(&old_pred.def_id()) {\n-                return false;\n-            }\n-\n-            // This is a quick fix to resolve an ICE (#96223).\n-            // This change should probably be deeper.\n-            // As suggested by @jackh726, `mk_trait_obligation_with_new_self_ty` could take a `Binder<(TraitRef, Ty)>\n-            // instead of `Binder<Ty>` leading to some changes to its call places.\n-            let Some(orig_ty) = old_pred.self_ty().no_bound_vars() else {\n-                return false;\n-            };\n-            let mk_result = |new_ty| {\n-                let obligation =\n-                    self.mk_trait_obligation_with_new_self_ty(param_env, old_pred, new_ty);\n-                self.predicate_must_hold_modulo_regions(&obligation)\n-            };\n-            let imm_result = mk_result(self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, orig_ty));\n-            let mut_result = mk_result(self.tcx.mk_mut_ref(self.tcx.lifetimes.re_static, orig_ty));\n-\n-            if imm_result || mut_result {\n-                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                    // We have a very specific type of error, where just borrowing this argument\n-                    // might solve the problem. In cases like this, the important part is the\n-                    // original type obligation, not the last one that failed, which is arbitrary.\n-                    // Because of this, we modify the error to refer to the original obligation and\n-                    // return early in the caller.\n-\n-                    let msg = format!(\n-                        \"the trait bound `{}: {}` is not satisfied\",\n-                        orig_ty,\n-                        old_pred.print_modifiers_and_trait_path(),\n-                    );\n-                    if has_custom_message {\n-                        err.note(&msg);\n-                    } else {\n-                        err.message =\n-                            vec![(rustc_errors::DiagnosticMessage::Str(msg), Style::NoStyle)];\n-                    }\n-                    if snippet.starts_with('&') {\n-                        // This is already a literal borrow and the obligation is failing\n-                        // somewhere else in the obligation chain. Do not suggest non-sense.\n-                        return false;\n-                    }\n-                    err.span_label(\n-                        span,\n-                        &format!(\n-                            \"expected an implementor of trait `{}`\",\n-                            old_pred.print_modifiers_and_trait_path(),\n-                        ),\n-                    );\n+        let mut try_borrowing =\n+            |old_pred: ty::PolyTraitPredicate<'tcx>, blacklist: &[DefId]| -> bool {\n+                if blacklist.contains(&old_pred.def_id()) {\n+                    return false;\n+                }\n+                // We map bounds to `&T` and `&mut T`\n+                let trait_pred_and_imm_ref = old_pred.map_bound(|trait_pred| {\n+                    (\n+                        trait_pred,\n+                        self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, trait_pred.self_ty()),\n+                    )\n+                });\n+                let trait_pred_and_mut_ref = old_pred.map_bound(|trait_pred| {\n+                    (\n+                        trait_pred,\n+                        self.tcx.mk_mut_ref(self.tcx.lifetimes.re_static, trait_pred.self_ty()),\n+                    )\n+                });\n \n-                    // This if is to prevent a special edge-case\n-                    if matches!(\n-                        span.ctxt().outer_expn_data().kind,\n-                        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop)\n-                    ) {\n-                        // We don't want a borrowing suggestion on the fields in structs,\n-                        // ```\n-                        // struct Foo {\n-                        //  the_foos: Vec<Foo>\n-                        // }\n-                        // ```\n-\n-                        if imm_result && mut_result {\n-                            err.span_suggestions(\n-                                span.shrink_to_lo(),\n-                                \"consider borrowing here\",\n-                                [\"&\".to_string(), \"&mut \".to_string()].into_iter(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                let mk_result = |trait_pred_and_new_ty| {\n+                    let obligation =\n+                        self.mk_trait_obligation_with_new_self_ty(param_env, trait_pred_and_new_ty);\n+                    self.predicate_must_hold_modulo_regions(&obligation)\n+                };\n+                let imm_result = mk_result(trait_pred_and_imm_ref);\n+                let mut_result = mk_result(trait_pred_and_mut_ref);\n+\n+                if imm_result || mut_result {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                        // We have a very specific type of error, where just borrowing this argument\n+                        // might solve the problem. In cases like this, the important part is the\n+                        // original type obligation, not the last one that failed, which is arbitrary.\n+                        // Because of this, we modify the error to refer to the original obligation and\n+                        // return early in the caller.\n+\n+                        let msg = format!(\"the trait bound `{}` is not satisfied\", old_pred);\n+                        if has_custom_message {\n+                            err.note(&msg);\n                         } else {\n-                            err.span_suggestion_verbose(\n-                                span.shrink_to_lo(),\n-                                &format!(\n-                                    \"consider{} borrowing here\",\n-                                    if mut_result { \" mutably\" } else { \"\" }\n-                                ),\n-                                format!(\"&{}\", if mut_result { \"mut \" } else { \"\" }),\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            err.message =\n+                                vec![(rustc_errors::DiagnosticMessage::Str(msg), Style::NoStyle)];\n                         }\n+                        if snippet.starts_with('&') {\n+                            // This is already a literal borrow and the obligation is failing\n+                            // somewhere else in the obligation chain. Do not suggest non-sense.\n+                            return false;\n+                        }\n+                        err.span_label(\n+                            span,\n+                            &format!(\n+                                \"expected an implementor of trait `{}`\",\n+                                old_pred.print_modifiers_and_trait_path(),\n+                            ),\n+                        );\n+\n+                        // This if is to prevent a special edge-case\n+                        if matches!(\n+                            span.ctxt().outer_expn_data().kind,\n+                            ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop)\n+                        ) {\n+                            // We don't want a borrowing suggestion on the fields in structs,\n+                            // ```\n+                            // struct Foo {\n+                            //  the_foos: Vec<Foo>\n+                            // }\n+                            // ```\n+\n+                            if imm_result && mut_result {\n+                                err.span_suggestions(\n+                                    span.shrink_to_lo(),\n+                                    \"consider borrowing here\",\n+                                    [\"&\".to_string(), \"&mut \".to_string()].into_iter(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            } else {\n+                                err.span_suggestion_verbose(\n+                                    span.shrink_to_lo(),\n+                                    &format!(\n+                                        \"consider{} borrowing here\",\n+                                        if mut_result { \" mutably\" } else { \"\" }\n+                                    ),\n+                                    format!(\"&{}\", if mut_result { \"mut \" } else { \"\" }),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                        }\n+                        return true;\n                     }\n-                    return true;\n                 }\n-            }\n-            return false;\n-        };\n+                return false;\n+            };\n \n         if let ObligationCauseCode::ImplDerivedObligation(cause) = &*code {\n             try_borrowing(cause.derived.parent_trait_pred, &[])\n@@ -992,20 +1000,22 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 return false;\n             }\n \n-            let Some(mut suggested_ty) = trait_pred.self_ty().no_bound_vars() else {\n-                return false;\n-            };\n+            // Skipping binder here, remapping below\n+            let mut suggested_ty = trait_pred.self_ty().skip_binder();\n \n             for refs_remaining in 0..refs_number {\n                 let ty::Ref(_, inner_ty, _) = suggested_ty.kind() else {\n                     break;\n                 };\n                 suggested_ty = *inner_ty;\n \n+                // Remapping bound vars here\n+                let trait_pred_and_suggested_ty =\n+                    trait_pred.map_bound(|trait_pred| (trait_pred, suggested_ty));\n+\n                 let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_pred,\n-                    suggested_ty,\n+                    trait_pred_and_suggested_ty,\n                 );\n \n                 if self.predicate_may_hold(&new_obligation) {\n@@ -1125,26 +1135,21 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 return;\n             }\n \n+            // Skipping binder here, remapping below\n             if let ty::Ref(region, t_type, mutability) = *trait_pred.skip_binder().self_ty().kind()\n             {\n-                if region.is_late_bound() || t_type.has_escaping_bound_vars() {\n-                    // Avoid debug assertion in `mk_obligation_for_def_id`.\n-                    //\n-                    // If the self type has escaping bound vars then it's not\n-                    // going to be the type of an expression, so the suggestion\n-                    // probably won't apply anyway.\n-                    return;\n-                }\n-\n                 let suggested_ty = match mutability {\n                     hir::Mutability::Mut => self.tcx.mk_imm_ref(region, t_type),\n                     hir::Mutability::Not => self.tcx.mk_mut_ref(region, t_type),\n                 };\n \n+                // Remapping bound vars here\n+                let trait_pred_and_suggested_ty =\n+                    trait_pred.map_bound(|trait_pred| (trait_pred, suggested_ty));\n+\n                 let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_pred,\n-                    suggested_ty,\n+                    trait_pred_and_suggested_ty,\n                 );\n                 let suggested_ty_would_satisfy_obligation = self\n                     .evaluate_obligation_no_overflow(&new_obligation)\n@@ -1195,7 +1200,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // Only suggest this if the expression behind the semicolon implements the predicate\n             && let Some(typeck_results) = self.in_progress_typeck_results\n             && let Some(ty) = typeck_results.borrow().expr_ty_opt(expr)\n-            && self.predicate_may_hold(&self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_pred, ty))\n+            && self.predicate_may_hold(&self.mk_trait_obligation_with_new_self_ty(\n+                obligation.param_env, trait_pred.map_bound(|trait_pred| (trait_pred, ty))\n+            ))\n         {\n             err.span_label(\n                 expr.span,\n@@ -2727,8 +2734,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 );\n                 let try_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_pred,\n-                    normalized_ty.ty().unwrap(),\n+                    trait_pred.map_bound(|trait_pred| (trait_pred, normalized_ty.ty().unwrap())),\n                 );\n                 debug!(\"suggest_await_before_try: try_trait_obligation {:?}\", try_obligation);\n                 if self.predicate_may_hold(&try_obligation)"}, {"sha": "57ded504b3c422527e03faea09fe9d52d7d713a2", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -103,22 +103,31 @@ pub struct SelectionContext<'cx, 'tcx> {\n     /// require themselves.\n     freshener: TypeFreshener<'cx, 'tcx>,\n \n-    /// If `true`, indicates that the evaluation should be conservative\n-    /// and consider the possibility of types outside this crate.\n+    /// During coherence we have to assume that other crates may add\n+    /// additional impls which we currently don't know about.\n+    ///\n+    /// To deal with this evaluation should be conservative\n+    /// and consider the possibility of impls from outside this crate.\n     /// This comes up primarily when resolving ambiguity. Imagine\n     /// there is some trait reference `$0: Bar` where `$0` is an\n     /// inference variable. If `intercrate` is true, then we can never\n     /// say for sure that this reference is not implemented, even if\n     /// there are *no impls at all for `Bar`*, because `$0` could be\n     /// bound to some type that in a downstream crate that implements\n-    /// `Bar`. This is the suitable mode for coherence. Elsewhere,\n-    /// though, we set this to false, because we are only interested\n-    /// in types that the user could actually have written --- in\n-    /// other words, we consider `$0: Bar` to be unimplemented if\n+    /// `Bar`.\n+    ///\n+    /// Outside of coherence we set this to false because we are only\n+    /// interested in types that the user could actually have written.\n+    /// In other words, we consider `$0: Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n     intercrate: bool,\n-\n+    /// If `intercrate` is set, we remember predicates which were\n+    /// considered ambiguous because of impls potentially added in other crates.\n+    /// This is used in coherence to give improved diagnostics.\n+    /// We don't do his until we detect a coherence error because it can\n+    /// lead to false overflow results (#47139) and because always\n+    /// computing it may negatively impact performance.\n     intercrate_ambiguity_causes: Option<Vec<IntercrateAmbiguityCause>>,\n \n     /// The mode that trait queries run in, which informs our error handling\n@@ -240,11 +249,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    /// Enables tracking of intercrate ambiguity causes. These are\n-    /// used in coherence to give improved diagnostics. We don't do\n-    /// this until we detect a coherence error because it can lead to\n-    /// false overflow results (#47139) and because it costs\n-    /// computation time.\n+    /// Enables tracking of intercrate ambiguity causes. See\n+    /// the documentation of [`Self::intercrate_ambiguity_causes`] for more.\n     pub fn enable_tracking_intercrate_ambiguity_causes(&mut self) {\n         assert!(self.intercrate);\n         assert!(self.intercrate_ambiguity_causes.is_none());"}, {"sha": "71957a2d1b07649cdaa8f7e406993da1dd59cfdf", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -58,7 +58,8 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use smallvec::{smallvec, SmallVec};\n@@ -615,7 +616,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         )];\n \n         let mut has_unsized_tuple_coercion = false;\n-        let mut has_trait_upcasting_coercion = false;\n+        let mut has_trait_upcasting_coercion = None;\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n@@ -635,7 +636,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             && data_a.principal_def_id() != data_b.principal_def_id()\n                         {\n                             debug!(\"coerce_unsized: found trait upcasting coercion\");\n-                            has_trait_upcasting_coercion = true;\n+                            has_trait_upcasting_coercion = Some((self_ty, unsize_ty));\n                         }\n                         if let ty::Tuple(..) = unsize_ty.kind() {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n@@ -706,14 +707,19 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             .emit();\n         }\n \n-        if has_trait_upcasting_coercion && !self.tcx().features().trait_upcasting {\n-            feature_err(\n+        if let Some((sub, sup)) = has_trait_upcasting_coercion\n+            && !self.tcx().features().trait_upcasting\n+        {\n+            // Renders better when we erase regions, since they're not really the point here.\n+            let (sub, sup) = self.tcx.erase_regions((sub, sup));\n+            let mut err = feature_err(\n                 &self.tcx.sess.parse_sess,\n                 sym::trait_upcasting,\n                 self.cause.span,\n-                \"trait upcasting coercion is experimental\",\n-            )\n-            .emit();\n+                &format!(\"cannot cast `{sub}` to `{sup}`, trait upcasting coercion is experimental\"),\n+            );\n+            err.note(&format!(\"required when coercing `{source}` into `{target}`\"));\n+            err.emit();\n         }\n \n         Ok(coercion)\n@@ -962,6 +968,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .find_map(|(ty, steps)| self.probe(|_| coerce.unify(ty, target)).ok().map(|_| steps))\n     }\n \n+    /// Given a type, this function will calculate and return the type given\n+    /// for `<Ty as Deref>::Target` only if `Ty` also implements `DerefMut`.\n+    ///\n+    /// This function is for diagnostics only, since it does not register\n+    /// trait or region sub-obligations. (presumably we could, but it's not\n+    /// particularly important for diagnostics...)\n+    pub fn deref_once_mutably_for_diagnostic(&self, expr_ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+        self.autoderef(rustc_span::DUMMY_SP, expr_ty).nth(1).and_then(|(deref_ty, _)| {\n+            self.infcx\n+                .type_implements_trait(\n+                    self.infcx.tcx.lang_items().deref_mut_trait()?,\n+                    expr_ty,\n+                    ty::List::empty(),\n+                    self.param_env,\n+                )\n+                .may_apply()\n+                .then(|| deref_ty)\n+        })\n+    }\n+\n     /// Given some expressions, their known unified type and another expression,\n     /// tries to unify the types, potentially inserting coercions on any of the\n     /// provided expressions and returns their LUB (aka \"common supertype\")."}, {"sha": "ede2180a8e9e73cf811ae198f9934e32e6280c4a", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -696,28 +696,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         };\n \n                         if let Some(hir::Node::Expr(hir::Expr {\n-                            kind: hir::ExprKind::Assign(left_expr, ..),\n+                            kind: hir::ExprKind::Assign(..),\n                             ..\n                         })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n                         {\n                             if mutability == hir::Mutability::Mut {\n-                                // Found the following case:\n-                                // fn foo(opt: &mut Option<String>){ opt = None }\n-                                //                                   ---   ^^^^\n-                                //                                   |     |\n-                                //    consider dereferencing here: `*opt`  |\n-                                // expected mutable reference, found enum `Option`\n-                                if sm.span_to_snippet(left_expr.span).is_ok() {\n-                                    return Some((\n-                                        left_expr.span.shrink_to_lo(),\n-                                        \"consider dereferencing here to assign to the mutable \\\n-                                         borrowed piece of memory\"\n-                                            .to_string(),\n-                                        \"*\".to_string(),\n-                                        Applicability::MachineApplicable,\n-                                        true,\n-                                    ));\n-                                }\n+                                // Suppressing this diagnostic, we'll properly print it in `check_expr_assign`\n+                                return None;\n                             }\n                         }\n "}, {"sha": "6d56445771a07885aa036ba00f3570fe343144e0", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -51,6 +51,7 @@ use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Pos};\n+use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -836,6 +837,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         lhs: &'tcx hir::Expr<'tcx>,\n         err_code: &'static str,\n         op_span: Span,\n+        adjust_err: impl FnOnce(&mut DiagnosticBuilder<'tcx, ErrorGuaranteed>),\n     ) {\n         if lhs.is_syntactic_place_expr() {\n             return;\n@@ -858,6 +860,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             );\n         });\n \n+        adjust_err(&mut err);\n+\n         err.emit();\n     }\n \n@@ -1050,10 +1054,47 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return self.tcx.ty_error();\n         }\n \n-        self.check_lhs_assignable(lhs, \"E0070\", span);\n-\n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n-        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty, Some(lhs));\n+\n+        let suggest_deref_binop = |err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+                                   rhs_ty: Ty<'tcx>| {\n+            if let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty) {\n+                // Can only assign if the type is sized, so if `DerefMut` yields a type that is\n+                // unsized, do not suggest dereferencing it.\n+                let lhs_deref_ty_is_sized = self\n+                    .infcx\n+                    .type_implements_trait(\n+                        self.tcx.lang_items().sized_trait().unwrap(),\n+                        lhs_deref_ty,\n+                        ty::List::empty(),\n+                        self.param_env,\n+                    )\n+                    .may_apply();\n+                if lhs_deref_ty_is_sized && self.can_coerce(rhs_ty, lhs_deref_ty) {\n+                    err.span_suggestion_verbose(\n+                        lhs.span.shrink_to_lo(),\n+                        \"consider dereferencing here to assign to the mutably borrowed value\",\n+                        \"*\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        };\n+\n+        self.check_lhs_assignable(lhs, \"E0070\", span, |err| {\n+            let rhs_ty = self.check_expr(&rhs);\n+            suggest_deref_binop(err, rhs_ty);\n+        });\n+\n+        // This is (basically) inlined `check_expr_coercable_to_type`, but we want\n+        // to suggest an additional fixup here in `suggest_deref_binop`.\n+        let rhs_ty = self.check_expr_with_hint(&rhs, lhs_ty);\n+        if let (_, Some(mut diag)) =\n+            self.demand_coerce_diag(rhs, rhs_ty, lhs_ty, Some(lhs), AllowTwoPhase::No)\n+        {\n+            suggest_deref_binop(&mut diag, rhs_ty);\n+            diag.emit();\n+        }\n \n         self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n "}, {"sha": "c99d9d8f9230d2824b2f1e944076f53c5ffffd8c", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -41,7 +41,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return_ty\n             };\n \n-        self.check_lhs_assignable(lhs, \"E0067\", op.span);\n+        self.check_lhs_assignable(lhs, \"E0067\", op.span, |err| {\n+            if let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty) {\n+                if self\n+                    .lookup_op_method(\n+                        lhs_deref_ty,\n+                        Some(rhs_ty),\n+                        Some(rhs),\n+                        Op::Binary(op, IsAssign::Yes),\n+                    )\n+                    .is_ok()\n+                {\n+                    // Suppress this error, since we already emitted\n+                    // a deref suggestion in check_overloaded_binop\n+                    err.delay_as_bug();\n+                }\n+            }\n+        });\n \n         ty\n     }\n@@ -404,16 +420,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         (err, missing_trait, use_output)\n                     }\n                 };\n-                if let Ref(_, rty, _) = lhs_ty.kind() {\n-                    if self.infcx.type_is_copy_modulo_regions(self.param_env, *rty, lhs_expr.span)\n-                        && self\n-                            .lookup_op_method(\n-                                *rty,\n-                                Some(rhs_ty),\n-                                Some(rhs_expr),\n-                                Op::Binary(op, is_assign),\n-                            )\n-                            .is_ok()\n+\n+                let mut suggest_deref_binop = |lhs_deref_ty: Ty<'tcx>| {\n+                    if self\n+                        .lookup_op_method(\n+                            lhs_deref_ty,\n+                            Some(rhs_ty),\n+                            Some(rhs_expr),\n+                            Op::Binary(op, is_assign),\n+                        )\n+                        .is_ok()\n                     {\n                         if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n                             let msg = &format!(\n@@ -423,7 +439,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     IsAssign::Yes => \"=\",\n                                     IsAssign::No => \"\",\n                                 },\n-                                rty.peel_refs(),\n+                                lhs_deref_ty.peel_refs(),\n                                 lstring,\n                             );\n                             err.span_suggestion_verbose(\n@@ -434,6 +450,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             );\n                         }\n                     }\n+                };\n+\n+                // We should suggest `a + b` => `*a + b` if `a` is copy, and suggest\n+                // `a += b` => `*a += b` if a is a mut ref.\n+                if is_assign == IsAssign::Yes\n+                    && let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty) {\n+                        suggest_deref_binop(lhs_deref_ty);\n+                } else if is_assign == IsAssign::No\n+                    && let Ref(_, lhs_deref_ty, _) = lhs_ty.kind() {\n+                    if self.infcx.type_is_copy_modulo_regions(self.param_env, *lhs_deref_ty, lhs_expr.span) {\n+                        suggest_deref_binop(*lhs_deref_ty);\n+                    }\n                 }\n                 if let Some(missing_trait) = missing_trait {\n                     let mut visitor = TypeParamVisitor(vec![]);"}, {"sha": "e253f46406fb78c595f592610f60b8e35146b9a6", "filename": "library/std/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -1764,7 +1764,7 @@ impl ExitCode {\n     ///     code.exit_process()\n     /// }\n     /// ```\n-    #[unstable(feature = \"exitcode_exit_method\", issue = \"none\")]\n+    #[unstable(feature = \"exitcode_exit_method\", issue = \"97100\")]\n     pub fn exit_process(self) -> ! {\n         exit(self.to_i32())\n     }"}, {"sha": "0bb6fee60c92eba5c22cd55910c7a6783da1b215", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -788,6 +788,10 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n \n     #[link(name = \"advapi32\")]\n     extern \"system\" {\n+        // Forbidden when targeting UWP\n+        #[link_name = \"SystemFunction036\"]\n+        pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;\n+\n         // Allowed but unused by UWP\n         pub fn OpenProcessToken(\n             ProcessHandle: HANDLE,"}, {"sha": "22e024d8552ec25f85d0c0acc47ce19cc3cd71ed", "filename": "library/std/src/sys/windows/rand.rs", "status": "modified", "additions": 70, "deletions": 4, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -1,8 +1,60 @@\n use crate::io;\n+use crate::lazy;\n use crate::mem;\n use crate::sys::c;\n \n+/// The kinds of HashMap RNG that may be available\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+enum HashMapRng {\n+    Preferred,\n+    Fallback,\n+}\n+\n pub fn hashmap_random_keys() -> (u64, u64) {\n+    match get_hashmap_rng() {\n+        HashMapRng::Preferred => {\n+            preferred_rng().expect(\"couldn't generate random bytes with preferred RNG\")\n+        }\n+        HashMapRng::Fallback => {\n+            fallback_rng().expect(\"couldn't generate random bytes with fallback RNG\")\n+        }\n+    }\n+}\n+\n+/// Returns the HashMap RNG that should be used\n+///\n+/// Panics if they are both broken\n+fn get_hashmap_rng() -> HashMapRng {\n+    // Assume that if the preferred RNG is broken the first time we use it, it likely means\n+    // that: the DLL has failed to load, there is no point to calling it over-and-over again,\n+    // and we should cache the result\n+    static VALUE: lazy::SyncOnceCell<HashMapRng> = lazy::SyncOnceCell::new();\n+    *VALUE.get_or_init(choose_hashmap_rng)\n+}\n+\n+/// Test whether we should use the preferred or fallback RNG\n+///\n+/// If the preferred RNG is successful, we choose it. Otherwise, if the fallback RNG is successful,\n+/// we choose that\n+///\n+/// Panics if both the preferred and the fallback RNG are both non-functional\n+fn choose_hashmap_rng() -> HashMapRng {\n+    let preferred_error = match preferred_rng() {\n+        Ok(_) => return HashMapRng::Preferred,\n+        Err(e) => e,\n+    };\n+\n+    match fallback_rng() {\n+        Ok(_) => return HashMapRng::Fallback,\n+        Err(fallback_error) => panic!(\n+            \"preferred RNG broken: `{}`, fallback RNG broken: `{}`\",\n+            preferred_error, fallback_error\n+        ),\n+    }\n+}\n+\n+/// Generate random numbers using the preferred RNG function (BCryptGenRandom)\n+fn preferred_rng() -> Result<(u64, u64), io::Error> {\n     use crate::ptr;\n \n     let mut v = (0, 0);\n@@ -14,8 +66,22 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n             c::BCRYPT_USE_SYSTEM_PREFERRED_RNG,\n         )\n     };\n-    if ret != 0 {\n-        panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n-    }\n-    return v;\n+\n+    if ret == 0 { Ok(v) } else { Err(io::Error::last_os_error()) }\n+}\n+\n+/// Generate random numbers using the fallback RNG function (RtlGenRandom)\n+#[cfg(not(target_vendor = \"uwp\"))]\n+fn fallback_rng() -> Result<(u64, u64), io::Error> {\n+    let mut v = (0, 0);\n+    let ret =\n+        unsafe { c::RtlGenRandom(&mut v as *mut _ as *mut u8, mem::size_of_val(&v) as c::ULONG) };\n+\n+    if ret != 0 { Ok(v) } else { Err(io::Error::last_os_error()) }\n+}\n+\n+/// We can't use RtlGenRandom with UWP, so there is no fallback\n+#[cfg(target_vendor = \"uwp\")]\n+fn fallback_rng() -> Result<(u64, u64), io::Error> {\n+    Err(io::const_io_error!(io::ErrorKind::Unsupported, \"RtlGenRandom() not supported on UWP\"))\n }"}, {"sha": "68303b842088ecadca31671af29cf1e884c719e6", "filename": "src/test/ui/binop/issue-77910-1.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -12,20 +12,14 @@ LL |     assert_eq!(foo, y);\n error[E0277]: `for<'r> fn(&'r i32) -> &'r i32 {foo}` doesn't implement `Debug`\n   --> $DIR/issue-77910-1.rs:8:5\n    |\n+LL | fn foo(s: &i32) -> &i32 {\n+   |    --- consider calling this function\n+...\n LL |     assert_eq!(foo, y);\n    |     ^^^^^^^^^^^^^^^^^^ `for<'r> fn(&'r i32) -> &'r i32 {foo}` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n    |\n    = help: the trait `Debug` is not implemented for `for<'r> fn(&'r i32) -> &'r i32 {foo}`\n-   = help: the following other types implement trait `Debug`:\n-             extern \"C\" fn() -> Ret\n-             extern \"C\" fn(A) -> Ret\n-             extern \"C\" fn(A, ...) -> Ret\n-             extern \"C\" fn(A, B) -> Ret\n-             extern \"C\" fn(A, B, ...) -> Ret\n-             extern \"C\" fn(A, B, C) -> Ret\n-             extern \"C\" fn(A, B, C, ...) -> Ret\n-             extern \"C\" fn(A, B, C, D) -> Ret\n-           and 68 others\n+   = help: use parentheses to call the function: `foo(s)`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors"}, {"sha": "6e3281d8508abfae6215f65a53f919205ce227b3", "filename": "src/test/ui/coherence/coherence-with-closure.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -0,0 +1,15 @@\n+// Test that encountering closures during coherence does not cause issues.\n+#![feature(type_alias_impl_trait)]\n+type OpaqueClosure = impl Sized;\n+fn defining_use() -> OpaqueClosure {\n+    || ()\n+}\n+\n+struct Wrapper<T>(T);\n+trait Trait {}\n+impl Trait for Wrapper<OpaqueClosure> {}\n+//~^ ERROR cannot implement trait on type alias impl trait\n+impl<T: Sync> Trait for Wrapper<T> {}\n+//~^ ERROR conflicting implementations of trait `Trait` for type `Wrapper<OpaqueClosure>`\n+\n+fn main() {}"}, {"sha": "20b986cee6913488c4b0fd7c206a1a37741809a9", "filename": "src/test/ui/coherence/coherence-with-closure.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.stderr?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -0,0 +1,24 @@\n+error: cannot implement trait on type alias impl trait\n+  --> $DIR/coherence-with-closure.rs:10:24\n+   |\n+LL | impl Trait for Wrapper<OpaqueClosure> {}\n+   |                        ^^^^^^^^^^^^^\n+   |\n+note: type alias impl trait defined here\n+  --> $DIR/coherence-with-closure.rs:3:22\n+   |\n+LL | type OpaqueClosure = impl Sized;\n+   |                      ^^^^^^^^^^\n+\n+error[E0119]: conflicting implementations of trait `Trait` for type `Wrapper<OpaqueClosure>`\n+  --> $DIR/coherence-with-closure.rs:12:1\n+   |\n+LL | impl Trait for Wrapper<OpaqueClosure> {}\n+   | ------------------------------------- first implementation here\n+LL |\n+LL | impl<T: Sync> Trait for Wrapper<T> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `Wrapper<OpaqueClosure>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "d34c391db9fb0bcb1f7306fd793a05b01f1a3541", "filename": "src/test/ui/coherence/coherence-with-generator.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -0,0 +1,19 @@\n+// Test that encountering closures during coherence does not cause issues.\n+#![feature(type_alias_impl_trait, generators)]\n+type OpaqueGenerator = impl Sized;\n+fn defining_use() -> OpaqueGenerator {\n+    || {\n+        for i in 0..10 {\n+            yield i;\n+        }\n+    }\n+}\n+\n+struct Wrapper<T>(T);\n+trait Trait {}\n+impl Trait for Wrapper<OpaqueGenerator> {}\n+//~^ ERROR cannot implement trait on type alias impl trait\n+impl<T: Sync> Trait for Wrapper<T> {}\n+//~^ ERROR conflicting implementations of trait `Trait` for type `Wrapper<OpaqueGenerator>`\n+\n+fn main() {}"}, {"sha": "249ad3cb9ec7fe6dce2b1e5c640b0ba030d22f0f", "filename": "src/test/ui/coherence/coherence-with-generator.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.stderr?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -0,0 +1,24 @@\n+error: cannot implement trait on type alias impl trait\n+  --> $DIR/coherence-with-generator.rs:14:24\n+   |\n+LL | impl Trait for Wrapper<OpaqueGenerator> {}\n+   |                        ^^^^^^^^^^^^^^^\n+   |\n+note: type alias impl trait defined here\n+  --> $DIR/coherence-with-generator.rs:3:24\n+   |\n+LL | type OpaqueGenerator = impl Sized;\n+   |                        ^^^^^^^^^^\n+\n+error[E0119]: conflicting implementations of trait `Trait` for type `Wrapper<OpaqueGenerator>`\n+  --> $DIR/coherence-with-generator.rs:16:1\n+   |\n+LL | impl Trait for Wrapper<OpaqueGenerator> {}\n+   | --------------------------------------- first implementation here\n+LL |\n+LL | impl<T: Sync> Trait for Wrapper<T> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `Wrapper<OpaqueGenerator>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "93afa78459d3da72ca90891af547f6f47523ff9b", "filename": "src/test/ui/feature-gates/feature-gate-trait_upcasting.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.stderr?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -1,11 +1,12 @@\n-error[E0658]: trait upcasting coercion is experimental\n+error[E0658]: cannot cast `dyn Bar` to `dyn Foo`, trait upcasting coercion is experimental\n   --> $DIR/feature-gate-trait_upcasting.rs:11:25\n    |\n LL |     let foo: &dyn Foo = bar;\n    |                         ^^^\n    |\n    = note: see issue #65991 <https://github.com/rust-lang/rust/issues/65991> for more information\n    = help: add `#![feature(trait_upcasting)]` to the crate attributes to enable\n+   = note: required when coercing `&dyn Bar` into `&dyn Foo`\n \n error: aborting due to previous error\n "}, {"sha": "17bfae2a4e46bdd33fa983a2d29f512a92579916", "filename": "src/test/ui/issues/issue-11515.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fissues%2Fissue-11515.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fissues%2Fissue-11515.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11515.stderr?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -1,11 +1,12 @@\n-error[E0658]: trait upcasting coercion is experimental\n+error[E0658]: cannot cast `dyn Fn()` to `dyn FnMut()`, trait upcasting coercion is experimental\n   --> $DIR/issue-11515.rs:9:33\n    |\n LL |     let test = box Test { func: closure };\n    |                                 ^^^^^^^\n    |\n    = note: see issue #65991 <https://github.com/rust-lang/rust/issues/65991> for more information\n    = help: add `#![feature(trait_upcasting)]` to the crate attributes to enable\n+   = note: required when coercing `Box<(dyn Fn() + 'static)>` into `Box<(dyn FnMut() + 'static)>`\n \n error: aborting due to previous error\n "}, {"sha": "f53ddb95416d15adf0b0266dcdb887cebc8dd9bc", "filename": "src/test/ui/issues/issue-5239-1.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -5,11 +5,6 @@ LL |     let x = |ref x: isize| { x += 1; };\n    |                              -^^^^^\n    |                              |\n    |                              cannot use `+=` on type `&isize`\n-   |\n-help: `+=` can be used on `isize`, you can dereference `x`\n-   |\n-LL |     let x = |ref x: isize| { *x += 1; };\n-   |                              +\n \n error: aborting due to previous error\n "}, {"sha": "ba6af8f15fa89658915f1ddad572cbfd4c52fe3f", "filename": "src/test/ui/suggestions/imm-ref-trait-object-literal-bound-regions.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal-bound-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal-bound-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal-bound-regions.stderr?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -5,6 +5,7 @@ LL |     foo::<S>(s);\n    |     ^^^^^^^^ the trait `for<'b> Trait` is not implemented for `&'b S`\n    |\n    = help: the trait `Trait` is implemented for `&'a mut S`\n+   = note: `for<'b> Trait` is implemented for `&'b mut S`, but not for `&'b S`\n note: required by a bound in `foo`\n   --> $DIR/imm-ref-trait-object-literal-bound-regions.rs:11:20\n    |"}, {"sha": "b3cb6dd06142be65bca5fe37c3d00e0a9706edd2", "filename": "src/test/ui/suggestions/mut-ref-reassignment.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fsuggestions%2Fmut-ref-reassignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Fsuggestions%2Fmut-ref-reassignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmut-ref-reassignment.stderr?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -8,7 +8,7 @@ LL |     opt = None;\n    |\n    = note: expected mutable reference `&mut Option<String>`\n                            found enum `Option<_>`\n-help: consider dereferencing here to assign to the mutable borrowed piece of memory\n+help: consider dereferencing here to assign to the mutably borrowed value\n    |\n LL |     *opt = None;\n    |     +\n@@ -34,7 +34,7 @@ LL |     opt = Some(String::new())\n    |\n    = note: expected mutable reference `&mut Option<String>`\n                            found enum `Option<String>`\n-help: consider dereferencing here to assign to the mutable borrowed piece of memory\n+help: consider dereferencing here to assign to the mutably borrowed value\n    |\n LL |     *opt = Some(String::new())\n    |     +"}, {"sha": "0c23199af22706526f6a4acf73b8cb12622dcf53", "filename": "src/test/ui/typeck/assign-non-lval-derefmut.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.fixed?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+fn main() {\n+    let x = std::sync::Mutex::new(1usize);\n+    *x.lock().unwrap() = 2;\n+    //~^ ERROR invalid left-hand side of assignment\n+    *x.lock().unwrap() += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `MutexGuard<'_, usize>`\n+\n+    let mut y = x.lock().unwrap();\n+    *y = 2;\n+    //~^ ERROR mismatched types\n+    *y += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `MutexGuard<'_, usize>`\n+}"}, {"sha": "ec1882f5271b19e89dba3b0f76615685d4da4015", "filename": "src/test/ui/typeck/assign-non-lval-derefmut.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+fn main() {\n+    let x = std::sync::Mutex::new(1usize);\n+    x.lock().unwrap() = 2;\n+    //~^ ERROR invalid left-hand side of assignment\n+    x.lock().unwrap() += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `MutexGuard<'_, usize>`\n+\n+    let mut y = x.lock().unwrap();\n+    y = 2;\n+    //~^ ERROR mismatched types\n+    y += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `MutexGuard<'_, usize>`\n+}"}, {"sha": "a6fcdfe21f481a3fb99435827c80454274974b32", "filename": "src/test/ui/typeck/assign-non-lval-derefmut.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.stderr?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -0,0 +1,58 @@\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/assign-non-lval-derefmut.rs:5:23\n+   |\n+LL |     x.lock().unwrap() = 2;\n+   |     ----------------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+help: consider dereferencing here to assign to the mutably borrowed value\n+   |\n+LL |     *x.lock().unwrap() = 2;\n+   |     +\n+\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `MutexGuard<'_, usize>`\n+  --> $DIR/assign-non-lval-derefmut.rs:7:5\n+   |\n+LL |     x.lock().unwrap() += 1;\n+   |     -----------------^^^^^\n+   |     |\n+   |     cannot use `+=` on type `MutexGuard<'_, usize>`\n+   |\n+help: `+=` can be used on `usize`, you can dereference `x.lock().unwrap()`\n+   |\n+LL |     *x.lock().unwrap() += 1;\n+   |     +\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assign-non-lval-derefmut.rs:11:9\n+   |\n+LL |     let mut y = x.lock().unwrap();\n+   |                 ----------------- expected due to this value\n+LL |     y = 2;\n+   |         ^ expected struct `MutexGuard`, found integer\n+   |\n+   = note: expected struct `MutexGuard<'_, usize>`\n+                found type `{integer}`\n+help: consider dereferencing here to assign to the mutably borrowed value\n+   |\n+LL |     *y = 2;\n+   |     +\n+\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `MutexGuard<'_, usize>`\n+  --> $DIR/assign-non-lval-derefmut.rs:13:5\n+   |\n+LL |     y += 1;\n+   |     -^^^^^\n+   |     |\n+   |     cannot use `+=` on type `MutexGuard<'_, usize>`\n+   |\n+help: `+=` can be used on `usize`, you can dereference `y`\n+   |\n+LL |     *y += 1;\n+   |     +\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0070, E0308, E0368.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "10c7b9dbfb331182333e6dfa58a7ba27f3ab0af9", "filename": "src/test/ui/typeck/assign-non-lval-mut-ref.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.fixed?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+fn main() {\n+    let mut x = vec![1usize];\n+    *x.last_mut().unwrap() = 2;\n+    //~^ ERROR invalid left-hand side of assignment\n+    *x.last_mut().unwrap() += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `&mut usize`\n+\n+    let y = x.last_mut().unwrap();\n+    *y = 2;\n+    //~^ ERROR mismatched types\n+    *y += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `&mut usize`\n+}"}, {"sha": "bceff0ef09d190c92eea614259fe431f8c11a5b9", "filename": "src/test/ui/typeck/assign-non-lval-mut-ref.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.rs?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+fn main() {\n+    let mut x = vec![1usize];\n+    x.last_mut().unwrap() = 2;\n+    //~^ ERROR invalid left-hand side of assignment\n+    x.last_mut().unwrap() += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `&mut usize`\n+\n+    let y = x.last_mut().unwrap();\n+    y = 2;\n+    //~^ ERROR mismatched types\n+    y += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `&mut usize`\n+}"}, {"sha": "be2e9fe95e87144a3e27ffcfe1d4d14267c2d14e", "filename": "src/test/ui/typeck/assign-non-lval-mut-ref.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.stderr?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -0,0 +1,56 @@\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/assign-non-lval-mut-ref.rs:5:27\n+   |\n+LL |     x.last_mut().unwrap() = 2;\n+   |     --------------------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+help: consider dereferencing here to assign to the mutably borrowed value\n+   |\n+LL |     *x.last_mut().unwrap() = 2;\n+   |     +\n+\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `&mut usize`\n+  --> $DIR/assign-non-lval-mut-ref.rs:7:5\n+   |\n+LL |     x.last_mut().unwrap() += 1;\n+   |     ---------------------^^^^^\n+   |     |\n+   |     cannot use `+=` on type `&mut usize`\n+   |\n+help: `+=` can be used on `usize`, you can dereference `x.last_mut().unwrap()`\n+   |\n+LL |     *x.last_mut().unwrap() += 1;\n+   |     +\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assign-non-lval-mut-ref.rs:11:9\n+   |\n+LL |     let y = x.last_mut().unwrap();\n+   |             --------------------- expected due to this value\n+LL |     y = 2;\n+   |         ^ expected `&mut usize`, found integer\n+   |\n+help: consider dereferencing here to assign to the mutably borrowed value\n+   |\n+LL |     *y = 2;\n+   |     +\n+\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `&mut usize`\n+  --> $DIR/assign-non-lval-mut-ref.rs:13:5\n+   |\n+LL |     y += 1;\n+   |     -^^^^^\n+   |     |\n+   |     cannot use `+=` on type `&mut usize`\n+   |\n+help: `+=` can be used on `usize`, you can dereference `y`\n+   |\n+LL |     *y += 1;\n+   |     +\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0070, E0308, E0368.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "167edc8942aec47d11cc2c26860ec9ca269de9d1", "filename": "src/test/ui/typeck/issue-93486.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fissue-93486.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a084b7ad35adb508bd2e053fc2a1b9a53df9536c/src%2Ftest%2Fui%2Ftypeck%2Fissue-93486.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-93486.stderr?ref=a084b7ad35adb508bd2e053fc2a1b9a53df9536c", "patch": "@@ -5,6 +5,11 @@ LL |         vec![].last_mut().unwrap() = 3_u8;\n    |         -------------------------- ^\n    |         |\n    |         cannot assign to this expression\n+   |\n+help: consider dereferencing here to assign to the mutably borrowed value\n+   |\n+LL |         *vec![].last_mut().unwrap() = 3_u8;\n+   |         +\n \n error: aborting due to previous error\n "}]}