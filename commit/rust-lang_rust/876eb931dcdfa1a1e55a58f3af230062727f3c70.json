{"sha": "876eb931dcdfa1a1e55a58f3af230062727f3c70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NmViOTMxZGNkZmExYTFlNTVhNThmM2FmMjMwMDYyNzI3ZjNjNzA=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-02-16T15:23:33Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-02-16T15:23:33Z"}, "message": "Remove Real trait and move methods into Float\n\nThis is part of the effort to simplify `std::num`, as tracked in issue #10387.", "tree": {"sha": "f5ab61bfecf60c1605504631d1aaf511d7483b76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5ab61bfecf60c1605504631d1aaf511d7483b76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/876eb931dcdfa1a1e55a58f3af230062727f3c70", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/876eb931dcdfa1a1e55a58f3af230062727f3c70", "html_url": "https://github.com/rust-lang/rust/commit/876eb931dcdfa1a1e55a58f3af230062727f3c70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/876eb931dcdfa1a1e55a58f3af230062727f3c70/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fe775e2b5eaa77dd49c1d9a234c67d52e5f9087", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fe775e2b5eaa77dd49c1d9a234c67d52e5f9087", "html_url": "https://github.com/rust-lang/rust/commit/6fe775e2b5eaa77dd49c1d9a234c67d52e5f9087"}], "stats": {"total": 1012, "additions": 501, "deletions": 511}, "files": [{"sha": "371c78b2b6843aa64e000cd1e3715c2a48e020b8", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=876eb931dcdfa1a1e55a58f3af230062727f3c70", "patch": "@@ -85,7 +85,7 @@ syn keyword rustTrait Iterator DoubleEndedIterator RandomAccessIterator Cloneabl\n syn keyword rustTrait OrdIterator MutableDoubleEndedIterator ExactSize\n \n syn keyword rustTrait Algebraic Trigonometric Exponential Hyperbolic\n-syn keyword rustTrait Bitwise Bounded Integer Fractional Real RealExt\n+syn keyword rustTrait Bitwise Bounded Integer\n syn keyword rustTrait Num NumCast CheckedAdd CheckedSub CheckedMul CheckedDiv\n syn keyword rustTrait Orderable Signed Unsigned Round\n syn keyword rustTrait Primitive Int Float ToStrRadix ToPrimitive FromPrimitive"}, {"sha": "3755b2e43af1b4ea0362e28b625c2be928fb2485", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=876eb931dcdfa1a1e55a58f3af230062727f3c70", "patch": "@@ -77,15 +77,15 @@ impl<T: Clone + Num> Cmplx<T> {\n     }\n }\n \n-impl<T: Clone + Real> Cmplx<T> {\n+impl<T: Clone + Float> Cmplx<T> {\n     /// Calculate |self|\n     #[inline]\n     pub fn norm(&self) -> T {\n         self.re.hypot(&self.im)\n     }\n }\n \n-impl<T: Clone + Real> Cmplx<T> {\n+impl<T: Clone + Float> Cmplx<T> {\n     /// Calculate the principal Arg of self.\n     #[inline]\n     pub fn arg(&self) -> T {\n@@ -192,7 +192,7 @@ mod test {\n     #[allow(non_uppercase_statics)];\n \n     use super::{Complex64, Cmplx};\n-    use std::num::{Zero,One,Real};\n+    use std::num::{Zero,One,Float};\n \n     pub static _0_0i : Complex64 = Cmplx { re: 0.0, im: 0.0 };\n     pub static _1_0i : Complex64 = Cmplx { re: 1.0, im: 0.0 };\n@@ -270,9 +270,9 @@ mod test {\n             assert!((c.arg() - arg).abs() < 1.0e-6)\n         }\n         test(_1_0i, 0.0);\n-        test(_1_1i, 0.25 * Real::pi());\n-        test(_neg1_1i, 0.75 * Real::pi());\n-        test(_05_05i, 0.25 * Real::pi());\n+        test(_1_1i, 0.25 * Float::pi());\n+        test(_neg1_1i, 0.75 * Float::pi());\n+        test(_05_05i, 0.25 * Float::pi());\n     }\n \n     #[test]"}, {"sha": "688e8347d9ad5e962545e4bde91febcd0618d2e6", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 162, "deletions": 164, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=876eb931dcdfa1a1e55a58f3af230062727f3c70", "patch": "@@ -127,7 +127,7 @@ pub mod consts {\n     // staticants from cmath.\n \n     // FIXME(#11621): These constants should be deprecated once CTFE is\n-    // implemented in favour of calling their respective functions in `Real`.\n+    // implemented in favour of calling their respective functions in `Float`.\n \n     /// Archimedes' constant\n     pub static PI: f32 = 3.14159265358979323846264338327950288_f32;\n@@ -300,7 +300,148 @@ impl Round for f32 {\n     fn fract(&self) -> f32 { *self - self.trunc() }\n }\n \n-impl Real for f32 {\n+impl Bounded for f32 {\n+    #[inline]\n+    fn min_value() -> f32 { 1.17549435e-38 }\n+\n+    #[inline]\n+    fn max_value() -> f32 { 3.40282347e+38 }\n+}\n+\n+impl Primitive for f32 {}\n+\n+impl Float for f32 {\n+    #[inline]\n+    fn nan() -> f32 { 0.0 / 0.0 }\n+\n+    #[inline]\n+    fn infinity() -> f32 { 1.0 / 0.0 }\n+\n+    #[inline]\n+    fn neg_infinity() -> f32 { -1.0 / 0.0 }\n+\n+    #[inline]\n+    fn neg_zero() -> f32 { -0.0 }\n+\n+    /// Returns `true` if the number is NaN\n+    #[inline]\n+    fn is_nan(&self) -> bool { *self != *self }\n+\n+    /// Returns `true` if the number is infinite\n+    #[inline]\n+    fn is_infinite(&self) -> bool {\n+        *self == Float::infinity() || *self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is neither infinite or NaN\n+    #[inline]\n+    fn is_finite(&self) -> bool {\n+        !(self.is_nan() || self.is_infinite())\n+    }\n+\n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    #[inline]\n+    fn is_normal(&self) -> bool {\n+        self.classify() == FPNormal\n+    }\n+\n+    /// Returns the floating point category of the number. If only one property is going to\n+    /// be tested, it is generally faster to use the specific predicate instead.\n+    fn classify(&self) -> FPCategory {\n+        static EXP_MASK: u32 = 0x7f800000;\n+        static MAN_MASK: u32 = 0x007fffff;\n+\n+        match (\n+            unsafe { ::cast::transmute::<f32,u32>(*self) } & MAN_MASK,\n+            unsafe { ::cast::transmute::<f32,u32>(*self) } & EXP_MASK,\n+        ) {\n+            (0, 0)        => FPZero,\n+            (_, 0)        => FPSubnormal,\n+            (0, EXP_MASK) => FPInfinite,\n+            (_, EXP_MASK) => FPNaN,\n+            _             => FPNormal,\n+        }\n+    }\n+\n+    #[inline]\n+    fn mantissa_digits(_: Option<f32>) -> uint { 24 }\n+\n+    #[inline]\n+    fn digits(_: Option<f32>) -> uint { 6 }\n+\n+    #[inline]\n+    fn epsilon() -> f32 { 1.19209290e-07 }\n+\n+    #[inline]\n+    fn min_exp(_: Option<f32>) -> int { -125 }\n+\n+    #[inline]\n+    fn max_exp(_: Option<f32>) -> int { 128 }\n+\n+    #[inline]\n+    fn min_10_exp(_: Option<f32>) -> int { -37 }\n+\n+    #[inline]\n+    fn max_10_exp(_: Option<f32>) -> int { 38 }\n+\n+    /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n+    #[inline]\n+    fn ldexp(x: f32, exp: int) -> f32 {\n+        ldexp(x, exp as c_int)\n+    }\n+\n+    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n+    ///\n+    /// - `self = x * pow(2, exp)`\n+    /// - `0.5 <= abs(x) < 1.0`\n+    #[inline]\n+    fn frexp(&self) -> (f32, int) {\n+        let mut exp = 0;\n+        let x = frexp(*self, &mut exp);\n+        (x, exp as int)\n+    }\n+\n+    /// Returns the exponential of the number, minus `1`, in a way that is accurate\n+    /// even if the number is close to zero\n+    #[inline]\n+    fn exp_m1(&self) -> f32 { exp_m1(*self) }\n+\n+    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n+    /// than if the operations were performed separately\n+    #[inline]\n+    fn ln_1p(&self) -> f32 { ln_1p(*self) }\n+\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n+    /// produces a more accurate result with better performance than a separate multiplication\n+    /// operation followed by an add.\n+    #[inline]\n+    fn mul_add(&self, a: f32, b: f32) -> f32 {\n+        mul_add(*self, a, b)\n+    }\n+\n+    /// Returns the next representable floating-point value in the direction of `other`\n+    #[inline]\n+    fn next_after(&self, other: f32) -> f32 {\n+        next_after(*self, other)\n+    }\n+\n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(&self) -> (u64, i16, i8) {\n+        let bits: u32 = unsafe {\n+            ::cast::transmute(*self)\n+        };\n+        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0x7fffff) << 1\n+        } else {\n+            (bits & 0x7fffff) | 0x800000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 127 + 23;\n+        (mantissa as u64, exponent, sign)\n+    }\n+\n     /// Archimedes' constant\n     #[inline]\n     fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n@@ -495,159 +636,16 @@ impl Real for f32 {\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline]\n-    fn to_degrees(&self) -> f32 { *self * (180.0f32 / Real::pi()) }\n+    fn to_degrees(&self) -> f32 { *self * (180.0f32 / Float::pi()) }\n \n     /// Converts to radians, assuming the number is in degrees\n     #[inline]\n     fn to_radians(&self) -> f32 {\n-        let value: f32 = Real::pi();\n+        let value: f32 = Float::pi();\n         *self * (value / 180.0f32)\n     }\n }\n \n-impl Bounded for f32 {\n-    #[inline]\n-    fn min_value() -> f32 { 1.17549435e-38 }\n-\n-    #[inline]\n-    fn max_value() -> f32 { 3.40282347e+38 }\n-}\n-\n-impl Primitive for f32 {}\n-\n-impl Float for f32 {\n-    #[inline]\n-    fn nan() -> f32 { 0.0 / 0.0 }\n-\n-    #[inline]\n-    fn infinity() -> f32 { 1.0 / 0.0 }\n-\n-    #[inline]\n-    fn neg_infinity() -> f32 { -1.0 / 0.0 }\n-\n-    #[inline]\n-    fn neg_zero() -> f32 { -0.0 }\n-\n-    /// Returns `true` if the number is NaN\n-    #[inline]\n-    fn is_nan(&self) -> bool { *self != *self }\n-\n-    /// Returns `true` if the number is infinite\n-    #[inline]\n-    fn is_infinite(&self) -> bool {\n-        *self == Float::infinity() || *self == Float::neg_infinity()\n-    }\n-\n-    /// Returns `true` if the number is neither infinite or NaN\n-    #[inline]\n-    fn is_finite(&self) -> bool {\n-        !(self.is_nan() || self.is_infinite())\n-    }\n-\n-    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline]\n-    fn is_normal(&self) -> bool {\n-        self.classify() == FPNormal\n-    }\n-\n-    /// Returns the floating point category of the number. If only one property is going to\n-    /// be tested, it is generally faster to use the specific predicate instead.\n-    fn classify(&self) -> FPCategory {\n-        static EXP_MASK: u32 = 0x7f800000;\n-        static MAN_MASK: u32 = 0x007fffff;\n-\n-        match (\n-            unsafe { ::cast::transmute::<f32,u32>(*self) } & MAN_MASK,\n-            unsafe { ::cast::transmute::<f32,u32>(*self) } & EXP_MASK,\n-        ) {\n-            (0, 0)        => FPZero,\n-            (_, 0)        => FPSubnormal,\n-            (0, EXP_MASK) => FPInfinite,\n-            (_, EXP_MASK) => FPNaN,\n-            _             => FPNormal,\n-        }\n-    }\n-\n-    #[inline]\n-    fn mantissa_digits(_: Option<f32>) -> uint { 24 }\n-\n-    #[inline]\n-    fn digits(_: Option<f32>) -> uint { 6 }\n-\n-    #[inline]\n-    fn epsilon() -> f32 { 1.19209290e-07 }\n-\n-    #[inline]\n-    fn min_exp(_: Option<f32>) -> int { -125 }\n-\n-    #[inline]\n-    fn max_exp(_: Option<f32>) -> int { 128 }\n-\n-    #[inline]\n-    fn min_10_exp(_: Option<f32>) -> int { -37 }\n-\n-    #[inline]\n-    fn max_10_exp(_: Option<f32>) -> int { 38 }\n-\n-    /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n-    #[inline]\n-    fn ldexp(x: f32, exp: int) -> f32 {\n-        ldexp(x, exp as c_int)\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n-    ///\n-    /// - `self = x * pow(2, exp)`\n-    /// - `0.5 <= abs(x) < 1.0`\n-    #[inline]\n-    fn frexp(&self) -> (f32, int) {\n-        let mut exp = 0;\n-        let x = frexp(*self, &mut exp);\n-        (x, exp as int)\n-    }\n-\n-    /// Returns the exponential of the number, minus `1`, in a way that is accurate\n-    /// even if the number is close to zero\n-    #[inline]\n-    fn exp_m1(&self) -> f32 { exp_m1(*self) }\n-\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n-    /// than if the operations were performed separately\n-    #[inline]\n-    fn ln_1p(&self) -> f32 { ln_1p(*self) }\n-\n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n-    /// produces a more accurate result with better performance than a separate multiplication\n-    /// operation followed by an add.\n-    #[inline]\n-    fn mul_add(&self, a: f32, b: f32) -> f32 {\n-        mul_add(*self, a, b)\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline]\n-    fn next_after(&self, other: f32) -> f32 {\n-        next_after(*self, other)\n-    }\n-\n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(&self) -> (u64, i16, i8) {\n-        let bits: u32 = unsafe {\n-            ::cast::transmute(*self)\n-        };\n-        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0x7fffff) << 1\n-        } else {\n-            (bits & 0x7fffff) | 0x800000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 127 + 23;\n-        (mantissa as u64, exponent, sign)\n-    }\n-}\n-\n //\n // Section: String Conversions\n //\n@@ -1002,23 +1000,23 @@ mod tests {\n \n     #[test]\n     fn test_real_consts() {\n-        let pi: f32 = Real::pi();\n-        let two_pi: f32 = Real::two_pi();\n-        let frac_pi_2: f32 = Real::frac_pi_2();\n-        let frac_pi_3: f32 = Real::frac_pi_3();\n-        let frac_pi_4: f32 = Real::frac_pi_4();\n-        let frac_pi_6: f32 = Real::frac_pi_6();\n-        let frac_pi_8: f32 = Real::frac_pi_8();\n-        let frac_1_pi: f32 = Real::frac_1_pi();\n-        let frac_2_pi: f32 = Real::frac_2_pi();\n-        let frac_2_sqrtpi: f32 = Real::frac_2_sqrtpi();\n-        let sqrt2: f32 = Real::sqrt2();\n-        let frac_1_sqrt2: f32 = Real::frac_1_sqrt2();\n-        let e: f32 = Real::e();\n-        let log2_e: f32 = Real::log2_e();\n-        let log10_e: f32 = Real::log10_e();\n-        let ln_2: f32 = Real::ln_2();\n-        let ln_10: f32 = Real::ln_10();\n+        let pi: f32 = Float::pi();\n+        let two_pi: f32 = Float::two_pi();\n+        let frac_pi_2: f32 = Float::frac_pi_2();\n+        let frac_pi_3: f32 = Float::frac_pi_3();\n+        let frac_pi_4: f32 = Float::frac_pi_4();\n+        let frac_pi_6: f32 = Float::frac_pi_6();\n+        let frac_pi_8: f32 = Float::frac_pi_8();\n+        let frac_1_pi: f32 = Float::frac_1_pi();\n+        let frac_2_pi: f32 = Float::frac_2_pi();\n+        let frac_2_sqrtpi: f32 = Float::frac_2_sqrtpi();\n+        let sqrt2: f32 = Float::sqrt2();\n+        let frac_1_sqrt2: f32 = Float::frac_1_sqrt2();\n+        let e: f32 = Float::e();\n+        let log2_e: f32 = Float::log2_e();\n+        let log10_e: f32 = Float::log10_e();\n+        let ln_2: f32 = Float::ln_2();\n+        let ln_10: f32 = Float::ln_10();\n \n         assert_approx_eq!(two_pi, 2f32 * pi);\n         assert_approx_eq!(frac_pi_2, pi / 2f32);"}, {"sha": "dafb3187ff8487ad5d0e10925dec228ba63943e2", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 162, "deletions": 164, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=876eb931dcdfa1a1e55a58f3af230062727f3c70", "patch": "@@ -134,7 +134,7 @@ pub mod consts {\n     // constants from cmath.\n \n     // FIXME(#11621): These constants should be deprecated once CTFE is\n-    // implemented in favour of calling their respective functions in `Real`.\n+    // implemented in favour of calling their respective functions in `Float`.\n \n     /// Archimedes' constant\n     pub static PI: f64 = 3.14159265358979323846264338327950288_f64;\n@@ -302,7 +302,148 @@ impl Round for f64 {\n     fn fract(&self) -> f64 { *self - self.trunc() }\n }\n \n-impl Real for f64 {\n+impl Bounded for f64 {\n+    #[inline]\n+    fn min_value() -> f64 { 2.2250738585072014e-308 }\n+\n+    #[inline]\n+    fn max_value() -> f64 { 1.7976931348623157e+308 }\n+}\n+\n+impl Primitive for f64 {}\n+\n+impl Float for f64 {\n+    #[inline]\n+    fn nan() -> f64 { 0.0 / 0.0 }\n+\n+    #[inline]\n+    fn infinity() -> f64 { 1.0 / 0.0 }\n+\n+    #[inline]\n+    fn neg_infinity() -> f64 { -1.0 / 0.0 }\n+\n+    #[inline]\n+    fn neg_zero() -> f64 { -0.0 }\n+\n+    /// Returns `true` if the number is NaN\n+    #[inline]\n+    fn is_nan(&self) -> bool { *self != *self }\n+\n+    /// Returns `true` if the number is infinite\n+    #[inline]\n+    fn is_infinite(&self) -> bool {\n+        *self == Float::infinity() || *self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is neither infinite or NaN\n+    #[inline]\n+    fn is_finite(&self) -> bool {\n+        !(self.is_nan() || self.is_infinite())\n+    }\n+\n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    #[inline]\n+    fn is_normal(&self) -> bool {\n+        self.classify() == FPNormal\n+    }\n+\n+    /// Returns the floating point category of the number. If only one property is going to\n+    /// be tested, it is generally faster to use the specific predicate instead.\n+    fn classify(&self) -> FPCategory {\n+        static EXP_MASK: u64 = 0x7ff0000000000000;\n+        static MAN_MASK: u64 = 0x000fffffffffffff;\n+\n+        match (\n+            unsafe { ::cast::transmute::<f64,u64>(*self) } & MAN_MASK,\n+            unsafe { ::cast::transmute::<f64,u64>(*self) } & EXP_MASK,\n+        ) {\n+            (0, 0)        => FPZero,\n+            (_, 0)        => FPSubnormal,\n+            (0, EXP_MASK) => FPInfinite,\n+            (_, EXP_MASK) => FPNaN,\n+            _             => FPNormal,\n+        }\n+    }\n+\n+    #[inline]\n+    fn mantissa_digits(_: Option<f64>) -> uint { 53 }\n+\n+    #[inline]\n+    fn digits(_: Option<f64>) -> uint { 15 }\n+\n+    #[inline]\n+    fn epsilon() -> f64 { 2.2204460492503131e-16 }\n+\n+    #[inline]\n+    fn min_exp(_: Option<f64>) -> int { -1021 }\n+\n+    #[inline]\n+    fn max_exp(_: Option<f64>) -> int { 1024 }\n+\n+    #[inline]\n+    fn min_10_exp(_: Option<f64>) -> int { -307 }\n+\n+    #[inline]\n+    fn max_10_exp(_: Option<f64>) -> int { 308 }\n+\n+    /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n+    #[inline]\n+    fn ldexp(x: f64, exp: int) -> f64 {\n+        ldexp(x, exp as c_int)\n+    }\n+\n+    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n+    ///\n+    /// - `self = x * pow(2, exp)`\n+    /// - `0.5 <= abs(x) < 1.0`\n+    #[inline]\n+    fn frexp(&self) -> (f64, int) {\n+        let mut exp = 0;\n+        let x = frexp(*self, &mut exp);\n+        (x, exp as int)\n+    }\n+\n+    /// Returns the exponential of the number, minus `1`, in a way that is accurate\n+    /// even if the number is close to zero\n+    #[inline]\n+    fn exp_m1(&self) -> f64 { exp_m1(*self) }\n+\n+    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n+    /// than if the operations were performed separately\n+    #[inline]\n+    fn ln_1p(&self) -> f64 { ln_1p(*self) }\n+\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n+    /// produces a more accurate result with better performance than a separate multiplication\n+    /// operation followed by an add.\n+    #[inline]\n+    fn mul_add(&self, a: f64, b: f64) -> f64 {\n+        mul_add(*self, a, b)\n+    }\n+\n+    /// Returns the next representable floating-point value in the direction of `other`\n+    #[inline]\n+    fn next_after(&self, other: f64) -> f64 {\n+        next_after(*self, other)\n+    }\n+\n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(&self) -> (u64, i16, i8) {\n+        let bits: u64 = unsafe {\n+            ::cast::transmute(*self)\n+        };\n+        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0xfffffffffffff) << 1\n+        } else {\n+            (bits & 0xfffffffffffff) | 0x10000000000000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 1023 + 52;\n+        (mantissa, exponent, sign)\n+    }\n+\n     /// Archimedes' constant\n     #[inline]\n     fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n@@ -497,159 +638,16 @@ impl Real for f64 {\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline]\n-    fn to_degrees(&self) -> f64 { *self * (180.0f64 / Real::pi()) }\n+    fn to_degrees(&self) -> f64 { *self * (180.0f64 / Float::pi()) }\n \n     /// Converts to radians, assuming the number is in degrees\n     #[inline]\n     fn to_radians(&self) -> f64 {\n-        let value: f64 = Real::pi();\n+        let value: f64 = Float::pi();\n         *self * (value / 180.0)\n     }\n }\n \n-impl Bounded for f64 {\n-    #[inline]\n-    fn min_value() -> f64 { 2.2250738585072014e-308 }\n-\n-    #[inline]\n-    fn max_value() -> f64 { 1.7976931348623157e+308 }\n-}\n-\n-impl Primitive for f64 {}\n-\n-impl Float for f64 {\n-    #[inline]\n-    fn nan() -> f64 { 0.0 / 0.0 }\n-\n-    #[inline]\n-    fn infinity() -> f64 { 1.0 / 0.0 }\n-\n-    #[inline]\n-    fn neg_infinity() -> f64 { -1.0 / 0.0 }\n-\n-    #[inline]\n-    fn neg_zero() -> f64 { -0.0 }\n-\n-    /// Returns `true` if the number is NaN\n-    #[inline]\n-    fn is_nan(&self) -> bool { *self != *self }\n-\n-    /// Returns `true` if the number is infinite\n-    #[inline]\n-    fn is_infinite(&self) -> bool {\n-        *self == Float::infinity() || *self == Float::neg_infinity()\n-    }\n-\n-    /// Returns `true` if the number is neither infinite or NaN\n-    #[inline]\n-    fn is_finite(&self) -> bool {\n-        !(self.is_nan() || self.is_infinite())\n-    }\n-\n-    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline]\n-    fn is_normal(&self) -> bool {\n-        self.classify() == FPNormal\n-    }\n-\n-    /// Returns the floating point category of the number. If only one property is going to\n-    /// be tested, it is generally faster to use the specific predicate instead.\n-    fn classify(&self) -> FPCategory {\n-        static EXP_MASK: u64 = 0x7ff0000000000000;\n-        static MAN_MASK: u64 = 0x000fffffffffffff;\n-\n-        match (\n-            unsafe { ::cast::transmute::<f64,u64>(*self) } & MAN_MASK,\n-            unsafe { ::cast::transmute::<f64,u64>(*self) } & EXP_MASK,\n-        ) {\n-            (0, 0)        => FPZero,\n-            (_, 0)        => FPSubnormal,\n-            (0, EXP_MASK) => FPInfinite,\n-            (_, EXP_MASK) => FPNaN,\n-            _             => FPNormal,\n-        }\n-    }\n-\n-    #[inline]\n-    fn mantissa_digits(_: Option<f64>) -> uint { 53 }\n-\n-    #[inline]\n-    fn digits(_: Option<f64>) -> uint { 15 }\n-\n-    #[inline]\n-    fn epsilon() -> f64 { 2.2204460492503131e-16 }\n-\n-    #[inline]\n-    fn min_exp(_: Option<f64>) -> int { -1021 }\n-\n-    #[inline]\n-    fn max_exp(_: Option<f64>) -> int { 1024 }\n-\n-    #[inline]\n-    fn min_10_exp(_: Option<f64>) -> int { -307 }\n-\n-    #[inline]\n-    fn max_10_exp(_: Option<f64>) -> int { 308 }\n-\n-    /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n-    #[inline]\n-    fn ldexp(x: f64, exp: int) -> f64 {\n-        ldexp(x, exp as c_int)\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n-    ///\n-    /// - `self = x * pow(2, exp)`\n-    /// - `0.5 <= abs(x) < 1.0`\n-    #[inline]\n-    fn frexp(&self) -> (f64, int) {\n-        let mut exp = 0;\n-        let x = frexp(*self, &mut exp);\n-        (x, exp as int)\n-    }\n-\n-    /// Returns the exponential of the number, minus `1`, in a way that is accurate\n-    /// even if the number is close to zero\n-    #[inline]\n-    fn exp_m1(&self) -> f64 { exp_m1(*self) }\n-\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n-    /// than if the operations were performed separately\n-    #[inline]\n-    fn ln_1p(&self) -> f64 { ln_1p(*self) }\n-\n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n-    /// produces a more accurate result with better performance than a separate multiplication\n-    /// operation followed by an add.\n-    #[inline]\n-    fn mul_add(&self, a: f64, b: f64) -> f64 {\n-        mul_add(*self, a, b)\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline]\n-    fn next_after(&self, other: f64) -> f64 {\n-        next_after(*self, other)\n-    }\n-\n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(&self) -> (u64, i16, i8) {\n-        let bits: u64 = unsafe {\n-            ::cast::transmute(*self)\n-        };\n-        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0xfffffffffffff) << 1\n-        } else {\n-            (bits & 0xfffffffffffff) | 0x10000000000000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 1023 + 52;\n-        (mantissa, exponent, sign)\n-    }\n-}\n-\n //\n // Section: String Conversions\n //\n@@ -999,23 +997,23 @@ mod tests {\n \n     #[test]\n     fn test_real_consts() {\n-        let pi: f64 = Real::pi();\n-        let two_pi: f64 = Real::two_pi();\n-        let frac_pi_2: f64 = Real::frac_pi_2();\n-        let frac_pi_3: f64 = Real::frac_pi_3();\n-        let frac_pi_4: f64 = Real::frac_pi_4();\n-        let frac_pi_6: f64 = Real::frac_pi_6();\n-        let frac_pi_8: f64 = Real::frac_pi_8();\n-        let frac_1_pi: f64 = Real::frac_1_pi();\n-        let frac_2_pi: f64 = Real::frac_2_pi();\n-        let frac_2_sqrtpi: f64 = Real::frac_2_sqrtpi();\n-        let sqrt2: f64 = Real::sqrt2();\n-        let frac_1_sqrt2: f64 = Real::frac_1_sqrt2();\n-        let e: f64 = Real::e();\n-        let log2_e: f64 = Real::log2_e();\n-        let log10_e: f64 = Real::log10_e();\n-        let ln_2: f64 = Real::ln_2();\n-        let ln_10: f64 = Real::ln_10();\n+        let pi: f64 = Float::pi();\n+        let two_pi: f64 = Float::two_pi();\n+        let frac_pi_2: f64 = Float::frac_pi_2();\n+        let frac_pi_3: f64 = Float::frac_pi_3();\n+        let frac_pi_4: f64 = Float::frac_pi_4();\n+        let frac_pi_6: f64 = Float::frac_pi_6();\n+        let frac_pi_8: f64 = Float::frac_pi_8();\n+        let frac_1_pi: f64 = Float::frac_1_pi();\n+        let frac_2_pi: f64 = Float::frac_2_pi();\n+        let frac_2_sqrtpi: f64 = Float::frac_2_sqrtpi();\n+        let sqrt2: f64 = Float::sqrt2();\n+        let frac_1_sqrt2: f64 = Float::frac_1_sqrt2();\n+        let e: f64 = Float::e();\n+        let log2_e: f64 = Float::log2_e();\n+        let log10_e: f64 = Float::log10_e();\n+        let ln_2: f64 = Float::ln_2();\n+        let ln_10: f64 = Float::ln_10();\n \n         assert_approx_eq!(two_pi, 2.0 * pi);\n         assert_approx_eq!(frac_pi_2, pi / 2f64);"}, {"sha": "a954e7673222f64bf0b4bb5fa4ebf00a0f5f6f10", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 166, "deletions": 172, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=876eb931dcdfa1a1e55a58f3af230062727f3c70", "patch": "@@ -166,115 +166,6 @@ pub trait Round {\n     fn fract(&self) -> Self;\n }\n \n-/// Defines constants and methods common to real numbers\n-pub trait Real: Signed\n-              + Ord\n-              + Round\n-              + Div<Self,Self> {\n-    // Common Constants\n-    // FIXME (#5527): These should be associated constants\n-    fn pi() -> Self;\n-    fn two_pi() -> Self;\n-    fn frac_pi_2() -> Self;\n-    fn frac_pi_3() -> Self;\n-    fn frac_pi_4() -> Self;\n-    fn frac_pi_6() -> Self;\n-    fn frac_pi_8() -> Self;\n-    fn frac_1_pi() -> Self;\n-    fn frac_2_pi() -> Self;\n-    fn frac_2_sqrtpi() -> Self;\n-    fn sqrt2() -> Self;\n-    fn frac_1_sqrt2() -> Self;\n-    fn e() -> Self;\n-    fn log2_e() -> Self;\n-    fn log10_e() -> Self;\n-    fn ln_2() -> Self;\n-    fn ln_10() -> Self;\n-\n-    // Fractional functions\n-\n-    /// Take the reciprocal (inverse) of a number, `1/x`.\n-    fn recip(&self) -> Self;\n-\n-    // Algebraic functions\n-    /// Raise a number to a power.\n-    fn powf(&self, n: &Self) -> Self;\n-\n-    /// Take the square root of a number.\n-    fn sqrt(&self) -> Self;\n-    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    fn rsqrt(&self) -> Self;\n-    /// Take the cubic root of a number.\n-    fn cbrt(&self) -> Self;\n-    /// Calculate the length of the hypotenuse of a right-angle triangle given\n-    /// legs of length `x` and `y`.\n-    fn hypot(&self, other: &Self) -> Self;\n-\n-    // Trigonometric functions\n-\n-    /// Computes the sine of a number (in radians).\n-    fn sin(&self) -> Self;\n-    /// Computes the cosine of a number (in radians).\n-    fn cos(&self) -> Self;\n-    /// Computes the tangent of a number (in radians).\n-    fn tan(&self) -> Self;\n-\n-    /// Computes the arcsine of a number. Return value is in radians in\n-    /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n-    /// [-1, 1].\n-    fn asin(&self) -> Self;\n-    /// Computes the arccosine of a number. Return value is in radians in\n-    /// the range [0, pi] or NaN if the number is outside the range\n-    /// [-1, 1].\n-    fn acos(&self) -> Self;\n-    /// Computes the arctangent of a number. Return value is in radians in the\n-    /// range [-pi/2, pi/2];\n-    fn atan(&self) -> Self;\n-    /// Computes the four quadrant arctangent of a number, `y`, and another\n-    /// number `x`. Return value is in radians in the range [-pi, pi].\n-    fn atan2(&self, other: &Self) -> Self;\n-    /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n-    /// `(sin(x), cos(x))`.\n-    fn sin_cos(&self) -> (Self, Self);\n-\n-    // Exponential functions\n-\n-    /// Returns `e^(self)`, (the exponential function).\n-    fn exp(&self) -> Self;\n-    /// Returns 2 raised to the power of the number, `2^(self)`.\n-    fn exp2(&self) -> Self;\n-    /// Returns the natural logarithm of the number.\n-    fn ln(&self) -> Self;\n-    /// Returns the logarithm of the number with respect to an arbitrary base.\n-    fn log(&self, base: &Self) -> Self;\n-    /// Returns the base 2 logarithm of the number.\n-    fn log2(&self) -> Self;\n-    /// Returns the base 10 logarithm of the number.\n-    fn log10(&self) -> Self;\n-\n-    // Hyperbolic functions\n-\n-    /// Hyperbolic sine function.\n-    fn sinh(&self) -> Self;\n-    /// Hyperbolic cosine function.\n-    fn cosh(&self) -> Self;\n-    /// Hyperbolic tangent function.\n-    fn tanh(&self) -> Self;\n-    /// Inverse hyperbolic sine function.\n-    fn asinh(&self) -> Self;\n-    /// Inverse hyperbolic cosine function.\n-    fn acosh(&self) -> Self;\n-    /// Inverse hyperbolic tangent function.\n-    fn atanh(&self) -> Self;\n-\n-    // Angular conversions\n-\n-    /// Convert radians to degrees.\n-    fn to_degrees(&self) -> Self;\n-    /// Convert degrees to radians.\n-    fn to_radians(&self) -> Self;\n-}\n-\n /// Raises a value to the power of exp, using exponentiation by squaring.\n ///\n /// # Example\n@@ -300,67 +191,6 @@ pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T {\n     }\n }\n \n-/// Raise a number to a power.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::num;\n-///\n-/// let sixteen: f64 = num::powf(2.0, 4.0);\n-/// assert_eq!(sixteen, 16.0);\n-/// ```\n-#[inline(always)] pub fn powf<T: Real>(value: T, n: T) -> T { value.powf(&n) }\n-/// Take the square root of a number.\n-#[inline(always)] pub fn sqrt<T: Real>(value: T) -> T { value.sqrt() }\n-/// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-#[inline(always)] pub fn rsqrt<T: Real>(value: T) -> T { value.rsqrt() }\n-/// Take the cubic root of a number.\n-#[inline(always)] pub fn cbrt<T: Real>(value: T) -> T { value.cbrt() }\n-/// Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and\n-/// `y`.\n-#[inline(always)] pub fn hypot<T: Real>(x: T, y: T) -> T { x.hypot(&y) }\n-/// Sine function.\n-#[inline(always)] pub fn sin<T: Real>(value: T) -> T { value.sin() }\n-/// Cosine function.\n-#[inline(always)] pub fn cos<T: Real>(value: T) -> T { value.cos() }\n-/// Tangent function.\n-#[inline(always)] pub fn tan<T: Real>(value: T) -> T { value.tan() }\n-/// Compute the arcsine of the number.\n-#[inline(always)] pub fn asin<T: Real>(value: T) -> T { value.asin() }\n-/// Compute the arccosine of the number.\n-#[inline(always)] pub fn acos<T: Real>(value: T) -> T { value.acos() }\n-/// Compute the arctangent of the number.\n-#[inline(always)] pub fn atan<T: Real>(value: T) -> T { value.atan() }\n-/// Compute the arctangent with 2 arguments.\n-#[inline(always)] pub fn atan2<T: Real>(x: T, y: T) -> T { x.atan2(&y) }\n-/// Simultaneously computes the sine and cosine of the number.\n-#[inline(always)] pub fn sin_cos<T: Real>(value: T) -> (T, T) { value.sin_cos() }\n-/// Returns `e^(value)`, (the exponential function).\n-#[inline(always)] pub fn exp<T: Real>(value: T) -> T { value.exp() }\n-/// Returns 2 raised to the power of the number, `2^(value)`.\n-#[inline(always)] pub fn exp2<T: Real>(value: T) -> T { value.exp2() }\n-/// Returns the natural logarithm of the number.\n-#[inline(always)] pub fn ln<T: Real>(value: T) -> T { value.ln() }\n-/// Returns the logarithm of the number with respect to an arbitrary base.\n-#[inline(always)] pub fn log<T: Real>(value: T, base: T) -> T { value.log(&base) }\n-/// Returns the base 2 logarithm of the number.\n-#[inline(always)] pub fn log2<T: Real>(value: T) -> T { value.log2() }\n-/// Returns the base 10 logarithm of the number.\n-#[inline(always)] pub fn log10<T: Real>(value: T) -> T { value.log10() }\n-/// Hyperbolic sine function.\n-#[inline(always)] pub fn sinh<T: Real>(value: T) -> T { value.sinh() }\n-/// Hyperbolic cosine function.\n-#[inline(always)] pub fn cosh<T: Real>(value: T) -> T { value.cosh() }\n-/// Hyperbolic tangent function.\n-#[inline(always)] pub fn tanh<T: Real>(value: T) -> T { value.tanh() }\n-/// Inverse hyperbolic sine function.\n-#[inline(always)] pub fn asinh<T: Real>(value: T) -> T { value.asinh() }\n-/// Inverse hyperbolic cosine function.\n-#[inline(always)] pub fn acosh<T: Real>(value: T) -> T { value.acosh() }\n-/// Inverse hyperbolic tangent function.\n-#[inline(always)] pub fn atanh<T: Real>(value: T) -> T { value.atanh() }\n-\n pub trait Bounded {\n     // FIXME (#5527): These should be associated constants\n     fn min_value() -> Self;\n@@ -473,8 +303,8 @@ pub enum FPCategory {\n }\n \n /// Primitive floating point numbers\n-pub trait Float: Real\n-               + Signed\n+pub trait Float: Signed\n+               + Round\n                + Primitive {\n     // FIXME (#5527): These should be associated constants\n     fn nan() -> Self;\n@@ -506,6 +336,109 @@ pub trait Float: Real\n     fn next_after(&self, other: Self) -> Self;\n \n     fn integer_decode(&self) -> (u64, i16, i8);\n+\n+    // Common Mathematical Constants\n+    // FIXME (#5527): These should be associated constants\n+    fn pi() -> Self;\n+    fn two_pi() -> Self;\n+    fn frac_pi_2() -> Self;\n+    fn frac_pi_3() -> Self;\n+    fn frac_pi_4() -> Self;\n+    fn frac_pi_6() -> Self;\n+    fn frac_pi_8() -> Self;\n+    fn frac_1_pi() -> Self;\n+    fn frac_2_pi() -> Self;\n+    fn frac_2_sqrtpi() -> Self;\n+    fn sqrt2() -> Self;\n+    fn frac_1_sqrt2() -> Self;\n+    fn e() -> Self;\n+    fn log2_e() -> Self;\n+    fn log10_e() -> Self;\n+    fn ln_2() -> Self;\n+    fn ln_10() -> Self;\n+\n+    // Fractional functions\n+\n+    /// Take the reciprocal (inverse) of a number, `1/x`.\n+    fn recip(&self) -> Self;\n+\n+    // Algebraic functions\n+    /// Raise a number to a power.\n+    fn powf(&self, n: &Self) -> Self;\n+\n+    /// Take the square root of a number.\n+    fn sqrt(&self) -> Self;\n+    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    fn rsqrt(&self) -> Self;\n+    /// Take the cubic root of a number.\n+    fn cbrt(&self) -> Self;\n+    /// Calculate the length of the hypotenuse of a right-angle triangle given\n+    /// legs of length `x` and `y`.\n+    fn hypot(&self, other: &Self) -> Self;\n+\n+    // Trigonometric functions\n+\n+    /// Computes the sine of a number (in radians).\n+    fn sin(&self) -> Self;\n+    /// Computes the cosine of a number (in radians).\n+    fn cos(&self) -> Self;\n+    /// Computes the tangent of a number (in radians).\n+    fn tan(&self) -> Self;\n+\n+    /// Computes the arcsine of a number. Return value is in radians in\n+    /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n+    /// [-1, 1].\n+    fn asin(&self) -> Self;\n+    /// Computes the arccosine of a number. Return value is in radians in\n+    /// the range [0, pi] or NaN if the number is outside the range\n+    /// [-1, 1].\n+    fn acos(&self) -> Self;\n+    /// Computes the arctangent of a number. Return value is in radians in the\n+    /// range [-pi/2, pi/2];\n+    fn atan(&self) -> Self;\n+    /// Computes the four quadrant arctangent of a number, `y`, and another\n+    /// number `x`. Return value is in radians in the range [-pi, pi].\n+    fn atan2(&self, other: &Self) -> Self;\n+    /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n+    /// `(sin(x), cos(x))`.\n+    fn sin_cos(&self) -> (Self, Self);\n+\n+    // Exponential functions\n+\n+    /// Returns `e^(self)`, (the exponential function).\n+    fn exp(&self) -> Self;\n+    /// Returns 2 raised to the power of the number, `2^(self)`.\n+    fn exp2(&self) -> Self;\n+    /// Returns the natural logarithm of the number.\n+    fn ln(&self) -> Self;\n+    /// Returns the logarithm of the number with respect to an arbitrary base.\n+    fn log(&self, base: &Self) -> Self;\n+    /// Returns the base 2 logarithm of the number.\n+    fn log2(&self) -> Self;\n+    /// Returns the base 10 logarithm of the number.\n+    fn log10(&self) -> Self;\n+\n+    // Hyperbolic functions\n+\n+    /// Hyperbolic sine function.\n+    fn sinh(&self) -> Self;\n+    /// Hyperbolic cosine function.\n+    fn cosh(&self) -> Self;\n+    /// Hyperbolic tangent function.\n+    fn tanh(&self) -> Self;\n+    /// Inverse hyperbolic sine function.\n+    fn asinh(&self) -> Self;\n+    /// Inverse hyperbolic cosine function.\n+    fn acosh(&self) -> Self;\n+    /// Inverse hyperbolic tangent function.\n+    fn atanh(&self) -> Self;\n+\n+    // Angular conversions\n+\n+    /// Convert radians to degrees.\n+    fn to_degrees(&self) -> Self;\n+    /// Convert degrees to radians.\n+    fn to_radians(&self) -> Self;\n }\n \n /// Returns the exponential of the number, minus `1`, `exp(n) - 1`, in a way\n@@ -520,6 +453,67 @@ pub trait Float: Real\n /// architectures) than a separate multiplication operation followed by an add.\n #[inline(always)] pub fn mul_add<T: Float>(a: T, b: T, c: T) -> T { a.mul_add(b, c) }\n \n+/// Raise a number to a power.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::num;\n+///\n+/// let sixteen: f64 = num::powf(2.0, 4.0);\n+/// assert_eq!(sixteen, 16.0);\n+/// ```\n+#[inline(always)] pub fn powf<T: Float>(value: T, n: T) -> T { value.powf(&n) }\n+/// Take the square root of a number.\n+#[inline(always)] pub fn sqrt<T: Float>(value: T) -> T { value.sqrt() }\n+/// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+#[inline(always)] pub fn rsqrt<T: Float>(value: T) -> T { value.rsqrt() }\n+/// Take the cubic root of a number.\n+#[inline(always)] pub fn cbrt<T: Float>(value: T) -> T { value.cbrt() }\n+/// Calculate the length of the hypotenuse of a right-angle triangle given legs\n+/// of length `x` and `y`.\n+#[inline(always)] pub fn hypot<T: Float>(x: T, y: T) -> T { x.hypot(&y) }\n+/// Sine function.\n+#[inline(always)] pub fn sin<T: Float>(value: T) -> T { value.sin() }\n+/// Cosine function.\n+#[inline(always)] pub fn cos<T: Float>(value: T) -> T { value.cos() }\n+/// Tangent function.\n+#[inline(always)] pub fn tan<T: Float>(value: T) -> T { value.tan() }\n+/// Compute the arcsine of the number.\n+#[inline(always)] pub fn asin<T: Float>(value: T) -> T { value.asin() }\n+/// Compute the arccosine of the number.\n+#[inline(always)] pub fn acos<T: Float>(value: T) -> T { value.acos() }\n+/// Compute the arctangent of the number.\n+#[inline(always)] pub fn atan<T: Float>(value: T) -> T { value.atan() }\n+/// Compute the arctangent with 2 arguments.\n+#[inline(always)] pub fn atan2<T: Float>(x: T, y: T) -> T { x.atan2(&y) }\n+/// Simultaneously computes the sine and cosine of the number.\n+#[inline(always)] pub fn sin_cos<T: Float>(value: T) -> (T, T) { value.sin_cos() }\n+/// Returns `e^(value)`, (the exponential function).\n+#[inline(always)] pub fn exp<T: Float>(value: T) -> T { value.exp() }\n+/// Returns 2 raised to the power of the number, `2^(value)`.\n+#[inline(always)] pub fn exp2<T: Float>(value: T) -> T { value.exp2() }\n+/// Returns the natural logarithm of the number.\n+#[inline(always)] pub fn ln<T: Float>(value: T) -> T { value.ln() }\n+/// Returns the logarithm of the number with respect to an arbitrary base.\n+#[inline(always)] pub fn log<T: Float>(value: T, base: T) -> T { value.log(&base) }\n+/// Returns the base 2 logarithm of the number.\n+#[inline(always)] pub fn log2<T: Float>(value: T) -> T { value.log2() }\n+/// Returns the base 10 logarithm of the number.\n+#[inline(always)] pub fn log10<T: Float>(value: T) -> T { value.log10() }\n+/// Hyperbolic sine function.\n+#[inline(always)] pub fn sinh<T: Float>(value: T) -> T { value.sinh() }\n+/// Hyperbolic cosine function.\n+#[inline(always)] pub fn cosh<T: Float>(value: T) -> T { value.cosh() }\n+/// Hyperbolic tangent function.\n+#[inline(always)] pub fn tanh<T: Float>(value: T) -> T { value.tanh() }\n+/// Inverse hyperbolic sine function.\n+#[inline(always)] pub fn asinh<T: Float>(value: T) -> T { value.asinh() }\n+/// Inverse hyperbolic cosine function.\n+#[inline(always)] pub fn acosh<T: Float>(value: T) -> T { value.acosh() }\n+/// Inverse hyperbolic tangent function.\n+#[inline(always)] pub fn atanh<T: Float>(value: T) -> T { value.atanh() }\n+\n /// A generic trait for converting a value to a number.\n pub trait ToPrimitive {\n     /// Converts the value of `self` to an `int`."}, {"sha": "c355091cfb13e134a7db2be7fd0b90153cf3fd67", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=876eb931dcdfa1a1e55a58f3af230062727f3c70", "patch": "@@ -58,7 +58,7 @@ pub use hash::Hash;\n pub use iter::{FromIterator, Extendable};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n-pub use num::{Integer, Real, Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n+pub use num::{Integer, Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n pub use num::{Signed, Unsigned, Round};\n pub use num::{Primitive, Int, Float, ToStrRadix, ToPrimitive, FromPrimitive};\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};"}, {"sha": "09c36d945eb1a19fd876494ebefdcd765181d180", "filename": "src/libstd/rand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Frand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Frand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fexponential.rs?ref=876eb931dcdfa1a1e55a58f3af230062727f3c70", "patch": "@@ -10,7 +10,7 @@\n \n //! The exponential distribution.\n \n-use num::Real;\n+use num::Float;\n use rand::{Rng, Rand};\n use rand::distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};\n "}, {"sha": "a14b58188bd784eef6c244204cb6d7b2bfe87bc1", "filename": "src/libstd/rand/distributions/gamma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs?ref=876eb931dcdfa1a1e55a58f3af230062727f3c70", "patch": "@@ -10,7 +10,7 @@\n \n //! The Gamma and derived distributions.\n \n-use num::Real;\n+use num::Float;\n use num;\n use rand::{Rng, Open01};\n use super::normal::StandardNormal;"}, {"sha": "c9dc3c8abc1abc7ee00b6973f7894bba773ebfbf", "filename": "src/libstd/rand/distributions/normal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Frand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/876eb931dcdfa1a1e55a58f3af230062727f3c70/src%2Flibstd%2Frand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fnormal.rs?ref=876eb931dcdfa1a1e55a58f3af230062727f3c70", "patch": "@@ -10,7 +10,7 @@\n \n //! The normal and derived distributions.\n \n-use num::Real;\n+use num::Float;\n use rand::{Rng, Rand, Open01};\n use rand::distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};\n "}]}