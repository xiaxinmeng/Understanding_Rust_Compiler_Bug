{"sha": "ae4be16e407061828fe604b1ccbd61181b14a3f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNGJlMTZlNDA3MDYxODI4ZmU2MDRiMWNjYmQ2MTE4MWIxNGEzZjE=", "commit": {"author": {"name": "tyler", "email": "tyler@brainiumstudios.com", "date": "2019-04-27T14:38:01Z"}, "committer": {"name": "tyler", "email": "tyler@brainiumstudios.com", "date": "2019-05-15T14:30:33Z"}, "message": "redox had a copy of fast thread local (oversight?)", "tree": {"sha": "59461cea814349005ab153ae4ebb218f0b9441eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59461cea814349005ab153ae4ebb218f0b9441eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae4be16e407061828fe604b1ccbd61181b14a3f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae4be16e407061828fe604b1ccbd61181b14a3f1", "html_url": "https://github.com/rust-lang/rust/commit/ae4be16e407061828fe604b1ccbd61181b14a3f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae4be16e407061828fe604b1ccbd61181b14a3f1/comments", "author": {"login": "mtak-", "id": 6643140, "node_id": "MDQ6VXNlcjY2NDMxNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6643140?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mtak-", "html_url": "https://github.com/mtak-", "followers_url": "https://api.github.com/users/mtak-/followers", "following_url": "https://api.github.com/users/mtak-/following{/other_user}", "gists_url": "https://api.github.com/users/mtak-/gists{/gist_id}", "starred_url": "https://api.github.com/users/mtak-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mtak-/subscriptions", "organizations_url": "https://api.github.com/users/mtak-/orgs", "repos_url": "https://api.github.com/users/mtak-/repos", "events_url": "https://api.github.com/users/mtak-/events{/privacy}", "received_events_url": "https://api.github.com/users/mtak-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mtak-", "id": 6643140, "node_id": "MDQ6VXNlcjY2NDMxNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6643140?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mtak-", "html_url": "https://github.com/mtak-", "followers_url": "https://api.github.com/users/mtak-/followers", "following_url": "https://api.github.com/users/mtak-/following{/other_user}", "gists_url": "https://api.github.com/users/mtak-/gists{/gist_id}", "starred_url": "https://api.github.com/users/mtak-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mtak-/subscriptions", "organizations_url": "https://api.github.com/users/mtak-/orgs", "repos_url": "https://api.github.com/users/mtak-/repos", "events_url": "https://api.github.com/users/mtak-/events{/privacy}", "received_events_url": "https://api.github.com/users/mtak-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48e3da6d5910d119d4afefd7d06340390db6968d", "url": "https://api.github.com/repos/rust-lang/rust/commits/48e3da6d5910d119d4afefd7d06340390db6968d", "html_url": "https://github.com/rust-lang/rust/commit/48e3da6d5910d119d4afefd7d06340390db6968d"}], "stats": {"total": 105, "additions": 1, "deletions": 104}, "files": [{"sha": "67b92d490b2345d7b95c500dc9c533cc1a84b441", "filename": "src/libstd/sys/redox/fast_thread_local.rs", "status": "modified", "additions": 1, "deletions": 104, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/ae4be16e407061828fe604b1ccbd61181b14a3f1/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4be16e407061828fe604b1ccbd61181b14a3f1/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs?ref=ae4be16e407061828fe604b1ccbd61181b14a3f1", "patch": "@@ -1,107 +1,4 @@\n #![cfg(target_thread_local)]\n #![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n \n-use crate::cell::{Cell, UnsafeCell};\n-use crate::mem;\n-use crate::ptr;\n-\n-\n-pub struct Key<T> {\n-    inner: UnsafeCell<Option<T>>,\n-\n-    // Metadata to keep track of the state of the destructor. Remember that\n-    // these variables are thread-local, not global.\n-    dtor_registered: Cell<bool>,\n-    dtor_running: Cell<bool>,\n-}\n-\n-unsafe impl<T> Sync for Key<T> { }\n-\n-impl<T> Key<T> {\n-    pub const fn new() -> Key<T> {\n-        Key {\n-            inner: UnsafeCell::new(None),\n-            dtor_registered: Cell::new(false),\n-            dtor_running: Cell::new(false)\n-        }\n-    }\n-\n-    pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n-        unsafe {\n-            if mem::needs_drop::<T>() && self.dtor_running.get() {\n-                return None\n-            }\n-            self.register_dtor();\n-        }\n-        Some(&self.inner)\n-    }\n-\n-    unsafe fn register_dtor(&self) {\n-        if !mem::needs_drop::<T>() || self.dtor_registered.get() {\n-            return\n-        }\n-\n-        register_dtor(self as *const _ as *mut u8,\n-                      destroy_value::<T>);\n-        self.dtor_registered.set(true);\n-    }\n-}\n-\n-pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-    // The fallback implementation uses a vanilla OS-based TLS key to track\n-    // the list of destructors that need to be run for this thread. The key\n-    // then has its own destructor which runs all the other destructors.\n-    //\n-    // The destructor for DTORS is a little special in that it has a `while`\n-    // loop to continuously drain the list of registered destructors. It\n-    // *should* be the case that this loop always terminates because we\n-    // provide the guarantee that a TLS key cannot be set after it is\n-    // flagged for destruction.\n-    use crate::sys_common::thread_local as os;\n-\n-    static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n-    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n-    if DTORS.get().is_null() {\n-        let v: Box<List> = box Vec::new();\n-        DTORS.set(Box::into_raw(v) as *mut u8);\n-    }\n-    let list: &mut List = &mut *(DTORS.get() as *mut List);\n-    list.push((t, dtor));\n-\n-    unsafe extern fn run_dtors(mut ptr: *mut u8) {\n-        while !ptr.is_null() {\n-            let list: Box<List> = Box::from_raw(ptr as *mut List);\n-            for (ptr, dtor) in list.into_iter() {\n-                dtor(ptr);\n-            }\n-            ptr = DTORS.get();\n-            DTORS.set(ptr::null_mut());\n-        }\n-    }\n-}\n-\n-pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n-    let ptr = ptr as *mut Key<T>;\n-    // Right before we run the user destructor be sure to flag the\n-    // destructor as running for this thread so calls to `get` will return\n-    // `None`.\n-    (*ptr).dtor_running.set(true);\n-\n-    // The macOS implementation of TLS apparently had an odd aspect to it\n-    // where the pointer we have may be overwritten while this destructor\n-    // is running. Specifically if a TLS destructor re-accesses TLS it may\n-    // trigger a re-initialization of all TLS variables, paving over at\n-    // least some destroyed ones with initial values.\n-    //\n-    // This means that if we drop a TLS value in place on macOS that we could\n-    // revert the value to its original state halfway through the\n-    // destructor, which would be bad!\n-    //\n-    // Hence, we use `ptr::read` on macOS (to move to a \"safe\" location)\n-    // instead of drop_in_place.\n-    if cfg!(target_os = \"macos\") {\n-        ptr::read((*ptr).inner.get());\n-    } else {\n-        ptr::drop_in_place((*ptr).inner.get());\n-    }\n-}\n+pub use crate::sys_common::thread_local::register_dtor_fallback as register_dtor;\n\\ No newline at end of file"}]}