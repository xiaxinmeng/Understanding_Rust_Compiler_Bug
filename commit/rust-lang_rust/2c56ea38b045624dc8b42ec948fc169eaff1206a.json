{"sha": "2c56ea38b045624dc8b42ec948fc169eaff1206a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNTZlYTM4YjA0NTYyNGRjOGI0MmVjOTQ4ZmMxNjllYWZmMTIwNmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-09T01:54:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-09T01:54:08Z"}, "message": "Auto merge of #78768 - mzabaluev:optimize-buf-writer, r=cramertj\n\nUse is_write_vectored to optimize the write_vectored implementation for BufWriter\n\nIn case when the underlying writer does not have an efficient implementation `write_vectored`, the present implementation of\n`write_vectored` for `BufWriter` may still forward vectored writes directly to the writer depending on the total length of the data. This misses the advantage of buffering, as the actually written slice may be small.\n\nProvide an alternative code path for the non-vectored case, where the slices passed to `BufWriter` are coalesced in the buffer before being flushed to the underlying writer with plain `write` calls. The buffer is only bypassed if an individual slice's length is at least as large as the buffer.\n\nRemove a FIXME comment referring to #72919 as the issue has been closed with an explanation provided.", "tree": {"sha": "67ec5a273fbd423069e9e616e0f2dbc46a91bfde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67ec5a273fbd423069e9e616e0f2dbc46a91bfde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c56ea38b045624dc8b42ec948fc169eaff1206a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c56ea38b045624dc8b42ec948fc169eaff1206a", "html_url": "https://github.com/rust-lang/rust/commit/2c56ea38b045624dc8b42ec948fc169eaff1206a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c56ea38b045624dc8b42ec948fc169eaff1206a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1700ca07c6dd7becff85678409a5df6ad4cf4f47", "url": "https://api.github.com/repos/rust-lang/rust/commits/1700ca07c6dd7becff85678409a5df6ad4cf4f47", "html_url": "https://github.com/rust-lang/rust/commit/1700ca07c6dd7becff85678409a5df6ad4cf4f47"}, {"sha": "674dd623ee067d4298fda867f72442b13014eaa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/674dd623ee067d4298fda867f72442b13014eaa3", "html_url": "https://github.com/rust-lang/rust/commit/674dd623ee067d4298fda867f72442b13014eaa3"}], "stats": {"total": 67, "additions": 53, "deletions": 14}, "files": [{"sha": "3b3399860ba7df7f572530a4dd176476c23d878e", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2c56ea38b045624dc8b42ec948fc169eaff1206a/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c56ea38b045624dc8b42ec948fc169eaff1206a/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=2c56ea38b045624dc8b42ec948fc169eaff1206a", "patch": "@@ -328,24 +328,57 @@ impl<W: Write> Write for BufWriter<W> {\n     }\n \n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n-        if self.buf.len() + total_len > self.buf.capacity() {\n-            self.flush_buf()?;\n-        }\n-        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n-        if total_len >= self.buf.capacity() {\n-            self.panicked = true;\n-            let r = self.get_mut().write_vectored(bufs);\n-            self.panicked = false;\n-            r\n+        if self.get_ref().is_write_vectored() {\n+            let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n+            if self.buf.len() + total_len > self.buf.capacity() {\n+                self.flush_buf()?;\n+            }\n+            if total_len >= self.buf.capacity() {\n+                self.panicked = true;\n+                let r = self.get_mut().write_vectored(bufs);\n+                self.panicked = false;\n+                r\n+            } else {\n+                bufs.iter().for_each(|b| self.buf.extend_from_slice(b));\n+                Ok(total_len)\n+            }\n         } else {\n-            bufs.iter().for_each(|b| self.buf.extend_from_slice(b));\n-            Ok(total_len)\n+            let mut iter = bufs.iter();\n+            let mut total_written = if let Some(buf) = iter.by_ref().find(|&buf| !buf.is_empty()) {\n+                // This is the first non-empty slice to write, so if it does\n+                // not fit in the buffer, we still get to flush and proceed.\n+                if self.buf.len() + buf.len() > self.buf.capacity() {\n+                    self.flush_buf()?;\n+                }\n+                if buf.len() >= self.buf.capacity() {\n+                    // The slice is at least as large as the buffering capacity,\n+                    // so it's better to write it directly, bypassing the buffer.\n+                    self.panicked = true;\n+                    let r = self.get_mut().write(buf);\n+                    self.panicked = false;\n+                    return r;\n+                } else {\n+                    self.buf.extend_from_slice(buf);\n+                    buf.len()\n+                }\n+            } else {\n+                return Ok(0);\n+            };\n+            debug_assert!(total_written != 0);\n+            for buf in iter {\n+                if self.buf.len() + buf.len() > self.buf.capacity() {\n+                    break;\n+                } else {\n+                    self.buf.extend_from_slice(buf);\n+                    total_written += buf.len();\n+                }\n+            }\n+            Ok(total_written)\n         }\n     }\n \n     fn is_write_vectored(&self) -> bool {\n-        self.get_ref().is_write_vectored()\n+        true\n     }\n \n     fn flush(&mut self) -> io::Result<()> {"}, {"sha": "d0c859d2e0c87de4ae69bdc293a9c33f574b97b7", "filename": "library/std/src/io/buffered/linewritershim.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c56ea38b045624dc8b42ec948fc169eaff1206a/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c56ea38b045624dc8b42ec948fc169eaff1206a/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs?ref=2c56ea38b045624dc8b42ec948fc169eaff1206a", "patch": "@@ -20,6 +20,12 @@ impl<'a, W: Write> LineWriterShim<'a, W> {\n         Self { buffer }\n     }\n \n+    /// Get a reference to the inner writer (that is, the writer\n+    /// wrapped by the BufWriter).\n+    fn inner(&self) -> &W {\n+        self.buffer.get_ref()\n+    }\n+\n     /// Get a mutable reference to the inner writer (that is, the writer\n     /// wrapped by the BufWriter). Be careful with this writer, as writes to\n     /// it will bypass the buffer.\n@@ -227,7 +233,7 @@ impl<'a, W: Write> Write for LineWriterShim<'a, W> {\n     }\n \n     fn is_write_vectored(&self) -> bool {\n-        self.buffer.is_write_vectored()\n+        self.inner().is_write_vectored()\n     }\n \n     /// Write some data into this BufReader with line buffering. This means"}]}