{"sha": "2194fd7569b227ba083c4f27e156af939e061c1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxOTRmZDc1NjliMjI3YmEwODNjNGYyN2UxNTZhZjkzOWUwNjFjMWI=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-06-20T00:11:32Z"}, "committer": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-07-04T00:22:32Z"}, "message": "liburl: rename and move from_str to Url::parse_str.\n\nurl::from_str => url::Url::parse_str\n\nThe FromStr trait still works, but its confusing to have a from_str\nfree function that retuns a Result, while the regular from_str\nreturns an Option, hence the rename.\n\n[breaking-change]", "tree": {"sha": "34dee3dfe5d93f0a4d671aeeb1b2bcbf2bf2ccc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34dee3dfe5d93f0a4d671aeeb1b2bcbf2bf2ccc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2194fd7569b227ba083c4f27e156af939e061c1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2194fd7569b227ba083c4f27e156af939e061c1b", "html_url": "https://github.com/rust-lang/rust/commit/2194fd7569b227ba083c4f27e156af939e061c1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2194fd7569b227ba083c4f27e156af939e061c1b/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd812ccbb56193c36819993dea25912788b447f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd812ccbb56193c36819993dea25912788b447f0", "html_url": "https://github.com/rust-lang/rust/commit/dd812ccbb56193c36819993dea25912788b447f0"}], "stats": {"total": 133, "additions": 61, "deletions": 72}, "files": [{"sha": "33688412f5f73a31d224680f3b5d205874e21230", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 61, "deletions": 72, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/2194fd7569b227ba083c4f27e156af939e061c1b/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2194fd7569b227ba083c4f27e156af939e061c1b/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=2194fd7569b227ba083c4f27e156af939e061c1b", "patch": "@@ -36,16 +36,13 @@ use std::uint;\n /// # Example\n ///\n /// ```rust\n-/// use url::{Url, UserInfo};\n+/// use url::Url;\n ///\n-/// let url = Url { scheme: \"https\".to_string(),\n-///                 user: Some(UserInfo { user: \"username\".to_string(), pass: None }),\n-///                 host: \"example.com\".to_string(),\n-///                 port: Some(\"8080\".to_string()),\n-///                 path: \"/foo/bar\".to_string(),\n-///                 query: vec!((\"baz\".to_string(), \"qux\".to_string())),\n-///                 fragment: Some(\"quz\".to_string()) };\n-/// // https://username@example.com:8080/foo/bar?baz=qux#quz\n+/// let raw = \"https://username@example.com:8080/foo/bar?baz=qux#quz\";\n+/// match Url::parse(raw) {\n+///     Ok(u) => println!(\"Parsed '{}'\", u),\n+///     Err(e) => println!(\"Couldn't parse '{}': {}\", raw, e),\n+/// }\n /// ```\n #[deriving(Clone, PartialEq, Eq)]\n pub struct Url {\n@@ -110,6 +107,38 @@ impl Url {\n             fragment: fragment,\n         }\n     }\n+\n+    /// Parses a URL, converting it from a string to a `Url` representation.\n+    ///\n+    /// # Arguments\n+    /// * rawurl - a string representing the full URL, including scheme.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Err(e)` if the string did not represent a valid URL, where `e` is a\n+    /// `String` error message. Otherwise, `Ok(u)` where `u` is a `Url` struct\n+    /// representing the URL.\n+    pub fn parse(rawurl: &str) -> Result<Url, String> {\n+        // scheme\n+        let (scheme, rest) = try!(get_scheme(rawurl));\n+\n+        // authority\n+        let (userinfo, host, port, rest) = try!(get_authority(rest.as_slice()));\n+\n+        // path\n+        let has_authority = host.len() > 0;\n+        let (path, rest) = try!(get_path(rest.as_slice(), has_authority));\n+\n+        // query and fragment\n+        let (query, fragment) = try!(get_query_fragment(rest.as_slice()));\n+\n+        Ok(Url::new(scheme, userinfo, host, port, path, query, fragment))\n+    }\n+}\n+\n+#[deprecated=\"use `Url::parse`\"]\n+pub fn from_str(s: &str) -> Result<Url, String> {\n+    Url::parse(s)\n }\n \n impl Path {\n@@ -734,46 +763,6 @@ fn get_query_fragment(rawurl: &str) ->\n     return Ok((query_from_str(q.as_slice()), f));\n }\n \n-/**\n- * Parses a URL, converting it from a string to `Url` representation.\n- *\n- * # Arguments\n- *\n- * `rawurl` - a string representing the full URL, including scheme.\n- *\n- * # Returns\n- *\n- * A `Url` struct type representing the URL.\n- */\n-pub fn from_str(rawurl: &str) -> Result<Url, String> {\n-    // scheme\n-    let (scheme, rest) = match get_scheme(rawurl) {\n-        Ok(val) => val,\n-        Err(e) => return Err(e),\n-    };\n-\n-    // authority\n-    let (userinfo, host, port, rest) = match get_authority(rest.as_slice()) {\n-        Ok(val) => val,\n-        Err(e) => return Err(e),\n-    };\n-\n-    // path\n-    let has_authority = host.len() > 0;\n-    let (path, rest) = match get_path(rest.as_slice(), has_authority) {\n-        Ok(val) => val,\n-        Err(e) => return Err(e),\n-    };\n-\n-    // query and fragment\n-    let (query, fragment) = match get_query_fragment(rest.as_slice()) {\n-        Ok(val) => val,\n-        Err(e) => return Err(e),\n-    };\n-\n-    Ok(Url::new(scheme, userinfo, host, port, path, query, fragment))\n-}\n-\n pub fn path_from_str(rawpath: &str) -> Result<Path, String> {\n     let (path, rest) = match get_path(rawpath, false) {\n         Ok(val) => val,\n@@ -791,7 +780,7 @@ pub fn path_from_str(rawpath: &str) -> Result<Path, String> {\n \n impl FromStr for Url {\n     fn from_str(s: &str) -> Option<Url> {\n-        match from_str(s) {\n+        match Url::parse(s) {\n             Ok(url) => Some(url),\n             Err(_) => None\n         }\n@@ -969,16 +958,16 @@ fn test_get_path() {\n #[cfg(test)]\n mod tests {\n     use {encode_form_urlencoded, decode_form_urlencoded,\n-         decode, encode, from_str, encode_component, decode_component,\n-         path_from_str, UserInfo, get_scheme};\n+         decode, encode, encode_component, decode_component,\n+         path_from_str, UserInfo, get_scheme, Url};\n \n     use std::collections::HashMap;\n \n     #[test]\n     fn test_url_parse() {\n         let url = \"http://user:pass@rust-lang.org:8080/doc/~u?s=v#something\";\n \n-        let up = from_str(url);\n+        let up = from_str::<Url>(url);\n         let u = up.unwrap();\n         assert_eq!(&u.scheme, &\"http\".to_string());\n         assert_eq!(&u.user, &Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n@@ -1003,7 +992,7 @@ mod tests {\n     #[test]\n     fn test_url_parse_host_slash() {\n         let urlstr = \"http://0.42.42.42/\";\n-        let url = from_str(urlstr).unwrap();\n+        let url = from_str::<Url>(urlstr).unwrap();\n         assert!(url.host == \"0.42.42.42\".to_string());\n         assert!(url.path == \"/\".to_string());\n     }\n@@ -1018,14 +1007,14 @@ mod tests {\n     #[test]\n     fn test_url_host_with_port() {\n         let urlstr = \"scheme://host:1234\";\n-        let url = from_str(urlstr).unwrap();\n+        let url = from_str::<Url>(urlstr).unwrap();\n         assert_eq!(&url.scheme, &\"scheme\".to_string());\n         assert_eq!(&url.host, &\"host\".to_string());\n         assert_eq!(&url.port, &Some(\"1234\".to_string()));\n         // is empty path really correct? Other tests think so\n         assert_eq!(&url.path, &\"\".to_string());\n         let urlstr = \"scheme://host:1234/\";\n-        let url = from_str(urlstr).unwrap();\n+        let url = from_str::<Url>(urlstr).unwrap();\n         assert_eq!(&url.scheme, &\"scheme\".to_string());\n         assert_eq!(&url.host, &\"host\".to_string());\n         assert_eq!(&url.port, &Some(\"1234\".to_string()));\n@@ -1035,7 +1024,7 @@ mod tests {\n     #[test]\n     fn test_url_with_underscores() {\n         let urlstr = \"http://dotcom.com/file_name.html\";\n-        let url = from_str(urlstr).unwrap();\n+        let url = from_str::<Url>(urlstr).unwrap();\n         assert!(url.path == \"/file_name.html\".to_string());\n     }\n \n@@ -1049,7 +1038,7 @@ mod tests {\n     #[test]\n     fn test_url_with_dashes() {\n         let urlstr = \"http://dotcom.com/file-name.html\";\n-        let url = from_str(urlstr).unwrap();\n+        let url = from_str::<Url>(urlstr).unwrap();\n         assert!(url.path == \"/file-name.html\".to_string());\n     }\n \n@@ -1067,75 +1056,75 @@ mod tests {\n \n     #[test]\n     fn test_invalid_scheme_errors() {\n-        assert!(from_str(\"99://something\").is_err());\n-        assert!(from_str(\"://something\").is_err());\n+        assert!(Url::parse(\"99://something\").is_err());\n+        assert!(Url::parse(\"://something\").is_err());\n     }\n \n     #[test]\n     fn test_full_url_parse_and_format() {\n         let url = \"http://user:pass@rust-lang.org/doc?s=v#something\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        assert_eq!(from_str::<Url>(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_userless_url_parse_and_format() {\n         let url = \"http://rust-lang.org/doc?s=v#something\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        assert_eq!(from_str::<Url>(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_queryless_url_parse_and_format() {\n         let url = \"http://user:pass@rust-lang.org/doc#something\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        assert_eq!(from_str::<Url>(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_empty_query_url_parse_and_format() {\n         let url = \"http://user:pass@rust-lang.org/doc?#something\";\n         let should_be = \"http://user:pass@rust-lang.org/doc#something\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), should_be);\n+        assert_eq!(from_str::<Url>(url).unwrap().to_str().as_slice(), should_be);\n     }\n \n     #[test]\n     fn test_fragmentless_url_parse_and_format() {\n         let url = \"http://user:pass@rust-lang.org/doc?q=v\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        assert_eq!(from_str::<Url>(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_minimal_url_parse_and_format() {\n         let url = \"http://rust-lang.org/doc\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        assert_eq!(from_str::<Url>(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_url_with_port_parse_and_format() {\n         let url = \"http://rust-lang.org:80/doc\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        assert_eq!(from_str::<Url>(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_scheme_host_only_url_parse_and_format() {\n         let url = \"http://rust-lang.org\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        assert_eq!(from_str::<Url>(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_pathless_url_parse_and_format() {\n         let url = \"http://user:pass@rust-lang.org?q=v#something\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        assert_eq!(from_str::<Url>(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_scheme_host_fragment_only_url_parse_and_format() {\n         let url = \"http://rust-lang.org#something\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        assert_eq!(from_str::<Url>(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_url_component_encoding() {\n         let url = \"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n-        let u = from_str(url).unwrap();\n+        let u = from_str::<Url>(url).unwrap();\n         assert!(u.path == \"/doc uments\".to_string());\n         assert!(u.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n     }\n@@ -1151,7 +1140,7 @@ mod tests {\n     #[test]\n     fn test_url_without_authority() {\n         let url = \"mailto:test@email.com\";\n-        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n+        assert_eq!(from_str::<Url>(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]"}]}