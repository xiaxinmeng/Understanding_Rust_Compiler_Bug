{"sha": "989edf6dd908408723003539583643d11cd5b459", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4OWVkZjZkZDkwODQwODcyMzAwMzUzOTU4MzY0M2QxMWNkNWI0NTk=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-01-22T11:24:31Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-05-18T13:39:53Z"}, "message": "Add inline asm register definitions to librustc_target", "tree": {"sha": "69d28fd922926fb2386c64bbd93be2b6dc2831a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69d28fd922926fb2386c64bbd93be2b6dc2831a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/989edf6dd908408723003539583643d11cd5b459", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/989edf6dd908408723003539583643d11cd5b459", "html_url": "https://github.com/rust-lang/rust/commit/989edf6dd908408723003539583643d11cd5b459", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/989edf6dd908408723003539583643d11cd5b459/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62d5784a8f5aa8995b42b6fb5b0b2ffa4f8d69bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/62d5784a8f5aa8995b42b6fb5b0b2ffa4f8d69bb", "html_url": "https://github.com/rust-lang/rust/commit/62d5784a8f5aa8995b42b6fb5b0b2ffa4f8d69bb"}], "stats": {"total": 1449, "additions": 1448, "deletions": 1}, "files": [{"sha": "c734344f81ffec8e8ad85cccbf6d11c6124d02ad", "filename": "src/librustc_target/asm/aarch64.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/989edf6dd908408723003539583643d11cd5b459/src%2Flibrustc_target%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989edf6dd908408723003539583643d11cd5b459/src%2Flibrustc_target%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Faarch64.rs?ref=989edf6dd908408723003539583643d11cd5b459", "patch": "@@ -0,0 +1,155 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    AArch64 AArch64InlineAsmRegClass {\n+        reg,\n+        vreg,\n+        vreg_low16,\n+    }\n+}\n+\n+impl AArch64InlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        match self {\n+            Self::reg => &['w', 'x'],\n+            Self::vreg | Self::vreg_low16 => &['b', 'h', 's', 'd', 'q', 'v'],\n+        }\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        ty: InlineAsmType,\n+    ) -> Option<(char, &'static str, Option<&'static str>)> {\n+        match self {\n+            Self::reg => {\n+                if ty.size().bits() <= 32 {\n+                    Some(('w', \"w0\", None))\n+                } else {\n+                    None\n+                }\n+            }\n+            Self::vreg | Self::vreg_low16 => match ty.size().bits() {\n+                8 => Some(('b', \"b0\", None)),\n+                16 => Some(('h', \"h0\", None)),\n+                32 => Some(('s', \"s0\", None)),\n+                64 => Some(('d', \"d0\", None)),\n+                128 => Some(('q', \"q0\", None)),\n+                _ => None,\n+            },\n+        }\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        match self {\n+            Self::reg => Some(('x', \"x0\")),\n+            Self::vreg | Self::vreg_low16 => Some(('v', \"v0\")),\n+        }\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg => types! { _: I8, I16, I32, I64, F32, F64; },\n+            Self::vreg | Self::vreg_low16 => types! {\n+                \"fp\": I8, I16, I32, I64, F32, F64,\n+                VecI8(8), VecI16(4), VecI32(2), VecI64(1), VecF32(2), VecF64(1),\n+                VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2);\n+            },\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    AArch64 AArch64InlineAsmReg AArch64InlineAsmRegClass {\n+        x0: reg = [\"x0\", \"w0\"],\n+        x1: reg = [\"x1\", \"w1\"],\n+        x2: reg = [\"x2\", \"w2\"],\n+        x3: reg = [\"x3\", \"w3\"],\n+        x4: reg = [\"x4\", \"w4\"],\n+        x5: reg = [\"x5\", \"w5\"],\n+        x6: reg = [\"x6\", \"w6\"],\n+        x7: reg = [\"x7\", \"w7\"],\n+        x8: reg = [\"x8\", \"w8\"],\n+        x9: reg = [\"x9\", \"w9\"],\n+        x10: reg = [\"x10\", \"w10\"],\n+        x11: reg = [\"x11\", \"w11\"],\n+        x12: reg = [\"x12\", \"w12\"],\n+        x13: reg = [\"x13\", \"w13\"],\n+        x14: reg = [\"x14\", \"w14\"],\n+        x15: reg = [\"x15\", \"w15\"],\n+        x16: reg = [\"x16\", \"w16\"],\n+        x17: reg = [\"x17\", \"w17\"],\n+        x18: reg = [\"x18\", \"w18\"],\n+        x19: reg = [\"x19\", \"w19\"],\n+        x20: reg = [\"x20\", \"w20\"],\n+        x21: reg = [\"x21\", \"w21\"],\n+        x22: reg = [\"x22\", \"w22\"],\n+        x23: reg = [\"x23\", \"w23\"],\n+        x24: reg = [\"x24\", \"w24\"],\n+        x25: reg = [\"x25\", \"w25\"],\n+        x26: reg = [\"x26\", \"w26\"],\n+        x27: reg = [\"x27\", \"w27\"],\n+        x28: reg = [\"x28\", \"w28\"],\n+        x30: reg = [\"x30\", \"w30\", \"lr\"],\n+        v0: vreg, vreg_low16 = [\"v0\", \"b0\", \"h0\", \"s0\", \"d0\", \"q0\"],\n+        v1: vreg, vreg_low16 = [\"v1\", \"b1\", \"h1\", \"s1\", \"d1\", \"q1\"],\n+        v2: vreg, vreg_low16 = [\"v2\", \"b2\", \"h2\", \"s2\", \"d2\", \"q2\"],\n+        v3: vreg, vreg_low16 = [\"v3\", \"b3\", \"h3\", \"s3\", \"d3\", \"q3\"],\n+        v4: vreg, vreg_low16 = [\"v4\", \"b4\", \"h4\", \"s4\", \"d4\", \"q4\"],\n+        v5: vreg, vreg_low16 = [\"v5\", \"b5\", \"h5\", \"s5\", \"d5\", \"q5\"],\n+        v6: vreg, vreg_low16 = [\"v6\", \"b6\", \"h6\", \"s6\", \"d6\", \"q6\"],\n+        v7: vreg, vreg_low16 = [\"v7\", \"b7\", \"h7\", \"s7\", \"d7\", \"q7\"],\n+        v8: vreg, vreg_low16 = [\"v8\", \"b8\", \"h8\", \"s8\", \"d8\", \"q8\"],\n+        v9: vreg, vreg_low16 = [\"v9\", \"b9\", \"h9\", \"s9\", \"d9\", \"q9\"],\n+        v10: vreg, vreg_low16 = [\"v10\", \"b10\", \"h10\", \"s10\", \"d10\", \"q10\"],\n+        v11: vreg, vreg_low16 = [\"v11\", \"b11\", \"h11\", \"s11\", \"d11\", \"q11\"],\n+        v12: vreg, vreg_low16 = [\"v12\", \"b12\", \"h12\", \"s12\", \"d12\", \"q12\"],\n+        v13: vreg, vreg_low16 = [\"v13\", \"b13\", \"h13\", \"s13\", \"d13\", \"q13\"],\n+        v14: vreg, vreg_low16 = [\"v14\", \"b14\", \"h14\", \"s14\", \"d14\", \"q14\"],\n+        v15: vreg, vreg_low16 = [\"v15\", \"b15\", \"h15\", \"s15\", \"d15\", \"q15\"],\n+        v16: vreg = [\"v16\", \"b16\", \"h16\", \"s16\", \"d16\", \"q16\"],\n+        v17: vreg = [\"v17\", \"b17\", \"h17\", \"s17\", \"d17\", \"q17\"],\n+        v18: vreg = [\"v18\", \"b18\", \"h18\", \"s18\", \"d18\", \"q18\"],\n+        v19: vreg = [\"v19\", \"b19\", \"h19\", \"s19\", \"d19\", \"q19\"],\n+        v20: vreg = [\"v20\", \"b20\", \"h20\", \"s20\", \"d20\", \"q20\"],\n+        v21: vreg = [\"v21\", \"b21\", \"h21\", \"s21\", \"d21\", \"q21\"],\n+        v22: vreg = [\"v22\", \"b22\", \"h22\", \"s22\", \"d22\", \"q22\"],\n+        v23: vreg = [\"v23\", \"b23\", \"h23\", \"s23\", \"d23\", \"q23\"],\n+        v24: vreg = [\"v24\", \"b24\", \"h24\", \"s24\", \"d24\", \"q24\"],\n+        v25: vreg = [\"v25\", \"b25\", \"h25\", \"s25\", \"d25\", \"q25\"],\n+        v26: vreg = [\"v26\", \"b26\", \"h26\", \"s26\", \"d26\", \"q26\"],\n+        v27: vreg = [\"v27\", \"b27\", \"h27\", \"s27\", \"d27\", \"q27\"],\n+        v28: vreg = [\"v28\", \"b28\", \"h28\", \"s28\", \"d28\", \"q28\"],\n+        v29: vreg = [\"v29\", \"b29\", \"h29\", \"s29\", \"d29\", \"q29\"],\n+        v30: vreg = [\"v30\", \"b30\", \"h30\", \"s30\", \"d30\", \"q30\"],\n+        v31: vreg = [\"v31\", \"b31\", \"h31\", \"s31\", \"d31\", \"q31\"],\n+        \"the frame pointer cannot be used as an operand for inline asm\" =\n+            [\"x29\", \"fp\"],\n+        \"the stack pointer cannot be used as an operand for inline asm\" =\n+            [\"sp\", \"wsp\"],\n+        \"the zero register cannot be used as an operand for inline asm\" =\n+            [\"xzr\", \"wzr\"],\n+    }\n+}\n+\n+impl AArch64InlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        modifier: Option<char>,\n+    ) -> fmt::Result {\n+        let (prefix, index) = if (self as u32) < Self::v0 as u32 {\n+            (modifier.unwrap_or('x'), self as u32 - Self::x0 as u32)\n+        } else {\n+            (modifier.unwrap_or('v'), self as u32 - Self::v0 as u32)\n+        };\n+        assert!(index < 32);\n+        write!(out, \"{}{}\", prefix, index)\n+    }\n+}"}, {"sha": "143852db8298846a6ec67a8ccb1f506ca8db6256", "filename": "src/librustc_target/asm/arm.rs", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/989edf6dd908408723003539583643d11cd5b459/src%2Flibrustc_target%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989edf6dd908408723003539583643d11cd5b459/src%2Flibrustc_target%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Farm.rs?ref=989edf6dd908408723003539583643d11cd5b459", "patch": "@@ -0,0 +1,253 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    Arm ArmInlineAsmRegClass {\n+        reg,\n+        reg_thumb,\n+        sreg,\n+        sreg_low16,\n+        dreg,\n+        dreg_low16,\n+        dreg_low8,\n+        qreg,\n+        qreg_low8,\n+        qreg_low4,\n+    }\n+}\n+\n+impl ArmInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        match self {\n+            Self::qreg | Self::qreg_low8 | Self::qreg_low4 => &['e', 'f'],\n+            _ => &[],\n+        }\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str, Option<&'static str>)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg | Self::reg_thumb => types! { _: I8, I16, I32, F32; },\n+            Self::sreg | Self::sreg_low16 => types! { \"vfp2\": I32, F32; },\n+            Self::dreg | Self::dreg_low16 | Self::dreg_low8 => types! {\n+                \"vfp2\": I64, F64, VecI8(8), VecI16(4), VecI32(2), VecI64(1), VecF32(2);\n+            },\n+            Self::qreg | Self::qreg_low8 | Self::qreg_low4 => types! {\n+                \"neon\": VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4);\n+            },\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    Arm ArmInlineAsmReg ArmInlineAsmRegClass {\n+        r0: reg, reg_thumb = [\"r0\", \"a1\"],\n+        r1: reg, reg_thumb = [\"r1\", \"a2\"],\n+        r2: reg, reg_thumb = [\"r2\", \"a3\"],\n+        r3: reg, reg_thumb = [\"r3\", \"a4\"],\n+        r4: reg, reg_thumb = [\"r4\", \"v1\"],\n+        r5: reg, reg_thumb = [\"r5\", \"v2\"],\n+        r6: reg, reg_thumb = [\"r6\", \"v3\"],\n+        r7: reg, reg_thumb = [\"r7\", \"v4\"],\n+        r8: reg = [\"r8\", \"v5\"],\n+        r9: reg = [\"r9\", \"v6\", \"rfp\"],\n+        r10: reg = [\"r10\", \"sl\"],\n+        r12: reg = [\"r12\", \"ip\"],\n+        r14: reg = [\"r14\", \"lr\"],\n+        s0: sreg, sreg_low16 = [\"s0\"],\n+        s1: sreg, sreg_low16 = [\"s1\"],\n+        s2: sreg, sreg_low16 = [\"s2\"],\n+        s3: sreg, sreg_low16 = [\"s3\"],\n+        s4: sreg, sreg_low16 = [\"s4\"],\n+        s5: sreg, sreg_low16 = [\"s5\"],\n+        s6: sreg, sreg_low16 = [\"s6\"],\n+        s7: sreg, sreg_low16 = [\"s7\"],\n+        s8: sreg, sreg_low16 = [\"s8\"],\n+        s9: sreg, sreg_low16 = [\"s9\"],\n+        s10: sreg, sreg_low16 = [\"s10\"],\n+        s11: sreg, sreg_low16 = [\"s11\"],\n+        s12: sreg, sreg_low16 = [\"s12\"],\n+        s13: sreg, sreg_low16 = [\"s13\"],\n+        s14: sreg, sreg_low16 = [\"s14\"],\n+        s15: sreg, sreg_low16 = [\"s15\"],\n+        s16: sreg = [\"s16\"],\n+        s17: sreg = [\"s17\"],\n+        s18: sreg = [\"s18\"],\n+        s19: sreg = [\"s19\"],\n+        s20: sreg = [\"s20\"],\n+        s21: sreg = [\"s21\"],\n+        s22: sreg = [\"s22\"],\n+        s23: sreg = [\"s23\"],\n+        s24: sreg = [\"s24\"],\n+        s25: sreg = [\"s25\"],\n+        s26: sreg = [\"s26\"],\n+        s27: sreg = [\"s27\"],\n+        s28: sreg = [\"s28\"],\n+        s29: sreg = [\"s29\"],\n+        s30: sreg = [\"s30\"],\n+        s31: sreg = [\"s31\"],\n+        d0: dreg, dreg_low16, dreg_low8 = [\"d0\"],\n+        d1: dreg, dreg_low16, dreg_low8 = [\"d1\"],\n+        d2: dreg, dreg_low16, dreg_low8 = [\"d2\"],\n+        d3: dreg, dreg_low16, dreg_low8 = [\"d3\"],\n+        d4: dreg, dreg_low16, dreg_low8 = [\"d4\"],\n+        d5: dreg, dreg_low16, dreg_low8 = [\"d5\"],\n+        d6: dreg, dreg_low16, dreg_low8 = [\"d6\"],\n+        d7: dreg, dreg_low16, dreg_low8 = [\"d7\"],\n+        d8: dreg, dreg_low16 = [\"d8\"],\n+        d9: dreg, dreg_low16 = [\"d9\"],\n+        d10: dreg, dreg_low16 = [\"d10\"],\n+        d11: dreg, dreg_low16 = [\"d11\"],\n+        d12: dreg, dreg_low16 = [\"d12\"],\n+        d13: dreg, dreg_low16 = [\"d13\"],\n+        d14: dreg, dreg_low16 = [\"d14\"],\n+        d15: dreg, dreg_low16 = [\"d15\"],\n+        d16: dreg = [\"d16\"],\n+        d17: dreg = [\"d17\"],\n+        d18: dreg = [\"d18\"],\n+        d19: dreg = [\"d19\"],\n+        d20: dreg = [\"d20\"],\n+        d21: dreg = [\"d21\"],\n+        d22: dreg = [\"d22\"],\n+        d23: dreg = [\"d23\"],\n+        d24: dreg = [\"d24\"],\n+        d25: dreg = [\"d25\"],\n+        d26: dreg = [\"d26\"],\n+        d27: dreg = [\"d27\"],\n+        d28: dreg = [\"d28\"],\n+        d29: dreg = [\"d29\"],\n+        d30: dreg = [\"d30\"],\n+        d31: dreg = [\"d31\"],\n+        q0: qreg, qreg_low8, qreg_low4 = [\"q0\"],\n+        q1: qreg, qreg_low8, qreg_low4 = [\"q1\"],\n+        q2: qreg, qreg_low8, qreg_low4 = [\"q2\"],\n+        q3: qreg, qreg_low8, qreg_low4 = [\"q3\"],\n+        q4: qreg, qreg_low8 = [\"q4\"],\n+        q5: qreg, qreg_low8 = [\"q5\"],\n+        q6: qreg, qreg_low8 = [\"q6\"],\n+        q7: qreg, qreg_low8 = [\"q7\"],\n+        q8: qreg = [\"q8\"],\n+        q9: qreg = [\"q9\"],\n+        q10: qreg = [\"q10\"],\n+        q11: qreg = [\"q11\"],\n+        q12: qreg = [\"q12\"],\n+        q13: qreg = [\"q13\"],\n+        q14: qreg = [\"q14\"],\n+        q15: qreg = [\"q15\"],\n+        \"the frame pointer cannot be used as an operand for inline asm\" =\n+            [\"r11\", \"fp\"],\n+        \"the stack pointer cannot be used as an operand for inline asm\" =\n+            [\"r13\", \"sp\"],\n+        \"the program pointer cannot be used as an operand for inline asm\" =\n+            [\"r15\", \"pc\"],\n+    }\n+}\n+\n+impl ArmInlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        modifier: Option<char>,\n+    ) -> fmt::Result {\n+        // Only qreg is allowed to have modifiers. This should have been\n+        // validated already by now.\n+        if let Some(modifier) = modifier {\n+            let index = self as u32 - Self::q0 as u32;\n+            assert!(index < 16);\n+            let index = index * 2 + (modifier == 'f') as u32;\n+            write!(out, \"d{}\", index)\n+        } else {\n+            out.write_str(self.name())\n+        }\n+    }\n+\n+    pub fn overlapping_regs(self, mut cb: impl FnMut(ArmInlineAsmReg)) {\n+        cb(self);\n+\n+        macro_rules! reg_conflicts {\n+            (\n+                $(\n+                    $q:ident : $d0:ident $d1:ident : $s0:ident $s1:ident $s2:ident $s3:ident\n+                ),*;\n+                $(\n+                    $q_high:ident : $d0_high:ident $d1_high:ident\n+                ),*;\n+            ) => {\n+                match self {\n+                    $(\n+                        Self::$q => {\n+                            cb(Self::$d0);\n+                            cb(Self::$d1);\n+                            cb(Self::$s0);\n+                            cb(Self::$s1);\n+                            cb(Self::$s2);\n+                            cb(Self::$s3);\n+                        }\n+                        Self::$d0 => {\n+                            cb(Self::$q);\n+                            cb(Self::$s0);\n+                            cb(Self::$s1);\n+                        }\n+                        Self::$d1 => {\n+                            cb(Self::$q);\n+                            cb(Self::$s2);\n+                            cb(Self::$s3);\n+                        }\n+                        Self::$s0 | Self::$s1 => {\n+                            cb(Self::$q);\n+                            cb(Self::$d0);\n+                        }\n+                        Self::$s2 | Self::$s3 => {\n+                            cb(Self::$q);\n+                            cb(Self::$d1);\n+                        }\n+                    )*\n+                    $(\n+                        Self::$q_high => {\n+                            cb(Self::$d0_high);\n+                            cb(Self::$d1_high);\n+                        }\n+                        Self::$d0_high | Self::$d1_high => {\n+                            cb(Self::$q_high);\n+                        }\n+                    )*\n+                    _ => {},\n+                }\n+            };\n+        }\n+        reg_conflicts! {\n+            q0 : d0 d1 : s0 s1 s2 s3,\n+            q1 : d2 d3 : s4 s5 s6 s7,\n+            q2 : d4 d5 : s8 s9 s10 s11,\n+            q3 : d6 d7 : s12 s13 s14 s15,\n+            q4 : d8 d9 : s16 s17 s18 s19,\n+            q5 : d10 d11 : s20 s21 s22 s23,\n+            q6 : d12 d13 : s24 s25 s26 s27,\n+            q7 : d14 d15 : s28 s29 s30 s31;\n+            q8 : d16 d17,\n+            q9 : d18 d19,\n+            q10 : d20 d21,\n+            q11 : d22 d23,\n+            q12 : d24 d25,\n+            q13 : d26 d27,\n+            q14 : d28 d29,\n+            q15 : d30 d31;\n+        }\n+    }\n+}"}, {"sha": "1f8ff5d6d395a67e651a807619e5c705cd9de61b", "filename": "src/librustc_target/asm/mod.rs", "status": "added", "additions": 560, "deletions": 0, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/989edf6dd908408723003539583643d11cd5b459/src%2Flibrustc_target%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989edf6dd908408723003539583643d11cd5b459/src%2Flibrustc_target%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fmod.rs?ref=989edf6dd908408723003539583643d11cd5b459", "patch": "@@ -0,0 +1,560 @@\n+use crate::abi::Size;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_macros::HashStable_Generic;\n+use rustc_span::{Span, Symbol};\n+use std::fmt;\n+use std::str::FromStr;\n+\n+#[macro_use]\n+macro_rules! def_reg_class {\n+    ($arch:ident $arch_regclass:ident {\n+        $(\n+            $class:ident,\n+        )*\n+    }) => {\n+        #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n+        #[allow(non_camel_case_types)]\n+        pub enum $arch_regclass {\n+            $($class,)*\n+        }\n+\n+        impl $arch_regclass {\n+            pub fn name(self) -> &'static str {\n+                match self {\n+                    $(Self::$class => stringify!($class),)*\n+                }\n+            }\n+\n+            pub fn parse(_arch: super::InlineAsmArch, name: &str) -> Result<Self, &'static str> {\n+                match name {\n+                    $(\n+                        stringify!($class) => Ok(Self::$class),\n+                    )*\n+                    _ => Err(\"unknown register class\"),\n+                }\n+            }\n+        }\n+\n+        pub(super) fn regclass_map() -> rustc_data_structures::fx::FxHashMap<\n+            super::InlineAsmRegClass,\n+            rustc_data_structures::fx::FxHashSet<super::InlineAsmReg>,\n+        > {\n+            use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+            use super::InlineAsmRegClass;\n+            let mut map = FxHashMap::default();\n+            $(\n+                map.insert(InlineAsmRegClass::$arch($arch_regclass::$class), FxHashSet::default());\n+            )*\n+            map\n+        }\n+    }\n+}\n+\n+#[macro_use]\n+macro_rules! def_regs {\n+    ($arch:ident $arch_reg:ident $arch_regclass:ident {\n+        $(\n+            $reg:ident: $class:ident $(, $extra_class:ident)* = [$reg_name:literal $(, $alias:literal)*] $(% $filter:ident)?,\n+        )*\n+        $(\n+            $error:literal = [$($bad_reg:literal),+],\n+        )*\n+    }) => {\n+        #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n+        #[allow(non_camel_case_types)]\n+        pub enum $arch_reg {\n+            $($reg,)*\n+        }\n+\n+        impl $arch_reg {\n+            pub fn name(self) -> &'static str {\n+                match self {\n+                    $(Self::$reg => $reg_name,)*\n+                }\n+            }\n+\n+            pub fn reg_class(self) -> $arch_regclass {\n+                match self {\n+                    $(Self::$reg => $arch_regclass::$class,)*\n+                }\n+            }\n+\n+            pub fn parse(\n+                _arch: super::InlineAsmArch,\n+                mut _has_feature: impl FnMut(&str) -> bool,\n+                name: &str,\n+            ) -> Result<Self, &'static str> {\n+                match name {\n+                    $(\n+                        $($alias)|* | $reg_name => {\n+                            $($filter(_arch, &mut _has_feature)?;)?\n+                            Ok(Self::$reg)\n+                        }\n+                    )*\n+                    $(\n+                        $($bad_reg)|* => Err($error),\n+                    )*\n+                    _ => Err(\"unknown register\"),\n+                }\n+            }\n+        }\n+\n+        pub(super) fn fill_reg_map(\n+            _arch: super::InlineAsmArch,\n+            mut _has_feature: impl FnMut(&str) -> bool,\n+            map: &mut rustc_data_structures::fx::FxHashMap<\n+                super::InlineAsmRegClass,\n+                rustc_data_structures::fx::FxHashSet<super::InlineAsmReg>,\n+            >,\n+        ) {\n+            use super::{InlineAsmReg, InlineAsmRegClass};\n+            $(\n+                if $($filter(_arch, &mut _has_feature).is_ok() &&)? true {\n+                    if let Some(set) = map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$class)) {\n+                        set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n+                    }\n+                    $(\n+                        if let Some(set) = map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$extra_class)) {\n+                            set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n+                        }\n+                    )*\n+                }\n+            )*\n+        }\n+    }\n+}\n+\n+#[macro_use]\n+macro_rules! types {\n+    (\n+        $(_ : $($ty:expr),+;)?\n+        $($feature:literal: $($ty2:expr),+;)*\n+    ) => {\n+        {\n+            use super::InlineAsmType::*;\n+            &[\n+                $($(\n+                    ($ty, None),\n+                )*)?\n+                $($(\n+                    ($ty2, Some($feature)),\n+                )*)*\n+            ]\n+        }\n+    };\n+}\n+\n+mod aarch64;\n+mod arm;\n+mod riscv;\n+mod x86;\n+\n+pub use aarch64::{AArch64InlineAsmReg, AArch64InlineAsmRegClass};\n+pub use arm::{ArmInlineAsmReg, ArmInlineAsmRegClass};\n+pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n+pub use x86::{X86InlineAsmReg, X86InlineAsmRegClass};\n+\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash)]\n+pub enum InlineAsmArch {\n+    X86,\n+    X86_64,\n+    Arm,\n+    AArch64,\n+    RiscV32,\n+    RiscV64,\n+}\n+\n+impl FromStr for InlineAsmArch {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<InlineAsmArch, ()> {\n+        match s {\n+            \"x86\" => Ok(Self::X86),\n+            \"x86_64\" => Ok(Self::X86_64),\n+            \"arm\" => Ok(Self::Arm),\n+            \"aarch64\" => Ok(Self::AArch64),\n+            \"riscv32\" => Ok(Self::RiscV32),\n+            \"riscv64\" => Ok(Self::RiscV64),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+#[derive(\n+    Copy,\n+    Clone,\n+    RustcEncodable,\n+    RustcDecodable,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    Hash,\n+    HashStable_Generic\n+)]\n+pub enum InlineAsmReg {\n+    X86(X86InlineAsmReg),\n+    Arm(ArmInlineAsmReg),\n+    AArch64(AArch64InlineAsmReg),\n+    RiscV(RiscVInlineAsmReg),\n+}\n+\n+impl InlineAsmReg {\n+    pub fn name(self) -> &'static str {\n+        match self {\n+            Self::X86(r) => r.name(),\n+            Self::Arm(r) => r.name(),\n+            Self::AArch64(r) => r.name(),\n+            Self::RiscV(r) => r.name(),\n+        }\n+    }\n+\n+    pub fn reg_class(self) -> InlineAsmRegClass {\n+        match self {\n+            Self::X86(r) => InlineAsmRegClass::X86(r.reg_class()),\n+            Self::Arm(r) => InlineAsmRegClass::Arm(r.reg_class()),\n+            Self::AArch64(r) => InlineAsmRegClass::AArch64(r.reg_class()),\n+            Self::RiscV(r) => InlineAsmRegClass::RiscV(r.reg_class()),\n+        }\n+    }\n+\n+    pub fn parse(\n+        arch: InlineAsmArch,\n+        has_feature: impl FnMut(&str) -> bool,\n+        name: Symbol,\n+    ) -> Result<Self, &'static str> {\n+        // FIXME: use direct symbol comparison for register names\n+        name.with(|name| {\n+            Ok(match arch {\n+                InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n+                    Self::X86(X86InlineAsmReg::parse(arch, has_feature, name)?)\n+                }\n+                InlineAsmArch::Arm => Self::Arm(ArmInlineAsmReg::parse(arch, has_feature, name)?),\n+                InlineAsmArch::AArch64 => {\n+                    Self::AArch64(AArch64InlineAsmReg::parse(arch, has_feature, name)?)\n+                }\n+                InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n+                    Self::RiscV(RiscVInlineAsmReg::parse(arch, has_feature, name)?)\n+                }\n+            })\n+        })\n+    }\n+\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        arch: InlineAsmArch,\n+        modifier: Option<char>,\n+    ) -> fmt::Result {\n+        match self {\n+            Self::X86(r) => r.emit(out, arch, modifier),\n+            Self::Arm(r) => r.emit(out, arch, modifier),\n+            Self::AArch64(r) => r.emit(out, arch, modifier),\n+            Self::RiscV(r) => r.emit(out, arch, modifier),\n+        }\n+    }\n+\n+    pub fn overlapping_regs(self, mut cb: impl FnMut(InlineAsmReg)) {\n+        match self {\n+            Self::X86(r) => r.overlapping_regs(|r| cb(Self::X86(r))),\n+            Self::Arm(r) => r.overlapping_regs(|r| cb(Self::Arm(r))),\n+            Self::AArch64(_) => cb(self),\n+            Self::RiscV(_) => cb(self),\n+        }\n+    }\n+}\n+\n+#[derive(\n+    Copy,\n+    Clone,\n+    RustcEncodable,\n+    RustcDecodable,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    Hash,\n+    HashStable_Generic\n+)]\n+pub enum InlineAsmRegClass {\n+    X86(X86InlineAsmRegClass),\n+    Arm(ArmInlineAsmRegClass),\n+    AArch64(AArch64InlineAsmRegClass),\n+    RiscV(RiscVInlineAsmRegClass),\n+}\n+\n+impl InlineAsmRegClass {\n+    pub fn name(self) -> &'static str {\n+        match self {\n+            Self::X86(r) => r.name(),\n+            Self::Arm(r) => r.name(),\n+            Self::AArch64(r) => r.name(),\n+            Self::RiscV(r) => r.name(),\n+        }\n+    }\n+\n+    /// Returns a suggested template modifier to use for this type and an\n+    /// example of a  register named formatted with it. Optionally also returns\n+    /// the name of a different register class to use instead.\n+    ///\n+    /// Such suggestions are useful if a type smaller than the full register\n+    /// size is used and a modifier can be used to point to the subregister of\n+    /// the correct size.\n+    pub fn suggest_modifier(\n+        self,\n+        arch: InlineAsmArch,\n+        ty: InlineAsmType,\n+    ) -> Option<(char, &'static str, Option<&'static str>)> {\n+        match self {\n+            Self::X86(r) => r.suggest_modifier(arch, ty),\n+            Self::Arm(r) => r.suggest_modifier(arch, ty),\n+            Self::AArch64(r) => r.suggest_modifier(arch, ty),\n+            Self::RiscV(r) => r.suggest_modifier(arch, ty),\n+        }\n+    }\n+\n+    /// Returns the default modifier for this register and an example of a\n+    /// register named formatted with it.\n+    ///\n+    /// This is only needed when the register class can suggest a modifier, so\n+    /// that the user can be shown how to get the default behavior without a\n+    /// warning.\n+    pub fn default_modifier(self, arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        match self {\n+            Self::X86(r) => r.default_modifier(arch),\n+            Self::Arm(r) => r.default_modifier(arch),\n+            Self::AArch64(r) => r.default_modifier(arch),\n+            Self::RiscV(r) => r.default_modifier(arch),\n+        }\n+    }\n+\n+    /// Returns a list of supported types for this register class, each with a\n+    /// options target feature required to use this type.\n+    pub fn supported_types(\n+        self,\n+        arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::X86(r) => r.supported_types(arch),\n+            Self::Arm(r) => r.supported_types(arch),\n+            Self::AArch64(r) => r.supported_types(arch),\n+            Self::RiscV(r) => r.supported_types(arch),\n+        }\n+    }\n+\n+    pub fn parse(arch: InlineAsmArch, name: Symbol) -> Result<Self, &'static str> {\n+        // FIXME: use direct symbol comparison for register class names\n+        name.with(|name| {\n+            Ok(match arch {\n+                InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n+                    Self::X86(X86InlineAsmRegClass::parse(arch, name)?)\n+                }\n+                InlineAsmArch::Arm => Self::Arm(ArmInlineAsmRegClass::parse(arch, name)?),\n+                InlineAsmArch::AArch64 => {\n+                    Self::AArch64(AArch64InlineAsmRegClass::parse(arch, name)?)\n+                }\n+                InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n+                    Self::RiscV(RiscVInlineAsmRegClass::parse(arch, name)?)\n+                }\n+            })\n+        })\n+    }\n+\n+    /// Returns the list of template modifiers that can be used with this\n+    /// register class.\n+    pub fn valid_modifiers(self, arch: InlineAsmArch) -> &'static [char] {\n+        match self {\n+            Self::X86(r) => r.valid_modifiers(arch),\n+            Self::Arm(r) => r.valid_modifiers(arch),\n+            Self::AArch64(r) => r.valid_modifiers(arch),\n+            Self::RiscV(r) => r.valid_modifiers(arch),\n+        }\n+    }\n+}\n+\n+#[derive(\n+    Copy,\n+    Clone,\n+    RustcEncodable,\n+    RustcDecodable,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    Hash,\n+    HashStable_Generic\n+)]\n+pub enum InlineAsmRegOrRegClass {\n+    Reg(InlineAsmReg),\n+    RegClass(InlineAsmRegClass),\n+}\n+\n+impl InlineAsmRegOrRegClass {\n+    pub fn reg_class(self) -> InlineAsmRegClass {\n+        match self {\n+            Self::Reg(r) => r.reg_class(),\n+            Self::RegClass(r) => r,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for InlineAsmRegOrRegClass {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Reg(r) => write!(f, \"\\\"{}\\\"\", r.name()),\n+            Self::RegClass(r) => f.write_str(r.name()),\n+        }\n+    }\n+}\n+\n+bitflags::bitflags! {\n+    #[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+    pub struct InlineAsmOptions: u8 {\n+        const PURE = 1 << 0;\n+        const NOMEM = 1 << 1;\n+        const READONLY = 1 << 2;\n+        const PRESERVES_FLAGS = 1 << 3;\n+        const NORETURN = 1 << 4;\n+        const NOSTACK = 1 << 5;\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+pub enum InlineAsmTemplatePiece {\n+    String(String),\n+    Placeholder { operand_idx: usize, modifier: Option<char>, span: Span },\n+}\n+\n+impl fmt::Display for InlineAsmTemplatePiece {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::String(s) => {\n+                for c in s.chars() {\n+                    match c {\n+                        '{' => f.write_str(\"{{\")?,\n+                        '}' => f.write_str(\"}}\")?,\n+                        _ => write!(f, \"{}\", c.escape_debug())?,\n+                    }\n+                }\n+                Ok(())\n+            }\n+            Self::Placeholder { operand_idx, modifier: Some(modifier), .. } => {\n+                write!(f, \"{{{}:{}}}\", operand_idx, modifier)\n+            }\n+            Self::Placeholder { operand_idx, modifier: None, .. } => {\n+                write!(f, \"{{{}}}\", operand_idx)\n+            }\n+        }\n+    }\n+}\n+\n+impl InlineAsmTemplatePiece {\n+    /// Rebuilds the asm template string from its pieces.\n+    pub fn to_string(s: &[Self]) -> String {\n+        use fmt::Write;\n+        let mut out = String::new();\n+        for p in s.iter() {\n+            let _ = write!(out, \"{}\", p);\n+        }\n+        out\n+    }\n+}\n+\n+/// Set of types which can be used with a particular register class.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum InlineAsmType {\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n+    F32,\n+    F64,\n+    VecI8(u64),\n+    VecI16(u64),\n+    VecI32(u64),\n+    VecI64(u64),\n+    VecI128(u64),\n+    VecF32(u64),\n+    VecF64(u64),\n+}\n+\n+impl InlineAsmType {\n+    pub fn is_integer(self) -> bool {\n+        match self {\n+            Self::I8 | Self::I16 | Self::I32 | Self::I64 | Self::I128 => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn size(self) -> Size {\n+        Size::from_bytes(match self {\n+            Self::I8 => 1,\n+            Self::I16 => 2,\n+            Self::I32 => 4,\n+            Self::I64 => 8,\n+            Self::I128 => 16,\n+            Self::F32 => 4,\n+            Self::F64 => 8,\n+            Self::VecI8(n) => n * 1,\n+            Self::VecI16(n) => n * 2,\n+            Self::VecI32(n) => n * 4,\n+            Self::VecI64(n) => n * 8,\n+            Self::VecI128(n) => n * 16,\n+            Self::VecF32(n) => n * 4,\n+            Self::VecF64(n) => n * 8,\n+        })\n+    }\n+}\n+\n+impl fmt::Display for InlineAsmType {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            Self::I8 => f.write_str(\"i8\"),\n+            Self::I16 => f.write_str(\"i16\"),\n+            Self::I32 => f.write_str(\"i32\"),\n+            Self::I64 => f.write_str(\"i64\"),\n+            Self::I128 => f.write_str(\"i128\"),\n+            Self::F32 => f.write_str(\"f32\"),\n+            Self::F64 => f.write_str(\"f64\"),\n+            Self::VecI8(n) => write!(f, \"i8x{}\", n),\n+            Self::VecI16(n) => write!(f, \"i16x{}\", n),\n+            Self::VecI32(n) => write!(f, \"i32x{}\", n),\n+            Self::VecI64(n) => write!(f, \"i64x{}\", n),\n+            Self::VecI128(n) => write!(f, \"i128x{}\", n),\n+            Self::VecF32(n) => write!(f, \"f32x{}\", n),\n+            Self::VecF64(n) => write!(f, \"f64x{}\", n),\n+        }\n+    }\n+}\n+\n+/// Returns the full set of allocatable registers for a given architecture.\n+///\n+/// The registers are structured as a map containing the set of allocatable\n+/// registers in each register class. A particular register may be allocatable\n+/// from multiple register classes, in which case it will appear multiple times\n+/// in the map.\n+pub fn allocatable_registers(\n+    arch: InlineAsmArch,\n+    has_feature: impl FnMut(&str) -> bool,\n+) -> FxHashMap<InlineAsmRegClass, FxHashSet<InlineAsmReg>> {\n+    match arch {\n+        InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n+            let mut map = x86::regclass_map();\n+            x86::fill_reg_map(arch, has_feature, &mut map);\n+            map\n+        }\n+        InlineAsmArch::Arm => {\n+            let mut map = arm::regclass_map();\n+            arm::fill_reg_map(arch, has_feature, &mut map);\n+            map\n+        }\n+        InlineAsmArch::AArch64 => {\n+            let mut map = aarch64::regclass_map();\n+            aarch64::fill_reg_map(arch, has_feature, &mut map);\n+            map\n+        }\n+        InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n+            let mut map = riscv::regclass_map();\n+            riscv::fill_reg_map(arch, has_feature, &mut map);\n+            map\n+        }\n+    }\n+}"}, {"sha": "c57e277c0cd052f85a9fa431ab41a6ebeb7cfe98", "filename": "src/librustc_target/asm/riscv.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/989edf6dd908408723003539583643d11cd5b459/src%2Flibrustc_target%2Fasm%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989edf6dd908408723003539583643d11cd5b459/src%2Flibrustc_target%2Fasm%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Friscv.rs?ref=989edf6dd908408723003539583643d11cd5b459", "patch": "@@ -0,0 +1,140 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    RiscV RiscVInlineAsmRegClass {\n+        reg,\n+        freg,\n+    }\n+}\n+\n+impl RiscVInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str, Option<&'static str>)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg => {\n+                if arch == InlineAsmArch::RiscV64 {\n+                    types! { _: I8, I16, I32, I64, F32, F64; }\n+                } else {\n+                    types! { _: I8, I16, I32, F32; }\n+                }\n+            }\n+            Self::freg => types! { \"f\": F32; \"d\": F64; },\n+        }\n+    }\n+}\n+\n+fn not_e(\n+    _arch: InlineAsmArch,\n+    mut has_feature: impl FnMut(&str) -> bool,\n+) -> Result<(), &'static str> {\n+    if has_feature(\"e\") {\n+        Err(\"register can't be used with the `e` target feature\")\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+def_regs! {\n+    RiscV RiscVInlineAsmReg RiscVInlineAsmRegClass {\n+        x1: reg = [\"x1\", \"ra\"],\n+        x5: reg = [\"x5\", \"t0\"],\n+        x6: reg = [\"x6\", \"t1\"],\n+        x7: reg = [\"x7\", \"t2\"],\n+        x9: reg = [\"x9\", \"s1\"],\n+        x10: reg = [\"x10\", \"a0\"],\n+        x11: reg = [\"x11\", \"a1\"],\n+        x12: reg = [\"x12\", \"a2\"],\n+        x13: reg = [\"x13\", \"a3\"],\n+        x14: reg = [\"x14\", \"a4\"],\n+        x15: reg = [\"x15\", \"a5\"],\n+        x16: reg = [\"x16\", \"a6\"] % not_e,\n+        x17: reg = [\"x17\", \"a7\"] % not_e,\n+        x18: reg = [\"x18\", \"s2\"] % not_e,\n+        x19: reg = [\"x19\", \"s3\"] % not_e,\n+        x20: reg = [\"x20\", \"s4\"] % not_e,\n+        x21: reg = [\"x21\", \"s5\"] % not_e,\n+        x22: reg = [\"x22\", \"s6\"] % not_e,\n+        x23: reg = [\"x23\", \"s7\"] % not_e,\n+        x24: reg = [\"x24\", \"s8\"] % not_e,\n+        x25: reg = [\"x25\", \"s9\"] % not_e,\n+        x26: reg = [\"x26\", \"s10\"] % not_e,\n+        x27: reg = [\"x27\", \"s11\"] % not_e,\n+        x28: reg = [\"x28\", \"t3\"] % not_e,\n+        x29: reg = [\"x29\", \"t4\"] % not_e,\n+        x30: reg = [\"x30\", \"t5\"] % not_e,\n+        x31: reg = [\"x31\", \"t6\"] % not_e,\n+        f0: freg = [\"f0\", \"ft0\"],\n+        f1: freg = [\"f1\", \"ft1\"],\n+        f2: freg = [\"f2\", \"ft2\"],\n+        f3: freg = [\"f3\", \"ft3\"],\n+        f4: freg = [\"f4\", \"ft4\"],\n+        f5: freg = [\"f5\", \"ft5\"],\n+        f6: freg = [\"f6\", \"ft6\"],\n+        f7: freg = [\"f7\", \"ft7\"],\n+        f8: freg = [\"f8\", \"fs0\"],\n+        f9: freg = [\"f9\", \"fs1\"],\n+        f10: freg = [\"f10\", \"fa0\"],\n+        f11: freg = [\"f11\", \"fa1\"],\n+        f12: freg = [\"f12\", \"fa2\"],\n+        f13: freg = [\"f13\", \"fa3\"],\n+        f14: freg = [\"f14\", \"fa4\"],\n+        f15: freg = [\"f15\", \"fa5\"],\n+        f16: freg = [\"f16\", \"fa6\"],\n+        f17: freg = [\"f17\", \"fa7\"],\n+        f18: freg = [\"f18\", \"fs2\"],\n+        f19: freg = [\"f19\", \"fs3\"],\n+        f20: freg = [\"f20\", \"fs4\"],\n+        f21: freg = [\"f21\", \"fs5\"],\n+        f22: freg = [\"f22\", \"fs6\"],\n+        f23: freg = [\"f23\", \"fs7\"],\n+        f24: freg = [\"f24\", \"fs8\"],\n+        f25: freg = [\"f25\", \"fs9\"],\n+        f26: freg = [\"f26\", \"fs10\"],\n+        f27: freg = [\"f27\", \"fs11\"],\n+        f28: freg = [\"f28\", \"ft8\"],\n+        f29: freg = [\"f29\", \"ft9\"],\n+        f30: freg = [\"f30\", \"ft10\"],\n+        f31: freg = [\"f31\", \"ft11\"],\n+        \"the frame pointer cannot be used as an operand for inline asm\" =\n+            [\"x8\", \"s0\", \"fp\"],\n+        \"the stack pointer cannot be used as an operand for inline asm\" =\n+            [\"x2\", \"sp\"],\n+        \"the global pointer cannot be used as an operand for inline asm\" =\n+            [\"x3\", \"gp\"],\n+        \"the thread pointer cannot be used as an operand for inline asm\" =\n+            [\"x4\", \"tp\"],\n+        \"the zero register cannot be used as an operand for inline asm\" =\n+            [\"x0\", \"zero\"],\n+    }\n+}\n+\n+impl RiscVInlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        _modifier: Option<char>,\n+    ) -> fmt::Result {\n+        out.write_str(self.name())\n+    }\n+}"}, {"sha": "7193b1ca8b6365347a803bce6e710f4326610083", "filename": "src/librustc_target/asm/x86.rs", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/989edf6dd908408723003539583643d11cd5b459/src%2Flibrustc_target%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989edf6dd908408723003539583643d11cd5b459/src%2Flibrustc_target%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fx86.rs?ref=989edf6dd908408723003539583643d11cd5b459", "patch": "@@ -0,0 +1,338 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    X86 X86InlineAsmRegClass {\n+        reg,\n+        reg_abcd,\n+        xmm_reg,\n+        ymm_reg,\n+        zmm_reg,\n+        kreg,\n+    }\n+}\n+\n+impl X86InlineAsmRegClass {\n+    pub fn valid_modifiers(self, arch: super::InlineAsmArch) -> &'static [char] {\n+        match self {\n+            Self::reg => {\n+                if arch == InlineAsmArch::X86_64 {\n+                    &['l', 'h', 'x', 'e', 'r']\n+                } else {\n+                    &['x', 'e']\n+                }\n+            }\n+            Self::reg_abcd => {\n+                if arch == InlineAsmArch::X86_64 {\n+                    &['l', 'h', 'x', 'e', 'r']\n+                } else {\n+                    &['l', 'h', 'x', 'e']\n+                }\n+            }\n+            Self::xmm_reg | Self::ymm_reg | Self::zmm_reg => &['x', 'y', 'z'],\n+            Self::kreg => &[],\n+        }\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        arch: InlineAsmArch,\n+        ty: InlineAsmType,\n+    ) -> Option<(char, &'static str, Option<&'static str>)> {\n+        match self {\n+            Self::reg => match ty.size().bits() {\n+                8 => {\n+                    if arch == InlineAsmArch::X86_64 {\n+                        Some(('l', \"al\", None))\n+                    } else {\n+                        // Low byte registers require reg_abcd on x86 so we emit\n+                        // a suggestion to use that register class instead.\n+                        Some(('l', \"al\", Some(\"reg_abcd\")))\n+                    }\n+                }\n+                16 => Some(('x', \"ax\", None)),\n+                32 if arch == InlineAsmArch::X86_64 => Some(('e', \"eax\", None)),\n+                _ => None,\n+            },\n+            Self::reg_abcd => match ty.size().bits() {\n+                8 => Some(('l', \"al\", None)),\n+                16 => Some(('x', \"ax\", None)),\n+                32 if arch == InlineAsmArch::X86_64 => Some(('e', \"eax\", None)),\n+                _ => None,\n+            },\n+            Self::xmm_reg => None,\n+            Self::ymm_reg => {\n+                if ty.size().bits() <= 128 {\n+                    Some(('x', \"xmm0\", None))\n+                } else {\n+                    None\n+                }\n+            }\n+            Self::zmm_reg => match ty.size().bits() {\n+                256 => Some(('y', \"ymm0\", None)),\n+                512 => None,\n+                _ => Some(('x', \"xmm0\", None)),\n+            },\n+            Self::kreg => None,\n+        }\n+    }\n+\n+    pub fn default_modifier(self, arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        match self {\n+            Self::reg | Self::reg_abcd => {\n+                if arch == InlineAsmArch::X86_64 {\n+                    Some(('r', \"rax\"))\n+                } else {\n+                    Some(('e', \"eax\"))\n+                }\n+            }\n+            Self::xmm_reg => Some(('x', \"xmm0\")),\n+            Self::ymm_reg => Some(('y', \"ymm0\")),\n+            Self::zmm_reg => Some(('z', \"zmm0\")),\n+            Self::kreg => None,\n+        }\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg | Self::reg_abcd => {\n+                if arch == InlineAsmArch::X86_64 {\n+                    types! { _: I8, I16, I32, I64, F32, F64; }\n+                } else {\n+                    types! { _: I8, I16, I32, F32; }\n+                }\n+            }\n+            Self::xmm_reg => types! {\n+                \"sse\": I32, I64, F32, F64,\n+                VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2);\n+            },\n+            Self::ymm_reg => types! {\n+                \"avx\": I32, I64, F32, F64,\n+                VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2),\n+                VecI8(32), VecI16(16), VecI32(8), VecI64(4), VecF32(8), VecF64(4);\n+            },\n+            Self::zmm_reg => types! {\n+                \"avx512f\": I32, I64, F32, F64,\n+                VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2),\n+                VecI8(32), VecI16(16), VecI32(8), VecI64(4), VecF32(8), VecF64(4),\n+                VecI8(64), VecI16(32), VecI32(16), VecI64(8), VecF32(16), VecF64(8);\n+            },\n+            Self::kreg => types! {\n+                \"avx512f\": I8, I16;\n+                \"avx512bw\": I32, I64;\n+            },\n+        }\n+    }\n+}\n+\n+fn x86_64_only(\n+    arch: InlineAsmArch,\n+    _has_feature: impl FnMut(&str) -> bool,\n+) -> Result<(), &'static str> {\n+    match arch {\n+        InlineAsmArch::X86 => Err(\"register is only available on x86_64\"),\n+        InlineAsmArch::X86_64 => Ok(()),\n+        _ => unreachable!(),\n+    }\n+}\n+\n+def_regs! {\n+    X86 X86InlineAsmReg X86InlineAsmRegClass {\n+        ax: reg, reg_abcd = [\"ax\", \"al\", \"eax\", \"rax\"],\n+        bx: reg, reg_abcd = [\"bx\", \"bl\", \"ebx\", \"rbx\"],\n+        cx: reg, reg_abcd = [\"cx\", \"cl\", \"ecx\", \"rcx\"],\n+        dx: reg, reg_abcd = [\"dx\", \"dl\", \"edx\", \"rdx\"],\n+        si: reg = [\"si\", \"sil\", \"esi\", \"rsi\"],\n+        di: reg = [\"di\", \"dil\", \"edi\", \"rdi\"],\n+        r8: reg = [\"r8\", \"r8b\", \"r8w\", \"r8d\"] % x86_64_only,\n+        r9: reg = [\"r9\", \"r9b\", \"r9w\", \"r9d\"] % x86_64_only,\n+        r10: reg = [\"r10\", \"r10b\", \"r10w\", \"r10d\"] % x86_64_only,\n+        r11: reg = [\"r11\", \"r11b\", \"r11w\", \"r11d\"] % x86_64_only,\n+        r12: reg = [\"r12\", \"r12b\", \"r12w\", \"r12d\"] % x86_64_only,\n+        r13: reg = [\"r13\", \"r13b\", \"r13w\", \"r13d\"] % x86_64_only,\n+        r14: reg = [\"r14\", \"r14b\", \"r14w\", \"r14d\"] % x86_64_only,\n+        r15: reg = [\"r15\", \"r15b\", \"r15w\", \"r15d\"] % x86_64_only,\n+        xmm0: xmm_reg = [\"xmm0\"],\n+        xmm1: xmm_reg = [\"xmm1\"],\n+        xmm2: xmm_reg = [\"xmm2\"],\n+        xmm3: xmm_reg = [\"xmm3\"],\n+        xmm4: xmm_reg = [\"xmm4\"],\n+        xmm5: xmm_reg = [\"xmm5\"],\n+        xmm6: xmm_reg = [\"xmm6\"],\n+        xmm7: xmm_reg = [\"xmm7\"],\n+        xmm8: xmm_reg = [\"xmm8\"] % x86_64_only,\n+        xmm9: xmm_reg = [\"xmm9\"] % x86_64_only,\n+        xmm10: xmm_reg = [\"xmm10\"] % x86_64_only,\n+        xmm11: xmm_reg = [\"xmm11\"] % x86_64_only,\n+        xmm12: xmm_reg = [\"xmm12\"] % x86_64_only,\n+        xmm13: xmm_reg = [\"xmm13\"] % x86_64_only,\n+        xmm14: xmm_reg = [\"xmm14\"] % x86_64_only,\n+        xmm15: xmm_reg = [\"xmm15\"] % x86_64_only,\n+        ymm0: ymm_reg = [\"ymm0\"],\n+        ymm1: ymm_reg = [\"ymm1\"],\n+        ymm2: ymm_reg = [\"ymm2\"],\n+        ymm3: ymm_reg = [\"ymm3\"],\n+        ymm4: ymm_reg = [\"ymm4\"],\n+        ymm5: ymm_reg = [\"ymm5\"],\n+        ymm6: ymm_reg = [\"ymm6\"],\n+        ymm7: ymm_reg = [\"ymm7\"],\n+        ymm8: ymm_reg = [\"ymm8\"] % x86_64_only,\n+        ymm9: ymm_reg = [\"ymm9\"] % x86_64_only,\n+        ymm10: ymm_reg = [\"ymm10\"] % x86_64_only,\n+        ymm11: ymm_reg = [\"ymm11\"] % x86_64_only,\n+        ymm12: ymm_reg = [\"ymm12\"] % x86_64_only,\n+        ymm13: ymm_reg = [\"ymm13\"] % x86_64_only,\n+        ymm14: ymm_reg = [\"ymm14\"] % x86_64_only,\n+        ymm15: ymm_reg = [\"ymm15\"] % x86_64_only,\n+        zmm0: zmm_reg = [\"zmm0\"],\n+        zmm1: zmm_reg = [\"zmm1\"],\n+        zmm2: zmm_reg = [\"zmm2\"],\n+        zmm3: zmm_reg = [\"zmm3\"],\n+        zmm4: zmm_reg = [\"zmm4\"],\n+        zmm5: zmm_reg = [\"zmm5\"],\n+        zmm6: zmm_reg = [\"zmm6\"],\n+        zmm7: zmm_reg = [\"zmm7\"],\n+        zmm8: zmm_reg = [\"zmm8\"] % x86_64_only,\n+        zmm9: zmm_reg = [\"zmm9\"] % x86_64_only,\n+        zmm10: zmm_reg = [\"zmm10\"] % x86_64_only,\n+        zmm11: zmm_reg = [\"zmm11\"] % x86_64_only,\n+        zmm12: zmm_reg = [\"zmm12\"] % x86_64_only,\n+        zmm13: zmm_reg = [\"zmm13\"] % x86_64_only,\n+        zmm14: zmm_reg = [\"zmm14\"] % x86_64_only,\n+        zmm15: zmm_reg = [\"zmm15\"] % x86_64_only,\n+        zmm16: zmm_reg = [\"zmm16\", \"xmm16\", \"ymm16\"] % x86_64_only,\n+        zmm17: zmm_reg = [\"zmm17\", \"xmm17\", \"ymm17\"] % x86_64_only,\n+        zmm18: zmm_reg = [\"zmm18\", \"xmm18\", \"ymm18\"] % x86_64_only,\n+        zmm19: zmm_reg = [\"zmm19\", \"xmm19\", \"ymm19\"] % x86_64_only,\n+        zmm20: zmm_reg = [\"zmm20\", \"xmm20\", \"ymm20\"] % x86_64_only,\n+        zmm21: zmm_reg = [\"zmm21\", \"xmm21\", \"ymm21\"] % x86_64_only,\n+        zmm22: zmm_reg = [\"zmm22\", \"xmm22\", \"ymm22\"] % x86_64_only,\n+        zmm23: zmm_reg = [\"zmm23\", \"xmm23\", \"ymm23\"] % x86_64_only,\n+        zmm24: zmm_reg = [\"zmm24\", \"xmm24\", \"ymm24\"] % x86_64_only,\n+        zmm25: zmm_reg = [\"zmm25\", \"xmm25\", \"ymm25\"] % x86_64_only,\n+        zmm26: zmm_reg = [\"zmm26\", \"xmm26\", \"ymm26\"] % x86_64_only,\n+        zmm27: zmm_reg = [\"zmm27\", \"xmm27\", \"ymm27\"] % x86_64_only,\n+        zmm28: zmm_reg = [\"zmm28\", \"xmm28\", \"ymm28\"] % x86_64_only,\n+        zmm29: zmm_reg = [\"zmm29\", \"xmm29\", \"ymm29\"] % x86_64_only,\n+        zmm30: zmm_reg = [\"zmm30\", \"xmm30\", \"ymm30\"] % x86_64_only,\n+        zmm31: zmm_reg = [\"zmm31\", \"xmm31\", \"ymm31\"] % x86_64_only,\n+        k1: kreg = [\"k1\"],\n+        k2: kreg = [\"k2\"],\n+        k3: kreg = [\"k3\"],\n+        k4: kreg = [\"k4\"],\n+        k5: kreg = [\"k5\"],\n+        k6: kreg = [\"k6\"],\n+        k7: kreg = [\"k7\"],\n+        \"high byte registers are not currently supported as operands for inline asm\" =\n+            [\"ah\", \"bh\", \"ch\", \"dh\"],\n+        \"the frame pointer cannot be used as an operand for inline asm\" =\n+            [\"bp\", \"bpl\", \"ebp\", \"rbp\"],\n+        \"the stack pointer cannot be used as an operand for inline asm\" =\n+            [\"sp\", \"spl\", \"esp\", \"rsp\"],\n+        \"the instruction pointer cannot be used as an operand for inline asm\" =\n+            [\"ip\", \"eip\", \"rip\"],\n+        \"x87 registers are not currently supported as operands for inline asm\" =\n+            [\"st\", \"st(0)\", \"st(1)\", \"st(2)\", \"st(3)\", \"st(4)\", \"st(5)\", \"st(6)\", \"st(7)\"],\n+        \"MMX registers are not currently supported as operands for inline asm\" =\n+            [\"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\"],\n+        \"the k0 AVX mask register cannot be used as an operand for inline asm\" = [\"k0\"],\n+    }\n+}\n+\n+impl X86InlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        arch: InlineAsmArch,\n+        modifier: Option<char>,\n+    ) -> fmt::Result {\n+        let reg_default_modifier = match arch {\n+            InlineAsmArch::X86 => 'e',\n+            InlineAsmArch::X86_64 => 'r',\n+            _ => unreachable!(),\n+        };\n+        if self as u32 <= Self::dx as u32 {\n+            let root = ['a', 'b', 'c', 'd'][self as usize - Self::ax as usize];\n+            match modifier.unwrap_or(reg_default_modifier) {\n+                'l' => write!(out, \"{}l\", root),\n+                'h' => write!(out, \"{}h\", root),\n+                'x' => write!(out, \"{}x\", root),\n+                'e' => write!(out, \"e{}x\", root),\n+                'r' => write!(out, \"r{}x\", root),\n+                _ => unreachable!(),\n+            }\n+        } else if self as u32 <= Self::di as u32 {\n+            let root = [\"si\", \"di\"][self as usize - Self::si as usize];\n+            match modifier.unwrap_or(reg_default_modifier) {\n+                'l' => write!(out, \"{}l\", root),\n+                'x' => write!(out, \"{}\", root),\n+                'e' => write!(out, \"e{}\", root),\n+                'r' => write!(out, \"r{}\", root),\n+                _ => unreachable!(),\n+            }\n+        } else if self as u32 <= Self::r15 as u32 {\n+            let index = self as u32 - Self::r8 as u32 + 8;\n+            match modifier.unwrap_or(reg_default_modifier) {\n+                'l' => write!(out, \"r{}b\", index),\n+                'x' => write!(out, \"r{}w\", index),\n+                'e' => write!(out, \"r{}d\", index),\n+                'r' => write!(out, \"r{}\", index),\n+                _ => unreachable!(),\n+            }\n+        } else if self as u32 <= Self::xmm15 as u32 {\n+            let prefix = modifier.unwrap_or('x');\n+            let index = self as u32 - Self::xmm0 as u32;\n+            write!(out, \"{}{}\", prefix, index)\n+        } else if self as u32 <= Self::ymm15 as u32 {\n+            let prefix = modifier.unwrap_or('y');\n+            let index = self as u32 - Self::ymm0 as u32;\n+            write!(out, \"{}{}\", prefix, index)\n+        } else if self as u32 <= Self::zmm31 as u32 {\n+            let prefix = modifier.unwrap_or('z');\n+            let index = self as u32 - Self::zmm0 as u32;\n+            write!(out, \"{}{}\", prefix, index)\n+        } else {\n+            let index = self as u32 - Self::k1 as u32 + 1;\n+            write!(out, \"k{}\", index)\n+        }\n+    }\n+\n+    pub fn overlapping_regs(self, mut cb: impl FnMut(X86InlineAsmReg)) {\n+        macro_rules! reg_conflicts {\n+            ($($x:ident : $y:ident : $z:ident,)*) => {\n+                match self {\n+                    $(\n+                        Self::$x | Self::$y | Self::$z => {\n+                            cb(Self::$x);\n+                            cb(Self::$y);\n+                            cb(Self::$z);\n+                        }\n+                    )*\n+                    r => cb(r),\n+                }\n+            };\n+        }\n+        reg_conflicts! {\n+            xmm0 : ymm0 : zmm0,\n+            xmm1 : ymm1 : zmm1,\n+            xmm2 : ymm2 : zmm2,\n+            xmm3 : ymm3 : zmm3,\n+            xmm4 : ymm4 : zmm4,\n+            xmm5 : ymm5 : zmm5,\n+            xmm6 : ymm6 : zmm6,\n+            xmm7 : ymm7 : zmm7,\n+            xmm8 : ymm8 : zmm8,\n+            xmm9 : ymm9 : zmm9,\n+            xmm10 : ymm10 : zmm10,\n+            xmm11 : ymm11 : zmm11,\n+            xmm12 : ymm12 : zmm12,\n+            xmm13 : ymm13 : zmm13,\n+            xmm14 : ymm14 : zmm14,\n+            xmm15 : ymm15 : zmm15,\n+        }\n+    }\n+}"}, {"sha": "0e634587b4a4aa697648ca60ec22c3b82ebbb47e", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/989edf6dd908408723003539583643d11cd5b459/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989edf6dd908408723003539583643d11cd5b459/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=989edf6dd908408723003539583643d11cd5b459", "patch": "@@ -25,9 +25,10 @@ extern crate rustc_macros;\n extern crate log;\n \n pub mod abi;\n+pub mod asm;\n pub mod spec;\n \n /// Requirements for a `StableHashingContext` to be used in this crate.\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n /// instead of implementing everything in librustc_middle.\n-pub trait HashStableContext {}\n+pub trait HashStableContext: rustc_span::HashStableContext {}"}]}