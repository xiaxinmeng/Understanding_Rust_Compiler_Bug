{"sha": "73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "node_id": "C_kwDOAAsO6NoAKDczZTcyMDdiZmMwZGM0N2Y3YjU0YzgxYzBkMjM1MTM4N2VmNzA4ZmI", "commit": {"author": {"name": "Ulrich Weigand", "email": "ulrich.weigand@de.ibm.com", "date": "2022-12-22T15:40:50Z"}, "committer": {"name": "Ulrich Weigand", "email": "ulrich.weigand@de.ibm.com", "date": "2022-12-27T14:23:15Z"}, "message": "Fix ui constant tests for big-endian platforms\n\nA number of tests under ui/const-ptr and ui/consts are currently\nfailing on big-endian platforms as the binary encoding of some\nconstants is hard-coded in the stderr test files.  Fix this by\nproviding a normalize-stderr-test rule that strips out the\nraw bytes hex dump, so the comparison can be done in an\nendianness-independent manner.  Note that in most cases, this\nmeans the tests are now also independent of word size, so the\n32bit and 64bit cases can be re-unified.\n\nTo keep tests that verify the details of those raw bytes dumps,\na new test case raw-bytes.rs performs the tests where the hex\ndumps were stripped out a second time, but only on little-\nendian platforms.\n\nIn addition, src/test/ui/const-ptr/forbidden_slices.rs exposes\nan endian-specific difference in this diagnostic output:\n   constructing invalid value at .<deref>[0]: encountered 0x11,\n   but expected a boolean\ndepending on which byte of D0 is not a boolean value (0 or 1).\nFixed this by choosing a value of D0 that differs from 0 or 1\nin all bytes.\n\nFixes part of https://github.com/rust-lang/rust/issues/105383.", "tree": {"sha": "008d562d34d44722d0e9cb3142ea5746c7549a32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/008d562d34d44722d0e9cb3142ea5746c7549a32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "html_url": "https://github.com/rust-lang/rust/commit/73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/comments", "author": {"login": "uweigand", "id": 4154057, "node_id": "MDQ6VXNlcjQxNTQwNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4154057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uweigand", "html_url": "https://github.com/uweigand", "followers_url": "https://api.github.com/users/uweigand/followers", "following_url": "https://api.github.com/users/uweigand/following{/other_user}", "gists_url": "https://api.github.com/users/uweigand/gists{/gist_id}", "starred_url": "https://api.github.com/users/uweigand/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uweigand/subscriptions", "organizations_url": "https://api.github.com/users/uweigand/orgs", "repos_url": "https://api.github.com/users/uweigand/repos", "events_url": "https://api.github.com/users/uweigand/events{/privacy}", "received_events_url": "https://api.github.com/users/uweigand/received_events", "type": "User", "site_admin": false}, "committer": {"login": "uweigand", "id": 4154057, "node_id": "MDQ6VXNlcjQxNTQwNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4154057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uweigand", "html_url": "https://github.com/uweigand", "followers_url": "https://api.github.com/users/uweigand/followers", "following_url": "https://api.github.com/users/uweigand/following{/other_user}", "gists_url": "https://api.github.com/users/uweigand/gists{/gist_id}", "starred_url": "https://api.github.com/users/uweigand/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uweigand/subscriptions", "organizations_url": "https://api.github.com/users/uweigand/orgs", "repos_url": "https://api.github.com/users/uweigand/repos", "events_url": "https://api.github.com/users/uweigand/events{/privacy}", "received_events_url": "https://api.github.com/users/uweigand/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d8651a92761421b0437ffb44ba5670bea5ee1df", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d8651a92761421b0437ffb44ba5670bea5ee1df", "html_url": "https://github.com/rust-lang/rust/commit/2d8651a92761421b0437ffb44ba5670bea5ee1df"}], "stats": {"total": 2846, "additions": 1716, "deletions": 1130}, "files": [{"sha": "f4f9fe69516a6a258a1abb022c7c35b5b135d37a", "filename": "src/test/ui/const-ptr/forbidden_slices.64bit.stderr", "status": "removed", "additions": 0, "deletions": 240, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -1,240 +0,0 @@\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-   = note: dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n-   |\n-note: inside `std::slice::from_raw_parts::<'_, u32>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `S0`\n-  --> $DIR/forbidden_slices.rs:18:34\n-   |\n-LL | pub static S0: &[u32] = unsafe { from_raw_parts(ptr::null(), 0) };\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-   = note: dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n-   |\n-note: inside `std::slice::from_raw_parts::<'_, ()>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `S1`\n-  --> $DIR/forbidden_slices.rs:19:33\n-   |\n-LL | pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-   = note: dereferencing pointer failed: allocN has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n-   |\n-note: inside `std::slice::from_raw_parts::<'_, u32>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `S2`\n-  --> $DIR/forbidden_slices.rs:22:34\n-   |\n-LL | pub static S2: &[u32] = unsafe { from_raw_parts(&D0, 2) };\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:25:1\n-   |\n-LL | pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) };\n-   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:27:1\n-   |\n-LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size_of::<&u32>()) };\n-   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:29:1\n-   |\n-LL | pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:32:1\n-   |\n-LL | pub static S7: &[u16] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[1]: encountered uninitialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID+0x2\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-   = note: dereferencing pointer failed: allocN has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n-   |\n-note: inside `std::slice::from_raw_parts::<'_, u64>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `S8`\n-  --> $DIR/forbidden_slices.rs:43:5\n-   |\n-LL |     from_raw_parts(ptr, 1)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-   = note: out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n-   |\n-note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `from_ptr_range::<'_, u32>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `R0`\n-  --> $DIR/forbidden_slices.rs:46:34\n-   |\n-LL | pub static R0: &[u32] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-   = note: the evaluated program panicked at 'assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize', $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-note: inside `ptr::const_ptr::<impl *const ()>::sub_ptr`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `from_ptr_range::<'_, ()>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `R1`\n-  --> $DIR/forbidden_slices.rs:47:33\n-   |\n-LL | pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-   = note: out-of-bounds pointer arithmetic: allocN has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n-   |\n-note: inside `ptr::const_ptr::<impl *const u32>::offset`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u32>::add`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `R2`\n-  --> $DIR/forbidden_slices.rs:50:25\n-   |\n-LL |     from_ptr_range(ptr..ptr.add(2))\n-   |                         ^^^^^^^^^^\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:52:1\n-   |\n-LL | pub static R4: &[u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:57:1\n-   |\n-LL | pub static R5: &[u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:62:1\n-   |\n-LL | pub static R6: &[bool] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-   = note: accessing memory with alignment 1, but alignment 2 is required\n-   |\n-note: inside `std::slice::from_raw_parts::<'_, u16>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `from_ptr_range::<'_, u16>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `R7`\n-  --> $DIR/forbidden_slices.rs:69:5\n-   |\n-LL |     from_ptr_range(ptr..ptr.add(4))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-   = note: out-of-bounds pointer arithmetic: allocN has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n-   |\n-note: inside `ptr::const_ptr::<impl *const u64>::offset`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u64>::add`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `R8`\n-  --> $DIR/forbidden_slices.rs:73:25\n-   |\n-LL |     from_ptr_range(ptr..ptr.add(1))\n-   |                         ^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-   = note: `ptr_offset_from_unsigned` called on pointers into different allocations\n-   |\n-note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `from_ptr_range::<'_, u32>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `R9`\n-  --> $DIR/forbidden_slices.rs:78:34\n-   |\n-LL | pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-   = note: `ptr_offset_from_unsigned` called on pointers into different allocations\n-   |\n-note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `from_ptr_range::<'_, u32>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `R10`\n-  --> $DIR/forbidden_slices.rs:79:35\n-   |\n-LL | pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 18 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "192b6a46de6073d0e84c41064b11e837cdf2700e", "filename": "src/test/ui/const-ptr/forbidden_slices.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.rs?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,5 +1,6 @@\n-// stderr-per-bitwidth\n-// normalize-stderr-test \"\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c\" -> \"\u257eALLOC_ID$2\u257c\"\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n // normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n // error-pattern: could not evaluate static initializer\n #![feature(\n@@ -78,7 +79,7 @@ pub static R8: &[u64] = unsafe {\n pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n \n-const D0: u32 = 0x11;\n+const D0: u32 = 0x11111111; // Constant chosen for endianness-independent behavior.\n const D1: MaybeUninit<&u32> = MaybeUninit::uninit();\n const D2: Struct = Struct { a: 1, b: 2, c: 3, d: 4 };\n const D3: &u32 = &42;"}, {"sha": "b42361872c475daac8ce1360d275246eb6520772", "filename": "src/test/ui/const-ptr/forbidden_slices.stderr", "status": "renamed", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -6,7 +6,7 @@ error[E0080]: could not evaluate static initializer\n note: inside `std::slice::from_raw_parts::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `S0`\n-  --> $DIR/forbidden_slices.rs:18:34\n+  --> $DIR/forbidden_slices.rs:19:34\n    |\n LL | pub static S0: &[u32] = unsafe { from_raw_parts(ptr::null(), 0) };\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -19,7 +19,7 @@ error[E0080]: could not evaluate static initializer\n note: inside `std::slice::from_raw_parts::<'_, ()>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `S1`\n-  --> $DIR/forbidden_slices.rs:19:33\n+  --> $DIR/forbidden_slices.rs:20:33\n    |\n LL | pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -32,54 +32,54 @@ error[E0080]: could not evaluate static initializer\n note: inside `std::slice::from_raw_parts::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `S2`\n-  --> $DIR/forbidden_slices.rs:22:34\n+  --> $DIR/forbidden_slices.rs:23:34\n    |\n LL | pub static S2: &[u32] = unsafe { from_raw_parts(&D0, 2) };\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:25:1\n+  --> $DIR/forbidden_slices.rs:26:1\n    |\n LL | pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) };\n    | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:27:1\n+  --> $DIR/forbidden_slices.rs:28:1\n    |\n LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size_of::<&u32>()) };\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:29:1\n+  --> $DIR/forbidden_slices.rs:30:1\n    |\n LL | pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:32:1\n+  --> $DIR/forbidden_slices.rs:33:1\n    |\n LL | pub static S7: &[u16] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[1]: encountered uninitialized bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID+0x2\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: could not evaluate static initializer\n@@ -90,7 +90,7 @@ error[E0080]: could not evaluate static initializer\n note: inside `std::slice::from_raw_parts::<'_, u64>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `S8`\n-  --> $DIR/forbidden_slices.rs:43:5\n+  --> $DIR/forbidden_slices.rs:44:5\n    |\n LL |     from_raw_parts(ptr, 1)\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n@@ -105,7 +105,7 @@ note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R0`\n-  --> $DIR/forbidden_slices.rs:46:34\n+  --> $DIR/forbidden_slices.rs:47:34\n    |\n LL | pub static R0: &[u32] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -120,7 +120,7 @@ note: inside `ptr::const_ptr::<impl *const ()>::sub_ptr`\n note: inside `from_ptr_range::<'_, ()>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R1`\n-  --> $DIR/forbidden_slices.rs:47:33\n+  --> $DIR/forbidden_slices.rs:48:33\n    |\n LL | pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -136,43 +136,43 @@ note: inside `ptr::const_ptr::<impl *const u32>::offset`\n note: inside `ptr::const_ptr::<impl *const u32>::add`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n note: inside `R2`\n-  --> $DIR/forbidden_slices.rs:50:25\n+  --> $DIR/forbidden_slices.rs:51:25\n    |\n LL |     from_ptr_range(ptr..ptr.add(2))\n    |                         ^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:52:1\n+  --> $DIR/forbidden_slices.rs:53:1\n    |\n LL | pub static R4: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:57:1\n+  --> $DIR/forbidden_slices.rs:58:1\n    |\n LL | pub static R5: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:62:1\n+  --> $DIR/forbidden_slices.rs:63:1\n    |\n LL | pub static R6: &[bool] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: could not evaluate static initializer\n@@ -185,7 +185,7 @@ note: inside `std::slice::from_raw_parts::<'_, u16>`\n note: inside `from_ptr_range::<'_, u16>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R7`\n-  --> $DIR/forbidden_slices.rs:69:5\n+  --> $DIR/forbidden_slices.rs:70:5\n    |\n LL |     from_ptr_range(ptr..ptr.add(4))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -200,7 +200,7 @@ note: inside `ptr::const_ptr::<impl *const u64>::offset`\n note: inside `ptr::const_ptr::<impl *const u64>::add`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n note: inside `R8`\n-  --> $DIR/forbidden_slices.rs:73:25\n+  --> $DIR/forbidden_slices.rs:74:25\n    |\n LL |     from_ptr_range(ptr..ptr.add(1))\n    |                         ^^^^^^^^^^\n@@ -215,7 +215,7 @@ note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R9`\n-  --> $DIR/forbidden_slices.rs:78:34\n+  --> $DIR/forbidden_slices.rs:79:34\n    |\n LL | pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -230,7 +230,7 @@ note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R10`\n-  --> $DIR/forbidden_slices.rs:79:35\n+  --> $DIR/forbidden_slices.rs:80:35\n    |\n LL | pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/const-ptr/forbidden_slices.32bit.stderr"}, {"sha": "91a426580c3cdad9e77e0a06b5794ec8a36f2568", "filename": "src/test/ui/consts/const-eval/raw-bytes.32bit.stderr", "status": "added", "additions": 596, "deletions": 0, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -0,0 +1,596 @@\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:20:1\n+   |\n+LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x00000001, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               01 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:28:1\n+   |\n+LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x00000000, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               00 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:42:1\n+   |\n+LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 1, align: 1) {\n+               01                                              \u2502 .\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:44:1\n+   |\n+LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 1, align: 1) {\n+               03                                              \u2502 .\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:50:1\n+   |\n+LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               78 00 00 00 ff ff ff ff                         \u2502 x.......\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:54:1\n+   |\n+LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               00 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:57:1\n+   |\n+LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 1, align: 1) {\n+               00                                              \u2502 .\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:59:1\n+   |\n+LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               00 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:65:1\n+   |\n+LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 42, but expected something in the range 10..=30\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               2a 00 00 00                                     \u2502 *...\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:71:1\n+   |\n+LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 20, but expected something less or equal to 10, or greater or equal to 30\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               14 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:74:1\n+   |\n+LL | const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               00 00 00 00 \u257eALLOC_ID\u257c                         \u2502 ....\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:82:1\n+   |\n+LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:86:1\n+   |\n+LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned box (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:90:1\n+   |\n+LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null reference\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               00 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:93:1\n+   |\n+LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null box\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               00 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:96:1\n+   |\n+LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               39 05 00 00                                     \u2502 9...\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:99:1\n+   |\n+LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               39 05 00 00                                     \u2502 9...\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:102:1\n+   |\n+LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               00 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:104:1\n+   |\n+LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               0d 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:106:1\n+   |\n+LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a function pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:112:1\n+   |\n+LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type Bar\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               01 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:137:1\n+   |\n+LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:139:1\n+   |\n+LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:141:1\n+   |\n+LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:144:1\n+   |\n+LL | const STR_NO_INIT: &str = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized data in `str`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:146:1\n+   |\n+LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered uninitialized data in `str`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:148:1\n+   |\n+LL | const MYSTR_NO_INIT_ISSUE83182: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:152:1\n+   |\n+LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:154:1\n+   |\n+LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c ff ff ff 7f                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:157:1\n+   |\n+LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:160:1\n+   |\n+LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+           }\n+\n+note: erroneous constant used\n+  --> $DIR/raw-bytes.rs:160:40\n+   |\n+LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:166:1\n+   |\n+LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+           }\n+\n+note: erroneous constant used\n+  --> $DIR/raw-bytes.rs:166:42\n+   |\n+LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:170:1\n+   |\n+LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.1[0]: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+           }\n+\n+note: erroneous constant used\n+  --> $DIR/raw-bytes.rs:170:42\n+   |\n+LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:175:1\n+   |\n+LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:179:1\n+   |\n+LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:183:1\n+   |\n+LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:186:1\n+   |\n+LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:190:1\n+   |\n+LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:194:1\n+   |\n+LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 00 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:196:1\n+   |\n+LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:201:1\n+   |\n+LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x00000000, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               00 10 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:205:1\n+   |\n+LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x00000003, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               09 00 00 00 03 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:209:1\n+   |\n+LL | const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) };\n+   | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type [!; 1]\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               01 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:210:1\n+   |\n+LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) };\n+   | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               01 00 00 00 01 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:211:1\n+   |\n+LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) };\n+   | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               01 00 00 00 2a 00 00 00                         \u2502 ....*...\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:215:1\n+   |\n+LL | pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) };\n+   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:218:1\n+   |\n+LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, mem::size_of::<&u32>()) };\n+   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:221:1\n+   |\n+LL | pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:225:1\n+   |\n+LL | pub static S7: &[u16] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[1]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID+0x2\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:232:1\n+   |\n+LL | pub static R4: &[u8] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:237:1\n+   |\n+LL | pub static R5: &[u8] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:242:1\n+   |\n+LL | pub static R6: &[bool] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error: aborting due to 52 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "e4c5e62f6bd3aab7135bb345e9ddd1cd914ac286", "filename": "src/test/ui/consts/const-eval/raw-bytes.64bit.stderr", "status": "added", "additions": 596, "deletions": 0, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -0,0 +1,596 @@\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:20:1\n+   |\n+LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x0000000000000001, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               01 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:28:1\n+   |\n+LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x0000000000000000, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               00 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:42:1\n+   |\n+LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 1, align: 1) {\n+               01                                              \u2502 .\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:44:1\n+   |\n+LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 1, align: 1) {\n+               03                                              \u2502 .\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:50:1\n+   |\n+LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               78 00 00 00 ff ff ff ff                         \u2502 x.......\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:54:1\n+   |\n+LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               00 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:57:1\n+   |\n+LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 1, align: 1) {\n+               00                                              \u2502 .\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:59:1\n+   |\n+LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               00 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:65:1\n+   |\n+LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 42, but expected something in the range 10..=30\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               2a 00 00 00                                     \u2502 *...\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:71:1\n+   |\n+LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 20, but expected something less or equal to 10, or greater or equal to 30\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               14 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:74:1\n+   |\n+LL | const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               00 00 00 00 00 00 00 00 \u257eALLOC_ID\u257c \u2502 ........\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:82:1\n+   |\n+LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:86:1\n+   |\n+LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned box (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:90:1\n+   |\n+LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null reference\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               00 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:93:1\n+   |\n+LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null box\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               00 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:96:1\n+   |\n+LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               39 05 00 00 00 00 00 00                         \u2502 9.......\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:99:1\n+   |\n+LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               39 05 00 00 00 00 00 00                         \u2502 9.......\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:102:1\n+   |\n+LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               00 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:104:1\n+   |\n+LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               0d 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:106:1\n+   |\n+LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a function pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:112:1\n+   |\n+LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type Bar\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               01 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:137:1\n+   |\n+LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:139:1\n+   |\n+LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:141:1\n+   |\n+LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:144:1\n+   |\n+LL | const STR_NO_INIT: &str = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized data in `str`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:146:1\n+   |\n+LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered uninitialized data in `str`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:148:1\n+   |\n+LL | const MYSTR_NO_INIT_ISSUE83182: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:152:1\n+   |\n+LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:154:1\n+   |\n+LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff 7f \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:157:1\n+   |\n+LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:160:1\n+   |\n+LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+note: erroneous constant used\n+  --> $DIR/raw-bytes.rs:160:40\n+   |\n+LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:166:1\n+   |\n+LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+note: erroneous constant used\n+  --> $DIR/raw-bytes.rs:166:42\n+   |\n+LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:170:1\n+   |\n+LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.1[0]: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+note: erroneous constant used\n+  --> $DIR/raw-bytes.rs:170:42\n+   |\n+LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:175:1\n+   |\n+LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:179:1\n+   |\n+LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:183:1\n+   |\n+LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:186:1\n+   |\n+LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:190:1\n+   |\n+LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:194:1\n+   |\n+LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:196:1\n+   |\n+LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:201:1\n+   |\n+LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x0000000000000000, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:205:1\n+   |\n+LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x0000000000000003, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               09 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00 \u2502 ................\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:209:1\n+   |\n+LL | const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) };\n+   | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type [!; 1]\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               01 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:210:1\n+   |\n+LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) };\n+   | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               01 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 \u2502 ................\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:211:1\n+   |\n+LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) };\n+   | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               01 00 00 00 00 00 00 00 2a 00 00 00 00 00 00 00 \u2502 ........*.......\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:215:1\n+   |\n+LL | pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) };\n+   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:218:1\n+   |\n+LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, mem::size_of::<&u32>()) };\n+   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:221:1\n+   |\n+LL | pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:225:1\n+   |\n+LL | pub static S7: &[u16] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[1]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID+0x2\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:232:1\n+   |\n+LL | pub static R4: &[u8] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:237:1\n+   |\n+LL | pub static R5: &[u8] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:242:1\n+   |\n+LL | pub static R6: &[bool] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error: aborting due to 52 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "6c1238c0a063e138373d32a28dad1ef272a0187b", "filename": "src/test/ui/consts/const-eval/raw-bytes.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.rs?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -0,0 +1,263 @@\n+// stderr-per-bitwidth\n+// ignore-endian-big\n+// ignore-tidy-linelength\n+// normalize-stderr-test \"\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c\" -> \"\u257eALLOC_ID$2\u257c\"\n+// normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n+#![feature(never_type, rustc_attrs, ptr_metadata, slice_from_ptr_range, const_slice_from_ptr_range)]\n+#![allow(invalid_value)]\n+\n+use std::mem;\n+use std::alloc::Layout;\n+use std::ptr::NonNull;\n+use std::num::{NonZeroU8, NonZeroUsize};\n+use std::slice::{from_ptr_range, from_raw_parts};\n+\n+#[repr(usize)]\n+#[derive(Copy, Clone)]\n+enum Enum {\n+    A = 0,\n+}\n+const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n+//~^ ERROR is undefined behavior\n+\n+#[repr(usize)]\n+#[derive(Copy, Clone)]\n+enum Enum2 {\n+    A = 2,\n+}\n+const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n+//~^ ERROR is undefined behavior\n+\n+#[derive(Copy, Clone)]\n+enum Never {}\n+\n+// An enum with 3 variants of which some are uninhabited -- so the uninhabited variants *do*\n+// have a discriminant.\n+enum UninhDiscriminant {\n+    A,\n+    B(!),\n+    C,\n+    D(Never),\n+}\n+const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n+//~^ ERROR is undefined behavior\n+const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n+//~^ ERROR is undefined behavior\n+\n+// Invalid enum field content (mostly to test printing of paths for enum tuple\n+// variants and tuples).\n+// Need to create something which does not clash with enum layout optimizations.\n+const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n+//~^ ERROR is undefined behavior\n+\n+\n+const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n+//~^ ERROR it is undefined behavior to use this value\n+const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+#[rustc_layout_scalar_valid_range_start(10)]\n+#[rustc_layout_scalar_valid_range_end(30)]\n+struct RestrictedRange1(u32);\n+const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+#[rustc_layout_scalar_valid_range_start(30)]\n+#[rustc_layout_scalar_valid_range_end(10)]\n+struct RestrictedRange2(u32);\n+const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n+//~^ ERROR it is undefined behavior to use this value\n+    let x: &dyn Send = &42;\n+    let meta = std::ptr::metadata(x);\n+    mem::transmute((0_usize, meta))\n+};\n+\n+\n+const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n+\n+const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| constructing invalid value: encountered an unaligned box (required 2 byte alignment but found 1)\n+\n+const NULL: &u16 = unsafe { mem::transmute(0usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+#[derive(Copy, Clone)]\n+enum Bar {}\n+\n+const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+\n+/// A newtype wrapper to prevent MIR generation from inserting reborrows that would affect the error\n+/// message.\n+#[repr(transparent)]\n+struct W<T>(T);\n+\n+#[repr(C)]\n+union MaybeUninit<T: Copy> {\n+    uninit: (),\n+    init: T,\n+}\n+\n+trait Trait {}\n+impl Trait for bool {}\n+\n+// custom unsized type\n+struct MyStr(str);\n+\n+// custom unsized type with sized fields\n+struct MySlice<T: ?Sized>(bool, T);\n+type MySliceBool = MySlice<[bool]>;\n+\n+const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n+//~^ ERROR it is undefined behavior to use this value\n+const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n+//~^ ERROR it is undefined behavior to use this value\n+const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const STR_NO_INIT: &str = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n+//~^ ERROR it is undefined behavior to use this value\n+const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n+//~^ ERROR it is undefined behavior to use this value\n+const MYSTR_NO_INIT_ISSUE83182: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n+//~^ ERROR: it is undefined behavior to use this value\n+\n+// # slice\n+const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n+//~^ ERROR it is undefined behavior to use this value\n+const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n+//~^ ERROR it is undefined behavior to use this value\n+// bad slice box: length too big\n+const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n+//~^ ERROR it is undefined behavior to use this value\n+// bad data *inside* the slice\n+const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+//~^ ERROR it is undefined behavior to use this value\n+//~| constant\n+\n+\n+// bad: sized field is not okay\n+const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+//~^ ERROR it is undefined behavior to use this value\n+//~| constant\n+// bad: unsized part is not okay\n+const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+//~^ ERROR it is undefined behavior to use this value\n+//~| constant\n+\n+// bad trait object\n+const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable\n+// bad trait object\n+const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable\n+// bad trait object\n+const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable\n+const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable\n+// bad data *inside* the trait object\n+const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| expected a boolean\n+\n+const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n+//~^ ERROR it is undefined behavior to use this value\n+const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+\n+// not ok, since alignment needs to be non-zero.\n+const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+// not ok, since alignment needs to be a power of two.\n+const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+\n+const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) }; //~ ERROR undefined behavior\n+const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) }; //~ ERROR undefined behavior\n+const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) }; //~ ERROR undefined behavior\n+\n+\n+// Reading uninitialized  data\n+pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) };\n+//~^ ERROR: it is undefined behavior to use this value\n+// Reinterpret pointers as integers (UB in CTFE.)\n+pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, mem::size_of::<&u32>()) };\n+//~^ ERROR: it is undefined behavior to use this value\n+// Layout mismatch\n+pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n+//~^ ERROR: it is undefined behavior to use this value\n+\n+// Reading padding is not ok\n+pub static S7: &[u16] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = (&D2 as *const Struct as *const u16).add(1);\n+\n+    from_raw_parts(ptr, 4)\n+};\n+\n+pub static R4: &[u8] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = (&D1) as *const mem::MaybeUninit<&u32> as *const u8;\n+    from_ptr_range(ptr..ptr.add(1))\n+};\n+pub static R5: &[u8] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = &D3 as *const &u32;\n+    from_ptr_range(ptr.cast()..ptr.add(1).cast())\n+};\n+pub static R6: &[bool] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = &D0 as *const u32 as *const bool;\n+    from_ptr_range(ptr..ptr.add(4))\n+};\n+\n+const D0: u32 = 0x11111111; // Constant chosen for endianness-independent behavior.\n+const D1: mem::MaybeUninit<&u32> = mem::MaybeUninit::uninit();\n+const D2: Struct = Struct { a: 1, b: 2, c: 3, d: 4 };\n+const D3: &u32 = &42;\n+\n+#[repr(C)]\n+struct Struct {\n+    a: u8,\n+    // _pad: [mem::MaybeUninit<u8>; 3]\n+    b: u32,\n+    c: u16,\n+    d: u8,\n+    // _pad: [mem::MaybeUninit<u8>; 1]\n+}\n+\n+fn main() {}"}, {"sha": "2d86bd88f1c8834dd05b0fe7c86ac59bfc6fd07e", "filename": "src/test/ui/consts/const-eval/ub-enum.32bit.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,16 +1,16 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:24:1\n+  --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n    | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x00000001, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               01 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:27:1\n+  --> $DIR/ub-enum.rs:30:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -19,7 +19,7 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:30:1\n+  --> $DIR/ub-enum.rs:33:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -28,18 +28,18 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:42:1\n+  --> $DIR/ub-enum.rs:45:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x00000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               00 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:44:1\n+  --> $DIR/ub-enum.rs:47:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -48,7 +48,7 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:47:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -57,13 +57,13 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:56:42\n+  --> $DIR/ub-enum.rs:59:42\n    |\n LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:61:1\n+  --> $DIR/ub-enum.rs:64:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -72,46 +72,46 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:78:1\n+  --> $DIR/ub-enum.rs:81:1\n    |\n LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               01                                              \u2502 .\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:80:1\n+  --> $DIR/ub-enum.rs:83:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               03                                              \u2502 .\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:88:1\n+  --> $DIR/ub-enum.rs:91:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               78 00 00 00 ff ff ff ff                         \u2502 x.......\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:93:77\n+  --> $DIR/ub-enum.rs:96:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:95:77\n+  --> $DIR/ub-enum.rs:98:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type"}, {"sha": "a89d7ec5f6d44cb7824d0d7d7ab4aa783231c7f3", "filename": "src/test/ui/consts/const-eval/ub-enum.64bit.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,16 +1,16 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:24:1\n+  --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n    | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x0000000000000001, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               01 00 00 00 00 00 00 00                         \u2502 ........\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:27:1\n+  --> $DIR/ub-enum.rs:30:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -19,7 +19,7 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:30:1\n+  --> $DIR/ub-enum.rs:33:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -28,18 +28,18 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:42:1\n+  --> $DIR/ub-enum.rs:45:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x0000000000000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:44:1\n+  --> $DIR/ub-enum.rs:47:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -48,7 +48,7 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:47:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -57,13 +57,13 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:56:42\n+  --> $DIR/ub-enum.rs:59:42\n    |\n LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:61:1\n+  --> $DIR/ub-enum.rs:64:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -72,46 +72,46 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:78:1\n+  --> $DIR/ub-enum.rs:81:1\n    |\n LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               01                                              \u2502 .\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:80:1\n+  --> $DIR/ub-enum.rs:83:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               03                                              \u2502 .\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:88:1\n+  --> $DIR/ub-enum.rs:91:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               78 00 00 00 ff ff ff ff                         \u2502 x.......\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:93:77\n+  --> $DIR/ub-enum.rs:96:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:95:77\n+  --> $DIR/ub-enum.rs:98:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type"}, {"sha": "8f26d9a00d71bf5dee97997dd6177e415e49ba54", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,4 +1,7 @@\n // stderr-per-bitwidth\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n #![feature(never_type)]\n #![allow(invalid_value)]\n "}, {"sha": "92b8d017c0b77e404b5a63a4f5166e6d1a3f1686", "filename": "src/test/ui/consts/const-eval/ub-nonnull.64bit.stderr", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -1,81 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:12:1\n-   |\n-LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-nonnull.rs:18:30\n-   |\n-LL |     let out_of_bounds_ptr = &ptr[255];\n-   |                              ^^^^^^^^ dereferencing pointer failed: alloc11 has size 1, so pointer to 256 bytes starting at offset 0 is out-of-bounds\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:22:1\n-   |\n-LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               00                                              \u2502 .\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:24:1\n-   |\n-LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-nonnull.rs:32:36\n-   |\n-LL | const UNINIT: NonZeroU8 = unsafe { MaybeUninit { uninit: () }.init };\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:41:1\n-   |\n-LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 42, but expected something in the range 10..=30\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               2a 00 00 00                                     \u2502 *...\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:47:1\n-   |\n-LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 20, but expected something less or equal to 10, or greater or equal to 30\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               14 00 00 00                                     \u2502 ....\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:50:1\n-   |\n-LL | const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               00 00 00 00 00 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc26\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ........\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error: aborting due to 8 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "a64b3a74cf6c0c0145165a50a3f280a88b39d4fc", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,4 +1,6 @@\n-// stderr-per-bitwidth\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n #![feature(rustc_attrs, ptr_metadata)]\n #![allow(invalid_value)] // make sure we cannot allow away the errors tested here\n "}, {"sha": "9616487080459a66e2d105c5c9ce424e8e89ae20", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "renamed", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,79 +1,79 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:12:1\n+  --> $DIR/ub-nonnull.rs:14:1\n    |\n LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               00 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-nonnull.rs:18:30\n+  --> $DIR/ub-nonnull.rs:20:30\n    |\n LL |     let out_of_bounds_ptr = &ptr[255];\n    |                              ^^^^^^^^ dereferencing pointer failed: alloc11 has size 1, so pointer to 256 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:22:1\n+  --> $DIR/ub-nonnull.rs:24:1\n    |\n LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               00                                              \u2502 .\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:24:1\n+  --> $DIR/ub-nonnull.rs:26:1\n    |\n LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               00 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-nonnull.rs:32:36\n+  --> $DIR/ub-nonnull.rs:34:36\n    |\n LL | const UNINIT: NonZeroU8 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:41:1\n+  --> $DIR/ub-nonnull.rs:43:1\n    |\n LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 42, but expected something in the range 10..=30\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               2a 00 00 00                                     \u2502 *...\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:47:1\n+  --> $DIR/ub-nonnull.rs:49:1\n    |\n LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 20, but expected something less or equal to 10, or greater or equal to 30\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               14 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:50:1\n+  --> $DIR/ub-nonnull.rs:52:1\n    |\n LL | const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               00 00 00 00 \u257e\u2500alloc26\u2500\u257c                         \u2502 ....\u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error: aborting due to 8 previous errors", "previous_filename": "src/test/ui/consts/const-eval/ub-nonnull.32bit.stderr"}, {"sha": "d53b44671e3f48eb53a2c6f1c3a085cb95b92d7b", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -1,186 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:14:1\n-   |\n-LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:18:1\n-   |\n-LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned box (required 2 byte alignment but found 1)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:22:1\n-   |\n-LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null reference\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:25:1\n-   |\n-LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null box\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:32:1\n-   |\n-LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:35:39\n-   |\n-LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n-   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-note: erroneous constant used\n-  --> $DIR/ub-ref-ptr.rs:35:38\n-   |\n-LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n-   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:38:86\n-   |\n-LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n-   |                                                                                      ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-note: erroneous constant used\n-  --> $DIR/ub-ref-ptr.rs:38:85\n-   |\n-LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n-   |                                                                                     ^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:41:1\n-   |\n-LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               39 05 00 00 00 00 00 00                         \u2502 9.......\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:44:1\n-   |\n-LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               39 05 00 00 00 00 00 00                         \u2502 9.......\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:47:41\n-   |\n-LL | const UNINIT_PTR: *const i32 = unsafe { MaybeUninit { uninit: () }.init };\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:51:1\n-   |\n-LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:53:38\n-   |\n-LL | const UNINIT_FN_PTR: fn() = unsafe { MaybeUninit { uninit: () }.init };\n-   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:56:1\n-   |\n-LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               0d 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:58:1\n-   |\n-LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered alloc41, but expected a function pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc41\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error: accessing memory with alignment 1, but alignment 4 is required\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n-note: inside `std::ptr::read::<u32>`\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u32>::read`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:65:5\n-   |\n-LL |     ptr.read();\n-   |     ^^^^^^^^^^\n-   = note: `#[deny(invalid_alignment)]` on by default\n-\n-error: aborting due to 15 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`.\n-Future incompatibility report: Future breakage diagnostic:\n-error: accessing memory with alignment 1, but alignment 4 is required\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n-note: inside `std::ptr::read::<u32>`\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u32>::read`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:65:5\n-   |\n-LL |     ptr.read();\n-   |     ^^^^^^^^^^\n-   = note: `#[deny(invalid_alignment)]` on by default\n-"}, {"sha": "369e4519407fd24f647f27fe28a51195d3e2b068", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.rs?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,5 +1,7 @@\n // ignore-tidy-linelength\n-// stderr-per-bitwidth\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n #![allow(invalid_value)]\n #![feature(const_ptr_read)]\n "}, {"sha": "ce618802bd2c62e1531b41b506d0fd6e0bf49d27", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.stderr", "status": "renamed", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,49 +1,49 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:14:1\n+  --> $DIR/ub-ref-ptr.rs:16:1\n    |\n LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n    | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc3\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:18:1\n+  --> $DIR/ub-ref-ptr.rs:20:1\n    |\n LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned box (required 2 byte alignment but found 1)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc7\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:22:1\n+  --> $DIR/ub-ref-ptr.rs:24:1\n    |\n LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               00 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:25:1\n+  --> $DIR/ub-ref-ptr.rs:27:1\n    |\n LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null box\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               00 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:32:1\n+  --> $DIR/ub-ref-ptr.rs:34:1\n    |\n LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -52,7 +52,7 @@ LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:35:39\n+  --> $DIR/ub-ref-ptr.rs:37:39\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -61,13 +61,13 @@ LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n note: erroneous constant used\n-  --> $DIR/ub-ref-ptr.rs:35:38\n+  --> $DIR/ub-ref-ptr.rs:37:38\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:38:86\n+  --> $DIR/ub-ref-ptr.rs:40:86\n    |\n LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n    |                                                                                      ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -76,76 +76,76 @@ LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[us\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n note: erroneous constant used\n-  --> $DIR/ub-ref-ptr.rs:38:85\n+  --> $DIR/ub-ref-ptr.rs:40:85\n    |\n LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n    |                                                                                     ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:41:1\n+  --> $DIR/ub-ref-ptr.rs:43:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               39 05 00 00                                     \u2502 9...\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:44:1\n+  --> $DIR/ub-ref-ptr.rs:46:1\n    |\n LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               39 05 00 00                                     \u2502 9...\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:47:41\n+  --> $DIR/ub-ref-ptr.rs:49:41\n    |\n LL | const UNINIT_PTR: *const i32 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:51:1\n+  --> $DIR/ub-ref-ptr.rs:53:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               00 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:53:38\n+  --> $DIR/ub-ref-ptr.rs:55:38\n    |\n LL | const UNINIT_FN_PTR: fn() = unsafe { MaybeUninit { uninit: () }.init };\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:56:1\n+  --> $DIR/ub-ref-ptr.rs:58:1\n    |\n LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               0d 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:58:1\n+  --> $DIR/ub-ref-ptr.rs:60:1\n    |\n LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered alloc41, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc41\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error: accessing memory with alignment 1, but alignment 4 is required\n@@ -158,7 +158,7 @@ note: inside `std::ptr::read::<u32>`\n note: inside `ptr::const_ptr::<impl *const u32>::read`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:65:5\n+  --> $DIR/ub-ref-ptr.rs:67:5\n    |\n LL |     ptr.read();\n    |     ^^^^^^^^^^\n@@ -178,7 +178,7 @@ note: inside `std::ptr::read::<u32>`\n note: inside `ptr::const_ptr::<impl *const u32>::read`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:65:5\n+  --> $DIR/ub-ref-ptr.rs:67:5\n    |\n LL |     ptr.read();\n    |     ^^^^^^^^^^", "previous_filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr"}, {"sha": "2b7659f5d107e8ab9471aa0c48dca935591fc2ce", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.64bit.stderr", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.64bit.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -1,32 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:14:1\n-   |\n-LL | const BAD_BAD_BAD: Bar = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Bar\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:17:1\n-   |\n-LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type Bar\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               01 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:20:1\n-   |\n-LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered a value of uninhabited type Bar\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "4c4ef216d8628b69a34ccd6a7b7690fe2038541b", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,4 +1,6 @@\n-// stderr-per-bitwidth\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n \n use std::mem;\n "}, {"sha": "0ae376d03fc37ee23db3f4414896ce840511eebe", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.stderr", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,31 +1,31 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:14:1\n+  --> $DIR/ub-uninhabit.rs:16:1\n    |\n LL | const BAD_BAD_BAD: Bar = unsafe { MaybeUninit { uninit: () }.init };\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Bar\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {}\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:17:1\n+  --> $DIR/ub-uninhabit.rs:19:1\n    |\n LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type Bar\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               01 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:20:1\n+  --> $DIR/ub-uninhabit.rs:22:1\n    |\n LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { MaybeUninit { uninit: () }.init };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered a value of uninhabited type Bar\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {}\n \n error: aborting due to 3 previous errors\n ", "previous_filename": "src/test/ui/consts/const-eval/ub-uninhabit.32bit.stderr"}, {"sha": "ab25303ddc0cf611df2a306a549d4fde936f52e0", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.64bit.stderr", "status": "removed", "additions": 0, "deletions": 297, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -1,297 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:37:1\n-   |\n-LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:39:1\n-   |\n-LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid reference metadata: slice is bigger than largest supported object\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:42:1\n-   |\n-LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:45:1\n-   |\n-LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:47:1\n-   |\n-LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:51:1\n-   |\n-LL | const STR_NO_INIT: &str = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized data in `str`\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:54:1\n-   |\n-LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered uninitialized data in `str`\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:61:1\n-   |\n-LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:68:1\n-   |\n-LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:71:1\n-   |\n-LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff 7f \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:74:1\n-   |\n-LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:77:1\n-   |\n-LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (going beyond the bounds of its allocation)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:80:1\n-   |\n-LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:84:1\n-   |\n-LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x03, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:84:40\n-   |\n-LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n-   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:91:1\n-   |\n-LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered 0x03, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:91:42\n-   |\n-LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:95:1\n-   |\n-LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.1[0]: encountered 0x03, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:95:42\n-   |\n-LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:103:1\n-   |\n-LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:112:1\n-   |\n-LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:116:1\n-   |\n-LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:120:1\n-   |\n-LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:123:57\n-   |\n-LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n-   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:126:57\n-   |\n-LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n-   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:129:56\n-   |\n-LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n-   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:132:1\n-   |\n-LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:137:1\n-   |\n-LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:142:1\n-   |\n-LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:144:1\n-   |\n-LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:150:5\n-   |\n-LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:154:5\n-   |\n-LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n-\n-error: aborting due to 29 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "a765dc71273d735c9c7b5cc1065f3da16d3e4339", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,10 +1,11 @@\n-// stderr-per-bitwidth\n // ignore-tidy-linelength\n #![allow(unused)]\n \n use std::mem;\n \n-// normalize-stderr-test \"\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c\" -> \"\u257eALLOC_ID$2\u257c\"\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n // normalize-stderr-test \"offset \\d+\" -> \"offset N\"\n // normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n // normalize-stderr-test \"size \\d+\" -> \"size N\""}, {"sha": "f38e7916b75530fb145380898775fe15b81076f0", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "renamed", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,27 +1,27 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:37:1\n+  --> $DIR/ub-wide-ptr.rs:38:1\n    |\n LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:39:1\n+  --> $DIR/ub-wide-ptr.rs:40:1\n    |\n LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:42:1\n+  --> $DIR/ub-wide-ptr.rs:43:1\n    |\n LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -30,7 +30,7 @@ LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:45:1\n+  --> $DIR/ub-wide-ptr.rs:46:1\n    |\n LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -39,68 +39,68 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:47:1\n+  --> $DIR/ub-wide-ptr.rs:48:1\n    |\n LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:51:1\n+  --> $DIR/ub-wide-ptr.rs:52:1\n    |\n LL | const STR_NO_INIT: &str = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized data in `str`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:54:1\n+  --> $DIR/ub-wide-ptr.rs:55:1\n    |\n LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered uninitialized data in `str`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:61:1\n+  --> $DIR/ub-wide-ptr.rs:62:1\n    |\n LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:68:1\n+  --> $DIR/ub-wide-ptr.rs:69:1\n    |\n LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:71:1\n+  --> $DIR/ub-wide-ptr.rs:72:1\n    |\n LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c ff ff ff 7f                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:74:1\n+  --> $DIR/ub-wide-ptr.rs:75:1\n    |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -109,18 +109,18 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:77:1\n+  --> $DIR/ub-wide-ptr.rs:78:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:80:1\n+  --> $DIR/ub-wide-ptr.rs:81:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -129,165 +129,165 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:84:1\n+  --> $DIR/ub-wide-ptr.rs:85:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:84:40\n+  --> $DIR/ub-wide-ptr.rs:85:40\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:91:1\n+  --> $DIR/ub-wide-ptr.rs:92:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:91:42\n+  --> $DIR/ub-wide-ptr.rs:92:42\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:95:1\n+  --> $DIR/ub-wide-ptr.rs:96:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.1[0]: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:95:42\n+  --> $DIR/ub-wide-ptr.rs:96:42\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:103:1\n+  --> $DIR/ub-wide-ptr.rs:104:1\n    |\n LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:112:1\n+  --> $DIR/ub-wide-ptr.rs:113:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:116:1\n+  --> $DIR/ub-wide-ptr.rs:117:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:120:1\n+  --> $DIR/ub-wide-ptr.rs:121:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:123:57\n+  --> $DIR/ub-wide-ptr.rs:124:57\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:126:57\n+  --> $DIR/ub-wide-ptr.rs:127:57\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:129:56\n+  --> $DIR/ub-wide-ptr.rs:130:56\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:132:1\n+  --> $DIR/ub-wide-ptr.rs:133:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:137:1\n+  --> $DIR/ub-wide-ptr.rs:138:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:142:1\n+  --> $DIR/ub-wide-ptr.rs:143:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 00 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:144:1\n+  --> $DIR/ub-wide-ptr.rs:145:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:150:5\n+  --> $DIR/ub-wide-ptr.rs:151:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:154:5\n+  --> $DIR/ub-wide-ptr.rs:155:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable", "previous_filename": "src/test/ui/consts/const-eval/ub-wide-ptr.32bit.stderr"}, {"sha": "9e884ce12890b379b1c96115ddc767b05bd694b5", "filename": "src/test/ui/consts/issue-83182.64bit.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.64bit.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -1,15 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/issue-83182.rs:5:1\n-   |\n-LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "b62f903bdc27071e7d47e660c6da927a08e17044", "filename": "src/test/ui/consts/issue-83182.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.rs?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,4 +1,6 @@\n-// stderr-per-bitwidth\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n \n use std::mem;\n struct MyStr(str);"}, {"sha": "1d578f910c0408650bc7b4f1a144c68a6090c36d", "filename": "src/test/ui/consts/issue-83182.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,13 +1,13 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/issue-83182.rs:5:1\n+  --> $DIR/issue-83182.rs:7:1\n    |\n LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc4\u2500\u2500\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error: aborting due to previous error", "previous_filename": "src/test/ui/consts/issue-83182.32bit.stderr"}, {"sha": "8c83df53dade5045fe3053cdc154fcfc313b567a", "filename": "src/test/ui/consts/std/alloc.32bit.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.32bit.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,23 +1,23 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/alloc.rs:9:1\n+  --> $DIR/alloc.rs:12:1\n    |\n LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x00000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               00 10 00 00 00 00 00 00                         \u2502 ........\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/alloc.rs:13:1\n+  --> $DIR/alloc.rs:16:1\n    |\n LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x00000003, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               09 00 00 00 03 00 00 00                         \u2502 ........\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error: aborting due to 2 previous errors"}, {"sha": "addedad17047a9be851b19c214554b4223fc157a", "filename": "src/test/ui/consts/std/alloc.64bit.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.64bit.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,23 +1,23 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/alloc.rs:9:1\n+  --> $DIR/alloc.rs:12:1\n    |\n LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x0000000000000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/alloc.rs:13:1\n+  --> $DIR/alloc.rs:16:1\n    |\n LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x0000000000000003, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               09 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00 \u2502 ................\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error: aborting due to 2 previous errors"}, {"sha": "9abf35d63d30ac9d585603f895034d5f43827844", "filename": "src/test/ui/consts/std/alloc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.rs?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,5 +1,8 @@\n // stderr-per-bitwidth\n // ignore-debug (the debug assertions change the error)\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n use std::alloc::Layout;\n \n // ok"}, {"sha": "dac4e200a89deaa30680e65f144c2750676be117", "filename": "src/test/ui/consts/validate_never_arrays.64bit.stderr", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8651a92761421b0437ffb44ba5670bea5ee1df/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.64bit.stderr?ref=2d8651a92761421b0437ffb44ba5670bea5ee1df", "patch": "@@ -1,36 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_never_arrays.rs:4:1\n-   |\n-LL | const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) };\n-   | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type [!; 1]\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               01 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_never_arrays.rs:7:1\n-   |\n-LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) };\n-   | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               01 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 \u2502 ................\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_never_arrays.rs:8:1\n-   |\n-LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) };\n-   | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               01 00 00 00 00 00 00 00 2a 00 00 00 00 00 00 00 \u2502 ........*.......\n-           }\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "f96ca6839265ef2831734dada44987007daf5aaa", "filename": "src/test/ui/consts/validate_never_arrays.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.rs?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,4 +1,6 @@\n-// stderr-per-bitwidth\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n #![feature(never_type)]\n \n const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) }; //~ ERROR undefined behavior"}, {"sha": "12090e483a4e65f328eb763518d2086e4f8c3a32", "filename": "src/test/ui/consts/validate_never_arrays.stderr", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73e7207bfc0dc47f7b54c81c0d2351387ef708fb/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr?ref=73e7207bfc0dc47f7b54c81c0d2351387ef708fb", "patch": "@@ -1,34 +1,34 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_never_arrays.rs:4:1\n+  --> $DIR/validate_never_arrays.rs:6:1\n    |\n LL | const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) };\n    | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type [!; 1]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               01 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_never_arrays.rs:7:1\n+  --> $DIR/validate_never_arrays.rs:9:1\n    |\n LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) };\n    | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               01 00 00 00 01 00 00 00                         \u2502 ........\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_never_arrays.rs:8:1\n+  --> $DIR/validate_never_arrays.rs:10:1\n    |\n LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) };\n    | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               01 00 00 00 2a 00 00 00                         \u2502 ....*...\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error: aborting due to 3 previous errors", "previous_filename": "src/test/ui/consts/validate_never_arrays.32bit.stderr"}]}