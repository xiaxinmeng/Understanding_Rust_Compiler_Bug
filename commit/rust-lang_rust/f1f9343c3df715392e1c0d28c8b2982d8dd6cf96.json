{"sha": "f1f9343c3df715392e1c0d28c8b2982d8dd6cf96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZjkzNDNjM2RmNzE1MzkyZTFjMGQyOGM4YjI5ODJkOGRkNmNmOTY=", "commit": {"author": {"name": "Daan de Graaf", "email": "daandegraaf9@gmail.com", "date": "2018-12-28T12:15:39Z"}, "committer": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-05-04T09:47:26Z"}, "message": "Remove old pointee_info_at body.", "tree": {"sha": "8a83de0676f0bbd0dc99cd4024d5250d760105bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a83de0676f0bbd0dc99cd4024d5250d760105bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1f9343c3df715392e1c0d28c8b2982d8dd6cf96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f9343c3df715392e1c0d28c8b2982d8dd6cf96", "html_url": "https://github.com/rust-lang/rust/commit/f1f9343c3df715392e1c0d28c8b2982d8dd6cf96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1f9343c3df715392e1c0d28c8b2982d8dd6cf96/comments", "author": {"login": "wildarch", "id": 8987615, "node_id": "MDQ6VXNlcjg5ODc2MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8987615?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wildarch", "html_url": "https://github.com/wildarch", "followers_url": "https://api.github.com/users/wildarch/followers", "following_url": "https://api.github.com/users/wildarch/following{/other_user}", "gists_url": "https://api.github.com/users/wildarch/gists{/gist_id}", "starred_url": "https://api.github.com/users/wildarch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wildarch/subscriptions", "organizations_url": "https://api.github.com/users/wildarch/orgs", "repos_url": "https://api.github.com/users/wildarch/repos", "events_url": "https://api.github.com/users/wildarch/events{/privacy}", "received_events_url": "https://api.github.com/users/wildarch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed716d4c8960bb5e5127375ac023c698613b27bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed716d4c8960bb5e5127375ac023c698613b27bd", "html_url": "https://github.com/rust-lang/rust/commit/ed716d4c8960bb5e5127375ac023c698613b27bd"}], "stats": {"total": 145, "additions": 13, "deletions": 132}, "files": [{"sha": "7a7008822372d5ae3e30b8eff1f3999059752e01", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1f9343c3df715392e1c0d28c8b2982d8dd6cf96/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f9343c3df715392e1c0d28c8b2982d8dd6cf96/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=f1f9343c3df715392e1c0d28c8b2982d8dd6cf96", "patch": "@@ -7,13 +7,19 @@ use crate::value::Value;\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::mir::operand::OperandValue;\n+<<<<<<< HEAD\n+=======\n+use type_::Type;\n+use type_of::{LayoutLlvmExt};\n+use value::Value;\n+>>>>>>> Remove old pointee_info_at body.\n use rustc_target::abi::call::ArgType;\n \n use rustc_codegen_ssa::traits::*;\n \n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n use rustc::ty::{self, Ty, Instance};\n-use rustc::ty::layout;\n+use rustc::ty::layout::{self, PointerKind};\n \n use libc::c_uint;\n "}, {"sha": "55b28682725916218a9ad428384a13c5bc773842", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1f9343c3df715392e1c0d28c8b2982d8dd6cf96/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f9343c3df715392e1c0d28c8b2982d8dd6cf96/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=f1f9343c3df715392e1c0d28c8b2982d8dd6cf96", "patch": "@@ -16,7 +16,7 @@ use rustc_data_structures::small_c_str::SmallCStr;\n use rustc::mir::mono::Stats;\n use rustc::session::config::{self, DebugInfo};\n use rustc::session::Session;\n-use rustc::ty::layout::{LayoutError, LayoutOf, Size, TyLayout, VariantIdx};\n+use rustc::ty::layout::{LayoutError, LayoutOf, PointeeInfo, Size, TyLayout, VariantIdx};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::spec::{HasTargetSpec, Target};"}, {"sha": "e1c3c42add816a258c3285fa3db81708e76fdb8a", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 5, "deletions": 130, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/f1f9343c3df715392e1c0d28c8b2982d8dd6cf96/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f9343c3df715392e1c0d28c8b2982d8dd6cf96/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=f1f9343c3df715392e1c0d28c8b2982d8dd6cf96", "patch": "@@ -2,9 +2,11 @@ use crate::abi::{FnType, FnTypeExt};\n use crate::common::*;\n use crate::type_::Type;\n use rustc::hir;\n+use abi::{FnType, FnTypeExt};\n+use common::*;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n-use rustc_target::abi::FloatTy;\n+use rustc::ty::layout::{self, Align, LayoutOf, PointeeInfo, Size, TyLayout};\n+use rustc_target::abi::{FloatTy, TyLayoutMethods};\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use rustc_codegen_ssa::traits::*;\n \n@@ -174,28 +176,6 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n-pub enum PointerKind {\n-    /// Most general case, we know no restrictions to tell LLVM.\n-    Shared,\n-\n-    /// `&T` where `T` contains no `UnsafeCell`, is `noalias` and `readonly`.\n-    Frozen,\n-\n-    /// `&mut T`, when we know `noalias` is safe for LLVM.\n-    UniqueBorrowed,\n-\n-    /// `Box<T>`, unlike `UniqueBorrowed`, it also has `noalias` on returns.\n-    UniqueOwned\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct PointeeInfo {\n-    pub size: Size,\n-    pub align: Align,\n-    pub safe: Option<PointerKind>,\n-}\n-\n pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_immediate(&self) -> bool;\n     fn is_llvm_scalar_pair<'a>(&self) -> bool;\n@@ -406,112 +386,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             return pointee;\n         }\n \n-        let mut result = None;\n-        match self.ty.sty {\n-            ty::RawPtr(mt) if offset.bytes() == 0 => {\n-                let (size, align) = cx.size_and_align_of(mt.ty);\n-                result = Some(PointeeInfo {\n-                    size,\n-                    align,\n-                    safe: None\n-                });\n-            }\n-\n-            ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n-                let (size, align) = cx.size_and_align_of(ty);\n-\n-                let kind = match mt {\n-                    hir::MutImmutable => if cx.type_is_freeze(ty) {\n-                        PointerKind::Frozen\n-                    } else {\n-                        PointerKind::Shared\n-                    },\n-                    hir::MutMutable => {\n-                        // Previously we would only emit noalias annotations for LLVM >= 6 or in\n-                        // panic=abort mode. That was deemed right, as prior versions had many bugs\n-                        // in conjunction with unwinding, but later versions didn\u2019t seem to have\n-                        // said issues. See issue #31681.\n-                        //\n-                        // Alas, later on we encountered a case where noalias would generate wrong\n-                        // code altogether even with recent versions of LLVM in *safe* code with no\n-                        // unwinding involved. See #54462.\n-                        //\n-                        // For now, do not enable mutable_noalias by default at all, while the\n-                        // issue is being figured out.\n-                        let mutable_noalias = cx.tcx.sess.opts.debugging_opts.mutable_noalias\n-                            .unwrap_or(false);\n-                        if mutable_noalias {\n-                            PointerKind::UniqueBorrowed\n-                        } else {\n-                            PointerKind::Shared\n-                        }\n-                    }\n-                };\n-\n-                result = Some(PointeeInfo {\n-                    size,\n-                    align,\n-                    safe: Some(kind)\n-                });\n-            }\n-\n-            _ => {\n-                let mut data_variant = match self.variants {\n-                    // Within the discriminant field, only the niche itself is\n-                    // always initialized, so we only check for a pointer at its\n-                    // offset.\n-                    //\n-                    // If the niche is a pointer, it's either valid (according\n-                    // to its type), or null (which the niche field's scalar\n-                    // validity range encodes).  This allows using\n-                    // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n-                    // this will continue to work as long as we don't start\n-                    // using more niches than just null (e.g., the first page of\n-                    // the address space, or unaligned pointers).\n-                    layout::Variants::Multiple {\n-                        discr_kind: layout::DiscriminantKind::Niche {\n-                            dataful_variant,\n-                            ..\n-                        },\n-                        discr_index,\n-                        ..\n-                    } if self.fields.offset(discr_index) == offset =>\n-                        Some(self.for_variant(cx, dataful_variant)),\n-                    _ => Some(*self),\n-                };\n-\n-                if let Some(variant) = data_variant {\n-                    // We're not interested in any unions.\n-                    if let layout::FieldPlacement::Union(_) = variant.fields {\n-                        data_variant = None;\n-                    }\n-                }\n-\n-                if let Some(variant) = data_variant {\n-                    let ptr_end = offset + layout::Pointer.size(cx);\n-                    for i in 0..variant.fields.count() {\n-                        let field_start = variant.fields.offset(i);\n-                        if field_start <= offset {\n-                            let field = variant.field(cx, i);\n-                            if ptr_end <= field_start + field.size {\n-                                // We found the right field, look inside it.\n-                                result = field.pointee_info_at(cx, offset - field_start);\n-                                break;\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n-                if let Some(ref mut pointee) = result {\n-                    if let ty::Adt(def, _) = self.ty.sty {\n-                        if def.is_box() && offset.bytes() == 0 {\n-                            pointee.safe = Some(PointerKind::UniqueOwned);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+        let result = Ty::pointee_info_at(*self, cx, offset);\n \n         cx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n         result"}]}