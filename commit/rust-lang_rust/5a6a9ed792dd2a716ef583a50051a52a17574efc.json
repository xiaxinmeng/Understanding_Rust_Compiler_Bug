{"sha": "5a6a9ed792dd2a716ef583a50051a52a17574efc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNmE5ZWQ3OTJkZDJhNzE2ZWY1ODNhNTAwNTFhNTJhMTc1NzRlZmM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-17T04:44:23Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-24T12:16:02Z"}, "message": "rustc: combine partial_def_map and last_private_map into def_map.", "tree": {"sha": "438c891bf9b68e126acea4f0ce9405683fce715c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/438c891bf9b68e126acea4f0ce9405683fce715c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a6a9ed792dd2a716ef583a50051a52a17574efc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a6a9ed792dd2a716ef583a50051a52a17574efc", "html_url": "https://github.com/rust-lang/rust/commit/5a6a9ed792dd2a716ef583a50051a52a17574efc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a6a9ed792dd2a716ef583a50051a52a17574efc/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06f362aeb3c6956bb471fe44de72185dd831eb48", "url": "https://api.github.com/repos/rust-lang/rust/commits/06f362aeb3c6956bb471fe44de72185dd831eb48", "html_url": "https://github.com/rust-lang/rust/commit/06f362aeb3c6956bb471fe44de72185dd831eb48"}], "stats": {"total": 893, "additions": 444, "deletions": 449}, "files": [{"sha": "28baeb5dc9e62c2c455465f67206987a588a3651", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -406,7 +406,7 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n-        match self.cx.tcx.def_map.borrow()[id].clone() {\n+        match self.cx.tcx.def_map.borrow()[id].full_def() {\n             def::DefPrimTy(ast::TyInt(ast::TyIs(_))) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `isize` in foreign module, while \\\n@@ -1000,7 +1000,8 @@ impl LintPass for NonSnakeCase {\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         if let &ast::PatIdent(_, ref path1, _) = &p.node {\n-            if let Some(&def::DefLocal(_)) = cx.tcx.def_map.borrow().get(&p.id) {\n+            let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n+            if let Some(def::DefLocal(_)) = def {\n                 self.check_snake_case(cx, \"variable\", path1.node, p.span);\n             }\n         }\n@@ -1065,8 +1066,8 @@ impl LintPass for NonUpperCaseGlobals {\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n-        match (&p.node, cx.tcx.def_map.borrow().get(&p.id)) {\n-            (&ast::PatIdent(_, ref path1, _), Some(&def::DefConst(..))) => {\n+        match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n+            (&ast::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n                                                       path1.node, p.span);\n             }\n@@ -1226,10 +1227,13 @@ impl LintPass for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n         let def_map = cx.tcx.def_map.borrow();\n         if let ast::PatStruct(_, ref v, _) = pat.node {\n-            for fieldpat in v.iter()\n-                             .filter(|fieldpat| !fieldpat.node.is_shorthand)\n-                             .filter(|fieldpat| def_map.get(&fieldpat.node.pat.id)\n-                                                == Some(&def::DefLocal(fieldpat.node.pat.id))) {\n+            let field_pats = v.iter()\n+                              .filter(|fieldpat| !fieldpat.node.is_shorthand)\n+                              .filter(|fieldpat| {\n+                let def = def_map.get(&fieldpat.node.pat.id).map(|d| d.full_def());\n+                def == Some(def::DefLocal(fieldpat.node.pat.id))\n+            });\n+            for fieldpat in field_pats {\n                 if let ast::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node.as_str() == fieldpat.node.ident.as_str() {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n@@ -1908,10 +1912,7 @@ impl LintPass for UnconditionalRecursion {\n                                       _: ast::Ident,\n                                       id: ast::NodeId) -> bool {\n             tcx.def_map.borrow().get(&id)\n-                .map_or(false, |def| {\n-                    let did = def.def_id();\n-                    ast_util::is_local(did) && did.node == fn_id\n-                })\n+                .map_or(false, |def| def.def_id() == ast_util::local_def(fn_id))\n         }\n \n         // check if the method call `id` refers to method `method_id`"}, {"sha": "4aea73cfb0ec0a18b7ff8f7566e986de65722ee9", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -1870,9 +1870,7 @@ struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         if let ast::ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let def_map = &self.ecx.tcx.def_map;\n-            let trait_def = def_map.borrow()[trait_ref.ref_id].clone();\n-            let def_id = trait_def.def_id();\n+            let def_id = self.ecx.tcx.def_map.borrow()[trait_ref.ref_id].def_id();\n \n             // Load eagerly if this is an implementation of the Drop trait\n             // or if the trait is not defined in this crate."}, {"sha": "c9196f0cb2a64fd860bcc9ed89b943e6210f12e7", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -65,7 +65,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                 tcx.sess.span_bug(ast_ty.span,\n                                   &format!(\"unbound path {}\", path.repr(tcx)))\n             }\n-            Some(&d) => d\n+            Some(d) => d.full_def()\n         };\n         if let def::DefPrimTy(nty) = def {\n             Some(prim_ty_to_ty(tcx, &path.segments[], nty))"}, {"sha": "5983829ed8fbef20e56b6124b2a1e868201aaf0d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -25,6 +25,7 @@ use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n use middle::check_const::ConstQualif;\n use middle::mem_categorization::Typer;\n+use middle::privacy::{AllPublic, LastMod};\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty, MethodCall, MethodCallee, MethodOrigin};\n@@ -1148,10 +1149,10 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n-    if let Some(def) = tcx.def_map.borrow().get(&id) {\n+    if let Some(def) = tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n         rbml_w.tag(c::tag_table_def, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| (*def).encode(rbml_w).unwrap());\n+            rbml_w.tag(c::tag_table_val, |rbml_w| def.encode(rbml_w).unwrap());\n         })\n     }\n \n@@ -1851,7 +1852,12 @@ fn decode_side_tables(dcx: &DecodeContext,\n                 match value {\n                     c::tag_table_def => {\n                         let def = decode_def(dcx, val_doc);\n-                        dcx.tcx.def_map.borrow_mut().insert(id, def);\n+                        dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution {\n+                            base_def: def,\n+                            // This doesn't matter cross-crate.\n+                            last_private: LastMod(AllPublic),\n+                            depth: 0\n+                        });\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(dcx);"}, {"sha": "ca9455ac421f2e1c5d1327b3b4b22a7b931c726e", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -610,32 +610,24 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn find_scope(&self,\n                   expr: &ast::Expr,\n                   label: Option<ast::Ident>) -> LoopScope {\n-        match label {\n-            None => {\n-                return *self.loop_scopes.last().unwrap();\n-            }\n-\n-            Some(_) => {\n-                match self.tcx.def_map.borrow().get(&expr.id) {\n-                    Some(&def::DefLabel(loop_id)) => {\n-                        for l in &self.loop_scopes {\n-                            if l.loop_id == loop_id {\n-                                return *l;\n-                            }\n-                        }\n-                        self.tcx.sess.span_bug(\n-                            expr.span,\n-                            &format!(\"no loop scope for id {}\",\n-                                    loop_id));\n-                    }\n+        if label.is_none() {\n+            return *self.loop_scopes.last().unwrap();\n+        }\n \n-                    r => {\n-                        self.tcx.sess.span_bug(\n-                            expr.span,\n-                            &format!(\"bad entry `{:?}` in def_map for label\",\n-                                    r));\n+        match self.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n+            Some(def::DefLabel(loop_id)) => {\n+                for l in &self.loop_scopes {\n+                    if l.loop_id == loop_id {\n+                        return *l;\n                     }\n                 }\n+                self.tcx.sess.span_bug(expr.span,\n+                    &format!(\"no loop scope for id {}\", loop_id));\n+            }\n+\n+            r => {\n+                self.tcx.sess.span_bug(expr.span,\n+                    &format!(\"bad entry `{:?}` in def_map for label\", r));\n             }\n         }\n     }"}, {"sha": "57e4d3d2f02030353c7d0be8a18773edcc94d219", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -440,7 +440,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprPath(_) | ast::ExprQPath(_) => {\n-            let def = v.tcx.def_map.borrow().get(&e.id).cloned();\n+            let def = v.tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n             match def {\n                 Some(def::DefVariant(_, _, _)) => {\n                     // Count the discriminator or function pointer.\n@@ -499,7 +499,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                     _ => break\n                 };\n             }\n-            let def = v.tcx.def_map.borrow().get(&callee.id).cloned();\n+            let def = v.tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def());\n             match def {\n                 Some(def::DefStruct(..)) => {}\n                 Some(def::DefVariant(..)) => {"}, {"sha": "c409c8fb13f14502437aa2d1c9813b1365624f9d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -242,7 +242,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n             ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n                 let pat_ty = ty::pat_ty(cx.tcx, p);\n                 if let ty::ty_enum(def_id, _) = pat_ty.sty {\n-                    let def = cx.tcx.def_map.borrow().get(&p.id).cloned();\n+                    let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n                     if let Some(DefLocal(_)) = def {\n                         if ty::enum_variants(cx.tcx, def_id).iter().any(|variant|\n                             token::get_name(variant.name) == token::get_name(ident.node.name)\n@@ -434,7 +434,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n             ast::PatIdent(..) | ast::PatEnum(..) => {\n-                let def = self.tcx.def_map.borrow().get(&pat.id).cloned();\n+                let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n                     Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n                         Some(const_expr) => {\n@@ -733,28 +733,28 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     let pat = raw_pat(p);\n     match pat.node {\n         ast::PatIdent(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id) {\n-                Some(&DefConst(..)) =>\n+            match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                Some(DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(&DefStruct(_)) => vec!(Single),\n-                Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n+                Some(DefStruct(_)) => vec!(Single),\n+                Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!()\n             },\n         ast::PatEnum(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id) {\n-                Some(&DefConst(..)) =>\n+            match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                Some(DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n+                Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         ast::PatStruct(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id) {\n-                Some(&DefConst(..)) =>\n+            match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                Some(DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n+                Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         ast::PatLit(ref expr) =>\n@@ -847,7 +847,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             Some(repeat(DUMMY_WILD_PAT).take(arity).collect()),\n \n         ast::PatIdent(_, _, _) => {\n-            let opt_def = cx.tcx.def_map.borrow().get(&pat_id).cloned();\n+            let opt_def = cx.tcx.def_map.borrow().get(&pat_id).map(|d| d.full_def());\n             match opt_def {\n                 Some(DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n@@ -862,7 +862,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         ast::PatEnum(_, ref args) => {\n-            let def = cx.tcx.def_map.borrow()[pat_id].clone();\n+            let def = cx.tcx.def_map.borrow()[pat_id].full_def();\n             match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n@@ -880,7 +880,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n \n         ast::PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n-            let def = cx.tcx.def_map.borrow()[pat_id].clone();\n+            let def = cx.tcx.def_map.borrow()[pat_id].full_def();\n             let class_id = match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\"}, {"sha": "a4393f4648b1eec0c6899444d3f6a13f63032ca3", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -94,9 +94,9 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprPath(_) | ast::ExprQPath(_) => {\n-                match self.def_map.borrow().get(&e.id) {\n-                    Some(&DefStatic(def_id, _)) |\n-                    Some(&DefConst(def_id)) if\n+                match self.def_map.borrow().get(&e.id).map(|d| d.full_def()) {\n+                    Some(DefStatic(def_id, _)) |\n+                    Some(DefConst(def_id)) if\n                             ast_util::is_local(def_id) => {\n                         match self.ast_map.get(def_id.node) {\n                           ast_map::NodeItem(item) =>"}, {"sha": "d3c6a585fa3fd0b82ad8b3a1f32e8553dc2c845c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -31,7 +31,7 @@ use std::{i8, i16, i32, i64};\n use std::rc::Rc;\n \n fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n-    let opt_def = tcx.def_map.borrow().get(&e.id).cloned();\n+    let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n     match opt_def {\n         Some(def::DefConst(def_id)) => {\n             lookup_const_by_id(tcx, def_id)\n@@ -148,11 +148,11 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n             ast::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect()),\n \n         ast::ExprCall(ref callee, ref args) => {\n-            let def = tcx.def_map.borrow()[callee.id].clone();\n+            let def = tcx.def_map.borrow()[callee.id];\n             if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n                entry.insert(def);\n             }\n-            let path = match def {\n+            let path = match def.full_def() {\n                 def::DefStruct(def_id) => def_to_path(tcx, def_id),\n                 def::DefVariant(_, variant_did, _) => def_to_path(tcx, variant_did),\n                 _ => unreachable!()\n@@ -179,7 +179,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n         }\n \n         ast::ExprPath(ref path) => {\n-            let opt_def = tcx.def_map.borrow().get(&expr.id).cloned();\n+            let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(def::DefStruct(..)) =>\n                     ast::PatStruct(path.clone(), vec![], false),\n@@ -389,7 +389,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         cast_const(val, ety)\n       }\n       ast::ExprPath(_) | ast::ExprQPath(_) => {\n-          let opt_def = tcx.def_map.borrow().get(&e.id).cloned();\n+          let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n           let (const_expr, const_ty) = match opt_def {\n               Some(def::DefConst(def_id)) => {\n                   if ast_util::is_local(def_id) {"}, {"sha": "2d837ce52b56a4f9abcee7e973d8dc95d7a55d3f", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -71,13 +71,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n         self.tcx.def_map.borrow().get(id).map(|def| {\n-            match def {\n-                &def::DefConst(_) => {\n+            match def.full_def() {\n+                def::DefConst(_) => {\n                     self.check_def_id(def.def_id())\n                 }\n                 _ if self.ignore_non_const_paths => (),\n-                &def::DefPrimTy(_) => (),\n-                &def::DefVariant(enum_id, variant_id, _) => {\n+                def::DefPrimTy(_) => (),\n+                def::DefVariant(enum_id, variant_id, _) => {\n                     self.check_def_id(enum_id);\n                     self.check_def_id(variant_id);\n                 }\n@@ -158,7 +158,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &ast::Pat,\n                                   pats: &[codemap::Spanned<ast::FieldPat>]) {\n-        let id = match (*self.tcx.def_map.borrow())[lhs.id] {\n+        let id = match self.tcx.def_map.borrow()[lhs.id].full_def() {\n             def::DefVariant(_, id, _) => id,\n             _ => {\n                 match ty::ty_to_def_id(ty::node_id_to_type(self.tcx,"}, {"sha": "1a054c0f464aac9afb5a91adb6f007490a8969da", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -11,6 +11,7 @@\n pub use self::Def::*;\n pub use self::MethodProvenance::*;\n \n+use middle::privacy::LastPrivate;\n use middle::subst::ParamSpace;\n use util::nodemap::NodeMap;\n use syntax::ast;\n@@ -51,24 +52,43 @@ pub enum Def {\n     DefMethod(ast::DefId /* method */, MethodProvenance),\n }\n \n-/// The result of resolving the prefix of a path to a type:\n+/// The result of resolving a path.\n+/// Before type checking completes, `depth` represents the number of\n+/// trailing segments which are yet unresolved. Afterwards, if there\n+/// were no errors, all paths should be fully resolved, with `depth`\n+/// set to `0` and `base_def` representing the final resolution.\n ///\n-///     module::Type::AssocA::AssocB::AssocC::MethodOrAssocType\n-///     ^~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~\n-///     base_type     extra_associated_types\n+///     module::Type::AssocX::AssocY::MethodOrAssocType\n+///     ^~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+///     base_def      depth = 3\n ///\n-///     <T as Trait>::AssocA::AssocB::AssocC::MethodOrAssocType\n-///           ^~~~~~~~~~~~~~  ^~~~~~~~~~~~~~\n-///           base_type       extra_associated_types\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct PartialDef {\n-    pub base_type: Def,\n-    pub extra_associated_types: u32,\n+///     <T as Trait>::AssocX::AssocY::MethodOrAssocType\n+///           ^~~~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~\n+///           base_def        depth = 2\n+#[derive(Copy, Debug)]\n+pub struct PathResolution {\n+    pub base_def: Def,\n+    pub last_private: LastPrivate,\n+    pub depth: usize\n+}\n+\n+impl PathResolution {\n+    /// Get the definition, if fully resolved, otherwise panic.\n+    pub fn full_def(&self) -> Def {\n+        if self.depth != 0 {\n+            panic!(\"path not fully resolved: {:?}\", self);\n+        }\n+        self.base_def\n+    }\n+\n+    /// Get the DefId, if fully resolved, otherwise panic.\n+    pub fn def_id(&self) -> ast::DefId {\n+        self.full_def().def_id()\n+    }\n }\n \n // Definition mapping\n-pub type DefMap = RefCell<NodeMap<Def>>;\n-pub type PartialDefMap = RefCell<NodeMap<PartialDef>>;\n+pub type DefMap = RefCell<NodeMap<PathResolution>>;\n // This is the replacement export map. It maps a module to all of the exports\n // within.\n pub type ExportMap = NodeMap<Vec<Export>>;\n@@ -119,7 +139,7 @@ impl Def {\n                 local_def(id)\n             }\n \n-            DefPrimTy(_) => panic!()\n+            DefPrimTy(_) => panic!(\"attempted .def_id() on DefPrimTy\")\n         }\n     }\n "}, {"sha": "f7c723c68746fef3d49ef8a45a2e74033c5c56a1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -1017,7 +1017,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n-                let def = def_map.borrow()[pat.id].clone();\n+                let def = def_map.borrow()[pat.id].full_def();\n                 match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     Ok(binding_cmt) => {\n                         delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n@@ -1097,13 +1097,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n             match pat.node {\n                 ast::PatEnum(_, _) | ast::PatIdent(_, _, None) | ast::PatStruct(..) => {\n-                    match def_map.get(&pat.id) {\n+                    match def_map.get(&pat.id).map(|d| d.full_def()) {\n                         None => {\n                             // no definition found: pat is not a\n                             // struct or enum pattern.\n                         }\n \n-                        Some(&def::DefVariant(enum_did, variant_did, _is_struct)) => {\n+                        Some(def::DefVariant(enum_did, variant_did, _is_struct)) => {\n                             let downcast_cmt =\n                                 if ty::enum_is_univariant(tcx, enum_did) {\n                                     cmt_pat\n@@ -1119,7 +1119,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             delegate.matched_pat(pat, downcast_cmt, match_mode);\n                         }\n \n-                        Some(&def::DefStruct(..)) | Some(&def::DefTy(_, false)) => {\n+                        Some(def::DefStruct(..)) | Some(def::DefTy(_, false)) => {\n                             // A struct (in either the value or type\n                             // namespace; we encounter the former on\n                             // e.g. patterns for unit structs).\n@@ -1131,14 +1131,14 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             delegate.matched_pat(pat, cmt_pat, match_mode);\n                         }\n \n-                        Some(&def::DefConst(..)) |\n-                        Some(&def::DefLocal(..)) => {\n+                        Some(def::DefConst(..)) |\n+                        Some(def::DefLocal(..)) => {\n                             // This is a leaf (i.e. identifier binding\n                             // or constant value to match); thus no\n                             // `matched_pat` call.\n                         }\n \n-                        Some(def @ &def::DefTy(_, true)) => {\n+                        Some(def @ def::DefTy(_, true)) => {\n                             // An enum's type -- should never be in a\n                             // pattern.\n "}, {"sha": "60b7e1169b49bcb923534fd909569c66e8704e80", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -1242,7 +1242,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                         \"unbound path {}\",\n                                         pprust::path_to_string(path)))\n                         }\n-                        Some(&d) => d\n+                        Some(d) => d.full_def()\n                     };\n                     match a_def {\n                         def::DefTy(did, _) | def::DefStruct(did) => {"}, {"sha": "4685a05f41604d31887f98b8db6574a4e8fb3367", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -446,7 +446,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ast::ExprPath(_) | ast::ExprQPath(_) => {\n-        let def = ir.tcx.def_map.borrow()[expr.id].clone();\n+        let def = ir.tcx.def_map.borrow()[expr.id].full_def();\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if let DefLocal(..) = def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -705,8 +705,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             Some(_) => {\n                 // Refers to a labeled loop. Use the results of resolve\n                 // to find with one\n-                match self.ir.tcx.def_map.borrow().get(&id) {\n-                    Some(&DefLabel(loop_id)) => loop_id,\n+                match self.ir.tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n+                    Some(DefLabel(loop_id)) => loop_id,\n                     _ => self.ir.tcx.sess.span_bug(sp, \"label on break/loop \\\n                                                         doesn't refer to a loop\")\n                 }\n@@ -1300,7 +1300,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n                    -> LiveNode {\n-        match self.ir.tcx.def_map.borrow()[expr.id].clone() {\n+        match self.ir.tcx.def_map.borrow()[expr.id].full_def() {\n           DefLocal(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0 {\n@@ -1562,7 +1562,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n             ast::ExprPath(_) | ast::ExprQPath(_) => {\n-                if let DefLocal(nid) = self.ir.tcx.def_map.borrow()[expr.id].clone() {\n+                if let DefLocal(nid) = self.ir.tcx.def_map.borrow()[expr.id].full_def() {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability"}, {"sha": "44ab3cf60aaa3dbe6f0ff19df2db8b41747f0eb8", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -530,7 +530,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::ExprPath(_) | ast::ExprQPath(_) => {\n-            let def = (*self.tcx().def_map.borrow())[expr.id];\n+            let def = self.tcx().def_map.borrow()[expr.id].full_def();\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -1199,14 +1199,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         (*op)(self, cmt.clone(), pat);\n \n-        let def_map = self.tcx().def_map.borrow();\n-        let opt_def = def_map.get(&pat.id);\n+        let opt_def = self.tcx().def_map.borrow().get(&pat.id).map(|d| d.full_def());\n \n         // Note: This goes up here (rather than within the PatEnum arm\n         // alone) because struct patterns can refer to struct types or\n         // to struct variants within enums.\n         let cmt = match opt_def {\n-            Some(&def::DefVariant(enum_did, variant_did, _))\n+            Some(def::DefVariant(enum_did, variant_did, _))\n                 // univariant enums do not need downcasts\n                 if !ty::enum_is_univariant(self.tcx(), enum_did) => {\n                     self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n@@ -1224,7 +1223,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n           ast::PatEnum(_, Some(ref subpats)) => {\n             match opt_def {\n-                Some(&def::DefVariant(..)) => {\n+                Some(def::DefVariant(..)) => {\n                     // variant(x, y, z)\n                     for (i, subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n@@ -1237,7 +1236,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         try!(self.cat_pattern_(subcmt, &**subpat, op));\n                     }\n                 }\n-                Some(&def::DefStruct(..)) => {\n+                Some(def::DefStruct(..)) => {\n                     for (i, subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n                         let cmt_field =\n@@ -1247,7 +1246,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         try!(self.cat_pattern_(cmt_field, &**subpat, op));\n                     }\n                 }\n-                Some(&def::DefConst(..)) => {\n+                Some(def::DefConst(..)) => {\n                     for subpat in subpats {\n                         try!(self.cat_pattern_(cmt.clone(), &**subpat, op));\n                     }"}, {"sha": "c5abff3b96360bceaa9ca8b8d8124e02ad4fb08e", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -34,8 +34,8 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &ast::Pat) -> bool {\n         ast::PatEnum(_, _) |\n         ast::PatIdent(_, _, None) |\n         ast::PatStruct(..) => {\n-            match dm.borrow().get(&pat.id) {\n-                Some(&DefVariant(..)) => true,\n+            match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                Some(DefVariant(..)) => true,\n                 _ => false\n             }\n         }\n@@ -49,8 +49,8 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &ast::Pat) -> bool {\n         ast::PatEnum(_, _) |\n         ast::PatIdent(_, _, None) |\n         ast::PatStruct(..) => {\n-            match dm.borrow().get(&pat.id) {\n-                Some(&DefVariant(..)) | Some(&DefStruct(..)) => true,\n+            match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                Some(DefVariant(..)) | Some(DefStruct(..)) => true,\n                 _ => false\n             }\n         }\n@@ -61,8 +61,8 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &ast::Pat) -> bool {\n pub fn pat_is_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n         ast::PatIdent(_, _, None) | ast::PatEnum(..) => {\n-            match dm.borrow().get(&pat.id) {\n-                Some(&DefConst(..)) => true,\n+            match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                Some(DefConst(..)) => true,\n                 _ => false\n             }\n         }"}, {"sha": "3a253735f925b032e93390ce3618f6c4aa4aec87", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -16,7 +16,7 @@ pub use self::PrivateDep::*;\n pub use self::ImportUse::*;\n pub use self::LastPrivate::*;\n \n-use util::nodemap::{DefIdSet, NodeMap, NodeSet};\n+use util::nodemap::{DefIdSet, NodeSet};\n \n use syntax::ast;\n \n@@ -32,9 +32,6 @@ pub type ExternalExports = DefIdSet;\n /// reexporting a public struct doesn't inline the doc).\n pub type PublicItems = NodeSet;\n \n-// FIXME: dox\n-pub type LastPrivateMap = NodeMap<LastPrivate>;\n-\n #[derive(Copy, Debug)]\n pub enum LastPrivate {\n     LastMod(PrivateDep),"}, {"sha": "a140c766758e38a6f4a1790fe1d30744c88ed145", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n         match expr.node {\n             ast::ExprPath(_) | ast::ExprQPath(_) => {\n                 let def = match self.tcx.def_map.borrow().get(&expr.id) {\n-                    Some(&def) => def,\n+                    Some(d) => d.full_def(),\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n                                                \"def ID not in def map?!\")"}, {"sha": "9bcda68eb3ad797503fd5767515d93b6324b0395", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -168,8 +168,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             ast::TyPath(ref path) => {\n                 // if this path references a trait, then this will resolve to\n                 // a trait ref, which introduces a binding scope.\n-                match self.def_map.borrow().get(&ty.id) {\n-                    Some(&def::DefTrait(..)) => {\n+                match self.def_map.borrow().get(&ty.id).map(|d| (d.base_def, d.depth)) {\n+                    Some((def::DefTrait(..), 0)) => {\n                         self.with(LateScope(&Vec::new(), self.scope), |_, this| {\n                             this.visit_path(path, ty.id);\n                         });"}, {"sha": "f67e470ee54917a1a2f9105fca63a5c50c5a877a", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -393,12 +393,14 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n \n pub fn check_path(tcx: &ty::ctxt, path: &ast::Path, id: ast::NodeId,\n                   cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n-    let did = match tcx.def_map.borrow().get(&id) {\n-        Some(&def::DefPrimTy(..)) => return,\n-        Some(def) => def.def_id(),\n-        None => return\n-    };\n-    maybe_do_stability_check(tcx, did, path.span, cb)\n+    match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n+        Some(def::DefPrimTy(..)) => {}\n+        Some(def) => {\n+            maybe_do_stability_check(tcx, def.def_id(), path.span, cb);\n+        }\n+        None => {}\n+    }\n+\n }\n \n fn maybe_do_stability_check(tcx: &ty::ctxt, id: ast::DefId, span: Span,"}, {"sha": "7cd047279028cc90c667575d744af14d1fe725b2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -46,12 +46,11 @@ use metadata::csearch;\n use middle;\n use middle::check_const;\n use middle::const_eval;\n-use middle::def::{self, DefMap, ExportMap, PartialDefMap};\n+use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n use middle::lang_items::{FnOnceTraitLangItem, TyDescStructLangItem};\n use middle::mem_categorization as mc;\n-use middle::privacy::LastPrivateMap;\n use middle::region;\n use middle::resolve_lifetime;\n use middle::infer;\n@@ -683,8 +682,6 @@ pub struct ctxt<'tcx> {\n \n     pub sess: Session,\n     pub def_map: DefMap,\n-    pub partial_def_map: PartialDefMap,\n-    pub last_private_map: RefCell<LastPrivateMap>,\n \n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n \n@@ -2427,8 +2424,6 @@ impl<'tcx> CommonTypes<'tcx> {\n pub fn mk_ctxt<'tcx>(s: Session,\n                      arenas: &'tcx CtxtArenas<'tcx>,\n                      def_map: DefMap,\n-                     partial_def_map: PartialDefMap,\n-                     last_private_map: LastPrivateMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n                      freevars: RefCell<FreevarMap>,\n@@ -2451,8 +2446,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         variance_computed: Cell::new(false),\n         sess: s,\n         def_map: def_map,\n-        partial_def_map: partial_def_map,\n-        last_private_map: RefCell::new(last_private_map),\n         region_maps: region_maps,\n         node_types: RefCell::new(FnvHashMap()),\n         item_substs: RefCell::new(NodeMap()),\n@@ -4509,7 +4502,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n \n pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n     match tcx.def_map.borrow().get(&expr.id) {\n-        Some(&def) => def,\n+        Some(def) => def.full_def(),\n         None => {\n             tcx.sess.span_bug(expr.span, &format!(\n                 \"no def-map entry for expr {}\", expr.id));\n@@ -4692,11 +4685,10 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n \n         ast::ExprBox(Some(ref place), _) => {\n             // Special case `Box<T>` for now:\n-            let definition = match tcx.def_map.borrow().get(&place.id) {\n-                Some(&def) => def,\n+            let def_id = match tcx.def_map.borrow().get(&place.id) {\n+                Some(def) => def.def_id(),\n                 None => panic!(\"no def for place\"),\n             };\n-            let def_id = definition.def_id();\n             if tcx.lang_items.exchange_heap() == Some(def_id) {\n                 RvalueDatumExpr\n             } else {\n@@ -5144,10 +5136,7 @@ pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n }\n \n pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n-    let def = *tcx.def_map.borrow()\n-                     .get(&tr.ref_id)\n-                     .expect(\"no def-map entry for trait\");\n-    def.def_id()\n+    tcx.def_map.borrow().get(&tr.ref_id).expect(\"no def-map entry for trait\").def_id()\n }\n \n pub fn try_add_builtin_trait("}, {"sha": "bd911c20afc47e0aeb178cd30485ec1470ef926f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -567,12 +567,10 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n \n     let resolve::CrateMap {\n         def_map,\n-        partial_def_map,\n         freevars,\n         export_map,\n         trait_map,\n         external_exports,\n-        last_private_map,\n         glob_map,\n     } =\n         time(time_passes, \"resolution\", (),\n@@ -608,8 +606,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     let ty_cx = ty::mk_ctxt(sess,\n                             arenas,\n                             def_map,\n-                            partial_def_map,\n-                            last_private_map,\n                             named_region_map,\n                             ast_map,\n                             freevars,"}, {"sha": "f325a6abede51a7518935cd5b146a12519263efd", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -259,7 +259,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             ast::ItemImpl(_, _, _, _, ref ty, ref impl_items) => {\n                 let public_ty = match ty.node {\n                     ast::TyPath(_) => {\n-                        match self.tcx.def_map.borrow()[ty.id].clone() {\n+                        match self.tcx.def_map.borrow()[ty.id].full_def() {\n                             def::DefPrimTy(..) => true,\n                             def => {\n                                 let did = def.def_id();\n@@ -326,7 +326,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n \n             ast::ItemTy(ref ty, _) if public_first => {\n                 if let ast::TyPath(_) = ty.node {\n-                    match self.tcx.def_map.borrow()[ty.id].clone() {\n+                    match self.tcx.def_map.borrow()[ty.id].full_def() {\n                         def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                         def => {\n                             let did = def.def_id();\n@@ -630,7 +630,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             ast::TyPath(_) => {}\n                             _ => return Some((err_span, err_msg, None)),\n                         };\n-                        let def = self.tcx.def_map.borrow()[ty.id].clone();\n+                        let def = self.tcx.def_map.borrow()[ty.id].full_def();\n                         let did = def.def_id();\n                         assert!(is_local(did));\n                         match self.tcx.map.get(did.node) {\n@@ -716,19 +716,19 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Checks that a path is in scope.\n     fn check_path(&mut self, span: Span, path_id: ast::NodeId, last: ast::Ident) {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n-        let orig_def = self.tcx.def_map.borrow()[path_id].clone();\n+        let path_res = self.tcx.def_map.borrow()[path_id];\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n                 debug!(\"privacy - ck_public {:?}\", def);\n                 let name = token::get_ident(last);\n-                let origdid = orig_def.def_id();\n+                let origdid = path_res.def_id();\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n                                    &format!(\"{} `{}`\", tyname, name))\n             };\n \n-            match self.tcx.last_private_map.borrow()[path_id] {\n+            match path_res.last_private {\n                 LastMod(AllPublic) => {},\n                 LastMod(DependsOn(def)) => {\n                     self.report_error(ck_public(def));\n@@ -792,7 +792,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         // def map is not. Therefore the names we work out below will not always\n         // be accurate and we can get slightly wonky error messages (but type\n         // checking is always correct).\n-        match self.tcx.def_map.borrow()[path_id].clone() {\n+        match path_res.full_def() {\n             def::DefFn(..) => ck(\"function\"),\n             def::DefStatic(..) => ck(\"static\"),\n             def::DefConst(..) => ck(\"const\"),\n@@ -889,7 +889,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow()[expr.id].clone() {\n+                        match self.tcx.def_map.borrow()[expr.id].full_def() {\n                             def::DefVariant(_, variant_id, _) => {\n                                 for field in fields {\n                                     self.check_field(expr.span, variant_id,\n@@ -922,8 +922,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                              with private fields\");\n                     }\n                 };\n-                match self.tcx.def_map.borrow().get(&expr.id) {\n-                    Some(&def::DefStruct(did)) => {\n+                match self.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n+                    Some(def::DefStruct(did)) => {\n                         guard(if is_local(did) {\n                             local_def(self.tcx.map.get_parent(did.node))\n                         } else {\n@@ -962,8 +962,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow().get(&pattern.id) {\n-                            Some(&def::DefVariant(_, variant_id, _)) => {\n+                        match self.tcx.def_map.borrow().get(&pattern.id).map(|d| d.full_def()) {\n+                            Some(def::DefVariant(_, variant_id, _)) => {\n                                 for field in fields {\n                                     self.check_field(pattern.span, variant_id,\n                                                      NamedField(field.node.ident.name));\n@@ -1214,7 +1214,7 @@ struct CheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n \n impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n-        let did = match self.tcx.def_map.borrow().get(&path_id).cloned() {\n+        let did = match self.tcx.def_map.borrow().get(&path_id).map(|d| d.full_def()) {\n             // `int` etc. (None doesn't seem to occur.)\n             None | Some(def::DefPrimTy(..)) => return false,\n             Some(def) => def.def_id()"}, {"sha": "aebbe14407380336174b9c85f82bd693b5084dbd", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -68,17 +68,17 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n                                   \"unused import\".to_string());\n         }\n \n-        let (v_priv, t_priv) = match self.last_private.get(&id) {\n-            Some(&LastImport {\n-                value_priv: v,\n-                value_used: _,\n-                type_priv: t,\n-                type_used: _\n-            }) => (v, t),\n-            Some(_) => {\n+        let mut def_map = self.def_map.borrow_mut();\n+        let path_res = if let Some(r) = def_map.get_mut(&id) {\n+            r\n+        } else {\n+            return;\n+        };\n+        let (v_priv, t_priv) = match path_res.last_private {\n+            LastImport { value_priv, type_priv, .. } => (value_priv, type_priv),\n+            _ => {\n                 panic!(\"we should only have LastImport for `use` directives\")\n             }\n-            _ => return,\n         };\n \n         let mut v_used = if self.used_imports.contains(&(id, ValueNS)) {\n@@ -100,10 +100,12 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n             _ => {},\n         }\n \n-        self.last_private.insert(id, LastImport{value_priv: v_priv,\n-                                                value_used: v_used,\n-                                                type_priv: t_priv,\n-                                                type_used: t_used});\n+        path_res.last_private = LastImport {\n+            value_priv: v_priv,\n+            value_used: v_used,\n+            type_priv: t_priv,\n+            type_used: t_used\n+        };\n     }\n }\n "}, {"sha": "265f398d25ca5d881986839828324d87de6a73fc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 204, "deletions": 208, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -934,13 +934,11 @@ struct Resolver<'a, 'tcx:'a> {\n     primitive_type_table: PrimitiveTypeTable,\n \n     def_map: DefMap,\n-    partial_def_map: PartialDefMap,\n     freevars: RefCell<FreevarMap>,\n     freevars_seen: RefCell<NodeMap<NodeSet>>,\n     export_map: ExportMap,\n     trait_map: TraitMap,\n     external_exports: ExternalExports,\n-    last_private: LastPrivateMap,\n \n     // Whether or not to print error messages. Can be set to true\n     // when getting additional info for error message suggestions,\n@@ -1008,15 +1006,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             primitive_type_table: PrimitiveTypeTable::new(),\n \n             def_map: RefCell::new(NodeMap()),\n-            partial_def_map: RefCell::new(NodeMap()),\n             freevars: RefCell::new(NodeMap()),\n             freevars_seen: RefCell::new(NodeMap()),\n             export_map: NodeMap(),\n             trait_map: NodeMap(),\n             used_imports: HashSet::new(),\n             used_crates: HashSet::new(),\n             external_exports: DefIdSet(),\n-            last_private: NodeMap(),\n \n             emit_errors: true,\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n@@ -1574,31 +1570,36 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        let value_private = match import_resolution.value_target {\n-            Some(ref target) => {\n-                let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n-                self.def_map.borrow_mut().insert(directive.id, def);\n-                let did = def.def_id();\n-                if value_used_public {Some(lp)} else {Some(DependsOn(did))}\n-            },\n-            // AllPublic here and below is a dummy value, it should never be used because\n-            // _exists is false.\n-            None => None,\n-        };\n-        let type_private = match import_resolution.type_target {\n-            Some(ref target) => {\n-                let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n-                self.def_map.borrow_mut().insert(directive.id, def);\n-                let did = def.def_id();\n-                if type_used_public {Some(lp)} else {Some(DependsOn(did))}\n-            },\n-            None => None,\n+        let value_def_and_priv = import_resolution.value_target.as_ref().map(|target| {\n+            let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n+            (def, if value_used_public { lp } else { DependsOn(def.def_id()) })\n+        });\n+        let type_def_and_priv = import_resolution.type_target.as_ref().map(|target| {\n+            let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n+            (def, if type_used_public { lp } else { DependsOn(def.def_id()) })\n+        });\n+\n+        let import_lp = LastImport {\n+            value_priv: value_def_and_priv.map(|(_, p)| p),\n+            value_used: Used,\n+            type_priv: type_def_and_priv.map(|(_, p)| p),\n+            type_used: Used\n         };\n \n-        self.last_private.insert(directive.id, LastImport{value_priv: value_private,\n-                                                          value_used: Used,\n-                                                          type_priv: type_private,\n-                                                          type_used: Used});\n+        if let Some((def, _)) = value_def_and_priv {\n+            self.def_map.borrow_mut().insert(directive.id, PathResolution {\n+                base_def: def,\n+                last_private: import_lp,\n+                depth: 0\n+            });\n+        }\n+        if let Some((def, _)) = type_def_and_priv {\n+            self.def_map.borrow_mut().insert(directive.id, PathResolution {\n+                base_def: def,\n+                last_private: import_lp,\n+                depth: 0\n+            });\n+        }\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n@@ -1716,12 +1717,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Record the destination of this import\n-        match containing_module.def_id.get() {\n-            Some(did) => {\n-                self.def_map.borrow_mut().insert(id, DefMod(did));\n-                self.last_private.insert(id, lp);\n-            }\n-            None => {}\n+        if let Some(did) = containing_module.def_id.get() {\n+            self.def_map.borrow_mut().insert(id, PathResolution {\n+                base_def: DefMod(did),\n+                last_private: lp,\n+                depth: 0\n+            });\n         }\n \n         debug!(\"(resolving glob import) successfully resolved import\");\n@@ -2846,8 +2847,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ItemUse(ref view_path) => {\n                 // check for imports shadowing primitive types\n                 if let ast::ViewPathSimple(ident, _) = view_path.node {\n-                    match self.def_map.borrow().get(&item.id) {\n-                        Some(&DefTy(..)) | Some(&DefStruct(..)) | Some(&DefTrait(..)) | None => {\n+                    match self.def_map.borrow().get(&item.id).map(|d| d.full_def()) {\n+                        Some(DefTy(..)) | Some(DefStruct(..)) | Some(DefTrait(..)) | None => {\n                             self.check_if_primitive_type_name(ident.name, item.span);\n                         }\n                         _ => {}\n@@ -2959,30 +2960,28 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                id: NodeId,\n                                trait_path: &Path,\n                                path_depth: usize)\n-                               -> Result<(Def, LastPrivate, usize), ()> {\n-        match self.resolve_path(id, trait_path, path_depth, TypeNS, true) {\n-            Some(def @ (DefTrait(_), _, _)) => {\n-                debug!(\"(resolving trait) found trait def: {:?}\", def);\n-                Ok(def)\n-            }\n-            Some((def, _, _)) => {\n+                               -> Result<PathResolution, ()> {\n+        if let Some(path_res) = self.resolve_path(id, trait_path, path_depth, TypeNS, true) {\n+            if let DefTrait(_) = path_res.base_def {\n+                debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n+                Ok(path_res)\n+            } else {\n                 self.resolve_error(trait_path.span,\n                     &format!(\"`{}` is not a trait\",\n                              self.path_names_to_string(trait_path, path_depth)));\n \n                 // If it's a typedef, give a note\n-                if let DefTy(..) = def {\n+                if let DefTy(..) = path_res.base_def {\n                     self.session.span_note(trait_path.span,\n                                            \"`type` aliases cannot be used for traits\");\n                 }\n                 Err(())\n             }\n-            None => {\n-                let msg = format!(\"use of undeclared trait name `{}`\",\n-                                  self.path_names_to_string(trait_path, path_depth));\n-                self.resolve_error(trait_path.span, &msg[]);\n-                Err(())\n-            }\n+        } else {\n+            let msg = format!(\"use of undeclared trait name `{}`\",\n+                              self.path_names_to_string(trait_path, path_depth));\n+            self.resolve_error(trait_path.span, &msg[]);\n+            Err(())\n         }\n     }\n \n@@ -2995,14 +2994,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 &ast::WherePredicate::BoundPredicate(_) |\n                 &ast::WherePredicate::RegionPredicate(_) => {}\n                 &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n-                    match self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS, true) {\n-                        Some(def @ (DefTyParam(..), _, _)) => {\n-                            self.record_def(eq_pred.id, def);\n-                        }\n-                        _ => {\n-                            self.resolve_error(eq_pred.path.span,\n-                                               \"undeclared associated type\");\n-                        }\n+                    let path_res = self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS, true);\n+                    if let Some(PathResolution { base_def: DefTyParam(..), .. }) = path_res {\n+                        self.record_def(eq_pred.id, path_res.unwrap());\n+                    } else {\n+                        self.resolve_error(eq_pred.path.span, \"undeclared associated type\");\n                     }\n                 }\n             }\n@@ -3028,9 +3024,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut new_val = None;\n         if let Some(ref trait_ref) = *opt_trait_ref {\n             match self.resolve_trait_reference(trait_ref.ref_id, &trait_ref.path, 0) {\n-                Ok(def) => {\n-                    self.record_def(trait_ref.ref_id, def);\n-                    new_val = Some((def.0.def_id(), trait_ref.clone()));\n+                Ok(path_res) => {\n+                    self.record_def(trait_ref.ref_id, path_res);\n+                    new_val = Some((path_res.base_def.def_id(), trait_ref.clone()));\n                 }\n                 Err(_) => { /* error was already reported */ }\n             }\n@@ -3259,23 +3255,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     path.segments.len()\n                 };\n \n-                let mut result = None;\n+                let mut resolution = None;\n                 for depth in 0..max_assoc_types {\n                     self.with_no_errors(|this| {\n-                        result = this.resolve_path(ty.id, path, depth, TypeNS, true);\n+                        resolution = this.resolve_path(ty.id, path, depth, TypeNS, true);\n                     });\n-                    if result.is_some() {\n+                    if resolution.is_some() {\n                         break;\n                     }\n                 }\n-                if let Some((DefMod(_), _, _)) = result {\n+                if let Some(DefMod(_)) = resolution.map(|r| r.base_def) {\n                     // A module is not a valid type.\n-                    result = None;\n+                    resolution = None;\n                 }\n \n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n-                match result {\n+                match resolution {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `{}` \\\n@@ -3338,7 +3334,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 pattern,\n                                 binding_mode,\n                                 \"an enum variant\");\n-                            self.record_def(pattern.id, (def, lp, 0));\n+                            self.record_def(pattern.id, PathResolution {\n+                                base_def: def,\n+                                last_private: lp,\n+                                depth: 0\n+                            });\n                         }\n                         FoundStructOrEnumVariant(..) => {\n                             self.resolve_error(\n@@ -3357,7 +3357,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 pattern,\n                                 binding_mode,\n                                 \"a constant\");\n-                            self.record_def(pattern.id, (def, lp, 0));\n+                            self.record_def(pattern.id, PathResolution {\n+                                base_def: def,\n+                                last_private: lp,\n+                                depth: 0\n+                            });\n                         }\n                         FoundConst(..) => {\n                             self.resolve_error(pattern.span,\n@@ -3374,7 +3378,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // will be able to distinguish variants from\n                             // locals in patterns.\n \n-                            self.record_def(pattern.id, (def, LastMod(AllPublic), 0));\n+                            self.record_def(pattern.id, PathResolution {\n+                                base_def: def,\n+                                last_private: LastMod(AllPublic),\n+                                depth: 0\n+                            });\n \n                             // Add the binding to the local ribs, if it\n                             // doesn't already exist in the bindings list. (We\n@@ -3417,29 +3425,28 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 PatEnum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n-                    match self.resolve_path(pat_id, path, 0, ValueNS, false) {\n-                        Some(def @ (DefVariant(..), _, _)) |\n-                        Some(def @ (DefStruct(..), _, _))  |\n-                        Some(def @ (DefConst(..), _, _)) => {\n-                            self.record_def(pattern.id, def);\n-                        }\n-                        Some((DefStatic(..), _, _)) => {\n-                            self.resolve_error(path.span,\n-                                               \"static variables cannot be \\\n-                                                referenced in a pattern, \\\n-                                                use a `const` instead\");\n-                        }\n-                        Some(_) => {\n-                            self.resolve_error(path.span,\n-                                &format!(\"`{}` is not an enum variant, struct or const\",\n-                                    token::get_ident(\n-                                        path.segments.last().unwrap().identifier)));\n-                        }\n-                        None => {\n-                            self.resolve_error(path.span,\n-                                &format!(\"unresolved enum variant, struct or const `{}`\",\n-                                    token::get_ident(path.segments.last().unwrap().identifier)));\n+                    if let Some(path_res) = self.resolve_path(pat_id, path, 0, ValueNS, false) {\n+                        match path_res.base_def {\n+                            DefVariant(..) | DefStruct(..) | DefConst(..) => {\n+                                self.record_def(pattern.id, path_res);\n+                            }\n+                            DefStatic(..) => {\n+                                self.resolve_error(path.span,\n+                                                   \"static variables cannot be \\\n+                                                    referenced in a pattern, \\\n+                                                    use a `const` instead\");\n+                            }\n+                            _ => {\n+                                self.resolve_error(path.span,\n+                                    &format!(\"`{}` is not an enum variant, struct or const\",\n+                                        token::get_ident(\n+                                            path.segments.last().unwrap().identifier)));\n+                            }\n                         }\n+                    } else {\n+                        self.resolve_error(path.span,\n+                            &format!(\"unresolved enum variant, struct or const `{}`\",\n+                                token::get_ident(path.segments.last().unwrap().identifier)));\n                     }\n                     visit::walk_path(self, path);\n                 }\n@@ -3535,18 +3542,26 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n+    /// Skips `path_depth` trailing segments, which is also reflected in the\n+    /// returned value. See `middle::def::PathResolution` for more info.\n     fn resolve_path(&mut self,\n                     id: NodeId,\n                     path: &Path,\n                     path_depth: usize,\n                     namespace: Namespace,\n-                    check_ribs: bool) -> Option<(Def, LastPrivate, usize)> {\n+                    check_ribs: bool) -> Option<PathResolution> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len()-path_depth];\n \n+        let mk_res = |(def, lp)| PathResolution {\n+            base_def: def,\n+            last_private: lp,\n+            depth: path_depth\n+        };\n+\n         if path.global {\n             let def = self.resolve_crate_relative_path(span, segments, namespace);\n-            return def.map(|(def, lp)| (def, lp, path_depth));\n+            return def.map(mk_res);\n         }\n \n         // Try to find a path to an item in a module.\n@@ -3568,9 +3583,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 _ => ()\n             }\n \n-            def.map(|(def, lp)| (def, lp, path_depth))\n+            def.map(mk_res)\n         } else {\n-            unqualified_def.map(|(def, lp)| (def, lp, path_depth))\n+            unqualified_def.map(mk_res)\n         }\n     }\n \n@@ -3957,10 +3972,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         if allowed == Everything {\n             // Look for a field with the same name in the current self_type.\n-            match self.def_map.borrow().get(&node_id) {\n-                 Some(&DefTy(did, _))\n-                | Some(&DefStruct(did))\n-                | Some(&DefVariant(_, did, _)) => match self.structs.get(&did) {\n+            match self.def_map.borrow().get(&node_id).map(|d| d.full_def()) {\n+                Some(DefTy(did, _)) |\n+                Some(DefStruct(did)) |\n+                Some(DefVariant(_, did, _)) => match self.structs.get(&did) {\n                     None => {}\n                     Some(fields) => {\n                         if fields.iter().any(|&field_name| name == field_name) {\n@@ -4060,27 +4075,27 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     path.segments.len()\n                 };\n \n-                let mut result = self.with_no_errors(|this| {\n+                let mut resolution = self.with_no_errors(|this| {\n                     this.resolve_path(expr.id, path, 0, ValueNS, true)\n                 });\n                 for depth in 1..max_assoc_types {\n-                    if result.is_some() {\n+                    if resolution.is_some() {\n                         break;\n                     }\n                     self.with_no_errors(|this| {\n-                        result = this.resolve_path(expr.id, path, depth, TypeNS, true);\n+                        resolution = this.resolve_path(expr.id, path, depth, TypeNS, true);\n                     });\n                 }\n-                if let Some((DefMod(_), _, _)) = result {\n+                if let Some(DefMod(_)) = resolution.map(|r| r.base_def) {\n                     // A module is not a valid type or value.\n-                    result = None;\n+                    resolution = None;\n                 }\n \n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n-                match result {\n+                if let Some(path_res) = resolution {\n                     // Check if struct variant\n-                    Some((DefVariant(_, _, true), _, 0)) => {\n+                    if let DefVariant(_, _, true) = path_res.base_def {\n                         let path_name = self.path_names_to_string(path, 0);\n                         self.resolve_error(expr.span,\n                                 &format!(\"`{}` is a struct variant name, but \\\n@@ -4092,95 +4107,93 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             &format!(\"Did you mean to write: \\\n                                      `{} {{ /* fields */ }}`?\",\n                                      path_name));\n-                    }\n-                    Some(def) => {\n+                    } else {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `{}`\",\n                                self.path_names_to_string(path, 0));\n \n                         // Partial resolutions will need the set of traits in scope,\n                         // so they can be completed during typeck.\n-                        if def.2 != 0 {\n+                        if path_res.depth != 0 {\n                             let method_name = path.segments.last().unwrap().identifier.name;\n                             let traits = self.search_for_traits_containing_method(method_name);\n                             self.trait_map.insert(expr.id, traits);\n                         }\n \n-                        self.record_def(expr.id, def);\n+                        self.record_def(expr.id, path_res);\n                     }\n-                    None => {\n-                        // Be helpful if the name refers to a struct\n-                        // (The pattern matching def_tys where the id is in self.structs\n-                        // matches on regular structs while excluding tuple- and enum-like\n-                        // structs, which wouldn't result in this error.)\n-                        let path_name = self.path_names_to_string(path, 0);\n-                        match self.with_no_errors(|this|\n-                            this.resolve_path(expr.id, path, 0, TypeNS, false)) {\n-                            Some((DefTy(struct_id, _), _, 0))\n-                              if self.structs.contains_key(&struct_id) => {\n-                                self.resolve_error(expr.span,\n-                                        &format!(\"`{}` is a structure name, but \\\n-                                                  this expression \\\n-                                                  uses it like a function name\",\n-                                                 path_name));\n-\n-                                self.session.span_help(expr.span,\n-                                    &format!(\"Did you mean to write: \\\n-                                             `{} {{ /* fields */ }}`?\",\n-                                             path_name));\n-\n-                            }\n-                            _ => {\n-                                // Keep reporting some errors even if they're ignored above.\n-                                self.resolve_path(expr.id, path, 0, ValueNS, true);\n-\n-                                let mut method_scope = false;\n-                                self.value_ribs.iter().rev().all(|rib| {\n-                                    method_scope = match rib.kind {\n-                                        MethodRibKind => true,\n-                                        ItemRibKind | ConstantItemRibKind => false,\n-                                        _ => return true, // Keep advancing\n-                                    };\n-                                    false // Stop advancing\n-                                });\n+                } else {\n+                    // Be helpful if the name refers to a struct\n+                    // (The pattern matching def_tys where the id is in self.structs\n+                    // matches on regular structs while excluding tuple- and enum-like\n+                    // structs, which wouldn't result in this error.)\n+                    let path_name = self.path_names_to_string(path, 0);\n+                    let type_res = self.with_no_errors(|this| {\n+                        this.resolve_path(expr.id, path, 0, TypeNS, false)\n+                    });\n+                    match type_res.map(|r| r.base_def) {\n+                        Some(DefTy(struct_id, _))\n+                            if self.structs.contains_key(&struct_id) => {\n+                            self.resolve_error(expr.span,\n+                                    &format!(\"`{}` is a structure name, but \\\n+                                                this expression \\\n+                                                uses it like a function name\",\n+                                                path_name));\n+\n+                            self.session.span_help(expr.span,\n+                                &format!(\"Did you mean to write: \\\n+                                            `{} {{ /* fields */ }}`?\",\n+                                            path_name));\n \n-                                if method_scope && &token::get_name(self.self_name)[..]\n-                                                                   == path_name {\n-                                        self.resolve_error(\n-                                            expr.span,\n-                                            \"`self` is not available \\\n-                                             in a static method. Maybe a \\\n-                                             `self` argument is missing?\");\n-                                } else {\n-                                    let last_name = path.segments.last().unwrap().identifier.name;\n-                                    let mut msg = match self.find_fallback_in_self_type(last_name) {\n-                                        NoSuggestion => {\n-                                            // limit search to 5 to reduce the number\n-                                            // of stupid suggestions\n-                                            self.find_best_match_for_name(&path_name, 5)\n-                                                                .map_or(\"\".to_string(),\n-                                                                        |x| format!(\"`{}`\", x))\n-                                        }\n-                                        Field =>\n-                                            format!(\"`self.{}`\", path_name),\n-                                        Method\n-                                        | TraitItem =>\n-                                            format!(\"to call `self.{}`\", path_name),\n-                                        TraitMethod(path_str)\n-                                        | StaticMethod(path_str) =>\n-                                            format!(\"to call `{}::{}`\", path_str, path_name)\n-                                    };\n-\n-                                    if msg.len() > 0 {\n-                                        msg = format!(\". Did you mean {}?\", msg)\n-                                    }\n+                        }\n+                        _ => {\n+                            // Keep reporting some errors even if they're ignored above.\n+                            self.resolve_path(expr.id, path, 0, ValueNS, true);\n+\n+                            let mut method_scope = false;\n+                            self.value_ribs.iter().rev().all(|rib| {\n+                                method_scope = match rib.kind {\n+                                    MethodRibKind => true,\n+                                    ItemRibKind | ConstantItemRibKind => false,\n+                                    _ => return true, // Keep advancing\n+                                };\n+                                false // Stop advancing\n+                            });\n \n+                            if method_scope && &token::get_name(self.self_name)[..]\n+                                                                == path_name {\n                                     self.resolve_error(\n                                         expr.span,\n-                                        &format!(\"unresolved name `{}`{}\",\n-                                                 path_name,\n-                                                 msg));\n+                                        \"`self` is not available \\\n+                                         in a static method. Maybe a \\\n+                                         `self` argument is missing?\");\n+                            } else {\n+                                let last_name = path.segments.last().unwrap().identifier.name;\n+                                let mut msg = match self.find_fallback_in_self_type(last_name) {\n+                                    NoSuggestion => {\n+                                        // limit search to 5 to reduce the number\n+                                        // of stupid suggestions\n+                                        self.find_best_match_for_name(&path_name, 5)\n+                                                            .map_or(\"\".to_string(),\n+                                                                    |x| format!(\"`{}`\", x))\n+                                    }\n+                                    Field => format!(\"`self.{}`\", path_name),\n+                                    Method |\n+                                    TraitItem =>\n+                                        format!(\"to call `self.{}`\", path_name),\n+                                    TraitMethod(path_str) |\n+                                    StaticMethod(path_str) =>\n+                                        format!(\"to call `{}::{}`\", path_str, path_name)\n+                                };\n+\n+                                if msg.len() > 0 {\n+                                    msg = format!(\". Did you mean {}?\", msg)\n                                 }\n+\n+                                self.resolve_error(\n+                                    expr.span,\n+                                    &format!(\"unresolved name `{}`{}\",\n+                                             path_name, msg));\n                             }\n                         }\n                     }\n@@ -4231,7 +4244,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n-                        self.record_def(expr.id, (def, LastMod(AllPublic), 0))\n+                        self.record_def(expr.id, PathResolution {\n+                            base_def: def,\n+                            last_private: LastMod(AllPublic),\n+                            depth: 0\n+                        })\n                     }\n                     Some(_) => {\n                         self.session.span_bug(expr.span,\n@@ -4349,33 +4366,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         found_traits\n     }\n \n-    fn record_def(&mut self,\n-                  node_id: NodeId,\n-                  (def, lp, depth): (Def, LastPrivate, usize)) {\n-        debug!(\"(recording def) recording {:?} for {}, last private {:?}\",\n-                def, node_id, lp);\n-        assert!(match lp {LastImport{..} => false, _ => true},\n+    fn record_def(&mut self, node_id: NodeId, resolution: PathResolution) {\n+        debug!(\"(recording def) recording {:?} for {}\", resolution, node_id);\n+        assert!(match resolution.last_private {LastImport{..} => false, _ => true},\n                 \"Import should only be used for `use` directives\");\n-        self.last_private.insert(node_id, lp);\n \n-        if depth == 0 {\n-            if let Some(prev_def) = self.def_map.borrow_mut().insert(node_id, def) {\n-                let span = self.ast_map.opt_span(node_id).unwrap_or(codemap::DUMMY_SP);\n-                self.session.span_bug(span, &format!(\"path resolved multiple times \\\n-                                                      ({:?} before, {:?} now)\",\n-                                                     prev_def, def));\n-            }\n-        } else {\n-            let def = PartialDef {\n-                base_type: def,\n-                extra_associated_types: (depth - 1) as u32\n-            };\n-            if let Some(prev_def) = self.partial_def_map.borrow_mut().insert(node_id, def) {\n-                let span = self.ast_map.opt_span(node_id).unwrap_or(codemap::DUMMY_SP);\n-                self.session.span_bug(span, &format!(\"path resolved multiple times \\\n-                                                      ({:?} before, {:?} now)\",\n-                                                     prev_def, def));\n-            }\n+        if let Some(prev_res) = self.def_map.borrow_mut().insert(node_id, resolution) {\n+            let span = self.ast_map.opt_span(node_id).unwrap_or(codemap::DUMMY_SP);\n+            self.session.span_bug(span, &format!(\"path resolved multiple times \\\n+                                                  ({:?} before, {:?} now)\",\n+                                                 prev_res, resolution));\n         }\n     }\n \n@@ -4466,12 +4466,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n pub struct CrateMap {\n     pub def_map: DefMap,\n-    pub partial_def_map: PartialDefMap,\n     pub freevars: RefCell<FreevarMap>,\n     pub export_map: ExportMap,\n     pub trait_map: TraitMap,\n     pub external_exports: ExternalExports,\n-    pub last_private_map: LastPrivateMap,\n     pub glob_map: Option<GlobMap>\n }\n \n@@ -4506,12 +4504,10 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n \n     CrateMap {\n         def_map: resolver.def_map,\n-        partial_def_map: resolver.partial_def_map,\n         freevars: resolver.freevars,\n         export_map: resolver.export_map,\n         trait_map: resolver.trait_map,\n         external_exports: resolver.external_exports,\n-        last_private_map: resolver.last_private,\n         glob_map: if resolver.make_glob_map {\n                         Some(resolver.glob_map)\n                     } else {"}, {"sha": "ea346798679c0fdcdcdbd4788ec437729f1229c8", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -218,7 +218,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n                                   ref_id));\n         }\n-        let def = (*self.analysis.ty_cx.def_map.borrow())[ref_id];\n+        let def = self.analysis.ty_cx.def_map.borrow()[ref_id].full_def();\n         match def {\n             def::DefPrimTy(_) => None,\n             _ => Some(def.def_id()),\n@@ -231,7 +231,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n                                              ref_id));\n         }\n-        let def = (*def_map)[ref_id];\n+        let def = def_map[ref_id].full_def();\n         match def {\n             def::DefMod(_) |\n             def::DefForeignMod(_) => Some(recorder::ModRef),\n@@ -792,9 +792,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.span_bug(span,\n                                &format!(\"def_map has no key for {} in visit_expr\", id));\n         }\n-        let def = &(*def_map)[id];\n+        let def = def_map[id].full_def();\n         let sub_span = self.span.span_for_last_ident(span);\n-        match *def {\n+        match def {\n             def::DefUpvar(..) |\n             def::DefLocal(..) |\n             def::DefStatic(..) |\n@@ -866,10 +866,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     &format!(\"Unexpected def kind while looking \\\n                                               up path in `{}`: `{:?}`\",\n                                              self.span.snippet(span),\n-                                             *def)),\n+                                             def)),\n         }\n         // modules or types in the path prefix\n-        match *def {\n+        match def {\n             def::DefMethod(did, _) => {\n                 let ti = ty::impl_or_trait_item(&self.analysis.ty_cx, did);\n                 if let ty::MethodTraitItem(m) = ti {\n@@ -1456,8 +1456,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                    &format!(\"def_map has no key for {} in visit_arm\",\n                                            id));\n             }\n-            let def = &(*def_map)[id];\n-            match *def {\n+            let def = def_map[id].full_def();\n+            match def {\n                 def::DefLocal(id)  => {\n                     let value = if *immut {\n                         self.span.snippet(p.span).to_string()\n@@ -1480,7 +1480,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 def::DefStatic(_, _) => {}\n                 def::DefConst(..) => {}\n                 _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n-                            *def)\n+                            def)\n             }\n         }\n         for &(id, ref path, ref_kind) in &paths_to_process {"}, {"sha": "3e741640117aa14c779d23cdec6a7ece0a269ed0", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -598,7 +598,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n-                let opt_def = tcx.def_map.borrow().get(&cur.id).cloned();\n+                let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n                         let variant = ty::enum_variant_with_id(tcx, enum_id, var_id);\n@@ -725,14 +725,14 @@ fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: uint) -> bool {\n         match pat.node {\n             ast::PatTup(_) => true,\n             ast::PatStruct(..) => {\n-                match tcx.def_map.borrow().get(&pat.id) {\n-                    Some(&def::DefVariant(..)) => false,\n+                match tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                    Some(def::DefVariant(..)) => false,\n                     _ => true,\n                 }\n             }\n             ast::PatEnum(..) | ast::PatIdent(_, _, None) => {\n-                match tcx.def_map.borrow().get(&pat.id) {\n-                    Some(&def::DefStruct(..)) => true,\n+                match tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                    Some(def::DefStruct(..)) => true,\n                     _ => false\n                 }\n             }\n@@ -1282,15 +1282,15 @@ fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool\n             _ => return false\n         },\n         ast::ExprField(ref base, field) => {\n-            let vid = match bcx.tcx().def_map.borrow().get(&base.id) {\n-                Some(&def::DefLocal(vid)) | Some(&def::DefUpvar(vid, _)) => vid,\n+            let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n+                Some(def::DefLocal(vid)) | Some(def::DefUpvar(vid, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::NamedField(field.node.name)))\n         },\n         ast::ExprTupField(ref base, field) => {\n-            let vid = match bcx.tcx().def_map.borrow().get(&base.id) {\n-                Some(&def::DefLocal(vid)) | Some(&def::DefUpvar(vid, _)) => vid,\n+            let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n+                Some(def::DefLocal(vid)) | Some(def::DefUpvar(vid, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::PositionalField(field.node)))\n@@ -1689,7 +1689,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::PatEnum(_, ref sub_pats) => {\n-            let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).cloned();\n+            let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(def::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);"}, {"sha": "d8fc6df2685dd5d9656ee561e0dd9a5565b90371", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -603,7 +603,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n \n     pub fn def(&self, nid: ast::NodeId) -> def::Def {\n         match self.tcx().def_map.borrow().get(&nid) {\n-            Some(v) => v.clone(),\n+            Some(v) => v.full_def(),\n             None => {\n                 self.tcx().sess.bug(&format!(\n                     \"no def associated with node id {}\", nid));"}, {"sha": "6e1d2da02c10185f675faf8c14e58d4ead4eedb7", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -194,7 +194,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Special-case constants to cache a common global for all uses.\n     match expr.node {\n         ast::ExprPath(_) => {\n-            let def = ccx.tcx().def_map.borrow()[expr.id];\n+            let def = ccx.tcx().def_map.borrow()[expr.id].full_def();\n             match def {\n                 def::DefConst(def_id) => {\n                     if !ccx.tcx().adjustments.borrow().contains_key(&expr.id) {\n@@ -582,7 +582,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       _ => break,\n                   }\n               }\n-              let opt_def = cx.tcx().def_map.borrow().get(&cur.id).cloned();\n+              let opt_def = cx.tcx().def_map.borrow().get(&cur.id).map(|d| d.full_def());\n               if let Some(def::DefStatic(def_id, _)) = opt_def {\n                   return get_static_val(cx, def_id, ety);\n               }\n@@ -664,7 +664,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           }\n           ast::ExprPath(_) | ast::ExprQPath(_) => {\n-            let def = cx.tcx().def_map.borrow()[e.id];\n+            let def = cx.tcx().def_map.borrow()[e.id].full_def();\n             match def {\n                 def::DefFn(..) | def::DefMethod(..) => {\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n@@ -701,7 +701,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           }\n           ast::ExprCall(ref callee, ref args) => {\n-              let opt_def = cx.tcx().def_map.borrow().get(&callee.id).cloned();\n+              let opt_def = cx.tcx().def_map.borrow().get(&callee.id).map(|d| d.full_def());\n               let arg_vals = map_list(&args[..]);\n               match opt_def {\n                   Some(def::DefStruct(_)) => {"}, {"sha": "ad96c506c9ddf14333af894780629a2dc254f47b", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -306,11 +306,10 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loop_id = match opt_label {\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n-            match bcx.tcx().def_map.borrow().get(&expr.id) {\n-                Some(&def::DefLabel(loop_id)) => loop_id,\n-                ref r => {\n-                    bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\",\n-                                               r))\n+            match bcx.tcx().def_map.borrow().get(&expr.id).map(|d| d.full_def())  {\n+                Some(def::DefLabel(loop_id)) => loop_id,\n+                r => {\n+                    bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\", r))\n                 }\n             }\n         }"}, {"sha": "80fe2ed8f3af31da7940cea19d60051562cde690", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -1363,7 +1363,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                         ty.repr(tcx)));\n                 }\n                 Some(node_id) => {\n-                    let def = tcx.def_map.borrow()[node_id].clone();\n+                    let def = tcx.def_map.borrow()[node_id].full_def();\n                     match def {\n                         def::DefVariant(enum_id, variant_id, _) => {\n                             let variant_info = ty::enum_variant_with_id("}, {"sha": "982cc1e3792e1a6d4c77578d2d13cfe9b16be9c6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -898,7 +898,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n \n     match ty.node {\n         ast::TyPath(ref path) => {\n-            let def = this.tcx().def_map.borrow().get(&ty.id).cloned();\n+            let def = this.tcx().def_map.borrow().get(&ty.id).map(|d| d.full_def());\n             match def {\n                 Some(def::DefTrait(trait_def_id)) => {\n                     let mut projection_bounds = Vec::new();\n@@ -1303,16 +1303,14 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds)\n         }\n         ast::TyPath(ref path) | ast::TyQPath(ast::QPath { ref path, .. }) => {\n-            let result = if let Some(&d) = tcx.def_map.borrow().get(&ast_ty.id) {\n-                (d, 0)\n-            } else if let Some(d) = tcx.partial_def_map.borrow().get(&ast_ty.id) {\n-                (d.base_type, (d.extra_associated_types + 1) as usize)\n+            let path_res = if let Some(&d) = tcx.def_map.borrow().get(&ast_ty.id) {\n+                d\n             } else {\n                 tcx.sess.span_bug(ast_ty.span,\n                                   &format!(\"unbound path {}\", ast_ty.repr(tcx)))\n             };\n-            let (mut def, max_depth) = result;\n-            let base_ty_end = path.segments.len() - max_depth;\n+            let mut def = path_res.base_def;\n+            let base_ty_end = path.segments.len() - path_res.depth;\n             let opt_self_ty = if let ast::TyQPath(ref qpath) = ast_ty.node {\n                 Some(ast_ty_to_ty(this, rscope, &*qpath.self_type))\n             } else {\n@@ -1324,9 +1322,13 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                                 &path.segments[..base_ty_end],\n                                                 &path.segments[base_ty_end..]);\n \n-            if max_depth != 0 && ty.sty != ty::ty_err {\n+            if path_res.depth != 0 && ty.sty != ty::ty_err {\n                 // Write back the new resolution.\n-                tcx.def_map.borrow_mut().insert(ast_ty.id, def);\n+                tcx.def_map.borrow_mut().insert(ast_ty.id, def::PathResolution {\n+                    base_def: def,\n+                    last_private: path_res.last_private,\n+                    depth: 0\n+                });\n             }\n \n             ty"}, {"sha": "dd2ab6c6b13ca5d5ee273eb59080b04edc962333", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -103,7 +103,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n-            let const_did = tcx.def_map.borrow()[pat.id].clone().def_id();\n+            let const_did = tcx.def_map.borrow()[pat.id].def_id();\n             let const_scheme = ty::lookup_item_type(tcx, const_did);\n             assert!(const_scheme.generics.is_empty());\n             let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n@@ -433,7 +433,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow()[pat.id].clone();\n+    let def = tcx.def_map.borrow()[pat.id].full_def();\n     let (enum_def_id, variant_def_id) = match def {\n         def::DefTrait(_) => {\n             let name = pprust::path_to_string(path);\n@@ -502,7 +502,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow()[pat.id].clone();\n+    let def = tcx.def_map.borrow()[pat.id].full_def();\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n "}, {"sha": "f99e4e4b2ed8a984f8482532353f1d8cde240bbd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -91,7 +91,6 @@ use middle::infer;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::pat_util::{self, pat_id_map};\n-use middle::privacy::{AllPublic, LastMod};\n use middle::region::{self, CodeExtent};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits;\n@@ -3598,21 +3597,23 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n               None\n           };\n \n-          // Helpers to avoid keeping the RefCell borrow for too long.\n-          let get_def = || tcx.def_map.borrow().get(&id).cloned();\n-          let get_partial_def = || tcx.partial_def_map.borrow().get(&id).cloned();\n+          let path_res = if let Some(&d) = tcx.def_map.borrow().get(&id) {\n+              d\n+          } else {\n+              tcx.sess.span_bug(expr.span,\n+                                &format!(\"unbound path {}\", expr.repr(tcx))[])\n+          };\n \n-          if let Some(def) = get_def() {\n+          let mut def = path_res.base_def;\n+          if path_res.depth == 0 {\n               let (scheme, predicates) =\n                   type_scheme_and_predicates_for_def(fcx, expr.span, def);\n               instantiate_path(fcx, &path.segments,\n                                scheme, &predicates,\n-                               None, def, expr.span, id);\n-          } else if let Some(partial) = get_partial_def() {\n-              let mut def = partial.base_type;\n+                               opt_self_ty, def, expr.span, id);\n+          } else {\n               let ty_segments = path.segments.init();\n-              let ty_assoc_num = partial.extra_associated_types as usize;\n-              let base_ty_end = ty_segments.len() - ty_assoc_num;\n+              let base_ty_end = path.segments.len() - path_res.depth;\n               let ty = astconv::finish_resolving_def_to_ty(fcx, fcx, expr.span,\n                                                            PathParamMode::Optional,\n                                                            &mut def,\n@@ -3624,13 +3625,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n               match method::resolve_ufcs(fcx, expr.span, method_name, ty, id) {\n                   Ok((def, lp)) => {\n                       // Write back the new resolution.\n-                      tcx.def_map.borrow_mut().insert(id, def);\n-\n-                      if let LastMod(AllPublic) = lp {\n-                          // Public method, don't change the last private entry.\n-                      } else {\n-                          tcx.last_private_map.borrow_mut().insert(id, lp);\n-                      }\n+                      tcx.def_map.borrow_mut().insert(id, def::PathResolution {\n+                          base_def: def,\n+                          last_private: path_res.last_private.or(lp),\n+                          depth: 0\n+                      });\n \n                       let (scheme, predicates) =\n                           type_scheme_and_predicates_for_def(fcx, expr.span, def);\n@@ -3644,9 +3643,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                       fcx.write_error(id);\n                   }\n               }\n-          } else {\n-              tcx.sess.span_bug(expr.span,\n-                                &format!(\"unbound path {}\", expr.repr(tcx))[])\n           }\n \n           // We always require that the type provided as the value for\n@@ -3882,7 +3878,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprStruct(ref path, ref fields, ref base_expr) => {\n         // Resolve the path.\n-        let def = tcx.def_map.borrow().get(&id).cloned();\n+        let def = tcx.def_map.borrow().get(&id).map(|d| d.full_def());\n         let struct_id = match def {\n             Some(def::DefVariant(enum_id, variant_id, true)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n@@ -5174,8 +5170,8 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     (block_query(b, |e| {\n         match e.node {\n             ast::ExprBreak(Some(_)) => {\n-                match cx.def_map.borrow().get(&e.id) {\n-                    Some(&def::DefLabel(loop_id)) if id == loop_id => true,\n+                match cx.def_map.borrow().get(&e.id).map(|d| d.full_def()) {\n+                    Some(def::DefLabel(loop_id)) if id == loop_id => true,\n                     _ => false,\n                 }\n             }"}, {"sha": "6b1d46aa04df85cc2cf340f8bfde4839df67d673", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -165,7 +165,7 @@ fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n     match tcx.def_map.borrow().get(&id) {\n-        Some(x) => x.clone(),\n+        Some(x) => x.full_def(),\n         _ => {\n             span_fatal!(tcx.sess, sp, E0242, \"internal error looking up a definition\")\n         }"}, {"sha": "24b9d03400cb32275d92e2ae02683c49e55e0e3c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -46,7 +46,7 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Ident>)\n         None => return None,\n     };\n     let def = match tcx.def_map.borrow().get(&id) {\n-        Some(def) => *def,\n+        Some(d) => d.full_def(),\n         None => return None,\n     };\n     let did = def.def_id();"}, {"sha": "0aa1a23ad7e763052bf9bc5da18e8ca5fcee99e3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -2388,7 +2388,7 @@ fn resolve_type(cx: &DocContext,\n     };\n     debug!(\"searching for {} in defmap\", id);\n     let def = match tcx.def_map.borrow().get(&id) {\n-        Some(&k) => k,\n+        Some(k) => k.full_def(),\n         None => panic!(\"unresolved id not in defmap\")\n     };\n \n@@ -2454,7 +2454,7 @@ fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSou\n \n fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<ast::DefId> {\n     cx.tcx_opt().and_then(|tcx| {\n-        tcx.def_map.borrow().get(&id).map(|&def| register_def(cx, def))\n+        tcx.def_map.borrow().get(&id).map(|d| register_def(cx, d.full_def()))\n     })\n }\n "}, {"sha": "3e998166397bc5deb38e2a30bb6497c0da82e63c", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6a9ed792dd2a716ef583a50051a52a17574efc/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=5a6a9ed792dd2a716ef583a50051a52a17574efc", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Some(tcx) => tcx,\n             None => return false\n         };\n-        let def = (*tcx.def_map.borrow())[id].def_id();\n+        let def = tcx.def_map.borrow()[id].def_id();\n         if !ast_util::is_local(def) { return false }\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false"}]}