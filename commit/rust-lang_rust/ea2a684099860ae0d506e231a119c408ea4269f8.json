{"sha": "ea2a684099860ae0d506e231a119c408ea4269f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMmE2ODQwOTk4NjBhZTBkNTA2ZTIzMWExMTljNDA4ZWE0MjY5Zjg=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-02-12T13:33:17Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-02-20T16:47:44Z"}, "message": "Add error codes for errors in libsyntax", "tree": {"sha": "b4a65a5aaef31514a8b702852e55c6a7d0cf557d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4a65a5aaef31514a8b702852e55c6a7d0cf557d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea2a684099860ae0d506e231a119c408ea4269f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea2a684099860ae0d506e231a119c408ea4269f8", "html_url": "https://github.com/rust-lang/rust/commit/ea2a684099860ae0d506e231a119c408ea4269f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea2a684099860ae0d506e231a119c408ea4269f8/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0128be9ad70970829420ed498d2f2943a72e1b62", "url": "https://api.github.com/repos/rust-lang/rust/commits/0128be9ad70970829420ed498d2f2943a72e1b62", "html_url": "https://github.com/rust-lang/rust/commit/0128be9ad70970829420ed498d2f2943a72e1b62"}], "stats": {"total": 126, "additions": 86, "deletions": 40}, "files": [{"sha": "f482b818f7746707b5b3c17e1aa10e0dd5babaa2", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea2a684099860ae0d506e231a119c408ea4269f8/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2a684099860ae0d506e231a119c408ea4269f8/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=ea2a684099860ae0d506e231a119c408ea4269f8", "patch": "@@ -224,4 +224,8 @@ register_diagnostics! {\n     E0555, // malformed feature attribute, expected #![feature(...)]\n     E0556, // malformed feature, expected just one word\n     E0557, // feature has been removed\n+    E0583, // file not found for module\n+    E0584, // file for module `..` found at both .. and ..\n+    E0585, // documentation comment that doesn't document anything\n+    E0586, // inclusive range with no end\n }"}, {"sha": "464d16f53a3a7f01e62b4501b69cd423ef83cb1d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 82, "deletions": 40, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ea2a684099860ae0d506e231a119c408ea4269f8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2a684099860ae0d506e231a119c408ea4269f8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ea2a684099860ae0d506e231a119c408ea4269f8", "patch": "@@ -219,7 +219,7 @@ fn is_ident_or_underscore(t: &token::Token) -> bool {\n pub struct ModulePath {\n     pub name: String,\n     pub path_exists: bool,\n-    pub result: Result<ModulePathSuccess, ModulePathError>,\n+    pub result: Result<ModulePathSuccess, Errors>,\n }\n \n pub struct ModulePathSuccess {\n@@ -233,6 +233,63 @@ pub struct ModulePathError {\n     pub help_msg: String,\n }\n \n+pub enum Errors {\n+    FileNotFoundForModule {\n+        mod_name: String,\n+        default_path: String,\n+        secondary_path: String,\n+        dir_path: String,\n+    },\n+    DuplicatePaths {\n+        mod_name: String,\n+        default_path: String,\n+        secondary_path: String,\n+    },\n+    UselessDocComment,\n+    InclusiveRangeWithNoEnd,\n+}\n+\n+impl Errors {\n+    pub fn span_err<'a>(self, sp: Span, handler: &'a errors::Handler) -> DiagnosticBuilder<'a> {\n+        match self {\n+            Errors::FileNotFoundForModule { ref mod_name,\n+                                            ref default_path,\n+                                            ref secondary_path,\n+                                            ref dir_path } => {\n+                let mut err = struct_span_err!(handler, sp, E0583,\n+                                               \"file not found for module `{}`\", mod_name);\n+                err.help(&format!(\"name the file either {} or {} inside the directory {:?}\",\n+                                  default_path,\n+                                  secondary_path,\n+                                  dir_path));\n+                err\n+            }\n+            Errors::DuplicatePaths { ref mod_name, ref default_path, ref secondary_path } => {\n+                let mut err = struct_span_err!(handler, sp, E0584,\n+                                               \"file for module `{}` found at both {} and {}\",\n+                                               mod_name,\n+                                               default_path,\n+                                               secondary_path);\n+                err.help(\"delete or rename one of them to remove the ambiguity\");\n+                err\n+            }\n+            Errors::UselessDocComment => {\n+                let mut err = struct_span_err!(handler, sp, E0585,\n+                                  \"found a documentation comment that doesn't document anything\");\n+                err.help(\"doc comments must come before what they document, maybe a comment was \\\n+                          intended with `//`?\");\n+                err\n+            }\n+            Errors::InclusiveRangeWithNoEnd => {\n+                let mut err = struct_span_err!(handler, sp, E0586,\n+                                               \"inclusive range with no end\");\n+                err.help(\"inclusive ranges must be bounded at the end (`...b` or `a...b`)\");\n+                err\n+            }\n+        }\n+    }\n+}\n+\n pub enum LhsExpr {\n     NotYetParsed,\n     AttributesParsed(ThinVec<Attribute>),\n@@ -461,10 +518,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 Err(if self.prev_token_kind == PrevTokenKind::DocComment {\n-                    self.span_fatal_help(self.prev_span,\n-                        \"found a documentation comment that doesn't document anything\",\n-                        \"doc comments must come before what they document, maybe a comment was \\\n-                        intended with `//`?\")\n+                        self.span_fatal_err(self.prev_span, Errors::UselessDocComment)\n                     } else {\n                         let mut err = self.fatal(&format!(\"expected identifier, found `{}`\",\n                                                           self.this_token_to_string()));\n@@ -955,6 +1009,9 @@ impl<'a> Parser<'a> {\n     pub fn span_fatal(&self, sp: Span, m: &str) -> DiagnosticBuilder<'a> {\n         self.sess.span_diagnostic.struct_span_fatal(sp, m)\n     }\n+    pub fn span_fatal_err(&self, sp: Span, err: Errors) -> DiagnosticBuilder<'a> {\n+        err.span_err(sp, self.diagnostic())\n+    }\n     pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> DiagnosticBuilder<'a> {\n         let mut err = self.sess.span_diagnostic.struct_span_fatal(sp, m);\n         err.help(help);\n@@ -1944,10 +2001,7 @@ impl<'a> Parser<'a> {\n                     limits: RangeLimits)\n                     -> PResult<'a, ast::ExprKind> {\n         if end.is_none() && limits == RangeLimits::Closed {\n-            Err(self.span_fatal_help(self.span,\n-                                     \"inclusive range with no end\",\n-                                     \"inclusive ranges must be bounded at the end \\\n-                                      (`...b` or `a...b`)\"))\n+            Err(self.span_fatal_err(self.span, Errors::InclusiveRangeWithNoEnd))\n         } else {\n             Ok(ExprKind::Range(start, end, limits))\n         }\n@@ -3862,10 +3916,7 @@ impl<'a> Parser<'a> {\n                     let unused_attrs = |attrs: &[_], s: &mut Self| {\n                         if attrs.len() > 0 {\n                             if s.prev_token_kind == PrevTokenKind::DocComment {\n-                                s.span_err_help(s.prev_span,\n-                                    \"found a documentation comment that doesn't document anything\",\n-                                    \"doc comments must come before what they document, maybe a \\\n-                                    comment was intended with `//`?\");\n+                                self.span_fatal_err(s.prev_span, Errors::UselessDocComment).emit();\n                             } else {\n                                 s.span_err(s.span, \"expected statement after outer attribute\");\n                             }\n@@ -4998,10 +5049,8 @@ impl<'a> Parser<'a> {\n                 self.bump();\n             }\n             token::CloseDelim(token::Brace) => {}\n-            token::DocComment(_) => return Err(self.span_fatal_help(self.span,\n-                        \"found a documentation comment that doesn't document anything\",\n-                        \"doc comments must come before what they document, maybe a comment was \\\n-                        intended with `//`?\")),\n+            token::DocComment(_) => return Err(self.span_fatal_err(self.span,\n+                                                                   Errors::UselessDocComment)),\n             _ => return Err(self.span_fatal_help(self.span,\n                     &format!(\"expected `,`, or `}}`, found `{}`\", self.this_token_to_string()),\n                     \"struct fields should be separated by commas\")),\n@@ -5162,8 +5211,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Returns either a path to a module, or .\n-    pub fn default_submod_path(id: ast::Ident, dir_path: &Path, codemap: &CodeMap) -> ModulePath\n-    {\n+    pub fn default_submod_path(id: ast::Ident, dir_path: &Path, codemap: &CodeMap) -> ModulePath {\n         let mod_name = id.to_string();\n         let default_path_str = format!(\"{}.rs\", mod_name);\n         let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n@@ -5183,19 +5231,16 @@ impl<'a> Parser<'a> {\n                 directory_ownership: DirectoryOwnership::Owned,\n                 warn: false,\n             }),\n-            (false, false) => Err(ModulePathError {\n-                err_msg: format!(\"file not found for module `{}`\", mod_name),\n-                help_msg: format!(\"name the file either {} or {} inside the directory {:?}\",\n-                                  default_path_str,\n-                                  secondary_path_str,\n-                                  dir_path.display()),\n+            (false, false) => Err(Errors::FileNotFoundForModule {\n+                mod_name: mod_name.clone(),\n+                default_path: default_path_str,\n+                secondary_path: secondary_path_str,\n+                dir_path: format!(\"{}\", dir_path.display()),\n             }),\n-            (true, true) => Err(ModulePathError {\n-                err_msg: format!(\"file for module `{}` found at both {} and {}\",\n-                                 mod_name,\n-                                 default_path_str,\n-                                 secondary_path_str),\n-                help_msg: \"delete or rename one of them to remove the ambiguity\".to_owned(),\n+            (true, true) => Err(Errors::DuplicatePaths {\n+                mod_name: mod_name.clone(),\n+                default_path: default_path_str,\n+                secondary_path: secondary_path_str,\n             }),\n         };\n \n@@ -5232,7 +5277,7 @@ impl<'a> Parser<'a> {\n                                   paths.name);\n                 err.span_note(id_sp, &msg);\n             }\n-            return Err(err);\n+            Err(err)\n         } else if let DirectoryOwnership::UnownedViaMod(warn) = self.directory.ownership {\n             if warn {\n                 if let Ok(result) = paths.result {\n@@ -5254,15 +5299,12 @@ impl<'a> Parser<'a> {\n                               &format!(\"... or maybe `use` the module `{}` instead \\\n                                         of possibly redeclaring it\",\n                                        paths.name));\n-                return Err(err);\n+                Err(err)\n             } else {\n-                return Err(err);\n-            };\n-        }\n-\n-        match paths.result {\n-            Ok(succ) => Ok(succ),\n-            Err(err) => Err(self.span_fatal_help(id_sp, &err.err_msg, &err.help_msg)),\n+                Err(err)\n+            }\n+        } else {\n+            paths.result.map_err(|err| self.span_fatal_err(id_sp, err))\n         }\n     }\n "}]}