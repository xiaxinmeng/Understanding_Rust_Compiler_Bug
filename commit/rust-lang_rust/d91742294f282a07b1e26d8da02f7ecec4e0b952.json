{"sha": "d91742294f282a07b1e26d8da02f7ecec4e0b952", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MTc0MjI5NGYyODJhMDdiMWUyNmQ4ZGEwMmY3ZWNlYzRlMGI5NTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-12T17:19:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-14T01:30:07Z"}, "message": "first (functional) version of the auto_serialize syntax ext", "tree": {"sha": "e9a1adbbe9b13706fbe4682a9ed55d8ac0ec3a5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9a1adbbe9b13706fbe4682a9ed55d8ac0ec3a5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d91742294f282a07b1e26d8da02f7ecec4e0b952", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d91742294f282a07b1e26d8da02f7ecec4e0b952", "html_url": "https://github.com/rust-lang/rust/commit/d91742294f282a07b1e26d8da02f7ecec4e0b952", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d91742294f282a07b1e26d8da02f7ecec4e0b952/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06c8acdd3167127170bc7024849d5f89bd9ac70e", "url": "https://api.github.com/repos/rust-lang/rust/commits/06c8acdd3167127170bc7024849d5f89bd9ac70e", "html_url": "https://github.com/rust-lang/rust/commit/06c8acdd3167127170bc7024849d5f89bd9ac70e"}], "stats": {"total": 1395, "additions": 855, "deletions": 540}, "files": [{"sha": "e790c55d11fe2b6d5b1a8e178b976ea0a3f34263", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -31,7 +31,7 @@ export uint, u8, u16, u32, u64;\n export float, f32, f64;\n export box, char, str, ptr, vec, bool;\n export either, option, result, iter;\n-export libc, os, io, run, rand, sys, unsafe, logging;\n+export libc, os, ctypes, io, run, rand, sys, unsafe, logging, serialization;\n export comm, task, future;\n export extfmt;\n export tuple;\n@@ -88,6 +88,7 @@ mod cmath;\n mod sys;\n mod unsafe;\n mod logging;\n+mod serialization;\n \n // Concurrency\n mod comm;"}, {"sha": "40e468a99dbaf9abe8be7ff06df2ae9d392122ce", "filename": "src/libcore/serialization.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibcore%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibcore%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fserialization.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -0,0 +1,116 @@\n+export serializer;\n+export serializer_helpers;\n+export deserializer;\n+export deserializer_helpers;\n+\n+/*\n+Core serialization interfaces.\n+*/\n+\n+iface serializer {\n+    // Primitive types:\n+    fn emit_nil();\n+    fn emit_uint(v: uint);\n+    fn emit_u64(v: u64);\n+    fn emit_u32(v: u32);\n+    fn emit_u16(v: u16);\n+    fn emit_u8(v: u8);\n+    fn emit_int(v: int);\n+    fn emit_i64(v: i64);\n+    fn emit_i32(v: i32);\n+    fn emit_i16(v: i16);\n+    fn emit_i8(v: i8);\n+    fn emit_bool(v: bool);\n+    fn emit_float(v: float);\n+    fn emit_f64(v: f64);\n+    fn emit_f32(v: f32);\n+    fn emit_str(v: str);\n+\n+    // Compound types:\n+    fn emit_enum(name: str, f: fn());\n+    fn emit_enum_variant(v_name: str, v_id: uint, sz: uint, f: fn());\n+    fn emit_enum_variant_arg(idx: uint, f: fn());\n+    fn emit_vec(len: uint, f: fn());\n+    fn emit_vec_elt(idx: uint, f: fn());\n+    fn emit_box(f: fn());\n+    fn emit_uniq(f: fn());\n+    fn emit_rec(f: fn());\n+    fn emit_rec_field(f_name: str, f_idx: uint, f: fn());\n+    fn emit_tup(sz: uint, f: fn());\n+    fn emit_tup_elt(idx: uint, f: fn());\n+}\n+\n+iface deserializer {\n+    // Primitive types:\n+    fn read_nil() -> ();\n+\n+    fn read_uint() -> uint;\n+    fn read_u64() -> u64;\n+    fn read_u32() -> u32;\n+    fn read_u16() -> u16;\n+    fn read_u8() -> u8;\n+\n+    fn read_int() -> int;\n+    fn read_i64() -> i64;\n+    fn read_i32() -> i32;\n+    fn read_i16() -> i16;\n+    fn read_i8() -> i8;\n+\n+\n+    fn read_bool() -> bool;\n+\n+    fn read_str() -> str;\n+\n+    fn read_f64() -> f64;\n+    fn read_f32() -> f32;\n+    fn read_float() -> float;\n+\n+    // Compound types:\n+    fn read_enum<T:copy>(name: str, f: fn() -> T) -> T;\n+    fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T;\n+    fn read_enum_variant_arg<T:copy>(idx: uint, f: fn() -> T) -> T;\n+    fn read_vec<T:copy>(f: fn(uint) -> T) -> T;\n+    fn read_vec_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n+    fn read_box<T:copy>(f: fn() -> T) -> T;\n+    fn read_uniq<T:copy>(f: fn() -> T) -> T;\n+    fn read_rec<T:copy>(f: fn() -> T) -> T;\n+    fn read_rec_field<T:copy>(f_name: str, f_idx: uint, f: fn() -> T) -> T;\n+    fn read_tup<T:copy>(sz: uint, f: fn() -> T) -> T;\n+    fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n+}\n+\n+// ___________________________________________________________________________\n+// Helper routines\n+//\n+// These should eventually be coded as traits.\n+\n+fn emit_from_vec<S: serializer, T>(s: S, v: [T], f: fn(T)) {\n+    s.emit_vec(vec::len(v)) {||\n+        vec::iteri(v) {|i,e|\n+            s.emit_vec_elt(i) {||\n+                f(e)\n+            }\n+        }\n+    }\n+}\n+\n+fn read_to_vec<D: deserializer, T>(d: D, f: fn() -> T) -> [T] {\n+    d.read_vec {|len|\n+        vec::init_fn(len) {|i|\n+            d.read_vec_elt(i) {|| f() }\n+        }\n+    }\n+}\n+\n+impl serializer_helpers<S: serializer> for S {\n+    fn emit_from_vec<T>(v: [T], f: fn(T)) {\n+        emit_from_vec(self, v, f)\n+    }\n+}\n+\n+impl deserializer_helpers<D: deserializer> for D {\n+    fn read_to_vec<T>(f: fn() -> T) -> [T] {\n+        read_to_vec(self, f)\n+    }\n+}\n+"}, {"sha": "e466717657d58721b3707b270851e979fd0756b6", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -192,6 +192,14 @@ fn compl(i: uint) -> uint {\n     max_value ^ i\n }\n \n+fn serialize<S: serialization::serializer>(s: S, v: uint) {\n+    s.emit_uint(v);\n+}\n+\n+fn deserialize<D: serialization::deserializer>(d: D) -> uint {\n+    d.read_uint()\n+}\n+\n #[cfg(test)]\n mod tests {\n "}, {"sha": "72ae981d36b34bd8254a0ff68b347a1cf5d2fa3c", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -406,7 +406,7 @@ fn map<T, U>(v: [T], f: fn(T) -> U) -> [U] {\n }\n \n fn flat_map<T, U>(v: [T], f: fn(T) -> [U]) -> [U] {\n-    let result = [];\n+    let mut result = [];\n     for elem: T in v { result += f(elem); }\n     ret result;\n }"}, {"sha": "203e7e12ad032a3829b7e330f0cacdaa63c809bb", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -25,6 +25,9 @@ export doc_as_i16;\n export doc_as_i32;\n export doc_as_i64;\n export writer;\n+export serializer;\n+export ebml_deserializer;\n+export deserializer;\n \n type ebml_tag = {id: uint, size: uint};\n \n@@ -273,3 +276,314 @@ impl writer for writer {\n \n // TODO: optionally perform \"relaxations\" on end_tag to more efficiently\n // encode sizes; this is a fixed point iteration\n+\n+// Set to true to generate more debugging in EBML serialization.\n+// Totally lame approach.\n+const debug: bool = true;\n+\n+enum ebml_serializer_tag {\n+    es_uint, es_u64, es_u32, es_u16, es_u8,\n+    es_int, es_i64, es_i32, es_i16, es_i8,\n+    es_bool,\n+    es_str,\n+    es_f64, es_f32, es_float,\n+    es_enum, es_enum_vid, es_enum_body,\n+    es_vec, es_vec_len, es_vec_elt,\n+\n+    es_label // Used only when debugging\n+}\n+\n+impl serializer of core::serialization::serializer for ebml::writer {\n+    fn emit_nil() {}\n+\n+    // used internally to emit things like the vector length and so on\n+    fn _emit_tagged_uint(t: ebml_serializer_tag, v: uint) {\n+        assert v <= 0xFFFF_FFFF_u;\n+        self.wr_tagged_u32(t as uint, v as u32);\n+    }\n+\n+    fn _emit_label(label: str) {\n+        // There are various strings that we have access to, such as\n+        // the name of a record field, which do not actually appear in\n+        // the serialized EBML (normally).  This is just for\n+        // efficiency.  When debugging, though, we can emit such\n+        // labels and then they will be checked by deserializer to\n+        // try and check failures more quickly.\n+        if debug { self.wr_tagged_str(es_label as uint, label) }\n+    }\n+\n+    fn emit_uint(v: uint) { self.wr_tagged_u64(es_uint as uint, v as u64); }\n+    fn emit_u64(v: u64) { self.wr_tagged_u64(es_u64 as uint, v); }\n+    fn emit_u32(v: u32) { self.wr_tagged_u32(es_u32 as uint, v); }\n+    fn emit_u16(v: u16) { self.wr_tagged_u16(es_u16 as uint, v); }\n+    fn emit_u8(v: u8)   { self.wr_tagged_u8 (es_u8  as uint, v); }\n+\n+    fn emit_int(v: int) { self.wr_tagged_i64(es_int as uint, v as i64); }\n+    fn emit_i64(v: i64) { self.wr_tagged_i64(es_i64 as uint, v); }\n+    fn emit_i32(v: i32) { self.wr_tagged_i32(es_i32 as uint, v); }\n+    fn emit_i16(v: i16) { self.wr_tagged_i16(es_i16 as uint, v); }\n+    fn emit_i8(v: i8)   { self.wr_tagged_i8 (es_i8  as uint, v); }\n+\n+    fn emit_bool(v: bool) { self.wr_tagged_u8(es_bool as uint, v as u8) }\n+\n+    fn emit_f64(_v: f64) { fail \"TODO\"; }\n+    fn emit_f32(_v: f32) { fail \"TODO\"; }\n+    fn emit_float(_v: float) { fail \"TODO\"; }\n+\n+    fn emit_str(v: str) { self.wr_tagged_str(es_str as uint, v) }\n+\n+    fn emit_enum(name: str, f: fn()) {\n+        self._emit_label(name);\n+        self.wr_tag(es_enum as uint, f)\n+    }\n+    fn emit_enum_variant(_v_name: str, v_id: uint, _cnt: uint, f: fn()) {\n+        self._emit_tagged_uint(es_enum_vid, v_id);\n+        self.wr_tag(es_enum_body as uint, f)\n+    }\n+    fn emit_enum_variant_arg(_idx: uint, f: fn()) { f() }\n+\n+    fn emit_vec(len: uint, f: fn()) {\n+        self.wr_tag(es_vec as uint) {||\n+            self._emit_tagged_uint(es_vec_len, len);\n+            f()\n+        }\n+    }\n+\n+    fn emit_vec_elt(_idx: uint, f: fn()) {\n+        self.wr_tag(es_vec_elt as uint, f)\n+    }\n+\n+    fn emit_box(f: fn()) { f() }\n+    fn emit_uniq(f: fn()) { f() }\n+    fn emit_rec(f: fn()) { f() }\n+    fn emit_rec_field(f_name: str, _f_idx: uint, f: fn()) {\n+        self._emit_label(f_name);\n+        f()\n+    }\n+    fn emit_tup(_sz: uint, f: fn()) { f() }\n+    fn emit_tup_elt(_idx: uint, f: fn()) { f() }\n+}\n+\n+type ebml_deserializer = {mutable parent: ebml::doc,\n+                          mutable pos: uint};\n+\n+fn ebml_deserializer(d: ebml::doc) -> ebml_deserializer {\n+    {mutable parent: d, mutable pos: d.start}\n+}\n+\n+impl deserializer of core::serialization::deserializer for ebml_deserializer {\n+    fn _check_label(lbl: str) {\n+        if self.pos < self.parent.end {\n+            let {tag: r_tag, doc: r_doc} =\n+                ebml::doc_at(self.parent.data, self.pos);\n+            if r_tag == (es_label as uint) {\n+                self.pos = r_doc.end;\n+                let str = ebml::doc_as_str(r_doc);\n+                if lbl != str {\n+                    fail #fmt[\"Expected label %s but found %s\", lbl, str];\n+                }\n+            }\n+        }\n+    }\n+\n+    fn next_doc(exp_tag: ebml_serializer_tag) -> ebml::doc {\n+        #debug[\". next_doc(exp_tag=%?)\", exp_tag];\n+        if self.pos >= self.parent.end {\n+            fail \"no more documents in current node!\";\n+        }\n+        let {tag: r_tag, doc: r_doc} =\n+            ebml::doc_at(self.parent.data, self.pos);\n+        #debug[\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n+               self.parent.start, self.parent.end, self.pos,\n+               r_tag, r_doc.start, r_doc.end];\n+        if r_tag != (exp_tag as uint) {\n+            fail #fmt[\"expected EMBL doc with tag %? but found tag %?\",\n+                      exp_tag, r_tag];\n+        }\n+        if r_doc.end > self.parent.end {\n+            fail #fmt[\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n+                      r_doc.end, self.parent.end];\n+        }\n+        self.pos = r_doc.end;\n+        ret r_doc;\n+    }\n+\n+    fn push_doc<T: copy>(d: ebml::doc, f: fn() -> T) -> T{\n+        let old_parent = self.parent;\n+        let old_pos = self.pos;\n+        self.parent = d;\n+        self.pos = d.start;\n+        let r = f();\n+        self.parent = old_parent;\n+        self.pos = old_pos;\n+        ret r;\n+    }\n+\n+    fn _next_uint(exp_tag: ebml_serializer_tag) -> uint {\n+        let r = ebml::doc_as_u32(self.next_doc(exp_tag));\n+        #debug[\"_next_uint exp_tag=%? result=%?\", exp_tag, r];\n+        ret r as uint;\n+    }\n+\n+    fn read_nil() -> () { () }\n+\n+    fn read_u64() -> u64 { ebml::doc_as_u64(self.next_doc(es_u64)) }\n+    fn read_u32() -> u32 { ebml::doc_as_u32(self.next_doc(es_u32)) }\n+    fn read_u16() -> u16 { ebml::doc_as_u16(self.next_doc(es_u16)) }\n+    fn read_u8 () -> u8  { ebml::doc_as_u8 (self.next_doc(es_u8 )) }\n+    fn read_uint() -> uint {\n+        let v = ebml::doc_as_u64(self.next_doc(es_uint));\n+        if v > (core::uint::max_value as u64) {\n+            fail #fmt[\"uint %? too large for this architecture\", v];\n+        }\n+        ret v as uint;\n+    }\n+\n+    fn read_i64() -> i64 { ebml::doc_as_u64(self.next_doc(es_i64)) as i64 }\n+    fn read_i32() -> i32 { ebml::doc_as_u32(self.next_doc(es_i32)) as i32 }\n+    fn read_i16() -> i16 { ebml::doc_as_u16(self.next_doc(es_i16)) as i16 }\n+    fn read_i8 () -> i8  { ebml::doc_as_u8 (self.next_doc(es_i8 )) as i8  }\n+    fn read_int() -> int {\n+        let v = ebml::doc_as_u64(self.next_doc(es_int)) as i64;\n+        if v > (int::max_value as i64) || v < (int::min_value as i64) {\n+            fail #fmt[\"int %? out of range for this architecture\", v];\n+        }\n+        ret v as int;\n+    }\n+\n+    fn read_bool() -> bool { ebml::doc_as_u8(self.next_doc(es_bool)) as bool }\n+\n+    fn read_f64() -> f64 { fail \"read_f64()\"; }\n+    fn read_f32() -> f32 { fail \"read_f32()\"; }\n+    fn read_float() -> float { fail \"read_float()\"; }\n+\n+    fn read_str() -> str { ebml::doc_as_str(self.next_doc(es_str)) }\n+\n+    // Compound types:\n+    fn read_enum<T:copy>(name: str, f: fn() -> T) -> T {\n+        #debug[\"read_enum(%s)\", name];\n+        self._check_label(name);\n+        self.push_doc(self.next_doc(es_enum), f)\n+    }\n+\n+    fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T {\n+        #debug[\"read_enum_variant()\"];\n+        let idx = self._next_uint(es_enum_vid);\n+        #debug[\"  idx=%u\", idx];\n+        self.push_doc(self.next_doc(es_enum_body)) {||\n+            f(idx)\n+        }\n+    }\n+\n+    fn read_enum_variant_arg<T:copy>(idx: uint, f: fn() -> T) -> T {\n+        #debug[\"read_enum_variant_arg(idx=%u)\", idx];\n+        f()\n+    }\n+\n+    fn read_vec<T:copy>(f: fn(uint) -> T) -> T {\n+        #debug[\"read_vec()\"];\n+        self.push_doc(self.next_doc(es_vec)) {||\n+            let len = self._next_uint(es_vec_len);\n+            #debug[\"  len=%u\", len];\n+            f(len)\n+        }\n+    }\n+\n+    fn read_vec_elt<T:copy>(idx: uint, f: fn() -> T) -> T {\n+        #debug[\"read_vec_elt(idx=%u)\", idx];\n+        self.push_doc(self.next_doc(es_vec_elt), f)\n+    }\n+\n+    fn read_box<T:copy>(f: fn() -> T) -> T {\n+        #debug[\"read_box()\"];\n+        f()\n+    }\n+\n+    fn read_uniq<T:copy>(f: fn() -> T) -> T {\n+        #debug[\"read_uniq()\"];\n+        f()\n+    }\n+\n+    fn read_rec<T:copy>(f: fn() -> T) -> T {\n+        #debug[\"read_rec()\"];\n+        f()\n+    }\n+\n+    fn read_rec_field<T:copy>(f_name: str, f_idx: uint, f: fn() -> T) -> T {\n+        #debug[\"read_rec_field(%s, idx=%u)\", f_name, f_idx];\n+        self._check_label(f_name);\n+        f()\n+    }\n+\n+    fn read_tup<T:copy>(sz: uint, f: fn() -> T) -> T {\n+        #debug[\"read_tup(sz=%u)\", sz];\n+        f()\n+    }\n+\n+    fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T {\n+        #debug[\"read_tup_elt(idx=%u)\", idx];\n+        f()\n+    }\n+}\n+\n+\n+// ___________________________________________________________________________\n+// Testing\n+\n+#[test]\n+fn test_option_int() {\n+    fn serialize_1<S: serialization::serializer>(s: S, v: int) {\n+        s.emit_i64(v as i64);\n+    }\n+\n+    fn serialize_0<S: serialization::serializer>(s: S, v: option<int>) {\n+        s.emit_enum(\"core::option::t\") {||\n+            alt v {\n+              none {\n+                s.emit_enum_variant(\"core::option::none\", 0u, 0u) {||}\n+              }\n+              some(v0) {\n+                s.emit_enum_variant(\"core::option::some\", 1u, 1u) {||\n+                    s.emit_enum_variant_arg(0u) {|| serialize_1(s, v0) }\n+                }\n+              }\n+            }\n+        }\n+    }\n+\n+    fn deserialize_1<S: serialization::deserializer>(s: S) -> int {\n+        s.read_i64() as int\n+    }\n+\n+    fn deserialize_0<S: serialization::deserializer>(s: S) -> option<int> {\n+        s.read_enum(\"core::option::t\") {||\n+            s.read_enum_variant {|i|\n+                alt check i {\n+                  0u { none }\n+                  1u {\n+                    let v0 = s.read_enum_variant_arg(0u) {||\n+                        deserialize_1(s)\n+                    };\n+                    some(v0)\n+                  }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn test_v(v: option<int>) {\n+        #debug[\"v == %?\", v];\n+        let mbuf = io::mem_buffer();\n+        let ebml_w = ebml::writer(io::mem_buffer_writer(mbuf));\n+        serialize_0(ebml_w, v);\n+        let ebml_doc = ebml::new_doc(@io::mem_buffer_buf(mbuf));\n+        let deser = ebml_deserializer(ebml_doc);\n+        let v1 = deserialize_0(deser);\n+        #debug[\"v1 == %?\", v1];\n+        assert v == v1;\n+    }\n+\n+    test_v(some(22));\n+    test_v(none);\n+    test_v(some(3));\n+}"}, {"sha": "10d971ff0f2037d815f655d75accd098ce96d0ad", "filename": "src/libstd/prettyprint.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -0,0 +1,130 @@\n+import io::writer;\n+import io::writer_util;\n+import serialization::serializer;\n+\n+impl of serializer for writer {\n+    fn emit_nil() {\n+        self.write_str(\"()\")\n+    }\n+\n+    fn emit_uint(v: uint) {\n+        self.write_str(#fmt[\"%?u\", v]);\n+    }\n+\n+    fn emit_u64(v: u64) {\n+        self.write_str(#fmt[\"%?_u64\", v]);\n+    }\n+\n+    fn emit_u32(v: u32) {\n+        self.write_str(#fmt[\"%?_u32\", v]);\n+    }\n+\n+    fn emit_u16(v: u16) {\n+        self.write_str(#fmt[\"%?_u16\", v]);\n+    }\n+\n+    fn emit_u8(v: u8) {\n+        self.write_str(#fmt[\"%?_u8\", v]);\n+    }\n+\n+    fn emit_int(v: int) {\n+        self.write_str(#fmt[\"%?\", v]);\n+    }\n+\n+    fn emit_i64(v: i64) {\n+        self.write_str(#fmt[\"%?_i64\", v]);\n+    }\n+\n+    fn emit_i32(v: i32) {\n+        self.write_str(#fmt[\"%?_i32\", v]);\n+    }\n+\n+    fn emit_i16(v: i16) {\n+        self.write_str(#fmt[\"%?_i16\", v]);\n+    }\n+\n+    fn emit_i8(v: i8) {\n+        self.write_str(#fmt[\"%?_i8\", v]);\n+    }\n+\n+    fn emit_bool(v: bool) {\n+        self.write_str(#fmt[\"%b\", v]);\n+    }\n+\n+    fn emit_float(v: float) {\n+        self.write_str(#fmt[\"%?_f\", v]);\n+    }\n+\n+    fn emit_f64(v: f64) {\n+        self.write_str(#fmt[\"%?_f64\", v]);\n+    }\n+\n+    fn emit_f32(v: f32) {\n+        self.write_str(#fmt[\"%?_f32\", v]);\n+    }\n+\n+    fn emit_str(v: str) {\n+        self.write_str(#fmt[\"%?\", v]);\n+    }\n+\n+    fn emit_enum(_name: str, f: fn()) {\n+        f();\n+    }\n+\n+    fn emit_enum_variant(v_name: str, _v_id: uint, _sz: uint, f: fn()) {\n+        self.write_str(v_name);\n+        self.write_str(\"(\");\n+        f();\n+        self.write_str(\")\");\n+    }\n+\n+    fn emit_enum_variant_arg(idx: uint, f: fn()) {\n+        if idx > 0u { self.write_str(\", \"); }\n+        f();\n+    }\n+\n+    fn emit_vec(_len: uint, f: fn()) {\n+        self.write_str(\"[\");\n+        f();\n+        self.write_str(\"]\");\n+    }\n+\n+    fn emit_vec_elt(idx: uint, f: fn()) {\n+        if idx > 0u { self.write_str(\", \"); }\n+        f();\n+    }\n+\n+    fn emit_box(f: fn()) {\n+        self.write_str(\"@\");\n+        f();\n+    }\n+\n+    fn emit_uniq(f: fn()) {\n+        self.write_str(\"~\");\n+        f();\n+    }\n+\n+    fn emit_rec(f: fn()) {\n+        self.write_str(\"{\");\n+        f();\n+        self.write_str(\"}\");\n+    }\n+\n+    fn emit_rec_field(f_name: str, f_idx: uint, f: fn()) {\n+        if f_idx > 0u { self.write_str(\", \"); }\n+        self.write_str(f_name);\n+        self.write_str(\": \");\n+        f();\n+    }\n+\n+    fn emit_tup(_sz: uint, f: fn()) {\n+        self.write_str(\"(\");\n+        f();\n+        self.write_str(\")\");\n+    }\n+\n+    fn emit_tup_elt(idx: uint, f: fn()) {\n+        if idx > 0u { self.write_str(\", \"); }\n+        f();\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "fe70247e01b16d9e2571b2ded20773cfba4779bb", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 4, "deletions": 413, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -1,416 +1,7 @@\n-#[doc = \"Support code for serialization.\"];\n+#[doc = \"Support code for serialization.\n \n+Deprecated in favor of core::serialization.\"];\n+\n+use core;\n import list::list;\n import ebml::writer;\n-\n-// Set to true to generate more debugging in EBML serialization.\n-// Totally lame approach.\n-const debug: bool = true;\n-\n-iface serializer {\n-    // Primitive types:\n-    fn emit_nil();\n-    fn emit_uint(v: uint);\n-    fn emit_u64(v: u64);\n-    fn emit_u32(v: u32);\n-    fn emit_u16(v: u16);\n-    fn emit_u8(v: u8);\n-    fn emit_int(v: int);\n-    fn emit_i64(v: i64);\n-    fn emit_i32(v: i32);\n-    fn emit_i16(v: i16);\n-    fn emit_i8(v: i8);\n-    fn emit_bool(v: bool);\n-    fn emit_float(v: float);\n-    fn emit_f64(v: f64);\n-    fn emit_f32(v: f32);\n-    fn emit_str(v: str);\n-\n-    // Compound types:\n-    fn emit_enum(name: str, f: fn());\n-    fn emit_enum_variant(v_name: str, v_id: uint, sz: uint, f: fn());\n-    fn emit_enum_variant_arg(idx: uint, f: fn());\n-    fn emit_vec(len: uint, f: fn());\n-    fn emit_vec_elt(idx: uint, f: fn());\n-    fn emit_box(f: fn());\n-    fn emit_uniq(f: fn());\n-    fn emit_rec(f: fn());\n-    fn emit_rec_field(f_name: str, f_idx: uint, f: fn());\n-    fn emit_tup(sz: uint, f: fn());\n-    fn emit_tup_elt(idx: uint, f: fn());\n-}\n-\n-iface deserializer {\n-    // Primitive types:\n-    fn read_nil() -> ();\n-\n-    fn read_uint() -> uint;\n-    fn read_u64() -> u64;\n-    fn read_u32() -> u32;\n-    fn read_u16() -> u16;\n-    fn read_u8() -> u8;\n-\n-    fn read_int() -> int;\n-    fn read_i64() -> i64;\n-    fn read_i32() -> i32;\n-    fn read_i16() -> i16;\n-    fn read_i8() -> i8;\n-\n-\n-    fn read_bool() -> bool;\n-\n-    fn read_str() -> str;\n-\n-    fn read_f64() -> f64;\n-    fn read_f32() -> f32;\n-    fn read_float() -> float;\n-\n-    // Compound types:\n-    fn read_enum<T:copy>(name: str, f: fn() -> T) -> T;\n-    fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T;\n-    fn read_enum_variant_arg<T:copy>(idx: uint, f: fn() -> T) -> T;\n-    fn read_vec<T:copy>(f: fn(uint) -> T) -> T;\n-    fn read_vec_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n-    fn read_box<T:copy>(f: fn() -> T) -> T;\n-    fn read_uniq<T:copy>(f: fn() -> T) -> T;\n-    fn read_rec<T:copy>(f: fn() -> T) -> T;\n-    fn read_rec_field<T:copy>(f_name: str, f_idx: uint, f: fn() -> T) -> T;\n-    fn read_tup<T:copy>(sz: uint, f: fn() -> T) -> T;\n-    fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n-}\n-\n-enum ebml_serializer_tag {\n-    es_uint, es_u64, es_u32, es_u16, es_u8,\n-    es_int, es_i64, es_i32, es_i16, es_i8,\n-    es_bool,\n-    es_str,\n-    es_f64, es_f32, es_float,\n-    es_enum, es_enum_vid, es_enum_body,\n-    es_vec, es_vec_len, es_vec_elt,\n-\n-    es_label // Used only when debugging\n-}\n-\n-impl of serializer for ebml::writer {\n-    fn emit_nil() {}\n-\n-    // used internally to emit things like the vector length and so on\n-    fn _emit_tagged_uint(t: ebml_serializer_tag, v: uint) {\n-        assert v <= 0xFFFF_FFFF_u;\n-        self.wr_tagged_u32(t as uint, v as u32);\n-    }\n-\n-    fn _emit_label(label: str) {\n-        // There are various strings that we have access to, such as\n-        // the name of a record field, which do not actually appear in\n-        // the serialized EBML (normally).  This is just for\n-        // efficiency.  When debugging, though, we can emit such\n-        // labels and then they will be checked by deserializer to\n-        // try and check failures more quickly.\n-        if debug { self.wr_tagged_str(es_label as uint, label) }\n-    }\n-\n-    fn emit_uint(v: uint) { self.wr_tagged_u64(es_uint as uint, v as u64); }\n-    fn emit_u64(v: u64) { self.wr_tagged_u64(es_u64 as uint, v); }\n-    fn emit_u32(v: u32) { self.wr_tagged_u32(es_u32 as uint, v); }\n-    fn emit_u16(v: u16) { self.wr_tagged_u16(es_u16 as uint, v); }\n-    fn emit_u8(v: u8)   { self.wr_tagged_u8 (es_u8  as uint, v); }\n-\n-    fn emit_int(v: int) { self.wr_tagged_i64(es_int as uint, v as i64); }\n-    fn emit_i64(v: i64) { self.wr_tagged_i64(es_i64 as uint, v); }\n-    fn emit_i32(v: i32) { self.wr_tagged_i32(es_i32 as uint, v); }\n-    fn emit_i16(v: i16) { self.wr_tagged_i16(es_i16 as uint, v); }\n-    fn emit_i8(v: i8)   { self.wr_tagged_i8 (es_i8  as uint, v); }\n-\n-    fn emit_bool(v: bool) { self.wr_tagged_u8(es_bool as uint, v as u8) }\n-\n-    fn emit_f64(_v: f64) { fail \"TODO\"; }\n-    fn emit_f32(_v: f32) { fail \"TODO\"; }\n-    fn emit_float(_v: float) { fail \"TODO\"; }\n-\n-    fn emit_str(v: str) { self.wr_tagged_str(es_str as uint, v) }\n-\n-    fn emit_enum(name: str, f: fn()) {\n-        self._emit_label(name);\n-        self.wr_tag(es_enum as uint, f)\n-    }\n-    fn emit_enum_variant(_v_name: str, v_id: uint, _cnt: uint, f: fn()) {\n-        self._emit_tagged_uint(es_enum_vid, v_id);\n-        self.wr_tag(es_enum_body as uint, f)\n-    }\n-    fn emit_enum_variant_arg(_idx: uint, f: fn()) { f() }\n-\n-    fn emit_vec(len: uint, f: fn()) {\n-        self.wr_tag(es_vec as uint) {||\n-            self._emit_tagged_uint(es_vec_len, len);\n-            f()\n-        }\n-    }\n-\n-    fn emit_vec_elt(_idx: uint, f: fn()) {\n-        self.wr_tag(es_vec_elt as uint, f)\n-    }\n-\n-    fn emit_box(f: fn()) { f() }\n-    fn emit_uniq(f: fn()) { f() }\n-    fn emit_rec(f: fn()) { f() }\n-    fn emit_rec_field(f_name: str, _f_idx: uint, f: fn()) {\n-        self._emit_label(f_name);\n-        f()\n-    }\n-    fn emit_tup(_sz: uint, f: fn()) { f() }\n-    fn emit_tup_elt(_idx: uint, f: fn()) { f() }\n-}\n-\n-type ebml_deserializer = {mutable parent: ebml::doc,\n-                          mutable pos: uint};\n-\n-fn ebml_deserializer(d: ebml::doc) -> ebml_deserializer {\n-    {mutable parent: d, mutable pos: d.start}\n-}\n-\n-impl of deserializer for ebml_deserializer {\n-    fn _check_label(lbl: str) {\n-        if self.pos < self.parent.end {\n-            let {tag: r_tag, doc: r_doc} =\n-                ebml::doc_at(self.parent.data, self.pos);\n-            if r_tag == (es_label as uint) {\n-                self.pos = r_doc.end;\n-                let str = ebml::doc_as_str(r_doc);\n-                if lbl != str {\n-                    fail #fmt[\"Expected label %s but found %s\", lbl, str];\n-                }\n-            }\n-        }\n-    }\n-\n-    fn next_doc(exp_tag: ebml_serializer_tag) -> ebml::doc {\n-        #debug[\". next_doc(exp_tag=%?)\", exp_tag];\n-        if self.pos >= self.parent.end {\n-            fail \"no more documents in current node!\";\n-        }\n-        let {tag: r_tag, doc: r_doc} =\n-            ebml::doc_at(self.parent.data, self.pos);\n-        #debug[\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n-               self.parent.start, self.parent.end, self.pos,\n-               r_tag, r_doc.start, r_doc.end];\n-        if r_tag != (exp_tag as uint) {\n-            fail #fmt[\"expected EMBL doc with tag %? but found tag %?\",\n-                      exp_tag, r_tag];\n-        }\n-        if r_doc.end > self.parent.end {\n-            fail #fmt[\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n-                      r_doc.end, self.parent.end];\n-        }\n-        self.pos = r_doc.end;\n-        ret r_doc;\n-    }\n-\n-    fn push_doc<T: copy>(d: ebml::doc, f: fn() -> T) -> T{\n-        let old_parent = self.parent;\n-        let old_pos = self.pos;\n-        self.parent = d;\n-        self.pos = d.start;\n-        let r = f();\n-        self.parent = old_parent;\n-        self.pos = old_pos;\n-        ret r;\n-    }\n-\n-    fn _next_uint(exp_tag: ebml_serializer_tag) -> uint {\n-        let r = ebml::doc_as_u32(self.next_doc(exp_tag));\n-        #debug[\"_next_uint exp_tag=%? result=%?\", exp_tag, r];\n-        ret r as uint;\n-    }\n-\n-    fn read_nil() -> () { () }\n-\n-    fn read_u64() -> u64 { ebml::doc_as_u64(self.next_doc(es_u64)) }\n-    fn read_u32() -> u32 { ebml::doc_as_u32(self.next_doc(es_u32)) }\n-    fn read_u16() -> u16 { ebml::doc_as_u16(self.next_doc(es_u16)) }\n-    fn read_u8 () -> u8  { ebml::doc_as_u8 (self.next_doc(es_u8 )) }\n-    fn read_uint() -> uint {\n-        let v = ebml::doc_as_u64(self.next_doc(es_uint));\n-        if v > (uint::max_value as u64) {\n-            fail #fmt[\"uint %? too large for this architecture\", v];\n-        }\n-        ret v as uint;\n-    }\n-\n-    fn read_i64() -> i64 { ebml::doc_as_u64(self.next_doc(es_i64)) as i64 }\n-    fn read_i32() -> i32 { ebml::doc_as_u32(self.next_doc(es_i32)) as i32 }\n-    fn read_i16() -> i16 { ebml::doc_as_u16(self.next_doc(es_i16)) as i16 }\n-    fn read_i8 () -> i8  { ebml::doc_as_u8 (self.next_doc(es_i8 )) as i8  }\n-    fn read_int() -> int {\n-        let v = ebml::doc_as_u64(self.next_doc(es_int)) as i64;\n-        if v > (int::max_value as i64) || v < (int::min_value as i64) {\n-            fail #fmt[\"int %? out of range for this architecture\", v];\n-        }\n-        ret v as int;\n-    }\n-\n-    fn read_bool() -> bool { ebml::doc_as_u8(self.next_doc(es_bool)) as bool }\n-\n-    fn read_f64() -> f64 { fail \"read_f64()\"; }\n-    fn read_f32() -> f32 { fail \"read_f32()\"; }\n-    fn read_float() -> float { fail \"read_float()\"; }\n-\n-    fn read_str() -> str { ebml::doc_as_str(self.next_doc(es_str)) }\n-\n-    // Compound types:\n-    fn read_enum<T:copy>(name: str, f: fn() -> T) -> T {\n-        #debug[\"read_enum(%s)\", name];\n-        self._check_label(name);\n-        self.push_doc(self.next_doc(es_enum), f)\n-    }\n-\n-    fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T {\n-        #debug[\"read_enum_variant()\"];\n-        let idx = self._next_uint(es_enum_vid);\n-        #debug[\"  idx=%u\", idx];\n-        self.push_doc(self.next_doc(es_enum_body)) {||\n-            f(idx)\n-        }\n-    }\n-\n-    fn read_enum_variant_arg<T:copy>(idx: uint, f: fn() -> T) -> T {\n-        #debug[\"read_enum_variant_arg(idx=%u)\", idx];\n-        f()\n-    }\n-\n-    fn read_vec<T:copy>(f: fn(uint) -> T) -> T {\n-        #debug[\"read_vec()\"];\n-        self.push_doc(self.next_doc(es_vec)) {||\n-            let len = self._next_uint(es_vec_len);\n-            #debug[\"  len=%u\", len];\n-            f(len)\n-        }\n-    }\n-\n-    fn read_vec_elt<T:copy>(idx: uint, f: fn() -> T) -> T {\n-        #debug[\"read_vec_elt(idx=%u)\", idx];\n-        self.push_doc(self.next_doc(es_vec_elt), f)\n-    }\n-\n-    fn read_box<T:copy>(f: fn() -> T) -> T {\n-        #debug[\"read_box()\"];\n-        f()\n-    }\n-\n-    fn read_uniq<T:copy>(f: fn() -> T) -> T {\n-        #debug[\"read_uniq()\"];\n-        f()\n-    }\n-\n-    fn read_rec<T:copy>(f: fn() -> T) -> T {\n-        #debug[\"read_rec()\"];\n-        f()\n-    }\n-\n-    fn read_rec_field<T:copy>(f_name: str, f_idx: uint, f: fn() -> T) -> T {\n-        #debug[\"read_rec_field(%s, idx=%u)\", f_name, f_idx];\n-        self._check_label(f_name);\n-        f()\n-    }\n-\n-    fn read_tup<T:copy>(sz: uint, f: fn() -> T) -> T {\n-        #debug[\"read_tup(sz=%u)\", sz];\n-        f()\n-    }\n-\n-    fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T {\n-        #debug[\"read_tup_elt(idx=%u)\", idx];\n-        f()\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Helper routines\n-//\n-// These should eventually be coded as traits.\n-\n-impl serializer_helpers<S: serializer> for S {\n-    fn emit_from_vec<T>(v: [T], f: fn(T)) {\n-        self.emit_vec(vec::len(v)) {||\n-            vec::iteri(v) {|i,e|\n-                self.emit_vec_elt(i) {||\n-                    f(e)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl deserializer_helpers<D: deserializer> for D {\n-    fn read_to_vec<T>(f: fn() -> T) -> [T] {\n-        self.read_vec {|len|\n-            let v = [];\n-            vec::reserve(v, len);\n-            uint::range(0u, len) {|i|\n-                self.read_vec_elt(i) {|| v += [f()] }\n-            }\n-            v\n-        }\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Testing\n-\n-#[test]\n-fn test_option_int() {\n-    fn serialize_1<S: serializer>(s: S, v: int) {\n-        s.emit_i64(v as i64);\n-    }\n-\n-    fn serialize_0<S: serializer>(s: S, v: option<int>) {\n-        s.emit_enum(\"core::option::t\") {||\n-            alt v {\n-              none {\n-                s.emit_enum_variant(\"core::option::none\", 0u, 0u) {||}\n-              }\n-              some(v0) {\n-                s.emit_enum_variant(\"core::option::some\", 1u, 1u) {||\n-                    s.emit_enum_variant_arg(0u) {|| serialize_1(s, v0) }\n-                }\n-              }\n-            }\n-        }\n-    }\n-\n-    fn deserialize_1<S: deserializer>(s: S) -> int {\n-        s.read_i64() as int\n-    }\n-\n-    fn deserialize_0<S: deserializer>(s: S) -> option<int> {\n-        s.read_enum(\"core::option::t\") {||\n-            s.read_enum_variant {|i|\n-                alt check i {\n-                  0u { none }\n-                  1u {\n-                    let v0 = s.read_enum_variant_arg(0u) {||\n-                        deserialize_1(s)\n-                    };\n-                    some(v0)\n-                  }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn test_v(v: option<int>) {\n-        #debug[\"v == %?\", v];\n-        let mbuf = io::mk_mem_buffer();\n-        let ebml_w = ebml::writer(io::mem_buffer_writer(mbuf));\n-        serialize_0(ebml_w, v);\n-        let ebml_doc = ebml::new_doc(@io::mem_buffer_buf(mbuf));\n-        let deser = ebml_deserializer(ebml_doc);\n-        let v1 = deserialize_0(deser);\n-        #debug[\"v1 == %?\", v1];\n-        assert v == v1;\n-    }\n-\n-    test_v(some(22));\n-    test_v(none);\n-    test_v(some(3));\n-}"}, {"sha": "0f11b8533d235c06e8b3256cb668d3f47b8ea9e7", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -12,7 +12,7 @@ export net, uv;\n export c_vec, four, tri, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n export rope;\n-export ebml, dbg, getopts, json, rand, sha1, term, time;\n+export ebml, dbg, getopts, json, rand, sha1, term, time, prettyprint;\n export test, tempfile, serialization;\n \n \n@@ -55,6 +55,7 @@ mod md4;\n mod tempfile;\n mod term;\n mod time;\n+mod prettyprint;\n \n #[cfg(unicode)]\n mod unicode;"}, {"sha": "71f39a77e362987fb5087a6dacf81d6c5e1f49ae", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -15,7 +15,8 @@ import io::{reader_util, writer_util};\n import getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n import back::{x86, x86_64};\n \n-enum pp_mode { ppm_normal, ppm_expanded, ppm_typed, ppm_identified, }\n+enum pp_mode {ppm_normal, ppm_expanded, ppm_typed, ppm_identified,\n+              ppm_expanded_identified }\n \n fn default_configuration(sess: session, argv0: str, input: str) ->\n    ast::crate_cfg {\n@@ -253,7 +254,7 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: str,\n     // from stdin, we're going to just suck the source into a string\n     // so both the parser and pretty-printer can use it.\n     let upto = alt ppm {\n-      ppm_expanded { cu_expand }\n+      ppm_expanded | ppm_expanded_identified { cu_expand }\n       ppm_typed { cu_typeck }\n       _ { cu_parse }\n     };\n@@ -265,7 +266,7 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: str,\n         ann = {pre: ann_paren_for_expr,\n                post: bind ann_typed_post(option::get(tcx), _)};\n       }\n-      ppm_identified {\n+      ppm_identified | ppm_expanded_identified {\n         ann = {pre: ann_paren_for_expr, post: ann_identified_post};\n       }\n       ppm_expanded | ppm_normal {}\n@@ -498,7 +499,11 @@ fn parse_pretty(sess: session, &&name: str) -> pp_mode {\n         ret ppm_expanded;\n     } else if str::eq(name, \"typed\") {\n         ret ppm_typed;\n-    } else if str::eq(name, \"identified\") { ret ppm_identified; }\n+    } else if str::eq(name, \"expanded,identified\") {\n+        ret ppm_expanded_identified;\n+    } else if str::eq(name, \"identified\") {\n+        ret ppm_identified;\n+    }\n     sess.fatal(\"argument to `pretty` must be one of `normal`, `typed`, or \" +\n                    \"`identified`\");\n }"}, {"sha": "f09b4f902fd34a15fd3b8fe4a8b873fe2a1f35e9", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -6,12 +6,13 @@ import syntax::ast_util::inlined_item_methods;\n import syntax::codemap::span;\n import std::ebml;\n import std::ebml::writer;\n+import std::ebml::serializer;\n+import std::ebml::deserializer;\n import std::map::hashmap;\n-import std::serialization;\n-import std::serialization::serializer;\n-import std::serialization::deserializer;\n-import std::serialization::serializer_helpers;\n-import std::serialization::deserializer_helpers;\n+import serialization::serializer;\n+import serialization::deserializer;\n+import serialization::serializer_helpers;\n+import serialization::deserializer_helpers;\n import std::smallintmap::map;\n import middle::trans::common::maps;\n import middle::{ty, typeck, last_use, ast_map};\n@@ -243,7 +244,7 @@ fn encode_id_range(ebml_w: ebml::writer, id_range: id_range) {\n \n fn decode_id_range(par_doc: ebml::doc) -> id_range {\n     let range_doc = par_doc[c::tag_id_range];\n-    let dsr = serialization::ebml_deserializer(range_doc);\n+    let dsr = ebml::ebml_deserializer(range_doc);\n     dsr.read_tup(2u) {||\n         {min: dsr.read_tup_elt(0u) {|| dsr.read_int() },\n          max: dsr.read_tup_elt(1u) {|| dsr.read_int() }}\n@@ -368,7 +369,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n \n fn decode_ast(par_doc: ebml::doc) -> ast::inlined_item {\n     let chi_doc = par_doc[c::tag_tree];\n-    let d = serialization::ebml_deserializer(chi_doc);\n+    let d = ebml::ebml_deserializer(chi_doc);\n     astencode_gen::deserialize_syntax_ast_inlined_item(d)\n }\n \n@@ -398,7 +399,7 @@ fn encode_def(ebml_w: ebml::writer, def: ast::def) {\n }\n \n fn decode_def(xcx: extended_decode_ctxt, doc: ebml::doc) -> ast::def {\n-    let dsr = serialization::ebml_deserializer(doc);\n+    let dsr = ebml::ebml_deserializer(doc);\n     let def = astencode_gen::deserialize_syntax_ast_def(dsr);\n     def.tr(xcx)\n }\n@@ -445,7 +446,7 @@ fn encode_freevar_entry(ebml_w: ebml::writer, fv: freevar_entry) {\n     astencode_gen::serialize_middle_freevars_freevar_entry(ebml_w, fv)\n }\n \n-impl helper for serialization::ebml_deserializer {\n+impl helper for ebml::ebml_deserializer {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry {\n         let fv =\n             astencode_gen::deserialize_middle_freevars_freevar_entry(self);\n@@ -466,7 +467,7 @@ fn encode_method_origin(ebml_w: ebml::writer, mo: method_origin) {\n     astencode_gen::serialize_middle_typeck_method_origin(ebml_w, mo)\n }\n \n-impl helper for serialization::ebml_deserializer {\n+impl helper for ebml::ebml_deserializer {\n     fn read_method_origin(xcx: extended_decode_ctxt) -> method_origin {\n         let fv = astencode_gen::deserialize_middle_typeck_method_origin(self);\n         fv.tr(xcx)\n@@ -559,7 +560,7 @@ fn encode_dict_origin(ecx: @e::encode_ctxt,\n \n }\n \n-impl helpers for serialization::ebml_deserializer {\n+impl helpers for ebml::ebml_deserializer {\n     fn read_dict_res(xcx: extended_decode_ctxt) -> typeck::dict_res {\n         @self.read_to_vec {|| self.read_dict_origin(xcx) }\n     }\n@@ -800,7 +801,7 @@ impl decoder for ebml::doc {\n     }\n }\n \n-impl decoder for serialization::ebml_deserializer {\n+impl decoder for ebml::ebml_deserializer {\n     fn read_ty(xcx: extended_decode_ctxt) -> ty::t {\n         tydecode::parse_ty_data(\n             self.parent.data, xcx.dcx.cdata.cnum, self.pos, xcx.dcx.tcx,\n@@ -850,7 +851,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             dcx.maps.copy_map.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val];\n-            let val_dsr = serialization::ebml_deserializer(val_doc);\n+            let val_dsr = ebml::ebml_deserializer(val_doc);\n             if tag == (c::tag_table_def as uint) {\n                 let def = decode_def(xcx, val_doc);\n                 dcx.tcx.def_map.insert(id, def);\n@@ -903,7 +904,7 @@ fn encode_item_ast(ebml_w: ebml::writer, item: @ast::item) {\n #[cfg(test)]\n fn decode_item_ast(par_doc: ebml::doc) -> @ast::item {\n     let chi_doc = par_doc[c::tag_tree];\n-    let d = serialization::ebml_deserializer(chi_doc);\n+    let d = ebml::ebml_deserializer(chi_doc);\n     @astencode_gen::deserialize_syntax_ast_item(d)\n }\n "}, {"sha": "a61c88cad4a84655951238eafa244f926e57260c", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -306,6 +306,9 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         for ast_ty: @ast::ty in args {\n             param_bindings += [do_ast_ty_to_ty(tcx, use_site, mode, ast_ty)];\n         }\n+        #debug(\"substituting(%s into %s)\",\n+               str::concat(vec::map(param_bindings, {|t| ty_to_str(tcx, t)})),\n+               ty_to_str(tcx, ty_param_bounds_and_ty.ty));\n         let typ =\n             ty::substitute_type_params(tcx, param_bindings,\n                                        ty_param_bounds_and_ty.ty);"}, {"sha": "b06bf81e5a7c5ce249d4694e9ddc52ed90fc4120", "filename": "src/rustc/syntax/ext/auto_serialize.rs", "status": "modified", "additions": 163, "deletions": 106, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -82,26 +82,39 @@ import base::*;\n import driver::session::session;\n import codemap::span;\n import std::map;\n+import std::map::hashmap;\n+import front::attr;\n \n-export expand_auto_serialize;\n+export expand;\n \n-enum ser_cx = {\n+enum ser_cx = @{\n     ext_cx: ext_ctxt,\n-    tps: map::map<str, fn@(@ast::expr) -> [@ast::stmt]>\n+    tps: map::hashmap<str, fn@(@ast::expr) -> [@ast::stmt]>\n };\n \n-fn expand_auto_serialize(cx: ext_ctxt,\n-                         span: span,\n-                         _mitem: ast::meta_item,\n-                         in_items: [@ast::item]) -> [@ast::item] {\n+fn expand(cx: ext_ctxt,\n+          span: span,\n+          _mitem: ast::meta_item,\n+          in_items: [@ast::item]) -> [@ast::item] {\n+    fn not_auto_serialize(a: ast::attribute) -> bool {\n+        attr::get_attr_name(a) != \"auto_serialize\"\n+    }\n+\n+    fn filter_attrs(item: @ast::item) -> @ast::item {\n+        @{attrs: vec::filter(item.attrs, not_auto_serialize)\n+          with *item}\n+    }\n+\n     vec::flat_map(in_items) {|in_item|\n         alt in_item.node {\n           ast::item_ty(ty, tps) {\n-            [in_item, ty_module(cx, in_item.ident, copy ty, tps)]\n+            [filter_attrs(in_item),\n+             ty_module(cx, in_item.ident, ty, tps)]\n           }\n \n           ast::item_enum(variants, tps) {\n-            [in_item, enum_module(cx, in_item.ident, variants, tps)]\n+            [filter_attrs(in_item),\n+             enum_module(cx, in_item.ident, in_item.span, variants, tps)]\n           }\n \n           _ {\n@@ -118,9 +131,7 @@ impl helpers for ext_ctxt {\n     fn next_id() -> ast::node_id { self.session().next_node_id() }\n \n     fn path(span: span, strs: [str]) -> @ast::path {\n-        @{node: {global: false,\n-                 idents: strs + [\"serialize\"],\n-                 types: []},\n+        @{node: {global: false, idents: strs, types: []},\n           span: span}\n     }\n \n@@ -140,6 +151,28 @@ impl helpers for ser_cx {\n         self.ext_cx.ty_path(span, strs)\n     }\n \n+    fn ty_fn(span: span,\n+             -input_tys: [@ast::ty],\n+             -output: @ast::ty) -> @ast::ty {\n+        let args = vec::map(input_tys) {|ty|\n+            {mode: ast::expl(ast::by_ref),\n+             ty: ty,\n+             ident: \"\",\n+             id: self.next_id()}\n+        };\n+\n+        @{node: ast::ty_fn(ast::proto_any, {inputs: args,\n+                                            output: output,\n+                                            purity: ast::impure_fn,\n+                                            cf: ast::return_val,\n+                                            constraints: []}),\n+          span: span}\n+    }\n+\n+    fn ty_nil(span: span) -> @ast::ty {\n+        @{node: ast::ty_nil, span: span}\n+    }\n+\n     fn expr(span: span, node: ast::expr_) -> @ast::expr {\n         @{id: self.next_id(), node: node, span: span}\n     }\n@@ -195,8 +228,9 @@ impl helpers for ser_cx {\n                   span: span}))\n     }\n \n-    fn lambda(-blk: @ast::blk) -> @ast::expr {\n-        let blk_e = cx.expr(blk.span, expr_block(blk));\n+    fn lambda(blk: ast::blk) -> @ast::expr {\n+        let ext_cx = self;\n+        let blk_e = self.expr(blk.span, ast::expr_block(blk));\n         #ast(expr){{|| $(blk_e) }}\n     }\n \n@@ -208,6 +242,14 @@ impl helpers for ser_cx {\n         fld.fold_expr(v)\n     }\n \n+    fn clone_ty(v: @ast::ty) -> @ast::ty {\n+        let fld = fold::make_fold({\n+            new_id: {|_id| self.next_id()}\n+            with *fold::default_ast_fold()\n+        });\n+        fld.fold_ty(v)\n+    }\n+\n     fn clone_ty_param(v: ast::ty_param) -> ast::ty_param {\n         let fld = fold::make_fold({\n             new_id: {|_id| self.next_id()}\n@@ -249,23 +291,26 @@ fn serialize_path(cx: ser_cx, path: @ast::path,\n                 cx.path(path.span, path.node.idents + [\"serialize\"])));\n \n     let ty_args = vec::map(path.node.types) {|ty|\n-        let sv = serialize_ty(cx, ty, s, #ast(expr){\"__v\"});\n-        cx.at(ty.span, #ast(expr){\"{|__v| $(sv)}\"})\n+        let sv_stmts = serialize_ty(cx, ty, cx.clone(s), #ast(expr){__v});\n+        let sv = cx.expr(path.span,\n+                         ast::expr_block(cx.blk(path.span,\n+                                                sv_stmts)));\n+        cx.at(ty.span, #ast(expr){{|__v| $(sv)}})\n     };\n \n     [cx.stmt(\n         cx.expr(\n             path.span,\n-            ast::expr_call(callee, [s] + ty_args + [v], false)))]\n+            ast::expr_call(callee, [s, v] + ty_args, false)))]\n }\n \n fn serialize_variant(cx: ser_cx,\n                      tys: [@ast::ty],\n                      span: span,\n                      -s: @ast::expr,\n                      pfn: fn([@ast::pat]) -> ast::pat_,\n-                     bodyfn: fn(-@ast::expr, @ast::blk) -> @ast::expr,\n-                     argfn: fn(-@ast::expr, uint, @ast::blk) -> @ast::expr)\n+                     bodyfn: fn(-@ast::expr, ast::blk) -> @ast::expr,\n+                     argfn: fn(-@ast::expr, uint, ast::blk) -> @ast::expr)\n     -> ast::arm {\n     let vnames = vec::init_fn(vec::len(tys)) {|i| #fmt[\"__v%u\", i]};\n     let pats = vec::init_fn(vec::len(tys)) {|i|\n@@ -281,34 +326,59 @@ fn serialize_variant(cx: ser_cx,\n         cx.stmt(argfn(cx.clone(s), i, arg_blk))\n     };\n \n-    let body_blk = cx.blk(span, vec::concat(stmts));\n+    let body_blk = cx.blk(span, stmts);\n     let body = cx.blk(span, [cx.stmt(bodyfn(s, body_blk))]);\n \n     {pats: [pat], guard: none, body: body}\n }\n \n fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n     -> [@ast::stmt] {\n+\n+    fn ty_lambda(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n+        -> @ast::expr {\n+        cx.lambda(cx.blk(ty.span, serialize_ty(cx, ty, s, v)))\n+    }\n+\n+\n     let ext_cx = cx.ext_cx;\n \n     alt ty.node {\n       ast::ty_nil | ast::ty_bot {\n         []\n       }\n \n-      ast::ty_box(mt) |\n-      ast::ty_uniq(mt) |\n-      ast::ty_ptr(mt) {\n-        serialize_ty(cx, mt.ty, s, #ast(expr){\"*$(v)\"})\n+      ast::ty_box(mt) {\n+        let l = ty_lambda(cx, mt.ty, cx.clone(s), #ast(expr){*$(v)});\n+        [#ast(stmt){$(s).emit_box($(l));}]\n+      }\n+\n+      ast::ty_uniq(mt) {\n+        let l = ty_lambda(cx, mt.ty, cx.clone(s), #ast(expr){*$(v)});\n+        [#ast(stmt){$(s).emit_uniq($(l));}]\n+      }\n+\n+      ast::ty_ptr(_) | ast::ty_rptr(_, _) {\n+        cx.session().span_err(\n+            ty.span, #fmt[\"Cannot serialize pointer types\"]);\n+        []\n       }\n \n       ast::ty_rec(flds) {\n-        vec::flat_map(flds) {|fld|\n-            let vf = cx.expr(\n-                fld.span,\n-                ast::expr_field(cx.clone(v), fld.node.ident, []));\n-            serialize_ty(cx, fld.node.mt.ty, cx.clone(s), vf)\n-        }\n+        let fld_stmts = vec::init_fn(vec::len(flds)) {|fidx|\n+            let fld = flds[fidx];\n+            let vf = cx.expr(fld.span,\n+                             ast::expr_field(cx.clone(v),\n+                                             fld.node.ident,\n+                                             []));\n+            let s = cx.clone(s);\n+            let f = cx.lit_str(fld.span, fld.node.ident);\n+            let i = cx.lit_uint(fld.span, fidx);\n+            let l = ty_lambda(cx, fld.node.mt.ty, cx.clone(s), vf);\n+            #ast(stmt){$(s).emit_rec_field($(f), $(i), $(l));}\n+        };\n+        let fld_lambda = cx.lambda(cx.blk(ty.span, fld_stmts));\n+        [#ast(stmt){$(s).emit_rec($(fld_lambda));}]\n       }\n \n       ast::ty_fn(_, _) {\n@@ -335,7 +405,7 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n                 {|pats| ast::pat_tup(pats)},\n \n                 // Generate body s.emit_tup(3, {|| blk })\n-                {|-s, -blk|\n+                {|-s, blk|\n                     let sz = cx.lit_uint(ty.span, vec::len(tys));\n                     let body = cx.lambda(blk);\n                     #ast[expr]{\n@@ -344,7 +414,7 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n                 },\n \n                 // Generate s.emit_tup_elt(i, {|| blk })\n-                {|-s, i, -blk|\n+                {|-s, i, blk|\n                     let idx = cx.lit_uint(ty.span, i);\n                     let body = cx.lambda(blk);\n                     #ast[expr]{\n@@ -399,57 +469,55 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n                                 ty.span,\n                                 #ast(expr){__e})))));\n \n-        [cx.stmt(\n-            cx.expr(\n-                ty.span,\n-                ast::expr_call(\n-                    #ast(expr){$(s).emit_from_vec},\n-                    [#ast(expr){{|__e| $(ser_e)}}],\n-                    false)))]\n+        [#ast(stmt){\n+            core::serialization::emit_from_vec($(s), $(v), {|__e| $(ser_e) })\n+        }]\n       }\n     }\n }\n \n fn mk_ser_fn(ext_cx: ext_ctxt, span: span,\n-             -v_ty: @ast::ty, tps: [ast::ty_param],\n+             v_ty: @ast::ty, tps: [ast::ty_param],\n              f: fn(ser_cx, @ast::ty, -@ast::expr, -@ast::expr) -> [@ast::stmt])\n     -> @ast::item {\n \n-    let cx = ser_cx({ext_cx: ext_cx, tps: map::new_str_hash()});\n+    let cx = ser_cx(@{ext_cx: ext_cx, tps: map::new_str_hash()});\n \n     let tp_inputs =\n         vec::map(tps, {|tp|\n             {mode: ast::expl(ast::by_ref),\n-             ty: cx.ty_path(span, [tp.ident]),\n+             ty: cx.ty_fn(span,\n+                          [cx.ty_path(span, [tp.ident])],\n+                          cx.ty_nil(span)),\n              ident: \"__s\" + tp.ident,\n              id: cx.next_id()}});\n \n+    #debug[\"tp_inputs = %?\", tp_inputs];\n+\n     let ser_inputs: [ast::arg] =\n         [{mode: ast::expl(ast::by_ref),\n           ty: cx.ty_path(span, [\"__S\"]),\n           ident: \"__s\",\n           id: cx.next_id()},\n          {mode: ast::expl(ast::by_ref),\n-          ty: v_ty,\n+          ty: cx.clone_ty(v_ty),\n           ident: \"__v\",\n           id: cx.next_id()}]\n         + tp_inputs;\n \n-    vec::iter2(tps, ser_inputs) {|tp, arg|\n+    vec::iter2(tps, tp_inputs) {|tp, arg|\n         let arg_ident = arg.ident;\n         cx.tps.insert(\n             tp.ident,\n             fn@(v: @ast::expr) -> [@ast::stmt] {\n                 let f = cx.var_ref(span, arg_ident);\n-                [cx.stmt(\n-                    cx.expr(\n-                        span,\n-                        ast::expr_call(f, [v], false)))]\n+                #debug[\"serializing type arg %s\", arg_ident];\n+                [#ast(stmt){$(f)($(v));}]\n             });\n     }\n \n     let ser_bnds = @[ast::bound_iface(cx.ty_path(span,\n-                                                 [\"__std\", \"serialization\",\n+                                                 [\"serialization\",\n                                                   \"serializer\"]))];\n \n     let ser_tps: [ast::ty_param] =\n@@ -462,7 +530,7 @@ fn mk_ser_fn(ext_cx: ext_ctxt, span: span,\n                                  span: span};\n \n     let ser_blk = cx.blk(span,\n-                         f(cx, v_ty, #ast(expr){\"__s\"}, #ast(expr){\"__v\"}));\n+                         f(cx, v_ty, #ast(expr){__s}, #ast(expr){__v}));\n \n     @{ident: \"serialize\",\n       attrs: [],\n@@ -477,7 +545,7 @@ fn mk_ser_fn(ext_cx: ext_ctxt, span: span,\n       span: span}\n }\n \n-fn ty_module(ext_cx: ext_ctxt, name: str, -ty: @ast::ty, tps: [ast::ty_param])\n+fn ty_module(ext_cx: ext_ctxt, name: str, ty: @ast::ty, tps: [ast::ty_param])\n     -> @ast::item {\n \n     let span = ty.span;\n@@ -497,62 +565,51 @@ fn enum_module(ext_cx: ext_ctxt, name: str, span: span,\n                variants: [ast::variant], tps: [ast::ty_param])\n     -> @ast::item {\n \n-    let span = ty.span;\n     let ty = ext_cx.ty_path(span, [name]);\n-    let ser_fn = mk_ser_fn(ext_cx, span, ty, tps) {|cx, ty, s, v|\n-        let arms = vec::init_fn(vec::len(variants)) {|vidx|\n-            let variant = variants[vidx];\n-\n-            if vec::is_empty(variant.args) {\n-                // degenerate case.\n-                let pat = {id: cx.next_id(),\n-                           node: ast::pat_ident(cx.path(variant.ident), none),\n-                           Span: variant.span};\n-                //#ast(expr){\n-                //    $(s).emit_enum_variant(X, Y, SZ) {||\n-                //    };\n-                //}\n-            }\n-\n-            let variant_tys = vec::map(variant.args) {|a| a.ty };\n-\n-            serialize_variant(\n-                cx, variant_tys, variant.span, cx.clone(s),\n-\n-                // Generate pattern var(v1, v2, v3)\n-                {|pats|\n-                    let pat = {id: cx.next_id(),\n-                               node: ast::pat_enum(cx.path(variant.ident)),\n-                               span: variant.span};\n-\n-                    {id: cx.next_id(),\n-                     node: expr_call(s, [v_name,\n-                                         v_id,\n-                                         sz,\n-                                         f], false),\n-                     span: variant.span}\n-                },\n-\n-                // Generate body s.emit_enum_variant(\"foo\", 0u, 3u, {|| blk })\n-                {|-s, -blk|\n-                    let v_name = cx.lit_str(variant.span, variant.ident);\n-                    let v_id = cx.lit_uint(variant.span, vidx);\n-                    let sz = cx.lit_uint(variant.span, vec::len(variant_tys));\n-                    let body = cx.lambda(blk);\n-                    #ast[expr]{\n-                        $(s).emit_enum_variant($(v_name), $(v_id), $(sz), $(body))\n-                    }\n-                },\n-\n-                // Generate s.emit_enum_variant_arg(i, {|| blk })\n-                {|-s, i, -blk|\n-                    let idx = cx.lit_uint(i);\n-                    let body = cx.lambda(blk);\n-                    #ast[expr]{\n-                        $(s).emit_enum_variant_arg($(idx), $(body))\n-                    }\n-                })\n-        };\n+    let ser_fn = mk_ser_fn(ext_cx, span, ty, tps) {|cx, _ty, s, v|\n+        let arms = vec::init_fn(\n+            vec::len(variants),\n+            fn&(vidx: uint) -> ast::arm {\n+                let variant = variants[vidx];\n+                let span = variant.span;\n+                let name = variant.node.name;\n+                let variant_tys = vec::map(variant.node.args) {|a| a.ty };\n+\n+                serialize_variant(\n+                    cx, variant_tys, span, cx.clone(s),\n+\n+                    // Generate pattern var(v1, v2, v3)\n+                    {|pats|\n+                        if vec::is_empty(pats) {\n+                            ast::pat_ident(cx.path(span, [name]), none)\n+                        } else {\n+                            ast::pat_enum(cx.path(span, [name]), pats)\n+                        }\n+                    },\n+\n+                    // Generate body s.emit_enum_variant(\"foo\", 0u,\n+                    //                                   3u, {|| blk })\n+                    {|-s, blk|\n+                        let v_name = cx.lit_str(span, name);\n+                        let v_id = cx.lit_uint(span, vidx);\n+                        let sz = cx.lit_uint(span, vec::len(variant_tys));\n+                        let body = cx.lambda(blk);\n+                        #ast[expr]{\n+                            $(s).emit_enum_variant($(v_name), $(v_id),\n+                                                   $(sz), $(body))\n+                        }\n+                    },\n+\n+                    // Generate s.emit_enum_variant_arg(i, {|| blk })\n+                    {|-s, i, blk|\n+                        let idx = cx.lit_uint(span, i);\n+                        let body = cx.lambda(blk);\n+                        #ast[expr]{\n+                            $(s).emit_enum_variant_arg($(idx), $(body))\n+                        }\n+                    })\n+            });\n+        [cx.alt_stmt(arms, span, v)]\n     };\n \n     @{ident: name,"}, {"sha": "014cc17b5d5bbdf93ee0616908458711a89a0906", "filename": "src/rustc/syntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Frustc%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Frustc%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fbase.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -27,6 +27,8 @@ fn syntax_expander_table() -> hashmap<str, syntax_extension> {\n         {normal({expander: f, span: none})}\n     let syntax_expanders = new_str_hash::<syntax_extension>();\n     syntax_expanders.insert(\"fmt\", builtin(ext::fmt::expand_syntax_ext));\n+    syntax_expanders.insert(\"auto_serialize\",\n+                            item_decorator(ext::auto_serialize::expand));\n     syntax_expanders.insert(\"env\", builtin(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(\"macro\",\n                             macro_defining(ext::simplext::add_new_extension));"}, {"sha": "742e7ce45d97c8ee23b345706aae536e1b6c51f7", "filename": "src/rustc/syntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Frustc%2Fsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Frustc%2Fsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fqquote.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -193,6 +193,7 @@ fn finish<T: qq_helper>\n {\n     let cm = ecx.session().parse_sess.cm;\n     let str = @codemap::span_to_snippet(body.span, cm);\n+    #debug[\"qquote--str==%?\", str];\n     let fname = codemap::mk_substr_filename(cm, body.span);\n     let node = parse_from_source_str\n         (f, fname, codemap::fss_internal(body.span), str,"}, {"sha": "19861d0fff6480efded032c39b940b7477ee2b5a", "filename": "src/test/run-pass/auto_serialize_enum.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Ftest%2Frun-pass%2Fauto_serialize_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Ftest%2Frun-pass%2Fauto_serialize_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize_enum.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -0,0 +1,19 @@\n+use std;\n+import std::prettyprint::serializer;\n+import std::io;\n+\n+#[auto_serialize]\n+enum expr {\n+    val(uint),\n+    plus(@expr, @expr),\n+    minus(@expr, @expr)\n+}\n+\n+fn main() {\n+    let ex = @plus(@minus(@val(3u), @val(10u)),\n+                   @plus(@val(22u), @val(5u)));\n+    let s = io::with_str_writer {|w| expr::serialize(w, *ex)};\n+    #debug[\"s == %?\", s];\n+    assert s == \"plus(@minus(@val(3u), @val(10u)), \\\n+                 @plus(@val(22u), @val(5u)))\";\n+}\n\\ No newline at end of file"}, {"sha": "21155e509f5498a589dec0d4e11198f6c63deb1b", "filename": "src/test/run-pass/auto_serialize_gen.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Ftest%2Frun-pass%2Fauto_serialize_gen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Ftest%2Frun-pass%2Fauto_serialize_gen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize_gen.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -0,0 +1,19 @@\n+use std;\n+import std::prettyprint::serializer;\n+import std::io;\n+\n+// Test where we link various types used by name.\n+\n+#[auto_serialize]\n+type spanned<T> = {lo: uint, hi: uint, node: T};\n+\n+#[auto_serialize]\n+type spanned_uint = spanned<uint>;\n+\n+fn main() {\n+    let x: spanned_uint = {lo: 0u, hi: 5u, node: 22u};\n+    spanned_uint::serialize(io::stdout(), x);\n+    let s = io::with_str_writer {|w| spanned_uint::serialize(w, x)};\n+    #debug[\"s == %?\", s];\n+    assert s == \"{lo: 0u, hi: 5u, node: 22u}\";\n+}\n\\ No newline at end of file"}, {"sha": "b146b956e8eb6e2293871d3d90c88299224e04e6", "filename": "src/test/run-pass/auto_serialize_link.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Ftest%2Frun-pass%2Fauto_serialize_link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Ftest%2Frun-pass%2Fauto_serialize_link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize_link.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -0,0 +1,22 @@\n+use std;\n+import std::prettyprint::serializer;\n+import std::io;\n+\n+// Test where we link various types used by name.\n+\n+#[auto_serialize]\n+type uint_vec = [uint];\n+\n+#[auto_serialize]\n+type some_rec = {v: uint_vec};\n+\n+#[auto_serialize]\n+enum an_enum = some_rec;\n+\n+fn main() {\n+    let x = an_enum({v: [1u, 2u, 3u]});\n+    an_enum::serialize(io::stdout(), x);\n+    let s = io::with_str_writer {|w| an_enum::serialize(w, x)};\n+    #debug[\"s == %?\", s];\n+    assert s == \"an_enum({v: [1u, 2u, 3u]})\";\n+}\n\\ No newline at end of file"}, {"sha": "d1043c8278de538d5af9b2bdfef237c419c37212", "filename": "src/test/run-pass/auto_serialize_rec.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Ftest%2Frun-pass%2Fauto_serialize_rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Ftest%2Frun-pass%2Fauto_serialize_rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize_rec.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -0,0 +1,12 @@\n+use std;\n+import std::prettyprint::serializer;\n+import std::io;\n+\n+#[auto_serialize]\n+type point = {x: uint, y: uint};\n+\n+fn main() {\n+    let s = io::with_str_writer {|w| point::serialize(w, {x: 3u, y: 5u}) };\n+    #debug[\"s == %?\", s];\n+    assert s == \"{x: 3u, y: 5u}\";\n+}\n\\ No newline at end of file"}, {"sha": "103340b7b2a103314fde93fef87d49184ab31263", "filename": "src/test/run-pass/auto_serialize_vec.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Ftest%2Frun-pass%2Fauto_serialize_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91742294f282a07b1e26d8da02f7ecec4e0b952/src%2Ftest%2Frun-pass%2Fauto_serialize_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize_vec.rs?ref=d91742294f282a07b1e26d8da02f7ecec4e0b952", "patch": "@@ -0,0 +1,13 @@\n+use std;\n+import std::prettyprint::serializer;\n+import std::io;\n+\n+#[auto_serialize]\n+type uint_vec = [uint];\n+\n+fn main() {\n+    let ex = [1u, 2u, 3u];\n+    let s = io::with_str_writer {|w| uint_vec::serialize(w, ex)};\n+    #debug[\"s == %?\", s];\n+    assert s == \"[1u, 2u, 3u]\";\n+}\n\\ No newline at end of file"}]}