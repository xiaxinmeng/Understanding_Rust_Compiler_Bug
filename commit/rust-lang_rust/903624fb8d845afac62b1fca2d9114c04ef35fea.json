{"sha": "903624fb8d845afac62b1fca2d9114c04ef35fea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMzYyNGZiOGQ4NDVhZmFjNjJiMWZjYTJkOTExNGMwNGVmMzVmZWE=", "commit": {"author": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2018-06-04T06:02:58Z"}, "committer": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2018-06-04T13:08:52Z"}, "message": "Add ExactChunks::remainder and ExactChunks::into_remainder\n\nThese allow to get the leftover items of the slice that are not being\niterated as part of the iterator due to not filling a complete chunk.\n\nThe mutable version consumes the slice because otherwise we would either\na) have to borrow the iterator instead of taking the lifetime of\nthe underlying slice, which is not what *any* of the other iterator\nfunctions is doing, or\nb) would allow returning multiple mutable references to the same data\n\nThe current behaviour of consuming the iterator is consistent with\nIterMut::into_slice for the normal iterator.", "tree": {"sha": "4ef613741e4d26669e7db221fd4dc688cab29884", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ef613741e4d26669e7db221fd4dc688cab29884"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/903624fb8d845afac62b1fca2d9114c04ef35fea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/903624fb8d845afac62b1fca2d9114c04ef35fea", "html_url": "https://github.com/rust-lang/rust/commit/903624fb8d845afac62b1fca2d9114c04ef35fea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/903624fb8d845afac62b1fca2d9114c04ef35fea/comments", "author": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6eafab06cf76fd1461aabc2c6a4fc0daa516da13", "url": "https://api.github.com/repos/rust-lang/rust/commits/6eafab06cf76fd1461aabc2c6a4fc0daa516da13", "html_url": "https://github.com/rust-lang/rust/commit/6eafab06cf76fd1461aabc2c6a4fc0daa516da13"}], "stats": {"total": 62, "additions": 54, "deletions": 8}, "files": [{"sha": "e5e47e4f6536c9f98f770d2e989adbf1dade9b40", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/903624fb8d845afac62b1fca2d9114c04ef35fea/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903624fb8d845afac62b1fca2d9114c04ef35fea/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=903624fb8d845afac62b1fca2d9114c04ef35fea", "patch": "@@ -729,7 +729,8 @@ impl<T> [T] {\n     /// Returns an iterator over `chunk_size` elements of the slice at a\n     /// time. The chunks are slices and do not overlap. If `chunk_size` does\n     /// not divide the length of the slice, then the last up to `chunk_size-1`\n-    /// elements will be omitted.\n+    /// elements will be omitted and can be retrieved from the `remainder`\n+    /// function of the iterator.\n     ///\n     /// Due to each chunk having exactly `chunk_size` elements, the compiler\n     /// can often optimize the resulting code better than in the case of\n@@ -758,14 +759,15 @@ impl<T> [T] {\n         assert!(chunk_size != 0);\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n-        ExactChunks { v: &self[..len], chunk_size: chunk_size}\n+        let (fst, snd) = self.split_at(len);\n+        ExactChunks { v: fst, rem: snd, chunk_size: chunk_size}\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n     /// not divide the length of the slice, then the last up to `chunk_size-1`\n-    /// elements will be omitted.\n-    ///\n+    /// elements will be omitted and can be retrieved from the `into_remainder`\n+    /// function of the iterator.\n     ///\n     /// Due to each chunk having exactly `chunk_size` elements, the compiler\n     /// can often optimize the resulting code better than in the case of\n@@ -799,7 +801,8 @@ impl<T> [T] {\n         assert!(chunk_size != 0);\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n-        ExactChunksMut { v: &mut self[..len], chunk_size: chunk_size}\n+        let (fst, snd) = self.split_at_mut(len);\n+        ExactChunksMut { v: fst, rem: snd, chunk_size: chunk_size}\n     }\n \n     /// Divides one slice into two at an index.\n@@ -3654,25 +3657,39 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n /// time).\n ///\n /// When the slice len is not evenly divided by the chunk size, the last\n-/// up to `chunk_size-1` elements will be omitted.\n+/// up to `chunk_size-1` elements will be omitted but can be retrieved from\n+/// the [`remainder`] function from the iterator.\n ///\n /// This struct is created by the [`exact_chunks`] method on [slices].\n ///\n /// [`exact_chunks`]: ../../std/primitive.slice.html#method.exact_chunks\n+/// [`remainder`]: ../../std/slice/struct.ExactChunks.html#method.remainder\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n pub struct ExactChunks<'a, T:'a> {\n     v: &'a [T],\n+    rem: &'a [T],\n     chunk_size: usize\n }\n \n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> ExactChunks<'a, T> {\n+    /// Return the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    pub fn remainder(&self) -> &'a [T] {\n+        self.rem\n+    }\n+}\n+\n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n impl<'a, T> Clone for ExactChunks<'a, T> {\n     fn clone(&self) -> ExactChunks<'a, T> {\n         ExactChunks {\n             v: self.v,\n+            rem: self.rem,\n             chunk_size: self.chunk_size,\n         }\n     }\n@@ -3760,20 +3777,35 @@ unsafe impl<'a, T> TrustedRandomAccess for ExactChunks<'a, T> {\n }\n \n /// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n-/// elements at a time). When the slice len is not evenly divided by the chunk\n-/// size, the last up to `chunk_size-1` elements will be omitted.\n+/// elements at a time).\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last up to\n+/// `chunk_size-1` elements will be omitted but can be retrieved from the\n+/// [`into_remainder`] function from the iterator.\n ///\n /// This struct is created by the [`exact_chunks_mut`] method on [slices].\n ///\n /// [`exact_chunks_mut`]: ../../std/primitive.slice.html#method.exact_chunks_mut\n+/// [`into_remainder`]: ../../std/slice/struct.ExactChunksMut.html#method.into_remainder\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n pub struct ExactChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n+    rem: &'a mut [T],\n     chunk_size: usize\n }\n \n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> ExactChunksMut<'a, T> {\n+    /// Return the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    pub fn into_remainder(self) -> &'a mut [T] {\n+        self.rem\n+    }\n+}\n+\n #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n impl<'a, T> Iterator for ExactChunksMut<'a, T> {\n     type Item = &'a mut [T];"}, {"sha": "cf937244911e8e0cae810822c8ff4904f92f9e92", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/903624fb8d845afac62b1fca2d9114c04ef35fea/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903624fb8d845afac62b1fca2d9114c04ef35fea/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=903624fb8d845afac62b1fca2d9114c04ef35fea", "patch": "@@ -259,6 +259,13 @@ fn test_exact_chunks_last() {\n     assert_eq!(c2.last().unwrap(), &[2, 3]);\n }\n \n+#[test]\n+fn test_exact_chunks_remainder() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4];\n+    let c = v.exact_chunks(2);\n+    assert_eq!(c.remainder(), &[4]);\n+}\n+\n #[test]\n fn test_exact_chunks_zip() {\n     let v1: &[i32] = &[0, 1, 2, 3, 4];\n@@ -310,6 +317,13 @@ fn test_exact_chunks_mut_last() {\n     assert_eq!(c2.last().unwrap(), &[2, 3]);\n }\n \n+#[test]\n+fn test_exact_chunks_mut_remainder() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c = v.exact_chunks_mut(2);\n+    assert_eq!(c.into_remainder(), &[4]);\n+}\n+\n #[test]\n fn test_exact_chunks_mut_zip() {\n     let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];"}]}