{"sha": "3c5048d2eceb315341582093d2102786c8be38c9", "node_id": "C_kwDOAAsO6NoAKDNjNTA0OGQyZWNlYjMxNTM0MTU4MjA5M2QyMTAyNzg2YzhiZTM4Yzk", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-05T16:33:09Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-07-25T17:19:23Z"}, "message": "Report elision failures on the AST.", "tree": {"sha": "49cc17d5fe8f1e1dfe4505c3a0df298c6fa48e04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49cc17d5fe8f1e1dfe4505c3a0df298c6fa48e04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c5048d2eceb315341582093d2102786c8be38c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c5048d2eceb315341582093d2102786c8be38c9", "html_url": "https://github.com/rust-lang/rust/commit/3c5048d2eceb315341582093d2102786c8be38c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c5048d2eceb315341582093d2102786c8be38c9/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfd0435fd75cb185676ecc9f685e6e61d07c5bf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfd0435fd75cb185676ecc9f685e6e61d07c5bf9", "html_url": "https://github.com/rust-lang/rust/commit/bfd0435fd75cb185676ecc9f685e6e61d07c5bf9"}], "stats": {"total": 3072, "additions": 1482, "deletions": 1590}, "files": [{"sha": "d4b41aad08ca4ba6e839168eb05e7bd15d2f6062", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1835,7 +1835,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug!(?self.captured_lifetimes);\n         let name = match res {\n             LifetimeRes::Param { mut param, binder } => {\n-                debug_assert_ne!(ident.name, kw::UnderscoreLifetime);\n                 let p_name = ParamName::Plain(ident);\n                 if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n                     if !captured_lifetimes.binders_to_ignore.contains(&binder) {"}, {"sha": "c0d5d2bc46d0d31988583e85663e15cbf2fe32ae", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -713,7 +713,7 @@ impl<Id> Res<Id> {\n }\n \n /// Resolution for a lifetime appearing in a type.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum LifetimeRes {\n     /// Successfully linked the lifetime to a generic parameter.\n     Param {"}, {"sha": "fc8b8da6c0bd698673f8036cb1786181941c4914", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 473, "deletions": 161, "changes": 634, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -21,6 +21,7 @@ use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::{PrimTy, TraitCandidate};\n+use rustc_middle::middle::resolve_lifetime::Set1;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n@@ -43,6 +44,10 @@ type IdentMap<T> = FxHashMap<Ident, T>;\n /// Map from the name in a pattern to its binding mode.\n type BindingMap = IdentMap<BindingInfo>;\n \n+use diagnostics::{\n+    ElisionFnParameter, LifetimeElisionCandidate, MissingLifetime, MissingLifetimeKind,\n+};\n+\n #[derive(Copy, Clone, Debug)]\n struct BindingInfo {\n     span: Span,\n@@ -258,10 +263,13 @@ enum LifetimeRibKind {\n     AnonymousReportError,\n \n     /// Pass responsibility to `resolve_lifetime` code for all cases.\n-    AnonymousPassThrough(NodeId, /* in_fn_return */ bool),\n+    AnonymousPassThrough(NodeId),\n \n     /// Replace all anonymous lifetimes by provided lifetime.\n     Elided(LifetimeRes),\n+\n+    /// Signal we cannot find which should be the anonymous lifetime.\n+    ElisionFailure,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -525,6 +533,10 @@ struct DiagnosticMetadata<'ast> {\n \n     /// When processing impl trait\n     currently_processing_impl_trait: Option<(TraitRef, Ty)>,\n+\n+    /// Accumulate the errors due to missed lifetime elision,\n+    /// and report them all at once for each function.\n+    current_elision_failures: Vec<MissingLifetime>,\n }\n \n struct LateResolutionVisitor<'a, 'b, 'ast> {\n@@ -543,6 +555,13 @@ struct LateResolutionVisitor<'a, 'b, 'ast> {\n     /// The current set of local scopes for lifetimes.\n     lifetime_ribs: Vec<LifetimeRib>,\n \n+    /// We are looking for lifetimes in an elision context.\n+    /// The set contains all the resolutions that we encountered so far.\n+    /// They will be used to determine the correct lifetime for the fn return type.\n+    /// The `LifetimeElisionCandidate` is used for diagnostics, to suggest introducing named\n+    /// lifetimes.\n+    lifetime_elision_candidates: Option<FxIndexMap<LifetimeRes, LifetimeElisionCandidate>>,\n+\n     /// The trait that the current context can refer to.\n     current_trait_ref: Option<(Module<'a>, TraitRef)>,\n \n@@ -612,8 +631,10 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             TyKind::Rptr(None, _) => {\n                 // Elided lifetime in reference: we resolve as if there was some lifetime `'_` with\n                 // NodeId `ty.id`.\n+                // This span will be used in case of elision failure.\n                 let span = self.r.session.source_map().next_point(ty.span.shrink_to_lo());\n                 self.resolve_elided_lifetime(ty.id, span);\n+                visit::walk_ty(self, ty);\n             }\n             TyKind::Path(ref qself, ref path) => {\n                 self.diagnostic_metadata.current_type_path = Some(ty);\n@@ -639,8 +660,8 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         },\n                         |this| this.visit_path(&path, ty.id),\n                     );\n-                    self.diagnostic_metadata.current_type_path = prev_ty;\n-                    return;\n+                } else {\n+                    visit::walk_ty(self, ty)\n                 }\n             }\n             TyKind::ImplicitSelf => {\n@@ -654,9 +675,16 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     )\n                     .map_or(Res::Err, |d| d.res());\n                 self.r.record_partial_res(ty.id, PartialRes::new(res));\n+                visit::walk_ty(self, ty)\n+            }\n+            TyKind::ImplTrait(..) => {\n+                let candidates = self.lifetime_elision_candidates.take();\n+                visit::walk_ty(self, ty);\n+                self.lifetime_elision_candidates = candidates;\n             }\n             TyKind::TraitObject(ref bounds, ..) => {\n                 self.diagnostic_metadata.current_trait_object = Some(&bounds[..]);\n+                visit::walk_ty(self, ty)\n             }\n             TyKind::BareFn(ref bare_fn) => {\n                 let span = ty.span.shrink_to_lo().to(bare_fn.decl_span.shrink_to_lo());\n@@ -670,25 +698,20 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     },\n                     |this| {\n                         this.visit_generic_params(&bare_fn.generic_params, false);\n-                        this.with_lifetime_rib(\n-                            LifetimeRibKind::AnonymousCreateParameter {\n-                                binder: ty.id,\n-                                report_in_path: false,\n-                            },\n-                            |this| walk_list!(this, visit_param, &bare_fn.decl.inputs),\n-                        );\n-                        this.with_lifetime_rib(\n-                            LifetimeRibKind::AnonymousPassThrough(ty.id, true),\n-                            |this| this.visit_fn_ret_ty(&bare_fn.decl.output),\n+                        this.resolve_fn_signature(\n+                            ty.id,\n+                            None,\n+                            false,\n+                            // We don't need to deal with patterns in parameters, because\n+                            // they are not possible for foreign or bodiless functions.\n+                            bare_fn.decl.inputs.iter().map(|Param { ty, .. }| (None, &**ty)),\n+                            &bare_fn.decl.output,\n                         );\n                     },\n-                );\n-                self.diagnostic_metadata.current_trait_object = prev;\n-                return;\n+                )\n             }\n-            _ => (),\n+            _ => visit::walk_ty(self, ty),\n         }\n-        visit::walk_ty(self, ty);\n         self.diagnostic_metadata.current_trait_object = prev;\n         self.diagnostic_metadata.current_type_path = prev_ty;\n     }\n@@ -762,18 +785,12 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             | FnKind::Fn(_, _, sig, _, generics, None) => {\n                 self.visit_fn_header(&sig.header);\n                 self.visit_generics(generics);\n-                // We don't need to deal with patterns in parameters, because\n-                // they are not possible for foreign or bodiless functions.\n-                self.with_lifetime_rib(\n-                    LifetimeRibKind::AnonymousCreateParameter {\n-                        binder: fn_id,\n-                        report_in_path: false,\n-                    },\n-                    |this| walk_list!(this, visit_param, &sig.decl.inputs),\n-                );\n-                self.with_lifetime_rib(\n-                    LifetimeRibKind::AnonymousPassThrough(fn_id, true),\n-                    |this| this.visit_fn_ret_ty(&sig.decl.output),\n+                self.resolve_fn_signature(\n+                    fn_id,\n+                    None,\n+                    sig.decl.has_self(),\n+                    sig.decl.inputs.iter().map(|Param { ty, .. }| (None, &**ty)),\n+                    &sig.decl.output,\n                 );\n                 return;\n             }\n@@ -798,19 +815,15 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         let declaration = &sig.decl;\n                         let async_node_id = sig.header.asyncness.opt_return_id();\n \n-                        // Argument-position elided lifetimes must be transformed into fresh\n-                        // generic parameters.  This is especially useful for `async fn`, where\n-                        // these fresh generic parameters can be applied to the opaque `impl Trait`\n-                        // return type.\n-                        this.with_lifetime_rib(\n-                            LifetimeRibKind::AnonymousCreateParameter {\n-                                binder: fn_id,\n-                                // Only emit a hard error for `async fn`, since this kind of\n-                                // elision has always been allowed in regular `fn`s.\n-                                report_in_path: async_node_id.is_some(),\n-                            },\n-                            // Add each argument to the rib.\n-                            |this| this.resolve_params(&declaration.inputs),\n+                        this.resolve_fn_signature(\n+                            fn_id,\n+                            async_node_id,\n+                            declaration.has_self(),\n+                            declaration\n+                                .inputs\n+                                .iter()\n+                                .map(|Param { pat, ty, .. }| (Some(&**pat), &**ty)),\n+                            &declaration.output,\n                         );\n \n                         // Construct the list of in-scope lifetime parameters for async lowering.\n@@ -849,23 +862,13 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                                 .insert(async_node_id, extra_lifetime_params);\n                         }\n \n-                        this.with_lifetime_rib(\n-                            LifetimeRibKind::AnonymousPassThrough(\n-                                // For async fn, the return type appears inside a custom\n-                                // `impl Future` RPIT, so we override the binder's id.\n-                                async_node_id.unwrap_or(fn_id),\n-                                true,\n-                            ),\n-                            |this| visit::walk_fn_ret_ty(this, &declaration.output),\n-                        );\n-\n                         if let Some(body) = body {\n                             // Ignore errors in function bodies if this is rustdoc\n                             // Be sure not to set this until the function signature has been resolved.\n                             let previous_state = replace(&mut this.in_func_body, true);\n                             // Resolve the function body, potentially inside the body of an async closure\n                             this.with_lifetime_rib(\n-                                LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n+                                LifetimeRibKind::AnonymousPassThrough(fn_id),\n                                 |this| this.visit_block(body),\n                             );\n \n@@ -893,7 +896,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         this.with_lifetime_rib(\n                             match binder {\n                                 ClosureBinder::NotPresent => {\n-                                    LifetimeRibKind::AnonymousPassThrough(fn_id, true)\n+                                    LifetimeRibKind::AnonymousPassThrough(fn_id)\n                                 }\n                                 ClosureBinder::For { .. } => LifetimeRibKind::AnonymousReportError,\n                             },\n@@ -905,7 +908,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         let previous_state = replace(&mut this.in_func_body, true);\n                         // Resolve the function body, potentially inside the body of an async closure\n                         this.with_lifetime_rib(\n-                            LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n+                            LifetimeRibKind::AnonymousPassThrough(fn_id),\n                             |this| this.visit_expr(body),\n                         );\n \n@@ -1035,16 +1038,12 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                                 kind: LifetimeBinderKind::PolyTrait,\n                                 ..\n                             } => {\n-                                self.with_lifetime_rib(\n-                                    LifetimeRibKind::AnonymousCreateParameter {\n-                                        binder,\n-                                        report_in_path: false,\n-                                    },\n-                                    |this| walk_list!(this, visit_ty, &p_args.inputs),\n-                                );\n-                                self.with_lifetime_rib(\n-                                    LifetimeRibKind::AnonymousPassThrough(binder, true),\n-                                    |this| visit::walk_fn_ret_ty(this, &p_args.output),\n+                                self.resolve_fn_signature(\n+                                    binder,\n+                                    None,\n+                                    false,\n+                                    p_args.inputs.iter().map(|ty| (None, &**ty)),\n+                                    &p_args.output,\n                                 );\n                                 break;\n                             }\n@@ -1058,6 +1057,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                             | LifetimeRibKind::AnonymousCreateParameter { .. }\n                             | LifetimeRibKind::AnonymousReportError\n                             | LifetimeRibKind::Elided(_)\n+                            | LifetimeRibKind::ElisionFailure\n                             | LifetimeRibKind::AnonConst\n                             | LifetimeRibKind::ConstGeneric => {}\n                         }\n@@ -1162,6 +1162,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             },\n             label_ribs: Vec::new(),\n             lifetime_ribs: Vec::new(),\n+            lifetime_elision_candidates: None,\n             current_trait_ref: None,\n             diagnostic_metadata: Box::new(DiagnosticMetadata::default()),\n             // errors at module scope should always be reported\n@@ -1368,7 +1369,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         work: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n         self.lifetime_ribs.push(LifetimeRib::new(kind));\n+        let outer_elision_candidates = self.lifetime_elision_candidates.take();\n         let ret = work(self);\n+        self.lifetime_elision_candidates = outer_elision_candidates;\n         self.lifetime_ribs.pop();\n         ret\n     }\n@@ -1378,7 +1381,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let ident = lifetime.ident;\n \n         if ident.name == kw::StaticLifetime {\n-            self.record_lifetime_res(lifetime.id, LifetimeRes::Static);\n+            self.record_lifetime_res(\n+                lifetime.id,\n+                LifetimeRes::Static,\n+                LifetimeElisionCandidate::Named,\n+            );\n             return;\n         }\n \n@@ -1391,7 +1398,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             let rib = &self.lifetime_ribs[i];\n             let normalized_ident = ident.normalize_to_macros_2_0();\n             if let Some(&(_, res)) = rib.bindings.get(&normalized_ident) {\n-                self.record_lifetime_res(lifetime.id, res);\n+                self.record_lifetime_res(lifetime.id, res, LifetimeElisionCandidate::Named);\n \n                 if let LifetimeRes::Param { param, .. } = res {\n                     match self.lifetime_uses.entry(param) {\n@@ -1405,12 +1412,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                     // Do not suggest eliding a lifetime where an anonymous\n                                     // lifetime would be illegal.\n                                     LifetimeRibKind::Item\n-                                    | LifetimeRibKind::AnonymousPassThrough(_, true)\n-                                    | LifetimeRibKind::AnonymousReportError => {\n-                                        Some(LifetimeUseSet::Many)\n-                                    }\n+                                    | LifetimeRibKind::AnonymousReportError\n+                                    | LifetimeRibKind::ElisionFailure => Some(LifetimeUseSet::Many),\n                                     // An anonymous lifetime is legal here, go ahead.\n-                                    LifetimeRibKind::AnonymousPassThrough(_, false)\n+                                    LifetimeRibKind::AnonymousPassThrough(_)\n                                     | LifetimeRibKind::AnonymousCreateParameter { .. } => {\n                                         Some(LifetimeUseSet::One { use_span: ident.span, use_ctxt })\n                                     }\n@@ -1442,12 +1447,20 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 LifetimeRibKind::Item => break,\n                 LifetimeRibKind::ConstGeneric => {\n                     self.emit_non_static_lt_in_const_generic_error(lifetime);\n-                    self.r.lifetimes_res_map.insert(lifetime.id, LifetimeRes::Error);\n+                    self.record_lifetime_res(\n+                        lifetime.id,\n+                        LifetimeRes::Error,\n+                        LifetimeElisionCandidate::Ignore,\n+                    );\n                     return;\n                 }\n                 LifetimeRibKind::AnonConst => {\n                     self.maybe_emit_forbidden_non_static_lifetime_error(lifetime);\n-                    self.r.lifetimes_res_map.insert(lifetime.id, LifetimeRes::Error);\n+                    self.record_lifetime_res(\n+                        lifetime.id,\n+                        LifetimeRes::Error,\n+                        LifetimeElisionCandidate::Ignore,\n+                    );\n                     return;\n                 }\n                 _ => {}\n@@ -1465,19 +1478,31 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n \n         self.emit_undeclared_lifetime_error(lifetime, outer_res);\n-        self.record_lifetime_res(lifetime.id, LifetimeRes::Error);\n+        self.record_lifetime_res(lifetime.id, LifetimeRes::Error, LifetimeElisionCandidate::Named);\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn resolve_anonymous_lifetime(&mut self, lifetime: &Lifetime, elided: bool) {\n         debug_assert_eq!(lifetime.ident.name, kw::UnderscoreLifetime);\n \n+        let missing_lifetime = MissingLifetime {\n+            id: lifetime.id,\n+            span: lifetime.ident.span,\n+            kind: if elided {\n+                MissingLifetimeKind::Ampersand\n+            } else {\n+                MissingLifetimeKind::Underscore\n+            },\n+            count: 1,\n+        };\n+        let elision_candidate = LifetimeElisionCandidate::Missing(missing_lifetime);\n         for i in (0..self.lifetime_ribs.len()).rev() {\n             let rib = &mut self.lifetime_ribs[i];\n+            debug!(?rib.kind);\n             match rib.kind {\n                 LifetimeRibKind::AnonymousCreateParameter { binder, .. } => {\n                     let res = self.create_fresh_lifetime(lifetime.id, lifetime.ident, binder);\n-                    self.record_lifetime_res(lifetime.id, res);\n+                    self.record_lifetime_res(lifetime.id, res, elision_candidate);\n                     return;\n                 }\n                 LifetimeRibKind::AnonymousReportError => {\n@@ -1499,18 +1524,24 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     .span_label(lifetime.ident.span, note)\n                     .emit();\n \n-                    self.record_lifetime_res(lifetime.id, LifetimeRes::Error);\n+                    self.record_lifetime_res(lifetime.id, LifetimeRes::Error, elision_candidate);\n                     return;\n                 }\n-                LifetimeRibKind::AnonymousPassThrough(node_id, _) => {\n+                LifetimeRibKind::AnonymousPassThrough(node_id) => {\n                     self.record_lifetime_res(\n                         lifetime.id,\n                         LifetimeRes::Anonymous { binder: node_id, elided },\n+                        elision_candidate,\n                     );\n                     return;\n                 }\n                 LifetimeRibKind::Elided(res) => {\n-                    self.record_lifetime_res(lifetime.id, res);\n+                    self.record_lifetime_res(lifetime.id, res, elision_candidate);\n+                    return;\n+                }\n+                LifetimeRibKind::ElisionFailure => {\n+                    self.diagnostic_metadata.current_elision_failures.push(missing_lifetime);\n+                    self.record_lifetime_res(lifetime.id, LifetimeRes::Error, elision_candidate);\n                     return;\n                 }\n                 LifetimeRibKind::Item => break,\n@@ -1519,23 +1550,20 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 | LifetimeRibKind::AnonConst => {}\n             }\n         }\n-        // This resolution is wrong, it passes the work to HIR lifetime resolution.\n-        // We cannot use `LifetimeRes::Error` because we do not emit a diagnostic.\n-        self.record_lifetime_res(\n-            lifetime.id,\n-            LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided },\n-        );\n+        self.record_lifetime_res(lifetime.id, LifetimeRes::Error, elision_candidate);\n+        self.report_missing_lifetime_specifiers(vec![missing_lifetime], None);\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn resolve_elided_lifetime(&mut self, anchor_id: NodeId, span: Span) {\n         let id = self.r.next_node_id();\n+        let lt = Lifetime { id, ident: Ident::new(kw::UnderscoreLifetime, span) };\n+\n         self.record_lifetime_res(\n             anchor_id,\n             LifetimeRes::ElidedAnchor { start: id, end: NodeId::from_u32(id.as_u32() + 1) },\n+            LifetimeElisionCandidate::Ignore,\n         );\n-\n-        let lt = Lifetime { id, ident: Ident::new(kw::UnderscoreLifetime, span) };\n         self.resolve_anonymous_lifetime(&lt, true);\n     }\n \n@@ -1620,16 +1648,17 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             self.record_lifetime_res(\n                 segment_id,\n                 LifetimeRes::ElidedAnchor { start: node_ids.start, end: node_ids.end },\n+                LifetimeElisionCandidate::Ignore,\n             );\n \n             if !missing {\n                 // Do not create a parameter for patterns and expressions.\n                 for rib in self.lifetime_ribs.iter().rev() {\n                     match rib.kind {\n-                        LifetimeRibKind::AnonymousPassThrough(binder, _) => {\n+                        LifetimeRibKind::AnonymousPassThrough(binder) => {\n                             let res = LifetimeRes::Anonymous { binder, elided: true };\n                             for id in node_ids {\n-                                self.record_lifetime_res(id, res);\n+                                self.record_lifetime_res(id, res, LifetimeElisionCandidate::Named);\n                             }\n                             break;\n                         }\n@@ -1644,12 +1673,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                             let res =\n                                 LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided: true };\n                             for id in node_ids {\n-                                self.record_lifetime_res(id, res);\n+                                self.record_lifetime_res(id, res, LifetimeElisionCandidate::Named);\n                             }\n                             break;\n                         }\n                         LifetimeRibKind::AnonymousCreateParameter { .. }\n                         | LifetimeRibKind::Elided(_)\n+                        | LifetimeRibKind::ElisionFailure\n                         | LifetimeRibKind::Generics { .. }\n                         | LifetimeRibKind::ConstGeneric\n                         | LifetimeRibKind::AnonConst => {}\n@@ -1658,6 +1688,16 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 continue;\n             }\n \n+            let missing_lifetime = MissingLifetime {\n+                id: node_ids.start,\n+                span: elided_lifetime_span,\n+                kind: if segment.has_generic_args {\n+                    MissingLifetimeKind::Comma\n+                } else {\n+                    MissingLifetimeKind::Brackets\n+                },\n+                count: expected_lifetimes,\n+            };\n             let mut should_lint = true;\n             for rib in self.lifetime_ribs.iter().rev() {\n                 match rib.kind {\n@@ -1688,29 +1728,60 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         should_lint = false;\n \n                         for id in node_ids {\n-                            self.record_lifetime_res(id, LifetimeRes::Error);\n+                            self.record_lifetime_res(\n+                                id,\n+                                LifetimeRes::Error,\n+                                LifetimeElisionCandidate::Named,\n+                            );\n                         }\n                         break;\n                     }\n                     // Do not create a parameter for patterns and expressions.\n                     LifetimeRibKind::AnonymousCreateParameter { binder, .. } => {\n+                        // Group all suggestions into the first record.\n+                        let mut candidate = LifetimeElisionCandidate::Missing(missing_lifetime);\n                         for id in node_ids {\n                             let res = self.create_fresh_lifetime(id, ident, binder);\n-                            self.record_lifetime_res(id, res);\n+                            self.record_lifetime_res(\n+                                id,\n+                                res,\n+                                replace(&mut candidate, LifetimeElisionCandidate::Named),\n+                            );\n                         }\n                         break;\n                     }\n                     // `PassThrough` is the normal case.\n-                    LifetimeRibKind::AnonymousPassThrough(binder, _) => {\n+                    LifetimeRibKind::AnonymousPassThrough(binder) => {\n                         let res = LifetimeRes::Anonymous { binder, elided: true };\n+                        let mut candidate = LifetimeElisionCandidate::Missing(missing_lifetime);\n                         for id in node_ids {\n-                            self.record_lifetime_res(id, res);\n+                            self.record_lifetime_res(\n+                                id,\n+                                res,\n+                                replace(&mut candidate, LifetimeElisionCandidate::Ignore),\n+                            );\n                         }\n                         break;\n                     }\n                     LifetimeRibKind::Elided(res) => {\n+                        let mut candidate = LifetimeElisionCandidate::Missing(missing_lifetime);\n                         for id in node_ids {\n-                            self.record_lifetime_res(id, res);\n+                            self.record_lifetime_res(\n+                                id,\n+                                res,\n+                                replace(&mut candidate, LifetimeElisionCandidate::Ignore),\n+                            );\n+                        }\n+                        break;\n+                    }\n+                    LifetimeRibKind::ElisionFailure => {\n+                        self.diagnostic_metadata.current_elision_failures.push(missing_lifetime);\n+                        for id in node_ids {\n+                            self.record_lifetime_res(\n+                                id,\n+                                LifetimeRes::Error,\n+                                LifetimeElisionCandidate::Ignore,\n+                            );\n                         }\n                         break;\n                     }\n@@ -1719,13 +1790,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     // we simply resolve to an implicit lifetime, which will be checked later, at\n                     // which point a suitable error will be emitted.\n                     LifetimeRibKind::AnonymousReportError | LifetimeRibKind::Item => {\n-                        // FIXME(cjgillot) This resolution is wrong, but this does not matter\n-                        // since these cases are erroneous anyway.  Lifetime resolution should\n-                        // emit a \"missing lifetime specifier\" diagnostic.\n-                        let res = LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided: true };\n                         for id in node_ids {\n-                            self.record_lifetime_res(id, res);\n+                            self.record_lifetime_res(\n+                                id,\n+                                LifetimeRes::Error,\n+                                LifetimeElisionCandidate::Ignore,\n+                            );\n                         }\n+                        self.report_missing_lifetime_specifiers(vec![missing_lifetime], None);\n                         break;\n                     }\n                     LifetimeRibKind::Generics { .. }\n@@ -1752,13 +1824,223 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n-    fn record_lifetime_res(&mut self, id: NodeId, res: LifetimeRes) {\n+    fn record_lifetime_res(\n+        &mut self,\n+        id: NodeId,\n+        res: LifetimeRes,\n+        candidate: LifetimeElisionCandidate,\n+    ) {\n         if let Some(prev_res) = self.r.lifetimes_res_map.insert(id, res) {\n             panic!(\n                 \"lifetime {:?} resolved multiple times ({:?} before, {:?} now)\",\n                 id, prev_res, res\n             )\n         }\n+        match res {\n+            LifetimeRes::Param { .. }\n+            | LifetimeRes::Fresh { .. }\n+            | LifetimeRes::Anonymous { .. }\n+            | LifetimeRes::Static => {\n+                if let Some(ref mut candidates) = self.lifetime_elision_candidates {\n+                    candidates.insert(res, candidate);\n+                }\n+            }\n+            LifetimeRes::Error | LifetimeRes::ElidedAnchor { .. } => {}\n+        }\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn record_lifetime_param(&mut self, id: NodeId, res: LifetimeRes) {\n+        if let Some(prev_res) = self.r.lifetimes_res_map.insert(id, res) {\n+            panic!(\n+                \"lifetime parameter {:?} resolved multiple times ({:?} before, {:?} now)\",\n+                id, prev_res, res\n+            )\n+        }\n+    }\n+\n+    /// Perform resolution of a function signature, accounting for lifetime elision.\n+    #[tracing::instrument(level = \"debug\", skip(self, inputs))]\n+    fn resolve_fn_signature(\n+        &mut self,\n+        fn_id: NodeId,\n+        async_node_id: Option<NodeId>,\n+        has_self: bool,\n+        inputs: impl Iterator<Item = (Option<&'ast Pat>, &'ast Ty)> + Clone,\n+        output_ty: &'ast FnRetTy,\n+    ) {\n+        // Add each argument to the rib.\n+        let parameter_rib = LifetimeRibKind::AnonymousCreateParameter {\n+            binder: fn_id,\n+            report_in_path: async_node_id.is_some(),\n+        };\n+        let elision_lifetime =\n+            self.with_lifetime_rib(parameter_rib, |this| this.resolve_fn_params(has_self, inputs));\n+        debug!(?elision_lifetime);\n+\n+        let outer_failures = take(&mut self.diagnostic_metadata.current_elision_failures);\n+        let output_rib = if let Ok(res) = elision_lifetime.as_ref() {\n+            LifetimeRibKind::Elided(*res)\n+        } else {\n+            LifetimeRibKind::ElisionFailure\n+        };\n+        self.with_lifetime_rib(output_rib, |this| visit::walk_fn_ret_ty(this, &output_ty));\n+        let elision_failures =\n+            replace(&mut self.diagnostic_metadata.current_elision_failures, outer_failures);\n+        if !elision_failures.is_empty() {\n+            let Err(failure_info) = elision_lifetime else { bug!() };\n+            self.report_missing_lifetime_specifiers(elision_failures, Some(failure_info));\n+        }\n+    }\n+\n+    /// Resolve inside function parameters and parameter types.\n+    /// Returns the lifetime for elision in fn return type,\n+    /// or diagnostic information in case of elision failure.\n+    fn resolve_fn_params(\n+        &mut self,\n+        has_self: bool,\n+        inputs: impl Iterator<Item = (Option<&'ast Pat>, &'ast Ty)>,\n+    ) -> Result<LifetimeRes, (Vec<MissingLifetime>, Vec<ElisionFnParameter>)> {\n+        let outer_candidates =\n+            replace(&mut self.lifetime_elision_candidates, Some(Default::default()));\n+\n+        let mut elision_lifetime = None;\n+        let mut lifetime_count = 0;\n+        let mut parameter_info = Vec::new();\n+\n+        let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n+        for (index, (pat, ty)) in inputs.enumerate() {\n+            debug!(?pat, ?ty);\n+            if let Some(pat) = pat {\n+                self.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n+            }\n+            self.visit_ty(ty);\n+\n+            if let Some(ref candidates) = self.lifetime_elision_candidates {\n+                let new_count = candidates.len();\n+                let local_count = new_count - lifetime_count;\n+                if local_count != 0 {\n+                    parameter_info.push(ElisionFnParameter {\n+                        index,\n+                        ident: if let Some(pat) = pat && let PatKind::Ident(_, ident, _) = pat.kind {\n+                            Some(ident)\n+                        } else {\n+                            None\n+                        },\n+                        lifetime_count: local_count,\n+                        span: ty.span,\n+                    });\n+                }\n+                lifetime_count = new_count;\n+            }\n+\n+            // Handle `self` specially.\n+            if index == 0 && has_self {\n+                let self_lifetime = self.find_lifetime_for_self(ty);\n+                if let Set1::One(lifetime) = self_lifetime {\n+                    elision_lifetime = Some(lifetime);\n+                    self.lifetime_elision_candidates = None;\n+                } else {\n+                    self.lifetime_elision_candidates = Some(Default::default());\n+                    lifetime_count = 0;\n+                }\n+            }\n+            debug!(\"(resolving function / closure) recorded parameter\");\n+        }\n+\n+        let all_candidates = replace(&mut self.lifetime_elision_candidates, outer_candidates);\n+        debug!(?all_candidates);\n+\n+        if let Some(res) = elision_lifetime {\n+            return Ok(res);\n+        }\n+\n+        // We do not have a `self` candidate, look at the full list.\n+        let all_candidates = all_candidates.unwrap();\n+        if all_candidates.len() == 1 {\n+            Ok(*all_candidates.first().unwrap().0)\n+        } else {\n+            let all_candidates = all_candidates\n+                .into_iter()\n+                .filter_map(|(_, candidate)| match candidate {\n+                    LifetimeElisionCandidate::Ignore | LifetimeElisionCandidate::Named => None,\n+                    LifetimeElisionCandidate::Missing(missing) => Some(missing),\n+                })\n+                .collect();\n+            Err((all_candidates, parameter_info))\n+        }\n+    }\n+\n+    /// List all the lifetimes that appear in the provided type.\n+    fn find_lifetime_for_self(&self, ty: &'ast Ty) -> Set1<LifetimeRes> {\n+        struct SelfVisitor<'r, 'a> {\n+            r: &'r Resolver<'a>,\n+            impl_self: Option<Res>,\n+            lifetime: Set1<LifetimeRes>,\n+        }\n+\n+        impl SelfVisitor<'_, '_> {\n+            // Look for `self: &'a Self` - also desugared from `&'a self`,\n+            // and if that matches, use it for elision and return early.\n+            fn is_self_ty(&self, ty: &Ty) -> bool {\n+                match ty.kind {\n+                    TyKind::ImplicitSelf => true,\n+                    TyKind::Path(None, _) => {\n+                        let path_res = self.r.partial_res_map[&ty.id].base_res();\n+                        if let Res::SelfTy { .. } = path_res {\n+                            return true;\n+                        }\n+                        Some(path_res) == self.impl_self\n+                    }\n+                    _ => false,\n+                }\n+            }\n+        }\n+\n+        impl<'a> Visitor<'a> for SelfVisitor<'_, '_> {\n+            fn visit_ty(&mut self, ty: &'a Ty) {\n+                trace!(\"SelfVisitor considering ty={:?}\", ty);\n+                if let TyKind::Rptr(lt, ref mt) = ty.kind && self.is_self_ty(&mt.ty) {\n+                    let lt_id = if let Some(lt) = lt {\n+                        lt.id\n+                    } else {\n+                        let res = self.r.lifetimes_res_map[&ty.id];\n+                        let LifetimeRes::ElidedAnchor { start, .. } = res else { bug!() };\n+                        start\n+                    };\n+                    let lt_res = self.r.lifetimes_res_map[&lt_id];\n+                    trace!(\"SelfVisitor inserting res={:?}\", lt_res);\n+                    self.lifetime.insert(lt_res);\n+                }\n+                visit::walk_ty(self, ty)\n+            }\n+        }\n+\n+        let impl_self = self\n+            .diagnostic_metadata\n+            .current_self_type\n+            .as_ref()\n+            .and_then(|ty| {\n+                if let TyKind::Path(None, _) = ty.kind {\n+                    self.r.partial_res_map.get(&ty.id)\n+                } else {\n+                    None\n+                }\n+            })\n+            .map(|res| res.base_res())\n+            .filter(|res| {\n+                // Permit the types that unambiguously always\n+                // result in the same type constructor being used\n+                // (it can't differ between `Self` and `self`).\n+                matches!(\n+                    res,\n+                    Res::Def(DefKind::Struct | DefKind::Union | DefKind::Enum, _,) | Res::PrimTy(_)\n+                )\n+            });\n+        let mut visitor = SelfVisitor { r: self.r, impl_self, lifetime: Set1::Empty };\n+        visitor.visit_ty(ty);\n+        trace!(\"SelfVisitor found={:?}\", visitor.lifetime);\n+        visitor.lifetime\n     }\n \n     /// Searches the current set of local scopes for labels. Returns the `NodeId` of the resolved\n@@ -1983,22 +2265,29 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             ItemKind::Static(ref ty, _, ref expr) | ItemKind::Const(_, ref ty, ref expr) => {\n                 self.with_item_rib(|this| {\n-                    this.visit_ty(ty);\n-                    if let Some(expr) = expr {\n-                        let constant_item_kind = match item.kind {\n-                            ItemKind::Const(..) => ConstantItemKind::Const,\n-                            ItemKind::Static(..) => ConstantItemKind::Static,\n-                            _ => unreachable!(),\n-                        };\n-                        // We already forbid generic params because of the above item rib,\n-                        // so it doesn't matter whether this is a trivial constant.\n-                        this.with_constant_rib(\n-                            IsRepeatExpr::No,\n-                            HasGenericParams::Yes,\n-                            Some((item.ident, constant_item_kind)),\n-                            |this| this.visit_expr(expr),\n-                        );\n-                    }\n+                    this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Static), |this| {\n+                        this.visit_ty(ty);\n+                    });\n+                    this.with_lifetime_rib(\n+                        LifetimeRibKind::AnonymousPassThrough(item.id),\n+                        |this| {\n+                            if let Some(expr) = expr {\n+                                let constant_item_kind = match item.kind {\n+                                    ItemKind::Const(..) => ConstantItemKind::Const,\n+                                    ItemKind::Static(..) => ConstantItemKind::Static,\n+                                    _ => unreachable!(),\n+                                };\n+                                // We already forbid generic params because of the above item rib,\n+                                // so it doesn't matter whether this is a trivial constant.\n+                                this.with_constant_rib(\n+                                    IsRepeatExpr::No,\n+                                    HasGenericParams::Yes,\n+                                    Some((item.ident, constant_item_kind)),\n+                                    |this| this.visit_expr(expr),\n+                                );\n+                            }\n+                        },\n+                    );\n                 });\n             }\n \n@@ -2069,7 +2358,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             {\n                 diagnostics::signal_lifetime_shadowing(self.r.session, original, param.ident);\n                 // Record lifetime res, so lowering knows there is something fishy.\n-                self.record_lifetime_res(param.id, LifetimeRes::Error);\n+                self.record_lifetime_param(param.id, LifetimeRes::Error);\n                 continue;\n             }\n \n@@ -2080,7 +2369,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     self.report_error(param.ident.span, err);\n                     if let GenericParamKind::Lifetime = param.kind {\n                         // Record lifetime res, so lowering knows there is something fishy.\n-                        self.record_lifetime_res(param.id, LifetimeRes::Error);\n+                        self.record_lifetime_param(param.id, LifetimeRes::Error);\n                         continue;\n                     }\n                 }\n@@ -2099,7 +2388,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 .span_label(param.ident.span, \"`'_` is a reserved lifetime name\")\n                 .emit();\n                 // Record lifetime res, so lowering knows there is something fishy.\n-                self.record_lifetime_res(param.id, LifetimeRes::Error);\n+                self.record_lifetime_param(param.id, LifetimeRes::Error);\n                 continue;\n             }\n \n@@ -2114,7 +2403,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 .span_label(param.ident.span, \"'static is a reserved lifetime name\")\n                 .emit();\n                 // Record lifetime res, so lowering knows there is something fishy.\n-                self.record_lifetime_res(param.id, LifetimeRes::Error);\n+                self.record_lifetime_param(param.id, LifetimeRes::Error);\n                 continue;\n             }\n \n@@ -2126,7 +2415,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 GenericParamKind::Const { .. } => (&mut function_value_rib, DefKind::ConstParam),\n                 GenericParamKind::Lifetime => {\n                     let res = LifetimeRes::Param { param: def_id, binder };\n-                    self.record_lifetime_res(param.id, res);\n+                    self.record_lifetime_param(param.id, res);\n                     function_lifetime_rib.bindings.insert(ident, (param.id, res));\n                     continue;\n                 }\n@@ -2149,7 +2438,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n         self.ribs[TypeNS].pop();\n         self.ribs[ValueNS].pop();\n-        self.lifetime_ribs.pop();\n+        let function_lifetime_rib = self.lifetime_ribs.pop().unwrap();\n+\n+        // Do not account for the parameters we just bound for function lifetime elision.\n+        if let Some(ref mut candidates) = self.lifetime_elision_candidates {\n+            for (_, res) in function_lifetime_rib.bindings.values() {\n+                candidates.remove(res);\n+            }\n+        }\n \n         if let LifetimeBinderKind::BareFnType\n         | LifetimeBinderKind::WhereBound\n@@ -2247,20 +2543,26 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         //\n                         // Type parameters can already be used and as associated consts are\n                         // not used as part of the type system, this is far less surprising.\n-                        self.with_constant_rib(\n-                            IsRepeatExpr::No,\n-                            HasGenericParams::Yes,\n-                            None,\n-                            |this| this.visit_expr(expr),\n+                        self.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousPassThrough(item.id),\n+                            |this| {\n+                                this.with_constant_rib(\n+                                    IsRepeatExpr::No,\n+                                    HasGenericParams::Yes,\n+                                    None,\n+                                    |this| this.visit_expr(expr),\n+                                )\n+                            },\n                         );\n                     }\n                 }\n                 AssocItemKind::Fn(box Fn { generics, .. }) => {\n                     walk_assoc_item(self, generics, LifetimeBinderKind::Function, item);\n                 }\n-                AssocItemKind::TyAlias(box TyAlias { generics, .. }) => {\n-                    walk_assoc_item(self, generics, LifetimeBinderKind::Item, item);\n-                }\n+                AssocItemKind::TyAlias(box TyAlias { generics, .. }) => self\n+                    .with_lifetime_rib(LifetimeRibKind::AnonymousReportError, |this| {\n+                        walk_assoc_item(this, generics, LifetimeBinderKind::Item, item)\n+                    }),\n                 AssocItemKind::MacCall(_) => {\n                     panic!(\"unexpanded macro in resolve!\")\n                 }\n@@ -2331,7 +2633,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             LifetimeRibKind::Generics {\n                 span: generics.span,\n                 binder: item_id,\n-                kind: LifetimeBinderKind::ImplBlock\n+                kind: LifetimeBinderKind::ImplBlock,\n             },\n             |this| {\n                 // Dummy self type for better errors if `Self` is used in the trait path.\n@@ -2351,7 +2653,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n                                     // Register the trait definitions from here.\n                                     if let Some(trait_id) = trait_id {\n-                                        this.r.trait_impls.entry(trait_id).or_default().push(item_def_id);\n+                                        this.r\n+                                            .trait_impls\n+                                            .entry(trait_id)\n+                                            .or_default()\n+                                            .push(item_def_id);\n                                     }\n \n                                     let item_def_id = item_def_id.to_def_id();\n@@ -2370,21 +2676,17 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                         this.visit_generics(generics);\n \n                                         // Resolve the items within the impl.\n-                                        this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(item_id,false),\n-                                            |this| {\n-                                                this.with_current_self_type(self_type, |this| {\n-                                                    this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n-                                                        debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n-                                                        for item in impl_items {\n-                                                            this.resolve_impl_item(&**item);\n-                                                        }\n-                                                    });\n-                                                });\n-                                            },\n-                                        );\n+                                        this.with_current_self_type(self_type, |this| {\n+                                            this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n+                                                debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n+                                                for item in impl_items {\n+                                                    this.resolve_impl_item(&**item);\n+                                                }\n+                                            });\n+                                        });\n                                     });\n                                 },\n-                            );\n+                            )\n                         },\n                     );\n                 });\n@@ -2415,9 +2717,17 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     //\n                     // Type parameters can already be used and as associated consts are\n                     // not used as part of the type system, this is far less surprising.\n-                    self.with_constant_rib(IsRepeatExpr::No, HasGenericParams::Yes, None, |this| {\n-                        this.visit_expr(expr)\n-                    });\n+                    self.with_lifetime_rib(\n+                        LifetimeRibKind::AnonymousPassThrough(item.id),\n+                        |this| {\n+                            this.with_constant_rib(\n+                                IsRepeatExpr::No,\n+                                HasGenericParams::Yes,\n+                                None,\n+                                |this| this.visit_expr(expr),\n+                            )\n+                        },\n+                    );\n                 }\n             }\n             AssocItemKind::Fn(box Fn { generics, .. }) => {\n@@ -2459,18 +2769,20 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         kind: LifetimeBinderKind::Item,\n                     },\n                     |this| {\n-                        // If this is a trait impl, ensure the type\n-                        // exists in trait\n-                        this.check_trait_item(\n-                            item.id,\n-                            item.ident,\n-                            &item.kind,\n-                            TypeNS,\n-                            item.span,\n-                            |i, s, c| TypeNotMemberOfTrait(i, s, c),\n-                        );\n+                        this.with_lifetime_rib(LifetimeRibKind::AnonymousReportError, |this| {\n+                            // If this is a trait impl, ensure the type\n+                            // exists in trait\n+                            this.check_trait_item(\n+                                item.id,\n+                                item.ident,\n+                                &item.kind,\n+                                TypeNS,\n+                                item.span,\n+                                |i, s, c| TypeNotMemberOfTrait(i, s, c),\n+                            );\n \n-                        visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n+                            visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n+                        });\n                     },\n                 );\n             }"}, {"sha": "f979403e09735225ff3fc228bce4c286487918c4", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 279, "deletions": 572, "changes": 851, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1,26 +1,25 @@\n use crate::diagnostics::{ImportSuggestion, LabelSuggestion, TypoSuggestion};\n-use crate::late::lifetimes::{ElisionFailureInfo, LifetimeContext};\n use crate::late::{AliasPossibility, LateResolutionVisitor, RibKind};\n-use crate::late::{LifetimeBinderKind, LifetimeRibKind, LifetimeUseSet};\n+use crate::late::{LifetimeBinderKind, LifetimeRes, LifetimeRibKind, LifetimeUseSet};\n use crate::path_names_to_string;\n use crate::{Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n use rustc_ast::visit::{FnCtxt, FnKind, LifetimeCtxt};\n use rustc_ast::{\n     self as ast, AssocItemKind, Expr, ExprKind, GenericParam, GenericParamKind, Item, ItemKind,\n-    NodeId, Path, Ty, TyKind,\n+    NodeId, Path, Ty, TyKind, DUMMY_NODE_ID,\n };\n use rustc_ast_pretty::pprust::path_segment_to_string;\n-use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n     MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n-use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n@@ -29,7 +28,7 @@ use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, Span, DUMMY_SP};\n+use rustc_span::{BytePos, Span};\n \n use std::iter;\n use std::ops::Deref;\n@@ -59,45 +58,6 @@ impl AssocSuggestion {\n     }\n }\n \n-pub(crate) enum MissingLifetimeSpot<'tcx> {\n-    Generics(&'tcx hir::Generics<'tcx>),\n-    HigherRanked { span: Span, span_type: ForLifetimeSpanType },\n-    Static,\n-}\n-\n-pub(crate) enum ForLifetimeSpanType {\n-    BoundEmpty,\n-    BoundTail,\n-    TypeEmpty,\n-    TypeTail,\n-    ClosureEmpty,\n-    ClosureTail,\n-}\n-\n-impl ForLifetimeSpanType {\n-    pub(crate) fn descr(&self) -> &'static str {\n-        match self {\n-            Self::BoundEmpty | Self::BoundTail => \"bound\",\n-            Self::TypeEmpty | Self::TypeTail => \"type\",\n-            Self::ClosureEmpty | Self::ClosureTail => \"closure\",\n-        }\n-    }\n-\n-    pub(crate) fn suggestion(&self, sugg: impl std::fmt::Display) -> String {\n-        match self {\n-            Self::BoundEmpty | Self::TypeEmpty => format!(\"for<{}> \", sugg),\n-            Self::ClosureEmpty => format!(\"for<{}>\", sugg),\n-            Self::BoundTail | Self::TypeTail | Self::ClosureTail => format!(\", {}\", sugg),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Into<MissingLifetimeSpot<'tcx>> for &&'tcx hir::Generics<'tcx> {\n-    fn into(self) -> MissingLifetimeSpot<'tcx> {\n-        MissingLifetimeSpot::Generics(self)\n-    }\n-}\n-\n fn is_self_type(path: &[Segment], namespace: Namespace) -> bool {\n     namespace == TypeNS && path.len() == 1 && path[0].ident.name == kw::SelfUpper\n }\n@@ -122,6 +82,56 @@ fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, Str\n     (variant_path_string, enum_path_string)\n }\n \n+/// Description of an elided lifetime.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+pub(super) struct MissingLifetime {\n+    /// Used to overwrite the resolution with the suggestion, to avoid cascasing errors.\n+    pub id: NodeId,\n+    /// Where to suggest adding the lifetime.\n+    pub span: Span,\n+    /// How the lifetime was introduced, to have the correct space and comma.\n+    pub kind: MissingLifetimeKind,\n+    /// Number of elided lifetimes, used for elision in path.\n+    pub count: usize,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+pub(super) enum MissingLifetimeKind {\n+    /// An explicit `'_`.\n+    Underscore,\n+    /// An elided lifetime `&' ty`.\n+    Ampersand,\n+    /// An elided lifetime in brackets with written brackets.\n+    Comma,\n+    /// An elided lifetime with elided brackets.\n+    Brackets,\n+}\n+\n+/// Description of the lifetimes appearing in a function parameter.\n+/// This is used to provide a literal explanation to the elision failure.\n+#[derive(Clone, Debug)]\n+pub(super) struct ElisionFnParameter {\n+    /// The index of the argument in the original definition.\n+    pub index: usize,\n+    /// The name of the argument if it's a simple ident.\n+    pub ident: Option<Ident>,\n+    /// The number of lifetimes in the parameter.\n+    pub lifetime_count: usize,\n+    /// The span of the parameter.\n+    pub span: Span,\n+}\n+\n+/// Description of lifetimes that appear as candidates for elision.\n+/// This is used to suggest introducing an explicit lifetime.\n+#[derive(Debug)]\n+pub(super) enum LifetimeElisionCandidate {\n+    /// This is not a real lifetime.\n+    Ignore,\n+    /// There is a named lifetime, we won't suggest anything.\n+    Named,\n+    Missing(MissingLifetime),\n+}\n+\n impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     fn def_span(&self, def_id: DefId) -> Option<Span> {\n         match def_id.krate {\n@@ -2003,18 +2013,35 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             err.span_label(lifetime_ref.ident.span, \"undeclared lifetime\");\n             err\n         };\n-        let mut suggest_note = true;\n+        self.suggest_introducing_lifetime(\n+            &mut err,\n+            Some(lifetime_ref.ident.name.as_str()),\n+            |err, _, span, message, suggestion| {\n+                err.span_suggestion(span, message, suggestion, Applicability::MaybeIncorrect);\n+                true\n+            },\n+        );\n+        err.emit();\n+    }\n \n+    fn suggest_introducing_lifetime(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        name: Option<&str>,\n+        suggest: impl Fn(&mut DiagnosticBuilder<'_, ErrorGuaranteed>, bool, Span, &str, String) -> bool,\n+    ) {\n+        let mut suggest_note = true;\n         for rib in self.lifetime_ribs.iter().rev() {\n+            let mut should_continue = true;\n             match rib.kind {\n                 LifetimeRibKind::Generics { binder: _, span, kind } => {\n-                    if !span.can_be_used_for_suggestions() && suggest_note {\n+                    if !span.can_be_used_for_suggestions() && suggest_note && let Some(name) = name {\n                         suggest_note = false; // Avoid displaying the same help multiple times.\n                         err.span_label(\n                             span,\n                             &format!(\n                                 \"lifetime `{}` is missing in item created through this procedural macro\",\n-                                lifetime_ref.ident,\n+                                name,\n                             ),\n                         );\n                         continue;\n@@ -2030,46 +2057,42 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         let sugg = format!(\n                             \"{}<{}>{}\",\n                             if higher_ranked { \"for\" } else { \"\" },\n-                            lifetime_ref.ident,\n+                            name.unwrap_or(\"'a\"),\n                             if higher_ranked { \" \" } else { \"\" },\n                         );\n                         (span, sugg)\n                     } else {\n                         let span =\n                             self.r.session.source_map().span_through_char(span, '<').shrink_to_hi();\n-                        let sugg = format!(\"{}, \", lifetime_ref.ident);\n+                        let sugg = format!(\"{}, \", name.unwrap_or(\"'a\"));\n                         (span, sugg)\n                     };\n                     if higher_ranked {\n-                        err.span_suggestion(\n-                            span,\n-                            &format!(\n-                                \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n-                                kind.descr(),\n-                                lifetime_ref\n-                            ),\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n+                        let message = format!(\n+                            \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n+                            kind.descr(),\n+                            name.unwrap_or(\"'a\"),\n                         );\n+                        should_continue = suggest(err, true, span, &message, sugg);\n                         err.note_once(\n                             \"for more information on higher-ranked polymorphism, visit \\\n                              https://doc.rust-lang.org/nomicon/hrtb.html\",\n                         );\n+                    } else if let Some(name) = name {\n+                        let message = format!(\"consider introducing lifetime `{}` here\", name);\n+                        should_continue = suggest(err, false, span, &message, sugg);\n                     } else {\n-                        err.span_suggestion(\n-                            span,\n-                            &format!(\"consider introducing lifetime `{}` here\", lifetime_ref.ident),\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        let message = format!(\"consider introducing a named lifetime parameter\");\n+                        should_continue = suggest(err, false, span, &message, sugg);\n                     }\n                 }\n                 LifetimeRibKind::Item => break,\n                 _ => {}\n             }\n+            if !should_continue {\n+                break;\n+            }\n         }\n-\n-        err.emit();\n     }\n \n     pub(crate) fn emit_non_static_lt_in_const_generic_error(&self, lifetime_ref: &ast::Lifetime) {\n@@ -2105,552 +2128,209 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             .emit();\n         }\n     }\n-}\n \n-/// Report lifetime/lifetime shadowing as an error.\n-pub fn signal_lifetime_shadowing(sess: &Session, orig: Ident, shadower: Ident) {\n-    let mut err = struct_span_err!(\n-        sess,\n-        shadower.span,\n-        E0496,\n-        \"lifetime name `{}` shadows a lifetime name that is already in scope\",\n-        orig.name,\n-    );\n-    err.span_label(orig.span, \"first declared here\");\n-    err.span_label(shadower.span, format!(\"lifetime `{}` already in scope\", orig.name));\n-    err.emit();\n-}\n-\n-/// Shadowing involving a label is only a warning for historical reasons.\n-//FIXME: make this a proper lint.\n-pub fn signal_label_shadowing(sess: &Session, orig: Span, shadower: Ident) {\n-    let name = shadower.name;\n-    let shadower = shadower.span;\n-    let mut err = sess.struct_span_warn(\n-        shadower,\n-        &format!(\"label name `{}` shadows a label name that is already in scope\", name),\n-    );\n-    err.span_label(orig, \"first declared here\");\n-    err.span_label(shadower, format!(\"label `{}` already in scope\", name));\n-    err.emit();\n-}\n-\n-impl<'tcx> LifetimeContext<'_, 'tcx> {\n     pub(crate) fn report_missing_lifetime_specifiers(\n-        &self,\n-        spans: Vec<Span>,\n-        count: usize,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        struct_span_err!(\n-            self.tcx.sess,\n+        &mut self,\n+        lifetime_refs: Vec<MissingLifetime>,\n+        function_param_lifetimes: Option<(Vec<MissingLifetime>, Vec<ElisionFnParameter>)>,\n+    ) -> ErrorGuaranteed {\n+        let num_lifetimes: usize = lifetime_refs.iter().map(|lt| lt.count).sum();\n+        let spans: Vec<_> = lifetime_refs.iter().map(|lt| lt.span).collect();\n+\n+        let mut err = struct_span_err!(\n+            self.r.session,\n             spans,\n             E0106,\n             \"missing lifetime specifier{}\",\n-            pluralize!(count)\n-        )\n+            pluralize!(num_lifetimes)\n+        );\n+        self.add_missing_lifetime_specifiers_label(\n+            &mut err,\n+            lifetime_refs,\n+            function_param_lifetimes,\n+        );\n+        err.emit()\n     }\n \n-    /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n-    pub(crate) fn report_elision_failure(\n-        &self,\n-        diag: &mut Diagnostic,\n-        params: &[ElisionFailureInfo],\n-    ) -> bool {\n-        let mut m = String::new();\n-        let len = params.len();\n+    pub(crate) fn add_missing_lifetime_specifiers_label(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        lifetime_refs: Vec<MissingLifetime>,\n+        function_param_lifetimes: Option<(Vec<MissingLifetime>, Vec<ElisionFnParameter>)>,\n+    ) {\n+        for &lt in &lifetime_refs {\n+            err.span_label(\n+                lt.span,\n+                format!(\n+                    \"expected {} lifetime parameter{}\",\n+                    if lt.count == 1 { \"named\".to_string() } else { lt.count.to_string() },\n+                    pluralize!(lt.count),\n+                ),\n+            );\n+        }\n \n-        let elided_params: Vec<_> =\n-            params.iter().cloned().filter(|info| info.lifetime_count > 0).collect();\n+        let mut in_scope_lifetimes: Vec<_> = self\n+            .lifetime_ribs\n+            .iter()\n+            .rev()\n+            .take_while(|rib| !matches!(rib.kind, LifetimeRibKind::Item))\n+            .flat_map(|rib| rib.bindings.iter())\n+            .map(|(&ident, &res)| (ident, res))\n+            .filter(|(ident, _)| ident.name != kw::UnderscoreLifetime)\n+            .collect();\n+        debug!(?in_scope_lifetimes);\n \n-        let elided_len = elided_params.len();\n+        debug!(?function_param_lifetimes);\n+        if let Some((param_lifetimes, params)) = &function_param_lifetimes {\n+            let elided_len = param_lifetimes.len();\n+            let num_params = params.len();\n \n-        for (i, info) in elided_params.into_iter().enumerate() {\n-            let ElisionFailureInfo { parent, index, lifetime_count: n, have_bound_regions, span } =\n-                info;\n+            let mut m = String::new();\n \n-            diag.span_label(span, \"\");\n-            let help_name = if let Some(ident) =\n-                parent.and_then(|body| self.tcx.hir().body(body).params[index].pat.simple_ident())\n-            {\n-                format!(\"`{}`\", ident)\n-            } else {\n-                format!(\"argument {}\", index + 1)\n-            };\n+            for (i, info) in params.iter().enumerate() {\n+                let ElisionFnParameter { ident, index, lifetime_count, span } = *info;\n+                debug_assert_ne!(lifetime_count, 0);\n \n-            m.push_str(\n-                &(if n == 1 {\n-                    help_name\n+                err.span_label(span, \"\");\n+\n+                if i != 0 {\n+                    if i + 1 < num_params {\n+                        m.push_str(\", \");\n+                    } else if num_params == 2 {\n+                        m.push_str(\" or \");\n+                    } else {\n+                        m.push_str(\", or \");\n+                    }\n+                }\n+\n+                let help_name = if let Some(ident) = ident {\n+                    format!(\"`{}`\", ident)\n                 } else {\n-                    format!(\n-                        \"one of {}'s {} {}lifetimes\",\n-                        help_name,\n-                        n,\n-                        if have_bound_regions { \"free \" } else { \"\" }\n-                    )\n-                })[..],\n-            );\n+                    format!(\"argument {}\", index + 1)\n+                };\n \n-            if elided_len == 2 && i == 0 {\n-                m.push_str(\" or \");\n-            } else if i + 2 == elided_len {\n-                m.push_str(\", or \");\n-            } else if i != elided_len - 1 {\n-                m.push_str(\", \");\n+                if lifetime_count == 1 {\n+                    m.push_str(&help_name[..])\n+                } else {\n+                    m.push_str(&format!(\"one of {}'s {} lifetimes\", help_name, lifetime_count)[..])\n+                }\n             }\n-        }\n \n-        if len == 0 {\n-            diag.help(\n-                \"this function's return type contains a borrowed value, \\\n+            if num_params == 0 {\n+                err.help(\n+                    \"this function's return type contains a borrowed value, \\\n                  but there is no value for it to be borrowed from\",\n-            );\n-            true\n-        } else if elided_len == 0 {\n-            diag.help(\n-                \"this function's return type contains a borrowed value with \\\n+                );\n+                if in_scope_lifetimes.is_empty() {\n+                    in_scope_lifetimes = vec![(\n+                        Ident::with_dummy_span(kw::StaticLifetime),\n+                        (DUMMY_NODE_ID, LifetimeRes::Static),\n+                    )];\n+                }\n+            } else if elided_len == 0 {\n+                err.help(\n+                    \"this function's return type contains a borrowed value with \\\n                  an elided lifetime, but the lifetime cannot be derived from \\\n                  the arguments\",\n-            );\n-            true\n-        } else if elided_len == 1 {\n-            diag.help(&format!(\n-                \"this function's return type contains a borrowed value, \\\n+                );\n+                if in_scope_lifetimes.is_empty() {\n+                    in_scope_lifetimes = vec![(\n+                        Ident::with_dummy_span(kw::StaticLifetime),\n+                        (DUMMY_NODE_ID, LifetimeRes::Static),\n+                    )];\n+                }\n+            } else if num_params == 1 {\n+                err.help(&format!(\n+                    \"this function's return type contains a borrowed value, \\\n                  but the signature does not say which {} it is borrowed from\",\n-                m\n-            ));\n-            false\n-        } else {\n-            diag.help(&format!(\n-                \"this function's return type contains a borrowed value, \\\n+                    m\n+                ));\n+            } else {\n+                err.help(&format!(\n+                    \"this function's return type contains a borrowed value, \\\n                  but the signature does not say whether it is borrowed from {}\",\n-                m\n-            ));\n-            false\n+                    m\n+                ));\n+            }\n         }\n-    }\n \n-    pub(crate) fn is_trait_ref_fn_scope(\n-        &mut self,\n-        trait_ref: &'tcx hir::PolyTraitRef<'tcx>,\n-    ) -> bool {\n-        if let def::Res::Def(_, did) = trait_ref.trait_ref.path.res {\n-            if [\n-                self.tcx.lang_items().fn_once_trait(),\n-                self.tcx.lang_items().fn_trait(),\n-                self.tcx.lang_items().fn_mut_trait(),\n-            ]\n-            .contains(&Some(did))\n-            {\n-                let (span, span_type) = if let Some(bound) =\n-                    trait_ref.bound_generic_params.iter().rfind(|param| {\n-                        matches!(\n-                            param.kind,\n-                            hir::GenericParamKind::Lifetime {\n-                                kind: hir::LifetimeParamKind::Explicit\n-                            }\n-                        )\n-                    }) {\n-                    (bound.span.shrink_to_hi(), ForLifetimeSpanType::BoundTail)\n-                } else {\n-                    (trait_ref.span.shrink_to_lo(), ForLifetimeSpanType::BoundEmpty)\n-                };\n-                self.missing_named_lifetime_spots\n-                    .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n-                return true;\n-            }\n+        let existing_name = match &in_scope_lifetimes[..] {\n+            [] => Symbol::intern(\"'a\"),\n+            [(existing, _)] => existing.name,\n+            _ => Symbol::intern(\"'lifetime\"),\n         };\n-        false\n-    }\n-\n-    pub(crate) fn add_missing_lifetime_specifiers_label(\n-        &self,\n-        err: &mut Diagnostic,\n-        mut spans_with_counts: Vec<(Span, usize)>,\n-        in_scope_lifetimes: FxIndexSet<LocalDefId>,\n-        params: Option<&[ElisionFailureInfo]>,\n-    ) {\n-        let (mut lifetime_names, lifetime_spans): (FxHashSet<_>, Vec<_>) = in_scope_lifetimes\n-            .iter()\n-            .filter_map(|def_id| {\n-                let name = self.tcx.item_name(def_id.to_def_id());\n-                let span = self.tcx.def_ident_span(def_id.to_def_id())?;\n-                Some((name, span))\n-            })\n-            .filter(|&(n, _)| n != kw::UnderscoreLifetime)\n-            .unzip();\n \n-        if let Some(params) = params {\n-            // If there's no lifetime available, suggest `'static`.\n-            if self.report_elision_failure(err, params) && lifetime_names.is_empty() {\n-                lifetime_names.insert(kw::StaticLifetime);\n+        let mut spans_suggs: Vec<_> = Vec::new();\n+        let build_sugg = |lt: MissingLifetime| match lt.kind {\n+            MissingLifetimeKind::Underscore => {\n+                debug_assert_eq!(lt.count, 1);\n+                (lt.span, existing_name.to_string())\n             }\n-        }\n-        let params = params.unwrap_or(&[]);\n-\n-        let snippets: Vec<Option<String>> = spans_with_counts\n-            .iter()\n-            .map(|(span, _)| self.tcx.sess.source_map().span_to_snippet(*span).ok())\n-            .collect();\n-\n-        // Empty generics are marked with a span of \"<\", but since from now on\n-        // that information is in the snippets it can be removed from the spans.\n-        for ((span, _), snippet) in spans_with_counts.iter_mut().zip(&snippets) {\n-            if snippet.as_deref() == Some(\"<\") {\n-                *span = span.shrink_to_hi();\n+            MissingLifetimeKind::Ampersand => {\n+                debug_assert_eq!(lt.count, 1);\n+                (lt.span.shrink_to_hi(), format!(\"{} \", existing_name))\n             }\n+            MissingLifetimeKind::Comma => {\n+                let sugg: String = std::iter::repeat([existing_name.as_str(), \", \"])\n+                    .take(lt.count)\n+                    .flatten()\n+                    .collect();\n+                (lt.span.shrink_to_hi(), sugg)\n+            }\n+            MissingLifetimeKind::Brackets => {\n+                let sugg: String = std::iter::once(\"<\")\n+                    .chain(\n+                        std::iter::repeat(existing_name.as_str()).take(lt.count).intersperse(\", \"),\n+                    )\n+                    .chain([\">\"])\n+                    .collect();\n+                (lt.span.shrink_to_hi(), sugg)\n+            }\n+        };\n+        for &lt in &lifetime_refs {\n+            spans_suggs.push(build_sugg(lt));\n         }\n-\n-        for &(span, count) in &spans_with_counts {\n-            err.span_label(\n-                span,\n-                format!(\n-                    \"expected {} lifetime parameter{}\",\n-                    if count == 1 { \"named\".to_string() } else { count.to_string() },\n-                    pluralize!(count),\n-                ),\n-            );\n-        }\n-\n-        let suggest_existing =\n-            |err: &mut Diagnostic,\n-             name: Symbol,\n-             formatters: Vec<Option<Box<dyn Fn(Symbol) -> String>>>| {\n-                if let Some(MissingLifetimeSpot::HigherRanked { span: for_span, span_type }) =\n-                    self.missing_named_lifetime_spots.iter().rev().next()\n-                {\n-                    // When we have `struct S<'a>(&'a dyn Fn(&X) -> &X);` we want to not only suggest\n-                    // using `'a`, but also introduce the concept of HRLTs by suggesting\n-                    // `struct S<'a>(&'a dyn for<'b> Fn(&X) -> &'b X);`. (#72404)\n-                    let mut introduce_suggestion = vec![];\n-\n-                    let a_to_z_repeat_n = |n| {\n-                        (b'a'..=b'z').map(move |c| {\n-                            let mut s = '\\''.to_string();\n-                            s.extend(std::iter::repeat(char::from(c)).take(n));\n-                            s\n-                        })\n-                    };\n-\n-                    // If all single char lifetime names are present, we wrap around and double the chars.\n-                    let lt_name = (1..)\n-                        .flat_map(a_to_z_repeat_n)\n-                        .map(|lt| Symbol::intern(&lt))\n-                        .find(|lt| !lifetime_names.contains(lt))\n-                        .unwrap();\n-                    let msg = format!(\n-                        \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n-                        span_type.descr(),\n-                        lt_name,\n-                    );\n-                    err.note(\n-                        \"for more information on higher-ranked polymorphism, visit \\\n-                    https://doc.rust-lang.org/nomicon/hrtb.html\",\n-                    );\n-                    let for_sugg = span_type.suggestion(&lt_name);\n-                    for param in params {\n-                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span)\n-                        {\n-                            if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n-                                introduce_suggestion\n-                                    .push((param.span, format!(\"&{} {}\", lt_name, &snippet[1..])));\n-                            } else if let Some(stripped) = snippet.strip_prefix(\"&'_ \") {\n-                                introduce_suggestion\n-                                    .push((param.span, format!(\"&{} {}\", lt_name, stripped)));\n-                            }\n-                        }\n+        debug!(?spans_suggs);\n+        match in_scope_lifetimes.len() {\n+            0 => {\n+                if let Some((param_lifetimes, _)) = function_param_lifetimes {\n+                    for lt in param_lifetimes {\n+                        spans_suggs.push(build_sugg(lt))\n                     }\n-                    introduce_suggestion.push((*for_span, for_sugg));\n-                    for ((span, _), formatter) in spans_with_counts.iter().zip(formatters.iter()) {\n-                        if let Some(formatter) = formatter {\n-                            introduce_suggestion.push((*span, formatter(lt_name)));\n-                        }\n-                    }\n-                    err.multipart_suggestion_verbose(\n-                        &msg,\n-                        introduce_suggestion,\n-                        Applicability::MaybeIncorrect,\n-                    );\n                 }\n-\n-                let spans_suggs: Vec<_> = formatters\n-                    .into_iter()\n-                    .zip(spans_with_counts.iter())\n-                    .filter_map(|(formatter, (span, _))| {\n-                        if let Some(formatter) = formatter {\n-                            Some((*span, formatter(name)))\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .collect();\n-                if spans_suggs.is_empty() {\n-                    // If all the spans come from macros, we cannot extract snippets and then\n-                    // `formatters` only contains None and `spans_suggs` is empty.\n-                    return;\n-                }\n-                err.multipart_suggestion_verbose(\n-                    &format!(\n-                        \"consider using the `{}` lifetime\",\n-                        lifetime_names.iter().next().unwrap()\n-                    ),\n-                    spans_suggs,\n-                    Applicability::MaybeIncorrect,\n-                );\n-            };\n-        let suggest_new = |err: &mut Diagnostic, suggs: Vec<Option<String>>| {\n-            for missing in self.missing_named_lifetime_spots.iter().rev() {\n-                let mut introduce_suggestion = vec![];\n-                let msg;\n-                let should_break;\n-                introduce_suggestion.push(match missing {\n-                    MissingLifetimeSpot::Generics(generics) => {\n-                        if generics.span == DUMMY_SP {\n-                            // Account for malformed generics in the HIR. This shouldn't happen,\n-                            // but if we make a mistake elsewhere, mainly by keeping something in\n-                            // `missing_named_lifetime_spots` that we shouldn't, like associated\n-                            // `const`s or making a mistake in the AST lowering we would provide\n-                            // nonsensical suggestions. Guard against that by skipping these.\n-                            // (#74264)\n-                            continue;\n-                        }\n-                        msg = \"consider introducing a named lifetime parameter\".to_string();\n-                        should_break = true;\n-                        if let Some(param) = generics.params.iter().find(|p| {\n-                            !matches!(\n-                                p.kind,\n-                                hir::GenericParamKind::Type { synthetic: true, .. }\n-                                    | hir::GenericParamKind::Lifetime {\n-                                        kind: hir::LifetimeParamKind::Elided\n-                                    }\n-                            )\n-                        }) {\n-                            (param.span.shrink_to_lo(), \"'a, \".to_string())\n-                        } else {\n-                            (generics.span, \"<'a>\".to_string())\n-                        }\n-                    }\n-                    MissingLifetimeSpot::HigherRanked { span, span_type } => {\n-                        msg = format!(\n-                            \"consider making the {} lifetime-generic with a new `'a` lifetime\",\n-                            span_type.descr(),\n-                        );\n-                        should_break = false;\n-                        err.note(\n-                            \"for more information on higher-ranked polymorphism, visit \\\n-                            https://doc.rust-lang.org/nomicon/hrtb.html\",\n-                        );\n-                        (*span, span_type.suggestion(\"'a\"))\n-                    }\n-                    MissingLifetimeSpot::Static => {\n-                        let mut spans_suggs = Vec::new();\n-                        for ((span, count), snippet) in\n-                            spans_with_counts.iter().copied().zip(snippets.iter())\n-                        {\n-                            let (span, sugg) = match snippet.as_deref() {\n-                                Some(\"&\") => (span.shrink_to_hi(), \"'static \".to_owned()),\n-                                Some(\"'_\") => (span, \"'static\".to_owned()),\n-                                Some(snippet) if !snippet.ends_with('>') => {\n-                                    if snippet == \"\" {\n-                                        (\n-                                            span,\n-                                            std::iter::repeat(\"'static\")\n-                                                .take(count)\n-                                                .collect::<Vec<_>>()\n-                                                .join(\", \"),\n-                                        )\n-                                    } else if snippet == \"<\" || snippet == \"(\" {\n-                                        (\n-                                            span.shrink_to_hi(),\n-                                            std::iter::repeat(\"'static\")\n-                                                .take(count)\n-                                                .collect::<Vec<_>>()\n-                                                .join(\", \"),\n-                                        )\n-                                    } else {\n-                                        (\n-                                            span.shrink_to_hi(),\n-                                            format!(\n-                                                \"<{}>\",\n-                                                std::iter::repeat(\"'static\")\n-                                                    .take(count)\n-                                                    .collect::<Vec<_>>()\n-                                                    .join(\", \"),\n-                                            ),\n-                                        )\n-                                    }\n-                                }\n-                                _ => continue,\n-                            };\n-                            spans_suggs.push((span, sugg.to_string()));\n-                        }\n+                self.suggest_introducing_lifetime(\n+                    err,\n+                    None,\n+                    |err, higher_ranked, span, message, intro_sugg| {\n                         err.multipart_suggestion_verbose(\n-                            \"consider using the `'static` lifetime\",\n-                            spans_suggs,\n+                            message,\n+                            std::iter::once((span, intro_sugg))\n+                                .chain(spans_suggs.clone())\n+                                .collect(),\n                             Applicability::MaybeIncorrect,\n                         );\n-                        continue;\n-                    }\n-                });\n-\n-                struct Lifetime(Span, String);\n-                impl Lifetime {\n-                    fn is_unnamed(&self) -> bool {\n-                        self.1.starts_with('&') && !self.1.starts_with(\"&'\")\n-                    }\n-                    fn is_underscore(&self) -> bool {\n-                        self.1.starts_with(\"&'_ \")\n-                    }\n-                    fn is_named(&self) -> bool {\n-                        self.1.starts_with(\"&'\")\n-                    }\n-                    fn suggestion(&self, sugg: String) -> Option<(Span, String)> {\n-                        Some(\n-                            match (\n-                                self.is_unnamed(),\n-                                self.is_underscore(),\n-                                self.is_named(),\n-                                sugg.starts_with('&'),\n-                            ) {\n-                                (true, _, _, false) => (self.span_unnamed_borrow(), sugg),\n-                                (true, _, _, true) => {\n-                                    (self.span_unnamed_borrow(), sugg[1..].to_string())\n-                                }\n-                                (_, true, _, false) => {\n-                                    (self.span_underscore_borrow(), sugg.trim().to_string())\n-                                }\n-                                (_, true, _, true) => {\n-                                    (self.span_underscore_borrow(), sugg[1..].trim().to_string())\n-                                }\n-                                (_, _, true, false) => {\n-                                    (self.span_named_borrow(), sugg.trim().to_string())\n-                                }\n-                                (_, _, true, true) => {\n-                                    (self.span_named_borrow(), sugg[1..].trim().to_string())\n-                                }\n-                                _ => return None,\n-                            },\n-                        )\n-                    }\n-                    fn span_unnamed_borrow(&self) -> Span {\n-                        let lo = self.0.lo() + BytePos(1);\n-                        self.0.with_lo(lo).with_hi(lo)\n-                    }\n-                    fn span_named_borrow(&self) -> Span {\n-                        let lo = self.0.lo() + BytePos(1);\n-                        self.0.with_lo(lo)\n-                    }\n-                    fn span_underscore_borrow(&self) -> Span {\n-                        let lo = self.0.lo() + BytePos(1);\n-                        let hi = lo + BytePos(2);\n-                        self.0.with_lo(lo).with_hi(hi)\n-                    }\n-                }\n-\n-                for param in params {\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span) {\n-                        if let Some((span, sugg)) =\n-                            Lifetime(param.span, snippet).suggestion(\"'a \".to_string())\n-                        {\n-                            introduce_suggestion.push((span, sugg));\n-                        }\n-                    }\n-                }\n-                for (span, sugg) in spans_with_counts.iter().copied().zip(suggs.iter()).filter_map(\n-                    |((span, _), sugg)| match &sugg {\n-                        Some(sugg) => Some((span, sugg.to_string())),\n-                        _ => None,\n+                        higher_ranked\n                     },\n-                ) {\n-                    let (span, sugg) = self\n-                        .tcx\n-                        .sess\n-                        .source_map()\n-                        .span_to_snippet(span)\n-                        .ok()\n-                        .and_then(|snippet| Lifetime(span, snippet).suggestion(sugg.clone()))\n-                        .unwrap_or((span, sugg));\n-                    introduce_suggestion.push((span, sugg.to_string()));\n-                }\n+                );\n+            }\n+            1 => {\n                 err.multipart_suggestion_verbose(\n-                    &msg,\n-                    introduce_suggestion,\n+                    &format!(\"consider using the `{}` lifetime\", existing_name),\n+                    spans_suggs,\n                     Applicability::MaybeIncorrect,\n                 );\n-                if should_break {\n-                    break;\n-                }\n-            }\n-        };\n \n-        let lifetime_names: Vec<_> = lifetime_names.iter().collect();\n-        match &lifetime_names[..] {\n-            [name] => {\n-                let mut suggs: Vec<Option<Box<dyn Fn(Symbol) -> String>>> = Vec::new();\n-                for (snippet, (_, count)) in snippets.iter().zip(spans_with_counts.iter().copied())\n-                {\n-                    suggs.push(match snippet.as_deref() {\n-                        Some(\"&\") => Some(Box::new(|name| format!(\"&{} \", name))),\n-                        Some(\"'_\") => Some(Box::new(|n| n.to_string())),\n-                        Some(\"\") => Some(Box::new(move |n| format!(\"{}, \", n).repeat(count))),\n-                        Some(\"<\") => Some(Box::new(move |n| {\n-                            std::iter::repeat(n)\n-                                .take(count)\n-                                .map(|n| n.to_string())\n-                                .collect::<Vec<_>>()\n-                                .join(\", \")\n-                        })),\n-                        Some(snippet) if !snippet.ends_with('>') => Some(Box::new(move |name| {\n-                            format!(\n-                                \"{}<{}>\",\n-                                snippet,\n-                                std::iter::repeat(name.to_string())\n-                                    .take(count)\n-                                    .collect::<Vec<_>>()\n-                                    .join(\", \")\n-                            )\n-                        })),\n-                        _ => None,\n-                    });\n+                // Record as using the suggested resolution.\n+                let (_, (_, res)) = in_scope_lifetimes[0];\n+                for &lt in &lifetime_refs {\n+                    self.r.lifetimes_res_map.insert(lt.id, res);\n                 }\n-                suggest_existing(err, **name, suggs);\n             }\n-            [] => {\n-                let mut suggs = Vec::new();\n-                for (snippet, (_, count)) in\n-                    snippets.iter().cloned().zip(spans_with_counts.iter().copied())\n-                {\n-                    suggs.push(match snippet.as_deref() {\n-                        Some(\"&\") => Some(\"&'a \".to_string()),\n-                        Some(\"'_\") => Some(\"'a\".to_string()),\n-                        Some(\"\") => {\n-                            Some(std::iter::repeat(\"'a, \").take(count).collect::<Vec<_>>().join(\"\"))\n-                        }\n-                        Some(\"<\") => {\n-                            Some(std::iter::repeat(\"'a\").take(count).collect::<Vec<_>>().join(\", \"))\n-                        }\n-                        Some(snippet) => Some(format!(\n-                            \"{}<{}>\",\n-                            snippet,\n-                            std::iter::repeat(\"'a\").take(count).collect::<Vec<_>>().join(\", \"),\n-                        )),\n-                        None => None,\n-                    });\n-                }\n-                suggest_new(err, suggs);\n-            }\n-            lts if lts.len() > 1 => {\n+            _ => {\n+                let lifetime_spans: Vec<_> =\n+                    in_scope_lifetimes.iter().map(|(ident, _)| ident.span).collect();\n                 err.span_note(lifetime_spans, \"these named lifetimes are available to use\");\n \n-                let mut spans_suggs: Vec<_> = Vec::new();\n-                for ((span, _), snippet) in spans_with_counts.iter().copied().zip(snippets.iter()) {\n-                    match snippet.as_deref() {\n-                        Some(\"\") => spans_suggs.push((span, \"'lifetime, \".to_string())),\n-                        Some(\"&\") => spans_suggs\n-                            .push((span.with_lo(span.lo() + BytePos(1)), \"'lifetime \".to_string())),\n-                        _ => {}\n-                    }\n-                }\n-\n                 if spans_suggs.len() > 0 {\n                     // This happens when we have `Foo<T>` where we point at the space before `T`,\n                     // but this can be confusing so we give a suggestion with placeholders.\n@@ -2661,7 +2341,34 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                     );\n                 }\n             }\n-            _ => unreachable!(),\n         }\n     }\n }\n+\n+/// Report lifetime/lifetime shadowing as an error.\n+pub fn signal_lifetime_shadowing(sess: &Session, orig: Ident, shadower: Ident) {\n+    let mut err = struct_span_err!(\n+        sess,\n+        shadower.span,\n+        E0496,\n+        \"lifetime name `{}` shadows a lifetime name that is already in scope\",\n+        orig.name,\n+    );\n+    err.span_label(orig.span, \"first declared here\");\n+    err.span_label(shadower.span, format!(\"lifetime `{}` already in scope\", orig.name));\n+    err.emit();\n+}\n+\n+/// Shadowing involving a label is only a warning for historical reasons.\n+//FIXME: make this a proper lint.\n+pub fn signal_label_shadowing(sess: &Session, orig: Span, shadower: Ident) {\n+    let name = shadower.name;\n+    let shadower = shadower.span;\n+    let mut err = sess.struct_span_warn(\n+        shadower,\n+        &format!(\"label name `{}` shadows a label name that is already in scope\", name),\n+    );\n+    err.span_label(orig, \"first declared here\");\n+    err.span_label(shadower, format!(\"label `{}` already in scope\", name));\n+    err.emit();\n+}"}, {"sha": "25049b8ffac9a96ec353a22870156b0b8cb17788", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 38, "deletions": 186, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -6,21 +6,19 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n-use crate::late::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n use rustc_ast::walk_list;\n use rustc_data_structures::fx::{FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node};\n-use rustc_hir::{GenericParamKind, HirIdMap, LifetimeParamKind};\n+use rustc_hir::{GenericArg, GenericParam, GenericParamKind, HirIdMap, LifetimeName, Node};\n+use rustc_middle::bug;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n-use rustc_middle::{bug, span_bug};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n@@ -152,10 +150,6 @@ pub(crate) struct LifetimeContext<'a, 'tcx> {\n \n     /// Cache for cross-crate per-definition object lifetime defaults.\n     xcrate_object_lifetime_defaults: DefIdMap<Vec<ObjectLifetimeDefault>>,\n-\n-    /// When encountering an undefined named lifetime, we will suggest introducing it in these\n-    /// places.\n-    pub(crate) missing_named_lifetime_spots: Vec<MissingLifetimeSpot<'tcx>>,\n }\n \n #[derive(Debug)]\n@@ -323,23 +317,12 @@ enum Elide {\n     /// Always use this one lifetime.\n     Exact(Region),\n     /// Less or more than one lifetime were found, error on unspecified.\n-    Error(Vec<ElisionFailureInfo>),\n+    Error,\n     /// Forbid lifetime elision inside of a larger scope where it would be\n     /// permitted. For example, in let position impl trait.\n     Forbid,\n }\n \n-#[derive(Clone, Debug)]\n-pub(crate) struct ElisionFailureInfo {\n-    /// Where we can find the argument pattern.\n-    pub(crate) parent: Option<hir::BodyId>,\n-    /// The index of the argument in the original definition.\n-    pub(crate) index: usize,\n-    pub(crate) lifetime_count: usize,\n-    pub(crate) have_bound_regions: bool,\n-    pub(crate) span: Span,\n-}\n-\n type ScopeRef<'a> = &'a Scope<'a>;\n \n const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n@@ -421,7 +404,6 @@ fn do_resolve(\n         scope: ROOT_SCOPE,\n         trait_definition_only,\n         xcrate_object_lifetime_defaults: Default::default(),\n-        missing_named_lifetime_spots: vec![],\n     };\n     visitor.visit_item(item);\n \n@@ -644,40 +626,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 where_bound_origin: None,\n             };\n \n-            if let &hir::ClosureBinder::For { span, .. } = binder {\n-                let last_lt = bound_generic_params\n-                    .iter()\n-                    .filter(|p| {\n-                        matches!(\n-                            p,\n-                            GenericParam {\n-                                kind: GenericParamKind::Lifetime {\n-                                    kind: LifetimeParamKind::Explicit\n-                                },\n-                                ..\n-                            }\n-                        )\n-                    })\n-                    .last();\n-                let (span, span_type) = match last_lt {\n-                    Some(GenericParam { span: last_sp, .. }) => {\n-                        (last_sp.shrink_to_hi(), ForLifetimeSpanType::ClosureTail)\n-                    }\n-                    None => (span, ForLifetimeSpanType::ClosureEmpty),\n-                };\n-                self.missing_named_lifetime_spots\n-                    .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n-            }\n-\n             self.with(scope, |this| {\n                 // a closure has no bounds, so everything\n                 // contained within is scoped within its binder.\n                 intravisit::walk_expr(this, e)\n             });\n-\n-            if let hir::ClosureBinder::For { .. } = binder {\n-                self.missing_named_lifetime_spots.pop();\n-            }\n         } else {\n             intravisit::walk_expr(self, e)\n         }\n@@ -694,11 +647,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n         match item.kind {\n             hir::ItemKind::Fn(_, ref generics, _) => {\n-                self.missing_named_lifetime_spots.push(generics.into());\n                 self.visit_early_late(None, item.hir_id(), generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n-                self.missing_named_lifetime_spots.pop();\n             }\n \n             hir::ItemKind::ExternCrate(_)\n@@ -761,8 +712,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::Trait(_, _, ref generics, ..)\n             | hir::ItemKind::TraitAlias(ref generics, ..)\n             | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n-                self.missing_named_lifetime_spots.push(generics.into());\n-\n                 // These kinds of items have only early-bound lifetime parameters.\n                 let mut index = if sub_items_have_self_param(&item.kind) {\n                     1 // Self comes before lifetimes\n@@ -800,7 +749,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         intravisit::walk_item(this, item);\n                     });\n                 });\n-                self.missing_named_lifetime_spots.pop();\n             }\n         }\n     }\n@@ -826,20 +774,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         match ty.kind {\n             hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n-                let lifetime_span: Option<Span> =\n-                    c.generic_params.iter().rev().find_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit } => {\n-                            Some(param.span)\n-                        }\n-                        _ => None,\n-                    });\n-                let (span, span_type) = if let Some(span) = lifetime_span {\n-                    (span.shrink_to_hi(), ForLifetimeSpanType::TypeTail)\n-                } else {\n-                    (ty.span.shrink_to_lo(), ForLifetimeSpanType::TypeEmpty)\n-                };\n-                self.missing_named_lifetime_spots\n-                    .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n                 let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n@@ -867,7 +801,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     // contained within is scoped within its binder.\n                     intravisit::walk_ty(this, ty);\n                 });\n-                self.missing_named_lifetime_spots.pop();\n             }\n             hir::TyKind::TraitObject(bounds, ref lifetime, _) => {\n                 debug!(?bounds, ?lifetime, \"TraitObject\");\n@@ -878,19 +811,14 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                 });\n                 match lifetime.name {\n-                    LifetimeName::Implicit => {\n-                        // For types like `dyn Foo`, we should\n-                        // generate a special form of elided.\n-                        span_bug!(ty.span, \"object-lifetime-default expected, not implicit\",);\n-                    }\n                     LifetimeName::ImplicitObjectLifetimeDefault => {\n                         // If the user does not write *anything*, we\n                         // use the object lifetime defaulting\n                         // rules. So e.g., `Box<dyn Debug>` becomes\n                         // `Box<dyn Debug + 'static>`.\n                         self.resolve_object_lifetime_default(lifetime)\n                     }\n-                    LifetimeName::Underscore => {\n+                    LifetimeName::Implicit | LifetimeName::Underscore => {\n                         // If the user writes `'_`, we use the *ordinary* elision\n                         // rules. So the `'_` in e.g., `Box<dyn Debug + '_>` will be\n                         // resolved the same as the `'_` in `&'_ Foo`.\n@@ -1010,10 +938,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut elision = None;\n                 let mut lifetimes = FxIndexMap::default();\n                 let mut non_lifetime_count = 0;\n+                debug!(?generics.params);\n                 for param in generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (def_id, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n+                            lifetimes.insert(def_id, reg);\n                             if let hir::ParamName::Plain(Ident {\n                                 name: kw::UnderscoreLifetime,\n                                 ..\n@@ -1022,8 +952,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 // Pick the elided lifetime \"definition\" if one exists\n                                 // and use it to make an elision scope.\n                                 elision = Some(reg);\n-                            } else {\n-                                lifetimes.insert(def_id, reg);\n                             }\n                         }\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n@@ -1088,18 +1016,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         use self::hir::TraitItemKind::*;\n         match trait_item.kind {\n             Fn(_, _) => {\n-                self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(trait_item.hir_id())),\n                     trait_item.hir_id(),\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n                 );\n-                self.missing_named_lifetime_spots.pop();\n             }\n             Type(bounds, ref ty) => {\n-                self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let generics = &trait_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n@@ -1140,14 +1065,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         }\n                     })\n                 });\n-                self.missing_named_lifetime_spots.pop();\n             }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(trait_item.generics.params.is_empty());\n-                self.missing_named_lifetime_spots.push(MissingLifetimeSpot::Static);\n                 intravisit::walk_trait_item(self, trait_item);\n-                self.missing_named_lifetime_spots.pop();\n             }\n         }\n     }\n@@ -1156,19 +1078,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         use self::hir::ImplItemKind::*;\n         match impl_item.kind {\n             Fn(..) => {\n-                self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(impl_item.hir_id())),\n                     impl_item.hir_id(),\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n                 );\n-                self.missing_named_lifetime_spots.pop();\n             }\n             TyAlias(ref ty) => {\n                 let generics = &impl_item.generics;\n-                self.missing_named_lifetime_spots.push(generics.into());\n                 let mut index = self.next_early_index();\n                 let mut non_lifetime_count = 0;\n                 debug!(\"visit_ty: index = {}\", index);\n@@ -1203,14 +1122,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         this.visit_ty(ty);\n                     })\n                 });\n-                self.missing_named_lifetime_spots.pop();\n             }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(impl_item.generics.params.is_empty());\n-                self.missing_named_lifetime_spots.push(MissingLifetimeSpot::Static);\n                 intravisit::walk_impl_item(self, impl_item);\n-                self.missing_named_lifetime_spots.pop();\n             }\n         }\n     }\n@@ -1393,8 +1309,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         debug!(\"visit_poly_trait_ref(trait_ref={:?})\", trait_ref);\n \n-        let should_pop_missing_lt = self.is_trait_ref_fn_scope(trait_ref);\n-\n         let next_early_index = self.next_early_index();\n         let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n@@ -1435,10 +1349,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n             this.visit_trait_ref(&trait_ref.trait_ref);\n         });\n-\n-        if should_pop_missing_lt {\n-            self.missing_named_lifetime_spots.pop();\n-        }\n     }\n }\n \n@@ -1584,22 +1494,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     {\n         let LifetimeContext { tcx, map, .. } = self;\n         let xcrate_object_lifetime_defaults = take(&mut self.xcrate_object_lifetime_defaults);\n-        let missing_named_lifetime_spots = take(&mut self.missing_named_lifetime_spots);\n         let mut this = LifetimeContext {\n             tcx: *tcx,\n             map,\n             scope: &wrap_scope,\n             trait_definition_only: self.trait_definition_only,\n             xcrate_object_lifetime_defaults,\n-            missing_named_lifetime_spots,\n         };\n         let span = tracing::debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n             f(&mut this);\n         }\n         self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n-        self.missing_named_lifetime_spots = this.missing_named_lifetime_spots;\n     }\n \n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n@@ -2202,38 +2109,33 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut assoc_item_kind = None;\n         let mut impl_self = None;\n         let parent = self.tcx.hir().get_parent_node(output.hir_id);\n-        let body = match self.tcx.hir().get(parent) {\n+        match self.tcx.hir().get(parent) {\n             // `fn` definitions and methods.\n-            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(.., body), .. }) => Some(body),\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(..), .. }) => {}\n \n-            Node::TraitItem(&hir::TraitItem { kind: hir::TraitItemKind::Fn(_, ref m), .. }) => {\n+            Node::TraitItem(&hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. }) => {\n                 if let hir::ItemKind::Trait(.., ref trait_items) =\n                     self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n                 {\n                     assoc_item_kind =\n                         trait_items.iter().find(|ti| ti.id.hir_id() == parent).map(|ti| ti.kind);\n                 }\n-                match *m {\n-                    hir::TraitFn::Required(_) => None,\n-                    hir::TraitFn::Provided(body) => Some(body),\n-                }\n             }\n \n-            Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, body), .. }) => {\n+            Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, _), .. }) => {\n                 if let hir::ItemKind::Impl(hir::Impl { ref self_ty, ref items, .. }) =\n                     self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n                 {\n                     impl_self = Some(self_ty);\n                     assoc_item_kind =\n                         items.iter().find(|ii| ii.id.hir_id() == parent).map(|ii| ii.kind);\n                 }\n-                Some(body)\n             }\n \n             // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n-            Node::ForeignItem(_) | Node::Ty(_) | Node::TraitRef(_) => None,\n+            Node::ForeignItem(_) | Node::Ty(_) | Node::TraitRef(_) => {},\n \n-            Node::TypeBinding(_) if let Node::TraitRef(_) = self.tcx.hir().get(self.tcx.hir().get_parent_node(parent)) => None,\n+            Node::TypeBinding(_) if let Node::TraitRef(_) = self.tcx.hir().get(self.tcx.hir().get_parent_node(parent)) => {},\n \n             // Everything else (only closures?) doesn't\n             // actually enjoy elision in return types.\n@@ -2320,42 +2222,29 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // have that lifetime.\n         let mut possible_implied_output_region = None;\n         let mut lifetime_count = 0;\n-        let arg_lifetimes = inputs\n-            .iter()\n-            .enumerate()\n-            .skip(has_self as usize)\n-            .map(|(i, input)| {\n-                let mut gather = GatherLifetimes {\n-                    map: self.map,\n-                    outer_index: ty::INNERMOST,\n-                    have_bound_regions: false,\n-                    lifetimes: Default::default(),\n-                };\n-                gather.visit_ty(input);\n-\n-                lifetime_count += gather.lifetimes.len();\n+        for input in inputs.iter().skip(has_self as usize) {\n+            let mut gather = GatherLifetimes {\n+                map: self.map,\n+                outer_index: ty::INNERMOST,\n+                have_bound_regions: false,\n+                lifetimes: Default::default(),\n+            };\n+            gather.visit_ty(input);\n \n-                if lifetime_count == 1 && gather.lifetimes.len() == 1 {\n-                    // there's a chance that the unique lifetime of this\n-                    // iteration will be the appropriate lifetime for output\n-                    // parameters, so lets store it.\n-                    possible_implied_output_region = gather.lifetimes.iter().cloned().next();\n-                }\n+            lifetime_count += gather.lifetimes.len();\n \n-                ElisionFailureInfo {\n-                    parent: body,\n-                    index: i,\n-                    lifetime_count: gather.lifetimes.len(),\n-                    have_bound_regions: gather.have_bound_regions,\n-                    span: input.span,\n-                }\n-            })\n-            .collect();\n+            if lifetime_count == 1 && gather.lifetimes.len() == 1 {\n+                // there's a chance that the unique lifetime of this\n+                // iteration will be the appropriate lifetime for output\n+                // parameters, so lets store it.\n+                possible_implied_output_region = gather.lifetimes.iter().cloned().next();\n+            }\n+        }\n \n         let elide = if lifetime_count == 1 {\n             Elide::Exact(possible_implied_output_region.unwrap())\n         } else {\n-            Elide::Error(arg_lifetimes)\n+            Elide::Error\n         };\n \n         debug!(?elide);\n@@ -2487,17 +2376,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let mut late_depth = 0;\n         let mut scope = self.scope;\n-        let mut in_scope_lifetimes = FxIndexSet::default();\n-        let error = loop {\n+        loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n                 Scope::Body { .. } => return,\n \n-                Scope::Root => break None,\n+                Scope::Root => break,\n \n-                Scope::Binder { s, ref lifetimes, scope_type, .. } => {\n-                    // collect named lifetimes for suggestions\n-                    in_scope_lifetimes.extend(lifetimes.keys().copied());\n+                Scope::Binder { s, scope_type, .. } => {\n                     match scope_type {\n                         BinderScopeType::Normal => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n@@ -2526,54 +2412,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     return;\n                 }\n \n-                Scope::Elision { elide: Elide::Error(ref e), ref s, .. } => {\n-                    let mut scope = s;\n-                    loop {\n-                        match scope {\n-                            Scope::Binder { ref lifetimes, s, .. } => {\n-                                // Collect named lifetimes for suggestions.\n-                                in_scope_lifetimes.extend(lifetimes.keys().copied());\n-                                scope = s;\n-                            }\n-                            Scope::ObjectLifetimeDefault { ref s, .. }\n-                            | Scope::Elision { ref s, .. }\n-                            | Scope::TraitRefBoundary { ref s, .. } => {\n-                                scope = s;\n-                            }\n-                            _ => break,\n-                        }\n-                    }\n-                    break Some(&e[..]);\n-                }\n-\n-                Scope::Elision { elide: Elide::Forbid, .. } => break None,\n+                Scope::Elision { elide: Elide::Error, .. }\n+                | Scope::Elision { elide: Elide::Forbid, .. } => break,\n \n                 Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n                 }\n             }\n-        };\n-\n-        let mut spans: Vec<_> = lifetime_refs.iter().map(|lt| lt.span).collect();\n-        spans.sort();\n-        let mut spans_dedup = spans.clone();\n-        spans_dedup.dedup();\n-        let spans_with_counts: Vec<_> = spans_dedup\n-            .into_iter()\n-            .map(|sp| (sp, spans.iter().filter(|nsp| *nsp == &sp).count()))\n-            .collect();\n-\n-        let mut err = self.report_missing_lifetime_specifiers(spans.clone(), lifetime_refs.len());\n+        }\n \n-        self.add_missing_lifetime_specifiers_label(\n-            &mut err,\n-            spans_with_counts,\n-            in_scope_lifetimes,\n-            error,\n-        );\n-        err.emit();\n+        for lt in lifetime_refs {\n+            self.tcx.sess.delay_span_bug(lt.span, \"Missing lifetime specifier\");\n+        }\n     }\n \n     fn resolve_object_lifetime_default(&mut self, lifetime_ref: &'tcx hir::Lifetime) {"}, {"sha": "6945306a6918962d806ada168105cc4603aa9abf", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -11,6 +11,7 @@\n #![feature(drain_filter)]\n #![feature(if_let_guard)]\n #![cfg_attr(bootstrap, feature(let_chains))]\n+#![feature(iter_intersperse)]\n #![feature(let_else)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]"}, {"sha": "4a533939931b2c7c7d4fc0ad951ccab0e2dedcb2", "filename": "src/test/ui/associated-type-bounds/elision.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fassociated-type-bounds%2Felision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fassociated-type-bounds%2Felision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Felision.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -0,0 +1,9 @@\n+#![feature(associated_type_bounds)]\n+#![feature(anonymous_lifetime_in_impl_trait)]\n+\n+// The same thing should happen for constaints in dyn trait.\n+fn f(x: &mut dyn Iterator<Item: Iterator<Item = &'_ ()>>) -> Option<&'_ ()> { x.next() }\n+//~^ ERROR missing lifetime specifier\n+//~| ERROR mismatched types\n+\n+fn main() {}"}, {"sha": "ea3024627496527e6f1be0ad46a7f6c72d22465b", "filename": "src/test/ui/associated-type-bounds/elision.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fassociated-type-bounds%2Felision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fassociated-type-bounds%2Felision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Felision.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -0,0 +1,28 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/elision.rs:5:70\n+   |\n+LL | fn f(x: &mut dyn Iterator<Item: Iterator<Item = &'_ ()>>) -> Option<&'_ ()> { x.next() }\n+   |         ------------------------------------------------             ^^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `x`'s 2 lifetimes it is borrowed from\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn f<'a>(x: &'a mut dyn Iterator<Item: Iterator<Item = &'a ()>>) -> Option<&'a ()> { x.next() }\n+   |     ++++     ++                                         ~~                  ~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/elision.rs:5:79\n+   |\n+LL | fn f(x: &mut dyn Iterator<Item: Iterator<Item = &'_ ()>>) -> Option<&'_ ()> { x.next() }\n+   |                           -----------------------------      --------------   ^^^^^^^^ expected `&()`, found type parameter `impl Iterator<Item = &'_ ()>`\n+   |                           |                                  |\n+   |                           |                                  expected `Option<&'static ()>` because of return type\n+   |                           this type parameter\n+   |\n+   = note: expected enum `Option<&'static ()>`\n+              found enum `Option<impl Iterator<Item = &'_ ()>>`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0106, E0308.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "4de4afb6e92461699d2c208ef0aad2ead233b3e4", "filename": "src/test/ui/associated-types/bound-lifetime-in-binding-only.elision.stderr", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -5,15 +5,10 @@ LL | fn elision<T: Fn() -> &i32>() {\n    |                       ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n-help: consider making the bound lifetime-generic with a new `'a` lifetime\n-   |\n-LL | fn elision<T: for<'a> Fn() -> &'a i32>() {\n-   |               +++++++         ~~~\n help: consider using the `'static` lifetime\n    |\n LL | fn elision<T: Fn() -> &'static i32>() {\n-   |                       ~~~~~~~~\n+   |                        +++++++\n \n error: aborting due to previous error\n "}, {"sha": "7753d186504f815ef1aa954704394bff70907bfe", "filename": "src/test/ui/associated-types/bound-lifetime-in-return-only.elision.stderr", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -5,15 +5,10 @@ LL | fn elision(_: fn() -> &i32) {\n    |                       ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n-help: consider making the type lifetime-generic with a new `'a` lifetime\n-   |\n-LL | fn elision(_: for<'a> fn() -> &'a i32) {\n-   |               +++++++         ~~~\n help: consider using the `'static` lifetime\n    |\n LL | fn elision(_: fn() -> &'static i32) {\n-   |                       ~~~~~~~~\n+   |                        +++++++\n \n error: aborting due to previous error\n "}, {"sha": "90b59f96e5f553b46cabce767d07bb0aae4026bf", "filename": "src/test/ui/async-await/issues/issue-63388-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -11,6 +11,7 @@ impl Xyz {\n         foo: &dyn Foo, bar: &'a dyn Foo\n     ) -> &dyn Foo //~ ERROR missing lifetime specifier\n     {\n+        //~^ ERROR explicit lifetime required in the type of `foo` [E0621]\n         foo\n     }\n }"}, {"sha": "e515f227c7ef6641036104aaa2bb089734c1f798", "filename": "src/test/ui/async-await/issues/issue-63388-2.stderr", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -10,8 +10,21 @@ LL |     ) -> &dyn Foo\n help: consider using the `'a` lifetime\n    |\n LL |     ) -> &'a dyn Foo\n-   |          ~~~\n+   |           ++\n \n-error: aborting due to previous error\n+error[E0621]: explicit lifetime required in the type of `foo`\n+  --> $DIR/issue-63388-2.rs:13:5\n+   |\n+LL |           foo: &dyn Foo, bar: &'a dyn Foo\n+   |                -------- help: add explicit lifetime `'a` to the type of `foo`: `&'a (dyn Foo + 'a)`\n+LL |       ) -> &dyn Foo\n+LL | /     {\n+LL | |\n+LL | |         foo\n+LL | |     }\n+   | |_____^ lifetime `'a` required\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0106`.\n+Some errors have detailed explanations: E0106, E0621.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "4c7792d9650190e48b79c7dee7dd5fa8e735da1a", "filename": "src/test/ui/c-variadic/variadic-ffi-6.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -4,11 +4,11 @@ error[E0106]: missing lifetime specifier\n LL | ) -> &usize {\n    |      ^ expected named lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n LL | ) -> &'static usize {\n-   |      ~~~~~~~~\n+   |       +++++++\n \n error: aborting due to previous error\n "}, {"sha": "d11a24f7768552f853b2b1caceb770d258f054d5", "filename": "src/test/ui/error-codes/E0106.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Ferror-codes%2FE0106.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Ferror-codes%2FE0106.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0106.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -23,6 +23,17 @@ LL |     A(u8),\n LL ~     B(&'a bool),\n    |\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/E0106.rs:10:14\n+   |\n+LL | type MyStr = &str;\n+   |              ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | type MyStr<'a> = &'a str;\n+   |           ++++    ++\n+\n error[E0106]: missing lifetime specifier\n   --> $DIR/E0106.rs:17:10\n    |\n@@ -50,17 +61,6 @@ LL |\n LL ~     buzz: Buzz<'a, 'a>,\n    |\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/E0106.rs:10:14\n-   |\n-LL | type MyStr = &str;\n-   |              ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL | type MyStr<'a> = &'a str;\n-   |           ++++    ++\n-\n error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0106`."}, {"sha": "35a4b34fb0a4d457e77b2e5de653dbc75cb4f1a4", "filename": "src/test/ui/error-codes/E0637.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Ferror-codes%2FE0637.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Ferror-codes%2FE0637.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0637.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -4,12 +4,6 @@ error[E0637]: `'_` cannot be used here\n LL | fn underscore_lifetime<'_>(str1: &'_ str, str2: &'_ str) -> &'_ str {\n    |                        ^^ `'_` is a reserved lifetime name\n \n-error[E0637]: `&` without an explicit lifetime name cannot be used here\n-  --> $DIR/E0637.rs:13:13\n-   |\n-LL |     T: Into<&u32>,\n-   |             ^ explicit lifetime name needed here\n-\n error[E0106]: missing lifetime specifier\n   --> $DIR/E0637.rs:1:62\n    |\n@@ -22,6 +16,12 @@ help: consider introducing a named lifetime parameter\n LL | fn underscore_lifetime<'a, '_>(str1: &'a str, str2: &'a str) -> &'a str {\n    |                        +++            ~~             ~~          ~~\n \n+error[E0637]: `&` without an explicit lifetime name cannot be used here\n+  --> $DIR/E0637.rs:13:13\n+   |\n+LL |     T: Into<&u32>,\n+   |             ^ explicit lifetime name needed here\n+\n error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0106, E0637."}, {"sha": "df1a23a19edd51c3b2aab0f21f87ea3c9f28c094", "filename": "src/test/ui/foreign-fn-return-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -8,7 +8,7 @@ LL |     pub fn f() -> &u8;\n help: consider using the `'static` lifetime\n    |\n LL |     pub fn f() -> &'static u8;\n-   |                   ~~~~~~~~\n+   |                    +++++++\n \n error: aborting due to previous error\n "}, {"sha": "dbf7e02aeafccdb3d34859afab4397f225dd451e", "filename": "src/test/ui/generic-associated-types/gat-trait-path-generic-type-arg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-trait-path-generic-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-trait-path-generic-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-trait-path-generic-type-arg.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -7,9 +7,10 @@ trait Foo {\n }\n \n impl <T, T1> Foo for T {\n+    //~^ ERROR: the type parameter `T1` is not constrained\n     type F<T1> = &[u8];\n       //~^ ERROR: the name `T1` is already used for\n-      //~| ERROR: missing lifetime specifier\n+      //~| ERROR: `&` without an explicit lifetime name cannot be used here\n }\n \n fn main() {}"}, {"sha": "dad0dae6a44bff9fd1ccac0ebceede0089b10838", "filename": "src/test/ui/generic-associated-types/gat-trait-path-generic-type-arg.stderr", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-trait-path-generic-type-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-trait-path-generic-type-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-trait-path-generic-type-arg.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1,23 +1,25 @@\n error[E0403]: the name `T1` is already used for a generic parameter in this item's generic parameters\n-  --> $DIR/gat-trait-path-generic-type-arg.rs:10:12\n+  --> $DIR/gat-trait-path-generic-type-arg.rs:11:12\n    |\n LL | impl <T, T1> Foo for T {\n    |          -- first use of `T1`\n+LL |\n LL |     type F<T1> = &[u8];\n    |            ^^ already used\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/gat-trait-path-generic-type-arg.rs:10:18\n+error[E0637]: `&` without an explicit lifetime name cannot be used here\n+  --> $DIR/gat-trait-path-generic-type-arg.rs:11:18\n    |\n LL |     type F<T1> = &[u8];\n-   |                  ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n+   |                  ^ explicit lifetime name needed here\n+\n+error[E0207]: the type parameter `T1` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/gat-trait-path-generic-type-arg.rs:9:10\n    |\n-LL |     type F<'a, T1> = &'a [u8];\n-   |            +++        ++\n+LL | impl <T, T1> Foo for T {\n+   |          ^^ unconstrained type parameter\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0106, E0403.\n-For more information about an error, try `rustc --explain E0106`.\n+Some errors have detailed explanations: E0207, E0403, E0637.\n+For more information about an error, try `rustc --explain E0207`."}, {"sha": "f778f985cf0d1c277ad56f82cfd0cbc197c79320", "filename": "src/test/ui/generic-associated-types/issue-70304.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -2,6 +2,7 @@\n \n trait Document {\n     type Cursor<'a>: DocCursor<'a>;\n+    //~^ ERROR: missing required bound on `Cursor`\n \n     fn cursor(&self) -> Self::Cursor<'_>;\n }"}, {"sha": "bba7cab7093cefdd41855b256223c80865b0b0d6", "filename": "src/test/ui/generic-associated-types/issue-70304.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1,11 +1,11 @@\n error[E0637]: `'_` cannot be used here\n-  --> $DIR/issue-70304.rs:47:41\n+  --> $DIR/issue-70304.rs:48:41\n    |\n LL | fn create_doc() -> impl Document<Cursor<'_> = DocCursorImpl<'_>> {\n    |                                         ^^ `'_` is a reserved lifetime name\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-70304.rs:47:61\n+  --> $DIR/issue-70304.rs:48:61\n    |\n LL | fn create_doc() -> impl Document<Cursor<'_> = DocCursorImpl<'_>> {\n    |                                                             ^^ expected named lifetime parameter\n@@ -16,7 +16,18 @@ help: consider using the `'static` lifetime\n LL | fn create_doc() -> impl Document<Cursor<'_> = DocCursorImpl<'static>> {\n    |                                                             ~~~~~~~\n \n-error: aborting due to 2 previous errors\n+error: missing required bound on `Cursor`\n+  --> $DIR/issue-70304.rs:4:5\n+   |\n+LL |     type Cursor<'a>: DocCursor<'a>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |                                   |\n+   |                                   help: add the required where clause: `where Self: 'a`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n+\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0106, E0637.\n For more information about an error, try `rustc --explain E0106`."}, {"sha": "9ea9fc71b557fe13a64275fa774dcf328f576114", "filename": "src/test/ui/generics/issue-65285-incorrect-explicit-lifetime-name-needed.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -8,6 +8,7 @@ fn should_error<T>() where T : Into<&u32> {}\n trait X<'a, K: 'a> {\n     fn foo<'b, L: X<&'b Nested<K>>>();\n     //~^ ERROR missing lifetime specifier [E0106]\n+    //~| ERROR the type `&'b Nested<K>` does not fulfill the required lifetime\n }\n \n fn bar<'b, L: X<&'b Nested<i32>>>(){}"}, {"sha": "e45387acaf31df709d6c0860898fce2d5e021d6f", "filename": "src/test/ui/generics/issue-65285-incorrect-explicit-lifetime-name-needed.stderr", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -5,21 +5,10 @@ LL | fn should_error<T>() where T : Into<&u32> {}\n    |                                     ^ explicit lifetime name needed here\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:13:17\n-   |\n-LL | fn bar<'b, L: X<&'b Nested<i32>>>(){}\n-   |                 ^ expected named lifetime parameter\n-   |\n-help: consider using the `'b` lifetime\n-   |\n-LL | fn bar<'b, L: X<'b, &'b Nested<i32>>>(){}\n-   |                 +++\n-\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:9:21\n+  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:9:20\n    |\n LL |     fn foo<'b, L: X<&'b Nested<K>>>();\n-   |                     ^ expected named lifetime parameter\n+   |                    ^ expected named lifetime parameter\n    |\n note: these named lifetimes are available to use\n   --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:8:9\n@@ -33,7 +22,30 @@ help: consider using one of the available lifetimes here\n LL |     fn foo<'b, L: X<'lifetime, &'b Nested<K>>>();\n    |                     ++++++++++\n \n-error: aborting due to 3 previous errors\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:14:16\n+   |\n+LL | fn bar<'b, L: X<&'b Nested<i32>>>(){}\n+   |                ^ expected named lifetime parameter\n+   |\n+help: consider using the `'b` lifetime\n+   |\n+LL | fn bar<'b, L: X<'b, &'b Nested<i32>>>(){}\n+   |                 +++\n+\n+error[E0477]: the type `&'b Nested<K>` does not fulfill the required lifetime\n+  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:9:19\n+   |\n+LL |     fn foo<'b, L: X<&'b Nested<K>>>();\n+   |                   ^^^^^^^^^^^^^^^^\n+   |\n+note: type must satisfy the static lifetime as required by this binding\n+  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:8:16\n+   |\n+LL | trait X<'a, K: 'a> {\n+   |                ^^\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0106, E0637.\n+Some errors have detailed explanations: E0106, E0477, E0637.\n For more information about an error, try `rustc --explain E0106`."}, {"sha": "cd2f96a1819e466cc42bb127c17439545505bc42", "filename": "src/test/ui/generics/wrong-number-of-args.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -120,6 +120,7 @@ mod r#trait {\n     type B = Box<dyn GenericLifetime>;\n     //~^ ERROR missing lifetime specifier\n     //~| HELP consider introducing\n+    //~| HELP consider making the bound lifetime-generic\n \n     type C = Box<dyn GenericLifetime<'static, 'static>>;\n     //~^ ERROR this trait takes 1 lifetime argument but 2 lifetime arguments were supplied\n@@ -136,6 +137,7 @@ mod r#trait {\n     type F = Box<dyn GenericLifetime<>>;\n     //~^ ERROR missing lifetime specifier\n     //~| HELP consider introducing\n+    //~| HELP consider making the bound lifetime-generic\n \n     type G = Box<dyn GenericType<>>;\n     //~^ ERROR this trait takes 1 generic argument but 0 generic arguments\n@@ -161,6 +163,7 @@ mod associated_item {\n         type A = Box<dyn GenericLifetimeAT<AssocTy=()>>;\n         //~^ ERROR missing lifetime specifier\n         //~| HELP consider introducing\n+        //~| HELP consider making the bound lifetime-generic\n \n         type B = Box<dyn GenericLifetimeAT<'static, 'static, AssocTy=()>>;\n         //~^ ERROR this trait takes 1 lifetime argument but 2 lifetime arguments were supplied\n@@ -169,6 +172,7 @@ mod associated_item {\n         type C = Box<dyn GenericLifetimeAT<(), AssocTy=()>>;\n         //~^ ERROR missing lifetime specifier\n         //~| HELP consider introducing\n+        //~| HELP consider making the bound lifetime-generic\n         //~| ERROR this trait takes 0 generic arguments but 1 generic argument\n         //~| HELP remove\n     }\n@@ -203,6 +207,7 @@ mod associated_item {\n         //~| HELP add missing\n         //~| ERROR missing lifetime specifier\n         //~| HELP consider introducing\n+        //~| HELP consider making the bound lifetime-generic\n \n         type B = Box<dyn GenericLifetimeTypeAT<'static, AssocTy=()>>;\n         //~^ ERROR this trait takes 1 generic argument but 0 generic arguments were supplied\n@@ -217,10 +222,12 @@ mod associated_item {\n         type D = Box<dyn GenericLifetimeTypeAT<(), AssocTy=()>>;\n         //~^ ERROR missing lifetime specifier\n         //~| HELP consider introducing\n+        //~| HELP consider making the bound lifetime-generic\n \n         type E = Box<dyn GenericLifetimeTypeAT<(), (), AssocTy=()>>;\n         //~^ ERROR missing lifetime specifier\n         //~| HELP consider introducing\n+        //~| HELP consider making the bound lifetime-generic\n         //~| ERROR this trait takes 1 generic argument but 2 generic arguments\n         //~| HELP remove\n \n@@ -265,6 +272,7 @@ mod associated_item {\n         type A = Box<dyn GenericLifetimeLifetimeAT<AssocTy=()>>;\n         //~^ ERROR missing lifetime specifier\n         //~| HELP consider introducing\n+        //~| HELP consider making the bound lifetime-generic\n \n         type B = Box<dyn GenericLifetimeLifetimeAT<'static, AssocTy=()>>;\n         //~^ ERROR this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n@@ -279,6 +287,7 @@ mod associated_item {\n         type A = Box<dyn GenericLifetimeLifetimeTypeAT<AssocTy=()>>;\n         //~^ ERROR missing lifetime specifier\n         //~| HELP consider introducing\n+        //~| HELP consider making the bound lifetime-generic\n         //~| ERROR this trait takes 1 generic argument but 0 generic arguments\n         //~| HELP add missing\n "}, {"sha": "388c23fc24f74e2513f0898759b435d46de50237", "filename": "src/test/ui/generics/wrong-number-of-args.stderr", "status": "modified", "additions": 233, "deletions": 196, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1,3 +1,172 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:48:14\n+   |\n+LL |     type A = Ty;\n+   |              ^^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |     type A<'a> = Ty<'a>;\n+   |           ++++     ++++\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:58:16\n+   |\n+LL |     type C = Ty<usize>;\n+   |                ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |     type C<'a> = Ty<'a, usize>;\n+   |           ++++      +++\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:64:16\n+   |\n+LL |     type E = Ty<>;\n+   |                ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |     type E<'a> = Ty<'a, >;\n+   |           ++++      +++\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:120:22\n+   |\n+LL |     type B = Box<dyn GenericLifetime>;\n+   |                      ^^^^^^^^^^^^^^^ expected named lifetime parameter\n+   |\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL |     type B = Box<dyn for<'a> GenericLifetime<'a>>;\n+   |                      +++++++                ++++\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |     type B<'a> = Box<dyn GenericLifetime<'a>>;\n+   |           ++++                          ++++\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:137:37\n+   |\n+LL |     type F = Box<dyn GenericLifetime<>>;\n+   |                                     ^ expected named lifetime parameter\n+   |\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL |     type F = Box<dyn for<'a> GenericLifetime<'a, >>;\n+   |                      +++++++                 +++\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |     type F<'a> = Box<dyn GenericLifetime<'a, >>;\n+   |           ++++                           +++\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:163:43\n+   |\n+LL |         type A = Box<dyn GenericLifetimeAT<AssocTy=()>>;\n+   |                                           ^ expected named lifetime parameter\n+   |\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL |         type A = Box<dyn for<'a> GenericLifetimeAT<'a, AssocTy=()>>;\n+   |                          +++++++                   +++\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type A<'a> = Box<dyn GenericLifetimeAT<'a, AssocTy=()>>;\n+   |               ++++                             +++\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:172:43\n+   |\n+LL |         type C = Box<dyn GenericLifetimeAT<(), AssocTy=()>>;\n+   |                                           ^ expected named lifetime parameter\n+   |\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL |         type C = Box<dyn for<'a> GenericLifetimeAT<'a, (), AssocTy=()>>;\n+   |                          +++++++                   +++\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type C<'a> = Box<dyn GenericLifetimeAT<'a, (), AssocTy=()>>;\n+   |               ++++                             +++\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:205:47\n+   |\n+LL |         type A = Box<dyn GenericLifetimeTypeAT<AssocTy=()>>;\n+   |                                               ^ expected named lifetime parameter\n+   |\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL |         type A = Box<dyn for<'a> GenericLifetimeTypeAT<'a, AssocTy=()>>;\n+   |                          +++++++                       +++\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type A<'a> = Box<dyn GenericLifetimeTypeAT<'a, AssocTy=()>>;\n+   |               ++++                                 +++\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:222:47\n+   |\n+LL |         type D = Box<dyn GenericLifetimeTypeAT<(), AssocTy=()>>;\n+   |                                               ^ expected named lifetime parameter\n+   |\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL |         type D = Box<dyn for<'a> GenericLifetimeTypeAT<'a, (), AssocTy=()>>;\n+   |                          +++++++                       +++\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type D<'a> = Box<dyn GenericLifetimeTypeAT<'a, (), AssocTy=()>>;\n+   |               ++++                                 +++\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:227:47\n+   |\n+LL |         type E = Box<dyn GenericLifetimeTypeAT<(), (), AssocTy=()>>;\n+   |                                               ^ expected named lifetime parameter\n+   |\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL |         type E = Box<dyn for<'a> GenericLifetimeTypeAT<'a, (), (), AssocTy=()>>;\n+   |                          +++++++                       +++\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type E<'a> = Box<dyn GenericLifetimeTypeAT<'a, (), (), AssocTy=()>>;\n+   |               ++++                                 +++\n+\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/wrong-number-of-args.rs:272:51\n+   |\n+LL |         type A = Box<dyn GenericLifetimeLifetimeAT<AssocTy=()>>;\n+   |                                                   ^ expected 2 lifetime parameters\n+   |\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL |         type A = Box<dyn for<'a> GenericLifetimeLifetimeAT<'a, 'a, AssocTy=()>>;\n+   |                          +++++++                           +++++++\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type A<'a> = Box<dyn GenericLifetimeLifetimeAT<'a, 'a, AssocTy=()>>;\n+   |               ++++                                     +++++++\n+\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/wrong-number-of-args.rs:287:55\n+   |\n+LL |         type A = Box<dyn GenericLifetimeLifetimeTypeAT<AssocTy=()>>;\n+   |                                                       ^ expected 2 lifetime parameters\n+   |\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL |         type A = Box<dyn for<'a> GenericLifetimeLifetimeTypeAT<'a, 'a, AssocTy=()>>;\n+   |                          +++++++                               +++++++\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type A<'a> = Box<dyn GenericLifetimeLifetimeTypeAT<'a, 'a, AssocTy=()>>;\n+   |               ++++                                         +++++++\n+\n error[E0107]: this struct takes 0 lifetime arguments but 1 lifetime argument was supplied\n   --> $DIR/wrong-number-of-args.rs:6:14\n    |\n@@ -148,17 +317,6 @@ help: add missing generic argument\n LL |     type A = Ty<T>;\n    |              ~~~~~\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:48:14\n-   |\n-LL |     type A = Ty;\n-   |              ^^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |     type A<'a> = Ty<'a>;\n-   |           ++++   ~~~~~~\n-\n error[E0107]: this struct takes 1 generic argument but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:54:14\n    |\n@@ -175,17 +333,6 @@ help: add missing generic argument\n LL |     type B = Ty<'static, T>;\n    |                        +++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:58:17\n-   |\n-LL |     type C = Ty<usize>;\n-   |                 ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |     type C<'a> = Ty<'a, usize>;\n-   |           ++++      +++\n-\n error[E0107]: this struct takes 1 generic argument but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:64:14\n    |\n@@ -202,17 +349,6 @@ help: add missing generic argument\n LL |     type E = Ty<T>;\n    |                 +\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:64:16\n-   |\n-LL |     type E = Ty<>;\n-   |                ^- expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |     type E<'a> = Ty<'a>;\n-   |           ++++      ++\n-\n error[E0107]: this struct takes 1 lifetime argument but 2 lifetime arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:70:14\n    |\n@@ -319,19 +455,8 @@ note: trait defined here, with 0 generic parameters\n LL |     trait NonGeneric {\n    |           ^^^^^^^^^^\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:120:22\n-   |\n-LL |     type B = Box<dyn GenericLifetime>;\n-   |                      ^^^^^^^^^^^^^^^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |     type B<'a> = Box<dyn GenericLifetime<'a>>;\n-   |           ++++           ~~~~~~~~~~~~~~~~~~~\n-\n error[E0107]: this trait takes 1 lifetime argument but 2 lifetime arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:124:22\n+  --> $DIR/wrong-number-of-args.rs:125:22\n    |\n LL |     type C = Box<dyn GenericLifetime<'static, 'static>>;\n    |                      ^^^^^^^^^^^^^^^          ------- help: remove this lifetime argument\n@@ -345,7 +470,7 @@ LL |     trait GenericLifetime<'a> {\n    |           ^^^^^^^^^^^^^^^ --\n \n error[E0107]: missing generics for trait `GenericType`\n-  --> $DIR/wrong-number-of-args.rs:128:22\n+  --> $DIR/wrong-number-of-args.rs:129:22\n    |\n LL |     type D = Box<dyn GenericType>;\n    |                      ^^^^^^^^^^^ expected 1 generic argument\n@@ -361,7 +486,7 @@ LL |     type D = Box<dyn GenericType<A>>;\n    |                      ~~~~~~~~~~~~~~\n \n error[E0107]: this trait takes 1 generic argument but 2 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:132:22\n+  --> $DIR/wrong-number-of-args.rs:133:22\n    |\n LL |     type E = Box<dyn GenericType<String, usize>>;\n    |                      ^^^^^^^^^^^         ----- help: remove this generic argument\n@@ -374,19 +499,8 @@ note: trait defined here, with 1 generic parameter: `A`\n LL |     trait GenericType<A> {\n    |           ^^^^^^^^^^^ -\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:136:37\n-   |\n-LL |     type F = Box<dyn GenericLifetime<>>;\n-   |                                     ^- expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |     type F<'a> = Box<dyn GenericLifetime<'a>>;\n-   |           ++++                           ++\n-\n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:140:22\n+  --> $DIR/wrong-number-of-args.rs:142:22\n    |\n LL |     type G = Box<dyn GenericType<>>;\n    |                      ^^^^^^^^^^^ expected 1 generic argument\n@@ -402,77 +516,55 @@ LL |     type G = Box<dyn GenericType<A>>;\n    |                                  +\n \n error[E0107]: this trait takes 0 generic arguments but 1 generic argument was supplied\n-  --> $DIR/wrong-number-of-args.rs:151:26\n+  --> $DIR/wrong-number-of-args.rs:153:26\n    |\n LL |         type A = Box<dyn NonGenericAT<usize, AssocTy=()>>;\n    |                          ^^^^^^^^^^^^------------------- help: remove these generics\n    |                          |\n    |                          expected 0 generic arguments\n    |\n note: trait defined here, with 0 generic parameters\n-  --> $DIR/wrong-number-of-args.rs:147:15\n+  --> $DIR/wrong-number-of-args.rs:149:15\n    |\n LL |         trait NonGenericAT {\n    |               ^^^^^^^^^^^^\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:161:44\n-   |\n-LL |         type A = Box<dyn GenericLifetimeAT<AssocTy=()>>;\n-   |                                            ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type A<'a> = Box<dyn GenericLifetimeAT<'a, AssocTy=()>>;\n-   |               ++++                             +++\n-\n error[E0107]: this trait takes 1 lifetime argument but 2 lifetime arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:165:26\n+  --> $DIR/wrong-number-of-args.rs:168:26\n    |\n LL |         type B = Box<dyn GenericLifetimeAT<'static, 'static, AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^          ------- help: remove this lifetime argument\n    |                          |\n    |                          expected 1 lifetime argument\n    |\n note: trait defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/wrong-number-of-args.rs:157:15\n+  --> $DIR/wrong-number-of-args.rs:159:15\n    |\n LL |         trait GenericLifetimeAT<'a> {\n    |               ^^^^^^^^^^^^^^^^^ --\n \n error[E0107]: this trait takes 0 generic arguments but 1 generic argument was supplied\n-  --> $DIR/wrong-number-of-args.rs:169:26\n+  --> $DIR/wrong-number-of-args.rs:172:26\n    |\n LL |         type C = Box<dyn GenericLifetimeAT<(), AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^ -- help: remove this generic argument\n    |                          |\n    |                          expected 0 generic arguments\n    |\n note: trait defined here, with 0 generic parameters\n-  --> $DIR/wrong-number-of-args.rs:157:15\n+  --> $DIR/wrong-number-of-args.rs:159:15\n    |\n LL |         trait GenericLifetimeAT<'a> {\n    |               ^^^^^^^^^^^^^^^^^\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:169:44\n-   |\n-LL |         type C = Box<dyn GenericLifetimeAT<(), AssocTy=()>>;\n-   |                                            ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type C<'a> = Box<dyn GenericLifetimeAT<'a, (), AssocTy=()>>;\n-   |               ++++                             +++\n-\n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:181:26\n+  --> $DIR/wrong-number-of-args.rs:185:26\n    |\n LL |         type A = Box<dyn GenericTypeAT<AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^ expected 1 generic argument\n    |\n note: trait defined here, with 1 generic parameter: `A`\n-  --> $DIR/wrong-number-of-args.rs:177:15\n+  --> $DIR/wrong-number-of-args.rs:181:15\n    |\n LL |         trait GenericTypeAT<A> {\n    |               ^^^^^^^^^^^^^ -\n@@ -482,41 +574,41 @@ LL |         type A = Box<dyn GenericTypeAT<A, AssocTy=()>>;\n    |                                        ++\n \n error[E0107]: this trait takes 1 generic argument but 2 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:185:26\n+  --> $DIR/wrong-number-of-args.rs:189:26\n    |\n LL |         type B = Box<dyn GenericTypeAT<(), (), AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^     -- help: remove this generic argument\n    |                          |\n    |                          expected 1 generic argument\n    |\n note: trait defined here, with 1 generic parameter: `A`\n-  --> $DIR/wrong-number-of-args.rs:177:15\n+  --> $DIR/wrong-number-of-args.rs:181:15\n    |\n LL |         trait GenericTypeAT<A> {\n    |               ^^^^^^^^^^^^^ -\n \n error[E0107]: this trait takes 0 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/wrong-number-of-args.rs:189:26\n+  --> $DIR/wrong-number-of-args.rs:193:26\n    |\n LL |         type C = Box<dyn GenericTypeAT<'static, AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^--------------------- help: remove these generics\n    |                          |\n    |                          expected 0 lifetime arguments\n    |\n note: trait defined here, with 0 lifetime parameters\n-  --> $DIR/wrong-number-of-args.rs:177:15\n+  --> $DIR/wrong-number-of-args.rs:181:15\n    |\n LL |         trait GenericTypeAT<A> {\n    |               ^^^^^^^^^^^^^\n \n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:189:26\n+  --> $DIR/wrong-number-of-args.rs:193:26\n    |\n LL |         type C = Box<dyn GenericTypeAT<'static, AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^ expected 1 generic argument\n    |\n note: trait defined here, with 1 generic parameter: `A`\n-  --> $DIR/wrong-number-of-args.rs:177:15\n+  --> $DIR/wrong-number-of-args.rs:181:15\n    |\n LL |         trait GenericTypeAT<A> {\n    |               ^^^^^^^^^^^^^ -\n@@ -526,13 +618,13 @@ LL |         type C = Box<dyn GenericTypeAT<'static, A, AssocTy=()>>;\n    |                                               +++\n \n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:201:26\n+  --> $DIR/wrong-number-of-args.rs:205:26\n    |\n LL |         type A = Box<dyn GenericLifetimeTypeAT<AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^ expected 1 generic argument\n    |\n note: trait defined here, with 1 generic parameter: `A`\n-  --> $DIR/wrong-number-of-args.rs:197:15\n+  --> $DIR/wrong-number-of-args.rs:201:15\n    |\n LL |         trait GenericLifetimeTypeAT<'a, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^     -\n@@ -541,25 +633,14 @@ help: add missing generic argument\n LL |         type A = Box<dyn GenericLifetimeTypeAT<A, AssocTy=()>>;\n    |                                                ++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:201:48\n-   |\n-LL |         type A = Box<dyn GenericLifetimeTypeAT<AssocTy=()>>;\n-   |                                                ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type A<'a> = Box<dyn GenericLifetimeTypeAT<'a, AssocTy=()>>;\n-   |               ++++                                 +++\n-\n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:207:26\n+  --> $DIR/wrong-number-of-args.rs:212:26\n    |\n LL |         type B = Box<dyn GenericLifetimeTypeAT<'static, AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^ expected 1 generic argument\n    |\n note: trait defined here, with 1 generic parameter: `A`\n-  --> $DIR/wrong-number-of-args.rs:197:15\n+  --> $DIR/wrong-number-of-args.rs:201:15\n    |\n LL |         trait GenericLifetimeTypeAT<'a, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^     -\n@@ -569,27 +650,27 @@ LL |         type B = Box<dyn GenericLifetimeTypeAT<'static, A, AssocTy=()>>;\n    |                                                       +++\n \n error[E0107]: this trait takes 1 lifetime argument but 2 lifetime arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:211:26\n+  --> $DIR/wrong-number-of-args.rs:216:26\n    |\n LL |         type C = Box<dyn GenericLifetimeTypeAT<'static, 'static, AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^          ------- help: remove this lifetime argument\n    |                          |\n    |                          expected 1 lifetime argument\n    |\n note: trait defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/wrong-number-of-args.rs:197:15\n+  --> $DIR/wrong-number-of-args.rs:201:15\n    |\n LL |         trait GenericLifetimeTypeAT<'a, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^ --\n \n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:211:26\n+  --> $DIR/wrong-number-of-args.rs:216:26\n    |\n LL |         type C = Box<dyn GenericLifetimeTypeAT<'static, 'static, AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^ expected 1 generic argument\n    |\n note: trait defined here, with 1 generic parameter: `A`\n-  --> $DIR/wrong-number-of-args.rs:197:15\n+  --> $DIR/wrong-number-of-args.rs:201:15\n    |\n LL |         trait GenericLifetimeTypeAT<'a, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^     -\n@@ -598,106 +679,84 @@ help: add missing generic argument\n LL |         type C = Box<dyn GenericLifetimeTypeAT<'static, 'static, A, AssocTy=()>>;\n    |                                                                +++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:217:48\n-   |\n-LL |         type D = Box<dyn GenericLifetimeTypeAT<(), AssocTy=()>>;\n-   |                                                ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type D<'a> = Box<dyn GenericLifetimeTypeAT<'a, (), AssocTy=()>>;\n-   |               ++++                                 +++\n-\n error[E0107]: this trait takes 1 generic argument but 2 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:221:26\n+  --> $DIR/wrong-number-of-args.rs:227:26\n    |\n LL |         type E = Box<dyn GenericLifetimeTypeAT<(), (), AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^     -- help: remove this generic argument\n    |                          |\n    |                          expected 1 generic argument\n    |\n note: trait defined here, with 1 generic parameter: `A`\n-  --> $DIR/wrong-number-of-args.rs:197:15\n+  --> $DIR/wrong-number-of-args.rs:201:15\n    |\n LL |         trait GenericLifetimeTypeAT<'a, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^     -\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:221:48\n-   |\n-LL |         type E = Box<dyn GenericLifetimeTypeAT<(), (), AssocTy=()>>;\n-   |                                                ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type E<'a> = Box<dyn GenericLifetimeTypeAT<'a, (), (), AssocTy=()>>;\n-   |               ++++                                 +++\n-\n error[E0107]: this trait takes 1 lifetime argument but 2 lifetime arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:227:26\n+  --> $DIR/wrong-number-of-args.rs:234:26\n    |\n LL |         type F = Box<dyn GenericLifetimeTypeAT<'static, 'static, (), AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^          ------- help: remove this lifetime argument\n    |                          |\n    |                          expected 1 lifetime argument\n    |\n note: trait defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/wrong-number-of-args.rs:197:15\n+  --> $DIR/wrong-number-of-args.rs:201:15\n    |\n LL |         trait GenericLifetimeTypeAT<'a, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^ --\n \n error[E0107]: this trait takes 1 generic argument but 2 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:231:26\n+  --> $DIR/wrong-number-of-args.rs:238:26\n    |\n LL |         type G = Box<dyn GenericLifetimeTypeAT<'static, (), (), AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^              -- help: remove this generic argument\n    |                          |\n    |                          expected 1 generic argument\n    |\n note: trait defined here, with 1 generic parameter: `A`\n-  --> $DIR/wrong-number-of-args.rs:197:15\n+  --> $DIR/wrong-number-of-args.rs:201:15\n    |\n LL |         trait GenericLifetimeTypeAT<'a, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^     -\n \n error[E0107]: this trait takes 1 lifetime argument but 2 lifetime arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:235:26\n+  --> $DIR/wrong-number-of-args.rs:242:26\n    |\n LL |         type H = Box<dyn GenericLifetimeTypeAT<'static, 'static, (), (), AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^          ------- help: remove this lifetime argument\n    |                          |\n    |                          expected 1 lifetime argument\n    |\n note: trait defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/wrong-number-of-args.rs:197:15\n+  --> $DIR/wrong-number-of-args.rs:201:15\n    |\n LL |         trait GenericLifetimeTypeAT<'a, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^ --\n \n error[E0107]: this trait takes 1 generic argument but 2 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:235:26\n+  --> $DIR/wrong-number-of-args.rs:242:26\n    |\n LL |         type H = Box<dyn GenericLifetimeTypeAT<'static, 'static, (), (), AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^                       -- help: remove this generic argument\n    |                          |\n    |                          expected 1 generic argument\n    |\n note: trait defined here, with 1 generic parameter: `A`\n-  --> $DIR/wrong-number-of-args.rs:197:15\n+  --> $DIR/wrong-number-of-args.rs:201:15\n    |\n LL |         trait GenericLifetimeTypeAT<'a, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^     -\n \n error[E0107]: this trait takes 2 generic arguments but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:247:26\n+  --> $DIR/wrong-number-of-args.rs:254:26\n    |\n LL |         type A = Box<dyn GenericTypeTypeAT<AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^ expected 2 generic arguments\n    |\n note: trait defined here, with 2 generic parameters: `A`, `B`\n-  --> $DIR/wrong-number-of-args.rs:243:15\n+  --> $DIR/wrong-number-of-args.rs:250:15\n    |\n LL |         trait GenericTypeTypeAT<A, B> {\n    |               ^^^^^^^^^^^^^^^^^ -  -\n@@ -707,15 +766,15 @@ LL |         type A = Box<dyn GenericTypeTypeAT<A, B, AssocTy=()>>;\n    |                                            +++++\n \n error[E0107]: this trait takes 2 generic arguments but 1 generic argument was supplied\n-  --> $DIR/wrong-number-of-args.rs:251:26\n+  --> $DIR/wrong-number-of-args.rs:258:26\n    |\n LL |         type B = Box<dyn GenericTypeTypeAT<(), AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^ -- supplied 1 generic argument\n    |                          |\n    |                          expected 2 generic arguments\n    |\n note: trait defined here, with 2 generic parameters: `A`, `B`\n-  --> $DIR/wrong-number-of-args.rs:243:15\n+  --> $DIR/wrong-number-of-args.rs:250:15\n    |\n LL |         trait GenericTypeTypeAT<A, B> {\n    |               ^^^^^^^^^^^^^^^^^ -  -\n@@ -725,40 +784,29 @@ LL |         type B = Box<dyn GenericTypeTypeAT<(), B, AssocTy=()>>;\n    |                                              +++\n \n error[E0107]: this trait takes 2 generic arguments but 3 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:255:26\n+  --> $DIR/wrong-number-of-args.rs:262:26\n    |\n LL |         type C = Box<dyn GenericTypeTypeAT<(), (), (), AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^         -- help: remove this generic argument\n    |                          |\n    |                          expected 2 generic arguments\n    |\n note: trait defined here, with 2 generic parameters: `A`, `B`\n-  --> $DIR/wrong-number-of-args.rs:243:15\n+  --> $DIR/wrong-number-of-args.rs:250:15\n    |\n LL |         trait GenericTypeTypeAT<A, B> {\n    |               ^^^^^^^^^^^^^^^^^ -  -\n \n-error[E0106]: missing lifetime specifiers\n-  --> $DIR/wrong-number-of-args.rs:265:52\n-   |\n-LL |         type A = Box<dyn GenericLifetimeLifetimeAT<AssocTy=()>>;\n-   |                                                    ^ expected 2 lifetime parameters\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type A<'a> = Box<dyn GenericLifetimeLifetimeAT<'a, 'a, AssocTy=()>>;\n-   |               ++++                                     +++++++\n-\n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/wrong-number-of-args.rs:269:26\n+  --> $DIR/wrong-number-of-args.rs:277:26\n    |\n LL |         type B = Box<dyn GenericLifetimeLifetimeAT<'static, AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^ ------- supplied 1 lifetime argument\n    |                          |\n    |                          expected 2 lifetime arguments\n    |\n note: trait defined here, with 2 lifetime parameters: `'a`, `'b`\n-  --> $DIR/wrong-number-of-args.rs:261:15\n+  --> $DIR/wrong-number-of-args.rs:268:15\n    |\n LL |         trait GenericLifetimeLifetimeAT<'a, 'b> {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^ --  --\n@@ -768,13 +816,13 @@ LL |         type B = Box<dyn GenericLifetimeLifetimeAT<'static, 'b, AssocTy=()>\n    |                                                           ++++\n \n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:279:26\n+  --> $DIR/wrong-number-of-args.rs:287:26\n    |\n LL |         type A = Box<dyn GenericLifetimeLifetimeTypeAT<AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 generic argument\n    |\n note: trait defined here, with 1 generic parameter: `A`\n-  --> $DIR/wrong-number-of-args.rs:275:15\n+  --> $DIR/wrong-number-of-args.rs:283:15\n    |\n LL |         trait GenericLifetimeLifetimeTypeAT<'a, 'b, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^         -\n@@ -783,27 +831,16 @@ help: add missing generic argument\n LL |         type A = Box<dyn GenericLifetimeLifetimeTypeAT<A, AssocTy=()>>;\n    |                                                        ++\n \n-error[E0106]: missing lifetime specifiers\n-  --> $DIR/wrong-number-of-args.rs:279:56\n-   |\n-LL |         type A = Box<dyn GenericLifetimeLifetimeTypeAT<AssocTy=()>>;\n-   |                                                        ^ expected 2 lifetime parameters\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type A<'a> = Box<dyn GenericLifetimeLifetimeTypeAT<'a, 'a, AssocTy=()>>;\n-   |               ++++                                         +++++++\n-\n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/wrong-number-of-args.rs:285:26\n+  --> $DIR/wrong-number-of-args.rs:294:26\n    |\n LL |         type B = Box<dyn GenericLifetimeLifetimeTypeAT<'static, AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ------- supplied 1 lifetime argument\n    |                          |\n    |                          expected 2 lifetime arguments\n    |\n note: trait defined here, with 2 lifetime parameters: `'a`, `'b`\n-  --> $DIR/wrong-number-of-args.rs:275:15\n+  --> $DIR/wrong-number-of-args.rs:283:15\n    |\n LL |         trait GenericLifetimeLifetimeTypeAT<'a, 'b, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ --  --\n@@ -813,13 +850,13 @@ LL |         type B = Box<dyn GenericLifetimeLifetimeTypeAT<'static, 'b, AssocTy\n    |                                                               ++++\n \n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:285:26\n+  --> $DIR/wrong-number-of-args.rs:294:26\n    |\n LL |         type B = Box<dyn GenericLifetimeLifetimeTypeAT<'static, AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 generic argument\n    |\n note: trait defined here, with 1 generic parameter: `A`\n-  --> $DIR/wrong-number-of-args.rs:275:15\n+  --> $DIR/wrong-number-of-args.rs:283:15\n    |\n LL |         trait GenericLifetimeLifetimeTypeAT<'a, 'b, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^         -\n@@ -829,15 +866,15 @@ LL |         type B = Box<dyn GenericLifetimeLifetimeTypeAT<'static, A, AssocTy=\n    |                                                               +++\n \n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/wrong-number-of-args.rs:291:26\n+  --> $DIR/wrong-number-of-args.rs:300:26\n    |\n LL |         type C = Box<dyn GenericLifetimeLifetimeTypeAT<'static, (), AssocTy=()>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ------- supplied 1 lifetime argument\n    |                          |\n    |                          expected 2 lifetime arguments\n    |\n note: trait defined here, with 2 lifetime parameters: `'a`, `'b`\n-  --> $DIR/wrong-number-of-args.rs:275:15\n+  --> $DIR/wrong-number-of-args.rs:283:15\n    |\n LL |         trait GenericLifetimeLifetimeTypeAT<'a, 'b, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ --  --\n@@ -847,7 +884,7 @@ LL |         type C = Box<dyn GenericLifetimeLifetimeTypeAT<'static, 'b, (), Ass\n    |                                                               ++++\n \n error[E0107]: missing generics for struct `HashMap`\n-  --> $DIR/wrong-number-of-args.rs:301:18\n+  --> $DIR/wrong-number-of-args.rs:310:18\n    |\n LL |         type A = HashMap;\n    |                  ^^^^^^^ expected at least 2 generic arguments\n@@ -863,7 +900,7 @@ LL |         type A = HashMap<K, V>;\n    |                  ~~~~~~~~~~~~~\n \n error[E0107]: this struct takes at least 2 generic arguments but 1 generic argument was supplied\n-  --> $DIR/wrong-number-of-args.rs:305:18\n+  --> $DIR/wrong-number-of-args.rs:314:18\n    |\n LL |         type B = HashMap<String>;\n    |                  ^^^^^^^ ------ supplied 1 generic argument\n@@ -881,7 +918,7 @@ LL |         type B = HashMap<String, V>;\n    |                                +++\n \n error[E0107]: this struct takes 0 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/wrong-number-of-args.rs:309:18\n+  --> $DIR/wrong-number-of-args.rs:318:18\n    |\n LL |         type C = HashMap<'static>;\n    |                  ^^^^^^^--------- help: remove these generics\n@@ -895,7 +932,7 @@ LL | pub struct HashMap<K, V, S = RandomState> {\n    |            ^^^^^^^\n \n error[E0107]: this struct takes at least 2 generic arguments but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:309:18\n+  --> $DIR/wrong-number-of-args.rs:318:18\n    |\n LL |         type C = HashMap<'static>;\n    |                  ^^^^^^^ expected at least 2 generic arguments\n@@ -911,7 +948,7 @@ LL |         type C = HashMap<'static, K, V>;\n    |                                 ++++++\n \n error[E0107]: this struct takes at most 3 generic arguments but 4 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:315:18\n+  --> $DIR/wrong-number-of-args.rs:324:18\n    |\n LL |         type D = HashMap<usize, String, char, f64>;\n    |                  ^^^^^^^                      --- help: remove this generic argument\n@@ -925,7 +962,7 @@ LL | pub struct HashMap<K, V, S = RandomState> {\n    |            ^^^^^^^ -  -  ---------------\n \n error[E0107]: this struct takes at least 2 generic arguments but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:319:18\n+  --> $DIR/wrong-number-of-args.rs:328:18\n    |\n LL |         type E = HashMap<>;\n    |                  ^^^^^^^ expected at least 2 generic arguments\n@@ -941,7 +978,7 @@ LL |         type E = HashMap<K, V>;\n    |                          ++++\n \n error[E0107]: missing generics for enum `Result`\n-  --> $DIR/wrong-number-of-args.rs:325:18\n+  --> $DIR/wrong-number-of-args.rs:334:18\n    |\n LL |         type A = Result;\n    |                  ^^^^^^ expected 2 generic arguments\n@@ -957,7 +994,7 @@ LL |         type A = Result<T, E>;\n    |                  ~~~~~~~~~~~~\n \n error[E0107]: this enum takes 2 generic arguments but 1 generic argument was supplied\n-  --> $DIR/wrong-number-of-args.rs:329:18\n+  --> $DIR/wrong-number-of-args.rs:338:18\n    |\n LL |         type B = Result<String>;\n    |                  ^^^^^^ ------ supplied 1 generic argument\n@@ -975,7 +1012,7 @@ LL |         type B = Result<String, E>;\n    |                               +++\n \n error[E0107]: this enum takes 0 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/wrong-number-of-args.rs:333:18\n+  --> $DIR/wrong-number-of-args.rs:342:18\n    |\n LL |         type C = Result<'static>;\n    |                  ^^^^^^--------- help: remove these generics\n@@ -989,7 +1026,7 @@ LL | pub enum Result<T, E> {\n    |          ^^^^^^\n \n error[E0107]: this enum takes 2 generic arguments but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:333:18\n+  --> $DIR/wrong-number-of-args.rs:342:18\n    |\n LL |         type C = Result<'static>;\n    |                  ^^^^^^ expected 2 generic arguments\n@@ -1005,7 +1042,7 @@ LL |         type C = Result<'static, T, E>;\n    |                                ++++++\n \n error[E0107]: this enum takes 2 generic arguments but 3 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:339:18\n+  --> $DIR/wrong-number-of-args.rs:348:18\n    |\n LL |         type D = Result<usize, String, char>;\n    |                  ^^^^^^                ---- help: remove this generic argument\n@@ -1019,7 +1056,7 @@ LL | pub enum Result<T, E> {\n    |          ^^^^^^ -  -\n \n error[E0107]: this enum takes 2 generic arguments but 0 generic arguments were supplied\n-  --> $DIR/wrong-number-of-args.rs:343:18\n+  --> $DIR/wrong-number-of-args.rs:352:18\n    |\n LL |         type E = Result<>;\n    |                  ^^^^^^ expected 2 generic arguments"}, {"sha": "b0089a37aa05fc1771469babced75326d4a86aee", "filename": "src/test/ui/impl-header-lifetime-elision/assoc-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fassoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fassoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fassoc-type.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -9,12 +9,12 @@ trait MyTrait {\n \n impl MyTrait for &i32 {\n     type Output = &i32;\n-    //~^ ERROR missing lifetime specifier\n+    //~^ ERROR `&` without an explicit lifetime name cannot be used here\n }\n \n impl MyTrait for &u32 {\n     type Output = &'_ i32;\n-    //~^ ERROR missing lifetime specifier\n+    //~^ ERROR `'_` cannot be used here\n }\n \n // This is what you have to do:"}, {"sha": "c4f27e0b80e41d5ba8a5b1424e6d39889482ec8a", "filename": "src/test/ui/impl-header-lifetime-elision/assoc-type.stderr", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fassoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fassoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fassoc-type.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1,25 +1,15 @@\n-error[E0106]: missing lifetime specifier\n+error[E0637]: `&` without an explicit lifetime name cannot be used here\n   --> $DIR/assoc-type.rs:11:19\n    |\n LL |     type Output = &i32;\n-   |                   ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |     type Output<'a> = &'a i32;\n-   |                ++++    ++\n+   |                   ^ explicit lifetime name needed here\n \n-error[E0106]: missing lifetime specifier\n+error[E0637]: `'_` cannot be used here\n   --> $DIR/assoc-type.rs:16:20\n    |\n LL |     type Output = &'_ i32;\n-   |                    ^^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |     type Output<'a> = &'a i32;\n-   |                ++++    ~~\n+   |                    ^^ `'_` is a reserved lifetime name\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0106`.\n+For more information about this error, try `rustc --explain E0637`."}, {"sha": "4b1d979da36e39d35200b7d66bb250ed49541d32", "filename": "src/test/ui/issues/issue-13497.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fissues%2Fissue-13497.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fissues%2Fissue-13497.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13497.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -8,7 +8,7 @@ LL |     &str\n help: consider using the `'static` lifetime\n    |\n LL |     &'static str\n-   |     ~~~~~~~~\n+   |      +++++++\n \n error: aborting due to previous error\n "}, {"sha": "3e1bb32c19b92e48676102b0544263389d645b1e", "filename": "src/test/ui/issues/issue-19707.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fissues%2Fissue-19707.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fissues%2Fissue-19707.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-19707.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -22,7 +22,6 @@ LL | fn bar<F: Fn(&u8, &u8) -> &u8>(f: &F) {}\n    |              ---  ---     ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from argument 1 or argument 2\n-   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n help: consider making the bound lifetime-generic with a new `'a` lifetime\n    |\n LL | fn bar<F: for<'a> Fn(&'a u8, &'a u8) -> &'a u8>(f: &F) {}"}, {"sha": "adb721a1cbaf18c290e7eeb10cd6b62494e023e2", "filename": "src/test/ui/issues/issue-30255.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fissues%2Fissue-30255.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fissues%2Fissue-30255.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30255.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -7,8 +7,8 @@ LL | fn f(a: &S, b: i32) -> &i32 {\n    = help: this function's return type contains a borrowed value, but the signature does not say which one of `a`'s 2 lifetimes it is borrowed from\n help: consider introducing a named lifetime parameter\n    |\n-LL | fn f<'a>(a: &'a S, b: i32) -> &'a i32 {\n-   |     ++++     ++                ++\n+LL | fn f<'a>(a: &'a S<'a>, b: i32) -> &'a i32 {\n+   |     ++++     ++  ++++              ++\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/issue-30255.rs:14:34\n@@ -19,8 +19,8 @@ LL | fn g(a: &S, b: bool, c: &i32) -> &i32 {\n    = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from one of `a`'s 2 lifetimes or `c`\n help: consider introducing a named lifetime parameter\n    |\n-LL | fn g<'a>(a: &'a S, b: bool, c: &'a i32) -> &'a i32 {\n-   |     ++++     ++                 ++          ++\n+LL | fn g<'a>(a: &'a S<'a>, b: bool, c: &'a i32) -> &'a i32 {\n+   |     ++++     ++  ++++               ++          ++\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/issue-30255.rs:19:44\n@@ -31,8 +31,8 @@ LL | fn h(a: &bool, b: bool, c: &S, d: &i32) -> &i32 {\n    = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a`, one of `c`'s 2 lifetimes, or `d`\n help: consider introducing a named lifetime parameter\n    |\n-LL | fn h<'a>(a: &'a bool, b: bool, c: &'a S, d: &'a i32) -> &'a i32 {\n-   |     ++++     ++                    ++        ++          ++\n+LL | fn h<'a>(a: &'a bool, b: bool, c: &'a S<'a>, d: &'a i32) -> &'a i32 {\n+   |     ++++     ++                    ++  ++++      ++          ++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "000ab6492bb96d6f8d0d04363e424557f7244e0c", "filename": "src/test/ui/lifetimes/issue-26638.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Flifetimes%2Fissue-26638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Flifetimes%2Fissue-26638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-26638.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1,8 +1,11 @@\n fn parse_type(iter: Box<dyn Iterator<Item=&str>+'static>) -> &str { iter.next() }\n //~^ ERROR missing lifetime specifier [E0106]\n+//~| ERROR mismatched types\n \n fn parse_type_2(iter: fn(&u8)->&u8) -> &str { iter() }\n //~^ ERROR missing lifetime specifier [E0106]\n+//~| ERROR mismatched types\n+//~| ERROR this function takes 1 argument but 0 arguments were supplied\n \n fn parse_type_3() -> &str { unimplemented!() }\n //~^ ERROR missing lifetime specifier [E0106]"}, {"sha": "f3af5cf5a35764f96c9d054889b64916afa3ccc6", "filename": "src/test/ui/lifetimes/issue-26638.stderr", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Flifetimes%2Fissue-26638.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Flifetimes%2Fissue-26638.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-26638.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -7,23 +7,23 @@ LL | fn parse_type(iter: Box<dyn Iterator<Item=&str>+'static>) -> &str { iter.ne\n    = help: this function's return type contains a borrowed value, but the signature does not say which one of `iter`'s 2 lifetimes it is borrowed from\n help: consider introducing a named lifetime parameter\n    |\n-LL | fn parse_type<'a>(iter: Box<dyn Iterator<Item=&str>+'static>) -> &'a str { iter.next() }\n-   |              ++++                                                 ++\n+LL | fn parse_type<'a>(iter: Box<dyn Iterator<Item=&'a str>+'static>) -> &'a str { iter.next() }\n+   |              ++++                              ++                    ++\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-26638.rs:4:40\n+  --> $DIR/issue-26638.rs:5:40\n    |\n LL | fn parse_type_2(iter: fn(&u8)->&u8) -> &str { iter() }\n    |                                        ^ expected named lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n LL | fn parse_type_2(iter: fn(&u8)->&u8) -> &'static str { iter() }\n-   |                                        ~~~~~~~~\n+   |                                         +++++++\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-26638.rs:7:22\n+  --> $DIR/issue-26638.rs:10:22\n    |\n LL | fn parse_type_3() -> &str { unimplemented!() }\n    |                      ^ expected named lifetime parameter\n@@ -32,8 +32,42 @@ LL | fn parse_type_3() -> &str { unimplemented!() }\n help: consider using the `'static` lifetime\n    |\n LL | fn parse_type_3() -> &'static str { unimplemented!() }\n-   |                      ~~~~~~~~\n+   |                       +++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-26638.rs:1:69\n+   |\n+LL | fn parse_type(iter: Box<dyn Iterator<Item=&str>+'static>) -> &str { iter.next() }\n+   |                                                              ----   ^^^^^^^^^^^ expected `&str`, found enum `Option`\n+   |                                                              |\n+   |                                                              expected `&'static str` because of return type\n+   |\n+   = note: expected reference `&'static str`\n+                   found enum `Option<&str>`\n+\n+error[E0061]: this function takes 1 argument but 0 arguments were supplied\n+  --> $DIR/issue-26638.rs:5:47\n+   |\n+LL | fn parse_type_2(iter: fn(&u8)->&u8) -> &str { iter() }\n+   |                                               ^^^^-- an argument of type `&u8` is missing\n+   |\n+help: provide the argument\n+   |\n+LL | fn parse_type_2(iter: fn(&u8)->&u8) -> &str { iter(/* &u8 */) }\n+   |                                               ~~~~~~~~~~~~~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-26638.rs:5:47\n+   |\n+LL | fn parse_type_2(iter: fn(&u8)->&u8) -> &str { iter() }\n+   |                                        ----   ^^^^^^ expected `str`, found `u8`\n+   |                                        |\n+   |                                        expected `&'static str` because of return type\n+   |\n+   = note: expected reference `&'static str`\n+              found reference `&u8`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0106`.\n+Some errors have detailed explanations: E0061, E0106, E0308.\n+For more information about an error, try `rustc --explain E0061`."}, {"sha": "d07754879559a7c50713144adfafc6c87bc8e571", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-requires-explicit-lifetime.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -8,7 +8,7 @@ LL | fn f() -> &isize {\n help: consider using the `'static` lifetime\n    |\n LL | fn f() -> &'static isize {\n-   |           ~~~~~~~~\n+   |            +++++++\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:7:33\n@@ -31,44 +31,44 @@ LL | fn h(_x: &Foo) -> &isize {\n    = help: this function's return type contains a borrowed value, but the signature does not say which one of `_x`'s 2 lifetimes it is borrowed from\n help: consider introducing a named lifetime parameter\n    |\n-LL | fn h<'a>(_x: &'a Foo) -> &'a isize {\n-   |     ++++      ++          ++\n+LL | fn h<'a>(_x: &'a Foo<'a>) -> &'a isize {\n+   |     ++++      ++    ++++      ++\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:21:20\n    |\n LL | fn i(_x: isize) -> &isize {\n    |                    ^ expected named lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n LL | fn i(_x: isize) -> &'static isize {\n-   |                    ~~~~~~~~\n+   |                     +++++++\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:34:24\n    |\n LL | fn j(_x: StaticStr) -> &isize {\n    |                        ^ expected named lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n LL | fn j(_x: StaticStr) -> &'static isize {\n-   |                        ~~~~~~~~\n+   |                         +++++++\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:40:49\n    |\n LL | fn k<'a, T: WithLifetime<'a>>(_x: T::Output) -> &isize {\n    |                                                 ^ expected named lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'a` lifetime\n    |\n LL | fn k<'a, T: WithLifetime<'a>>(_x: T::Output) -> &'a isize {\n-   |                                                 ~~~\n+   |                                                  ++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "d6c918843c700fc58d52e6a593fa2114fec5e4d1", "filename": "src/test/ui/lifetimes/lifetime-errors/ex1b-return-no-names-if-else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex1b-return-no-names-if-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex1b-return-no-names-if-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex1b-return-no-names-if-else.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -2,4 +2,4 @@ fn foo(x: &i32, y: &i32) -> &i32 { //~ ERROR missing lifetime\n     if x > y { x } else { y }\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "b8c68a4607da8f4dc93ca191e768dddde3748849", "filename": "src/test/ui/lifetimes/missing-lifetime-in-alias.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Flifetimes%2Fmissing-lifetime-in-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Flifetimes%2Fmissing-lifetime-in-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fmissing-lifetime-in-alias.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -7,7 +7,7 @@ LL | type B<'a> = <A<'a> as Trait>::Foo;\n help: consider using the `'a` lifetime\n    |\n LL | type B<'a> = <A<'a> as Trait<'a>>::Foo;\n-   |                        ~~~~~~~~~\n+   |                             ++++\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/missing-lifetime-in-alias.rs:26:28\n@@ -20,6 +20,10 @@ note: these named lifetimes are available to use\n    |\n LL | type C<'a, 'b> = <A<'a> as Trait>::Bar;\n    |        ^^  ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | type C<'a, 'b> = <A<'a> as Trait<'lifetime>>::Bar;\n+   |                                 +++++++++++\n \n error[E0107]: missing generics for associated type `Trait::Bar`\n   --> $DIR/missing-lifetime-in-alias.rs:26:36"}, {"sha": "c7842667dc614ba09e725a9861bab73abbc9ec78", "filename": "src/test/ui/mismatched_types/issue-74918-missing-lifetime.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -9,6 +9,7 @@ impl<T, S: Iterator<Item = T>> Iterator for ChunkingIterator<T, S> {\n     type Item = IteratorChunk<T, S>; //~ ERROR missing lifetime\n \n     fn next(&mut self) -> Option<IteratorChunk<T, S>> {\n+        //~^ ERROR `impl` item signature doesn't match `trait` item signature\n         todo!()\n     }\n }"}, {"sha": "94a9c97576f674b186ef8d7c14f12441860191c5", "filename": "src/test/ui/mismatched_types/issue-74918-missing-lifetime.stderr", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1,14 +1,30 @@\n error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-74918-missing-lifetime.rs:9:31\n+  --> $DIR/issue-74918-missing-lifetime.rs:9:30\n    |\n LL |     type Item = IteratorChunk<T, S>;\n-   |                               ^ expected named lifetime parameter\n+   |                              ^ expected named lifetime parameter\n    |\n help: consider introducing a named lifetime parameter\n    |\n LL |     type Item<'a> = IteratorChunk<'a, T, S>;\n    |              ++++                 +++\n \n-error: aborting due to previous error\n+error: `impl` item signature doesn't match `trait` item signature\n+  --> $DIR/issue-74918-missing-lifetime.rs:11:5\n+   |\n+LL |     fn next(&mut self) -> Option<IteratorChunk<T, S>> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found `fn(&'1 mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'1, T, S>>`\n+   |\n+  ::: $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     fn next(&mut self) -> Option<Self::Item>;\n+   |     ----------------------------------------- expected `fn(&'1 mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'static, T, S>>`\n+   |\n+   = note: expected `fn(&'1 mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'static, T, S>>`\n+              found `fn(&'1 mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'1, T, S>>`\n+   = help: the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+   = help: verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0106`."}, {"sha": "c377ecea94d0c4ab2deda58974bae6077bb08506", "filename": "src/test/ui/resolve/issue-69401-trait-fn-no-body-ty-local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fresolve%2Fissue-69401-trait-fn-no-body-ty-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fresolve%2Fissue-69401-trait-fn-no-body-ty-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-69401-trait-fn-no-body-ty-local.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -2,5 +2,5 @@ fn main() {}\n \n trait Foo {\n     fn fn_with_type_named_same_as_local_in_param(b: b);\n-    //~^ ERROR cannot find type `b` in this scope\n+    //~^ ERROR cannot find type `b` in this scope [E0412]\n }"}, {"sha": "26fa6fdb57f95a90482c357a4d926c331bd7c7db", "filename": "src/test/ui/rfc1623-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Frfc1623-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Frfc1623-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1623-2.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -9,5 +9,6 @@ static NON_ELIDABLE_FN: &fn(&u8, &u8) -> &u8 =\n //~^ ERROR missing lifetime specifier [E0106]\n     &(non_elidable as fn(&u8, &u8) -> &u8);\n     //~^ ERROR missing lifetime specifier [E0106]\n+    //~| ERROR non-primitive cast\n \n fn main() {}"}, {"sha": "495d45e2234169843d93cbbc599169ec2ca3d37b", "filename": "src/test/ui/rfc1623-2.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Frfc1623-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Frfc1623-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1623-2.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -18,12 +18,18 @@ LL |     &(non_elidable as fn(&u8, &u8) -> &u8);\n    |                          ---  ---     ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from argument 1 or argument 2\n-   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n help: consider making the type lifetime-generic with a new `'a` lifetime\n    |\n LL |     &(non_elidable as for<'a> fn(&'a u8, &'a u8) -> &'a u8);\n    |                       +++++++     ++      ++         ++\n \n-error: aborting due to 2 previous errors\n+error[E0605]: non-primitive cast: `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8 {non_elidable}` as `for<'r, 's> fn(&'r u8, &'s u8) -> &u8`\n+  --> $DIR/rfc1623-2.rs:10:6\n+   |\n+LL |     &(non_elidable as fn(&u8, &u8) -> &u8);\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n+\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0106`.\n+Some errors have detailed explanations: E0106, E0605.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "6d7c3d73097a9e2f0daa5c6e27eaeff4ba23afb4", "filename": "src/test/ui/suggestions/fn-missing-lifetime-in-item.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Ffn-missing-lifetime-in-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Ffn-missing-lifetime-in-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-missing-lifetime-in-item.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -21,7 +21,6 @@ LL | struct S2<F: Fn(&i32, &i32) -> &i32>(F);\n    |                 ----  ----     ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from argument 1 or argument 2\n-   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n help: consider making the bound lifetime-generic with a new `'a` lifetime\n    |\n LL | struct S2<F: for<'a> Fn(&'a i32, &'a i32) -> &'a i32>(F);"}, {"sha": "e82a6f769e090083d7c8ce9165d59309b61eae0f", "filename": "src/test/ui/suggestions/impl-trait-missing-lifetime-gated.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-missing-lifetime-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-missing-lifetime-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-missing-lifetime-gated.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1,43 +1,43 @@\n-error[E0658]: anonymous lifetimes in `impl Trait` are unstable\n-  --> $DIR/impl-trait-missing-lifetime-gated.rs:5:31\n-   |\n-LL | fn f(_: impl Iterator<Item = &'_ ()>) {}\n-   |                               ^^\n-   |\n-   = help: add `#![feature(anonymous_lifetime_in_impl_trait)]` to the crate attributes to enable\n-\n error[E0106]: missing lifetime specifier\n   --> $DIR/impl-trait-missing-lifetime-gated.rs:8:50\n    |\n LL | fn g(x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n    |                                                  ^^ expected named lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n LL | fn g(x: impl Iterator<Item = &'_ ()>) -> Option<&'static ()> { x.next() }\n    |                                                  ~~~~~~~\n \n-error[E0658]: anonymous lifetimes in `impl Trait` are unstable\n-  --> $DIR/impl-trait-missing-lifetime-gated.rs:8:31\n-   |\n-LL | fn g(x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n-   |                               ^^\n-   |\n-   = help: add `#![feature(anonymous_lifetime_in_impl_trait)]` to the crate attributes to enable\n-\n error[E0106]: missing lifetime specifier\n   --> $DIR/impl-trait-missing-lifetime-gated.rs:18:56\n    |\n LL | async fn i(x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n    |                                                        ^^ expected named lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n LL | async fn i(x: impl Iterator<Item = &'_ ()>) -> Option<&'static ()> { x.next() }\n    |                                                        ~~~~~~~\n \n+error[E0658]: anonymous lifetimes in `impl Trait` are unstable\n+  --> $DIR/impl-trait-missing-lifetime-gated.rs:5:31\n+   |\n+LL | fn f(_: impl Iterator<Item = &'_ ()>) {}\n+   |                               ^^\n+   |\n+   = help: add `#![feature(anonymous_lifetime_in_impl_trait)]` to the crate attributes to enable\n+\n+error[E0658]: anonymous lifetimes in `impl Trait` are unstable\n+  --> $DIR/impl-trait-missing-lifetime-gated.rs:8:31\n+   |\n+LL | fn g(x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n+   |                               ^^\n+   |\n+   = help: add `#![feature(anonymous_lifetime_in_impl_trait)]` to the crate attributes to enable\n+\n error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0106, E0658."}, {"sha": "6f7c912d707cf187a0d71b183b8ca144a6a944c2", "filename": "src/test/ui/suggestions/impl-trait-missing-lifetime.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-missing-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-missing-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-missing-lifetime.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -6,14 +6,15 @@\n fn f(_: impl Iterator<Item = &'_ ()>) {}\n \n // But that lifetime does not participate in resolution.\n-fn g(x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n+fn g(mut x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n //~^ ERROR missing lifetime specifier\n \n // This is understood as `fn foo<'_1>(_: impl Iterator<Item = &'_1 ()>) {}`.\n async fn h(_: impl Iterator<Item = &'_ ()>) {}\n \n // But that lifetime does not participate in resolution.\n-async fn i(x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n+async fn i(mut x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n //~^ ERROR missing lifetime specifier\n+//~| ERROR lifetime may not live long enough\n \n fn main() {}"}, {"sha": "b476d61017f1489161f69cf1eb5bb07a74fe1604", "filename": "src/test/ui/suggestions/impl-trait-missing-lifetime.stderr", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-missing-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-missing-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-missing-lifetime.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1,27 +1,35 @@\n error[E0106]: missing lifetime specifier\n-  --> $DIR/impl-trait-missing-lifetime.rs:9:50\n+  --> $DIR/impl-trait-missing-lifetime.rs:9:54\n    |\n-LL | fn g(x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n-   |                                                  ^^ expected named lifetime parameter\n+LL | fn g(mut x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n+   |                                                      ^^ expected named lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n-LL | fn g(x: impl Iterator<Item = &'_ ()>) -> Option<&'static ()> { x.next() }\n-   |                                                  ~~~~~~~\n+LL | fn g(mut x: impl Iterator<Item = &'_ ()>) -> Option<&'static ()> { x.next() }\n+   |                                                      ~~~~~~~\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/impl-trait-missing-lifetime.rs:16:56\n+  --> $DIR/impl-trait-missing-lifetime.rs:16:60\n    |\n-LL | async fn i(x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n-   |                                                        ^^ expected named lifetime parameter\n+LL | async fn i(mut x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n+   |                                                            ^^ expected named lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n-LL | async fn i(x: impl Iterator<Item = &'_ ()>) -> Option<&'static ()> { x.next() }\n-   |                                                        ~~~~~~~\n+LL | async fn i(mut x: impl Iterator<Item = &'_ ()>) -> Option<&'static ()> { x.next() }\n+   |                                                            ~~~~~~~\n \n-error: aborting due to 2 previous errors\n+error: lifetime may not live long enough\n+  --> $DIR/impl-trait-missing-lifetime.rs:16:69\n+   |\n+LL | async fn i(mut x: impl Iterator<Item = &'_ ()>) -> Option<&'_ ()> { x.next() }\n+   |                                                    --------------   ^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n+   |                                                    |\n+   |                                                    return type `impl Future<Output = Option<&'static ()>>` contains a lifetime `'1`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0106`."}, {"sha": "366787df1b4dd8c89ba94991e85b71e2cf1e7c22", "filename": "src/test/ui/suggestions/issue-86667.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fissue-86667.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fissue-86667.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-86667.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -6,6 +6,7 @@\n async fn a(s1: &str, s2: &str) -> &str {\n //~^ ERROR: missing lifetime specifier [E0106]\n     s1\n+//~^ ERROR: lifetime may not live long enough\n }\n \n fn b(s1: &str, s2: &str) -> &str {"}, {"sha": "8d611641626e136dfa6d2b88e54b3d486ba14311", "filename": "src/test/ui/suggestions/issue-86667.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fissue-86667.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fissue-86667.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-86667.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -11,7 +11,7 @@ LL | async fn a<'a>(s1: &'a str, s2: &'a str) -> &'a str {\n    |           ++++      ++           ++          ++\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-86667.rs:11:29\n+  --> $DIR/issue-86667.rs:12:29\n    |\n LL | fn b(s1: &str, s2: &str) -> &str {\n    |          ----      ----     ^ expected named lifetime parameter\n@@ -22,6 +22,15 @@ help: consider introducing a named lifetime parameter\n LL | fn b<'a>(s1: &'a str, s2: &'a str) -> &'a str {\n    |     ++++      ++           ++          ++\n \n-error: aborting due to 2 previous errors\n+error: lifetime may not live long enough\n+  --> $DIR/issue-86667.rs:8:5\n+   |\n+LL | async fn a(s1: &str, s2: &str) -> &str {\n+   |                - let's call the lifetime of this reference `'1`\n+LL |\n+LL |     s1\n+   |     ^^ returning this value requires that `'1` must outlive `'static`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0106`."}, {"sha": "233f1bc5a86eed3ffb6a3772ba7e57a88075bfcd", "filename": "src/test/ui/suggestions/missing-lifetime-in-assoc-const-type.stderr", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -4,10 +4,6 @@ error[E0106]: missing lifetime specifier\n LL |     const A: &str = \"\";\n    |              ^ expected named lifetime parameter\n    |\n-help: consider using the `'static` lifetime\n-   |\n-LL |     const A: &'static str = \"\";\n-   |               +++++++\n help: consider introducing a named lifetime parameter\n    |\n LL ~ trait ZstAssert<'a>: Sized {\n@@ -20,10 +16,6 @@ error[E0106]: missing lifetime specifier\n LL |     const B: S = S { s: &() };\n    |              ^ expected named lifetime parameter\n    |\n-help: consider using the `'static` lifetime\n-   |\n-LL |     const B: S<'static> = S { s: &() };\n-   |               +++++++++\n help: consider introducing a named lifetime parameter\n    |\n LL ~ trait ZstAssert<'a>: Sized {\n@@ -37,10 +29,6 @@ error[E0106]: missing lifetime specifier\n LL |     const C: &'_ str = \"\";\n    |               ^^ expected named lifetime parameter\n    |\n-help: consider using the `'static` lifetime\n-   |\n-LL |     const C: &'static str = \"\";\n-   |               ~~~~~~~\n help: consider introducing a named lifetime parameter\n    |\n LL ~ trait ZstAssert<'a>: Sized {\n@@ -55,10 +43,6 @@ error[E0106]: missing lifetime specifiers\n LL |     const D: T = T { a: &(), b: &() };\n    |              ^ expected 2 lifetime parameters\n    |\n-help: consider using the `'static` lifetime\n-   |\n-LL |     const D: T<'static, 'static> = T { a: &(), b: &() };\n-   |               ++++++++++++++++++\n help: consider introducing a named lifetime parameter\n    |\n LL ~ trait ZstAssert<'a>: Sized {"}, {"sha": "24f5f782f35211dc7904478e86773c94af614ab3", "filename": "src/test/ui/suggestions/missing-lifetime-specifier.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -21,22 +21,18 @@ thread_local! {\n }\n thread_local! {\n     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n-      //~^ ERROR missing lifetime specifier\n-      //~| ERROR missing lifetime specifier\n-      //~| ERROR missing lifetime specifier\n-      //~| ERROR missing lifetime specifier\n+      //~^ ERROR missing lifetime specifiers\n+      //~| ERROR missing lifetime specifiers\n }\n thread_local! {\n     static c: RefCell<HashMap<i32, Vec<Vec<Qux<i32>>>>> = RefCell::new(HashMap::new());\n-    //~^ ERROR missing lifetime\n-    //~| ERROR missing lifetime\n+    //~^ ERROR missing lifetime specifiers\n+    //~| ERROR missing lifetime specifiers\n }\n thread_local! {\n     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n-    //~^ ERROR missing lifetime\n-    //~| ERROR missing lifetime\n-    //~| ERROR missing lifetime\n-    //~| ERROR missing lifetime\n+    //~^ ERROR missing lifetime specifiers\n+    //~| ERROR missing lifetime specifiers\n }\n \n thread_local! {"}, {"sha": "10fb28c1891973898a36c303f84283c6bb4ef4a9", "filename": "src/test/ui/suggestions/missing-lifetime-specifier.stderr", "status": "modified", "additions": 54, "deletions": 104, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -8,7 +8,7 @@ LL |     static a: RefCell<HashMap<i32, Vec<Vec<Foo>>>> = RefCell::new(HashMap::\n help: consider using the `'static` lifetime\n    |\n LL |     static a: RefCell<HashMap<i32, Vec<Vec<Foo<'static, 'static>>>>> = RefCell::new(HashMap::new());\n-   |                                            ~~~~~~~~~~~~~~~~~~~~~\n+   |                                               ++++++++++++++++++\n \n error[E0106]: missing lifetime specifiers\n   --> $DIR/missing-lifetime-specifier.rs:18:44\n@@ -23,38 +23,28 @@ LL | | }\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 3 lifetimes it is borrowed from\n \n-error[E0106]: missing lifetime specifier\n+error[E0106]: missing lifetime specifiers\n   --> $DIR/missing-lifetime-specifier.rs:23:44\n    |\n LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n-   |                                            ^ expected named lifetime parameter\n+   |                                            ^^^^ expected 2 lifetime parameters\n+   |                                            |\n+   |                                            expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n-LL |     static b: RefCell<HashMap<i32, Vec<Vec<&'static Bar>>>> = RefCell::new(HashMap::new());\n-   |                                            ~~~~~~~~\n+LL |     static b: RefCell<HashMap<i32, Vec<Vec<&'static Bar<'static, 'static>>>>> = RefCell::new(HashMap::new());\n+   |                                             +++++++    ++++++++++++++++++\n \n error[E0106]: missing lifetime specifiers\n-  --> $DIR/missing-lifetime-specifier.rs:23:45\n-   |\n-LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n-   |                                             ^^^ expected 2 lifetime parameters\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n-   |\n-LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar<'static, 'static>>>>> = RefCell::new(HashMap::new());\n-   |                                             ~~~~~~~~~~~~~~~~~~~~~\n-\n-error[E0106]: missing lifetime specifier\n   --> $DIR/missing-lifetime-specifier.rs:23:44\n    |\n LL | / thread_local! {\n LL | |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n-   | |                                            ^ expected named lifetime parameter\n-LL | |\n-LL | |\n+   | |                                            ^^^^ expected 2 lifetime parameters\n+   | |                                            |\n+   | |                                            expected named lifetime parameter\n LL | |\n LL | |\n LL | | }\n@@ -63,25 +53,10 @@ LL | | }\n    = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 4 lifetimes it is borrowed from\n \n error[E0106]: missing lifetime specifiers\n-  --> $DIR/missing-lifetime-specifier.rs:23:45\n-   |\n-LL | / thread_local! {\n-LL | |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n-   | |                                             ^^^ expected 2 lifetime parameters\n-LL | |\n-LL | |\n-LL | |\n-LL | |\n-LL | | }\n-   | |_-\n-   |\n-   = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 4 lifetimes it is borrowed from\n-\n-error[E0106]: missing lifetime specifiers\n-  --> $DIR/missing-lifetime-specifier.rs:30:48\n+  --> $DIR/missing-lifetime-specifier.rs:28:47\n    |\n LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                ^ expected 2 lifetime parameters\n+   |                                               ^ expected 2 lifetime parameters\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n@@ -90,74 +65,76 @@ LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> =\n    |                                                +++++++++++++++++\n \n error[E0106]: missing lifetime specifiers\n-  --> $DIR/missing-lifetime-specifier.rs:30:48\n+  --> $DIR/missing-lifetime-specifier.rs:28:47\n    |\n LL | / thread_local! {\n LL | |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<i32>>>>> = RefCell::new(HashMap::new());\n-   | |                                                ^ expected 2 lifetime parameters\n+   | |                                               ^ expected 2 lifetime parameters\n LL | |\n LL | |\n LL | | }\n    | |_-\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 3 lifetimes it is borrowed from\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lifetime-specifier.rs:35:44\n-   |\n-LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n-   |                                            ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n-   |\n-LL |     static d: RefCell<HashMap<i32, Vec<Vec<&'static Tar<i32>>>>> = RefCell::new(HashMap::new());\n-   |                                            ~~~~~~~~\n-\n error[E0106]: missing lifetime specifiers\n-  --> $DIR/missing-lifetime-specifier.rs:35:49\n+  --> $DIR/missing-lifetime-specifier.rs:33:44\n    |\n LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                 ^ expected 2 lifetime parameters\n+   |                                            ^   ^ expected 2 lifetime parameters\n+   |                                            |\n+   |                                            expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n-LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                 +++++++++++++++++\n+LL |     static d: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                             +++++++     +++++++++++++++++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lifetime-specifier.rs:35:44\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/missing-lifetime-specifier.rs:33:44\n    |\n LL | / thread_local! {\n LL | |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n-   | |                                            ^ expected named lifetime parameter\n-LL | |\n-LL | |\n+   | |                                            ^   ^ expected 2 lifetime parameters\n+   | |                                            |\n+   | |                                            expected named lifetime parameter\n LL | |\n LL | |\n LL | | }\n    | |_-\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 4 lifetimes it is borrowed from\n \n-error[E0106]: missing lifetime specifiers\n-  --> $DIR/missing-lifetime-specifier.rs:35:49\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-specifier.rs:47:44\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                             +++++++\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-specifier.rs:47:44\n    |\n LL | / thread_local! {\n-LL | |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n-   | |                                                 ^ expected 2 lifetime parameters\n-LL | |\n+LL | |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   | |                                            ^ expected named lifetime parameter\n LL | |\n LL | |\n+...  |\n LL | |\n LL | | }\n    | |_-\n    |\n-   = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 4 lifetimes it is borrowed from\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 3 lifetimes it is borrowed from\n \n error[E0107]: this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:43:44\n+  --> $DIR/missing-lifetime-specifier.rs:39:44\n    |\n LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^^^ ------- supplied 1 lifetime argument\n@@ -175,7 +152,7 @@ LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> =\n    |                                                       +++++++++\n \n error[E0107]: this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:43:44\n+  --> $DIR/missing-lifetime-specifier.rs:39:44\n    |\n LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^^^ ------- supplied 1 lifetime argument\n@@ -193,7 +170,7 @@ LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'k, i32>>>>> = RefC\n    |                                                       ++++\n \n error[E0107]: this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:43:44\n+  --> $DIR/missing-lifetime-specifier.rs:39:44\n    |\n LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^^^ ------- supplied 1 lifetime argument\n@@ -211,7 +188,7 @@ LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'k, i32>>>>> = RefC\n    |                                                       ++++\n \n error[E0107]: this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:43:44\n+  --> $DIR/missing-lifetime-specifier.rs:39:44\n    |\n LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^^^ ------- supplied 1 lifetime argument\n@@ -229,7 +206,7 @@ LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'k, i32>>>>> = RefC\n    |                                                       ++++\n \n error[E0107]: this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:43:44\n+  --> $DIR/missing-lifetime-specifier.rs:39:44\n    |\n LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^^^ ------- supplied 1 lifetime argument\n@@ -247,7 +224,7 @@ LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> =\n    |                                                       +++++++++\n \n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:51:45\n+  --> $DIR/missing-lifetime-specifier.rs:47:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^ ------- supplied 1 lifetime argument\n@@ -264,20 +241,8 @@ help: add missing lifetime argument\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                                        +++++++++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lifetime-specifier.rs:51:44\n-   |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                            ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n-   |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                            ~~~~~~~~\n-\n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:51:45\n+  --> $DIR/missing-lifetime-specifier.rs:47:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^ ------- supplied 1 lifetime argument\n@@ -294,23 +259,8 @@ help: add missing lifetime argument\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'k, i32>>>>> = RefCell::new(HashMap::new());\n    |                                                        ++++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lifetime-specifier.rs:51:44\n-   |\n-LL | / thread_local! {\n-LL | |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n-   | |                                            ^ expected named lifetime parameter\n-LL | |\n-LL | |\n-...  |\n-LL | |\n-LL | | }\n-   | |_-\n-   |\n-   = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 3 lifetimes it is borrowed from\n-\n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:51:45\n+  --> $DIR/missing-lifetime-specifier.rs:47:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^ ------- supplied 1 lifetime argument\n@@ -328,7 +278,7 @@ LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'k, i32>>>>> = Ref\n    |                                                        ++++\n \n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:51:45\n+  --> $DIR/missing-lifetime-specifier.rs:47:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^ ------- supplied 1 lifetime argument\n@@ -346,7 +296,7 @@ LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'k, i32>>>>> = Ref\n    |                                                        ++++\n \n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:51:45\n+  --> $DIR/missing-lifetime-specifier.rs:47:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^ ------- supplied 1 lifetime argument\n@@ -363,7 +313,7 @@ help: add missing lifetime argument\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                                        +++++++++\n \n-error: aborting due to 24 previous errors\n+error: aborting due to 20 previous errors\n \n Some errors have detailed explanations: E0106, E0107.\n For more information about an error, try `rustc --explain E0106`."}, {"sha": "04ea3d831c93a9cd6b595d9fff8335208ed6bc67", "filename": "src/test/ui/suggestions/missing-lt-for-hrtb.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1,10 +1,8 @@\n struct X<'a>(&'a ());\n struct S<'a>(&'a dyn Fn(&X) -> &X);\n-//~^ ERROR missing lifetime specifier\n-//~| ERROR missing lifetime specifier\n+//~^ ERROR missing lifetime specifiers\n struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n-//~^ ERROR missing lifetime specifier\n-//~| ERROR missing lifetime specifier\n+//~^ ERROR missing lifetime specifiers\n \n fn main() {\n     let x = S(&|x| {"}, {"sha": "fa515644431ac0a3e5564ed662f95cbcfedeb8d5", "filename": "src/test/ui/suggestions/missing-lt-for-hrtb.stderr", "status": "modified", "additions": 15, "deletions": 46, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1,67 +1,36 @@\n-error[E0106]: missing lifetime specifier\n+error[E0106]: missing lifetime specifiers\n   --> $DIR/missing-lt-for-hrtb.rs:2:32\n    |\n LL | struct S<'a>(&'a dyn Fn(&X) -> &X);\n-   |                         --     ^ expected named lifetime parameter\n+   |                         --     ^^ expected named lifetime parameter\n+   |                                |\n+   |                                expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n-   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n-help: consider making the bound lifetime-generic with a new `'b` lifetime\n-   |\n-LL | struct S<'a>(&'a dyn for<'b> Fn(&'b X) -> &'b X);\n-   |                      +++++++    ~~~~~     ~~~\n-help: consider using the `'a` lifetime\n-   |\n-LL | struct S<'a>(&'a dyn Fn(&X) -> &'a X);\n-   |                                ~~~\n-\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lt-for-hrtb.rs:2:33\n-   |\n-LL | struct S<'a>(&'a dyn Fn(&X) -> &X);\n-   |                         --      ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n-   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n-help: consider making the bound lifetime-generic with a new `'b` lifetime\n-   |\n-LL | struct S<'a>(&'a dyn for<'b> Fn(&'b X) -> &X<'b>);\n-   |                      +++++++    ~~~~~      ~~~~~\n help: consider using the `'a` lifetime\n    |\n-LL | struct S<'a>(&'a dyn Fn(&X) -> &X<'a>);\n-   |                                 ~~~~~\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &'a X<'a>);\n+   |                                 ++  ++++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lt-for-hrtb.rs:5:40\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/missing-lt-for-hrtb.rs:4:40\n    |\n LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n-   |                                 --     ^ expected named lifetime parameter\n+   |                                 --     ^^ expected named lifetime parameter\n+   |                                        |\n+   |                                        expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n note: these named lifetimes are available to use\n-  --> $DIR/missing-lt-for-hrtb.rs:5:10\n+  --> $DIR/missing-lt-for-hrtb.rs:4:10\n    |\n LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n    |          ^^              ^^\n help: consider using one of the available lifetimes here\n    |\n-LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &'lifetime X);\n-   |                                         +++++++++\n-\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lt-for-hrtb.rs:5:41\n-   |\n-LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n-   |                                 --      ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n-note: these named lifetimes are available to use\n-  --> $DIR/missing-lt-for-hrtb.rs:5:10\n-   |\n-LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n-   |          ^^              ^^\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &'lifetime X<'lifetime>);\n+   |                                         +++++++++  +++++++++++\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0106`."}, {"sha": "012d5492a0404300fc618e4736f0c392dc32aa0f", "filename": "src/test/ui/suggestions/return-elided-lifetime.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -6,32 +6,27 @@\n fn f1() -> &i32 { loop {} }\n //~^ ERROR missing lifetime specifier [E0106]\n fn f1_() -> (&i32, &i32) { loop {} }\n-//~^ ERROR missing lifetime specifier [E0106]\n-//~^^ ERROR missing lifetime specifier [E0106]\n+//~^ ERROR missing lifetime specifiers [E0106]\n \n fn f2(a: i32, b: i32) -> &i32 { loop {} }\n //~^ ERROR missing lifetime specifier [E0106]\n fn f2_(a: i32, b: i32) -> (&i32, &i32) { loop {} }\n-//~^ ERROR missing lifetime specifier [E0106]\n-//~^^ ERROR missing lifetime specifier [E0106]\n+//~^ ERROR missing lifetime specifiers [E0106]\n \n struct S<'a, 'b> { a: &'a i32, b: &'b i32 }\n fn f3(s: &S) -> &i32 { loop {} }\n //~^ ERROR missing lifetime specifier [E0106]\n fn f3_(s: &S, t: &S) -> (&i32, &i32) { loop {} }\n-//~^ ERROR missing lifetime specifier [E0106]\n-//~^^ ERROR missing lifetime specifier [E0106]\n+//~^ ERROR missing lifetime specifiers [E0106]\n \n fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &i32 { loop {} }\n //~^ ERROR missing lifetime specifier [E0106]\n fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n-//~^ ERROR missing lifetime specifier [E0106]\n-//~^^ ERROR missing lifetime specifier [E0106]\n+//~^ ERROR missing lifetime specifiers [E0106]\n \n fn f5<'a>(a: &'a i32, b: &i32) -> &i32 { loop {} }\n //~^ ERROR missing lifetime specifier [E0106]\n fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &i32) { loop {} }\n-//~^ ERROR missing lifetime specifier [E0106]\n-//~^^ ERROR missing lifetime specifier [E0106]\n+//~^ ERROR missing lifetime specifiers [E0106]\n \n fn main() {}"}, {"sha": "273d95bc747d37b24c04b55f48b8ebb6f25bd1ed", "filename": "src/test/ui/suggestions/return-elided-lifetime.stderr", "status": "modified", "additions": 50, "deletions": 105, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -8,113 +8,83 @@ LL | fn f1() -> &i32 { loop {} }\n help: consider using the `'static` lifetime\n    |\n LL | fn f1() -> &'static i32 { loop {} }\n-   |            ~~~~~~~~\n+   |             +++++++\n \n-error[E0106]: missing lifetime specifier\n+error[E0106]: missing lifetime specifiers\n   --> $DIR/return-elided-lifetime.rs:8:14\n    |\n LL | fn f1_() -> (&i32, &i32) { loop {} }\n-   |              ^ expected named lifetime parameter\n+   |              ^     ^ expected named lifetime parameter\n+   |              |\n+   |              expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n-LL | fn f1_() -> (&'static i32, &i32) { loop {} }\n-   |              ~~~~~~~~\n+LL | fn f1_() -> (&'static i32, &'static i32) { loop {} }\n+   |               +++++++       +++++++\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:8:20\n-   |\n-LL | fn f1_() -> (&i32, &i32) { loop {} }\n-   |                    ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n-   |\n-LL | fn f1_() -> (&i32, &'static i32) { loop {} }\n-   |                    ~~~~~~~~\n-\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:12:26\n+  --> $DIR/return-elided-lifetime.rs:11:26\n    |\n LL | fn f2(a: i32, b: i32) -> &i32 { loop {} }\n    |                          ^ expected named lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n LL | fn f2(a: i32, b: i32) -> &'static i32 { loop {} }\n-   |                          ~~~~~~~~\n+   |                           +++++++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:14:28\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/return-elided-lifetime.rs:13:28\n    |\n LL | fn f2_(a: i32, b: i32) -> (&i32, &i32) { loop {} }\n-   |                            ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n-help: consider using the `'static` lifetime\n+   |                            ^     ^ expected named lifetime parameter\n+   |                            |\n+   |                            expected named lifetime parameter\n    |\n-LL | fn f2_(a: i32, b: i32) -> (&'static i32, &i32) { loop {} }\n-   |                            ~~~~~~~~\n-\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:14:34\n-   |\n-LL | fn f2_(a: i32, b: i32) -> (&i32, &i32) { loop {} }\n-   |                                  ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n help: consider using the `'static` lifetime\n    |\n-LL | fn f2_(a: i32, b: i32) -> (&i32, &'static i32) { loop {} }\n-   |                                  ~~~~~~~~\n+LL | fn f2_(a: i32, b: i32) -> (&'static i32, &'static i32) { loop {} }\n+   |                             +++++++       +++++++\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:19:17\n+  --> $DIR/return-elided-lifetime.rs:17:17\n    |\n LL | fn f3(s: &S) -> &i32 { loop {} }\n    |          --     ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say which one of `s`'s 3 lifetimes it is borrowed from\n help: consider introducing a named lifetime parameter\n    |\n-LL | fn f3<'a>(s: &'a S) -> &'a i32 { loop {} }\n-   |      ++++     ++        ++\n+LL | fn f3<'a>(s: &'a S<'a, 'a>) -> &'a i32 { loop {} }\n+   |      ++++     ++  ++++++++      ++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:21:26\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/return-elided-lifetime.rs:19:26\n    |\n LL | fn f3_(s: &S, t: &S) -> (&i32, &i32) { loop {} }\n-   |           --     --      ^ expected named lifetime parameter\n+   |           --     --      ^     ^ expected named lifetime parameter\n+   |                          |\n+   |                          expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from one of `s`'s 3 lifetimes or one of `t`'s 3 lifetimes\n help: consider introducing a named lifetime parameter\n    |\n-LL | fn f3_<'a>(s: &'a S, t: &'a S) -> (&'a i32, &i32) { loop {} }\n-   |       ++++     ++        ++         ++\n+LL | fn f3_<'a>(s: &'a S<'a, 'a>, t: &'a S<'a, 'a>) -> (&'a i32, &'a i32) { loop {} }\n+   |       ++++     ++  ++++++++      ++  ++++++++       ++       ++\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:21:32\n-   |\n-LL | fn f3_(s: &S, t: &S) -> (&i32, &i32) { loop {} }\n-   |           --     --            ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from one of `s`'s 3 lifetimes or one of `t`'s 3 lifetimes\n-help: consider introducing a named lifetime parameter\n-   |\n-LL | fn f3_<'a>(s: &'a S, t: &'a S) -> (&i32, &'a i32) { loop {} }\n-   |       ++++     ++        ++               ++\n-\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:25:42\n+  --> $DIR/return-elided-lifetime.rs:22:42\n    |\n LL | fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &i32 { loop {} }\n    |                  -------     -------     ^ expected named lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n note: these named lifetimes are available to use\n-  --> $DIR/return-elided-lifetime.rs:25:7\n+  --> $DIR/return-elided-lifetime.rs:22:7\n    |\n LL | fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &i32 { loop {} }\n    |       ^^  ^^\n@@ -123,42 +93,27 @@ help: consider using one of the available lifetimes here\n LL | fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &'lifetime i32 { loop {} }\n    |                                           +++++++++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:27:44\n-   |\n-LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n-   |                   -------     -------      ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n-note: these named lifetimes are available to use\n-  --> $DIR/return-elided-lifetime.rs:27:8\n-   |\n-LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n-   |        ^^  ^^\n-help: consider using one of the available lifetimes here\n-   |\n-LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&'lifetime i32, &i32) { loop {} }\n-   |                                             +++++++++\n-\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:27:50\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/return-elided-lifetime.rs:24:44\n    |\n LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n-   |                   -------     -------            ^ expected named lifetime parameter\n+   |                   -------     -------      ^     ^ expected named lifetime parameter\n+   |                                            |\n+   |                                            expected named lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n note: these named lifetimes are available to use\n-  --> $DIR/return-elided-lifetime.rs:27:8\n+  --> $DIR/return-elided-lifetime.rs:24:8\n    |\n LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n    |        ^^  ^^\n help: consider using one of the available lifetimes here\n    |\n-LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &'lifetime i32) { loop {} }\n-   |                                                   +++++++++\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&'lifetime i32, &'lifetime i32) { loop {} }\n+   |                                             +++++++++       +++++++++\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:31:35\n+  --> $DIR/return-elided-lifetime.rs:27:35\n    |\n LL | fn f5<'a>(a: &'a i32, b: &i32) -> &i32 { loop {} }\n    |              -------     ----     ^ expected named lifetime parameter\n@@ -167,32 +122,22 @@ LL | fn f5<'a>(a: &'a i32, b: &i32) -> &i32 { loop {} }\n help: consider using the `'a` lifetime\n    |\n LL | fn f5<'a>(a: &'a i32, b: &i32) -> &'a i32 { loop {} }\n-   |                                   ~~~\n-\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:33:37\n-   |\n-LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &i32) { loop {} }\n-   |               -------     ----      ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n-help: consider using the `'a` lifetime\n-   |\n-LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&'a i32, &i32) { loop {} }\n-   |                                     ~~~\n+   |                                    ++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/return-elided-lifetime.rs:33:43\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/return-elided-lifetime.rs:29:37\n    |\n LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &i32) { loop {} }\n-   |               -------     ----            ^ expected named lifetime parameter\n+   |               -------     ----      ^     ^ expected named lifetime parameter\n+   |                                     |\n+   |                                     expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n help: consider using the `'a` lifetime\n    |\n-LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &'a i32) { loop {} }\n-   |                                           ~~~\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&'a i32, &'a i32) { loop {} }\n+   |                                      ++       ++\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 10 previous errors\n \n For more information about this error, try `rustc --explain E0106`."}, {"sha": "5028e8d628f270a69ed48bafae4046cb96dc82db", "filename": "src/test/ui/suggestions/return-without-lifetime.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Freturn-without-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Fsuggestions%2Freturn-without-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-without-lifetime.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -7,7 +7,7 @@ LL | struct Foo<'a>(&usize);\n help: consider using the `'a` lifetime\n    |\n LL | struct Foo<'a>(&'a usize);\n-   |                ~~~\n+   |                 ++\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/return-without-lifetime.rs:5:34\n@@ -19,7 +19,7 @@ LL | fn func1<'a>(_arg: &'a Thing) -> &() { unimplemented!() }\n help: consider using the `'a` lifetime\n    |\n LL | fn func1<'a>(_arg: &'a Thing) -> &'a () { unimplemented!() }\n-   |                                  ~~~\n+   |                                   ++\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/return-without-lifetime.rs:7:35\n@@ -31,7 +31,7 @@ LL | fn func2<'a>(_arg: &Thing<'a>) -> &() { unimplemented!() }\n help: consider using the `'a` lifetime\n    |\n LL | fn func2<'a>(_arg: &Thing<'a>) -> &'a () { unimplemented!() }\n-   |                                   ~~~\n+   |                                    ++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "2b8fec86c8a18f5bc954a5bbd44b83a7373ee586", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-lifetime-elision.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-lifetime-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-lifetime-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-lifetime-elision.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -5,6 +5,11 @@ LL |     let _: dyn Foo(&isize, &usize) -> &usize;\n    |                    ------  ------     ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from argument 1 or argument 2\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL |     let _: dyn for<'a> Foo(&'a isize, &'a usize) -> &'a usize;\n+   |                +++++++      ++         ++            ++\n help: consider introducing a named lifetime parameter\n    |\n LL ~ fn main<'a>() {"}, {"sha": "e1deab736cf56eb185e781a8294d4e65b1524dc7", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore-in-struct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore-in-struct.rs?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -7,7 +7,6 @@ use std::fmt::Debug;\n \n struct Foo {\n     x: Box<dyn Debug + '_>, //~ ERROR missing lifetime specifier\n-    //~^ ERROR E0228\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "fd0860028039307c1feade7a2b262027bb1048d9", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore-in-struct.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore-in-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore-in-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore-in-struct.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -10,13 +10,6 @@ LL ~ struct Foo<'a> {\n LL ~     x: Box<dyn Debug + 'a>,\n    |\n \n-error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n-  --> $DIR/dyn-trait-underscore-in-struct.rs:9:12\n-   |\n-LL |     x: Box<dyn Debug + '_>,\n-   |            ^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0106, E0228.\n-For more information about an error, try `rustc --explain E0106`.\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "50401791effb8321802617fe5dda3be45ef5457a", "filename": "src/test/ui/underscore-lifetime/underscore-lifetime-binders.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c5048d2eceb315341582093d2102786c8be38c9/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr?ref=3c5048d2eceb315341582093d2102786c8be38c9", "patch": "@@ -1,3 +1,14 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/underscore-lifetime-binders.rs:2:17\n+   |\n+LL | struct Baz<'a>(&'_ &'a u8);\n+   |                 ^^ expected named lifetime parameter\n+   |\n+help: consider using the `'a` lifetime\n+   |\n+LL | struct Baz<'a>(&'a &'a u8);\n+   |                 ~~\n+\n error[E0637]: `'_` cannot be used here\n   --> $DIR/underscore-lifetime-binders.rs:4:8\n    |\n@@ -10,17 +21,6 @@ error[E0637]: `'_` cannot be used here\n LL | fn meh() -> Box<dyn for<'_> Meh<'_>>\n    |                         ^^ `'_` is a reserved lifetime name\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/underscore-lifetime-binders.rs:2:17\n-   |\n-LL | struct Baz<'a>(&'_ &'a u8);\n-   |                 ^^ expected named lifetime parameter\n-   |\n-help: consider using the `'a` lifetime\n-   |\n-LL | struct Baz<'a>(&'a &'a u8);\n-   |                 ~~\n-\n error[E0106]: missing lifetime specifier\n   --> $DIR/underscore-lifetime-binders.rs:10:33\n    |"}]}