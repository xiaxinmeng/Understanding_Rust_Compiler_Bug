{"sha": "17bd79f4978f1bf7267b54f86d676eed44af02d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3YmQ3OWY0OTc4ZjFiZjcyNjdiNTRmODZkNjc2ZWVkNDRhZjAyZDA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-02T22:56:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-02T22:56:52Z"}, "message": "Merge #4272\n\n4272: Fix Typos r=jonas-schievink a=lonesometraveler\n\n\n\nCo-authored-by: KENTARO OKUDA <lonesometraveler@mac.com>", "tree": {"sha": "830a8c35d1ce5a3802a18e6e8b238c3d2f8d86d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/830a8c35d1ce5a3802a18e6e8b238c3d2f8d86d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17bd79f4978f1bf7267b54f86d676eed44af02d0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJerfq0CRBK7hj4Ov3rIwAAdHIIACf4Nt/036JrwxJ85K3CetBD\nOs/G9qjbw0BQiYX6cKSZwvTsxj+idZwAF3IaLq4zPUGDfM9jOiXlH2hw4m/9qrMG\nDlnvVaV/U1phYYRYLnF+jYDdpOyxSuz9/cBqI+Tv4G1obyn3d0Ecod4XdtZ8AzuY\n/M9Xs4KqPxH0Cbz3haJ1cR/aWuXuOilPaYMXVDqV/LoYX+SNYx6mIMRFUduXZZ/D\n/mEAHkTaxGcwK+zl/EhKk2jz6hKsObA0mJZBhpo1zp0z3hzi/RetwA5XHwfw7QMt\noin0Mm+hOg37K0LbkoBu/FoujZw2TCP9lHuUq/8DIOMlbp7wplt0LBykPkAjLFU=\n=XNDX\n-----END PGP SIGNATURE-----\n", "payload": "tree 830a8c35d1ce5a3802a18e6e8b238c3d2f8d86d0\nparent 89e1f97515c36ab97bd378d972cabec0feb6d77e\nparent 4f4d0fd9ac2e1d4929bc749cbba0b67406302b6a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1588460212 +0000\ncommitter GitHub <noreply@github.com> 1588460212 +0000\n\nMerge #4272\n\n4272: Fix Typos r=jonas-schievink a=lonesometraveler\n\n\n\nCo-authored-by: KENTARO OKUDA <lonesometraveler@mac.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17bd79f4978f1bf7267b54f86d676eed44af02d0", "html_url": "https://github.com/rust-lang/rust/commit/17bd79f4978f1bf7267b54f86d676eed44af02d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17bd79f4978f1bf7267b54f86d676eed44af02d0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89e1f97515c36ab97bd378d972cabec0feb6d77e", "url": "https://api.github.com/repos/rust-lang/rust/commits/89e1f97515c36ab97bd378d972cabec0feb6d77e", "html_url": "https://github.com/rust-lang/rust/commit/89e1f97515c36ab97bd378d972cabec0feb6d77e"}, {"sha": "4f4d0fd9ac2e1d4929bc749cbba0b67406302b6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4d0fd9ac2e1d4929bc749cbba0b67406302b6a", "html_url": "https://github.com/rust-lang/rust/commit/4f4d0fd9ac2e1d4929bc749cbba0b67406302b6a"}], "stats": {"total": 42, "additions": 21, "deletions": 21}, "files": [{"sha": "c2864bbbc6373622f43e27bc2519c1e3f4812295", "filename": "docs/dev/syntax.md", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/17bd79f4978f1bf7267b54f86d676eed44af02d0/docs%2Fdev%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/17bd79f4978f1bf7267b54f86d676eed44af02d0/docs%2Fdev%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fsyntax.md?ref=17bd79f4978f1bf7267b54f86d676eed44af02d0", "patch": "@@ -64,15 +64,15 @@ struct Token {\n }\n ```\n \n-All the difference bettwen the above sketch and the real implementation are strictly due to optimizations.\n+All the difference between the above sketch and the real implementation are strictly due to optimizations.\n \n Points of note:\n * The tree is untyped. Each node has a \"type tag\", `SyntaxKind`.\n * Interior and leaf nodes are distinguished on the type level.\n * Trivia and non-trivia tokens are not distinguished on the type level.\n * Each token carries its full text.\n * The original text can be recovered by concatenating the texts of all tokens in order.\n-* Accessing a child of particular type (for example, parameter list of a function) generarly involves linerary traversing the children, looking for a specific `kind`.\n+* Accessing a child of particular type (for example, parameter list of a function) generally involves linerary traversing the children, looking for a specific `kind`.\n * Modifying the tree is roughly `O(depth)`.\n   We don't make special efforts to guarantree that the depth is not liner, but, in practice, syntax trees are branchy and shallow.\n * If mandatory (grammar wise) node is missing from the input, it's just missing from the tree.\n@@ -123,7 +123,7 @@ To more compactly store the children, we box *both* interior nodes and tokens, a\n `Either<Arc<Node>, Arc<Token>>` as a single pointer with a tag in the last bit.\n \n To avoid allocating EVERY SINGLE TOKEN on the heap, syntax trees use interning.\n-Because the tree is fully imutable, it's valid to structuraly share subtrees.\n+Because the tree is fully immutable, it's valid to structurally share subtrees.\n For example, in `1 + 1`, there will be a *single* token for `1` with ref count 2; the same goes for the ` ` whitespace token.\n Interior nodes are shared as well (for example in `(1 + 1) * (1 + 1)`).\n \n@@ -134,8 +134,8 @@ Currently, the interner is created per-file, but it will be easy to use a per-th\n \n We use a `TextSize`, a newtyped `u32`, to store the length of the text.\n \n-We currently use `SmolStr`, an small object optimized string to store text.\n-This was mostly relevant *before* we implmented tree interning, to avoid allocating common keywords and identifiers. We should switch to storing text data alongside the interned tokens.\n+We currently use `SmolStr`, a small object optimized string to store text.\n+This was mostly relevant *before* we implemented tree interning, to avoid allocating common keywords and identifiers. We should switch to storing text data alongside the interned tokens.\n \n #### Alternative designs\n \n@@ -162,12 +162,12 @@ Explicit trivia nodes, like in `rowan`, are used by IntelliJ.\n \n ##### Accessing Children\n \n-As noted before, accesing a specific child in the node requires a linear traversal of the children (though we can skip tokens, beacuse the tag is encoded in the pointer itself).\n+As noted before, accessing a specific child in the node requires a linear traversal of the children (though we can skip tokens, because the tag is encoded in the pointer itself).\n It is possible to recover O(1) access with another representation.\n We explicitly store optional and missing (required by the grammar, but not present) nodes.\n That is, we use `Option<Node>` for children.\n We also remove trivia tokens from the tree.\n-This way, each child kind genrerally occupies a fixed position in a parent, and we can use index access to fetch it.\n+This way, each child kind generally occupies a fixed position in a parent, and we can use index access to fetch it.\n The cost is that we now need to allocate space for all not-present optional nodes.\n So, `fn foo() {}` will have slots for visibility, unsafeness, attributes, abi and return type.\n \n@@ -193,7 +193,7 @@ Modeling this with immutable trees is possible, but annoying.\n ### Syntax Nodes\n \n A function green tree is not super-convenient to use.\n-The biggest problem is acessing parents (there are no parent pointers!).\n+The biggest problem is accessing parents (there are no parent pointers!).\n But there are also \"identify\" issues.\n Let's say you want to write a code which builds a list of expressions in a file: `fn collect_exrepssions(file: GreenNode) -> HashSet<GreenNode>`.\n For the input like\n@@ -207,7 +207,7 @@ fn main() {\n }\n ```\n \n-both copies of the `x + 2` expression are representing by equal (and, with interning in mind, actualy the same) green nodes.\n+both copies of the `x + 2` expression are representing by equal (and, with interning in mind, actually the same) green nodes.\n Green trees just can't differentiate between the two.\n \n `SyntaxNode` adds parent pointers and identify semantics to green nodes.\n@@ -285,9 +285,9 @@ They also point to the parent (and, consequently, to the root) with an owning `R\n In other words, one needs *one* arc bump when initiating a traversal.\n \n To get rid of allocations, `rowan` takes advantage of `SyntaxNode: !Sync` and uses a thread-local free list of `SyntaxNode`s.\n-In a typical traversal, you only directly hold a few `SyntaxNode`s at a time (and their ancesstors indirectly), so a free list proportional to the depth of the tree removes all allocations in a typical case.\n+In a typical traversal, you only directly hold a few `SyntaxNode`s at a time (and their ancestors indirectly), so a free list proportional to the depth of the tree removes all allocations in a typical case.\n \n-So, while traversal is not exactly incrementing a pointer, it's still prety cheep: tls + rc bump!\n+So, while traversal is not exactly incrementing a pointer, it's still pretty cheap: TLS + rc bump!\n \n Traversal also yields (cheap) owned nodes, which improves ergonomics quite a bit.\n \n@@ -308,15 +308,15 @@ struct SyntaxData {\n }\n ```\n \n-This allows using true pointer equality for comparision of identities of `SyntaxNodes`.\n-rust-analyzer used to have this design as well, but since we've switch to cursors.\n-The main problem with memoizing the red nodes is that it more than doubles the memory requirenments for fully realized syntax trees.\n+This allows using true pointer equality for comparison of identities of `SyntaxNodes`.\n+rust-analyzer used to have this design as well, but we've since switched to cursors.\n+The main problem with memoizing the red nodes is that it more than doubles the memory requirements for fully realized syntax trees.\n In contrast, cursors generally retain only a path to the root.\n C# combats increased memory usage by using weak references.\n \n ### AST\n \n-`GreenTree`s are untyped and homogeneous, because it makes accomodating error nodes, arbitrary whitespace and comments natural, and because it makes possible to write generic tree traversals.\n+`GreenTree`s are untyped and homogeneous, because it makes accommodating error nodes, arbitrary whitespace and comments natural, and because it makes possible to write generic tree traversals.\n However, when working with a specific node, like a function definition, one would want a strongly typed API.\n \n This is what is provided by the AST layer. AST nodes are transparent wrappers over untyped syntax nodes:\n@@ -397,7 +397,7 @@ impl HasVisbility for FnDef {\n Points of note:\n \n * Like `SyntaxNode`s, AST nodes are cheap to clone pointer-sized owned values.\n-* All \"fields\" are optional, to accomodate incomplete and/or erroneous source code.\n+* All \"fields\" are optional, to accommodate incomplete and/or erroneous source code.\n * It's always possible to go from an ast node to an untyped `SyntaxNode`.\n * It's possible to go in the opposite direction with a checked cast.\n * `enum`s allow modeling of arbitrary intersecting subsets of AST types.\n@@ -437,13 +437,13 @@ impl GreenNodeBuilder {\n }\n ```\n \n-The parser, ultimatelly, needs to invoke the `GreenNodeBuilder`.\n+The parser, ultimately, needs to invoke the `GreenNodeBuilder`.\n There are two principal sources of inputs for the parser:\n   * source text, which contains trivia tokens (whitespace and comments)\n   * token trees from macros, which lack trivia\n \n-Additionaly, input tokens do not correspond 1-to-1 with output tokens.\n-For example, two consequtive `>` tokens might be glued, by the parser, into a single `>>`.\n+Additionally, input tokens do not correspond 1-to-1 with output tokens.\n+For example, two consecutive `>` tokens might be glued, by the parser, into a single `>>`.\n \n For these reasons, the parser crate defines a callback interfaces for both input tokens and output trees.\n The explicit glue layer then bridges various gaps.\n@@ -491,7 +491,7 @@ Syntax errors are not stored directly in the tree.\n The primary motivation for this is that syntax tree is not necessary produced by the parser, it may also be assembled manually from pieces (which happens all the time in refactorings).\n Instead, parser reports errors to an error sink, which stores them in a `Vec`.\n If possible, errors are not reported during parsing and are postponed for a separate validation step.\n-For example, parser accepts visibility modifiers on trait methods, but then a separate tree traversal flags all such visibilites as erroneous.\n+For example, parser accepts visibility modifiers on trait methods, but then a separate tree traversal flags all such visibilities as erroneous.\n \n ### Macros\n \n@@ -501,7 +501,7 @@ Specifically, `TreeSink` constructs the tree in lockstep with draining the origi\n In the process, it records which tokens of the tree correspond to which tokens of the input, by using text ranges to identify syntax tokens.\n The end result is that parsing an expanded code yields a syntax tree and a mapping of text-ranges of the tree to original tokens.\n \n-To deal with precedence in cases like `$expr * 1`, we use special invisible parenthesis, which are explicitelly handled by the parser\n+To deal with precedence in cases like `$expr * 1`, we use special invisible parenthesis, which are explicitly handled by the parser\n \n ### Whitespace & Comments\n "}]}