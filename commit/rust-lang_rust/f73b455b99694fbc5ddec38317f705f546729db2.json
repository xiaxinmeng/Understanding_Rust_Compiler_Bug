{"sha": "f73b455b99694fbc5ddec38317f705f546729db2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3M2I0NTViOTk2OTRmYmM1ZGRlYzM4MzE3ZjcwNWY1NDY3MjlkYjI=", "commit": {"author": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-05-10T03:44:56Z"}, "committer": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-07-03T23:47:38Z"}, "message": "Refactoring", "tree": {"sha": "5d3dcd27d7b1e09dd2b3d3744e4d30c3c4ba33fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d3dcd27d7b1e09dd2b3d3744e4d30c3c4ba33fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f73b455b99694fbc5ddec38317f705f546729db2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f73b455b99694fbc5ddec38317f705f546729db2", "html_url": "https://github.com/rust-lang/rust/commit/f73b455b99694fbc5ddec38317f705f546729db2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f73b455b99694fbc5ddec38317f705f546729db2/comments", "author": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88c8afdddff07adeff4c87431cbe8bc630a36d68", "url": "https://api.github.com/repos/rust-lang/rust/commits/88c8afdddff07adeff4c87431cbe8bc630a36d68", "html_url": "https://github.com/rust-lang/rust/commit/88c8afdddff07adeff4c87431cbe8bc630a36d68"}], "stats": {"total": 231, "additions": 123, "deletions": 108}, "files": [{"sha": "208aa550765a42c5c1e43b6e4b57e0c9d8cb336a", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 106, "deletions": 64, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/f73b455b99694fbc5ddec38317f705f546729db2/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73b455b99694fbc5ddec38317f705f546729db2/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=f73b455b99694fbc5ddec38317f705f546729db2", "patch": "@@ -5,7 +5,7 @@ use if_chain::if_chain;\n \n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n-use rustc_hir::*;\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -69,17 +69,12 @@ declare_clippy_lint! {\n \n declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n \n-/// Returns true iff the given expression is the result of calling Result::ok\n+/// Returns true iff the given expression is the result of calling `Result::ok`\n fn is_result_ok(cx: &LateContext<'_, '_>, expr: &'_ Expr<'_>) -> bool {\n-    if_chain! {\n-        if let ExprKind::MethodCall(ref path, _, &[ref receiver]) = &expr.kind;\n-        if path.ident.name.to_ident_string() == \"ok\";\n-        if match_type(cx, &cx.tables.expr_ty(&receiver), &paths::RESULT);\n-        then {\n-            true\n-        } else {\n-            false\n-        }\n+    if let ExprKind::MethodCall(ref path, _, &[ref receiver]) = &expr.kind {\n+        path.ident.name.to_ident_string() == \"ok\" && match_type(cx, &cx.tables.expr_ty(&receiver), &paths::RESULT)\n+    } else {\n+        false\n     }\n }\n \n@@ -136,82 +131,129 @@ fn contains_return_break_continue<'tcx>(expression: &'tcx Expr<'tcx>) -> bool {\n     recursive_visitor.seen_return_break_continue\n }\n \n+/// Extracts the body of a given arm. If the arm contains only an expression,\n+/// then it returns the expression. Otherwise, it returns the entire block\n+fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n+    if let ExprKind::Block(\n+        Block {\n+            stmts: statements,\n+            expr: Some(expr),\n+            ..\n+        },\n+        _,\n+    ) = &arm.body.kind\n+    {\n+        if let [] = statements {\n+            Some(&expr)\n+        } else {\n+            Some(&arm.body)\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+/// If this is the else body of an if/else expression, then we need to wrap\n+/// it in curcly braces. Otherwise, we don't.\n+fn should_wrap_in_braces(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+    utils::get_enclosing_block(cx, expr.hir_id).map_or(false, |parent| {\n+        if let Some(Expr {\n+            kind:\n+                ExprKind::Match(\n+                    _,\n+                    arms,\n+                    MatchSource::IfDesugar {\n+                        contains_else_clause: true,\n+                    }\n+                    | MatchSource::IfLetDesugar {\n+                        contains_else_clause: true,\n+                    },\n+                ),\n+            ..\n+        }) = parent.expr\n+        {\n+            expr.hir_id == arms[1].body.hir_id\n+        } else {\n+            false\n+        }\n+    })\n+}\n+\n+fn format_option_in_sugg(\n+    cx: &LateContext<'_, '_>,\n+    cond_expr: &Expr<'_>,\n+    parens_around_option: bool,\n+    as_ref: bool,\n+    as_mut: bool,\n+) -> String {\n+    format!(\n+        \"{}{}{}{}\",\n+        if parens_around_option { \"(\" } else { \"\" },\n+        Sugg::hir(cx, cond_expr, \"..\"),\n+        if parens_around_option { \")\" } else { \"\" },\n+        if as_mut {\n+            \".as_mut()\"\n+        } else if as_ref {\n+            \".as_ref()\"\n+        } else {\n+            \"\"\n+        }\n+    )\n+}\n+\n /// If this expression is the option if let/else construct we're detecting, then\n-/// this function returns an OptionIfLetElseOccurence struct with details if\n+/// this function returns an `OptionIfLetElseOccurence` struct with details if\n /// this construct is found, or None if this construct is not found.\n fn detect_option_if_let_else<'a>(cx: &LateContext<'_, 'a>, expr: &'a Expr<'a>) -> Option<OptionIfLetElseOccurence> {\n     if_chain! {\n         if !utils::in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n-        if let ExprKind::Match(let_body, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n+        if let ExprKind::Match(cond_expr, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n         if arms.len() == 2;\n-        // if type_is_option(cx, &cx.tables.expr_ty(let_body).kind);\n-        if !is_result_ok(cx, let_body); // Don't lint on Result::ok because a different lint does it already\n+        if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n         if let PatKind::TupleStruct(struct_qpath, &[inner_pat], _) = &arms[0].pat.kind;\n         if utils::match_qpath(struct_qpath, &paths::OPTION_SOME);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n         if !contains_return_break_continue(arms[0].body);\n         if !contains_return_break_continue(arms[1].body);\n         then {\n-            let (capture_mut, capture_ref, capture_ref_mut) = match bind_annotation {\n-                BindingAnnotation::Unannotated => (false, false, false),\n-                BindingAnnotation::Mutable => (true, false, false),\n-                BindingAnnotation::Ref => (false, true, false),\n-                BindingAnnotation::RefMut => (false, false, true),\n-            };\n-            let some_body = if let ExprKind::Block(Block { stmts: statements, expr: Some(expr), .. }, _)\n-                = &arms[0].body.kind {\n-                if let &[] = &statements {\n-                    expr\n-                } else {\n-                    &arms[0].body\n-                }\n-            } else {\n-                return None;\n-            };\n-            let (none_body, method_sugg) = if let ExprKind::Block(Block { stmts: statements, expr: Some(expr), .. }, _)\n-                = &arms[1].body.kind {\n-                if let &[] = &statements {\n-                    (expr, \"map_or\")\n-                } else {\n-                    (&arms[1].body, \"map_or_else\")\n-                }\n-            } else {\n-                return None;\n+            let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n+            let some_body = extract_body_from_arm(&arms[0])?;\n+            let none_body = extract_body_from_arm(&arms[1])?;\n+            let method_sugg = match &none_body.kind {\n+                ExprKind::Block(..) => \"map_or_else\",\n+                _ => \"map_or\",\n             };\n             let capture_name = id.name.to_ident_string();\n-            let wrap_braces = utils::get_enclosing_block(cx, expr.hir_id).map_or(false, |parent| {\n-                if_chain! {\n-                    if let Some(Expr { kind: ExprKind::Match(\n-                                _,\n-                                arms,\n-                                MatchSource::IfDesugar{contains_else_clause: true}\n-                                    | MatchSource::IfLetDesugar{contains_else_clause: true}),\n-                                .. } ) = parent.expr;\n-                    if expr.hir_id == arms[1].body.hir_id;\n-                    then {\n-                        true\n-                    } else {\n-                        false\n-                    }\n-                }\n-            });\n-            let (parens_around_option, as_ref, as_mut, let_body) = match &let_body.kind {\n+            let wrap_braces = should_wrap_in_braces(cx, expr);\n+            let (as_ref, as_mut) = match &cond_expr.kind {\n+                ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n+                ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n+                _ => (bind_annotation == &BindingAnnotation::Ref, bind_annotation == &BindingAnnotation::RefMut),\n+            };\n+            let parens_around_option = match &cond_expr.kind {\n+                // Put parens around the option expression if not doing so might\n+                // mess up the order of operations.\n                 ExprKind::Call(..)\n                         | ExprKind::MethodCall(..)\n                         | ExprKind::Loop(..)\n                         | ExprKind::Match(..)\n                         | ExprKind::Block(..)\n                         | ExprKind::Field(..)\n                         | ExprKind::Path(_)\n-                    => (false, capture_ref, capture_ref_mut, let_body),\n-                ExprKind::Unary(UnOp::UnDeref, expr) => (false, capture_ref, capture_ref_mut, expr),\n-                ExprKind::AddrOf(_, mutability, expr) => (false, mutability == &Mutability::Not, mutability == &Mutability::Mut, expr),\n-                _ => (true, capture_ref, capture_ref_mut, let_body),\n+                        | ExprKind::Unary(UnOp::UnDeref, _)\n+                        | ExprKind::AddrOf(..)\n+                    => false,\n+                _ => true,\n+            };\n+            let cond_expr = match &cond_expr.kind {\n+                // Pointer dereferencing happens automatically, so we can omit it in the suggestion\n+                ExprKind::Unary(UnOp::UnDeref, expr)|ExprKind::AddrOf(_, _, expr) => expr,\n+                _ => cond_expr,\n             };\n             Some(OptionIfLetElseOccurence {\n-                option: format!(\"{}{}{}{}\", if parens_around_option { \"(\" } else { \"\" }, Sugg::hir(cx, let_body, \"..\"), if parens_around_option { \")\" } else { \"\" }, if as_mut { \".as_mut()\" } else if as_ref { \".as_ref()\" } else { \"\" }),\n-                method_sugg: format!(\"{}\", method_sugg),\n-                some_expr: format!(\"|{}{}{}| {}\", if false { \"ref \" } else { \"\" }, if capture_mut { \"mut \" } else { \"\" }, capture_name, Sugg::hir(cx, some_body, \"..\")),\n+                option: format_option_in_sugg(cx, cond_expr, parens_around_option, as_ref, as_mut),\n+                method_sugg: method_sugg.to_string(),\n+                some_expr: format!(\"|{}{}| {}\", capture_mut, capture_name, Sugg::hir(cx, some_body, \"..\")),\n                 none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir(cx, none_body, \"..\")),\n                 wrap_braces,\n             })"}, {"sha": "dee80d26bd976d93fda3f72fd0ce3a4cd65c3307", "filename": "tests/ui/option_if_let_else.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f73b455b99694fbc5ddec38317f705f546729db2/tests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73b455b99694fbc5ddec38317f705f546729db2/tests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.rs?ref=f73b455b99694fbc5ddec38317f705f546729db2", "patch": "@@ -20,27 +20,15 @@ fn else_if_option(string: Option<&str>) -> Option<(bool, &str)> {\n }\n \n fn unop_bad(string: &Option<&str>, mut num: Option<i32>) {\n-    let _ = if let Some(s) = *string {\n-        s.len()\n-    } else {\n-        0\n-    };\n-    let _ = if let Some(s) = &num {\n-        s\n-    } else {\n-        &0\n-    };\n+    let _ = if let Some(s) = *string { s.len() } else { 0 };\n+    let _ = if let Some(s) = &num { s } else { &0 };\n     let _ = if let Some(s) = &mut num {\n         *s += 1;\n         s\n     } else {\n         &mut 0\n     };\n-    let _ = if let Some(ref s) = num {\n-        s\n-    } else {\n-        &0\n-    };\n+    let _ = if let Some(ref s) = num { s } else { &0 };\n     let _ = if let Some(mut s) = num {\n         s += 1;\n         s"}, {"sha": "7005850efaf833b47f693ae04a7e9cd37722e476", "filename": "tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f73b455b99694fbc5ddec38317f705f546729db2/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f73b455b99694fbc5ddec38317f705f546729db2/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=f73b455b99694fbc5ddec38317f705f546729db2", "patch": "@@ -24,27 +24,17 @@ LL | |     }\n error: use Option::map_or instead of an if let/else\n   --> $DIR/option_if_let_else.rs:23:13\n    |\n-LL |       let _ = if let Some(s) = *string {\n-   |  _____________^\n-LL | |         s.len()\n-LL | |     } else {\n-LL | |         0\n-LL | |     };\n-   | |_____^ help: try: `string.map_or(0, |s| s.len())`\n+LL |     let _ = if let Some(s) = *string { s.len() } else { 0 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.map_or(0, |s| s.len())`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:28:13\n+  --> $DIR/option_if_let_else.rs:24:13\n    |\n-LL |       let _ = if let Some(s) = &num {\n-   |  _____________^\n-LL | |         s\n-LL | |     } else {\n-LL | |         &0\n-LL | |     };\n-   | |_____^ help: try: `num.as_ref().map_or(&0, |s| s)`\n+LL |     let _ = if let Some(s) = &num { s } else { &0 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:33:13\n+  --> $DIR/option_if_let_else.rs:25:13\n    |\n LL |       let _ = if let Some(s) = &mut num {\n    |  _____________^\n@@ -64,18 +54,13 @@ LL |     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:39:13\n+  --> $DIR/option_if_let_else.rs:31:13\n    |\n-LL |       let _ = if let Some(ref s) = num {\n-   |  _____________^\n-LL | |         s\n-LL | |     } else {\n-LL | |         &0\n-LL | |     };\n-   | |_____^ help: try: `num.as_ref().map_or(&0, |s| s)`\n+LL |     let _ = if let Some(ref s) = num { s } else { &0 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:44:13\n+  --> $DIR/option_if_let_else.rs:32:13\n    |\n LL |       let _ = if let Some(mut s) = num {\n    |  _____________^\n@@ -95,7 +80,7 @@ LL |     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:50:13\n+  --> $DIR/option_if_let_else.rs:38:13\n    |\n LL |       let _ = if let Some(ref mut s) = num {\n    |  _____________^\n@@ -115,7 +100,7 @@ LL |     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:59:5\n+  --> $DIR/option_if_let_else.rs:47:5\n    |\n LL | /     if let Some(x) = arg {\n LL | |         let y = x * x;\n@@ -134,7 +119,7 @@ LL |     })\n    |\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:68:13\n+  --> $DIR/option_if_let_else.rs:56:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -157,7 +142,7 @@ LL |     }, |x| x * x * x * x);\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:97:13\n+  --> $DIR/option_if_let_else.rs:85:13\n    |\n LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`"}]}