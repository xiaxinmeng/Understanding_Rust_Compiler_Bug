{"sha": "ca04855a06d1b0c436ee1b931653306ef7ad7e18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMDQ4NTVhMDZkMWIwYzQzNmVlMWI5MzE2NTMzMDZlZjdhZDdlMTg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-11-03T18:44:23Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-11-03T19:08:42Z"}, "message": "resolve: don't speculatively create freevars when resolving\n\nFixes #29522", "tree": {"sha": "a9a750b99ca63a2fef69baeb5957e2b28ce9a8b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9a750b99ca63a2fef69baeb5957e2b28ce9a8b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca04855a06d1b0c436ee1b931653306ef7ad7e18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca04855a06d1b0c436ee1b931653306ef7ad7e18", "html_url": "https://github.com/rust-lang/rust/commit/ca04855a06d1b0c436ee1b931653306ef7ad7e18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca04855a06d1b0c436ee1b931653306ef7ad7e18/comments", "author": null, "committer": null, "parents": [{"sha": "0152a93bb41ba360b41dd62451c2472fc5978d0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0152a93bb41ba360b41dd62451c2472fc5978d0c", "html_url": "https://github.com/rust-lang/rust/commit/0152a93bb41ba360b41dd62451c2472fc5978d0c"}], "stats": {"total": 345, "additions": 194, "deletions": 151}, "files": [{"sha": "882283ba06fd3662cff8fcfd120ddadb3243058e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 149, "deletions": 151, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/ca04855a06d1b0c436ee1b931653306ef7ad7e18/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca04855a06d1b0c436ee1b931653306ef7ad7e18/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ca04855a06d1b0c436ee1b931653306ef7ad7e18", "patch": "@@ -53,7 +53,7 @@ use rustc::front::map as hir_map;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::metadata::csearch;\n-use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n+use rustc::metadata::decoder::{DefLike, DlDef};\n use rustc::middle::def::*;\n use rustc::middle::def_id::DefId;\n use rustc::middle::pat_util::pat_bindings_hygienic;\n@@ -652,6 +652,21 @@ impl Rib {\n     }\n }\n \n+/// A definition along with the index of the rib it was found on\n+struct LocalDef {\n+    ribs: Option<(Namespace, usize)>,\n+    def: Def\n+}\n+\n+impl LocalDef {\n+    fn from_def(def: Def) -> Self {\n+        LocalDef {\n+            ribs: None,\n+            def: def\n+        }\n+    }\n+}\n+\n /// The link from a module up to its nearest parent node.\n #[derive(Clone,Debug)]\n enum ParentLink {\n@@ -1954,116 +1969,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.current_module = orig_module;\n     }\n \n-    /// Wraps the given definition in the appropriate number of `DefUpvar`\n-    /// wrappers.\n-    fn upvarify(&self,\n-                ribs: &[Rib],\n-                def_like: DefLike,\n-                span: Span)\n-                -> Option<DefLike> {\n-        let mut def = match def_like {\n-            DlDef(def) => def,\n-            _ => return Some(def_like)\n-        };\n-        match def {\n-            DefUpvar(..) => {\n-                self.session.span_bug(span,\n-                    &format!(\"unexpected {:?} in bindings\", def))\n-            }\n-            DefLocal(_, node_id) => {\n-                for rib in ribs {\n-                    match rib.kind {\n-                        NormalRibKind => {\n-                            // Nothing to do. Continue.\n-                        }\n-                        ClosureRibKind(function_id) => {\n-                            let prev_def = def;\n-                            let node_def_id = self.ast_map.local_def_id(node_id);\n-\n-                            let mut seen = self.freevars_seen.borrow_mut();\n-                            let seen = seen.entry(function_id).or_insert_with(|| NodeMap());\n-                            if let Some(&index) = seen.get(&node_id) {\n-                                def = DefUpvar(node_def_id, node_id, index, function_id);\n-                                continue;\n-                            }\n-                            let mut freevars = self.freevars.borrow_mut();\n-                            let vec = freevars.entry(function_id)\n-                                              .or_insert_with(|| vec![]);\n-                            let depth = vec.len();\n-                            vec.push(Freevar { def: prev_def, span: span });\n-\n-                            def = DefUpvar(node_def_id, node_id, depth, function_id);\n-                            seen.insert(node_id, depth);\n-                        }\n-                        ItemRibKind | MethodRibKind => {\n-                            // This was an attempt to access an upvar inside a\n-                            // named function item. This is not allowed, so we\n-                            // report an error.\n-                            resolve_error(\n-                                self,\n-                                span,\n-                                ResolutionError::CannotCaptureDynamicEnvironmentInFnItem\n-                            );\n-                            return None;\n-                        }\n-                        ConstantItemRibKind => {\n-                            // Still doesn't deal with upvars\n-                            resolve_error(\n-                                self,\n-                                span,\n-                                ResolutionError::AttemptToUseNonConstantValueInConstant\n-                            );\n-                            return None;\n-                        }\n-                    }\n-                }\n-            }\n-            DefTyParam(..) | DefSelfTy(..) => {\n-                for rib in ribs {\n-                    match rib.kind {\n-                        NormalRibKind | MethodRibKind | ClosureRibKind(..) => {\n-                            // Nothing to do. Continue.\n-                        }\n-                        ItemRibKind => {\n-                            // This was an attempt to use a type parameter outside\n-                            // its scope.\n-\n-                            resolve_error(self,\n-                                          span,\n-                                          ResolutionError::TypeParametersFromOuterFunction);\n-                            return None;\n-                        }\n-                        ConstantItemRibKind => {\n-                            // see #9186\n-                            resolve_error(self, span, ResolutionError::OuterTypeParameterContext);\n-                            return None;\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-        Some(DlDef(def))\n-    }\n-\n-    /// Searches the current set of local scopes and\n-    /// applies translations for closures.\n-    fn search_ribs(&self,\n-                   ribs: &[Rib],\n-                   name: Name,\n-                   span: Span)\n-                   -> Option<DefLike> {\n-        // FIXME #4950: Try caching?\n-\n-        for (i, rib) in ribs.iter().enumerate().rev() {\n-            if let Some(def_like) = rib.bindings.get(&name).cloned() {\n-                return self.upvarify(&ribs[i + 1..], def_like, span);\n-            }\n-        }\n-\n-        None\n-    }\n-\n     /// Searches the current set of local scopes for labels.\n     /// Stops after meeting a closure.\n     fn search_label(&self, name: Name) -> Option<DefLike> {\n@@ -3123,19 +3028,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Try to find a path to an item in a module.\n-        let unqualified_def =\n-                self.resolve_identifier(segments.last().unwrap().identifier,\n-                                        namespace,\n-                                        check_ribs,\n-                                        span);\n+        let unqualified_def = self.resolve_identifier(\n+            segments.last().unwrap().identifier,\n+            namespace, check_ribs);\n \n         if segments.len() <= 1 {\n-            return unqualified_def.map(mk_res);\n+            return unqualified_def\n+                .and_then(|def| self.adjust_local_def(def, span))\n+                .map(|def| {\n+                    PathResolution::new(def, LastMod(AllPublic), path_depth)\n+                });\n         }\n \n         let def = self.resolve_module_relative_path(span, segments, namespace);\n         match (def, unqualified_def) {\n-            (Some((ref d, _)), Some((ref ud, _))) if *d == *ud => {\n+            (Some((ref d, _)), Some(ref ud)) if *d == ud.def => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id, span,\n@@ -3147,31 +3054,119 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         def.map(mk_res)\n     }\n \n-    // Resolve a single identifier.\n+    // Resolve a single identifier\n     fn resolve_identifier(&mut self,\n                           identifier: Ident,\n                           namespace: Namespace,\n-                          check_ribs: bool,\n-                          span: Span)\n-                          -> Option<(Def, LastPrivate)> {\n+                          check_ribs: bool)\n+                          -> Option<LocalDef> {\n         // First, check to see whether the name is a primitive type.\n         if namespace == TypeNS {\n             if let Some(&prim_ty) = self.primitive_type_table\n                                         .primitive_types\n                                         .get(&identifier.name) {\n-                return Some((DefPrimTy(prim_ty), LastMod(AllPublic)));\n+                return Some(LocalDef::from_def(DefPrimTy(prim_ty)));\n             }\n         }\n \n         if check_ribs {\n             if let Some(def) = self.resolve_identifier_in_local_ribs(identifier,\n-                                                                     namespace,\n-                                                                     span) {\n-                return Some((def, LastMod(AllPublic)));\n+                                                                     namespace) {\n+                return Some(def);\n             }\n         }\n \n         self.resolve_item_by_name_in_lexical_scope(identifier.name, namespace)\n+            .map(LocalDef::from_def)\n+    }\n+\n+    // Resolve a local definition, potentially adjusting for closures.\n+    fn adjust_local_def(&self, local_def: LocalDef, span: Span) -> Option<Def> {\n+        let ribs = match local_def.ribs {\n+            Some((TypeNS, i)) => &self.type_ribs[i+1..],\n+            Some((ValueNS, i)) => &self.value_ribs[i+1..],\n+            _ => &[] as &[_]\n+        };\n+        let mut def = local_def.def;\n+        match def {\n+            DefUpvar(..) => {\n+                self.session.span_bug(span,\n+                    &format!(\"unexpected {:?} in bindings\", def))\n+            }\n+            DefLocal(_, node_id) => {\n+                for rib in ribs {\n+                    match rib.kind {\n+                        NormalRibKind => {\n+                            // Nothing to do. Continue.\n+                        }\n+                        ClosureRibKind(function_id) => {\n+                            let prev_def = def;\n+                            let node_def_id = self.ast_map.local_def_id(node_id);\n+\n+                            let mut seen = self.freevars_seen.borrow_mut();\n+                            let seen = seen.entry(function_id).or_insert_with(|| NodeMap());\n+                            if let Some(&index) = seen.get(&node_id) {\n+                                def = DefUpvar(node_def_id, node_id, index, function_id);\n+                                continue;\n+                            }\n+                            let mut freevars = self.freevars.borrow_mut();\n+                            let vec = freevars.entry(function_id)\n+                                              .or_insert_with(|| vec![]);\n+                            let depth = vec.len();\n+                            vec.push(Freevar { def: prev_def, span: span });\n+\n+                            def = DefUpvar(node_def_id, node_id, depth, function_id);\n+                            seen.insert(node_id, depth);\n+                        }\n+                        ItemRibKind | MethodRibKind => {\n+                            // This was an attempt to access an upvar inside a\n+                            // named function item. This is not allowed, so we\n+                            // report an error.\n+                            resolve_error(\n+                                self,\n+                                span,\n+                                ResolutionError::CannotCaptureDynamicEnvironmentInFnItem\n+                            );\n+                            return None;\n+                        }\n+                        ConstantItemRibKind => {\n+                            // Still doesn't deal with upvars\n+                            resolve_error(\n+                                self,\n+                                span,\n+                                ResolutionError::AttemptToUseNonConstantValueInConstant\n+                            );\n+                            return None;\n+                        }\n+                    }\n+                }\n+            }\n+            DefTyParam(..) | DefSelfTy(..) => {\n+                for rib in ribs {\n+                    match rib.kind {\n+                        NormalRibKind | MethodRibKind | ClosureRibKind(..) => {\n+                            // Nothing to do. Continue.\n+                        }\n+                        ItemRibKind => {\n+                            // This was an attempt to use a type parameter outside\n+                            // its scope.\n+\n+                            resolve_error(self,\n+                                          span,\n+                                          ResolutionError::TypeParametersFromOuterFunction);\n+                            return None;\n+                        }\n+                        ConstantItemRibKind => {\n+                            // see #9186\n+                            resolve_error(self, span, ResolutionError::OuterTypeParameterContext);\n+                            return None;\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        return Some(def);\n     }\n \n     // FIXME #4952: Merge me with resolve_name_in_module?\n@@ -3364,38 +3359,41 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_identifier_in_local_ribs(&mut self,\n                                         ident: Ident,\n-                                        namespace: Namespace,\n-                                        span: Span)\n-                                        -> Option<Def> {\n+                                        namespace: Namespace)\n+                                        -> Option<LocalDef> {\n         // Check the local set of ribs.\n-        let search_result = match namespace {\n-            ValueNS => {\n-                let renamed = mtwt::resolve(ident);\n-                self.search_ribs(&self.value_ribs, renamed, span)\n-            }\n-            TypeNS => {\n-                let name = ident.name;\n-                self.search_ribs(&self.type_ribs, name, span)\n-            }\n+        let (name, ribs) = match namespace {\n+            ValueNS => (mtwt::resolve(ident), &self.value_ribs),\n+            TypeNS => (ident.name, &self.type_ribs)\n         };\n \n-        match search_result {\n-            Some(DlDef(def)) => {\n-                debug!(\"(resolving path in local ribs) resolved `{}` to local: {:?}\",\n-                       ident,\n-                       def);\n-                Some(def)\n-            }\n-            Some(DlField) | Some(DlImpl(_)) | None => {\n-                None\n+        for (i, rib) in ribs.iter().enumerate().rev() {\n+            if let Some(def_like) = rib.bindings.get(&name).cloned() {\n+                match def_like {\n+                    DlDef(def) => {\n+                        debug!(\"(resolving path in local ribs) resolved `{}` to {:?} at {}\",\n+                               name, def, i);\n+                        return Some(LocalDef {\n+                            ribs: Some((namespace, i)),\n+                            def: def\n+                        });\n+                    }\n+                    def_like => {\n+                        debug!(\"(resolving path in local ribs) resolved `{}` to pseudo-def {:?}\",\n+                               name, def_like);\n+                        return None;\n+                    }\n+                }\n             }\n         }\n+\n+        None\n     }\n \n     fn resolve_item_by_name_in_lexical_scope(&mut self,\n                                              name: Name,\n                                              namespace: Namespace)\n-                                            -> Option<(Def, LastPrivate)> {\n+                                            -> Option<Def> {\n         // Check the items.\n         let module = self.current_module.clone();\n         match self.resolve_item_in_lexical_scope(module,\n@@ -3409,7 +3407,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         debug!(\"(resolving item path by identifier in lexical \\\n                                  scope) failed to resolve {} after success...\",\n                                  name);\n-                        return None;\n+                        None\n                     }\n                     Some(def) => {\n                         debug!(\"(resolving item path in lexical scope) \\\n@@ -3418,7 +3416,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // This lookup is \"all public\" because it only searched\n                         // for one identifier in the current module (couldn't\n                         // have passed through reexports or anything like that.\n-                        return Some((def, LastMod(AllPublic)));\n+                        Some(def)\n                     }\n                 }\n             }\n@@ -3433,7 +3431,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&*msg))\n                 }\n \n-                return None;\n+                None\n             }\n         }\n     }"}, {"sha": "de7c7aee05530dac2e00f0d7f41dfa8993b5ea22", "filename": "src/test/run-pass/issue-29522.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ca04855a06d1b0c436ee1b931653306ef7ad7e18/src%2Ftest%2Frun-pass%2Fissue-29522.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca04855a06d1b0c436ee1b931653306ef7ad7e18/src%2Ftest%2Frun-pass%2Fissue-29522.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29522.rs?ref=ca04855a06d1b0c436ee1b931653306ef7ad7e18", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that we don't accidentally capture upvars just because their name\n+// occurs in a path\n+\n+fn assert_static<T: 'static>(_t: T) {}\n+\n+mod foo {\n+    pub fn scope() {}\n+}\n+\n+fn main() {\n+    let scope = &mut 0;\n+    assert_static(|| {\n+       foo::scope();\n+    });\n+}"}, {"sha": "071279ae7d818f044555e4fc9935cff20f4d581e", "filename": "src/test/run-pass/resolve-pseudo-shadowing.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ca04855a06d1b0c436ee1b931653306ef7ad7e18/src%2Ftest%2Frun-pass%2Fresolve-pseudo-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca04855a06d1b0c436ee1b931653306ef7ad7e18/src%2Ftest%2Frun-pass%2Fresolve-pseudo-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresolve-pseudo-shadowing.rs?ref=ca04855a06d1b0c436ee1b931653306ef7ad7e18", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that type parameters can't \"shadow\" qualified paths.\n+\n+fn check<Clone>(_c: Clone) {\n+    fn check2() {\n+        <() as std::clone::Clone>::clone(&());\n+    }\n+    check2();\n+}\n+\n+fn main() { check(()); }"}]}